{
    "0shot": [
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for sufficient duration\n    for interval in free_intervals:\n        start, end = interval\n        if end - start >= duration * 60:\n            meeting_start = start\n            meeting_end = meeting_start + duration * 60\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nmichelle_schedule = [\"11:00 to 12:00\"]\nsteven_schedule = [\"9:00 to 9:30\", \"11:30 to 12:00\", \"13:30 to 14:00\", \"15:30 to 16:00\"]\njerry_schedule = [\"9:00 to 9:30\", \"10:00 to 11:00\", \"11:30 to 12:30\", \"13:00 to 14:30\", \"15:30 to 16:00\", \"16:30 to 17:00\"]\n\nparticipants_schedules = [michelle_schedule, steven_schedule, jerry_schedule]\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 1  # in hours\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration))\n```",
            "count": "calendar_scheduling_example_0"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each participant's busy slots to minutes\n    raymond_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    billy_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (12 * 60, 13 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    # Billy prefers no meetings after 15:00\n    billy_preference_end = 15 * 60\n    donald_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 11 * 60),\n        (12 * 60, 13 * 60),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n\n    # Combine all busy slots for checking\n    all_busy = raymond_busy + billy_busy + donald_busy\n\n    # Iterate through possible time slots\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        # Check if the slot is free for everyone\n        conflict = False\n        for busy_start, busy_end in all_busy:\n            if not (slot_end <= busy_start or current_time >= busy_end):\n                conflict = True\n                break\n        # Check Billy's preference\n        if not conflict and slot_end <= billy_preference_end:\n            # Format the time as HH:MM:HH:MM\n            start_hh = current_time // 60\n            start_mm = current_time % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n        current_time += 15  # Check in 15-minute increments\n\n    # If no slot found before 15:00, check after (though not preferred)\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        # Check if the slot is free for everyone\n        conflict = False\n        for busy_start, busy_end in all_busy:\n            if not (slot_end <= busy_start or current_time >= busy_end):\n                conflict = True\n                break\n        if not conflict:\n            # Format the time as HH:MM:HH:MM\n            start_hh = current_time // 60\n            start_mm = current_time % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n        current_time += 15  # Check in 15-minute increments\n\n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_1"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define participants' schedules in minutes\n    # Roy's busy slots: 9:00-9:30, 10:00-10:30, 11:00-11:30, 12:30-13:00\n    roy_busy = [(9*60, 9*60+30), (10*60, 10*60+30), (11*60, 11*60+30), (12*60+30, 13*60)]\n    \n    # Kathryn's busy slots: 9:30-10:00, 16:30-17:00\n    kathryn_busy = [(9*60+30, 10*60), (16*60+30, 17*60)]\n    \n    # Amy's busy slots: 9:00-14:30, 15:00-16:00, 16:30-17:00\n    # Amy prefers not to meet after 15:30, so we treat 15:30-17:00 as busy\n    amy_busy = [(9*60, 14*60+30), (15*60, 17*60)]\n    \n    # Combine all busy slots\n    all_busy = roy_busy + kathryn_busy + amy_busy\n    \n    # Sort busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Check each free slot for a 30-minute window\n    meeting_duration = 30\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Found a suitable slot\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_2"
        },
        {
            "final_program_time": "{9:30:10:30}",
            "expected_time": "{9:30:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define busy intervals in minutes for each participant\n    arthur_busy = [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 12 * 60), (16 * 60, 17 * 60)]\n    michael_busy = [(13 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30)]\n    samantha_busy = [(10 * 60 + 30, 11 * 60), (12 * 60, 15 * 60), (15 * 60 + 30, 17 * 60)]\n\n    # Combine all busy intervals\n    all_busy = arthur_busy + michael_busy + samantha_busy\n    all_busy.sort()\n\n    # Find free intervals by checking gaps between busy intervals\n    free_intervals = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_intervals.append((previous_end, work_end))\n\n    # Check each free interval for a 60-minute slot\n    meeting_duration = 60\n    for start, end in free_intervals:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_3"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define busy times in minutes for each participant\n    donna_busy = [(14 * 60, 14 * 60 + 30), (15 * 60 + 30, 16 * 60)]\n    john_busy = [(11 * 60, 11 * 60 + 30), (16 * 60 + 30, 17 * 60)]\n    billy_busy = [(9 * 60, 10 * 60), (10 * 60 + 30, 14 * 60), (14 * 60 + 30, 17 * 60)]\n    \n    # Combine all busy times\n    all_busy = donna_busy + john_busy + billy_busy\n    \n    # Generate free slots by inverting busy slots within work hours\n    free_slots = []\n    current_time = work_start\n    \n    # Sort all busy times by start time\n    all_busy_sorted = sorted(all_busy, key=lambda x: x[0])\n    \n    for busy_start, busy_end in all_busy_sorted:\n        if busy_start > current_time:\n            free_slots.append((current_time, busy_start))\n        current_time = max(current_time, busy_end)\n    \n    if current_time < work_end:\n        free_slots.append((current_time, work_end))\n    \n    # Check each free slot for a 30-minute window\n    meeting_duration = 30\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Found a suitable slot\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_4"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert blocked times to minutes since 9:00\n    kathryn_blocked = [\n        (9 * 60, 9 * 60 + 30),    # 9:00-9:30\n        (10 * 60 + 30, 11 * 60),  # 10:30-11:00\n        (11 * 60 + 30, 12 * 60),   # 11:30-12:00\n        (13 * 60 + 30, 14 * 60 + 30),  # 13:30-14:30\n        (16 * 60 + 30, 17 * 60)   # 16:30-17:00\n    ]\n    \n    charlotte_blocked = [\n        (12 * 60, 12 * 60 + 30),  # 12:00-12:30\n        (16 * 60, 16 * 60 + 30)    # 16:00-16:30\n    ]\n    \n    lauren_blocked = [\n        (9 * 60, 10 * 60),        # 9:00-10:00\n        (12 * 60, 12 * 60 + 30),  # 12:00-12:30\n        (13 * 60 + 30, 14 * 60 + 30),  # 13:30-14:30\n        (15 * 60, 16 * 60),        # 15:00-16:00\n        (16 * 60 + 30, 17 * 60)   # 16:30-17:00\n    ]\n    \n    # Charlotte doesn't want to meet after 13:30 (13 * 60 + 30)\n    charlotte_cutoff = 13 * 60 + 30\n    \n    # Generate all possible 30-minute slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + 30 <= work_end:\n        slot_end = current_time + 30\n        possible_slots.append((current_time, slot_end))\n        current_time += 30\n    \n    # Check each slot against all constraints\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        \n        # Check Charlotte's cutoff time\n        if slot_start >= charlotte_cutoff:\n            continue\n        \n        # Check Kathryn's availability\n        kathryn_available = True\n        for block in kathryn_blocked:\n            if not (slot_end <= block[0] or slot_start >= block[1]):\n                kathryn_available = False\n                break\n        if not kathryn_available:\n            continue\n        \n        # Check Charlotte's availability\n        charlotte_available = True\n        for block in charlotte_blocked:\n            if not (slot_end <= block[0] or slot_start >= block[1]):\n                charlotte_available = False\n                break\n        if not charlotte_available:\n            continue\n        \n        # Check Lauren's availability\n        lauren_available = True\n        for block in lauren_blocked:\n            if not (slot_end <= block[0] or slot_start >= block[1]):\n                lauren_available = False\n                break\n        if not lauren_available:\n            continue\n        \n        # If all checks passed, return this slot\n        start_h = slot_start // 60\n        start_m = slot_start % 60\n        end_h = slot_end // 60\n        end_m = slot_end % 60\n        return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_5"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration):\n    # Convert all time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = map(time_to_minutes, work_hours)\n    busy_slots = []\n    \n    for busy_times in participants_busy_times:\n        for start, end in busy_times:\n            busy_start = time_to_minutes(start)\n            busy_end = time_to_minutes(end)\n            busy_slots.append((busy_start, busy_end))\n    \n    # Sort all busy slots by start time\n    busy_slots.sort()\n    \n    # Find all free slots between work hours by merging busy slots\n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in busy_slots:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Check each free slot for availability of duration\n    for start, end in free_slots:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' busy times in HH:MM format\nthomas_busy = []\ndylan_busy = [(\"10:30\", \"11:00\"), (\"13:30\", \"14:00\")]\njerry_busy = [(\"09:00\", \"11:00\"), (\"11:30\", \"14:30\"), (\"16:00\", \"17:00\")]\n\nparticipants_busy_times = [thomas_busy, dylan_busy, jerry_busy]\nwork_hours = (\"9:00\", \"17:00\")\nduration = 60  # minutes\n\nproposed_time = find_meeting_time(participants_busy_times, work_hours, duration)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_6"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert schedules to minutes\n    heather_blocked = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 11 * 60),\n        (13 * 60, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    zachary_blocked = [\n        (9 * 60, 10 * 60 + 30),\n        (11 * 60, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 16 * 60 + 30)\n    ]\n    \n    # Zachary's preference: not after 14:00 (14 * 60)\n    zachary_preference_end = 14 * 60\n    \n    # Generate all possible 30-minute slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + 30 <= work_end:\n        slot_start = current_time\n        slot_end = current_time + 30\n        possible_slots.append((slot_start, slot_end))\n        current_time += 30\n    \n    # Check each slot against constraints\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        \n        # Check Heather's availability\n        heather_available = True\n        for block in heather_blocked:\n            block_start, block_end = block\n            if not (slot_end <= block_start or slot_start >= block_end):\n                heather_available = False\n                break\n        \n        if not heather_available:\n            continue\n        \n        # Check Zachary's availability and preference\n        zachary_available = True\n        for block in zachary_blocked:\n            block_start, block_end = block\n            if not (slot_end <= block_start or slot_start >= block_end):\n                zachary_available = False\n                break\n        \n        if not zachary_available:\n            continue\n        \n        # Zachary's preference: not after 14:00\n        if slot_start >= zachary_preference_end:\n            continue\n        \n        # Nicholas is always available\n        \n        # If all checks passed, return this slot\n        return f\"{slot_start // 60:02d}:{slot_start % 60:02d}:{slot_end // 60:02d}:{slot_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_7"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:11:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Check for the first available slot that can fit the meeting\n    duration_minutes = duration * 60\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules\nadam_schedule = [\n    \"10:00 to 10:30\",\n    \"12:30 to 13:00\",\n    \"13:30 to 14:30\"\n]\n\njerry_schedule = [\n    \"09:00 to 09:30\",\n    \"12:00 to 12:30\",\n    \"15:00 to 16:00\"\n]\n\nmatthew_schedule = [\n    \"09:30 to 11:00\",\n    \"11:30 to 12:30\",\n    \"13:00 to 14:00\",\n    \"14:30 to 17:00\"\n]\n\n# Combine all schedules\nparticipants_schedules = [adam_schedule, jerry_schedule, matthew_schedule]\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, \"09:00\", \"17:00\", 0.5)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_8"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration_minutes):\n    # Convert work hours and schedules to minutes since start of day\n    work_start, work_end = work_hours\n    work_start_min = work_start[0] * 60 + work_start[1]\n    work_end_min = work_end[0] * 60 + work_end[1]\n    \n    # Initialize the free slots for all participants\n    free_slots = []\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start = busy[0][0] * 60 + busy[0][1]\n            end = busy[1][0] * 60 + busy[1][1]\n            busy_slots.append((start, end))\n        # Sort busy slots by start time\n        busy_slots.sort()\n        # Calculate free slots between busy times and work hours\n        free = []\n        prev_end = work_start_min\n        for busy_start, busy_end in busy_slots:\n            if busy_start > prev_end:\n                free.append((prev_end, busy_start))\n            prev_end = max(prev_end, busy_end)\n        if prev_end < work_end_min:\n            free.append((prev_end, work_end_min))\n        free_slots.append(free)\n    \n    # Find overlapping free slots across all participants\n    common_free_slots = free_slots[0]\n    for free in free_slots[1:]:\n        new_common = []\n        i = j = 0\n        while i < len(common_free_slots) and j < len(free):\n            start1, end1 = common_free_slots[i]\n            start2, end2 = free[j]\n            # Find the overlap\n            overlap_start = max(start1, start2)\n            overlap_end = min(end1, end2)\n            if overlap_start < overlap_end:\n                new_common.append((overlap_start, overlap_end))\n            # Move the pointer which ends first\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free_slots = new_common\n    \n    # Find the first slot that can fit the meeting duration\n    for slot in common_free_slots:\n        start, end = slot\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No suitable time found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours = ((9, 0), (17, 0))\n\n# Define participants' schedules\ndiane_schedule = [\n    ((9, 0), (9, 30)),\n    ((12, 0), (12, 30)),\n    ((14, 30), (15, 30))\n]\nkelly_schedule = [\n    ((9, 30), (10, 0)),\n    ((10, 30), (11, 0))\n]\ndeborah_schedule = [\n    ((9, 0), (9, 30)),\n    ((10, 0), (14, 0)),\n    ((14, 30), (17, 0))\n]\n\nparticipants_schedules = [diane_schedule, kelly_schedule, deborah_schedule]\nduration_minutes = 30\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration_minutes))\n```",
            "count": "calendar_scheduling_example_9"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each participant's busy slots to minutes\n    diana_busy = [\n        (11 * 60 + 30, 12 * 60),    # 11:30-12:00\n        (13 * 60, 13 * 60 + 30)     # 13:00-13:30\n    ]\n    ethan_busy = []  # No meetings\n    janet_busy = [\n        (9 * 60, 10 * 60),          # 9:00-10:00\n        (12 * 60 + 30, 13 * 60),    # 12:30-13:00\n        (14 * 60, 15 * 60),         # 14:00-15:00\n        (15 * 60 + 30, 17 * 60)     # 15:30-17:00\n    ]\n    # Janet's constraint: not after 12:00 (i.e., before 12:00)\n    janet_max_time = 12 * 60\n\n    # Combine all busy slots for all participants\n    all_busy = diana_busy + ethan_busy + janet_busy\n\n    # Generate available slots by finding gaps in busy slots\n    all_busy_sorted = sorted(all_busy, key=lambda x: x[0])\n    available_slots = []\n    prev_end = work_start\n\n    for start, end in all_busy_sorted:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Filter slots that are >= meeting_duration and respect Janet's constraint\n    valid_slots = []\n    for slot in available_slots:\n        start, end = slot\n        # Ensure slot is within Janet's max time (before 12:00)\n        if start >= janet_max_time:\n            continue\n        if end - start >= meeting_duration:\n            valid_slots.append((start, end))\n\n    # Select the earliest possible slot\n    if valid_slots:\n        chosen_slot = valid_slots[0]\n        meeting_start = chosen_slot[0]\n        meeting_end = meeting_start + meeting_duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No valid time slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_10"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time strings to minutes since 9:00 (work_hours_start)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - work_hours_start) * 60 + mm\n    \n    # Convert work hours to minutes range\n    start_min = time_to_minutes(f\"{work_hours_start:02d}:00\")\n    end_min = time_to_minutes(f\"{work_hours_end:02d}:00\")\n    \n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy_intervals in participants_busy:\n        for interval in busy_intervals:\n            start, end = interval.split(' to ')\n            start_m = time_to_minutes(start)\n            end_m = time_to_minutes(end)\n            all_busy.append((start_m, end_m))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Find available slots between merged busy intervals\n    available_slots = []\n    prev_end = start_min\n    for start, end in merged_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < end_min:\n        available_slots.append((prev_end, end_min))\n    \n    # Check each available slot for sufficient duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_minutes:\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = work_hours_start + (minutes // 60)\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            \n            meeting_start = minutes_to_time(slot_start)\n            meeting_end = minutes_to_time(slot_start + duration_minutes)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No available slot found\"\n\n# Define participants' busy times\nparticipants_busy = [\n    [\"9:30 to 10:00\", \"10:30 to 11:00\", \"12:30 to 13:00\", \"14:30 to 15:00\", \"16:00 to 17:00\"],  # Alexander\n    [\"9:00 to 9:30\", \"11:30 to 12:30\", \"13:00 to 14:30\"],  # Elizabeth\n    [\"9:00 to 14:30\", \"15:30 to 17:00\"],  # Walter\n]\n\n# Define work hours and meeting duration\nwork_hours_start = 9\nwork_hours_end = 17\nduration_minutes = 30\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, work_hours_start, work_hours_end, duration_minutes))\n```",
            "count": "calendar_scheduling_example_11"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    duration = 60        # 1 hour in minutes\n\n    # Convert each participant's busy slots to minutes since 9:00\n    debra_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60, 13 * 60),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    kevin_busy = [\n        (9 * 60, 12 * 60),\n        (14 * 60, 17 * 60)\n    ]\n\n    # Combine all busy slots and sort them\n    all_busy = debra_busy + kevin_busy\n    all_busy.sort()\n\n    # Find the earliest available slot\n    previous_end = work_start\n    for start, end in all_busy:\n        if start > previous_end and start - previous_end >= duration:\n            meeting_start = previous_end\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n        previous_end = max(previous_end, end)\n\n    # Check after the last busy slot\n    if work_end - previous_end >= duration:\n        meeting_start = previous_end\n        meeting_end = meeting_start + duration\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_12"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    gerald_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (13 * 60, 14 * 60),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n    # Gerald prefers no meetings before 13:00\n    gerald_preferred_start = 13 * 60\n\n    barbara_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n\n    # Roy is free all day, so no constraints\n\n    # Generate all possible slots considering work hours and duration\n    possible_slots = []\n    current_start = max(work_start, gerald_preferred_start)\n    while current_start + meeting_duration <= work_end:\n        possible_slots.append((current_start, current_start + meeting_duration))\n        current_start += 15  # Check every 15 minutes for efficiency\n\n    # Check each slot against everyone's busy times\n    for slot_start, slot_end in possible_slots:\n        # Check Gerald's availability\n        gerald_available = True\n        for busy_start, busy_end in gerald_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                gerald_available = False\n                break\n        if not gerald_available:\n            continue\n\n        # Check Barbara's availability\n        barbara_available = True\n        for busy_start, busy_end in barbara_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                barbara_available = False\n                break\n        if not barbara_available:\n            continue\n\n        # Roy is always available, so if we're here, the slot works\n        # Format the time as HH:MM:HH:MM\n        start_hh = slot_start // 60\n        start_mm = slot_start % 60\n        end_hh = slot_end // 60\n        end_mm = slot_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"  # Shouldn't happen per problem statement\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_13"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert schedules to minutes\n    # Brandon's schedule: 13:00-14:00, 15:30-16:00, 16:30-17:00\n    brandon_busy = [\n        (13 * 60, 14 * 60),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    # Brandon prefers no meetings before 14:30\n    brandon_preference_start = 14 * 60 + 30\n\n    # Jerry has no meetings\n    jerry_busy = []\n\n    # Bradley's schedule: 9:00-11:30, 12:00-15:00, 16:00-16:30\n    bradley_busy = [\n        (9 * 60, 11 * 60 + 30),\n        (12 * 60, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n\n    # Combine all busy times and sort\n    all_busy = brandon_busy + jerry_busy + bradley_busy\n    all_busy.sort()\n\n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n\n    for start, end in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n\n    if work_end > prev_end:\n        available_slots.append((prev_end, work_end))\n\n    # Filter slots that meet duration and Brandon's preference\n    valid_slots = []\n    for slot_start, slot_end in available_slots:\n        if slot_start >= brandon_preference_start and (slot_end - slot_start) >= meeting_duration:\n            valid_slots.append((slot_start, slot_end))\n\n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_14"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Convert schedules to minutes\n    joyce_busy = [\n        (11 * 60, 11 * 60 + 30),\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 16 * 60 + 30)\n    ]\n    \n    alexander_busy = [\n        (9 * 60, 11 * 60),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Christine's constraint: not before 12:00\n    christine_constraint = 12 * 60\n    \n    # Duration of the meeting\n    duration = 30\n    \n    # Generate all possible slots\n    possible_slots = []\n    current_time = max(work_start, christine_constraint)\n    \n    while current_time + duration <= work_end:\n        # Check if the slot is free for all participants\n        joyce_free = all(not (start <= current_time < end or start < current_time + duration <= end) \n                         for start, end in joyce_busy)\n        alexander_free = all(not (start <= current_time < end or start < current_time + duration <= end) \n                             for start, end in alexander_busy)\n        \n        if joyce_free and alexander_free:\n            possible_slots.append((current_time, current_time + duration))\n        \n        current_time += 30  # Check every 30 minutes\n    \n    if possible_slots:\n        # Select the first available slot\n        start, end = possible_slots[0]\n        # Convert back to HH:MM format\n        start_hh = start // 60\n        start_mm = start % 60\n        end_hh = end // 60\n        end_mm = end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_15"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy_intervals in participants_busy.values():\n        for interval in busy_intervals:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_intervals.append((previous_end, work_end))\n    \n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' busy intervals\nparticipants_busy = {\n    \"Scott\": [\n        \"09:30 to 10:30\",\n        \"13:30 to 14:00\",\n        \"14:30 to 15:00\",\n        \"15:30 to 16:00\",\n        \"16:30 to 17:00\"\n    ],\n    \"Gabriel\": [],\n    \"Christine\": [\n        \"09:00 to 10:00\",\n        \"10:30 to 12:30\",\n        \"13:00 to 17:00\"\n    ]\n}\n\n# Define work hours and meeting duration\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_16"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert blocked times to minutes since midnight\n    margaret_blocked = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    donna_blocked = [\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    helen_blocked = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 11 * 60 + 30),\n        (13 * 60, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    helen_no_meet_after = 13 * 60 + 30  # 13:30\n\n    meeting_duration = 30  # minutes\n\n    # Generate all possible time slots\n    possible_slots = []\n    current_time = work_start\n\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        # Check if the slot is before Helen's no-meet-after time\n        if slot_end <= helen_no_meet_after:\n            # Check if all participants are free\n            margaret_free = all(not (start <= current_time < end or start < slot_end <= end) for start, end in margaret_blocked)\n            donna_free = all(not (start <= current_time < end or start < slot_end <= end) for start, end in donna_blocked)\n            helen_free = all(not (start <= current_time < end or start < slot_end <= end) for start, end in helen_blocked)\n            \n            if margaret_free and donna_free and helen_free:\n                possible_slots.append((current_time, slot_end))\n        \n        current_time += 15  # Check every 15 minutes for efficiency\n\n    if possible_slots:\n        # Return the first available slot\n        start, end = possible_slots[0]\n        # Format the output as HH:MM:HH:MM\n        start_hh = start // 60\n        start_mm = start % 60\n        end_hh = end // 60\n        end_mm = end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_17"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Billy's busy slots in minutes since midnight\n    billy_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Patricia's busy slots in minutes since midnight\n    patricia_busy = [\n        (9 * 60, 12 * 60 + 30),\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Billy's preference to avoid meetings after 15:30\n    billy_preference_end = 15 * 60 + 30\n    \n    # Generate all possible 30-minute slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 15  # check every 15 minutes for flexibility\n    \n    # Check each slot against all constraints\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        \n        # Check Billy's busy slots\n        billy_available = True\n        for busy_start, busy_end in billy_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                billy_available = False\n                break\n        \n        # Check Patricia's busy slots\n        patricia_available = True\n        for busy_start, busy_end in patricia_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                patricia_available = False\n                break\n        \n        # Check Billy's preference\n        if slot_start >= billy_preference_end:\n            billy_available = False\n        \n        # If all are available, return the slot\n        if billy_available and patricia_available:\n            # Convert minutes back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_18"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert all time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 9:00 (0 minutes)\n\n    # Convert work hours to minutes\n    work_start = time_to_minutes(work_hours[0])\n    work_end = time_to_minutes(work_hours[1])\n\n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy_intervals in participants_busy:\n        for interval in busy_intervals:\n            start = time_to_minutes(interval[0])\n            end = time_to_minutes(interval[1])\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Find available slots between merged busy intervals\n    available_slots = []\n    prev_end = work_start\n    for start, end in merged_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Check each available slot for a duration that fits\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                total_minutes = minutes + 540  # Add back 540 minutes (9:00)\n                hh = total_minutes // 60\n                mm = total_minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            start_time = minutes_to_time(meeting_start)\n            end_time = minutes_to_time(meeting_end)\n            return f\"{start_time}:{end_time}\"\n    return \"No available slot found\"\n\n# Define the participants' busy times\nparticipants_busy = [\n    [(\"10:00\", \"10:30\"), (\"13:00\", \"13:30\"), (\"14:30\", \"15:00\"), (\"16:00\", \"16:30\")],  # Stephen\n    [(\"09:00\", \"09:30\"), (\"10:00\", \"10:30\"), (\"13:30\", \"14:30\"), (\"15:00\", \"16:00\")],  # Edward\n    [(\"09:00\", \"11:30\"), (\"12:30\", \"13:00\"), (\"13:30\", \"15:30\"), (\"16:00\", \"17:00\")],  # Angela\n]\n\n# Define work hours and meeting duration\nwork_hours = (\"09:00\", \"17:00\")\nduration = 60  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_19"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define busy slots for each participant in minutes\n    ralph_busy = [(13 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60)]\n    peter_busy = [(9 * 60, 9 * 60 + 30), (11 * 60, 13 * 60), (16 * 60, 16 * 60 + 30)]\n    daniel_busy = [(9 * 60, 10 * 60), (10 * 60 + 30, 15 * 60 + 30), (16 * 60, 17 * 60)]\n    \n    # Daniel's preference: avoid meetings after 13:30 (13 * 60 + 30 = 810 minutes)\n    daniel_preference = 13 * 60 + 30\n    \n    # Combine all busy slots and sort them\n    all_busy = ralph_busy + peter_busy + daniel_busy\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Check each free slot for a 30-minute meeting that fits Daniel's preference\n    meeting_duration = 30\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        # The slot must be at least 30 minutes\n        if slot_end - slot_start >= meeting_duration:\n            # The meeting must end by 13:30 to fit Daniel's preference\n            if slot_start + meeting_duration <= daniel_preference:\n                # Check if all participants are free during this slot\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                # Check Ralph's availability\n                ralph_free = True\n                for r_start, r_end in ralph_busy:\n                    if not (meeting_end <= r_start or meeting_start >= r_end):\n                        ralph_free = False\n                        break\n                # Check Peter's availability\n                peter_free = True\n                for p_start, p_end in peter_busy:\n                    if not (meeting_end <= p_start or meeting_start >= p_end):\n                        peter_free = False\n                        break\n                # Check Daniel's availability\n                daniel_free = True\n                for d_start, d_end in daniel_busy:\n                    if not (meeting_end <= d_start or meeting_start >= d_end):\n                        daniel_free = False\n                        break\n                if ralph_free and peter_free and daniel_free:\n                    # Format the time as HH:MM:HH:MM\n                    start_hh = meeting_start // 60\n                    start_mm = meeting_start % 60\n                    end_hh = meeting_end // 60\n                    end_mm = meeting_end % 60\n                    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_20"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:10:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration):\n    # Convert all time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 9:00 (0 minutes)\n    \n    # Convert work hours to minutes\n    work_start, work_end = map(time_to_minutes, work_hours.split(':'))\n    \n    # Flatten all busy times and sort them\n    all_busy = []\n    for busy_times in participants_busy_times.values():\n        for start, end in busy_times:\n            all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    all_busy.sort()\n    \n    # Find available slots\n    available = []\n    prev_end = 0\n    for start, end in all_busy:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n    \n    # Check for a slot that fits the duration\n    for slot_start, slot_end in available:\n        if slot_end - slot_start >= duration:\n            return slot_start, slot_start + duration\n    \n    return None\n\n# Participants' busy times in HH:MM format\nparticipants_busy_times = {\n    'Bobby': [],\n    'Scott': [('11:30', '12:00'), ('15:30', '16:00')],\n    'Kimberly': [('11:00', '12:00'), ('12:30', '13:00'), ('13:30', '14:00'), ('14:30', '15:00'), ('15:30', '17:00')],\n}\n\nwork_hours = '9:00:17:00'\nmeeting_duration = 60  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours, meeting_duration)\n\n# Convert back to HH:MM format\ndef minutes_to_time(minutes):\n    total_minutes = minutes + 540  # Add back 540 minutes (9:00)\n    hh = total_minutes // 60\n    mm = total_minutes % 60\n    return f\"{hh:02d}:{mm:02d}\"\n\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{minutes_to_time(start)}:{minutes_to_time(end)}\")\nelse:\n    print(\"No available time slot found.\")\n```",
            "count": "calendar_scheduling_example_21"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find merged busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots\n    available = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n    \n    # Check each available slot for duration\n    for slot in available:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\ntheresa_schedule = [\n    \"9:00 to 9:30\",\n    \"12:30 to 13:30\",\n    \"14:00 to 15:00\",\n    \"16:30 to 17:00\"\n]\n\ncharles_schedule = [\n    \"10:00 to 10:30\",\n    \"11:30 to 12:30\",\n    \"14:00 to 15:30\"\n]\n\nbetty_schedule = [\n    \"9:00 to 10:30\",\n    \"12:00 to 12:30\",\n    \"13:00 to 14:00\",\n    \"15:00 to 16:00\"\n]\n\nparticipants_schedules = [theresa_schedule, charles_schedule, betty_schedule]\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 60  # 1 hour\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_22"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert all time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    # Parse work hours\n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n\n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy_intervals in participants_busy.values():\n        for interval in busy_intervals:\n            start, end = interval.split(' to ')\n            all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n\n    # Sort all busy intervals by start time\n    all_busy.sort()\n\n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n\n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No suitable time found\"\n\n# Define participants' busy times\nparticipants_busy = {\n    'Billy': ['11:30 to 12:00', '13:00 to 15:00', '16:00 to 16:30'],\n    'Maria': ['9:00 to 9:30', '10:00 to 10:30', '13:00 to 13:30', '14:00 to 14:30'],\n    'William': ['9:30 to 10:00', '12:00 to 12:30', '13:30 to 15:00', '15:30 to 17:00']\n}\n\n# Define work hours and meeting duration\nwork_hours = '9:00 to 17:00'\nmeeting_duration = 60  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, work_hours, meeting_duration))\n```",
            "count": "calendar_scheduling_example_23"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define meeting duration\n    duration = 30  # minutes\n    \n    # Define Brenda's busy times in minutes since midnight\n    brenda_busy = [\n        (9 * 60 + 30, 10 * 60),      # 9:30-10:00\n        (11 * 60 + 30, 12 * 60 + 30), # 11:30-12:30\n        (14 * 60, 16 * 60 + 30)       # 14:00-16:30\n    ]\n    \n    # Benjamin's constraint: doesn't want to meet after 9:30\n    benjamin_constraint = 9 * 60 + 30  # 9:30 in minutes\n    \n    # Find all possible slots that fit the duration within work hours\n    possible_slots = []\n    \n    # Check the slot before Benjamin's constraint\n    slot_start = work_start\n    slot_end = slot_start + duration\n    \n    if slot_end <= benjamin_constraint:\n        # Check if Brenda is free during this slot\n        brenda_free = True\n        for busy_start, busy_end in brenda_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                brenda_free = False\n                break\n        if brenda_free:\n            possible_slots.append((slot_start, slot_end))\n    \n    # If no slot found before 9:30, check other constraints (though in this case, it's not needed)\n    if not possible_slots:\n        # This part is just for completeness; the task states a solution exists\n        pass\n    \n    # Format the output\n    if possible_slots:\n        start_hour = possible_slots[0][0] // 60\n        start_min = possible_slots[0][0] % 60\n        end_hour = possible_slots[0][1] // 60\n        end_min = possible_slots[0][1] % 60\n        print(f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\")\n    else:\n        print(\"No valid slot found\")  # Shouldn't happen per task description\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_24"
        },
        {
            "final_program_time": "{13:30:14:30}",
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define busy intervals in minutes for each participant\n    anthony_busy = [\n        (9 * 60 + 30, 10 * 60),      # 9:30-10:00\n        (12 * 60, 13 * 60),           # 12:00-13:00\n        (16 * 60, 16 * 60 + 30)       # 16:00-16:30\n    ]\n    pamela_busy = [\n        (9 * 60 + 30, 10 * 60),       # 9:30-10:00\n        (16 * 60 + 30, 17 * 60)       # 16:30-17:00\n    ]\n    zachary_busy = [\n        (9 * 60, 11 * 60 + 30),       # 9:00-11:30\n        (12 * 60, 12 * 60 + 30),      # 12:00-12:30\n        (13 * 60, 13 * 60 + 30),      # 13:00-13:30\n        (14 * 60 + 30, 15 * 60),      # 14:30-15:00\n        (16 * 60, 17 * 60)            # 16:00-17:00\n    ]\n\n    # Pamela's constraint: no meetings after 14:30\n    pamela_constraint = 14 * 60 + 30  # 14:30 in minutes\n\n    # Combine all busy intervals and sort them\n    all_busy = anthony_busy + pamela_busy + zachary_busy\n    all_busy.sort()\n\n    # Find the earliest available 1-hour slot\n    current_time = work_start\n    meeting_duration = 60  # 1 hour\n\n    for start, end in all_busy:\n        if start > current_time:\n            # Check if the slot is long enough and before Pamela's constraint\n            if (start - current_time) >= meeting_duration and (current_time + meeting_duration) <= pamela_constraint:\n                # Check if all participants are free during this slot\n                if (all(not (current_time < busy_end and current_time + meeting_duration > busy_start)\n                        for busy_start, busy_end in anthony_busy) and\n                    all(not (current_time < busy_end and current_time + meeting_duration > busy_start)\n                        for busy_start, busy_end in pamela_busy) and\n                    all(not (current_time < busy_end and current_time + meeting_duration > busy_start)\n                        for busy_start, busy_end in zachary_busy)):\n                    # Format the time as HH:MM:HH:MM\n                    return f\"{current_time // 60:02d}:{current_time % 60:02d}:{(current_time + meeting_duration) // 60:02d}:{(current_time + meeting_duration) % 60:02d}\"\n        current_time = max(current_time, end)\n\n    # Check after the last busy interval\n    if (current_time + meeting_duration) <= work_end and (current_time + meeting_duration) <= pamela_constraint:\n        # Check if all participants are free during this slot\n        if (all(not (current_time < busy_end and current_time + meeting_duration > busy_start)\n                for busy_start, busy_end in anthony_busy) and\n            all(not (current_time < busy_end and current_time + meeting_duration > busy_start)\n                for busy_start, busy_end in pamela_busy) and\n            all(not (current_time < busy_end and current_time + meeting_duration > busy_start)\n                for busy_start, busy_end in zachary_busy)):\n            # Format the time as HH:MM:HH:MM\n            return f\"{current_time // 60:02d}:{current_time % 60:02d}:{(current_time + meeting_duration) // 60:02d}:{(current_time + meeting_duration) % 60:02d}\"\n\n    return \"No available time slot found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_25"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:30:16:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(schedules, duration, work_start, work_end):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Generate busy intervals for all participants\n    busy_intervals = []\n    for schedule in schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start_min\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        available_slots.append((prev_end, work_end_min))\n    \n    # Find the first available slot that can fit the meeting duration\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            \n            meeting_start = minutes_to_time(slot_start)\n            meeting_end = minutes_to_time(slot_start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return None\n\n# Define the schedules and constraints\nschedules = [\n    [],  # Katherine is free all day\n    [],  # Nicole is free all day\n    [\"9:00:10:00\", \"10:30:11:30\", \"12:00:15:30\", \"16:30:17:00\"]  # Kevin's busy times\n]\nduration = 60  # 1 hour in minutes\nwork_start = \"9:00\"\nwork_end = \"17:00\"\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(schedules, duration, work_start, work_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_26"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Find the earliest free interval that can fit the meeting\n    duration = duration_minutes\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_end = start + duration\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules\njesse_schedule = [\"10:00 to 10:30\", \"15:30 to 16:00\"]\nkathryn_schedule = []  # Wide open\nmegan_schedule = [\"10:30 to 11:00\", \"11:30 to 12:30\", \"13:30 to 14:30\", \"15:00 to 16:30\"]\n\n# Combine all schedules\nparticipants_schedules = [jesse_schedule, kathryn_schedule, megan_schedule]\n\n# Find the earliest meeting time\nmeeting_time = find_meeting_time(participants_schedules=participants_schedules,\n                                work_hours_start=\"9:00\",\n                                work_hours_end=\"17:00\",\n                                duration_minutes=30)\n\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_27"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the busy slots for all participants\n    busy_slots = []\n    for schedule in participants_schedules:\n        personal_busy = []\n        for slot in schedule:\n            start, end = map(time_to_minutes, slot.split(' to '))\n            personal_busy.append((start, end))\n        busy_slots.append(personal_busy)\n    \n    # Find all free slots for each participant\n    free_slots_per_participant = []\n    for personal_busy in busy_slots:\n        free_slots = []\n        previous_end = work_start\n        for start, end in sorted(personal_busy, key=lambda x: x[0]):\n            if start > previous_end:\n                free_slots.append((previous_end, start))\n            previous_end = max(previous_end, end)\n        if previous_end < work_end:\n            free_slots.append((previous_end, work_end))\n        free_slots_per_participant.append(free_slots)\n    \n    # Find overlapping free slots across all participants\n    common_free_slots = free_slots_per_participant[0]\n    for free_slots in free_slots_per_participant[1:]:\n        new_common_slots = []\n        i = j = 0\n        while i < len(common_free_slots) and j < len(free_slots):\n            start1, end1 = common_free_slots[i]\n            start2, end2 = free_slots[j]\n            overlap_start = max(start1, start2)\n            overlap_end = min(end1, end2)\n            if overlap_start < overlap_end:\n                new_common_slots.append((overlap_start, overlap_end))\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free_slots = new_common_slots\n    \n    # Find the earliest slot that fits the duration\n    duration = duration_minutes\n    for start, end in common_free_slots:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"13:00 to 13:30\", \"16:00 to 16:30\"],  # Brittany\n    [],                                    # Emily\n    [\"9:00 to 11:00\", \"11:30 to 14:30\", \"15:00 to 17:00\"]  # Doris\n]\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_28"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = work_hours.split(' to ')\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = busy.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            busy_intervals.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                new_end = max(last_end, current_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append(interval)\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start_min\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        available_slots.append((prev_end, work_end_min))\n    \n    # Check for a slot that can fit the duration\n    duration_min = duration * 60\n    for start, end in available_slots:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nmadison_schedule = [\"9:30 to 10:00\", \"11:30 to 12:00\"]\ndiana_schedule = [\"11:00 to 11:30\", \"13:00 to 13:30\"]\nshirley_schedule = [\"9:00 to 12:00\", \"13:30 to 15:00\", \"15:30 to 17:00\"]\n\nparticipants_schedules = [madison_schedule, diana_schedule, shirley_schedule]\nwork_hours = \"9:00 to 17:00\"\nduration = 1  # in hours\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_29"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each participant's busy slots to minutes\n    jeffrey_busy = [\n        (9 * 60 + 30, 10 * 60),    # 9:30-10:00\n        (10 * 60 + 30, 11 * 60)    # 10:30-11:00\n    ]\n    \n    virginia_busy = [\n        (9 * 60, 9 * 60 + 30),     # 9:00-9:30\n        (10 * 60, 10 * 60 + 30),   # 10:00-10:30\n        (14 * 60 + 30, 15 * 60),   # 14:30-15:00\n        (16 * 60, 16 * 60 + 30)    # 16:00-16:30\n    ]\n    \n    melissa_busy = [\n        (9 * 60, 11 * 60 + 30),    # 9:00-11:30\n        (12 * 60, 12 * 60 + 30),   # 12:00-12:30\n        (13 * 60, 15 * 60),        # 13:00-15:00\n        (16 * 60, 17 * 60)         # 16:00-17:00\n    ]\n    \n    # Melissa's preference: not after 14:00 (so before 14:00)\n    melissa_preference_end = 14 * 60\n    \n    # Duration of the meeting in minutes\n    duration = 30\n    \n    # Generate all possible slots and check for availability\n    for start in range(work_start, work_end - duration + 1, 15):  # Check every 15 minutes\n        end = start + duration\n        # Check if the slot is within Melissa's preference\n        if end > melissa_preference_end:\n            continue\n        # Check Jeffrey's availability\n        jeffrey_available = True\n        for busy_start, busy_end in jeffrey_busy:\n            if not (end <= busy_start or start >= busy_end):\n                jeffrey_available = False\n                break\n        if not jeffrey_available:\n            continue\n        # Check Virginia's availability\n        virginia_available = True\n        for busy_start, busy_end in virginia_busy:\n            if not (end <= busy_start or start >= busy_end):\n                virginia_available = False\n                break\n        if not virginia_available:\n            continue\n        # Check Melissa's availability\n        melissa_available = True\n        for busy_start, busy_end in melissa_busy:\n            if not (end <= busy_start or start >= busy_end):\n                melissa_available = False\n                break\n        if not melissa_available:\n            continue\n        # If all checks passed, return the slot\n        return f\"{start // 60:02d}:{start % 60:02d}:{end // 60:02d}:{end % 60:02d}\"\n    \n    return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_30"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes\n    richard_busy = [\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    martha_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (13 * 60, 13 * 60 + 30)\n    ]\n    martha_no_before = 14 * 60  # Martha doesn't want to meet before 14:00\n    kimberly_busy = [\n        (9 * 60, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60, 16 * 60)\n    ]\n\n    # Combine all busy slots\n    all_busy = richard_busy + martha_busy + kimberly_busy\n\n    # Generate free slots by finding gaps between busy slots\n    all_busy.sort()  # Sort by start time\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the remaining time after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that fits the meeting duration and Martha's preference\n    for start, end in free_slots:\n        slot_start = max(start, martha_no_before)\n        if slot_start + meeting_duration <= end:\n            # Convert back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = (slot_start + meeting_duration) // 60\n            end_mm = (slot_start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_31"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define busy slots for each participant in minutes since midnight\n    emily_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    melissa_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (14 * 60 + 30, 15 * 60)\n    ]\n    frank_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60 + 30),\n        (15 * 60, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    # Frank's additional constraint: not after 9:30 (but his first busy slot starts at 10:00)\n    frank_constraint = 9 * 60 + 30  # 9:30\n\n    # Combine all busy slots and constraints\n    all_busy = []\n    for slot in emily_busy:\n        all_busy.append(('Emily', slot))\n    for slot in melissa_busy:\n        all_busy.append(('Melissa', slot))\n    for slot in frank_busy:\n        all_busy.append(('Frank', slot))\n    all_busy.append(('Frank', (frank_constraint, work_end)))  # Frank doesn't want to meet after 9:30\n\n    # Sort all busy slots by start time\n    all_busy.sort(key=lambda x: x[1][0])\n\n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    current_time = work_start\n\n    for name, (start, end) in all_busy:\n        if start > current_time:\n            free_slots.append((current_time, start))\n        current_time = max(current_time, end)\n\n    # Check if there's a free slot after the last busy slot\n    if current_time < work_end:\n        free_slots.append((current_time, work_end))\n\n    # Find the first free slot that is at least 30 minutes long\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Return the first suitable slot\n            start_hour = start // 60\n            start_min = start % 60\n            end_hour = (start + meeting_duration) // 60\n            end_min = (start + meeting_duration) % 60\n            return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_32"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each participant's busy slots to minutes\n    lisa_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    bobby_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    # Bobby prefers no meetings after 15:00, so we adjust his availability\n    bobby_preferred_end = 15 * 60\n    \n    randy_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    # Combine all busy slots and sort them\n    all_busy = lisa_busy + bobby_busy + randy_busy\n    all_busy.sort()\n    \n    # Find the earliest time when all are free for 30 minutes\n    current_time = work_start\n    meeting_duration = 30\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > current_time:\n            # Check if the gap is enough for the meeting\n            if busy_start - current_time >= meeting_duration:\n                # Also check Bobby's preference (before 15:00)\n                if current_time + meeting_duration <= bobby_preferred_end:\n                    return f\"{current_time // 60:02d}:{current_time % 60:02d}:{(current_time + meeting_duration) // 60:02d}:{(current_time + meeting_duration) % 60:02d}\"\n        # Update current_time to the end of the current busy slot if it's later\n        if busy_end > current_time:\n            current_time = busy_end\n    \n    # Check after the last busy slot but within work hours and Bobby's preference\n    if current_time + meeting_duration <= work_end and current_time + meeting_duration <= bobby_preferred_end:\n        return f\"{current_time // 60:02d}:{current_time % 60:02d}:{(current_time + meeting_duration) // 60:02d}:{(current_time + meeting_duration) % 60:02d}\"\n    \n    # If no slot found (though the problem states there is one), return None\n    return None\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_33"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert all time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m - 540  # Subtract 540 to start from 0 (9:00)\n    \n    # Convert work hours to minutes\n    start_work, end_work = map(time_to_minutes, work_hours.split(' to '))\n    \n    # Initialize the free slots for all participants\n    free_slots = []\n    for busy_slots in participants_busy:\n        # Start with the entire work day as free\n        free = [(start_work, end_work)]\n        for busy in busy_slots:\n            busy_start, busy_end = map(time_to_minutes, busy.split(' to '))\n            new_free = []\n            for slot in free:\n                # Slot is completely before or after the busy time\n                if slot[1] <= busy_start or slot[0] >= busy_end:\n                    new_free.append(slot)\n                else:\n                    # Slot is partially or fully overlapped by busy time\n                    if slot[0] < busy_start:\n                        new_free.append((slot[0], busy_start))\n                    if slot[1] > busy_end:\n                        new_free.append((busy_end, slot[1]))\n            free = new_free\n        free_slots.append(free)\n    \n    # Find overlapping free slots\n    common_free = free_slots[0]\n    for free in free_slots[1:]:\n        new_common = []\n        for slot1 in common_free:\n            for slot2 in free:\n                start = max(slot1[0], slot2[0])\n                end = min(slot1[1], slot2[1])\n                if start < end:\n                    new_common.append((start, end))\n        common_free = new_common\n    \n    # Find the first slot that fits the duration\n    for slot in common_free:\n        if slot[1] - slot[0] >= duration:\n            # Convert back to HH:MM format\n            start_time = slot[0] + 540\n            end_time = start_time + duration\n            return f\"{start_time // 60:02d}:{start_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n    return \"No suitable time found\"\n\n# Define the participants' busy times\nparticipants_busy = [\n    [],  # Willie is free all day\n    [   # Richard's busy times\n        \"10:00 to 10:30\",\n        \"11:00 to 12:00\",\n        \"13:00 to 14:00\",\n        \"16:00 to 16:30\"\n    ],\n    [   # Noah's busy times\n        \"10:00 to 10:30\",\n        \"11:30 to 13:00\",\n        \"13:30 to 14:00\",\n        \"14:30 to 17:00\"\n    ]\n]\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nduration = 60  # 1 hour in minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_34"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' schedules and constraints\n    bradley_free = []\n    bradley_constraint = 14 * 60 + 30  # Bradley doesn't want to meet before 14:30\n    \n    zachary_busy = [\n        (10 * 60, 10 * 60 + 30),   # 10:00-10:30\n        (15 * 60, 15 * 60 + 30)     # 15:00-15:30\n    ]\n    \n    teresa_busy = [\n        (9 * 60, 10 * 60 + 30),     # 9:00-10:30\n        (11 * 60, 12 * 60 + 30),    # 11:00-12:30\n        (13 * 60, 14 * 60),         # 13:00-14:00\n        (14 * 60 + 30, 16 * 60 + 30) # 14:30-16:30\n    ]\n    \n    meeting_duration = 30  # minutes\n    \n    # Generate all possible slots within work hours, considering Bradley's constraint\n    possible_slots = []\n    current_start = max(work_start, bradley_constraint)\n    \n    while current_start + meeting_duration <= work_end:\n        possible_slots.append((current_start, current_start + meeting_duration))\n        current_start += 15  # Check every 15 minutes for efficiency\n    \n    # Check each slot against Zachary's and Teresa's busy times\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        \n        # Check Zachary's availability\n        zachary_available = True\n        for busy_start, busy_end in zachary_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                zachary_available = False\n                break\n        \n        if not zachary_available:\n            continue\n        \n        # Check Teresa's availability\n        teresa_available = True\n        for busy_start, busy_end in teresa_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                teresa_available = False\n                break\n        \n        if teresa_available:\n            # Convert minutes back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_35"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    ryan_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (12 * 60 + 30, 13 * 60)\n    ]\n    denise_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (12 * 60, 13 * 60),\n        (14 * 60 + 30, 16 * 60 + 30)\n    ]\n    # Denise doesn't want to meet after 12:30 (12*60 + 30)\n    denise_no_meet_after = 12 * 60 + 30\n\n    # Combine all busy times and sort them\n    all_busy = ryan_busy + denise_busy\n    all_busy.sort()\n\n    # Find available slots by checking gaps between busy times\n    available_slots = []\n    prev_end = work_start\n\n    for start, end in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n\n    # Check the slot after the last busy time\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Filter out slots that are too short or violate Denise's constraint\n    valid_slots = []\n    for start, end in available_slots:\n        slot_start = start\n        slot_end = end\n        # Ensure the slot is at least meeting_duration long\n        if slot_end - slot_start >= meeting_duration:\n            # Ensure the meeting doesn't end after Denise's no-meet time\n            if slot_start + meeting_duration <= denise_no_meet_after:\n                valid_slots.append((slot_start, slot_end))\n\n    # Select the first valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No valid slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_36"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert work hours and blocked times to minutes for easier calculation\n    work_start, work_end = work_hours\n    work_start_min = int(work_start.split(':')[0]) * 60 + int(work_start.split(':')[1])\n    work_end_min = int(work_end.split(':')[0]) * 60 + int(work_end.split(':')[1])\n    \n    # Initialize the available slots as the entire work day\n    available_slots = [(work_start_min, work_end_min)]\n    \n    # Process each participant's schedule to find common available times\n    for schedule in participants_schedules:\n        blocked_slots = []\n        for block in schedule:\n            start, end = block\n            start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n            end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n            blocked_slots.append((start_min, end_min))\n        \n        # Sort blocked slots by start time\n        blocked_slots.sort()\n        \n        # Merge overlapping or adjacent blocked slots\n        merged_blocked = []\n        for block in blocked_slots:\n            if not merged_blocked:\n                merged_blocked.append(block)\n            else:\n                last_start, last_end = merged_blocked[-1]\n                current_start, current_end = block\n                if current_start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = min(last_start, current_start)\n                    new_end = max(last_end, current_end)\n                    merged_blocked[-1] = (new_start, new_end)\n                else:\n                    merged_blocked.append(block)\n        \n        # Subtract blocked slots from available slots\n        new_available_slots = []\n        for avail_start, avail_end in available_slots:\n            current_start = avail_start\n            for block_start, block_end in merged_blocked:\n                if block_start > current_start and block_start < avail_end:\n                    # Slot before the block is available\n                    new_available_slots.append((current_start, block_start))\n                    current_start = block_end\n                elif block_start <= current_start and block_end > current_start:\n                    current_start = block_end\n            if current_start < avail_end:\n                new_available_slots.append((current_start, avail_end))\n        available_slots = new_available_slots\n    \n    # Find the first available slot that can fit the meeting duration\n    duration_min = duration * 60\n    for slot in available_slots:\n        start, end = slot\n        if end - start >= duration_min:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = (start + duration_min) // 60\n            end_mm = (start + duration_min) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No available slot found\"\n\n# Define the participants' schedules\ngregory_schedule = [\n    (\"11:00\", \"11:30\"),\n    (\"12:00\", \"12:30\"),\n    (\"15:30\", \"16:30\")\n]\n\nteresa_schedule = []  # Wide open\n\ncarol_schedule = [\n    (\"09:00\", \"10:30\"),\n    (\"11:00\", \"16:00\"),\n    (\"16:30\", \"17:00\")\n]\n\nparticipants_schedules = [gregory_schedule, teresa_schedule, carol_schedule]\n\n# Define work hours and meeting duration\nwork_hours = (\"09:00\", \"17:00\")\nduration = 0.5  # half an hour\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_37"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 9 * 60  # Subtract 9:00 (540 minutes)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 9 * 60 + minutes\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    work_start, work_end = map(time_to_minutes, work_hours.split(' to '))\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules.values():\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots between merged busy intervals\n    available_slots = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"Catherine\": [\"10:30 to 11:00\", \"12:30 to 13:30\", \"14:30 to 15:00\"],\n    \"Michael\": [\"9:30 to 10:30\", \"12:00 to 13:00\", \"13:30 to 14:00\", \"15:00 to 15:30\"],\n    \"Alexander\": [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:00 to 12:00\", \"13:00 to 13:30\", \"14:00 to 16:00\", \"16:30 to 17:00\"]\n}\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_hours = \"9:00 to 17:00\"\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, duration, work_hours))\n```",
            "count": "calendar_scheduling_example_38"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:00:14:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's schedule to find common free slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_slots.append((start, end))\n        \n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Calculate free slots for this participant\n        current_free = []\n        prev_end = work_start\n        for start, end in busy_slots:\n            if start > prev_end:\n                current_free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            current_free.append((prev_end, work_end))\n        \n        # Intersect current_free with existing free_slots\n        new_free_slots = []\n        i = j = 0\n        while i < len(free_slots) and j < len(current_free):\n            a_start, a_end = free_slots[i]\n            b_start, b_end = current_free[j]\n            \n            # Find overlap\n            overlap_start = max(a_start, b_start)\n            overlap_end = min(a_end, b_end)\n            if overlap_start < overlap_end:\n                new_free_slots.append((overlap_start, overlap_end))\n            \n            # Move the pointer which ends first\n            if a_end < b_end:\n                i += 1\n            else:\n                j += 1\n        \n        free_slots = new_free_slots\n    \n    # Find the earliest slot that can fit the meeting\n    duration_min = duration * 60\n    for slot in free_slots:\n        start, end = slot\n        if end - start >= duration_min:\n            meeting_end = start + duration_min\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return None\n\n# Define the participants' schedules\nemily_schedule = []  # Free all day\nvictoria_schedule = [\"13:30:14:00\", \"14:30:15:30\", \"16:30:17:00\"]\nnancy_schedule = [\"9:00:14:00\", \"14:30:15:30\"]\n\nparticipants_schedules = [emily_schedule, victoria_schedule, nancy_schedule]\nmeeting_duration = 0.5  # half hour\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, meeting_duration, work_hours_start, work_hours_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_39"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 9:00 (0 minutes)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes  # Add back 540 to start from 9:00\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Initialize busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        person_busy = []\n        for meeting in schedule:\n            start, end = meeting.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            person_busy.append((start_min, end_min))\n        busy_intervals.append(person_busy)\n    \n    # Find all busy intervals for all participants\n    all_busy = []\n    for person in busy_intervals:\n        for interval in person:\n            all_busy.append(interval)\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots\n    available = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n    \n    # Check for a slot that fits the duration\n    duration_min = duration * 60\n    for start, end in available:\n        if end - start >= duration_min:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration_min)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\njacob_schedule = [\n    \"10:00 to 11:00\",\n    \"11:30 to 12:00\",\n    \"16:00 to 16:30\"\n]\n\ngabriel_schedule = [\n    \"9:30 to 11:30\",\n    \"13:00 to 13:30\",\n    \"15:00 to 15:30\"\n]\n\nmatthew_schedule = [\n    \"9:00 to 9:30\",\n    \"10:30 to 11:00\",\n    \"11:30 to 12:00\",\n    \"12:30 to 14:00\",\n    \"15:30 to 16:30\"\n]\n\nparticipants_schedules = [jacob_schedule, gabriel_schedule, matthew_schedule]\nwork_hours = \"9:00 to 17:00\"\nduration = 1  # hour\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_40"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Alan's constraints: available after 14:30\n    alan_start = 14 * 60 + 30  # 14:30 in minutes\n    alan_end = work_end\n\n    # Nancy's busy slots in minutes\n    nancy_busy = [\n        (11 * 60, 12 * 60 + 30),  # 11:00-12:30\n        (13 * 60, 13 * 60 + 30),  # 13:00-13:30\n        (14 * 60, 15 * 60)         # 14:00-15:00\n    ]\n\n    # Patricia's busy slots in minutes\n    patricia_busy = [\n        (10 * 60, 12 * 60),        # 10:00-12:00\n        (12 * 60 + 30, 13 * 60),   # 12:30-13:00\n        (13 * 60 + 30, 16 * 60)    # 13:30-16:00\n    ]\n\n    # Combine all busy slots for Nancy and Patricia\n    all_busy = nancy_busy + patricia_busy\n\n    # Sort busy slots by start time\n    all_busy.sort()\n\n    # Find available slots after Alan's start time (14:30)\n    available_slots = []\n    previous_end = alan_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n\n    # Find the first available slot that is at least 30 minutes\n    meeting_duration = 30\n    for slot in available_slots:\n        start, end = slot\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_41"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours\n    start_min = time_to_minutes(start_work)\n    end_min = time_to_minutes(end_work)\n    duration_min = duration * 60\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = busy\n            busy_start = time_to_minutes(start)\n            busy_end = time_to_minutes(end)\n            busy_intervals.append((busy_start, busy_end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    prev_end = start_min\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    # Check the slot after the last busy interval until end of work day\n    if prev_end < end_min:\n        available_slots.append((prev_end, end_min))\n    \n    # Find the first available slot that can fit the meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\njulie_schedule = [\n    (\"9:00\", \"9:30\"),\n    (\"11:00\", \"11:30\"),\n    (\"12:00\", \"12:30\"),\n    (\"13:30\", \"14:00\"),\n    (\"16:00\", \"17:00\")\n]\n\nsean_schedule = [\n    (\"9:00\", \"9:30\"),\n    (\"13:00\", \"13:30\"),\n    (\"15:00\", \"15:30\"),\n    (\"16:00\", \"16:30\")\n]\n\nlori_schedule = [\n    (\"10:00\", \"10:30\"),\n    (\"11:00\", \"13:00\"),\n    (\"15:30\", \"17:00\")\n]\n\n# Combine all schedules\nparticipants_schedules = [julie_schedule, sean_schedule, lori_schedule]\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 1  # hour\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_42"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:9:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return (minutes_to_time(meeting_start), minutes_to_time(meeting_end))\n    \n    return None\n\n# Define participants' schedules\nalbert_schedule = [\n    \"09:30:10:30\",\n    \"12:00:12:30\",\n    \"14:00:14:30\",\n    \"15:00:15:30\",\n    \"16:30:17:00\"\n]\n\ngregory_schedule = [\n    \"11:00:11:30\",\n    \"12:30:13:00\",\n    \"13:30:14:00\",\n    \"15:30:16:00\"\n]\n\nbenjamin_schedule = [\n    \"09:30:10:00\",\n    \"10:30:11:00\",\n    \"11:30:13:30\",\n    \"14:00:15:00\",\n    \"15:30:16:00\",\n    \"16:30:17:00\"\n]\n\n# Meeting parameters\nmeeting_duration = 30  # minutes\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\n\n# Find the earliest meeting time\nparticipants_schedules = [albert_schedule, gregory_schedule, benjamin_schedule]\nmeeting_time = find_meeting_time(participants_schedules, meeting_duration, work_hours_start, work_hours_end)\n\n# Output the result in HH:MM:HH:MM format\nprint(f\"{meeting_time[0]}:{meeting_time[1]}\")\n```",
            "count": "calendar_scheduling_example_43"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each participant's busy slots to minutes\n    # Ronald's busy slots: 11:30-12:00, 14:00-14:30, 16:00-17:00\n    ronald_busy = [\n        (11 * 60 + 30, 12 * 60),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n    \n    # Amanda's busy slots: 9:30-12:00, 12:30-13:00, 13:30-14:00, 15:30-17:00\n    amanda_busy = [\n        (9 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    \n    # Isabella's preference: not after 13:00 (so latest end time is 13:00)\n    isabella_preference_end = 13 * 60\n    \n    # Generate all possible slots within work hours, checking for availability\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_start = current_time\n        slot_end = current_time + meeting_duration\n        \n        # Check Ronald's availability\n        ronald_available = True\n        for busy_start, busy_end in ronald_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                ronald_available = False\n                break\n        \n        # Check Amanda's availability\n        amanda_available = True\n        for busy_start, busy_end in amanda_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                amanda_available = False\n                break\n        \n        # Check Isabella's preference (slot must end by 13:00)\n        isabella_ok = slot_end <= isabella_preference_end\n        \n        # If all conditions are met, return the slot\n        if ronald_available and amanda_available and isabella_ok:\n            # Convert minutes back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n        \n        current_time += 15  # Check in 15-minute increments\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_44"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration):\n    # Convert all time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # 9:00 is 540 minutes\n    \n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = work_hours\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Collect all busy times for all participants\n    all_busy_times = []\n    for busy_times in participants_busy_times.values():\n        for start, end in busy_times:\n            all_busy_times.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy times by start time\n    all_busy_times.sort()\n    \n    # Find free slots between busy times\n    free_slots = []\n    previous_end = work_start_min\n    \n    for start, end in all_busy_times:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end_min:\n        free_slots.append((previous_end, work_end_min))\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define the participants' busy times\nparticipants_busy_times = {\n    \"Samuel\": [\n        (\"9:00\", \"10:30\"),\n        (\"11:30\", \"12:00\"),\n        (\"13:00\", \"13:30\"),\n        (\"14:00\", \"16:00\"),\n        (\"16:30\", \"17:00\")\n    ]\n}\n\n# Andrew and Grace have no meetings, so their busy times are empty\nparticipants_busy_times = {\n    \"Andrew\": [],\n    \"Grace\": [],\n    \"Samuel\": [\n        (\"9:00\", \"10:30\"),\n        (\"11:30\", \"12:00\"),\n        (\"13:00\", \"13:30\"),\n        (\"14:00\", \"16:00\"),\n        (\"16:30\", \"17:00\")\n    ]\n}\n\nwork_hours = (\"9:00\", \"17:00\")\nmeeting_duration = 30  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_45"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all times to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find the earliest available slot\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            available_duration = start - prev_end\n            if available_duration >= duration_minutes:\n                return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + duration_minutes)}\"\n        prev_end = max(prev_end, end)\n    \n    # Check after the last busy interval\n    if work_end - prev_end >= duration_minutes:\n        return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + duration_minutes)}\"\n    \n    return \"No available slot found\"\n\n# Define the participants' schedules\narthur_schedule = [\"09:30 to 10:00\", \"14:00 to 14:30\"]\ntheresa_schedule = [\"09:00 to 09:30\", \"12:00 to 13:00\", \"15:00 to 16:30\"]\ncarl_schedule = [\"09:00 to 11:30\", \"12:00 to 14:00\", \"14:30 to 17:00\"]\n\n# Combine all schedules\nall_schedules = arthur_schedule + theresa_schedule + carl_schedule\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time([all_schedules], \"09:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_46"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration):\n    # Convert all time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = map(time_to_minutes, work_hours.split('-'))\n    duration_minutes = duration * 60\n    \n    # Collect all busy times for all participants\n    all_busy_times = []\n    for busy_times in participants_busy_times.values():\n        for busy in busy_times:\n            start, end = map(time_to_minutes, busy.split('-'))\n            all_busy_times.append((start, end))\n    \n    # Sort all busy times by start time\n    all_busy_times.sort()\n    \n    # Find available slots by checking gaps between busy times and work hours\n    available_slots = []\n    prev_end = work_start\n    \n    for busy_start, busy_end in all_busy_times:\n        if busy_start > prev_end:\n            available_slots.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' busy times\nparticipants_busy_times = {\n    \"David\": [],\n    \"Eric\": [\"9:00-9:30\", \"10:30-11:30\", \"15:00-15:30\"],\n    \"Roger\": [\"9:30-10:30\", \"11:00-12:00\", \"12:30-13:00\", \"14:30-15:00\", \"15:30-16:30\"]\n}\n\n# Define work hours and meeting duration\nwork_hours = \"9:00-17:00\"\nduration = 1  # in hours\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_47"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each participant's busy slots to minutes\n    janet_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),  # 9:30-10:30\n        (12 * 60 + 30, 13 * 60),      # 12:30-13:00\n        (14 * 60, 14 * 60 + 30)       # 14:00-14:30\n    ]\n    \n    rachel_busy = []  # No meetings\n    \n    cynthia_busy = [\n        (9 * 60 + 30, 10 * 60),       # 9:30-10:00\n        (11 * 60, 11 * 60 + 30),      # 11:00-11:30\n        (12 * 60 + 30, 14 * 60 + 30), # 12:30-14:30\n        (16 * 60, 17 * 60)            # 16:00-17:00\n    ]\n    \n    # Cynthia's preference: not before 13:30\n    preference_start = 13 * 60 + 30  # 13:30 in minutes\n    \n    # Combine all busy slots\n    all_busy = janet_busy + rachel_busy + cynthia_busy\n    \n    # Sort busy slots by start time\n    all_busy.sort()\n    \n    # Initialize potential start times\n    potential_starts = []\n    \n    # Check from preference_start onwards first\n    current_time = max(work_start, preference_start)\n    meeting_duration = 60  # 1 hour\n    \n    while current_time + meeting_duration <= work_end:\n        conflict = False\n        for busy_start, busy_end in all_busy:\n            if not (current_time + meeting_duration <= busy_start or current_time >= busy_end):\n                conflict = True\n                break\n        if not conflict:\n            potential_starts.append(current_time)\n            break  # Take the first available slot\n        current_time += 30  # Check in 30-minute increments\n    \n    # If no slot found after preference_start, check before\n    if not potential_starts:\n        current_time = work_start\n        while current_time + meeting_duration <= work_end:\n            if current_time >= preference_start:\n                break  # Already checked this range\n            conflict = False\n            for busy_start, busy_end in all_busy:\n                if not (current_time + meeting_duration <= busy_start or current_time >= busy_end):\n                    conflict = True\n                    break\n            if not conflict:\n                potential_starts.append(current_time)\n                break  # Take the first available slot\n            current_time += 30\n    \n    if not potential_starts:\n        return \"No available time found\"\n    \n    # Convert the first available time to HH:MM format\n    start_time = potential_starts[0]\n    end_time = start_time + meeting_duration\n    \n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n    \n    return f\"{minutes_to_time(start_time)}:{minutes_to_time(end_time)}\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_48"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    teresa_busy = [\n        (9*60, 10*60),\n        (13*60, 13*60 + 30),\n        (14*60, 14*60 + 30),\n        (15*60, 15*60 + 30),\n        (16*60 + 30, 17*60)\n    ]\n    \n    kathleen_busy = [\n        (9*60, 9*60 + 30),\n        (12*60 + 30, 13*60),\n        (13*60 + 30, 14*60),\n        (15*60, 15*60 + 30)\n    ]\n    \n    patricia_busy = [\n        (9*60, 10*60 + 30),\n        (11*60 + 30, 12*60),\n        (13*60, 13*60 + 30),\n        (14*60, 14*60 + 30),\n        (15*60 + 30, 16*60),\n        (16*60 + 30, 17*60)\n    ]\n    \n    # Kathleen's preference: not after 14:30 (so latest start is 14:00)\n    kathleen_preference_end = 14 * 60 + 30\n    \n    # Generate all possible slots\n    possible_slots = []\n    current_time = work_start\n    \n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        # Check if the slot is valid for everyone\n        teresa_free = all(not (current_time < end and slot_end > start) for start, end in teresa_busy)\n        kathleen_free = all(not (current_time < end and slot_end > start) for start, end in kathleen_busy)\n        patricia_free = all(not (current_time < end and slot_end > start) for start, end in patricia_busy)\n        \n        # Check Kathleen's preference\n        kathleen_preference_ok = slot_end <= kathleen_preference_end\n        \n        if teresa_free and kathleen_free and patricia_free and kathleen_preference_ok:\n            possible_slots.append((current_time, slot_end))\n        \n        current_time += 30  # check in 30-minute increments\n    \n    if possible_slots:\n        # Return the first available slot\n        start, end = possible_slots[0]\n        # Convert back to HH:MM format\n        start_hh = start // 60\n        start_mm = start % 60\n        end_hh = end // 60\n        end_mm = end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_49"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:30:14:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = map(time_to_minutes, work_hours.split(':'))\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\ndaniel_schedule = []\nroy_schedule = []\nemma_schedule = [\"9:00:10:30\", \"11:00:12:00\", \"12:30:13:30\", \"14:30:15:30\", \"16:00:16:30\"]\n\nparticipants_schedules = [daniel_schedule, roy_schedule, emma_schedule]\nwork_hours = \"9:00:17:00\"\nduration = 60  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_50"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedule, work_hours, duration):\n    # Convert all time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work_hours start at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = 9 + minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    start_work = time_to_minutes(work_hours[0])\n    end_work = time_to_minutes(work_hours[1])\n    duration_min = duration * 60\n\n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedule.values():\n        for busy in schedule:\n            start, end = busy.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            busy_intervals.append((start_min, end_min))\n\n    # Sort intervals by start time\n    busy_intervals.sort()\n\n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append([start, end])\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1][1] = max(end, last_end)\n            else:\n                merged.append([start, end])\n\n    # Find available slots\n    available = []\n    prev_end = start_work\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < end_work:\n        available.append((prev_end, end_work))\n\n    # Check for a slot that can fit the duration\n    for start, end in available:\n        if end - start >= duration_min:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration_min)\n            return f\"{meeting_start}:{meeting_end}\"\n\n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedule = {\n    \"Brandon\": [\"11:30 to 12:00\", \"12:30 to 13:30\", \"14:00 to 14:30\"],\n    \"Donna\": [\"10:00 to 10:30\", \"12:00 to 12:30\"],\n    \"Jack\": [\"9:30 to 10:00\", \"10:30 to 11:00\", \"11:30 to 12:30\", \"13:00 to 14:30\", \"15:30 to 17:00\"]\n}\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 1  # in hours\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedule, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_51"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:30:15:30}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work_hours start at 9:00\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = 9 + minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work = time_to_minutes(work_hours[0])\n    end_work = time_to_minutes(work_hours[1])\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participents_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find the earliest available slot\n    prev_end = start_work\n    for start, end in all_busy:\n        if start > prev_end:\n            available_duration = start - prev_end\n            if available_duration >= duration:\n                return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + duration)}\"\n        prev_end = max(prev_end, end)\n    \n    # Check after the last busy interval\n    if prev_end + duration <= end_work:\n        return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + duration)}\"\n    \n    return \"No available slot found\"\n\n# Define the schedules and constraints\nparticipants_schedules = [\n    [\"9:00 to 9:30\", \"10:00 to 11:00\", \"16:00 to 16:30\"],  # Grace\n    [\"12:30 to 13:00\", \"16:00 to 16:30\"],                   # Randy\n    [\"9:00 to 14:30\", \"15:30 to 16:00\"]                      # Susan\n]\nwork_hours = [\"9:00\", \"17:00\"]\nmeeting_duration = 60  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, meeting_duration))\n```",
            "count": "calendar_scheduling_example_52"
        },
        {
            "final_program_time": "{15:30:16:30}",
            "expected_time": "{15:30:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration):\n    # Convert all time strings to minutes since start of the day\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert work hours to minutes\n    work_start, work_end = map(time_to_minutes, work_hours)\n    \n    # Generate busy intervals for each participant in minutes\n    busy_intervals = []\n    for busy_slots in participants_busy_times:\n        participant_intervals = []\n        for slot in busy_slots:\n            start, end = map(time_to_minutes, slot.split(' to '))\n            participant_intervals.append((start, end))\n        busy_intervals.append(participant_intervals)\n    \n    # Merge all busy intervals into a single list and sort them\n    all_busy = []\n    for intervals in busy_intervals:\n        all_busy.extend(intervals)\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Check for available slots before first busy interval\n    if merged_busy and merged_busy[0][0] > work_start:\n        available_start = work_start\n        available_end = merged_busy[0][0]\n        if available_end - available_start >= duration:\n            return available_start, available_start + duration\n    \n    # Check for available slots between busy intervals\n    for i in range(len(merged_busy) - 1):\n        current_end = merged_busy[i][1]\n        next_start = merged_busy[i+1][0]\n        if next_start - current_end >= duration:\n            return current_end, current_end + duration\n    \n    # Check for available slots after last busy interval\n    if merged_busy and merged_busy[-1][1] < work_end:\n        available_start = merged_busy[-1][1]\n        available_end = work_end\n        if available_end - available_start >= duration:\n            return available_start, available_start + duration\n    \n    # If no busy intervals, the whole work time is available\n    if not merged_busy:\n        return work_start, work_start + duration\n    \n    return None\n\ndef minutes_to_time(minutes):\n    hh = minutes // 60\n    mm = minutes % 60\n    return f\"{hh:02d}:{mm:02d}\"\n\n# Define the problem constraints\nwork_hours = (\"9:00\", \"17:00\")\nduration = 60  # minutes\n\n# Define each participant's busy times as lists of \"HH:MM to HH:MM\" strings\nparticipants_busy_times = [\n    [],  # Noah is wide open\n    [\n        \"9:30 to 10:00\",\n        \"12:30 to 13:00\",\n        \"14:30 to 15:00\",\n        \"16:30 to 17:00\"\n    ],  # Alice\n    [\n        \"9:00 to 9:30\",\n        \"10:00 to 11:00\",\n        \"11:30 to 12:00\",\n        \"13:00 to 14:00\",\n        \"15:00 to 15:30\",\n        \"16:30 to 17:00\"\n    ]  # Arthur\n]\n\n# Find a meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours, duration)\n\nif meeting_time:\n    start, end = meeting_time\n    start_time = minutes_to_time(start)\n    end_time = minutes_to_time(end)\n    print(f\"{start_time}:{end_time}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_53"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert blocked times to minutes since midnight\n    isabella_blocked = [(11 * 60, 11 * 60 + 30), (15 * 60 + 30, 16 * 60)]\n    tyler_blocked = [(9 * 60, 10 * 60)]\n    jordan_blocked = [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60), (12 * 60 + 30, 13 * 60 + 30), (14 * 60, 14 * 60 + 30), (15 * 60, 16 * 60)]\n    \n    # Tyler cannot meet after 16:00\n    tyler_limit = 16 * 60\n    \n    # Combine all blocked times for each participant\n    blocked_times = {\n        'Isabella': isabella_blocked,\n        'Tyler': tyler_blocked,\n        'Jordan': jordan_blocked\n    }\n    \n    # Generate all possible 1-hour slots within work hours\n    possible_slots = []\n    for start in range(work_start, work_end - 60 + 1, 15):  # Check every 15 minutes for efficiency\n        end = start + 60\n        if end > tyler_limit:\n            continue  # Skip slots that go beyond Tyler's limit\n        # Check if the slot is free for all participants\n        is_free = True\n        for participant, blocks in blocked_times.items():\n            for block_start, block_end in blocks:\n                if not (end <= block_start or start >= block_end):\n                    is_free = False\n                    break\n            if not is_free:\n                break\n        if is_free:\n            possible_slots.append((start, end))\n    \n    if not possible_slots:\n        return None\n    \n    # Select the earliest possible slot\n    meeting_start, meeting_end = possible_slots[0]\n    \n    # Convert back to HH:MM format\n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n    \n    return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_54"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 60  # minutes\n\n    # Convert each participant's busy slots to minutes\n    # Keith: 14:00-14:30, 16:00-16:30\n    keith_busy = [\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    # Christine: free all day\n    christine_busy = []\n    # Cynthia: 9:00-10:30, 11:30-17:00\n    cynthia_busy = [\n        (9 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 17 * 60)\n    ]\n\n    # Combine all busy slots for all participants\n    all_busy = keith_busy + christine_busy + cynthia_busy\n    # Sort busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    prev_end = work_start\n\n    for busy_start, busy_end in all_busy:\n        if busy_start > prev_end:\n            free_slots.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n    \n    # Check the time after the last busy slot\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_55"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration_minutes):\n    # Convert work hours to minutes since midnight\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start = busy[0] * 60\n            end = busy[1] * 60\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for busy in all_busy:\n        if not merged:\n            merged.append(busy)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = busy\n            if current_start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append(busy)\n    \n    # Find free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    prev_end = work_start\n    for busy_start, busy_end in merged:\n        if busy_start > prev_end:\n            free_intervals.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for a slot that fits the meeting duration\n    for start, end in free_intervals:\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            start_hour = meeting_start // 60\n            start_minute = meeting_start % 60\n            end_hour = meeting_end // 60\n            end_minute = meeting_end % 60\n            return f\"{start_hour:02d}:{start_minute:02d}:{end_hour:02d}:{end_minute:02d}\"\n    return \"No suitable time found\"\n\n# Define the participants' schedules in 24-hour format (HH.HH)\njeremy_schedule = [(12.00, 13.00), (13.30, 14.00), (15.00, 15.30)]\ndonna_schedule = [(9.30, 10.00), (13.00, 13.30), (16.00, 17.00)]\nrobert_schedule = [(9.00, 11.00), (11.30, 12.00), (12.30, 17.00)]\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (9.00, 17.00)\n\n# Meeting duration in minutes\nduration = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time([jeremy_schedule, donna_schedule, robert_schedule], work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_56"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    virginia_busy = [(10*60 - work_start, 12*60 - work_start)]  # 10:00-12:00\n    charles_busy = [(12*60 - work_start, 12*60 + 30 - work_start),  # 12:00-12:30\n                    (13*60 - work_start, 13*60 + 30 - work_start)]  # 13:00-13:30\n    megan_busy = [(9*60 - work_start, 12*60 - work_start),       # 9:00-12:00\n                  (13*60 + 30 - work_start, 16*60 - work_start), # 13:30-16:00\n                  (16*60 + 30 - work_start, 17*60 - work_start)] # 16:30-17:00\n\n    # Charles's preference: avoid before 14:30\n    charles_preference_start = 14 * 60 + 30 - work_start  # 14:30 in minutes since 9:00\n\n    # Combine all busy slots and sort them\n    all_busy = virginia_busy + charles_busy + megan_busy\n    all_busy.sort()\n\n    # Find free slots\n    free_slots = []\n    prev_end = 0\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end - work_start:\n        free_slots.append((prev_end, work_end - work_start))\n\n    # Find the first free slot that fits the meeting duration and Charles's preference\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        # Check if the slot starts after Charles's preference\n        if slot_start >= charles_preference_start:\n            if slot_end - slot_start >= meeting_duration:\n                meeting_start = slot_start\n                break\n        else:\n            # Check if the remaining part of the slot after preference fits\n            if slot_end > charles_preference_start:\n                available_start = max(slot_start, charles_preference_start)\n                if slot_end - available_start >= meeting_duration:\n                    meeting_start = available_start\n                    break\n\n    # Convert meeting_start back to HH:MM format\n    total_minutes = work_start + meeting_start\n    hours = total_minutes // 60\n    minutes = total_minutes % 60\n    start_time = f\"{hours:02d}:{minutes:02d}\"\n\n    # Calculate end time\n    total_minutes_end = total_minutes + meeting_duration\n    hours_end = total_minutes_end // 60\n    minutes_end = total_minutes_end % 60\n    end_time = f\"{hours_end:02d}:{minutes_end:02d}\"\n\n    return f\"{start_time}:{end_time}\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_57"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots\n    available_slots = []\n    previous_end = work_start\n    for start, end in merged:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Check each available slot for sufficient duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define the participants' schedules\njoan_schedule = [\"11:00 to 11:30\", \"12:30 to 13:00\"]\ntheresa_schedule = [\"12:00 to 12:30\", \"15:00 to 15:30\"]\nshirley_schedule = [\"9:30 to 10:30\", \"11:00 to 12:00\", \"13:00 to 14:00\", \"15:30 to 16:30\"]\n\nparticipants_schedules = [joan_schedule, theresa_schedule, shirley_schedule]\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 60  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_58"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy times in minutes since midnight\n    jack_busy = [\n        (10 * 60 + 30, 11 * 60 + 30),  # 10:30-11:30\n        (13 * 60, 13 * 60 + 30),        # 13:00-13:30\n        (14 * 60, 14 * 60 + 30),        # 14:00-14:30\n        (16 * 60, 17 * 60)              # 16:00-17:00\n    ]\n    \n    judith_busy = [\n        (9 * 60, 10 * 60),              # 9:00-10:00\n        (10 * 60 + 30, 11 * 60),        # 10:30-11:00\n        (11 * 60 + 30, 14 * 60),       # 11:30-14:00\n        (14 * 60 + 30, 15 * 60),        # 14:30-15:00\n        (15 * 60 + 30, 17 * 60)        # 15:30-17:00\n    ]\n    \n    # Jeffrey's constraint: not before 14:00\n    jeffrey_constraint = 14 * 60\n    \n    # Combine all busy times and sort them\n    all_busy = jack_busy + judith_busy\n    all_busy.sort()\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Filter slots that are at least 30 minutes and meet Jeffrey's constraint\n    meeting_duration = 30\n    valid_slots = []\n    \n    for slot in available_slots:\n        start, end = slot\n        if end - start >= meeting_duration and start >= jeffrey_constraint:\n            valid_slots.append(slot)\n    \n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n    else:\n        return \"No available slot found\"\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n    \n    return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_59"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy blocks to minutes since midnight\n    lisa_busy = [\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (14 * 60, 15 * 60)\n    ]\n    raymond_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 15 * 60),\n        (16 * 60, 17 * 60)\n    ]\n    # Dorothy is free all day but prefers before 10:30\n    dorothy_preference = 10 * 60 + 30\n\n    # Combine all busy times and sort\n    all_busy = lisa_busy + raymond_busy\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy times and work hours\n    free_slots = []\n    prev_end = work_start\n\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n\n    # Check each free slot for availability and Dorothy's preference\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        # Check if slot is long enough\n        if slot_end - slot_start >= meeting_duration:\n            # Check if slot starts before Dorothy's preference\n            if slot_start + meeting_duration <= dorothy_preference:\n                # Format the time as HH:MM:HH:MM\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_hh = (slot_start + meeting_duration) // 60\n                end_mm = (slot_start + meeting_duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    # If no slot before Dorothy's preference, look after (though not preferred)\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= meeting_duration:\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = (slot_start + meeting_duration) // 60\n            end_mm = (slot_start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_60"
        },
        {
            "final_program_time": "{13:30:14:30}",
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes  # Add back 540 to start from 9:00\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Collect all busy intervals\n    busy_intervals = []\n    for busy_slots in participants_busy.values():\n        for slot in busy_slots:\n            start, end = slot.split(' to ')\n            busy_start = time_to_minutes(start)\n            busy_end = time_to_minutes(end)\n            busy_intervals.append((busy_start, busy_end))\n    \n    # Sort intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append([start, end])\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1][1] = max(end, last_end)\n            else:\n                merged.append([start, end])\n    \n    # Find available slots\n    available = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n    \n    # Check for a slot that can fit the duration\n    for start, end in available:\n        if end - start >= duration:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No available slot found\"\n\n# Define participants' busy times\nparticipants_busy = {\n    \"Robert\": [],\n    \"Lisa\": [\"9:30 to 10:00\", \"11:30 to 12:00\"],\n    \"Patrick\": [\"9:30 to 11:30\", \"12:30 to 13:30\", \"16:00 to 17:00\"],\n}\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nmeeting_duration = 60  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, work_hours, meeting_duration))\n```",
            "count": "calendar_scheduling_example_61"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedule, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals\n    busy_intervals = []\n    \n    # Collect all busy intervals from participants\n    for schedule in participants_schedule:\n        for interval in schedule:\n            start = time_to_minutes(interval[0])\n            end = time_to_minutes(interval[1])\n            busy_intervals.append((start, end))\n    \n    # Sort the busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals during work hours\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Find the first free interval that can accommodate the meeting\n    duration_minutes = duration * 60\n    for start, end in free_intervals:\n        if end - start >= duration_minutes:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration_minutes)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedule = [\n    [],  # Abigail is free the entire day\n    [],  # Michael is free the entire day\n    [(\"09:00\", \"13:00\"), (\"14:00\", \"17:00\")]  # Sharon's schedule\n]\n\n# Define work hours and meeting duration\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 1  # in hours\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedule, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_62"
        },
        {
            "final_program_time": "{16:00:17:00}",
            "expected_time": "{16:00:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration_min = duration * 60\n\n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start = time_to_minutes(busy[0])\n            end = time_to_minutes(busy[1])\n            all_busy.append((start, end))\n\n    # Sort all busy intervals by start time\n    all_busy.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find available slots outside merged busy intervals and within work hours\n    available = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n\n    # Find the first available slot that can fit the meeting duration\n    for slot in available:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No available time slot found\"\n\n# Define the participants' schedules\nmadison_schedule = []\njudith_schedule = [(\"10:00\", \"10:30\"), (\"11:00\", \"12:00\"), (\"12:30\", \"13:00\")]\nroger_schedule = [(\"09:00\", \"09:30\"), (\"10:30\", \"11:00\"), (\"12:00\", \"12:30\"), (\"13:00\", \"13:30\"), (\"14:00\", \"16:00\")]\n\nparticipants_schedules = [madison_schedule, judith_schedule, roger_schedule]\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 1  # in hours\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration))\n```",
            "count": "calendar_scheduling_example_63"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Parse work hours\n    work_start, work_end = work_hours.split(' to ')\n    work_start = int(work_start.split(':')[0]) + int(work_start.split(':')[1]) / 60\n    work_end = int(work_end.split(':')[0]) + int(work_end.split(':')[1]) / 60\n\n    # Initialize available slots for each participant\n    available_slots = []\n    for participant in participants_schedules:\n        # Start with the full work day\n        participant_slots = [(work_start, work_end)]\n        # Subtract blocked times\n        for block in participants_schedules[participant]:\n            block_start, block_end = block.split(' to ')\n            block_start = int(block_start.split(':')[0]) + int(block_start.split(':')[1]) / 60\n            block_end = int(block_end.split(':')[0]) + int(block_end.split(':')[1]) / 60\n            new_slots = []\n            for slot in participant_slots:\n                if block_start >= slot[1] or block_end <= slot[0]:\n                    # No overlap\n                    new_slots.append(slot)\n                else:\n                    # Split the slot around the block\n                    if slot[0] < block_start:\n                        new_slots.append((slot[0], block_start))\n                    if block_end < slot[1]:\n                        new_slots.append((block_end, slot[1]))\n            participant_slots = new_slots\n        available_slots.append(participant_slots)\n\n    # Find common available time\n    common_slots = available_slots[0]\n    for slots in available_slots[1:]:\n        new_common_slots = []\n        for cs in common_slots:\n            for s in slots:\n                start = max(cs[0], s[0])\n                end = min(cs[1], s[1])\n                if start < end:\n                    new_common_slots.append((start, end))\n        common_slots = new_common_slots\n\n    # Find the first slot that fits the duration\n    duration_hours = duration / 60\n    for slot in common_slots:\n        if slot[1] - slot[0] >= duration_hours:\n            # Format the time\n            start_hour = int(slot[0])\n            start_min = int((slot[0] - start_hour) * 60)\n            end_time = slot[0] + duration_hours\n            end_hour = int(end_time)\n            end_min = int((end_time - end_hour) * 60)\n            return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n\n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"Nancy\": [\"9:30 to 10:00\", \"12:30 to 13:00\"],\n    \"Albert\": [],\n    \"Nathan\": [\"9:00 to 12:30\", \"13:00 to 14:30\", \"16:00 to 17:00\"]\n}\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nduration = 60  # minutes\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_64"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define busy intervals in minutes for each participant\n    john_busy = [(12 * 60 + 30, 13 * 60), (15 * 60 + 30, 16 * 60)]\n    andrea_busy = [(9 * 60, 9 * 60 + 30), (11 * 60, 12 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)]\n    lisa_busy = [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60), (12 * 60, 12 * 60 + 30), (14 * 60, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)]\n    \n    # Andrea cannot meet after 16:30\n    andrea_no_meet_after = 16 * 60 + 30\n    \n    # Meeting duration is 30 minutes\n    duration = 30\n    \n    # Generate all possible 30-minute slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + duration <= work_end:\n        slot_end = current_time + duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 1  # Check every minute\n    \n    # Check each slot against all constraints\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        \n        # Check Andrea's constraint: cannot meet after 16:30\n        if slot_start >= andrea_no_meet_after:\n            continue\n        \n        # Check John's availability\n        john_available = True\n        for busy_start, busy_end in john_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                john_available = False\n                break\n        if not john_available:\n            continue\n        \n        # Check Andrea's availability\n        andrea_available = True\n        for busy_start, busy_end in andrea_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                andrea_available = False\n                break\n        if not andrea_available:\n            continue\n        \n        # Check Lisa's availability\n        lisa_available = True\n        for busy_start, busy_end in lisa_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                lisa_available = False\n                break\n        if not lisa_available:\n            continue\n        \n        # If all checks passed, return this slot\n        return f\"{slot_start // 60:02d}:{slot_start % 60:02d}:{slot_end // 60:02d}:{slot_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_65"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration):\n    # Convert all time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 (9:00)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Initialize the merged busy times\n    merged_busy = []\n    for person in participants_busy_times:\n        for busy in person:\n            start, end = busy\n            merged_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort the busy times by start time\n    merged_busy.sort()\n    \n    # Merge overlapping or adjacent busy times\n    if not merged_busy:\n        merged = []\n    else:\n        merged = [merged_busy[0]]\n        for current in merged_busy[1:]:\n            last = merged[-1]\n            if current[0] <= last[1]:\n                new_end = max(last[1], current[1])\n                merged[-1] = (last[0], new_end)\n            else:\n                merged.append(current)\n    \n    # Add boundaries for work hours\n    work_start = time_to_minutes(work_hours[0])\n    work_end = time_to_minutes(work_hours[1])\n    if not merged:\n        available = [(work_start, work_end)]\n    else:\n        available = []\n        # Before first busy block\n        if work_start < merged[0][0]:\n            available.append((work_start, merged[0][0]))\n        # Between busy blocks\n        for i in range(1, len(merged)):\n            prev_end = merged[i-1][1]\n            current_start = merged[i][0]\n            if prev_end < current_start:\n                available.append((prev_end, current_start))\n        # After last busy block\n        if merged[-1][1] < work_end:\n            available.append((merged[-1][1], work_end))\n    \n    # Find the first available slot that fits the duration\n    duration_min = duration * 60\n    for slot in available:\n        start, end = slot\n        if end - start >= duration_min:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration_min)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No available slot found\"\n\n# Define the participants' busy times\nronald_busy = []\nmaria_busy = []\ncharles_busy = [\n    (\"9:00\", \"10:30\"),\n    (\"11:00\", \"11:30\"),\n    (\"13:30\", \"14:00\"),\n    (\"14:30\", \"15:00\"),\n    (\"15:30\", \"16:30\")\n]\n\nparticipants_busy = [ronald_busy, maria_busy, charles_busy]\nwork_hours = (\"9:00\", \"17:00\")\nduration = 1  # in hours\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_66"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each participant's busy slots to minutes\n    # Jacqueline's busy slots: 13:00-13:30, 16:00-16:30\n    j_busy = [(13 * 60, 13 * 60 + 30), (16 * 60, 16 * 60 + 30)]\n    # Christian is free all day\n    c_busy = []\n    # Linda's busy slots: 9:00-10:30, 11:30-12:30, 14:00-14:30, 15:30-16:30\n    # Linda cannot meet after 14:00, so her effective work_end is 14:00\n    l_work_end = 14 * 60\n    l_busy = [(9 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60 + 30), (14 * 60, 14 * 60 + 30), (15 * 60 + 30, 16 * 60 + 30)]\n\n    # Generate all possible slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + meeting_duration <= min(work_end, l_work_end):\n        slot_end = current_time + meeting_duration\n        # Check if the slot is free for all participants\n        j_free = all(not (start <= current_time < end or start < slot_end <= end) for start, end in j_busy)\n        c_free = True  # Christian is always free\n        l_free = all(not (start <= current_time < end or start < slot_end <= end) for start, end in l_busy)\n        if j_free and c_free and l_free:\n            possible_slots.append((current_time, slot_end))\n        current_time += 15  # Check every 15 minutes for efficiency\n\n    if not possible_slots:\n        return \"No meeting time available.\"\n\n    # Select the first available slot\n    meeting_start, meeting_end = possible_slots[0]\n    # Convert back to HH:MM format\n    start_hh = meeting_start // 60\n    start_mm = meeting_start % 60\n    end_hh = meeting_end // 60\n    end_mm = meeting_end % 60\n    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_67"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration_minutes=30):\n    # Convert work hours and blocked times to minutes since start of day\n    work_start, work_end = work_hours\n    work_start_min = work_start[0] * 60 + work_start[1]\n    work_end_min = work_end[0] * 60 + work_end[1]\n    \n    # Generate all possible time slots within work hours\n    time_slots = []\n    current_time = work_start_min\n    while current_time + duration_minutes <= work_end_min:\n        time_slots.append((current_time, current_time + duration_minutes))\n        current_time += 15  # Check every 15 minutes for efficiency\n    \n    # Check each time slot against each participant's schedule\n    for slot in time_slots:\n        slot_start, slot_end = slot\n        all_available = True\n        for participant in participants_schedules:\n            for blocked in participant:\n                blocked_start = blocked[0][0] * 60 + blocked[0][1]\n                blocked_end = blocked[1][0] * 60 + blocked[1][1]\n                # Check if slot overlaps with any blocked time\n                if not (slot_end <= blocked_start or slot_start >= blocked_end):\n                    all_available = False\n                    break\n            if not all_available:\n                break\n        if all_available:\n            # Convert back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No suitable time found\"\n\n# Define participants' schedules (blocked times) in HH:MM format\nmichael_schedule = [\n    ((10, 0), (10, 30)),\n    ((11, 30), (12, 0)),\n    ((13, 30), (14, 0)),\n    ((15, 30), (16, 0))\n]\nbryan_schedule = []  # No blocked times\nlauren_schedule = [\n    ((9, 0), (10, 30)),\n    ((14, 30), (17, 0))\n]\n\nparticipants_schedules = [michael_schedule, bryan_schedule, lauren_schedule]\nwork_hours = ((9, 0), (17, 0))  # 9:00 to 17:00\n\n# Find the earliest available meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_68"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{10:00:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration_min = duration * 60\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nshirley_schedule = [\"11:00 to 11:30\", \"14:00 to 15:00\", \"16:00 to 16:30\"]\nstephen_schedule = [\"13:00 to 13:30\", \"15:30 to 16:00\"]\npaul_schedule = [\"09:00 to 10:00\", \"11:00 to 17:00\"]\n\n# Combine all schedules\nparticipants_schedules = [shirley_schedule, stephen_schedule, paul_schedule]\n\n# Define work hours and meeting duration\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nduration_hours = 1\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_69"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration_minutes):\n    start_hour, end_hour = work_hours\n    time_slots = []\n    \n    # Convert work hours to minutes since midnight for easier calculation\n    start_time = start_hour * 60\n    end_time = end_hour * 60\n    \n    # Generate all possible 30-minute slots within work hours\n    for slot_start in range(start_time, end_time, duration_minutes):\n        slot_end = slot_start + duration_minutes\n        if slot_end > end_time:\n            continue\n        time_slots.append((slot_start, slot_end))\n    \n    # Check each slot against all participants' schedules\n    for slot in time_slots:\n        slot_start, slot_end = slot\n        all_available = True\n        for schedule in participants_schedules:\n            for busy_start, busy_end in schedule:\n                busy_start_min = busy_start[0] * 60 + busy_start[1]\n                busy_end_min = busy_end[0] * 60 + busy_end[1]\n                # Check if slot overlaps with any busy period\n                if not (slot_end <= busy_start_min or slot_start >= busy_end_min):\n                    all_available = False\n                    break\n            if not all_available:\n                break\n        if all_available:\n            # Convert back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return None\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (9, 17)\n\n# Define participants' schedules in (HH, MM) format\ndenise_schedule = [\n    ((12, 0), (12, 30)),\n    ((15, 30), (16, 0))\n]\nangela_schedule = []\nnatalie_schedule = [\n    ((9, 0), (11, 30)),\n    ((12, 0), (13, 0)),\n    ((14, 0), (14, 30)),\n    ((15, 0), (17, 0))\n]\n\nparticipants_schedules = [denise_schedule, angela_schedule, natalie_schedule]\n\n# Find the earliest available 30-minute slot\nmeeting_time = find_meeting_time(participants_schedules, work_hours, 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_70"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define blocked times for each participant in minutes since midnight\n    john_blocked = [\n        (12 * 60 + 30, 13 * 60),  # 12:30-13:00\n        (16 * 60 + 30, 17 * 60)   # 16:30-17:00\n    ]\n    ethan_blocked = [\n        (9 * 60, 10 * 60),        # 9:00-10:00\n        (11 * 60 + 30, 14 * 60),   # 11:30-14:00\n        (14 * 60 + 30, 17 * 60)    # 14:30-17:00\n    ]\n\n    # John's preference: not after 12:00\n    john_preference_end = 12 * 60  # 12:00\n\n    # Generate all possible slots within work hours\n    possible_slots = []\n    current_start = work_start\n\n    while current_start + meeting_duration <= work_end:\n        current_end = current_start + meeting_duration\n        slot_valid = True\n\n        # Check John's blocked times\n        for block_start, block_end in john_blocked:\n            if not (current_end <= block_start or current_start >= block_end):\n                slot_valid = False\n                break\n\n        # Check Ethan's blocked times\n        if slot_valid:\n            for block_start, block_end in ethan_blocked:\n                if not (current_end <= block_start or current_start >= block_end):\n                    slot_valid = False\n                    break\n\n        # Check John's preference (not after 12:00)\n        if slot_valid and current_start >= john_preference_end:\n            slot_valid = False\n\n        if slot_valid:\n            possible_slots.append((current_start, current_end))\n\n        current_start += 15  # Check every 15 minutes for efficiency\n\n    if not possible_slots:\n        return None\n\n    # Select the earliest possible slot\n    meeting_start, meeting_end = possible_slots[0]\n\n    # Convert minutes back to HH:MM format\n    start_hh = meeting_start // 60\n    start_mm = meeting_start % 60\n    end_hh = meeting_end // 60\n    end_mm = meeting_end % 60\n\n    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_71"
        },
        {
            "final_program_time": "{13:30:14:30}",
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, meeting_duration):\n    # Parse work hours\n    work_start, work_end = work_hours.split(' to ')\n    work_start = int(work_start.split(':')[0]) * 60 + int(work_start.split(':')[1])\n    work_end = int(work_end.split(':')[0]) * 60 + int(work_end.split(':')[1])\n    \n    # Initialize available slots for each participant\n    available_slots = []\n    for participant, schedules in participants_schedules.items():\n        # Start with the full work day as available\n        slots = [(work_start, work_end)]\n        \n        # Subtract blocked times\n        for block in schedules:\n            block_start, block_end = block.split(' to ')\n            block_start = int(block_start.split(':')[0]) * 60 + int(block_start.split(':')[1])\n            block_end = int(block_end.split(':')[0]) * 60 + int(block_end.split(':')[1])\n            \n            new_slots = []\n            for slot in slots:\n                if block_start >= slot[1] or block_end <= slot[0]:\n                    # No overlap\n                    new_slots.append(slot)\n                else:\n                    # Overlap, split the slot\n                    if slot[0] < block_start:\n                        new_slots.append((slot[0], block_start))\n                    if slot[1] > block_end:\n                        new_slots.append((block_end, slot[1]))\n            slots = new_slots\n        \n        available_slots.append(slots)\n    \n    # Find common available time\n    common_slots = available_slots[0]\n    for slots in available_slots[1:]:\n        temp_slots = []\n        for cs in common_slots:\n            for s in slots:\n                start = max(cs[0], s[0])\n                end = min(cs[1], s[1])\n                if start < end:\n                    temp_slots.append((start, end))\n        common_slots = temp_slots\n    \n    # Find the first slot that fits the meeting duration\n    meeting_duration_minutes = meeting_duration * 60\n    for slot in common_slots:\n        if slot[1] - slot[0] >= meeting_duration_minutes:\n            # Format the time as HH:MM:HH:MM\n            start_hh = slot[0] // 60\n            start_mm = slot[0] % 60\n            end_hh = (slot[0] + meeting_duration_minutes) // 60\n            end_mm = (slot[0] + meeting_duration_minutes) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    'Mason': [],\n    'Amy': ['9:30 to 11:30', '13:00 to 13:30', '16:30 to 17:00'],\n    'Christopher': ['9:00 to 10:00', '12:00 to 13:30', '14:30 to 15:00', '15:30 to 16:30']\n}\n\n# Define work hours and meeting duration\nwork_hours = '9:00 to 17:00'\nmeeting_duration = 1  # in hours\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, meeting_duration))\n```",
            "count": "calendar_scheduling_example_72"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n\n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy_times in participants_busy_times:\n        for interval in busy_times:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n\n    # Check the available slots between work hours and busy intervals\n    available_slots = []\n    prev_end = work_start\n    for start, end in merged_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No available time slot found\"\n\n# Define the participants' busy times\nparticipants_busy_times = [\n    [\"09:30 to 10:00\", \"13:00 to 13:30\", \"14:30 to 15:00\", \"16:30 to 17:00\"],  # Bradley\n    [\"09:00 to 09:30\", \"12:30 to 13:30\", \"14:00 to 14:30\", \"15:00 to 16:00\"],  # Andrew\n    [\"09:00 to 09:30\", \"10:00 to 10:30\", \"11:00 to 14:00\", \"15:00 to 15:30\", \"16:00 to 16:30\"],  # Melissa\n]\n\n# Define work hours and meeting duration\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_73"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy times in minutes\n    eric_busy = [(10 * 60, 12 * 60)]\n    albert_busy = [(12 * 60, 12 * 60 + 30), (15 * 60 + 30, 16 * 60)]\n    katherine_busy = [(10 * 60, 11 * 60), (11 * 60 + 30, 14 * 60), (15 * 60, 15 * 60 + 30)]\n    \n    # Eric's constraint: not after 15:30\n    eric_constraint = 15 * 60 + 30\n    \n    # Meeting duration in minutes\n    duration = 60\n    \n    # Combine all busy times and sort them\n    all_busy = []\n    for start, end in eric_busy:\n        all_busy.append((start, end, 'Eric'))\n    for start, end in albert_busy:\n        all_busy.append((start, end, 'Albert'))\n    for start, end in katherine_busy:\n        all_busy.append((start, end, 'Katherine'))\n    all_busy.sort()\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end, _ in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if work_end > prev_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Check each available slot for duration and constraints\n    for slot_start, slot_end in available_slots:\n        potential_start = slot_start\n        potential_end = potential_start + duration\n        \n        if potential_end > slot_end:\n            continue  # Slot too short\n        \n        # Check Eric's constraint\n        if potential_end > eric_constraint:\n            continue\n        \n        # Check if all participants are free\n        eric_free = all(not (s < potential_end and e > potential_start) for s, e, name in all_busy if name == 'Eric')\n        albert_free = all(not (s < potential_end and e > potential_start) for s, e, name in all_busy if name == 'Albert')\n        katherine_free = all(not (s < potential_end and e > potential_start) for s, e, name in all_busy if name == 'Katherine')\n        \n        if eric_free and albert_free and katherine_free:\n            # Convert back to HH:MM format\n            start_hh = potential_start // 60\n            start_mm = potential_start % 60\n            end_hh = potential_end // 60\n            end_mm = potential_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_74"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert all time strings to minutes since start of day\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy_intervals in participants_busy.values():\n        for interval in busy_intervals:\n            start, end = interval.split(' to ')\n            all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability of duration\n    duration_min = duration * 60\n    for start, end in free_intervals:\n        if end - start >= duration_min:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration_min)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No available time found\"\n\n# Define participants' busy times\nparticipants_busy = {\n    \"Jacob\": [\n        \"9:00 to 9:30\",\n        \"12:30 to 13:00\",\n        \"14:30 to 15:00\",\n        \"16:30 to 17:00\"\n    ],\n    \"Amanda\": [\n        \"10:00 to 10:30\",\n        \"12:00 to 12:30\"\n    ],\n    \"Lisa\": [\n        \"11:00 to 13:00\",\n        \"14:30 to 16:30\"\n    ]\n}\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nduration = 1  # in hours\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_75"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Convert each person's busy slots to minutes since midnight\n    beverly_busy = [\n        (9 * 60 + 30, 10 * 60 + 0),\n        (11 * 60 + 0, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60 + 0),\n        (14 * 60 + 0, 14 * 60 + 30),\n        (15 * 60 + 30, 16 * 60 + 0),\n        (16 * 60 + 30, 17 * 60 + 0)\n    ]\n    \n    peter_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (11 * 60 + 30, 13 * 60 + 0),\n        (14 * 60 + 30, 15 * 60 + 30),\n        (16 * 60 + 30, 17 * 60 + 0)\n    ]\n    \n    # Combine all busy slots and sort them\n    all_busy = beverly_busy + peter_busy\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    previous_end = work_start\n    free_slots = []\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if work_end > previous_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_76"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert blocked times to minutes since midnight\n    donald_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (15 * 60 + 30, 16 * 60 + 30)\n    ]\n    joyce_busy = [\n        (11 * 60, 13 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    abigail_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60, 14 * 60),\n        (15 * 60, 17 * 60)\n    ]\n    \n    # Donald's constraint: not after 12:00\n    donald_constraint = 12 * 60\n    \n    # Generate all possible 30-minute slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + 30 <= work_end:\n        slot_end = current_time + 30\n        possible_slots.append((current_time, slot_end))\n        current_time += 30\n    \n    # Check each slot against all constraints\n    for slot in possible_slots:\n        start, end = slot\n        \n        # Check Donald's constraint (not after 12:00)\n        if start >= donald_constraint:\n            continue\n        \n        # Check Donald's availability\n        donald_available = True\n        for busy_start, busy_end in donald_busy:\n            if not (end <= busy_start or start >= busy_end):\n                donald_available = False\n                break\n        if not donald_available:\n            continue\n        \n        # Check Joyce's availability\n        joyce_available = True\n        for busy_start, busy_end in joyce_busy:\n            if not (end <= busy_start or start >= busy_end):\n                joyce_available = False\n                break\n        if not joyce_available:\n            continue\n        \n        # Check Abigail's availability\n        abigail_available = True\n        for busy_start, busy_end in abigail_busy:\n            if not (end <= busy_start or start >= busy_end):\n                abigail_available = False\n                break\n        if not abigail_available:\n            continue\n        \n        # If all checks passed, return this slot\n        return f\"{start // 60:02d}:{start % 60:02d}:{end // 60:02d}:{end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_77"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:30}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 9:00 (0 minutes)\n    \n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours\n    start_min = time_to_minutes(start_work)\n    end_min = time_to_minutes(end_work)\n    \n    # Collect all busy intervals\n    busy_intervals = []\n    for person in participans_busy.values():\n        for interval in person:\n            start, end = interval\n            busy_intervals.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append([start, end])\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1][1] = max(end, last_end)\n            else:\n                merged.append([start, end])\n    \n    # Find available slots\n    available = []\n    prev_end = start_min\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < end_min:\n        available.append((prev_end, end_min))\n    \n    # Find first slot that fits the duration\n    for start, end in available:\n        if end - start >= duration:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No available slot found\"\n\n# Define participants' busy times\nparticipants_busy = {\n    \"Ronald\": [(\"9:00\", \"10:00\"), (\"11:00\", \"12:00\")],\n    \"Teresa\": [(\"10:30\", \"11:00\"), (\"14:00\", \"14:30\")],\n    \"Carol\": [(\"9:00\", \"12:30\"), (\"14:00\", \"15:30\"), (\"16:00\", \"17:00\")]\n}\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 60  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_78"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:10:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedule, work_hours, duration):\n    start_work, end_work = work_hours\n    busy_times = []\n    \n    # Collect all busy intervals from all participants\n    for schedule in participants_schedule.values():\n        busy_times.extend(schedule)\n    \n    # Sort all busy intervals by start time\n    busy_times.sort()\n    \n    # Initialize available time slots\n    available_slots = []\n    previous_end = start_work\n    \n    # Find gaps between busy times\n    for busy_start, busy_end in busy_times:\n        if busy_start > previous_end:\n            available_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    # Check the time after the last busy interval until end of work hours\n    if previous_end < end_work:\n        available_slots.append((previous_end, end_work))\n    \n    # Find the first available slot that can fit the meeting duration\n    for slot_start, slot_end in available_slots:\n        if (slot_end - slot_start) >= duration:\n            return f\"{slot_start:02d}:00:{slot_start + duration:02d}:00\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules\nparticipants_schedule = {\n    \"Amy\": [(11.0, 11.5), (12.0, 12.5)],\n    \"Emma\": [],\n    \"John\": [(10.0, 10.5), (11.5, 12.0), (12.5, 16.0), (16.5, 17.0)],\n}\n\n# Define work hours and meeting duration\nwork_hours = (9.0, 17.0)\nduration = 1.0  # 1 hour\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedule, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_79"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since midnight\n    michelle_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (12 * 60 + 30, 13 * 60)\n    ]\n    billy_busy = [\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    alexis_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (11 * 60, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    alexis_preference_end = 15 * 60  # Prefers not after 15:00\n\n    # Generate all possible 30-minute slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 1  # Check every minute for availability\n\n    # Check each slot for availability\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n\n        # Check Michelle's availability\n        michelle_available = True\n        for busy_start, busy_end in michelle_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                michelle_available = False\n                break\n        if not michelle_available:\n            continue\n\n        # Check Billy's availability\n        billy_available = True\n        for busy_start, busy_end in billy_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                billy_available = False\n                break\n        if not billy_available:\n            continue\n\n        # Check Alexis's availability and preference\n        alexis_available = True\n        for busy_start, busy_end in alexis_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                alexis_available = False\n                break\n        if not alexis_available:\n            continue\n        if slot_start >= alexis_preference_end:\n            continue\n\n        # If all checks passed, return this slot\n        start_hour = slot_start // 60\n        start_min = slot_start % 60\n        end_hour = slot_end // 60\n        end_min = slot_end % 60\n        return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_80"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Define each participant's busy blocks in minutes since midnight\n    jeremy_busy = [(14 * 60 + 30, 15 * 60 + 30)]\n    lawrence_busy = [(15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)]\n    helen_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60, 14 * 60),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n\n    # Combine all busy times and sort\n    all_busy = jeremy_busy + lawrence_busy + helen_busy\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy times\n    previous_end = work_start\n    possible_slots = []\n\n    for start, end in all_busy:\n        if start > previous_end:\n            gap = start - previous_end\n            if gap >= meeting_duration:\n                possible_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check the slot after the last busy block until work_end\n    if work_end - previous_end >= meeting_duration:\n        possible_slots.append((previous_end, work_end))\n\n    # Select the earliest possible slot\n    if possible_slots:\n        chosen_start, chosen_end = possible_slots[0]\n        meeting_end = chosen_start + meeting_duration\n        # Format the output as HH:MM:HH:MM\n        return f\"{chosen_start // 60:02d}:{chosen_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    else:\n        return \"No suitable time found.\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_81"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes, work_start, work_end):\n    # Convert time strings to minutes since 9:00 (work_start)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - work_start.hour) * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = work_start.hour + (minutes // 60)\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Initialize the free slots for the day (in minutes)\n    day_start = time_to_minutes(f\"{work_start.hour:02d}:{work_start.minute:02d}\")\n    day_end = time_to_minutes(f\"{work_end.hour:02d}:{work_end.minute:02d}\")\n    free_slots = [{'start': day_start, 'end': day_end}]\n    \n    # Process each participant's schedule to find common free slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for slot in schedule:\n            start = time_to_minutes(slot['start'])\n            end = time_to_minutes(slot['end'])\n            busy_slots.append({'start': start, 'end': end})\n        \n        # Sort busy slots by start time\n        busy_slots.sort(key=lambda x: x['start'])\n        \n        # Merge overlapping or adjacent busy slots\n        merged_busy = []\n        for slot in busy_slots:\n            if not merged_busy:\n                merged_busy.append(slot)\n            else:\n                last = merged_busy[-1]\n                if slot['start'] <= last['end']:\n                    last['end'] = max(last['end'], slot['end'])\n                else:\n                    merged_busy.append(slot)\n        \n        # Subtract busy slots from current free slots\n        new_free_slots = []\n        for free in free_slots:\n            current_start = free['start']\n            for busy in merged_busy:\n                if busy['start'] > current_start:\n                    new_free_slots.append({'start': current_start, 'end': busy['start']})\n                current_start = max(current_start, busy['end'])\n            if current_start < free['end']:\n                new_free_slots.append({'start': current_start, 'end': free['end']})\n        free_slots = new_free_slots\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot in free_slots:\n        if slot['end'] - slot['start'] >= duration_minutes:\n            start_time = minutes_to_time(slot['start'])\n            end_time = minutes_to_time(slot['start'] + duration_minutes)\n            return f\"{start_time}:{end_time}\"\n    \n    return \"No suitable time found\"\n\n# Define work hours and meeting duration\nclass Time:\n    def __init__(self, hour, minute):\n        self.hour = hour\n        self.minute = minute\n\nwork_start = Time(9, 0)\nwork_end = Time(17, 0)\nduration_minutes = 30\n\n# Define participants' schedules\nparticipants_schedules = [\n    [  # Michael's schedule\n        {'start': '09:30', 'end': '10:30'},\n        {'start': '15:00', 'end': '15:30'},\n        {'start': '16:00', 'end': '16:30'}\n    ],\n    [  # Eric's schedule (empty)\n    ],\n    [  # Arthur's schedule\n        {'start': '09:00', 'end': '12:00'},\n        {'start': '13:00', 'end': '15:00'},\n        {'start': '15:30', 'end': '16:00'},\n        {'start': '16:30', 'end': '17:00'}\n    ]\n]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration_minutes, work_start, work_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_82"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{10:00:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_hours):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration_minutes = duration_hours * 60\n    \n    # Collect all busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return None\n\n# Define participants' schedules\nanthony_schedule = [\"14:00 to 14:30\", \"15:00 to 15:30\"]\nronald_schedule = [\"9:00 to 10:00\", \"12:00 to 12:30\", \"13:30 to 14:00\"]\njonathan_schedule = [\"9:00 to 10:00\", \"11:00 to 11:30\", \"12:00 to 13:00\", \"14:00 to 14:30\", \"15:00 to 17:00\"]\n\nparticipants_schedules = [anthony_schedule, ronald_schedule, jonathan_schedule]\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_hours = 1\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_83"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert all time strings to minutes since start of the day\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours\n    start_min = time_to_minutes(start_work)\n    end_min = time_to_minutes(end_work)\n    duration_min = duration * 60\n    \n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy_intervals in participants_busy.values():\n        for interval in busy_intervals:\n            start, end = interval\n            all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = start_min\n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < end_min:\n        free_intervals.append((prev_end, end_min))\n    \n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define the participants' busy times\nparticipants_busy = {\n    \"Kevin\": [(\"9:30\", \"10:00\"), (\"10:30\", \"11:00\"), (\"15:00\", \"16:00\")],\n    \"Ryan\": [(\"10:30\", \"11:30\"), (\"12:30\", \"13:00\"), (\"13:30\", \"14:00\")],\n    \"Eugene\": [(\"9:00\", \"9:30\"), (\"10:00\", \"11:00\"), (\"12:30\", \"17:00\")],\n}\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 1  # in hours\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_84"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define busy blocks in minutes since midnight\n    # Kelly is free the entire day\n    kelly_busy = []\n    \n    # Julia's busy blocks\n    julia_busy = [\n        (9 * 60 + 30, 10 * 60),    # 9:30-10:00\n        (14 * 60, 14 * 60 + 30),    # 14:00-14:30\n        (15 * 60, 15 * 60 + 30),    # 15:00-15:30\n        (16 * 60 + 30, 17 * 60)     # 16:30-17:00\n    ]\n    # Julia doesn't want to meet after 13:30\n    julia_no_meet_after = 13 * 60 + 30  # 13:30 in minutes\n    \n    # Martha's busy blocks\n    martha_busy = [\n        (9 * 60, 11 * 60),          # 9:00-11:00\n        (12 * 60, 15 * 60)          # 12:00-15:00\n    ]\n    \n    # Combine all busy times for each participant\n    # Kelly has no busy times\n    # Julia's constraints: busy times + no meet after 13:30\n    # Martha's busy times\n    \n    # Generate potential slots\n    potential_slots = []\n    current_time = work_start\n    \n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        # Check if the slot is valid for all participants\n        # Kelly is always free\n        kelly_ok = True\n        \n        # Check Julia's availability\n        julia_ok = True\n        # Check if slot is after Julia's no-meet time\n        if current_time >= julia_no_meet_after:\n            julia_ok = False\n        else:\n            # Check against Julia's busy times\n            for start, end in julia_busy:\n                if not (slot_end <= start or current_time >= end):\n                    julia_ok = False\n                    break\n        \n        # Check Martha's availability\n        martha_ok = True\n        for start, end in martha_busy:\n            if not (slot_end <= start or current_time >= end):\n                martha_ok = False\n                break\n        \n        if kelly_ok and julia_ok and martha_ok:\n            potential_slots.append((current_time, slot_end))\n        \n        current_time += 15  # Check every 15 minutes for efficiency\n    \n    # Select the first available slot\n    if potential_slots:\n        start, end = potential_slots[0]\n        # Format the output as HH:MM:HH:MM\n        start_hour = start // 60\n        start_min = start % 60\n        end_hour = end // 60\n        end_min = end % 60\n        return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n    else:\n        return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_85"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find all free intervals by merging busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Check the time before the first busy interval\n    if merged:\n        first_start, _ = merged[0]\n        if first_start - work_start >= duration:\n            return f\"{minutes_to_time(work_start)}:{minutes_to_time(work_start + duration)}\"\n    \n    # Check the time between busy intervals\n    for i in range(1, len(merged)):\n        prev_end = merged[i-1][1]\n        curr_start = merged[i][0]\n        if curr_start - prev_end >= duration:\n            return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + duration)}\"\n    \n    # Check the time after the last busy interval\n    if merged:\n        _, last_end = merged[-1]\n        if work_end - last_end >= duration:\n            return f\"{minutes_to_time(last_end)}:{minutes_to_time(last_end + duration)}\"\n    else:\n        # No busy intervals, schedule at work start\n        return f\"{minutes_to_time(work_start)}:{minutes_to_time(work_start + duration)}\"\n    \n    return None\n\n# Define the participants' schedules\nsamuel_schedule = [\n    \"9:00 to 9:30\",\n    \"10:00 to 10:30\",\n    \"12:00 to 12:30\",\n    \"14:00 to 15:00\",\n    \"16:00 to 16:30\"\n]\n\nemma_schedule = []  # Free all day\n\nbrittany_schedule = [\n    \"11:30 to 14:30\",\n    \"15:00 to 15:30\",\n    \"16:30 to 17:00\"\n]\n\n# Combine all schedules\nparticipants_schedules = [samuel_schedule, emma_schedule, brittany_schedule]\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 60\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_86"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert all time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 (9:00)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Initialize the free intervals as the entire work day\n    free_intervals = [{'start': work_start, 'end': work_end}]\n    \n    # Process each participant's busy intervals\n    for participant in participants_busy:\n        for busy in participants_busy[participant]:\n            start_busy, end_busy = busy.split(' to ')\n            start_busy = time_to_minutes(start_busy)\n            end_busy = time_to_minutes(end_busy)\n            \n            new_free_intervals = []\n            for interval in free_intervals:\n                # No overlap\n                if interval['end'] <= start_busy or interval['start'] >= end_busy:\n                    new_free_intervals.append(interval)\n                else:\n                    # Interval before busy time\n                    if interval['start'] < start_busy:\n                        new_free_intervals.append({'start': interval['start'], 'end': start_busy})\n                    # Interval after busy time\n                    if interval['end'] > end_busy:\n                        new_free_intervals.append({'start': end_busy, 'end': interval['end']})\n            free_intervals = new_free_intervals\n    \n    # Merge overlapping intervals\n    if not free_intervals:\n        return None\n    \n    free_intervals.sort(key=lambda x: x['start'])\n    merged = [free_intervals[0]]\n    for interval in free_intervals[1:]:\n        last = merged[-1]\n        if interval['start'] <= last['end']:\n            last['end'] = max(last['end'], interval['end'])\n        else:\n            merged.append(interval)\n    \n    # Find the first interval that can fit the meeting\n    duration_min = duration * 60\n    for interval in merged:\n        if interval['end'] - interval['start'] >= duration_min:\n            start_time = minutes_to_time(interval['start'])\n            end_time = minutes_to_time(interval['start'] + duration_min)\n            return f\"{start_time}:{end_time}\"\n    \n    return None\n\n# Define the participants' busy times\nparticipants_busy = {\n    'Brittany': ['12:00 to 13:30', '14:30 to 15:00', '15:30 to 16:00', '16:30 to 17:00'],\n    'Wayne': ['9:30 to 10:00', '13:00 to 15:00', '16:30 to 17:00'],\n    'Charles': ['9:00 to 9:30', '10:00 to 10:30', '11:30 to 13:30', '14:30 to 16:30']\n}\n\n# Define work hours and meeting duration\nwork_hours = '9:00 to 17:00'\nduration = 0.5  # 0.5 hours = 30 minutes\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_87"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Parse work hours\n    work_start, work_end = work_hours.split(\" to \")\n    work_start = int(work_start.replace(\":\", \"\"))\n    work_end = int(work_end.replace(\":\", \"\"))\n    \n    # Initialize available slots within work hours\n    available_slots = [(work_start, work_end)]\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        busy_slots = []\n        if \"busy\" in schedule:\n            parts = schedule.split(\";\")\n            for part in parts:\n                if \"to\" in part:\n                    times = part.split(\"to\")\n                    start = int(times[0].strip().replace(\":\", \"\"))\n                    end = int(times[1].strip().replace(\":\", \"\"))\n                    busy_slots.append((start, end))\n        \n        # Subtract busy slots from available slots\n        new_available_slots = []\n        for slot in available_slots:\n            slot_start, slot_end = slot\n            for busy_start, busy_end in busy_slots:\n                if busy_start >= slot_end or busy_end <= slot_start:\n                    continue\n                if busy_start > slot_start:\n                    new_available_slots.append((slot_start, busy_start))\n                slot_start = busy_end\n            if slot_start < slot_end:\n                new_available_slots.append((slot_start, slot_end))\n        available_slots = new_available_slots\n    \n    # Find the first available slot that fits the duration\n    duration_mins = duration * 100  # Convert to HHMM format (e.g., 1 hour = 100)\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if (slot_end - slot_start) >= duration_mins:\n            # Format the time as HH:MM:HH:MM\n            start_time = f\"{str(slot_start)[:2]}:{str(slot_start)[2:]}\"\n            end_time = f\"{str(slot_start + duration_mins)[:2]}:{str(slot_start + duration_mins)[2:]}\"\n            return f\"{start_time}:{end_time}\"\n    return \"No available slot found\"\n\n# Define the participants' schedules and constraints\nparticipants_schedules = [\n    \"Dennis has no meetings the whole day.\",\n    \"Joseph is busy on Monday during 9:00 to 9:30, 12:30 to 13:00;\",\n    \"Isabella has blocked their calendar on Monday during 9:00 to 10:30, 11:30 to 12:00, 13:30 to 14:00, 14:30 to 17:00;\"\n]\nwork_hours = \"9:00 to 17:00\"\nduration = 1  # 1 hour\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_88"
        },
        {
            "final_program_time": "{15:00:16:00}",
            "expected_time": "{15:00:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_hour, end_hour = work_hours\n    # Convert work hours to minutes for easier calculation\n    start_time = start_hour * 60\n    end_time = end_hour * 60\n    \n    # Initialize a list to keep track of busy times for all participants\n    busy_times = []\n    \n    for schedule in participants_schedules:\n        for block in schedule:\n            start_block = block[0] * 60 + block[1]\n            end_block = block[2] * 60 + block[3]\n            busy_times.append((start_block, end_block))\n    \n    # Sort all busy times by start time\n    busy_times.sort()\n    \n    # Find all free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = start_time\n    \n    for start, end in busy_times:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy time until end of work hours\n    if previous_end < end_time:\n        free_slots.append((previous_end, end_time))\n    \n    # Now, merge overlapping or adjacent busy times across all participants\n    # Then find the free slots again\n    if not busy_times:\n        free_slots.append((start_time, end_time))\n    else:\n        merged_busy = []\n        busy_times.sort()\n        current_start, current_end = busy_times[0]\n        \n        for start, end in busy_times[1:]:\n            if start <= current_end:\n                current_end = max(current_end, end)\n            else:\n                merged_busy.append((current_start, current_end))\n                current_start, current_end = start, end\n        merged_busy.append((current_start, current_end))\n        \n        free_slots = []\n        previous_end = start_time\n        for start, end in merged_busy:\n            if start > previous_end:\n                free_slots.append((previous_end, start))\n            previous_end = max(previous_end, end)\n        if previous_end < end_time:\n            free_slots.append((previous_end, end_time))\n    \n    # Now find the first free slot that can accommodate the meeting duration\n    duration_minutes = duration * 60\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to hours and minutes\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (9, 17)\n\n# Define participants' schedules in (HH, MM, HH, MM) format\nmichelle = [\n    (11, 0, 12, 0),\n    (14, 0, 15, 0)\n]\n\nandrea = [\n    (9, 0, 9, 30),\n    (11, 30, 12, 30),\n    (13, 30, 14, 0),\n    (14, 30, 15, 0),\n    (16, 0, 16, 30)\n]\n\ndouglas = [\n    (9, 0, 9, 30),\n    (10, 0, 10, 30),\n    (11, 0, 15, 0),\n    (16, 0, 17, 0)\n]\n\n# Combine all schedules\nparticipants_schedules = [michelle, andrea, douglas]\n\n# Meeting duration in hours\nduration = 1\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_89"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes\n    adam_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    willie_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    gloria_busy = [\n        (9 * 60 + 30, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (15 * 60 + 30, 16 * 60)\n    ]\n\n    # Gloria's preference to avoid meetings after 15:30\n    gloria_preference_end = 15 * 60 + 30\n\n    # Generate all possible 30-minute slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 1  # Check every minute for availability\n\n    # Filter slots where all participants are free\n    valid_slots = []\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n\n        # Check Adam's availability\n        adam_free = True\n        for busy_start, busy_end in adam_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                adam_free = False\n                break\n\n        # Check Willie's availability\n        willie_free = True\n        for busy_start, busy_end in willie_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                willie_free = False\n                break\n\n        # Check Gloria's availability and preference\n        gloria_free = True\n        for busy_start, busy_end in gloria_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                gloria_free = False\n                break\n        if slot_start >= gloria_preference_end:\n            gloria_free = False\n\n        if adam_free and willie_free and gloria_free:\n            valid_slots.append(slot)\n\n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_slot = valid_slots[0]\n        start_hour = meeting_slot[0] // 60\n        start_min = meeting_slot[0] % 60\n        end_hour = meeting_slot[1] // 60\n        end_min = meeting_slot[1] % 60\n        return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n    else:\n        return \"No available slot found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_90"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        participant_busy = []\n        for meeting in schedule:\n            start, end = meeting.split(' to ')\n            participant_busy.append((time_to_minutes(start), time_to_minutes(end)))\n        all_busy.append(participant_busy)\n    \n    # Find all free intervals common to all participants\n    common_free = []\n    current_time = work_start\n    while current_time + duration <= work_end:\n        # Check if current_time is free for all participants\n        all_free = True\n        for participant_busy in all_busy:\n            is_free = True\n            for start, end in participant_busy:\n                if not (current_time >= end or current_time + duration <= start):\n                    is_free = False\n                    break\n            if not is_free:\n                all_free = False\n                break\n        if all_free:\n            common_free.append((current_time, current_time + duration))\n            break  # Return the first available slot\n        # Move to the next possible start time\n        next_time = current_time + 1\n        # Find the earliest next time that could be free\n        for participant_busy in all_busy:\n            for start, end in participant_busy:\n                if current_time < end and end > current_time:\n                    next_time = max(next_time, end)\n        current_time = next_time\n    \n    if common_free:\n        start, end = common_free[0]\n        return f\"{minutes_to_time(start)}:{minutes_to_time(end)}\"\n    else:\n        return \"No available time slot found\"\n\n# Define participants' schedules\ndanielle_schedule = [\n    \"9:00 to 10:00\",\n    \"10:30 to 11:00\",\n    \"14:30 to 15:00\",\n    \"15:30 to 16:00\",\n    \"16:30 to 17:00\"\n]\n\nbruce_schedule = [\n    \"11:00 to 11:30\",\n    \"12:30 to 13:00\",\n    \"14:00 to 14:30\",\n    \"15:30 to 16:00\"\n]\n\neric_schedule = [\n    \"9:00 to 9:30\",\n    \"10:00 to 11:00\",\n    \"11:30 to 13:00\",\n    \"14:30 to 15:30\"\n]\n\nparticipants_schedules = [danielle_schedule, bruce_schedule, eric_schedule]\nwork_hours = \"9:00 to 17:00\"\nmeeting_duration = 60  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, meeting_duration))\n```",
            "count": "calendar_scheduling_example_91"
        },
        {
            "final_program_time": "{11:00:12:00}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Parse work hours\n    work_start, work_end = [int(time.replace(':', '')) for time in work_hours.split(' to ')]\n    \n    # Generate all possible meeting slots within work hours\n    meeting_slots = []\n    current_time = work_start\n    while current_time + duration <= work_end:\n        slot_start = current_time\n        slot_end = current_time + duration\n        meeting_slots.append((slot_start, slot_end))\n        current_time += 100  # Assuming meetings start on the hour or half-hour\n    \n    # Check each slot against each participant's schedule\n    for slot in meeting_slots:\n        slot_start, slot_end = slot\n        slot_valid = True\n        for participant, schedules in participants_schedules.items():\n            for busy_start, busy_end in schedules:\n                if not (slot_end <= busy_start or slot_start >= busy_end):\n                    slot_valid = False\n                    break\n            if not slot_valid:\n                break\n        if slot_valid:\n            return f\"{slot_start//100:02d}:{slot_start%100:02d}:{slot_end//100:02d}:{slot_end%100:02d}\"\n    return \"No valid slot found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    'Jacqueline': [(930, 1000), (1630, 1700)],\n    'Henry': [],\n    'William': [(930, 1030), (1230, 1500), (1530, 1700)],\n}\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nmeeting_duration = 100  # 1 hour in HHMM format\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_92"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 (9:00)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes  # Add back 540 to start from 9:00\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = work_hours.split(' to ')\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Initialize a list to mark busy times\n    timeline = [False] * (work_end_min - work_start_min)\n    \n    # Mark busy times for each participant\n    for person in participants_busy:\n        for busy_range in participants_busy[person]:\n            start, end = busy_range.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            for i in range(start_min, end_min):\n                if i < len(timeline):\n                    timeline[i] = True\n    \n    # Find the first available slot of duration\n    required_slots = duration * 2  # Assuming 30-minute slots (duration is in hours)\n    current_slots = 0\n    for i in range(len(timeline)):\n        if not timeline[i]:\n            current_slots += 1\n            if current_slots >= required_slots:\n                start_time = i - current_slots + 1\n                end_time = start_time + required_slots\n                return f\"{minutes_to_time(start_time)}:{minutes_to_time(end_time)}\"\n        else:\n            current_slots = 0\n    \n    return \"No available slot found\"\n\n# Define participants' busy times\nparticipants_busy = {\n    'Austin': ['10:30 to 11:00', '13:30 to 14:00'],\n    'Danielle': ['9:00 to 10:00', '11:00 to 12:00', '13:00 to 13:30', '15:30 to 16:00'],\n    'Charles': ['9:00 to 11:30', '12:00 to 12:30', '13:00 to 17:00']\n}\n\n# Define work hours and meeting duration\nwork_hours = '9:00 to 17:00'\nduration = 0.5  # 30 minutes\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_93"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' schedules and constraints\n    # Nicholas is free all day\n    # Elizabeth's busy times in minutes\n    elizabeth_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60 + 30, 14 * 60 + 30),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    # Sandra's busy times in minutes and constraint (not before 13:00)\n    sandra_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 13 * 60 + 30),\n        (15 * 60 + 30, 16 * 60 + 30)\n    ]\n    sandra_min_time = 13 * 60  # 13:00 in minutes\n\n    meeting_duration = 30  # minutes\n\n    # Generate all possible 30-minute slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 1  # Check every minute for availability\n\n    # Check each slot against all constraints\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n\n        # Check Sandra's constraint (not before 13:00)\n        if slot_start < sandra_min_time:\n            continue\n\n        # Check Elizabeth's availability\n        elizabeth_available = True\n        for busy_start, busy_end in elizabeth_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                elizabeth_available = False\n                break\n        if not elizabeth_available:\n            continue\n\n        # Check Sandra's availability\n        sandra_available = True\n        for busy_start, busy_end in sandra_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                sandra_available = False\n                break\n        if not sandra_available:\n            continue\n\n        # If all checks passed, return this slot\n        return f\"{slot_start // 60:02d}:{slot_start % 60:02d}:{slot_end // 60:02d}:{slot_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_94"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define busy intervals in minutes since midnight\n    jennifer_busy = [(12 * 60, 12 * 60 + 30), (16 * 60, 16 * 60 + 30)]\n    gary_busy = [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 11 * 60), \n                 (11 * 60 + 30, 12 * 60 + 30), (14 * 60, 14 * 60 + 30), \n                 (16 * 60 + 30, 17 * 60)]\n    frances_busy = [(9 * 60, 11 * 60), (11 * 60 + 30, 12 * 60 + 30), \n                    (13 * 60, 17 * 60)]\n    \n    # Jennifer's constraint: not before 12:30\n    jennifer_constraint = 12 * 60 + 30\n    \n    # Combine all busy intervals\n    all_busy = jennifer_busy + gary_busy + frances_busy\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy intervals\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy interval\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Filter free slots that are at least 30 minutes and meet Jennifer's constraint\n    possible_slots = []\n    for start, end in free_slots:\n        if end - start >= 30 and start >= jennifer_constraint:\n            possible_slots.append((start, end))\n    \n    if not possible_slots:\n        return None\n    \n    # Select the earliest possible slot\n    meeting_start = possible_slots[0][0]\n    meeting_end = meeting_start + 30\n    \n    # Convert back to HH:MM format\n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n    \n    return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_95"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    christopher_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 13 * 60),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    \n    robert_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60 + 30, 14 * 60 + 30),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    \n    wayne_busy = [\n        (10 * 60, 17 * 60)\n    ]\n    \n    # Combine all busy slots\n    all_busy = christopher_busy + robert_busy + wayne_busy\n    \n    # Sort busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Check each free slot for availability for all participants\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Check Christopher's availability\n            christopher_free = True\n            for busy_start, busy_end in christopher_busy:\n                if not (slot_start >= busy_end or slot_start + meeting_duration <= busy_start):\n                    christopher_free = False\n                    break\n            \n            # Check Robert's availability\n            robert_free = True\n            for busy_start, busy_end in robert_busy:\n                if not (slot_start >= busy_end or slot_start + meeting_duration <= busy_start):\n                    robert_free = False\n                    break\n            \n            # Check Wayne's availability\n            wayne_free = True\n            for busy_start, busy_end in wayne_busy:\n                if not (slot_start >= busy_end or slot_start + meeting_duration <= busy_start):\n                    wayne_free = False\n                    break\n            \n            if christopher_free and robert_free and wayne_free:\n                # Convert back to HH:MM format\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_hh = (slot_start + meeting_duration) // 60\n                end_mm = (slot_start + meeting_duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_96"
        },
        {
            "final_program_time": "{16:00:17:00}",
            "expected_time": "{16:00:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Define busy intervals in minutes for each participant\n    joseph_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60 + 30, 15 * 60 + 30)\n    ]\n    kyle_busy = [\n        (12 * 60 + 30, 13 * 60 + 30)\n    ]\n    joan_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n\n    # Joseph's preference: not before 14:30\n    preference_start = 14 * 60 + 30\n\n    # Combine all busy intervals\n    all_busy = []\n    for busy in [joseph_busy, kyle_busy, joan_busy]:\n        all_busy.extend(busy)\n    all_busy.sort()\n\n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find available slots (considering work hours and preference)\n    available_slots = []\n    previous_end = max(work_start, preference_start)\n    for start, end in merged:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n\n    # Check for a 1-hour slot\n    meeting_duration = 60\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_97"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define busy intervals in minutes for each participant\n    juan_busy = [(9 * 60, 10 * 60 + 30), (15 * 60 + 30, 16 * 60)]\n    marilyn_busy = [(11 * 60, 11 * 60 + 30), (12 * 60 + 30, 13 * 60)]\n    ronald_busy = [(9 * 60, 10 * 60 + 30), (12 * 60, 12 * 60 + 30), \n                   (13 * 60, 13 * 60 + 30), (14 * 60, 16 * 60 + 30)]\n    \n    # Juan cannot meet after 16:00\n    juan_end_time = 16 * 60\n    \n    # Meeting duration in minutes\n    duration = 30\n    \n    # Combine all busy intervals and sort them\n    all_busy = juan_busy + marilyn_busy + ronald_busy\n    all_busy.sort()\n    \n    # Find free intervals by checking gaps between busy intervals\n    free_intervals = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the interval after the last busy interval\n    if previous_end < work_end:\n        free_intervals.append((previous_end, work_end))\n    \n    # Find the first free interval that fits the duration and meets Juan's constraint\n    for start, end in free_intervals:\n        if end > start + duration:\n            actual_end = min(end, juan_end_time)\n            if actual_end - start >= duration:\n                meeting_start = start\n                meeting_end = meeting_start + duration\n                # Format the output as HH:MM:HH:MM\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_98"
        },
        {
            "final_program_time": "{15:00:16:00}",
            "expected_time": "{15:00:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Define each participant's busy times in minutes since midnight\n    stephanie_busy = [(9 * 60, 9 * 60 + 30), (13 * 60 + 30, 14 * 60)]\n    scott_busy = [(9 * 60, 10 * 60), (11 * 60, 12 * 60 + 30), (14 * 60 + 30, 15 * 60), (16 * 60, 17 * 60)]\n    mark_preference = (15 * 60, work_end)  # Mark prefers after 15:00\n\n    # Combine all busy times\n    all_busy = []\n    all_busy.extend(stephanie_busy)\n    all_busy.extend(scott_busy)\n    all_busy.sort()  # Sort by start time\n\n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n\n    for busy_start, busy_end in all_busy:\n        if busy_start > prev_end:\n            available_slots.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Filter slots that meet Mark's preference and are long enough\n    valid_slots = []\n    for slot_start, slot_end in available_slots:\n        if slot_end <= mark_preference[0]:\n            continue  # Skip slots before Mark's preferred time\n        if slot_end - slot_start >= meeting_duration:\n            valid_slots.append((slot_start, slot_end))\n\n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_99"
        }
    ],
    "5shot": [
        {
            "final_program_time": null,
            "expected_time": "{14:30:15:30}",
            "type_error": "TypeError",
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants within work hours.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times (list of tuples).\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences (e.g., 'earliest' or 'after_time').\n    \n    Returns:\n        Tuple of (start_time, end_time) in HH:MM format, or None if no slot found.\n    \"\"\"\n    # Convert work hours to minutes for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Collect all busy intervals and merge them\n    all_busy = []\n    for person in participants:\n        for start, end in person['busy']:\n            all_busy.append((start[0] * 60 + start[1], end[0] * 60 + end[1]))\n    \n    # Sort busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                merged_busy[-1] = (last_start, max(end, last_end))\n            else:\n                merged_busy.append((start, end))\n    \n    # Add work hours boundaries\n    merged_busy.insert(0, (0, work_start))\n    merged_busy.append((work_end, 24 * 60))\n    \n    # Find available slots\n    available_slots = []\n    for i in range(len(merged_busy) - 1):\n        current_end = merged_busy[i][1]\n        next_start = merged_busy[i + 1][0]\n        if next_start - current_end >= duration:\n            available_slots.append((current_end, next_start))\n    \n    # Apply preferences if any\n    if preferences:\n        if 'after_time' in preferences:\n            after_min = preferences['after_time'][0] * 60 + preferences['after_time'][1]\n            available_slots = [slot for slot in available_slots if slot[0] >= after_min]\n    \n    if not available_slots:\n        return None\n    \n    # Choose the earliest available slot\n    start_min, end_min = available_slots[0]\n    start_time = (start_min // 60, start_min % 60)\n    end_time = ((start_min + duration) // 60, (start_min + duration) % 60)\n    \n    return (start_time, end_time)\n\n# Example usage for the given task\nparticipants = [\n    {\n        'name': 'Michelle',\n        'busy': [(11, 0), (12, 0)],  # 11:00-12:00\n    },\n    {\n        'name': 'Steven',\n        'busy': [\n            (9, 0), (9, 30),  # 9:00-9:30\n            (11, 30), (12, 0),  # 11:30-12:00\n            (13, 30), (14, 0),  # 13:30-14:00\n            (15, 30), (16, 0),  # 15:30-16:00\n        ],\n    },\n    {\n        'name': 'Jerry',\n        'busy': [\n            (9, 0), (9, 30),  # 9:00-9:30\n            (10, 0), (11, 0),  # 10:00-11:00\n            (11, 30), (12, 30),  # 11:30-12:30\n            (13, 0), (14, 30),  # 13:00-14:30\n            (15, 30), (16, 0),  # 15:30-16:00\n            (16, 30), (17, 0),  # 16:30-17:00\n        ],\n    },\n]\n\nduration = 60  # 1 hour\nwork_hours = (9, 17)  # 9:00-17:00\n\nresult = find_meeting_time(participants, duration, work_hours)\nif result:\n    start, end = result\n    print(f\"{start[0]:02d}:{start[1]:02d}:{end[0]:02d}:{end[1]:02d}\")\nelse:\n    print(\"No available slot found.\")\n```\n\nThe output of this script will be `14:30:15:30`, which corresponds to the available slot from 14:30 to 15:30.",
            "count": "calendar_scheduling_example_0"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, preferences=None):\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Initialize free slots for all participants\n    free_slots = []\n    for participant in participants:\n        busy_slots = participant['busy']\n        free = []\n        prev_end = work_start\n        \n        for start, end in sorted(busy_slots):\n            if prev_end < start:\n                free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free.append((prev_end, work_end))\n        \n        free_slots.append(free)\n    \n    # Find common free slots\n    common_free = free_slots[0]\n    for slots in free_slots[1:]:\n        temp = []\n        i = j = 0\n        while i < len(common_free) and j < len(slots):\n            start1, end1 = common_free[i]\n            start2, end2 = slots[j]\n            \n            overlap_start = max(start1, start2)\n            overlap_end = min(end1, end2)\n            \n            if overlap_start < overlap_end:\n                temp.append((overlap_start, overlap_end))\n            \n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free = temp\n    \n    # Apply preferences if any\n    if preferences:\n        if 'earliest' in preferences and preferences['earliest']:\n            common_free = [slot for slot in common_free if slot[0] >= preferences.get('min_time', 0)]\n        if 'avoid_after' in preferences:\n            avoid_after = preferences['avoid_after'] * 60\n            common_free = [slot for slot in common_free if slot[0] < avoid_after]\n    \n    # Find the earliest suitable slot of 30 minutes\n    for slot in common_free:\n        start, end = slot\n        duration = 30  # minutes\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Define participants and their busy slots\nparticipants = [\n    {\n        'name': 'Raymond',\n        'busy': [(9 * 60, 9 * 60 + 30), (11 * 60 + 30, 12 * 60), (13 * 60, 13 * 60 + 30), (15 * 60, 15 * 60 + 30)]\n    },\n    {\n        'name': 'Billy',\n        'busy': [(10 * 60, 10 * 60 + 30), (12 * 60, 13 * 60), (16 * 60 + 30, 17 * 60)]\n    },\n    {\n        'name': 'Donald',\n        'busy': [(9 * 60, 9 * 60 + 30), (10 * 60, 11 * 60), (12 * 60, 13 * 60), (14 * 60, 14 * 60 + 30), (16 * 60, 17 * 60)]\n    }\n]\n\n# Define preferences\npreferences = {\n    'avoid_after': 15  # Billy wants to avoid meetings after 15:00\n}\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants, preferences)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_1"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Find the earliest available meeting time for all participants within work hours.\n    \n    Args:\n        participants: List of dictionaries with 'name' and 'busy' times.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dictionary of preferences (e.g., 'earliest', 'after_time').\n    \n    Returns:\n        A string with the proposed meeting time in 'HH:MM-HH:MM' format.\n    \"\"\"\n    # Convert work hours to minutes for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's busy times\n    for participant in participants:\n        new_free_slots = []\n        for busy_start, busy_end in participant['busy']:\n            busy_start_min = busy_start[0] * 60 + busy_start[1]\n            busy_end_min = busy_end[0] * 60 + busy_end[1]\n            \n            # Split existing free slots around the busy time\n            updated_slots = []\n            for slot_start, slot_end in free_slots:\n                if busy_end_min <= slot_start or busy_start_min >= slot_end:\n                    # No overlap, keep the slot\n                    updated_slots.append((slot_start, slot_end))\n                else:\n                    # Overlap, split the slot\n                    if slot_start < busy_start_min:\n                        updated_slots.append((slot_start, busy_start_min))\n                    if busy_end_min < slot_end:\n                        updated_slots.append((busy_end_min, slot_end))\n            free_slots = updated_slots.copy()\n    \n    # Apply preferences if specified\n    if preferences:\n        if 'after_time' in preferences:\n            after_min = preferences['after_time'][0] * 60 + preferences['after_time'][1]\n            free_slots = [(start, end) for start, end in free_slots if start >= after_min]\n    \n    # Find the earliest slot that fits the duration\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}-{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time found.\"\n\n# Define the participants and their busy times\nparticipants = [\n    {\n        'name': 'Roy',\n        'busy': [\n            ((9, 0), (9, 30)),\n            ((10, 0), (10, 30)),\n            ((11, 0), (11, 30)),\n            ((12, 30), (13, 0))\n        ]\n    },\n    {\n        'name': 'Kathryn',\n        'busy': [\n            ((9, 30), (10, 0)),\n            ((16, 30), (17, 0))\n        ]\n    },\n    {\n        'name': 'Amy',\n        'busy': [\n            ((9, 0), (14, 30)),\n            ((15, 0), (16, 0)),\n            ((16, 30), (17, 0))\n        ],\n        'preferences': {\n            'after_time': (15, 30)\n        }\n    }\n]\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (9, 17)\n\n# Define meeting duration (30 minutes)\nduration = 30\n\n# Apply Amy's preference to not meet after 15:30\npreferences = {\n    'after_time': (15, 30)\n}\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants, duration, work_hours, preferences)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_2"
        },
        {
            "final_program_time": "{9:30:10:30}",
            "expected_time": "{9:30:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants within work hours.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times (list of tuples).\n        duration: Meeting duration in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences (e.g., 'earliest_after').\n    \n    Returns:\n        Tuple of (start_time, end_time) in HH:MM format or None if no slot found.\n    \"\"\"\n    # Convert work hours to minutes since midnight\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Collect all busy intervals and convert to minutes\n    busy_intervals = []\n    for person in participants:\n        for start, end in person['busy']:\n            start_min = start[0] * 60 + start[1]\n            end_min = end[0] * 60 + end[1]\n            busy_intervals.append((start_min, end_min))\n    \n    # Sort busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_end = max(end, last_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Check available slots between merged busy intervals and work hours\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Filter slots that meet duration and preferences\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            if preferences and 'earliest_after' in preferences:\n                earliest_after = preferences['earliest_after'][0] * 60 + preferences['earliest_after'][1]\n                if slot_start >= earliest_after:\n                    return (slot_start, slot_start + duration)\n            else:\n                return (slot_start, slot_start + duration)\n    \n    return None\n\n# Example usage for the given task\nparticipants = [\n    {\n        'name': 'Arthur',\n        'busy': [\n            ((9, 0), (9, 30)),\n            ((10, 30), (12, 0)),\n            ((16, 0), (17, 0))\n        ]\n    },\n    {\n        'name': 'Michael',\n        'busy': [\n            ((13, 0), (13, 30)),\n            ((14, 0), (14, 30))\n        ]\n    },\n    {\n        'name': 'Samantha',\n        'busy': [\n            ((10, 30), (11, 0)),\n            ((12, 0), (15, 0)),\n            ((15, 30), (17, 0))\n        ]\n    }\n]\n\nduration = 60  # 1 hour\nwork_hours = (9, 17)  # 9:00 to 17:00\n\nresult = find_meeting_time(participants, duration, work_hours)\nif result:\n    start_h, start_m = divmod(result[0], 60)\n    end_h, end_m = divmod(result[1], 60)\n    print(f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\")\nelse:\n    print(\"No available time slot found.\")\n```",
            "count": "calendar_scheduling_example_3"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:00:10:30}",
            "type_error": "TypeError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration, preferences=None):\n    # Convert work hours to minutes for easier calculation\n    start_work = work_hours[0]\n    end_work = work_hours[1]\n    \n    # Initialize the free slots for each participant\n    free_slots = []\n    for participant in participants_busy:\n        busy_slots = participants_busy[participant]\n        free = []\n        prev_end = start_work\n        \n        for busy in busy_slots:\n            busy_start = busy[0]\n            busy_end = busy[1]\n            if busy_start > prev_end:\n                free.append((prev_end, busy_start))\n            prev_end = max(prev_end, busy_end)\n        \n        if prev_end < end_work:\n            free.append((prev_end, end_work))\n        \n        free_slots.append(free)\n    \n    # Find common free slots\n    common_free = free_slots[0]\n    for i in range(1, len(free_slots)):\n        current_free = free_slots[i]\n        new_common = []\n        for slot1 in common_free:\n            for slot2 in current_free:\n                start = max(slot1[0], slot2[0])\n                end = min(slot1[1], slot2[1])\n                if start < end:\n                    new_common.append((start, end))\n        common_free = new_common\n    \n    # Apply preferences if any\n    if preferences:\n        if 'earliest' in preferences and preferences['earliest']:\n            common_free.sort(key=lambda x: x[0])\n        elif 'after_time' in preferences:\n            after_time = preferences['after_time']\n            common_free = [slot for slot in common_free if slot[0] >= after_time]\n    \n    # Find the first slot that can fit the duration\n    for slot in common_free:\n        slot_duration = slot[1] - slot[0]\n        if slot_duration >= duration:\n            meeting_start = slot[0]\n            meeting_end = meeting_start + duration\n            return f\"{meeting_start[0]:02d}:{meeting_start[1]:02d}:{meeting_end[0]:02d}:{meeting_end[1]:02d}\"\n    \n    return None\n\n# Define the task\nparticipants_busy = {\n    'Donna': [(14, 0, 14, 30), (15, 30, 16, 0)],\n    'John': [(11, 0, 11, 30), (16, 30, 17, 0)],\n    'Billy': [(9, 0, 10, 0), (10, 30, 14, 0), (14, 30, 17, 0)],\n}\n\nwork_hours = ((9, 0), (17, 0))\nduration = 30  # minutes\n\n# Convert busy slots to minutes format for processing\ndef convert_to_minutes(busy_slots):\n    converted = []\n    for slot in busy_slots:\n        start = (slot[0], slot[1])\n        end = (slot[2], slot[3])\n        converted.append((start, end))\n    return converted\n\nparticipants_busy_minutes = {}\nfor participant in participants_busy:\n    participants_busy_minutes[participant] = convert_to_minutes(participants_busy[participant])\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_minutes, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_4"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences (e.g., 'earliest' or 'after_time').\n    \n    Returns:\n        Tuple of (start_time, end_time) in HH:MM format.\n    \"\"\"\n    # Convert work hours to minutes for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Initialize all available slots as free\n    all_slots = []\n    current_time = work_start\n    \n    # Generate all possible slots within work hours\n    while current_time + duration <= work_end:\n        all_slots.append((current_time, current_time + duration))\n        current_time += 30  # Assuming 30-minute increments for simplicity\n    \n    # Check each slot against participants' busy times\n    for slot in all_slots:\n        slot_start, slot_end = slot\n        valid = True\n        \n        for participant in participants:\n            busy_slots = participant['busy']\n            for busy_start, busy_end in busy_slots:\n                busy_start_min = busy_start[0] * 60 + busy_start[1]\n                busy_end_min = busy_end[0] * 60 + busy_end[1]\n                \n                # Check if slot overlaps with any busy time\n                if not (slot_end <= busy_start_min or slot_start >= busy_end_min):\n                    valid = False\n                    break\n            \n            if not valid:\n                break\n        \n        # Check preferences if any\n        if valid and preferences:\n            if 'after_time' in preferences:\n                after_time_min = preferences['after_time'][0] * 60 + preferences['after_time'][1]\n                if slot_start < after_time_min:\n                    valid = False\n        \n        if valid:\n            # Convert back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}-{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available slot found\"\n\n# Example usage for Kathryn, Charlotte, and Lauren\nparticipants = [\n    {\n        'name': 'Kathryn',\n        'busy': [\n            ((9, 0), (9, 30)),\n            ((10, 30), (11, 0)),\n            ((11, 30), (12, 0)),\n            ((13, 30), (14, 30)),\n            ((16, 30), (17, 0))\n        ]\n    },\n    {\n        'name': 'Charlotte',\n        'busy': [\n            ((12, 0), (12, 30)),\n            ((16, 0), (16, 30))\n        ]\n    },\n    {\n        'name': 'Lauren',\n        'busy': [\n            ((9, 0), (10, 0)),\n            ((12, 0), (12, 30)),\n            ((13, 30), (14, 30)),\n            ((15, 0), (16, 0)),\n            ((16, 30), (17, 0))\n        ]\n    }\n]\n\nduration = 30  # minutes\nwork_hours = (9, 17)  # 9:00 to 17:00\npreferences = {'after_time': (13, 30)}  # Charlotte doesn't want to meet after 13:30\n\n# Find the earliest available time\nmeeting_time = find_meeting_time(participants, duration, work_hours, preferences)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_5"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:30:15:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times (list of tuples).\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict of preferences (e.g., 'earliest' or time constraints).\n    \n    Returns:\n        Tuple of (start_time, end_time) as strings in HH:MM format.\n    \"\"\"\n    # Convert work hours to minutes for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's busy times\n    for person in participants:\n        busy_slots = []\n        for busy in person['busy']:\n            start = busy[0] * 60\n            end = busy[1] * 60\n            busy_slots.append((start, end))\n        \n        # Merge overlapping busy slots\n        busy_slots.sort()\n        merged_busy = []\n        for busy in busy_slots:\n            if not merged_busy:\n                merged_busy.append(busy)\n            else:\n                last_start, last_end = merged_busy[-1]\n                current_start, current_end = busy\n                if current_start <= last_end:\n                    merged_busy[-1] = (last_start, max(last_end, current_end))\n                else:\n                    merged_busy.append(busy)\n        \n        # Subtract busy slots from free slots\n        new_free_slots = []\n        for free_start, free_end in free_slots:\n            current_free = [(free_start, free_end)]\n            for busy_start, busy_end in merged_busy:\n                temp_free = []\n                for slot_start, slot_end in current_free:\n                    if busy_end <= slot_start or busy_start >= slot_end:\n                        temp_free.append((slot_start, slot_end))\n                    else:\n                        if slot_start < busy_start:\n                            temp_free.append((slot_start, busy_start))\n                        if slot_end > busy_end:\n                            temp_free.append((busy_end, slot_end))\n                current_free = temp_free\n            new_free_slots.extend(current_free)\n        free_slots = new_free_slots\n    \n    # Apply preferences (e.g., earliest time or after a certain time)\n    if preferences and 'earliest' in preferences:\n        free_slots.sort(key=lambda x: x[0])\n    elif preferences and 'after' in preferences:\n        after_time = preferences['after'] * 60\n        free_slots = [slot for slot in free_slots if slot[0] >= after_time]\n        free_slots.sort(key=lambda x: x[0])\n    else:\n        free_slots.sort(key=lambda x: x[0])\n    \n    # Find the first slot that fits the duration\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}\", f\"{end_hh:02d}:{end_mm:02d}\"\n    \n    return None\n\n# Define the participants and their busy times\nparticipants = [\n    {\n        'name': 'Thomas',\n        'busy': []\n    },\n    {\n        'name': 'Dylan',\n        'busy': [(10.5, 11.0), (13.5, 14.0)]\n    },\n    {\n        'name': 'Jerry',\n        'busy': [(9.0, 11.0), (11.5, 14.5), (16.0, 17.0)]\n    }\n]\n\n# Define meeting duration (1 hour) and work hours (9:00 to 17:00)\nduration = 60\nwork_hours = (9, 17)\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants, duration, work_hours)\nprint(f\"{meeting_time[0]}:{meeting_time[1]}\")\n```",
            "count": "calendar_scheduling_example_6"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:00:12:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest meeting time that fits all participants' schedules.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times (list of tuples).\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences (e.g., 'earliest' or 'after_time').\n    \n    Returns:\n        Tuple of (start_time, end_time) as strings in HH:MM format.\n    \"\"\"\n    # Convert work hours to minutes for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Collect all busy intervals and sort them\n    all_busy = []\n    for person in participants:\n        for start, end in person['busy']:\n            all_busy.append((start[0] * 60 + start[1], end[0] * 60 + end[1]))\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1] = (last_start, max(end, last_end))\n            else:\n                merged.append((start, end))\n    \n    # Check the available slots between busy intervals and work hours\n    available = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n    \n    # Apply preferences (e.g., earliest or after a certain time)\n    if preferences:\n        if 'after_time' in preferences:\n            after_min = preferences['after_time'][0] * 60 + preferences['after_time'][1]\n            available = [(s, e) for s, e in available if s >= after_min]\n    \n    # Find the first available slot that fits the duration\n    for start, end in available:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return (f\"{start_hh:02d}:{start_mm:02d}\", f\"{end_hh:02d}:{end_mm:02d}\")\n    \n    return None\n\n# Define the participants and their busy times\nparticipants = [\n    {\n        'name': 'Heather',\n        'busy': [(9, 0, 9, 30), (10, 30, 11, 0), (13, 0, 14, 0), (14, 30, 15, 0), (16, 0, 16, 30)]\n    },\n    {\n        'name': 'Nicholas',\n        'busy': []\n    },\n    {\n        'name': 'Zachary',\n        'busy': [(9, 0, 10, 30), (11, 0, 12, 0), (12, 30, 13, 0), (13, 30, 16, 30)],\n        'preferences': {'after_time': (14, 0)}\n    }\n]\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (9, 17)\n\n# Define meeting duration (30 minutes)\nduration = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants, duration, work_hours, preferences={'after_time': (14, 0)})\n\n# Output the result in the required format\nif meeting_time:\n    print(f\"{{{meeting_time[0]}:{meeting_time[1]}}}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_7"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:11:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants within work hours.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times (list of tuples).\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences (e.g., 'earliest_time').\n    \n    Returns:\n        Tuple of (start_time, end_time) in HH:MM format, or None if no slot found.\n    \"\"\"\n    # Convert work hours to minutes for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Collect all busy intervals and sort them\n    all_busy = []\n    for person in participants:\n        for start, end in person['busy']:\n            all_busy.append((start[0] * 60 + start[1], end[0] * 60 + end[1]))\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1] = (last_start, max(end, last_end))\n            else:\n                merged.append((start, end))\n    \n    # Check the available slots between busy intervals and work hours\n    previous_end = work_start\n    for start, end in merged:\n        if start > previous_end:\n            available_start = previous_end\n            available_end = start\n            if available_end - available_start >= duration:\n                # Check if this slot meets preferences (e.g., not before earliest_time)\n                if preferences and 'earliest_time' in preferences:\n                    earliest_minutes = preferences['earliest_time'][0] * 60 + preferences['earliest_time'][1]\n                    if available_start < earliest_minutes:\n                        continue\n                return (available_start, available_start + duration)\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy interval\n    if work_end - previous_end >= duration:\n        if preferences and 'earliest_time' in preferences:\n            earliest_minutes = preferences['earliest_time'][0] * 60 + preferences['earliest_time'][1]\n            if previous_end < earliest_minutes:\n                return None\n        return (previous_end, previous_end + duration)\n    \n    return None\n\ndef format_time(minutes):\n    \"\"\"Converts minutes since midnight to HH:MM format.\"\"\"\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Example usage for the given task\nparticipants = [\n    {\n        'name': 'Adam',\n        'busy': [(10, 0, 10, 30), (12, 30, 13, 0), (13, 30, 14, 30)]\n    },\n    {\n        'name': 'Jerry',\n        'busy': [(9, 0, 9, 30), (12, 0, 12, 30), (15, 0, 16, 0)]\n    },\n    {\n        'name': 'Matthew',\n        'busy': [(9, 30, 11, 0), (11, 30, 12, 30), (13, 0, 14, 0), (14, 30, 17, 0)]\n    }\n]\n\nduration = 30  # minutes\nwork_hours = (9, 17)  # 9:00 to 17:00\n\nmeeting_time = find_meeting_time(participants, duration, work_hours)\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{format_time(start)}:{format_time(end)}\")\nelse:\n    print(\"No available time slot found.\")\n```",
            "count": "calendar_scheduling_example_8"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start, end) in 'HH:MM' format.\n        preferences: Optional dict with preferences (e.g., 'earliest' or 'after').\n    \n    Returns:\n        Tuple of (start, end) in 'HH:MM' format or None if no slot found.\n    \"\"\"\n    # Convert work hours to minutes\n    start_work = sum(x * int(t) for x, t in zip([60, 1], work_hours[0].split(':')))\n    end_work = sum(x * int(t) for x, t in zip([60, 1], work_hours[1].split(':')))\n    \n    # Convert all busy times to minutes\n    busy_slots = []\n    for person in participants:\n        for slot in person['busy']:\n            start, end = slot.split(' to ')\n            start_min = sum(x * int(t) for x, t in zip([60, 1], start.split(':')))\n            end_min = sum(x * int(t) for x, t in zip([60, 1], end.split(':')))\n            busy_slots.append((start_min, end_min))\n    \n    # Sort busy slots by start time\n    busy_slots.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = start_work\n    for start, end in busy_slots:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < end_work:\n        free_slots.append((prev_end, end_work))\n    \n    # Check preferences (e.g., earliest or after a certain time)\n    if preferences and 'after' in preferences:\n        after_time = sum(x * int(t) for x, t in zip([60, 1], preferences['after'].split(':')))\n        free_slots = [slot for slot in free_slots if slot[0] >= after_time]\n    \n    # Find the first slot that fits the duration\n    duration_min = duration\n    for start, end in free_slots:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = start + duration_min\n            # Convert back to 'HH:MM' format\n            start_str = f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}\"\n            end_str = f\"{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n            return (start_str, end_str)\n    return None\n\n# Task data\nparticipants = [\n    {\n        'name': 'Diane',\n        'busy': ['9:00 to 9:30', '12:00 to 12:30', '14:30 to 15:30']\n    },\n    {\n        'name': 'Kelly',\n        'busy': ['9:30 to 10:00', '10:30 to 11:00']\n    },\n    {\n        'name': 'Deborah',\n        'busy': ['9:00 to 9:30', '10:00 to 14:00', '14:30 to 17:00']\n    }\n]\n\n# Find meeting time\nmeeting_time = find_meeting_time(\n    participants,\n    duration=30,\n    work_hours=('9:00', '17:00')\n)\n\n# Output in HH:MM:HH:MM format\nif meeting_time:\n    print(f\"{{{meeting_time[0]}:{meeting_time[1]}}}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_9"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest meeting time that fits all participants' schedules and constraints.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times (list of tuples).\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences (e.g., 'earliest', 'after_time').\n    \n    Returns:\n        Tuple of (start_time, end_time) in HH:MM format, or None if no slot found.\n    \"\"\"\n    # Convert work hours to minutes for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Generate all possible time slots within work hours\n    time_slots = []\n    current_time = work_start\n    while current_time + duration <= work_end:\n        time_slots.append((current_time, current_time + duration))\n        current_time += 30  # Assuming 30-minute increments for simplicity\n    \n    # Filter time slots based on participants' busy times\n    for participant in participants:\n        busy_slots = []\n        for busy in participant['busy']:\n            busy_start = busy[0] * 60\n            busy_end = busy[1] * 60\n            busy_slots.append((busy_start, busy_end))\n        \n        # Remove overlapping time slots\n        new_slots = []\n        for slot in time_slots:\n            overlap = False\n            for busy in busy_slots:\n                if not (slot[1] <= busy[0] or slot[0] >= busy[1]):\n                    overlap = True\n                    break\n            if not overlap:\n                new_slots.append(slot)\n        time_slots = new_slots\n    \n    # Apply preferences if any\n    if preferences:\n        if 'after_time' in preferences:\n            after_time = preferences['after_time'] * 60\n            time_slots = [slot for slot in time_slots if slot[0] >= after_time]\n        if 'earliest' in preferences and preferences['earliest']:\n            time_slots.sort(key=lambda x: x[0])\n    \n    if not time_slots:\n        return None\n    \n    # Return the earliest available slot\n    start, end = time_slots[0]\n    return (f\"{start // 60:02d}:{start % 60:02d}\", f\"{end // 60:02d}:{end % 60:02d}\")\n\n# Define participants and their busy times\nparticipants = [\n    {\n        'name': 'Diana',\n        'busy': [(11.5, 12.0), (13.0, 13.5)]\n    },\n    {\n        'name': 'Ethan',\n        'busy': []\n    },\n    {\n        'name': 'Janet',\n        'busy': [(9.0, 10.0), (12.5, 13.0), (14.0, 15.0), (15.5, 17.0)]\n    }\n]\n\n# Define preferences (Janet does not want to meet after 12:00)\npreferences = {\n    'earliest': True,\n    'after_time': 9.0  # Work hours start at 9:00\n}\n\n# Filter Janet's busy times to before 12:00\njanet_busy_before_12 = [busy for busy in participants[2]['busy'] if busy[1] <= 12.0]\nparticipants[2]['busy'] = janet_busy_before_12\n\n# Find meeting time\nmeeting_time = find_meeting_time(\n    participants,\n    duration=30,\n    work_hours=(9, 17),\n    preferences=preferences\n)\n\n# Output the result in HH:MM:HH:MM format\nif meeting_time:\n    print(f\"{meeting_time[0]}:{meeting_time[1]}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_10"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants within work hours.\n    \n    Args:\n        participants: List of dictionaries with 'name' and 'busy' times.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dictionary of preferences (e.g., 'earliest', 'after_time').\n    \n    Returns:\n        A string representing the meeting time in 'HH:MM-HH:MM' format or None if no slot found.\n    \"\"\"\n    # Convert work hours to minutes since midnight for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Generate all possible time slots within work hours\n    time_slots = []\n    current_time = work_start\n    while current_time + duration <= work_end:\n        time_slots.append((current_time, current_time + duration))\n        current_time += 30  # Assuming 30-minute increments for simplicity\n    \n    # Check each time slot against participants' busy times\n    for slot_start, slot_end in time_slots:\n        all_available = True\n        for participant in participants:\n            busy_slots = participant['busy']\n            for busy_start, busy_end in busy_slots:\n                busy_start_min = busy_start[0] * 60 + busy_start[1]\n                busy_end_min = busy_end[0] * 60 + busy_end[1]\n                # Check if slot overlaps with any busy time\n                if not (slot_end <= busy_start_min or slot_start >= busy_end_min):\n                    all_available = False\n                    break\n            if not all_available:\n                break\n        \n        # Check preferences if all are available\n        if all_available:\n            if preferences:\n                if 'after_time' in preferences:\n                    after_min = preferences['after_time'][0] * 60 + preferences['after_time'][1]\n                    if slot_start < after_min:\n                        continue\n            # Convert slot back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}-{end_hh:02d}:{end_mm:02d}\"\n    \n    return None\n\n# Example usage for the given task\nparticipants = [\n    {\n        'name': 'Alexander',\n        'busy': [\n            ((9, 30), (10, 0)),\n            ((10, 30), (11, 0)),\n            ((12, 30), (13, 0)),\n            ((14, 30), (15, 0)),\n            ((16, 0), (17, 0))\n        ]\n    },\n    {\n        'name': 'Elizabeth',\n        'busy': [\n            ((9, 0), (9, 30)),\n            ((11, 30), (12, 30)),\n            ((13, 0), (14, 30))\n        ]\n    },\n    {\n        'name': 'Walter',\n        'busy': [\n            ((9, 0), (14, 30)),\n            ((15, 30), (17, 0))\n        ]\n    }\n]\n\nduration = 30  # minutes\nwork_hours = (9, 17)  # 9:00 to 17:00\n\nmeeting_time = find_meeting_time(participants, duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_11"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest meeting time that fits all participants' schedules.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times (list of tuples).\n        duration: Meeting duration in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences (e.g., 'earliest' or 'after_time').\n    \n    Returns:\n        Tuple of (start_time, end_time) as strings in HH:MM format.\n    \"\"\"\n    # Convert work hours to minutes for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Collect all busy intervals and sort them\n    all_busy = []\n    for person in participants:\n        for start, end in person['busy']:\n            all_busy.append((start[0] * 60 + start[1], end[0] * 60 + end[1]))\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1] = (last_start, max(end, last_end))\n            else:\n                merged.append((start, end))\n    \n    # Check the available slots between busy intervals and work hours\n    available = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n    \n    # Filter available slots based on duration and preferences\n    for slot_start, slot_end in available:\n        slot_duration = slot_end - slot_start\n        if slot_duration >= duration:\n            if preferences and 'after_time' in preferences:\n                after_min = preferences['after_time'][0] * 60 + preferences['after_time'][1]\n                if slot_start < after_min:\n                    continue\n            # Convert back to HH:MM format\n            start_h = slot_start // 60\n            start_m = slot_start % 60\n            end_h = (slot_start + duration) // 60\n            end_m = (slot_start + duration) % 60\n            return f\"{start_h:02d}:{start_m:02d}-{end_h:02d}:{end_m:02d}\"\n    \n    return \"No available time slot found.\"\n\n# Example usage for the given task\nparticipants = [\n    {\n        'name': 'David',\n        'busy': []\n    },\n    {\n        'name': 'Debra',\n        'busy': [\n            ((9, 30), (10, 0)),\n            ((11, 0), (11, 30)),\n            ((12, 0), (13, 0)),\n            ((14, 0), (14, 30)),\n            ((16, 0), (16, 30))\n        ]\n    },\n    {\n        'name': 'Kevin',\n        'busy': [\n            ((9, 0), (12, 0)),\n            ((14, 0), (17, 0))\n        ]\n    }\n]\n\nduration = 60  # minutes\nwork_hours = (9, 17)  # 9:00 to 17:00\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants, duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_12"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Find the earliest meeting time that fits all participants' schedules and constraints.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times (list of tuples).\n        duration: Meeting duration in minutes.\n        work_hours: Tuple of (start, end) times as strings (e.g., '9:00', '17:00').\n        preferences: Optional dict with preferences (e.g., 'earliest_after' time).\n    \n    Returns:\n        Tuple of (start, end) times as strings (e.g., '10:00', '10:30').\n    \"\"\"\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m\n    \n    def minutes_to_time(minutes):\n        h = minutes // 60\n        m = minutes % 60\n        return f\"{h:02d}:{m:02d}\"\n    \n    work_start, work_end = map(time_to_minutes, work_hours)\n    duration_min = duration\n    \n    # Collect all busy intervals\n    busy_intervals = []\n    for person in participants:\n        for start, end in person['busy']:\n            busy_intervals.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Add preferences as constraints (e.g., earliest_after)\n    if preferences and 'earliest_after' in preferences:\n        earliest_after = time_to_minutes(preferences['earliest_after'])\n        busy_intervals.append((work_start, earliest_after))\n    \n    # Sort busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Find the first free slot that fits the duration\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return (minutes_to_time(meeting_start), minutes_to_time(meeting_end))\n    \n    return None\n\n# Define participants and constraints\nparticipants = [\n    {\n        'name': 'Gerald',\n        'busy': [('9:00', '9:30'), ('13:00', '14:00'), ('15:00', '15:30'), ('16:00', '17:00')]\n    },\n    {\n        'name': 'Roy',\n        'busy': []\n    },\n    {\n        'name': 'Barbara',\n        'busy': [('9:30', '10:00'), ('11:30', '14:00'), ('14:30', '15:00'), ('15:30', '17:00')]\n    }\n]\n\nduration = 30  # minutes\nwork_hours = ('9:00', '17:00')\npreferences = {'earliest_after': '13:00'}  # Gerald's preference\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants, duration, work_hours, preferences)\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{{{start}:{end}}}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_13"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Find the earliest meeting time that fits all participants' schedules and constraints.\n    \n    Args:\n        participants: List of dicts with each participant's busy times.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences like 'earliest_time'.\n    \n    Returns:\n        Tuple of (start_time, end_time) in HH:MM format.\n    \"\"\"\n    # Convert work hours to minutes\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Collect all busy slots\n    busy_slots = []\n    for participant in participants:\n        for busy in participant['busy']:\n            start = busy[0] * 60\n            end = busy[1] * 60\n            busy_slots.append((start, end))\n    \n    # Sort busy slots by start time\n    busy_slots.sort()\n    \n    # Merge overlapping or adjacent busy slots\n    merged = []\n    for start, end in busy_slots:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find free slots between work hours and busy slots\n    free_slots = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Apply preferences\n    if preferences and 'earliest_time' in preferences:\n        earliest = preferences['earliest_time'] * 60\n        free_slots = [(s, e) for s, e in free_slots if s >= earliest]\n    \n    # Find the first free slot that can fit the meeting\n    for start, end in free_slots:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return (f\"{start_hh:02d}:{start_mm:02d}\", f\"{end_hh:02d}:{end_mm:02d}\")\n    \n    return None\n\n# Define the participants and their busy times\nparticipants = [\n    {\n        'name': 'Brandon',\n        'busy': [(13, 14), (15.5, 16), (16.5, 17)]\n    },\n    {\n        'name': 'Jerry',\n        'busy': []\n    },\n    {\n        'name': 'Bradley',\n        'busy': [(9, 11.5), (12, 15), (16, 16.5)]\n    }\n]\n\n# Define preferences\npreferences = {\n    'earliest_time': 14.5  # 14:30\n}\n\n# Find meeting time\nmeeting_time = find_meeting_time(\n    participants,\n    duration=30,\n    work_hours=(9, 17),\n    preferences=preferences\n)\n\n# Output the result\nprint(f\"{{{meeting_time[0]}:{meeting_time[1]}}}\")\n```",
            "count": "calendar_scheduling_example_14"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants within work hours.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times (list of tuples).\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences like 'earliest_after'.\n    \n    Returns:\n        Tuple of (start_time, end_time) as strings in HH:MM format.\n    \"\"\"\n    # Convert work hours to minutes since midnight\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Collect all busy intervals\n    busy_intervals = []\n    for person in participants:\n        for start, end in person['busy']:\n            busy_start = start[0] * 60 + start[1]\n            busy_end = end[0] * 60 + end[1]\n            busy_intervals.append((busy_start, busy_end))\n    \n    # Sort busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_end = max(end, last_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Check available slots between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Apply preferences (e.g., earliest after a certain time)\n    if preferences and 'earliest_after' in preferences:\n        earliest_time = preferences['earliest_after'][0] * 60 + preferences['earliest_after'][1]\n        available_slots = [(s, e) for s, e in available_slots if e > earliest_time]\n        available_slots = [(max(s, earliest_time), e) for s, e in available_slots]\n    \n    # Find the first available slot that fits the duration\n    for start, end in available_slots:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return (f\"{start_hh:02d}:{start_mm:02d}\", f\"{end_hh:02d}:{end_mm:02d}\")\n    \n    return None\n\n# Define participants and their busy times\nparticipants = [\n    {\n        'name': 'Joyce',\n        'busy': [\n            ((11, 0), (11, 30)),\n            ((13, 30), (14, 0)),\n            ((14, 30), (16, 30))\n        ]\n    },\n    {\n        'name': 'Christine',\n        'busy': []\n    },\n    {\n        'name': 'Alexander',\n        'busy': [\n            ((9, 0), (11, 0)),\n            ((12, 0), (12, 30)),\n            ((13, 30), (15, 0)),\n            ((15, 30), (16, 0)),\n            ((16, 30), (17, 0))\n        ]\n    }\n]\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (9, 17)\n\n# Define meeting duration (30 minutes)\nduration = 30\n\n# Define preferences (Christine cannot meet before 12:00)\npreferences = {\n    'earliest_after': (12, 0)\n}\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants, duration, work_hours, preferences)\n\n# Output the result in the required format\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{{{start}:{end}}}\")\nelse:\n    print(\"No available time slot found.\")\n```",
            "count": "calendar_scheduling_example_15"
        },
        {
            "final_program_time": "{12:30:12:60}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    # Parse work hours\n    work_start, work_end = [int(time.replace(':', '')) for time in work_hours.split(' to ')]\n    \n    # Generate all possible time slots within work hours\n    time_slots = []\n    current_time = work_start\n    while current_time + duration <= work_end:\n        slot_end = current_time + duration\n        time_slots.append((current_time, slot_end))\n        # Increment by 30 minutes (assuming duration is in 30-min increments)\n        current_time += 30 if duration == 30 else 100 if duration == 100 else 30\n    \n    # Check each time slot against participants' schedules\n    for slot in time_slots:\n        slot_start, slot_end = slot\n        all_available = True\n        for person, schedule in participants.items():\n            for busy_start, busy_end in schedule:\n                busy_start_int = int(busy_start.replace(':', ''))\n                busy_end_int = int(busy_end.replace(':', ''))\n                # Check if slot overlaps with any busy time\n                if not (slot_end <= busy_start_int or slot_start >= busy_end_int):\n                    all_available = False\n                    break\n            if not all_available:\n                break\n        if all_available:\n            # Check preferences if any\n            if preferences and 'before' in preferences:\n                pref_time = int(preferences['before'].replace(':', ''))\n                if slot_start >= pref_time:\n                    continue\n            if preferences and 'after' in preferences:\n                pref_time = int(preferences['after'].replace(':', ''))\n                if slot_start < pref_time:\n                    continue\n            # Format the time slot\n            start_str = f\"{str(slot_start)[:-2]}:{str(slot_start)[-2:]}\" if len(str(slot_start)) > 2 else f\"0{str(slot_start)[0]}:{str(slot_start)[1:]}\"\n            end_str = f\"{str(slot_end)[:-2]}:{str(slot_end)[-2:]}\" if len(str(slot_end)) > 2 else f\"0{str(slot_end)[0]}:{str(slot_end)[1:]}\"\n            return f\"{start_str}:{end_str}\"\n    return \"No available time slot found\"\n\n# Example usage for the given task\nparticipants = {\n    'Scott': [('9:30', '10:30'), ('13:30', '14:00'), ('14:30', '15:00'), ('15:30', '16:00'), ('16:30', '17:00')],\n    'Gabriel': [],\n    'Christine': [('9:00', '10:00'), ('10:30', '12:30'), ('13:00', '17:00')]\n}\nduration = 30  # minutes\nwork_hours = '9:00 to 17:00'\n\nproposed_time = find_meeting_time(participants, duration, work_hours)\nprint(f\"{{{proposed_time}}}\") if proposed_time != \"No available time slot found\" else print(proposed_time)\n```",
            "count": "calendar_scheduling_example_16"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants within work hours.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times (list of tuples).\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences (e.g., 'earliest' or 'not_before').\n    \n    Returns:\n        Tuple of (start_time, end_time) in 'HH:MM' format or None if no slot found.\n    \"\"\"\n    # Convert work hours to minutes for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Collect all busy intervals and convert to minutes\n    busy_intervals = []\n    for person in participants:\n        for start, end in person['busy']:\n            busy_start = start[0] * 60 + start[1]\n            busy_end = end[0] * 60 + end[1]\n            busy_intervals.append((busy_start, busy_end))\n    \n    # Sort busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_end = max(end, last_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Check available slots between merged busy intervals and work hours\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Filter slots based on duration and preferences\n    for slot_start, slot_end in available_slots:\n        slot_duration = slot_end - slot_start\n        if slot_duration >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            \n            # Apply preferences if any\n            if preferences:\n                if preferences.get('not_before'):\n                    not_before = preferences['not_before'][0] * 60 + preferences['not_before'][1]\n                    if meeting_start < not_before:\n                        continue\n                if preferences.get('not_after'):\n                    not_after = preferences['not_after'][0] * 60 + preferences['not_after'][1]\n                    if meeting_start >= not_after:\n                        continue\n            \n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            \n            return (f\"{start_hh:02d}:{start_mm:02d}\", f\"{end_hh:02d}:{end_mm:02d}\")\n    \n    return None\n\n# Define participants and their busy times\nparticipants = [\n    {\n        'name': 'Margaret',\n        'busy': [\n            ((9, 0), (10, 0)),\n            ((10, 30), (11, 0)),\n            ((11, 30), (12, 0)),\n            ((13, 0), (13, 30)),\n            ((15, 0), (15, 30))\n        ]\n    },\n    {\n        'name': 'Donna',\n        'busy': [\n            ((14, 30), (15, 0)),\n            ((16, 0), (16, 30))\n        ]\n    },\n    {\n        'name': 'Helen',\n        'busy': [\n            ((9, 0), (9, 30)),\n            ((10, 0), (11, 30)),\n            ((13, 0), (14, 0)),\n            ((14, 30), (15, 0)),\n            ((15, 30), (17, 0))\n        ]\n    }\n]\n\n# Define preferences (Helen does not want to meet after 13:30)\npreferences = {\n    'not_after': (13, 30)\n}\n\n# Find meeting time (30 minutes between 9:00 and 17:00)\nmeeting_time = find_meeting_time(\n    participants,\n    duration=30,\n    work_hours=(9, 17),\n    preferences=preferences\n)\n\n# Output the result in the required format\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{{{start}:{end}}}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_17"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:00}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours_start, work_hours_end, preferences=None):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's busy slots\n    for participant in participans:\n        busy_slots = participant['busy']\n        new_free_slots = []\n        for free_start, free_end in free_slots:\n            current_start = free_start\n            for busy_start, busy_end in busy_slots:\n                busy_start_min = time_to_minutes(busy_start)\n                busy_end_min = time_to_minutes(busy_end)\n                if busy_start_min > current_start:\n                    new_free_slots.append((current_start, busy_start_min))\n                current_start = max(current_start, busy_end_min)\n            if current_start < free_end:\n                new_free_slots.append((current_start, free_end))\n        free_slots = new_free_slots\n    \n    # Apply preferences if any\n    if preferences:\n        preferred_slots = []\n        for start, end in free_slots:\n            preferred_start = max(start, time_to_minutes(preferences.get('after', '00:00')))\n            preferred_end = min(end, time_to_minutes(preferences.get('before', '23:59')))\n            if preferred_start < preferred_end:\n                preferred_slots.append((preferred_start, preferred_end))\n        free_slots = preferred_slots\n    \n    # Find the earliest slot that fits the duration\n    duration_min = duration * 60\n    for start, end in free_slots:\n        if end - start >= duration_min:\n            meeting_end = start + duration_min\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants and their busy times\nparticipants = [\n    {\n        'name': 'Brian',\n        'busy': []\n    },\n    {\n        'name': 'Billy',\n        'busy': [\n            ('10:00', '10:30'),\n            ('11:30', '12:00'),\n            ('14:00', '14:30'),\n            ('16:30', '17:00')\n        ]\n    },\n    {\n        'name': 'Patricia',\n        'busy': [\n            ('09:00', '12:30'),\n            ('13:30', '14:00'),\n            ('14:30', '16:00'),\n            ('16:30', '17:00')\n        ]\n    }\n]\n\n# Define preferences\npreferences = {\n    'before': '15:30'\n}\n\n# Find the meeting time\nmeeting_time = find_meeting_time(\n    participants,\n    30,\n    '09:00',\n    '17:00',\n    preferences\n)\n\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_18"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Find the earliest available meeting time for all participants within work hours.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times (list of tuples).\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences (e.g., 'earliest' or 'not_before').\n    \n    Returns:\n        Tuple of (start_time, end_time) as strings in HH:MM format.\n    \"\"\"\n    # Convert work hours to minutes since midnight\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Collect all busy intervals and convert to minutes\n    busy_intervals = []\n    for person in participants:\n        for start, end in person['busy']:\n            busy_start = start[0] * 60 + start[1]\n            busy_end = end[0] * 60 + end[1]\n            busy_intervals.append((busy_start, busy_end))\n    \n    # Sort busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Apply preferences (e.g., not before a certain time)\n    if preferences and 'not_before' in preferences:\n        not_before = preferences['not_before'][0] * 60 + preferences['not_before'][1]\n        free_intervals = [(s, e) for s, e in free_intervals if s >= not_before]\n    \n    # Find the first free interval that can fit the meeting\n    duration_min = duration\n    for start, end in free_intervals:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return (f\"{start_hh:02d}:{start_mm:02d}\", f\"{end_hh:02d}:{end_mm:02d}\")\n    \n    return None\n\n# Define the participants and their busy times\nparticipants = [\n    {\n        'name': 'Stephen',\n        'busy': [\n            ((10, 0), (10, 30)),\n            ((13, 0), (13, 30)),\n            ((14, 30), (15, 0)),\n            ((16, 0), (16, 30))\n        ]\n    },\n    {\n        'name': 'Edward',\n        'busy': [\n            ((9, 0), (9, 30)),\n            ((10, 0), (10, 30)),\n            ((13, 30), (14, 30)),\n            ((15, 0), (16, 0))\n        ]\n    },\n    {\n        'name': 'Angela',\n        'busy': [\n            ((9, 0), (11, 30)),\n            ((12, 30), (13, 0)),\n            ((13, 30), (15, 30)),\n            ((16, 0), (17, 0))\n        ]\n    }\n]\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (9, 17)\n\n# Duration is 1 hour (60 minutes)\nduration = 60\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants, duration, work_hours)\n\n# Output the result in the required format\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{{{start}:{end}}}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_19"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants within work hours.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times (list of tuples).\n        duration: Meeting duration in minutes.\n        work_hours: Tuple of (start, end) times as strings in HH:MM format.\n        preferences: Optional dict of preferences (e.g., 'earliest_time').\n    \n    Returns:\n        Tuple of (start, end) times as strings in HH:MM format, or None if no slot found.\n    \"\"\"\n    # Convert work hours and busy times to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to make 9:00 as 0\n    \n    work_start, work_end = map(time_to_minutes, work_hours)\n    duration_min = duration\n    \n    # Process each participant's busy times\n    busy_slots = []\n    for person in participants:\n        person_busy = []\n        for start, end in person['busy']:\n            s = time_to_minutes(start)\n            e = time_to_minutes(end)\n            person_busy.append((s, e))\n        busy_slots.append(person_busy)\n    \n    # Merge all busy slots (union of all participants' busy times)\n    all_busy = []\n    for person in busy_slots:\n        for slot in person:\n            all_busy.append(slot)\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy slots\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots (gaps between busy times)\n    available = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n    \n    # Filter based on preferences (e.g., earliest_time)\n    if preferences and 'earliest_time' in preferences:\n        earliest = time_to_minutes(preferences['earliest_time'])\n        available = [(s, e) for s, e in available if s >= earliest]\n    \n    # Find the first available slot that fits the duration\n    for start, end in available:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            # Convert back to HH:MM format\n            def minutes_to_time(m):\n                hh = (m + 540) // 60\n                mm = (m + 540) % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return (minutes_to_time(meeting_start), minutes_to_time(meeting_end))\n    \n    return None\n\n# Task: Ralph, Peter, Daniel for 30 minutes between 9:00-17:00 on Monday\nparticipants = [\n    {\n        'name': 'Ralph',\n        'busy': [('13:30', '14:00'), ('14:30', '15:00')]\n    },\n    {\n        'name': 'Peter',\n        'busy': [('09:00', '09:30'), ('11:00', '13:00'), ('16:00', '16:30')]\n    },\n    {\n        'name': 'Daniel',\n        'busy': [('09:00', '10:00'), ('10:30', '15:30'), ('16:00', '17:00')]\n    }\n]\n\n# Daniel prefers not to meet after 13:30\npreferences = {'earliest_time': '00:00'}  # No preference on earliest, but filter slots after 13:30\nwork_hours = ('09:00', '17:00')\nduration = 30  # minutes\n\n# Find meeting time\nresult = find_meeting_time(participants, duration, work_hours, preferences)\nif result:\n    start, end = result\n    # Filter out slots after 13:30 for Daniel\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    if time_to_minutes(start) >= time_to_minutes('13:30'):\n        # Look for earlier slots\n        # Re-run with Daniel's preference as a hard constraint\n        participants[2]['busy'].append(('13:30', '17:00'))  # Block after 13:30\n        result = find_meeting_time(participants, duration, work_hours)\n    \n    if result:\n        start, end = result\n        print(f\"{start}:{end}\")\n    else:\n        print(\"No available slot found.\")\nelse:\n    print(\"No available slot found.\")\n```",
            "count": "calendar_scheduling_example_20"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest meeting time that fits all participants' schedules.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences (e.g., 'earliest' or 'after_time').\n    \n    Returns:\n        Tuple of (start_time, end_time) in HH:MM format, or None if no slot found.\n    \"\"\"\n    # Convert work hours to minutes since midnight\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Parse all busy intervals into minutes\n    busy_intervals = []\n    for person in participants:\n        for interval in person['busy']:\n            start_h, start_m = interval[0]\n            end_h, end_m = interval[1]\n            start = start_h * 60 + start_m\n            end = end_h * 60 + end_m\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_end = max(end, last_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Check available slots between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Filter slots that are long enough and meet preferences\n    for slot_start, slot_end in available_slots:\n        slot_duration = slot_end - slot_start\n        if slot_duration >= duration:\n            if preferences and 'after_time' in preferences:\n                after_time = preferences['after_time']\n                after_minutes = after_time[0] * 60 + after_time[1]\n                if slot_start >= after_minutes:\n                    return (slot_start, slot_start + duration)\n            else:\n                return (slot_start, slot_start + duration)\n    \n    return None\n\ndef format_time(minutes):\n    \"\"\"Converts minutes since midnight to HH:MM format.\"\"\"\n    h = minutes // 60\n    m = minutes % 60\n    return f\"{h:02d}:{m:02d}\"\n\n# Define the participants and their busy times\nparticipants = [\n    {\n        'name': 'Bobby',\n        'busy': []\n    },\n    {\n        'name': 'Scott',\n        'busy': [\n            ((11, 30), (12, 00)),\n            ((15, 30), (16, 00))\n        ]\n    },\n    {\n        'name': 'Kimberly',\n        'busy': [\n            ((11, 00), (12, 00)),\n            ((12, 30), (13, 00)),\n            ((13, 30), (14, 00)),\n            ((14, 30), (15, 00)),\n            ((15, 30), (17, 00))\n        ]\n    }\n]\n\n# Meeting duration in minutes (1 hour)\nduration = 60\n\n# Work hours (9:00 to 17:00)\nwork_hours = (9, 17)\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants, duration, work_hours)\n\nif meeting_time:\n    start, end = meeting_time\n    start_str = format_time(start)\n    end_str = format_time(end)\n    print(f\"{{{start_str}:{end_str}}}\")\nelse:\n    print(\"No suitable meeting time found.\")\n```",
            "count": "calendar_scheduling_example_21"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours_start, work_hours_end, preferences=None):\n    # Convert work hours to minutes\n    work_start = work_hours_start * 60\n    work_end = work_hours_end * 60\n    \n    # Initialize the free slots for all participants\n    free_slots = []\n    for participant in participants:\n        busy_slots = participants[participant]\n        free = []\n        prev_end = work_start\n        for start, end in sorted(busy_slots):\n            start_min = start[0] * 60 + start[1]\n            end_min = end[0] * 60 + end[1]\n            if prev_end < start_min:\n                free.append((prev_end, start_min))\n            prev_end = max(prev_end, end_min)\n        if prev_end < work_end:\n            free.append((prev_end, work_end))\n        free_slots.append(free)\n    \n    # Find intersection of all free slots\n    common_free = free_slots[0]\n    for slot_list in free_slots[1:]:\n        new_common = []\n        i = j = 0\n        while i < len(common_free) and j < len(slot_list):\n            start1, end1 = common_free[i]\n            start2, end2 = slot_list[j]\n            start_max = max(start1, start2)\n            end_min = min(end1, end2)\n            if start_max < end_min:\n                new_common.append((start_max, end_min))\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free = new_common\n    \n    # Apply preferences if any\n    if preferences:\n        preferred_slots = []\n        for start, end in common_free:\n            if preferences.get('earliest', False):\n                preferred_slots.append((start, end))\n                break\n            elif preferences.get('after_time', None):\n                after_min = preferences['after_time'][0] * 60 + preferences['after_time'][1]\n                if start >= after_min:\n                    preferred_slots.append((start, end))\n        if preferred_slots:\n            common_free = preferred_slots\n    \n    # Find the first slot that fits the duration\n    duration_min = duration * 60\n    for start, end in common_free:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            # Convert back to HH:MM format\n            start_h = meeting_start // 60\n            start_m = meeting_start % 60\n            end_h = meeting_end // 60\n            end_m = meeting_end % 60\n            return f\"{start_h:02d}:{start_m:02d}-{end_h:02d}:{end_m:02d}\"\n    return \"No suitable time found\"\n\n# Define the participants and their busy slots\nparticipants = {\n    'Theresa': [((9, 0), (9, 30)), ((12, 30), (13, 30)), ((14, 0), (15, 0)), ((16, 30), (17, 0))],\n    'Charles': [((10, 0), (10, 30)), ((11, 30), (12, 30)), ((14, 0), (15, 30))],\n    'Betty': [((9, 0), (10, 30)), ((12, 0), (12, 30)), ((13, 0), (14, 0)), ((15, 0), (16, 0))]\n}\n\n# Call the function\nmeeting_time = find_meeting_time(participants, 1, 9, 17)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_22"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, duration, work_hours_start, work_hours_end, preferences=None):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Generate all possible slots\n    slots = []\n    current = work_start\n    while current + duration <= work_end:\n        slots.append((current, current + duration))\n        current += 1  # Check every minute for availability\n    \n    # Filter slots based on preferences if any\n    if preferences and 'after' in preferences:\n        after_time = time_to_minutes(preferences['after'])\n        slots = [slot for slot in slots if slot[0] >= after_time]\n    \n    # Check each slot against each participant's busy times\n    for slot_start, slot_end in slots:\n        slot_ok = True\n        for participant in participants_busy_times.values():\n            for busy_start, busy_end in participant:\n                busy_start_min = time_to_minutes(busy_start)\n                busy_end_min = time_to_minutes(busy_end)\n                # Check if slot overlaps with any busy time\n                if not (slot_end <= busy_start_min or slot_start >= busy_end_min):\n                    slot_ok = False\n                    break\n            if not slot_ok:\n                break\n        if slot_ok:\n            return f\"{minutes_to_time(slot_start)}:{minutes_to_time(slot_end)}\"\n    return \"No available slot found\"\n\n# Define the participants' busy times\nparticipants_busy_times = {\n    'Billy': [('11:30', '12:00'), ('13:00', '15:00'), ('16:00', '16:30')],\n    'Maria': [('09:00', '09:30'), ('10:00', '10:30'), ('13:00', '13:30'), ('14:00', '14:30')],\n    'William': [('09:30', '10:00'), ('12:00', '12:30'), ('13:30', '15:00'), ('15:30', '17:00')],\n}\n\n# Define meeting parameters\nduration = 60  # minutes\nwork_hours_start = '09:00'\nwork_hours_end = '17:00'\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, duration, work_hours_start, work_hours_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_23"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:9:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants.\n    \n    Args:\n        participants: List of dictionaries with 'name' and 'busy' times.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dictionary of preferences (e.g., 'earliest', 'no_before').\n    \n    Returns:\n        A tuple of (start_time, end_time) in HH:MM format, or None if no slot found.\n    \"\"\"\n    # Convert work hours to minutes for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Collect all busy intervals and merge them\n    all_busy = []\n    for person in participants:\n        for busy in person['busy']:\n            start = busy[0] * 60\n            end = busy[1] * 60\n            all_busy.append((start, end))\n    \n    # Sort busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for busy in all_busy:\n        if not merged:\n            merged.append(busy)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = busy\n            if current_start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_end = max(last_end, current_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append(busy)\n    \n    # Find available slots\n    available = []\n    prev_end = work_start\n    for busy_start, busy_end in merged:\n        if busy_start > prev_end:\n            available.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n    \n    # Filter slots based on duration and preferences\n    for slot in available:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            # Check preferences\n            if preferences:\n                if 'no_before' in preferences:\n                    no_before = preferences['no_before'] * 60\n                    if slot_start < no_before:\n                        continue\n            # Convert back to HH:MM\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = (slot_start + duration) // 60\n            end_mm = (slot_start + duration) % 60\n            return (f\"{start_hh:02d}:{start_mm:02d}\", f\"{end_hh:02d}:{end_mm:02d}\")\n    \n    return None\n\n# Define participants and their busy times\nparticipants = [\n    {\n        'name': 'Benjamin',\n        'busy': []\n    },\n    {\n        'name': 'Hannah',\n        'busy': []\n    },\n    {\n        'name': 'Brenda',\n        'busy': [\n            (9.5, 10.0),\n            (11.5, 12.5),\n            (14.0, 16.5)\n        ]\n    }\n]\n\n# Define meeting constraints\nduration = 30  # minutes\nwork_hours = (9, 17)  # 9:00 to 17:00\npreferences = {\n    'no_before': 9.5  # Benjamin does not want to meet after 9:30\n}\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants, duration, work_hours, preferences)\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{{{start}:{end}}}\")\nelse:\n    print(\"No available time slot found.\")\n```",
            "count": "calendar_scheduling_example_24"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, preferences=None):\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    duration_minutes = duration * 60\n\n    # Combine all busy times and sort them\n    all_busy = []\n    for person in participants:\n        for busy in person['busy']:\n            start, end = busy\n            start_min = start[0] * 60 + start[1]\n            end_min = end[0] * 60 + end[1]\n            all_busy.append((start_min, end_min))\n    \n    # Sort busy intervals by start time\n    all_busy.sort()\n\n    # Find free slots\n    free_slots = []\n    prev_end = work_start\n    for busy_start, busy_end in all_busy:\n        if busy_start > prev_end:\n            free_slots.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n\n    # Filter free slots by duration and preferences\n    possible_slots = []\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration_minutes:\n            possible_slots.append((slot_start, slot_end))\n\n    # Apply preferences if any\n    if preferences:\n        preferred_slots = []\n        for slot_start, slot_end in possible_slots:\n            if preferences.get('before') and slot_start >= preferences['before'] * 60:\n                continue\n            if preferences.get('after') and slot_end <= preferences['after'] * 60:\n                continue\n            preferred_slots.append((slot_start, slot_end))\n        possible_slots = preferred_slots\n\n    if not possible_slots:\n        return None\n\n    # Choose the earliest possible slot\n    chosen_slot = possible_slots[0]\n    start_hour = chosen_slot[0] // 60\n    start_min = chosen_slot[0] % 60\n    end_hour = (chosen_slot[0] + duration_minutes) // 60\n    end_min = (chosen_slot[0] + duration_minutes) % 60\n\n    return f\"{start_hour:02d}:{start_min:02d}-{end_hour:02d}:{end_min:02d}\"\n\n# Define participants and their busy times\nparticipants = [\n    {\n        'name': 'Anthony',\n        'busy': [\n            ((9, 30), (10, 0)),\n            ((12, 0), (13, 0)),\n            ((16, 0), (16, 30))\n        ]\n    },\n    {\n        'name': 'Pamela',\n        'busy': [\n            ((9, 30), (10, 0)),\n            ((16, 30), (17, 0))\n        ]\n    },\n    {\n        'name': 'Zachary',\n        'busy': [\n            ((9, 0), (11, 30)),\n            ((12, 0), (12, 30)),\n            ((13, 0), (13, 30)),\n            ((14, 30), (15, 0)),\n            ((16, 0), (17, 0))\n        ]\n    }\n]\n\n# Define preferences (Pamela doesn't want to meet after 14:30)\npreferences = {\n    'before': 14.5  # 14:30 in decimal\n}\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants, 1, preferences)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_25"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:30:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences like 'earliest_time'.\n    \n    Returns:\n        A string with the proposed meeting time in 'HH:MM-HH:MM' format.\n    \"\"\"\n    # Convert work hours to minutes for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Collect all busy intervals and convert to minutes\n    busy_intervals = []\n    for person in participants:\n        for interval in person['busy']:\n            start_h, start_m = interval[0], interval[1]\n            end_h, end_m = interval[2], interval[3]\n            start = start_h * 60 + start_m\n            end = end_h * 60 + end_m\n            busy_intervals.append((start, end))\n    \n    # Sort busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                new_end = max(last_end, current_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append(interval)\n    \n    # Check available slots between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start\n    \n    for interval in merged:\n        start, end = interval\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that fits the duration\n    duration_min = duration\n    for slot in available_slots:\n        start, end = slot\n        if end - start >= duration_min:\n            # Check preferences if any\n            if preferences and 'earliest_time' in preferences:\n                pref_time = preferences['earliest_time'] * 60\n                if start >= pref_time:\n                    meeting_start = start\n                else:\n                    if end - pref_time >= duration_min:\n                        meeting_start = pref_time\n                    else:\n                        continue\n            else:\n                meeting_start = start\n            \n            # Convert back to HH:MM format\n            start_h = meeting_start // 60\n            start_m = meeting_start % 60\n            end_h = (meeting_start + duration_min) // 60\n            end_m = (meeting_start + duration_min) % 60\n            \n            return f\"{start_h:02d}:{start_m:02d}-{end_h:02d}:{end_m:02d}\"\n    \n    return \"No available time slot found.\"\n\n# Example usage for Katherine, Nicole, Kevin\nparticipants = [\n    {\n        'name': 'Katherine',\n        'busy': []\n    },\n    {\n        'name': 'Nicole',\n        'busy': []\n    },\n    {\n        'name': 'Kevin',\n        'busy': [\n            (9, 0, 10, 0),\n            (10, 30, 11, 30),\n            (12, 0, 15, 30),\n            (16, 30, 17, 0)\n        ]\n    }\n]\n\nduration = 60  # 1 hour\nwork_hours = (9, 17)  # 9:00 to 17:00\n\nproposed_time = find_meeting_time(participants, duration, work_hours)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_26"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start, end) in 'HH:MM' format.\n        preferences: Optional dict with preferences like 'earliest_availability'.\n    \n    Returns:\n        String with proposed time in 'HH:MM-HH:MM' format.\n    \"\"\"\n    # Convert work hours to minutes since midnight\n    start_work = int(work_hours[0].split(':')[0]) * 60 + int(work_hours[0].split(':')[1])\n    end_work = int(work_hours[1].split(':')[0]) * 60 + int(work_hours[1].split(':')[1])\n    \n    # Initialize all available slots as free\n    all_slots = set(range(start_work, end_work - duration + 1))\n    \n    # Process each participant's busy times\n    for person in participants:\n        busy_slots = set()\n        for busy in person['busy']:\n            start_busy = int(busy[0].split(':')[0]) * 60 + int(busy[0].split(':')[1])\n            end_busy = int(busy[1].split(':')[0]) * 60 + int(busy[1].split(':')[1])\n            # Add all slots that overlap with the busy time\n            busy_slots.update(range(start_busy, end_busy))\n        # Remove busy slots from all_slots\n        all_slots -= busy_slots\n    \n    # Apply preferences if any\n    if preferences and 'earliest_availability' in preferences:\n        # Find the earliest available slot\n        if all_slots:\n            start_time = min(all_slots)\n            end_time = start_time + duration\n            return f\"{minutes_to_time(start_time)}-{minutes_to_time(end_time)}\"\n        else:\n            return \"No available time found.\"\n    else:\n        # Default to earliest available\n        if all_slots:\n            start_time = min(all_slots)\n            end_time = start_time + duration\n            return f\"{minutes_to_time(start_time)}-{minutes_to_time(end_time)}\"\n        else:\n            return \"No available time found.\"\n\ndef minutes_to_time(minutes):\n    \"\"\"Converts minutes since midnight to 'HH:MM' format.\"\"\"\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Example usage for the current task\nparticipants = [\n    {\n        'name': 'Jesse',\n        'busy': [('10:00', '10:30'), ('15:30', '16:00')]\n    },\n    {\n        'name': 'Kathryn',\n        'busy': []\n    },\n    {\n        'name': 'Megan',\n        'busy': [('10:30', '11:00'), ('11:30', '12:30'), ('13:30', '14:30'), ('15:00', '16:30')]\n    }\n]\n\nduration = 30  # minutes\nwork_hours = ('9:00', '17:00')\npreferences = {'earliest_availability': True}\n\nproposed_time = find_meeting_time(participants, duration, work_hours, preferences)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_27"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants.\n    \n    Args:\n        participants_busy_times: List of lists, where each inner list contains busy intervals for a participant.\n        work_hours: Tuple (start, end) indicating the working hours.\n        duration: Duration of the meeting in minutes.\n        preferences: Optional dictionary of preferences (e.g., 'earliest' or 'after_time').\n    \n    Returns:\n        A string representing the meeting time in 'HH:MM-HH:MM' format, or None if no time found.\n    \"\"\"\n    # Convert all time intervals to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = map(time_to_minutes, work_hours)\n    duration_minutes = duration\n    \n    # Collect all busy intervals for all participants\n    all_busy = []\n    for participant in participants_busy_times:\n        for interval in participant:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Filter free intervals that meet the duration and preferences\n    for interval in free_intervals:\n        start, end = interval\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            # Check preferences if any\n            if preferences:\n                if 'after_time' in preferences:\n                    after_time = time_to_minutes(preferences['after_time'])\n                    if meeting_start < after_time:\n                        continue\n            return f\"{minutes_to_time(meeting_start)}-{minutes_to_time(meeting_end)}\"\n    \n    return None\n\n# Example usage for the given task\nparticipants_busy_times = [\n    [\"13:00 to 13:30\", \"16:00 to 16:30\"],  # Brittany\n    [],                                     # Emily\n    [\"9:00 to 11:00\", \"11:30 to 14:30\", \"15:00 to 17:00\"]  # Doris\n]\nwork_hours = (\"9:00\", \"17:00\")\nduration = 30  # minutes\npreferences = {'earliest': True}  # Schedule at earliest availability\n\nmeeting_time = find_meeting_time(participants_busy_times, work_hours, duration, preferences)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_28"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences like 'earliest_time'.\n    \n    Returns:\n        String with proposed meeting time in format \"HH:MM - HH:MM\".\n    \"\"\"\n    # Convert work hours to minutes\n    start_work = work_hours[0] * 60\n    end_work = work_hours[1] * 60\n    \n    # Initialize all available slots as free\n    all_slots = set(range(start_work, end_work - duration + 1))\n    \n    # Process each participant's busy times\n    for participant in participants:\n        busy_slots = set()\n        for busy in participant['busy']:\n            start_busy = busy[0] * 60 + busy[1]\n            end_busy = busy[2] * 60 + busy[3]\n            # Add all slots that overlap with the busy time\n            busy_slots.update(range(start_busy, end_busy))\n        # Remove busy slots from all_slots\n        all_slots -= busy_slots\n    \n    # Apply preferences if any\n    if preferences and 'earliest_time' in preferences:\n        earliest_min = preferences['earliest_time'][0] * 60 + preferences['earliest_time'][1]\n        all_slots = {slot for slot in all_slots if slot >= earliest_min}\n    \n    if not all_slots:\n        return \"No available time slot found.\"\n    \n    # Find the earliest available slot\n    meeting_start = min(all_slots)\n    meeting_end = meeting_start + duration\n    \n    # Convert back to HH:MM format\n    start_hh = meeting_start // 60\n    start_mm = meeting_start % 60\n    end_hh = meeting_end // 60\n    end_mm = meeting_end % 60\n    \n    return f\"{start_hh:02d}:{start_mm:02d} - {end_hh:02d}:{end_mm:02d}\"\n\n# Example usage for the current task\nparticipants = [\n    {\n        'name': 'Madison',\n        'busy': [(9, 30, 10, 0), (11, 30, 12, 0)]\n    },\n    {\n        'name': 'Diana',\n        'busy': [(11, 0, 11, 30), (13, 0, 13, 30)]\n    },\n    {\n        'name': 'Shirley',\n        'busy': [(9, 0, 12, 0), (13, 30, 15, 0), (15, 30, 17, 0)]\n    }\n]\n\nduration = 60  # 1 hour\nwork_hours = (9, 17)  # 9:00 to 17:00\n\nproposed_time = find_meeting_time(participants, duration, work_hours)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_29"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours_start, work_hours_end, preferences=None):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's busy slots\n    for participant in participants:\n        busy_slots = participant.get('busy', [])\n        participant_free = []\n        current_start = work_start\n        \n        for busy in busy_slots:\n            busy_start = time_to_minutes(busy[0])\n            busy_end = time_to_minutes(busy[1])\n            \n            if current_start < busy_start:\n                participant_free.append((current_start, busy_start))\n            current_start = max(current_start, busy_end)\n        \n        if current_start < work_end:\n            participant_free.append((current_start, work_end))\n        \n        # Intersect with current free_slots\n        new_free_slots = []\n        i = j = 0\n        while i < len(free_slots) and j < len(participant_free):\n            slot_start, slot_end = free_slots[i]\n            part_start, part_end = participant_free[j]\n            \n            # Find overlap\n            overlap_start = max(slot_start, part_start)\n            overlap_end = min(slot_end, part_end)\n            \n            if overlap_start < overlap_end:\n                new_free_slots.append((overlap_start, overlap_end))\n            \n            # Move the pointer which ends first\n            if slot_end < part_end:\n                i += 1\n            else:\n                j += 1\n        \n        free_slots = new_free_slots\n    \n    # Apply preferences if any\n    if preferences:\n        preferred_slots = []\n        for slot in free_slots:\n            slot_start, slot_end = slot\n            # Check if slot is within preferred time range\n            if 'earliest' in preferences:\n                earliest = time_to_minutes(preferences['earliest'])\n                if slot_end <= earliest:\n                    continue\n                slot_start = max(slot_start, earliest)\n            if 'latest' in preferences:\n                latest = time_to_minutes(preferences['latest'])\n                if slot_start >= latest:\n                    continue\n                slot_end = min(slot_end, latest)\n            if slot_start < slot_end:\n                preferred_slots.append((slot_start, slot_end))\n        free_slots = preferred_slots\n    \n    # Find the earliest slot that fits the duration\n    duration_min = duration * 60\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants and their busy times\nparticipants = [\n    {\n        'name': 'Jeffrey',\n        'busy': [('9:30', '10:00'), ('10:30', '11:00')]\n    },\n    {\n        'name': 'Virginia',\n        'busy': [('9:00', '9:30'), ('10:00', '10:30'), ('14:30', '15:00'), ('16:00', '16:30')]\n    },\n    {\n        'name': 'Melissa',\n        'busy': [('9:00', '11:30'), ('12:00', '12:30'), ('13:00', '15:00'), ('16:00', '17:00')],\n        'preferences': {'latest': '14:00'}\n    }\n]\n\n# Call the function\nmeeting_time = find_meeting_time(\n    participants=participants,\n    duration=0.5,\n    work_hours_start='9:00',\n    work_hours_end='17:00',\n    preferences={'latest': '14:00'}  # Melissa's preference\n)\n\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_30"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants within work hours.\n    \n    Args:\n        participants: A list of dictionaries, each containing 'name' and 'busy' times.\n        duration: Meeting duration in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dictionary of preferences (e.g., 'earliest', 'after_time').\n    \n    Returns:\n        A tuple of (start_time, end_time) in HH:MM format, or None if no slot found.\n    \"\"\"\n    # Convert work hours to minutes since midnight\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Parse all busy intervals into minutes\n    busy_intervals = []\n    for person in participants:\n        for interval in person['busy']:\n            start_h, start_m = interval[0], interval[1]\n            end_h, end_m = interval[2], interval[3]\n            start = start_h * 60 + start_m\n            end = end_h * 60 + end_m\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find free slots by checking gaps between busy intervals and work hours\n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Filter free slots that can fit the meeting duration\n    possible_slots = []\n    for start, end in free_slots:\n        if end - start >= duration:\n            possible_slots.append((start, end))\n    \n    # Apply preferences if any\n    if preferences:\n        if 'after_time' in preferences:\n            after_min = preferences['after_time'][0] * 60 + preferences['after_time'][1]\n            possible_slots = [slot for slot in possible_slots if slot[0] >= after_min]\n    \n    if not possible_slots:\n        return None\n    \n    # Choose the earliest possible slot\n    chosen_slot = possible_slots[0]\n    start_time = chosen_slot[0]\n    end_time = start_time + duration\n    \n    # Convert back to HH:MM format\n    def minutes_to_time(minutes):\n        h = minutes // 60\n        m = minutes % 60\n        return f\"{h:02d}:{m:02d}\"\n    \n    return (minutes_to_time(start_time), minutes_to_time(end_time))\n\n# Define the participants and their busy times for the current task\nparticipants = [\n    {\n        'name': 'Richard',\n        'busy': [(13, 30, 14, 00), (15, 00, 15, 30)]\n    },\n    {\n        'name': 'Martha',\n        'busy': [(9, 00, 9, 30), (13, 00, 13, 30)]\n    },\n    {\n        'name': 'Kimberly',\n        'busy': [(9, 00, 11, 00), (11, 30, 12, 00), (12, 30, 13, 00), (14, 00, 16, 00)]\n    }\n]\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\n\n# Work hours (9:00 to 17:00)\nwork_hours = (9, 17)\n\n# Preferences: Martha does not want to meet before 14:00\npreferences = {'after_time': (14, 00)}\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants, duration, work_hours, preferences)\n\n# Output the result in the specified format\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{{{start}:{end}}}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_31"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, work_hours_start, work_hours_end, duration, preferences=None):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m - 540  # Subtract 540 to start from 0 at 9:00\n\n    def minutes_to_time(minutes):\n        h = (minutes + 540) // 60\n        m = (minutes + 540) % 60\n        return f\"{h:02d}:{m:02d}\"\n\n    # Initialize busy slots for all participants\n    busy_slots = []\n    for participant in participants:\n        for busy in participant['busy']:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_slots.append((start, end))\n    \n    # Sort busy slots by start time\n    busy_slots.sort()\n    \n    # Merge overlapping or adjacent busy slots\n    merged = []\n    for start, end in busy_slots:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1] = (last_start, max(end, last_end))\n            else:\n                merged.append((start, end))\n    \n    # Find free slots between 9:00 and 17:00 (0 to 480 minutes)\n    free_slots = []\n    prev_end = 0\n    for start, end in merged:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < 480:\n        free_slots.append((prev_end, 480))\n    \n    # Filter free slots based on duration and preferences\n    possible_slots = []\n    for start, end in free_slots:\n        if end - start >= duration:\n            possible_slots.append((start, end))\n    \n    # Apply preferences if any\n    if preferences:\n        preferred_slots = []\n        for start, end in possible_slots:\n            slot_start_time = minutes_to_time(start)\n            slot_end_time = minutes_to_time(start + duration)\n            meets_preferences = True\n            for pref in preferences:\n                if pref == 'earliest':\n                    # No action needed, we'll pick the first slot\n                    pass\n                elif pref == 'after_12:30':\n                    if start < time_to_minutes('12:30'):\n                        meets_preferences = False\n                elif pref == 'before_9:30':\n                    if start + duration > time_to_minutes('9:30'):\n                        meets_preferences = False\n            if meets_preferences:\n                preferred_slots.append((start, end))\n        if preferred_slots:\n            possible_slots = preferred_slots\n    \n    # Select the earliest possible slot\n    if possible_slots:\n        start, end = possible_slots[0]\n        meeting_start = minutes_to_time(start)\n        meeting_end = minutes_to_time(start + duration)\n        return f\"{meeting_start}:{meeting_end}\"\n    else:\n        return \"No available slot found\"\n\n# Define participants and their busy times\nparticipants = [\n    {\n        'name': 'Emily',\n        'busy': ['10:00 to 10:30', '11:30 to 12:30', '14:00 to 15:00', '16:00 to 16:30']\n    },\n    {\n        'name': 'Melissa',\n        'busy': ['9:30 to 10:00', '14:30 to 15:00']\n    },\n    {\n        'name': 'Frank',\n        'busy': ['10:00 to 10:30', '11:00 to 11:30', '12:30 to 13:00', '13:30 to 14:30', '15:00 to 16:00', '16:30 to 17:00']\n    }\n]\n\n# Define preferences\npreferences = ['before_9:30']\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants, '9:00', '17:00', 30, preferences)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_32"
        },
        {
            "final_program_time": "{15:00:16:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Find the earliest available meeting time for all participants within work hours.\n    \n    Args:\n        participants: List of dictionaries with 'name' and 'busy' times.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dictionary of preferences (e.g., 'earliest_after').\n    \n    Returns:\n        Tuple of (start_time, end_time) as strings in HH:MM format.\n    \"\"\"\n    # Convert work hours to minutes for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Collect all busy intervals and sort them\n    busy_intervals = []\n    for person in participants:\n        for interval in person['busy']:\n            start = interval[0] * 60\n            end = interval[1] * 60\n            busy_intervals.append((start, end))\n    \n    # Merge overlapping or adjacent busy intervals\n    busy_intervals.sort()\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                new_end = max(last_end, current_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append(interval)\n    \n    # Find the earliest available slot\n    prev_end = work_start\n    for interval in merged:\n        start, end = interval\n        if start > prev_end:\n            available_duration = start - prev_end\n            if available_duration >= duration:\n                # Check preferences if any\n                if preferences and 'earliest_after' in preferences:\n                    earliest_after = preferences['earliest_after'] * 60\n                    if prev_end >= earliest_after:\n                        return (prev_end // 60, (prev_end + duration) // 60)\n                else:\n                    return (prev_end // 60, (prev_end + duration) // 60)\n        prev_end = max(prev_end, end)\n    \n    # Check after the last busy interval\n    if work_end - prev_end >= duration:\n        if preferences and 'earliest_after' in preferences:\n            earliest_after = preferences['earliest_after'] * 60\n            if prev_end >= earliest_after:\n                return (prev_end // 60, (prev_end + duration) // 60)\n        else:\n            return (prev_end // 60, (prev_end + duration) // 60)\n    \n    return None\n\n# Define participants and their busy times\nparticipants = [\n    {\n        'name': 'Lisa',\n        'busy': [(9, 10), (10.5, 11.5), (12.5, 13), (16, 16.5)]\n    },\n    {\n        'name': 'Bobby',\n        'busy': [(9, 9.5), (10, 10.5), (11.5, 12), (15, 15.5)]\n    },\n    {\n        'name': 'Randy',\n        'busy': [(9.5, 10), (10.5, 11), (11.5, 12.5), (13, 13.5), (14.5, 15.5), (16, 16.5)]\n    }\n]\n\n# Define preferences (Bobby wants to avoid after 15:00)\npreferences = {'earliest_after': 15}\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants, 30, (9, 17), preferences)\n\n# Format the output\nif meeting_time:\n    start_h, end_h = meeting_time\n    start_m = int((start_h - int(start_h)) * 60)\n    end_m = int((end_h - int(end_h)) * 60)\n    start_h = int(start_h)\n    end_h = int(end_h)\n    print(f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\")\nelse:\n    print(\"No available time slot found.\")\n```",
            "count": "calendar_scheduling_example_33"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences like 'earliest_time'.\n    \n    Returns:\n        Tuple of (start_time, end_time) in HH:MM format.\n    \"\"\"\n    # Convert work hours to minutes since midnight\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Collect all busy intervals\n    busy_intervals = []\n    for person in participants:\n        for interval in person['busy']:\n            start = interval[0] * 60\n            end = interval[1] * 60\n            busy_intervals.append((start, end))\n    \n    # Sort busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_end = max(end, last_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find free intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check preferences for earliest time constraint\n    earliest_time = work_start\n    if preferences and 'earliest_time' in preferences:\n        earliest_time = max(earliest_time, preferences['earliest_time'] * 60)\n    \n    # Find the first free interval that fits the duration and preferences\n    duration_min = duration * 60\n    for start, end in free_intervals:\n        adjusted_start = max(start, earliest_time)\n        if end - adjusted_start >= duration_min:\n            meeting_start = adjusted_start\n            meeting_end = meeting_start + duration_min\n            # Convert back to HH:MM\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return (f\"{start_hh:02d}:{start_mm:02d}\", f\"{end_hh:02d}:{end_mm:02d}\")\n    \n    return None\n\n# Example usage for Willie, Richard, Noah\nparticipants = [\n    {\n        'name': 'Willie',\n        'busy': []\n    },\n    {\n        'name': 'Richard',\n        'busy': [\n            (10.0, 10.5),\n            (11.0, 12.0),\n            (13.0, 14.0),\n            (16.0, 16.5)\n        ]\n    },\n    {\n        'name': 'Noah',\n        'busy': [\n            (10.0, 10.5),\n            (11.5, 13.0),\n            (13.5, 14.0),\n            (14.5, 17.0)\n        ]\n    }\n]\n\nduration = 60  # 1 hour\nwork_hours = (9.0, 17.0)\nmeeting_time = find_meeting_time(participants, duration, work_hours)\n\nif meeting_time:\n    print(f\"{{{meeting_time[0]}:{meeting_time[1]}}}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_34"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest meeting time that fits all participants' schedules and constraints.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times (list of tuples).\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences (e.g., 'earliest_time').\n    \n    Returns:\n        Tuple of (start_time, end_time) in HH:MM format, or None if no slot found.\n    \"\"\"\n    # Convert work hours to minutes for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Collect all busy intervals and convert to minutes\n    busy_intervals = []\n    for person in participants:\n        for start, end in person['busy']:\n            busy_start = start[0] * 60 + start[1]\n            busy_end = end[0] * 60 + end[1]\n            busy_intervals.append((busy_start, busy_end))\n    \n    # Sort busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                merged[-1] = (last_start, max(last_end, current_end))\n            else:\n                merged.append(interval)\n    \n    # Check available slots between merged busy intervals and work hours\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Filter slots based on duration and preferences\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            if preferences and 'earliest_time' in preferences:\n                earliest_minutes = preferences['earliest_time'][0] * 60 + preferences['earliest_time'][1]\n                if slot_start < earliest_minutes:\n                    continue\n            # Convert back to HH:MM\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = (slot_start + duration) // 60\n            end_mm = (slot_start + duration) % 60\n            return (f\"{start_hh:02d}:{start_mm:02d}\", f\"{end_hh:02d}:{end_mm:02d}\")\n    \n    return None\n\n# Define participants and their busy times\nparticipants = [\n    {\n        'name': 'Bradley',\n        'busy': []\n    },\n    {\n        'name': 'Zachary',\n        'busy': [\n            ((10, 0), (10, 30)),\n            ((15, 0), (15, 30))\n        ]\n    },\n    {\n        'name': 'Teresa',\n        'busy': [\n            ((9, 0), (10, 30)),\n            ((11, 0), (12, 30)),\n            ((13, 0), (14, 0)),\n            ((14, 30), (16, 30))\n        ]\n    }\n]\n\n# Define meeting duration (30 minutes)\nduration = 30\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (9, 17)\n\n# Define preferences (Bradley does not want to meet before 14:30)\npreferences = {\n    'earliest_time': (14, 30)\n}\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants, duration, work_hours, preferences)\n\n# Output the result\nif meeting_time:\n    print(f\"{{{meeting_time[0]}:{meeting_time[1]}}}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_35"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest meeting time that fits all participants' schedules and constraints.\n    \n    Args:\n        participants: List of dictionaries with 'name' and 'busy' times.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dictionary of preferences (e.g., 'earliest' or 'after_time').\n    \n    Returns:\n        A string representing the meeting time in 'HH:MM-HH:MM' format, or None if no time is found.\n    \"\"\"\n    # Convert work hours to minutes since midnight\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Parse busy times for each participant into minute ranges\n    busy_slots = []\n    for participant in participants:\n        participant_busy = []\n        for busy in participant['busy']:\n            start_h, start_m = busy[0], busy[1]\n            end_h, end_m = busy[2], busy[3]\n            start = start_h * 60 + start_m\n            end = end_h * 60 + end_m\n            participant_busy.append((start, end))\n        busy_slots.append(participant_busy)\n    \n    # Generate all possible meeting slots\n    for time in range(work_start, work_end - duration + 1):\n        end_time = time + duration\n        slot_valid = True\n        \n        # Check against each participant's busy slots\n        for participant_busy in busy_slots:\n            for busy_start, busy_end in participant_busy:\n                if not (end_time <= busy_start or time >= busy_end):\n                    slot_valid = False\n                    break\n            if not slot_valid:\n                break\n        \n        # Check preferences if any\n        if slot_valid and preferences:\n            if 'after_time' in preferences:\n                after_min = preferences['after_time'][0] * 60 + preferences['after_time'][1]\n                if time < after_min:\n                    slot_valid = False\n            if 'before_time' in preferences:\n                before_min = preferences['before_time'][0] * 60 + preferences['before_time'][1]\n                if end_time > before_min:\n                    slot_valid = False\n        \n        if slot_valid:\n            # Convert back to HH:MM format\n            start_h = time // 60\n            start_m = time % 60\n            end_h = end_time // 60\n            end_m = end_time % 60\n            return f\"{start_h:02d}:{start_m:02d}-{end_h:02d}:{end_m:02d}\"\n    \n    return None\n\n# Example usage for the current task\nparticipants = [\n    {\n        'name': 'Ryan',\n        'busy': [(9, 0, 9, 30), (12, 30, 13, 0)]\n    },\n    {\n        'name': 'Ruth',\n        'busy': []\n    },\n    {\n        'name': 'Denise',\n        'busy': [(9, 30, 10, 30), (12, 0, 13, 0), (14, 30, 16, 30)]\n    }\n]\n\nduration = 60  # 1 hour\nwork_hours = (9, 17)\npreferences = {'before_time': (12, 30)}  # Denise does not want to meet after 12:30\n\nmeeting_time = find_meeting_time(participants, duration, work_hours, preferences)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_36"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest meeting time that fits all participants' schedules.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times.\n        duration: Meeting duration in minutes.\n        work_hours: Tuple of (start, end) in 'HH:MM' format.\n        preferences: Optional dict with preferences like 'earliest_time'.\n    \n    Returns:\n        String with proposed time slot in 'HH:MM-HH:MM' format.\n    \"\"\"\n    # Convert work hours to minutes since midnight\n    start_work = int(work_hours[0].split(':')[0]) * 60 + int(work_hours[0].split(':')[1])\n    end_work = int(work_hours[1].split(':')[0]) * 60 + int(work_hours[1].split(':')[1])\n    \n    # Parse all busy slots to minutes\n    busy_slots = []\n    for person in participants:\n        for slot in person['busy']:\n            start, end = slot.split(' to ')\n            start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n            end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n            busy_slots.append((start_min, end_min))\n    \n    # Sort busy slots by start time\n    busy_slots.sort()\n    \n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    prev_end = start_work\n    \n    for slot in busy_slots:\n        if slot[0] > prev_end:\n            free_slots.append((prev_end, slot[0]))\n        prev_end = max(prev_end, slot[1])\n    \n    if prev_end < end_work:\n        free_slots.append((prev_end, end_work))\n    \n    # Filter free slots by duration and preferences\n    for slot in free_slots:\n        slot_duration = slot[1] - slot[0]\n        if slot_duration >= duration:\n            if preferences and 'earliest_time' in preferences:\n                pref_time = int(preferences['earliest_time'].split(':')[0]) * 60 + int(preferences['earliest_time'].split(':')[1])\n                if slot[0] >= pref_time:\n                    return format_time(slot[0], slot[0] + duration)\n            else:\n                return format_time(slot[0], slot[0] + duration)\n    \n    return \"No suitable time found.\"\n\ndef format_time(start_min, end_min):\n    \"\"\"Converts minutes to HH:MM format.\"\"\"\n    start_hh = start_min // 60\n    start_mm = start_min % 60\n    end_hh = end_min // 60\n    end_mm = end_min % 60\n    return f\"{start_hh:02d}:{start_mm:02d}-{end_hh:02d}:{end_mm:02d}\"\n\n# Example usage for the current task\nparticipants = [\n    {\n        'name': 'Gregory',\n        'busy': ['11:00 to 11:30', '12:00 to 12:30', '15:30 to 16:30']\n    },\n    {\n        'name': 'Teresa',\n        'busy': []\n    },\n    {\n        'name': 'Carol',\n        'busy': ['9:00 to 10:30', '11:00 to 16:00', '16:30 to 17:00']\n    }\n]\n\nduration = 30  # minutes\nwork_hours = ('9:00', '17:00')\nproposed_time = find_meeting_time(participants, duration, work_hours)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_37"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants within work hours.\n    \n    Args:\n        participants: List of dictionaries with 'name' and 'busy' times.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dictionary of preferences (e.g., 'earliest' or 'after_time').\n    \n    Returns:\n        A string representing the proposed meeting time in 'HH:MM-HH:MM' format.\n    \"\"\"\n    # Convert work hours to minutes for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Generate all possible time slots within work hours\n    time_slots = []\n    current_time = work_start\n    while current_time + duration <= work_end:\n        time_slots.append((current_time, current_time + duration))\n        current_time += 30  # Assuming 30-minute increments for simplicity\n    \n    # Check each time slot against participants' busy times\n    for slot_start, slot_end in time_slots:\n        slot_ok = True\n        for participant in participants:\n            for busy_start, busy_end in participant['busy']:\n                busy_start_min = busy_start[0] * 60 + busy_start[1]\n                busy_end_min = busy_end[0] * 60 + busy_end[1]\n                # Check if slot overlaps with any busy time\n                if not (slot_end <= busy_start_min or slot_start >= busy_end_min):\n                    slot_ok = False\n                    break\n            if not slot_ok:\n                break\n        \n        # Check preferences if any\n        if slot_ok and preferences:\n            if 'after_time' in preferences:\n                after_min = preferences['after_time'][0] * 60 + preferences['after_time'][1]\n                if slot_start < after_min:\n                    slot_ok = False\n        \n        if slot_ok:\n            # Convert back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}-{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time slot found.\"\n\n# Example usage for the given task\nparticipants = [\n    {\n        'name': 'Catherine',\n        'busy': [\n            ((10, 30), (11, 00)),\n            ((12, 30), (13, 30)),\n            ((14, 30), (15, 00))\n        ]\n    },\n    {\n        'name': 'Michael',\n        'busy': [\n            ((9, 30), (10, 30)),\n            ((12, 00), (13, 00)),\n            ((13, 30), (14, 00)),\n            ((15, 00), (15, 30))\n        ]\n    },\n    {\n        'name': 'Alexander',\n        'busy': [\n            ((9, 00), (9, 30)),\n            ((10, 00), (10, 30)),\n            ((11, 00), (12, 00)),\n            ((13, 00), (13, 30)),\n            ((14, 00), (16, 00)),\n            ((16, 30), (17, 00))\n        ]\n    }\n]\n\n# Duration is 30 minutes, work hours are 9:00 to 17:00 (9:00 AM to 5:00 PM)\nduration = 30\nwork_hours = (9, 17)\n\nproposed_time = find_meeting_time(participants, duration, work_hours)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_38"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times (list of tuples).\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences like 'earliest_time' or 'latest_time'.\n    \n    Returns:\n        Tuple of (start_time, end_time) in HH:MM format, or None if no slot found.\n    \"\"\"\n    # Convert work hours to minutes for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Collect all busy intervals and sort them\n    all_busy = []\n    for person in participants:\n        for start, end in person['busy']:\n            all_busy.append((start[0] * 60 + start[1], end[0] * 60 + end[1]))\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1] = (last_start, max(end, last_end))\n            else:\n                merged.append((start, end))\n    \n    # Check available slots between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Filter slots that meet duration and preferences\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            # Check preferences (e.g., earliest availability)\n            if preferences and 'earliest_time' in preferences:\n                pref_time = preferences['earliest_time'][0] * 60 + preferences['earliest_time'][1]\n                if slot_start < pref_time:\n                    continue\n            # Convert back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = (slot_start + duration) // 60\n            end_mm = (slot_start + duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return None\n\n# Define participants and their busy times\nparticipants = [\n    {\n        'name': 'Emily',\n        'busy': []\n    },\n    {\n        'name': 'Victoria',\n        'busy': [\n            ((13, 30), (14, 00)),\n            ((14, 30), (15, 30)),\n            ((16, 30), (17, 00))\n        ]\n    },\n    {\n        'name': 'Nancy',\n        'busy': [\n            ((9, 00), (14, 00)),\n            ((14, 30), (15, 30))\n        ]\n    }\n]\n\n# Define meeting parameters\nduration = 30  # minutes\nwork_hours = (9, 17)  # 9:00 to 17:00\npreferences = {'earliest_time': (9, 0)}  # Schedule at earliest availability\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants, duration, work_hours, preferences)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_39"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Find the earliest meeting time that fits all participants' schedules.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times (list of tuples).\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences (e.g., 'earliest' or 'after_time').\n    \n    Returns:\n        Tuple of (start_time, end_time) in HH:MM format, or None if no time found.\n    \"\"\"\n    # Convert work hours to minutes for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Collect all busy intervals and sort them\n    all_busy = []\n    for person in participants:\n        for start, end in person['busy']:\n            all_busy.append((start[0] * 60 + start[1], end[0] * 60 + end[1]))\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1] = (last_start, max(end, last_end))\n            else:\n                merged.append((start, end))\n    \n    # Check the available slots between busy intervals and work hours\n    available = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n    \n    # Filter available slots by duration and preferences\n    duration_min = duration\n    for slot_start, slot_end in available:\n        if slot_end - slot_start >= duration_min:\n            if preferences and 'after_time' in preferences:\n                after_min = preferences['after_time'][0] * 60 + preferences['after_time'][1]\n                if slot_start < after_min:\n                    continue\n            # Found the earliest suitable slot\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = (slot_start + duration_min) // 60\n            end_mm = (slot_start + duration_min) % 60\n            return (f\"{start_hh:02d}:{start_mm:02d}\", f\"{end_hh:02d}:{end_mm:02d}\")\n    \n    return None\n\n# Example usage for Jacob, Gabriel, and Matthew\nparticipants = [\n    {\n        'name': 'Jacob',\n        'busy': [((10, 0), (11, 0)), ((11, 30), (12, 0)), ((16, 0), (16, 30))]\n    },\n    {\n        'name': 'Gabriel',\n        'busy': [((9, 30), (11, 30)), ((13, 0), (13, 30)), ((15, 0), (15, 30))]\n    },\n    {\n        'name': 'Matthew',\n        'busy': [((9, 0), (9, 30)), ((10, 30), (11, 0)), ((11, 30), (12, 0)), \n                 ((12, 30), (14, 0)), ((15, 30), (16, 30))]\n    }\n]\n\nduration = 60  # 1 hour\nwork_hours = (9, 17)  # 9:00 to 17:00\n\nmeeting_time = find_meeting_time(participants, duration, work_hours)\nif meeting_time:\n    print(f\"{{{meeting_time[0]}:{meeting_time[1]}}}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_40"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:00:16:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Find the earliest available meeting time for all participants.\n    \n    Args:\n        participants: List of dictionaries with 'name' and 'busy' times.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dictionary with preferences like 'earliest_time'.\n    \n    Returns:\n        String with proposed meeting time in 'HH:MM-HH:MM' format.\n    \"\"\"\n    # Convert work hours to minutes for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Collect all busy intervals\n    busy_intervals = []\n    for person in participants:\n        for interval in person['busy']:\n            start = interval[0] * 60\n            end = interval[1] * 60\n            busy_intervals.append((start, end))\n    \n    # Sort intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                new_end = max(last_end, current_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append(interval)\n    \n    # Find available slots\n    available = []\n    prev_end = work_start\n    for interval in merged:\n        start, end = interval\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n    \n    # Apply preferences\n    if preferences and 'earliest_time' in preferences:\n        earliest = preferences['earliest_time'] * 60\n        available = [(s, e) for s, e in available if e > earliest]\n        available = [(max(s, earliest), e) for s, e in available]\n    \n    # Find the first slot that fits the duration\n    duration_min = duration * 60\n    for slot in available:\n        start, end = slot\n        if end - start >= duration_min:\n            meeting_end = start + duration_min\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}-{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time slot found.\"\n\n# Example usage for the current task\nparticipants = [\n    {\n        'name': 'Alan',\n        'busy': []\n    },\n    {\n        'name': 'Nancy',\n        'busy': [(11, 12.5), (13, 13.5), (14, 15)]\n    },\n    {\n        'name': 'Patricia',\n        'busy': [(10, 12), (12.5, 13), (13.5, 16)]\n    }\n]\n\nduration = 0.5  # half hour\nwork_hours = (9, 17)\npreferences = {'earliest_time': 14.5}  # Alan does not want to meet before 14:30\n\nproposed_time = find_meeting_time(participants, duration, work_hours, preferences)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_41"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    # Convert work hours to minutes for easier calculation\n    work_start = convert_to_minutes(work_hours[0])\n    work_end = convert_to_minutes(work_hours[1])\n    \n    # Initialize the free slots for all participants within work hours\n    free_slots = []\n    for participant in participants:\n        busy_slots = participants[participant]\n        free_slots_participant = []\n        prev_end = work_start\n        \n        for busy in sorted(busy_slots, key=lambda x: convert_to_minutes(x[0])):\n            busy_start = convert_to_minutes(busy[0])\n            busy_end = convert_to_minutes(busy[1])\n            \n            if prev_end < busy_start:\n                free_slots_participant.append((prev_end, busy_start))\n            prev_end = max(prev_end, busy_end)\n        \n        if prev_end < work_end:\n            free_slots_participant.append((prev_end, work_end))\n        \n        free_slots.append(free_slots_participant)\n    \n    # Find overlapping free slots\n    common_free_slots = []\n    for slot0 in free_slots[0]:\n        for slot1 in free_slots[1]:\n            for slot2 in free_slots[2]:\n                start = max(slot0[0], slot1[0], slot2[0])\n                end = min(slot0[1], slot1[1], slot2[1])\n                if start < end and (end - start) >= duration:\n                    common_free_slots.append((start, end))\n    \n    # Apply preferences if any\n    if preferences:\n        if 'earliest' in preferences and preferences['earliest']:\n            common_free_slots.sort(key=lambda x: x[0])\n        elif 'after_time' in preferences:\n            after_time = convert_to_minutes(preferences['after_time'])\n            common_free_slots = [slot for slot in common_free_slots if slot[0] >= after_time]\n    \n    if not common_free_slots:\n        return None\n    \n    # Select the first suitable slot\n    selected_slot = common_free_slots[0]\n    start_time = convert_to_hhmm(selected_slot[0])\n    end_time = convert_to_hhmm(selected_slot[0] + duration)\n    \n    return f\"{start_time}:{end_time}\"\n\ndef convert_to_minutes(time_str):\n    hours, minutes = map(int, time_str.split(':'))\n    return hours * 60 + minutes\n\ndef convert_to_hhmm(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Example usage for the given task\nparticipants = {\n    'Julie': [('9:00', '9:30'), ('11:00', '11:30'), ('12:00', '12:30'), ('13:30', '14:00'), ('16:00', '17:00')],\n    'Sean': [('9:00', '9:30'), ('13:00', '13:30'), ('15:00', '15:30'), ('16:00', '16:30')],\n    'Lori': [('10:00', '10:30'), ('11:00', '13:00'), ('15:30', '17:00')]\n}\n\nduration = 60  # minutes\nwork_hours = ('9:00', '17:00')\n\nmeeting_time = find_meeting_time(participants, duration, work_hours)\nprint(f\"{{{meeting_time.replace('-', ':')}}}\")\n```",
            "count": "calendar_scheduling_example_42"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants within work hours.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times (list of tuples).\n        duration: Meeting duration in minutes.\n        work_hours: Tuple of (start, end) in 'HH:MM' format.\n        preferences: Optional dict with preferences (e.g., 'earliest' or 'after' time).\n    \n    Returns:\n        Tuple of (start, end) in 'HH:MM' format or None if no slot found.\n    \"\"\"\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = map(time_to_minutes, work_hours)\n    duration_min = duration\n    \n    # Collect all busy intervals\n    busy_intervals = []\n    for person in participants:\n        for start, end in person['busy']:\n            busy_start = time_to_minutes(start)\n            busy_end = time_to_minutes(end)\n            busy_intervals.append((busy_start, busy_end))\n    \n    # Add work hours boundaries as busy times outside\n    busy_intervals.append((0, work_start))\n    busy_intervals.append((work_end, 24 * 60))\n    \n    # Sort intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1] = (last_start, max(end, last_end))\n            else:\n                merged.append((start, end))\n    \n    # Find the earliest available slot\n    previous_end = work_start\n    for start, end in merged:\n        if start > previous_end:\n            available_start = previous_end\n            available_end = start\n            if available_end - available_start >= duration_min:\n                meeting_start = available_start\n                if preferences and 'after' in preferences:\n                    after_time = time_to_minutes(preferences['after'])\n                    meeting_start = max(meeting_start, after_time)\n                if meeting_start + duration_min <= available_end:\n                    return (minutes_to_time(meeting_start), \n                            minutes_to_time(meeting_start + duration_min))\n        previous_end = max(previous_end, end)\n    \n    return None\n\n# Example usage for the given task\nparticipants = [\n    {\n        'name': 'Albert',\n        'busy': [('09:30', '10:30'), ('12:00', '12:30'), ('14:00', '14:30'), \n                 ('15:00', '15:30'), ('16:30', '17:00')]\n    },\n    {\n        'name': 'Gregory',\n        'busy': [('11:00', '11:30'), ('12:30', '13:00'), ('13:30', '14:00'), \n                 ('15:30', '16:00')]\n    },\n    {\n        'name': 'Benjamin',\n        'busy': [('09:30', '10:00'), ('10:30', '11:00'), ('11:30', '13:30'), \n                 ('14:00', '15:00'), ('15:30', '16:00'), ('16:30', '17:00')]\n    }\n]\n\nduration = 30\nwork_hours = ('09:00', '17:00')\npreferences = {'earliest': True}\n\nresult = find_meeting_time(participants, duration, work_hours, preferences)\nif result:\n    start, end = result\n    print(f\"{start}:{end}\")\nelse:\n    print(\"No available time slot found.\")\n```",
            "count": "calendar_scheduling_example_43"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    # Convert work hours to minutes\n    start_work, end_work = [int(t.split(':')[0]) * 60 + int(t.split(':')[1]) for t in work_hours.split('-')]\n    \n    # Initialize busy slots for all participants\n    busy_slots = []\n    for participant in participants:\n        busy = []\n        for block in participant['busy']:\n            start, end = [int(t.split(':')[0]) * 60 + int(t.split(':')[1]) for t in block.split('-')]\n            busy.append((start, end))\n        busy_slots.append(busy)\n    \n    # Generate all possible slots\n    possible_slots = []\n    current_time = start_work\n    while current_time + duration <= end_work:\n        slot_end = current_time + duration\n        valid = True\n        \n        # Check against each participant's busy slots\n        for i in range(len(participants)):\n            for busy_start, busy_end in busy_slots[i]:\n                if not (slot_end <= busy_start or current_time >= busy_end):\n                    valid = False\n                    break\n            if not valid:\n                break\n        \n        # Check preferences if any\n        if valid and preferences:\n            for name, pref in preferences.items():\n                if name == participant['name']:\n                    if 'before' in pref and slot_end > int(pref['before'].split(':')[0]) * 60 + int(pref['before'].split(':')[1]):\n                        valid = False\n                    if 'after' in pref and current_time < int(pref['after'].split(':')[0]) * 60 + int(pref['after'].split(':')[1]):\n                        valid = False\n        \n        if valid:\n            possible_slots.append((current_time, slot_end))\n        \n        current_time += 30  # Check in 30-minute increments\n    \n    if not possible_slots:\n        return None\n    \n    # Return the earliest possible slot\n    start, end = possible_slots[0]\n    return f\"{start // 60:02d}:{start % 60:02d}-{end // 60:02d}:{end % 60:02d}\"\n\n# Define participants and their busy times\nparticipants = [\n    {'name': 'Isabella', 'busy': []},\n    {'name': 'Ronald', 'busy': ['11:30-12:00', '14:00-14:30', '16:00-17:00']},\n    {'name': 'Amanda', 'busy': ['9:30-12:00', '12:30-13:00', '13:30-14:00', '15:30-17:00']}\n]\n\n# Define preferences\npreferences = {'Isabella': {'before': '13:00'}}\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants, 30, '9:00-17:00', preferences)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_44"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Find the earliest available meeting time for all participants.\n    \n    Args:\n        participants: List of dictionaries with 'busy' times.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dictionary of preferences (e.g., 'earliest_after').\n    \n    Returns:\n        Tuple of (start_time, end_time) in HH:MM format.\n    \"\"\"\n    # Convert work hours to minutes\n    start_work = work_hours[0] * 60\n    end_work = work_hours[1] * 60\n    \n    # Generate all busy slots in minutes\n    busy_slots = []\n    for person in participants:\n        for busy in person['busy']:\n            start = busy[0] * 60\n            end = busy[1] * 60\n            busy_slots.append((start, end))\n    \n    # Sort busy slots by start time\n    busy_slots.sort()\n    \n    # Merge overlapping or adjacent busy slots\n    merged = []\n    for start, end in busy_slots:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_end = max(end, last_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Check available slots between busy times and work hours\n    available = []\n    prev_end = start_work\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < end_work:\n        available.append((prev_end, end_work))\n    \n    # Apply preferences (e.g., earliest after a certain time)\n    if preferences and 'earliest_after' in preferences:\n        earliest_after = preferences['earliest_after'] * 60\n        available = [(s, e) for s, e in available if e > earliest_after]\n        available = [(max(s, earliest_after), e) for s, e in available]\n    \n    # Find the first available slot that fits the duration\n    duration_min = duration * 60\n    for start, end in available:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return (meeting_start // 60, meeting_start % 60), (meeting_end // 60, meeting_end % 60)\n    \n    return None\n\n# Define participants and their busy times\nparticipants = [\n    {\n        'name': 'Andrew',\n        'busy': []\n    },\n    {\n        'name': 'Grace',\n        'busy': []\n    },\n    {\n        'name': 'Samuel',\n        'busy': [\n            (9, 10.5),\n            (11.5, 12),\n            (13, 13.5),\n            (14, 16),\n            (16.5, 17)\n        ]\n    }\n]\n\n# Define meeting constraints\nduration = 0.5  # half an hour\nwork_hours = (9, 17)  # 9:00 to 17:00\npreferences = {'earliest_after': 9}  # earliest availability\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants, duration, work_hours, preferences)\n\n# Format output\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{start[0]:02d}:{start[1]:02d}:{end[0]:02d}:{end[1]:02d}\")\nelse:\n    print(\"No available time found.\")\n```",
            "count": "calendar_scheduling_example_45"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants within work hours.\n    \n    Args:\n        participants: List of dictionaries with 'busy' times in HH:MM format.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start, end) times in HH:MM format.\n        preferences: Optional dictionary of preferences (e.g., 'earliest' or time constraints).\n    \n    Returns:\n        String with proposed meeting time in HH:MM-HH:MM format.\n    \"\"\"\n    # Convert all times to minutes since 00:00 for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start, work_end = map(time_to_minutes, work_hours)\n    duration_min = duration * 60 if isinstance(duration, float) else duration  # Handle half-hour as 30 mins\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for person in participants:\n        for busy in person['busy']:\n            start, end = map(time_to_minutes, busy.split('-'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Check each available slot for sufficient duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_min:\n            # Check if this slot fits Mason's preference (after 12:30)\n            if preferences and 'after' in preferences:\n                after_time = time_to_minutes(preferences['after'])\n                if slot_start >= after_time:\n                    return f\"{minutes_to_time(slot_start)}-{minutes_to_time(slot_start + duration_min)}\"\n            else:\n                return f\"{minutes_to_time(slot_start)}-{minutes_to_time(slot_start + duration_min)}\"\n    \n    return \"No available slot found.\"\n\ndef minutes_to_time(minutes):\n    \"\"\"Convert minutes since 00:00 back to HH:MM format.\"\"\"\n    hh = minutes // 60\n    mm = minutes % 60\n    return f\"{hh:02d}:{mm:02d}\"\n\n# Example usage for Arthur, Theresa, Carl\nparticipants = [\n    {'busy': ['09:30-10:00', '14:00-14:30']},  # Arthur\n    {'busy': ['09:00-09:30', '12:00-13:00', '15:00-16:30']},  # Theresa\n    {'busy': ['09:00-11:30', '12:00-14:00', '14:30-17:00']},  # Carl\n]\n\nduration = 30  # minutes\nwork_hours = ('09:00', '17:00')\npreferences = None  # No specific preferences for this task\n\nproposed_time = find_meeting_time(participants, duration, work_hours, preferences)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_46"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours_start, work_hours_end, preferences=None):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's busy slots\n    for participant in participants:\n        busy_slots = participant.get('busy', [])\n        new_free_slots = []\n        for slot in free_slots:\n            current_start = slot[0]\n            for busy in busy_slots:\n                busy_start = time_to_minutes(busy[0])\n                busy_end = time_to_minutes(busy[1])\n                if busy_start > current_start:\n                    new_free_slots.append((current_start, busy_start))\n                current_start = max(current_start, busy_end)\n            if current_start < slot[1]:\n                new_free_slots.append((current_start, slot[1]))\n        free_slots = new_free_slots\n    \n    # Apply preferences if any\n    if preferences:\n        preferred_slots = []\n        for slot in free_slots:\n            slot_start = slot[0]\n            slot_end = slot[1]\n            if 'after' in preferences:\n                after_time = time_to_minutes(preferences['after'])\n                if slot_start < after_time:\n                    slot_start = after_time\n            if 'before' in preferences:\n                before_time = time_to_minutes(preferences['before'])\n                if slot_end > before_time:\n                    slot_end = before_time\n            if slot_start < slot_end:\n                preferred_slots.append((slot_start, slot_end))\n        free_slots = preferred_slots\n    \n    # Find the earliest slot that fits the duration\n    duration_min = duration * 60\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants and their busy slots\nparticipants = [\n    {\n        'name': 'David',\n        'busy': []\n    },\n    {\n        'name': 'Eric',\n        'busy': [\n            ('09:00', '09:30'),\n            ('10:30', '11:30'),\n            ('15:00', '15:30')\n        ]\n    },\n    {\n        'name': 'Roger',\n        'busy': [\n            ('09:30', '10:30'),\n            ('11:00', '12:00'),\n            ('12:30', '13:00'),\n            ('14:30', '15:00'),\n            ('15:30', '16:30')\n        ]\n    }\n]\n\n# Find meeting time\nmeeting_time = find_meeting_time(\n    participants,\n    duration=60,\n    work_hours_start='09:00',\n    work_hours_end='17:00'\n)\n\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_47"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours_start, work_hours_end, preferences=None):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        h = minutes // 60\n        m = minutes % 60\n        return f\"{h:02d}:{m:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's busy slots\n    for participant in participants:\n        busy_slots = participant.get('busy', [])\n        participant_free = []\n        current_start = work_start\n        \n        for busy in busy_slots:\n            busy_start = time_to_minutes(busy[0])\n            busy_end = time_to_minutes(busy[1])\n            if current_start < busy_start:\n                participant_free.append((current_start, busy_start))\n            current_start = max(current_start, busy_end)\n        \n        if current_start < work_end:\n            participant_free.append((current_start, work_end))\n        \n        # Intersect with existing free slots\n        new_free_slots = []\n        i = j = 0\n        while i < len(free_slots) and j < len(participant_free):\n            slot_start, slot_end = free_slots[i]\n            part_start, part_end = participant_free[j]\n            \n            # Find overlap\n            start = max(slot_start, part_start)\n            end = min(slot_end, part_end)\n            if start < end:\n                new_free_slots.append((start, end))\n            \n            # Move the pointer which ends first\n            if slot_end < part_end:\n                i += 1\n            else:\n                j += 1\n        \n        free_slots = new_free_slots\n    \n    # Apply preferences if any\n    if preferences:\n        preferred_start = time_to_minutes(preferences.get('after', '00:00'))\n        free_slots = [(s, e) for s, e in free_slots if s >= preferred_start]\n    \n    # Find the earliest slot that fits the duration\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants and their busy times\nparticipants = [\n    {\n        'name': 'Janet',\n        'busy': [('09:30', '10:30'), ('12:30', '13:00'), ('14:00', '14:30')]\n    },\n    {\n        'name': 'Rachel',\n        'busy': []\n    },\n    {\n        'name': 'Cynthia',\n        'busy': [('09:30', '10:00'), ('11:00', '11:30'), ('12:30', '14:30'), ('16:00', '17:00')],\n        'preferences': {'after': '13:30'}\n    }\n]\n\n# Meeting duration in minutes (1 hour)\nduration = 60\nwork_hours_start = '09:00'\nwork_hours_end = '17:00'\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants, duration, work_hours_start, work_hours_end, preferences={'after': '13:30'})\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_48"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest meeting time that fits all participants' schedules.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start, end) in 'HH:MM' format.\n        preferences: Optional dict with preferences like 'earliest' or 'latest'.\n    \n    Returns:\n        A tuple of (start, end) in 'HH:MM' format or None if no slot found.\n    \"\"\"\n    # Convert work hours to minutes since midnight\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start, work_end = map(time_to_minutes, work_hours)\n    \n    # Collect all busy slots and convert to minutes\n    busy_slots = []\n    for person in participants:\n        for busy in person['busy']:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_slots.append((start, end))\n    \n    # Sort busy slots by start time\n    busy_slots.sort()\n    \n    # Find free slots by merging busy intervals\n    free_slots = []\n    prev_end = work_start\n    for start, end in busy_slots:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Check each free slot for availability for all participants\n    for slot_start, slot_end in free_slots:\n        slot_duration = slot_end - slot_start\n        if slot_duration >= duration:\n            # Check if this slot is free for all participants\n            valid = True\n            for person in participants:\n                person_busy = False\n                for busy in person['busy']:\n                    busy_start, busy_end = map(time_to_minutes, busy.split(' to '))\n                    # Check if busy overlaps with the proposed slot\n                    if not (busy_end <= slot_start or busy_start >= slot_start + duration):\n                        person_busy = True\n                        break\n                if person_busy:\n                    valid = False\n                    break\n            if valid:\n                # Convert back to HH:MM\n                def minutes_to_time(minutes):\n                    hh = minutes // 60\n                    mm = minutes % 60\n                    return f\"{hh:02d}:{mm:02d}\"\n                return (minutes_to_time(slot_start), minutes_to_time(slot_start + duration))\n    \n    return None\n\n# Define participants and their busy times\nparticipants = [\n    {\n        'name': 'Teresa',\n        'busy': [\n            '9:00 to 10:00',\n            '13:00 to 13:30',\n            '14:00 to 14:30',\n            '15:00 to 15:30',\n            '16:30 to 17:00'\n        ]\n    },\n    {\n        'name': 'Kathleen',\n        'busy': [\n            '9:00 to 9:30',\n            '12:30 to 13:00',\n            '13:30 to 14:00',\n            '15:00 to 15:30'\n        ]\n    },\n    {\n        'name': 'Patricia',\n        'busy': [\n            '9:00 to 10:30',\n            '11:30 to 12:00',\n            '13:00 to 13:30',\n            '14:00 to 14:30',\n            '15:30 to 16:00',\n            '16:30 to 17:00'\n        ]\n    }\n]\n\n# Preferences: Kathleen would rather not meet after 14:30\n# We can adjust the free slots to end before 14:30\nwork_hours = ('9:00', '17:00')\nduration = 30  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants, duration, work_hours)\n\n# Apply Kathleen's preference to not meet after 14:30\nif meeting_time:\n    start, end = meeting_time\n    start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n    if start_min >= 14 * 60 + 30:\n        # Need to find another slot before 14:30\n        # Re-run with adjusted work hours\n        meeting_time = find_meeting_time(participants, duration, ('9:00', '14:30'))\n\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{start}:{end}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_49"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, duration, work_hours, preference=None):\n    # Convert work hours to minutes\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Generate all possible time slots within work hours\n    time_slots = []\n    current_time = work_start\n    while current_time + duration <= work_end:\n        time_slots.append((current_time, current_time + duration))\n        current_time += 30  # Assuming 30-minute increments for simplicity\n    \n    # Check each time slot against participants' busy times\n    for slot in time_slots:\n        slot_start, slot_end = slot\n        valid = True\n        \n        for busy_times in participants_busy_times:\n            for busy_start, busy_end in busy_times:\n                busy_start_min = busy_start[0] * 60 + busy_start[1]\n                busy_end_min = busy_end[0] * 60 + busy_end[1]\n                if not (slot_end <= busy_start_min or slot_start >= busy_end_min):\n                    valid = False\n                    break\n            if not valid:\n                break\n        \n        if valid:\n            if preference == 'earliest':\n                return slot\n            # Additional preference checks can be added here\n    \n    return None\n\n# Define the participants' busy times in (HH, MM) format\ndaniel_busy = []\nroy_busy = []\nemma_busy = [\n    ((9, 0), (10, 30)),\n    ((11, 0), (12, 0)),\n    ((12, 30), (13, 30)),\n    ((14, 30), (15, 30)),\n    ((16, 0), (16, 30))\n]\n\nparticipants_busy_times = [daniel_busy, roy_busy, emma_busy]\nduration = 60  # minutes\nwork_hours = (9, 17)  # 9:00 to 17:00\n\n# Find the meeting time\nmeeting_slot = find_meeting_time(participants_busy_times, duration, work_hours)\n\n# Convert the slot back to HH:MM format\nif meeting_slot:\n    start_hh = meeting_slot[0] // 60\n    start_mm = meeting_slot[0] % 60\n    end_hh = meeting_slot[1] // 60\n    end_mm = meeting_slot[1] % 60\n    print(f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_50"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest meeting time that fits all participants' schedules.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences like 'earliest_time'.\n    \n    Returns:\n        Tuple of (start_time, end_time) as strings in HH:MM format.\n    \"\"\"\n    # Convert work hours to minutes since midnight\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Parse all busy times into ranges of minutes since midnight\n    busy_ranges = []\n    for person in participants:\n        for busy in person['busy']:\n            start = busy[0] * 60 + busy[1]\n            end = busy[2] * 60 + busy[3]\n            busy_ranges.append((start, end))\n    \n    # Sort busy ranges by start time\n    busy_ranges.sort()\n    \n    # Find all free slots within work hours\n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in busy_ranges:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Check each free slot for availability\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            # Check if slot fits preferences\n            if preferences and 'earliest_time' in preferences:\n                pref_time = preferences['earliest_time'][0] * 60 + preferences['earliest_time'][1]\n                if slot_start < pref_time:\n                    continue\n            \n            # Convert back to HH:MM format\n            start_h = slot_start // 60\n            start_m = slot_start % 60\n            end_h = (slot_start + duration) // 60\n            end_m = (slot_start + duration) % 60\n            \n            return (\n                f\"{start_h:02d}:{start_m:02d}\",\n                f\"{end_h:02d}:{end_m:02d}\"\n            )\n    \n    return None\n\n# Define participants and their busy times\nparticipants = [\n    {\n        'name': 'Brandon',\n        'busy': [\n            (11, 30, 12, 0),\n            (12, 30, 13, 30),\n            (14, 0, 14, 30)\n        ]\n    },\n    {\n        'name': 'Donna',\n        'busy': [\n            (10, 0, 10, 30),\n            (12, 0, 12, 30)\n        ]\n    },\n    {\n        'name': 'Jack',\n        'busy': [\n            (9, 30, 10, 0),\n            (10, 30, 11, 0),\n            (11, 30, 12, 30),\n            (13, 0, 14, 30),\n            (15, 30, 17, 0)\n        ]\n    }\n]\n\n# Find meeting time\nmeeting_time = find_meeting_time(\n    participants=participants,\n    duration=60,\n    work_hours=(9, 17)\n)\n\n# Output the result\nprint(f\"{{{meeting_time[0]}:{meeting_time[1]}}}\") if meeting_time else print(\"No time found\")\n```",
            "count": "calendar_scheduling_example_51"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Find the earliest available meeting time for all participants.\n    \n    Args:\n        participants (list): List of dictionaries with 'name' and 'busy' times.\n        duration (int): Duration of the meeting in minutes.\n        work_hours (tuple): Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences (dict): Optional preferences like 'earliest' or 'after_time'.\n    \n    Returns:\n        str: Proposed meeting time in 'HH:MM-HH:MM' format.\n    \"\"\"\n    start_work, end_work = work_hours\n    time_slots = []\n    \n    # Convert work hours to minutes\n    start_min = start_work * 60\n    end_min = end_work * 60\n    \n    # Generate all possible time slots within work hours\n    for start in range(start_min, end_min - duration + 1, 15):\n        end = start + duration\n        time_slots.append((start, end))\n    \n    # Check each time slot against participants' busy times\n    for slot in time_slots:\n        slot_start, slot_end = slot\n        valid = True\n        \n        for person in participants:\n            for busy in person['busy']:\n                busy_start = busy[0] * 60 + busy[1]\n                busy_end = busy[2] * 60 + busy[3]\n                \n                # Check for overlap\n                if not (slot_end <= busy_start or slot_start >= busy_end):\n                    valid = False\n                    break\n            \n            if not valid:\n                break\n        \n        # Check preferences if any\n        if valid and preferences:\n            if 'after_time' in preferences:\n                after_min = preferences['after_time'][0] * 60 + preferences['after_time'][1]\n                if slot_start < after_min:\n                    valid = False\n        \n        if valid:\n            # Convert slot back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}-{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time slot found.\"\n\n# Example usage for Grace, Randy, and Susan\nparticipants = [\n    {\n        'name': 'Grace',\n        'busy': [(9, 0, 9, 30), (10, 0, 11, 0), (16, 0, 16, 30)]\n    },\n    {\n        'name': 'Randy',\n        'busy': [(12, 30, 13, 0), (16, 0, 16, 30)]\n    },\n    {\n        'name': 'Susan',\n        'busy': [(9, 0, 14, 30), (15, 30, 16, 0)]\n    }\n]\n\nduration = 60  # 1 hour\nwork_hours = (9, 17)  # 9:00 to 17:00\n\nproposed_time = find_meeting_time(participants, duration, work_hours)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_52"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{15:30:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours_start, work_hours_end, preferences=None):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        h = minutes // 60\n        m = minutes % 60\n        return f\"{h:02d}:{m:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's busy slots\n    for participant in participants:\n        busy_slots = participant.get('busy', [])\n        new_free_slots = []\n        \n        for free_start, free_end in free_slots:\n            current_start = free_start\n            for busy_start, busy_end in busy_slots:\n                busy_start_min = time_to_minutes(busy_start)\n                busy_end_min = time_to_minutes(busy_end)\n                \n                if busy_start_min > current_start:\n                    new_free_slots.append((current_start, busy_start_min))\n                current_start = max(current_start, busy_end_min)\n            \n            if current_start < free_end:\n                new_free_slots.append((current_start, free_end))\n        \n        free_slots = new_free_slots\n    \n    # Apply preferences if any\n    if preferences:\n        preferred_start = time_to_minutes(preferences.get('after', work_hours_start))\n        free_slots = [(start, end) for start, end in free_slots if start >= preferred_start]\n    \n    # Find the earliest slot that fits the duration\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Example usage for the given task\nparticipants = [\n    {'name': 'Noah', 'busy': []},\n    {'name': 'Alice', 'busy': [('9:30', '10:00'), ('12:30', '13:00'), ('14:30', '15:00'), ('16:30', '17:00')]},\n    {'name': 'Arthur', 'busy': [('9:00', '9:30'), ('10:00', '11:00'), ('11:30', '12:00'), ('13:00', '14:00'), ('15:00', '15:30'), ('16:30', '17:00')]}\n]\n\nduration = 60  # minutes\nwork_hours_start = '9:00'\nwork_hours_end = '17:00'\n\nmeeting_time = find_meeting_time(participants, duration, work_hours_start, work_hours_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_53"
        },
        {
            "final_program_time": "{16:00:17:00}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Find the earliest available meeting time for all participants.\n    \n    Args:\n        participants: List of dicts with each participant's busy times.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences (e.g., 'earliest' or 'after_time').\n    \n    Returns:\n        Tuple of (start_time, end_time) in HH:MM format.\n    \"\"\"\n    # Convert work hours to minutes for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Generate all possible time slots within work hours\n    time_slots = []\n    current_time = work_start\n    while current_time + duration <= work_end:\n        time_slots.append((current_time, current_time + duration))\n        current_time += 15  # Check every 15 minutes for granularity\n    \n    # Check each time slot against all participants' schedules\n    for slot in time_slots:\n        slot_start, slot_end = slot\n        valid = True\n        \n        # Check against each participant's busy times\n        for participant in participants:\n            for busy_start, busy_end in participant['busy']:\n                busy_start_min = busy_start[0] * 60 + busy_start[1]\n                busy_end_min = busy_end[0] * 60 + busy_end[1]\n                \n                # Check for overlap\n                if not (slot_end <= busy_start_min or slot_start >= busy_end_min):\n                    valid = False\n                    break\n            \n            if not valid:\n                break\n        \n        # Check preferences if any\n        if valid and preferences:\n            if 'after_time' in preferences:\n                after_min = preferences['after_time'][0] * 60 + preferences['after_time'][1]\n                if slot_start < after_min:\n                    valid = False\n            # Add other preference checks as needed\n        \n        if valid:\n            # Convert back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return (f\"{start_hh:02d}:{start_mm:02d}\", f\"{end_hh:02d}:{end_mm:02d}\")\n    \n    return None\n\n# Define participants and their busy times\nparticipants = [\n    {\n        'name': 'Isabella',\n        'busy': [\n            ((11, 0), (11, 30)),\n            ((15, 30), (16, 0))\n        ]\n    },\n    {\n        'name': 'Tyler',\n        'busy': [\n            ((9, 0), (10, 0))\n        ]\n    },\n    {\n        'name': 'Jordan',\n        'busy': [\n            ((9, 0), (10, 0)),\n            ((10, 30), (11, 0)),\n            ((12, 30), (13, 30)),\n            ((14, 0), (14, 30)),\n            ((15, 0), (16, 0))\n        ]\n    }\n]\n\n# Define preferences (Tyler cannot meet after 16:00)\npreferences = {\n    'after_time': (16, 0)  # Not used directly, but slot_end must be <= 16:00\n}\n\n# Find meeting time (1 hour duration, work hours 9:00-17:00)\nmeeting_time = find_meeting_time(\n    participants,\n    60,\n    (9, 17),\n    preferences\n)\n\n# Output in HH:MM:HH:MM format\nif meeting_time:\n    print(f\"{meeting_time[0]}:{meeting_time[1]}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_54"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:30}",
            "type_error": "TypeError",
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants within work hours.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times (list of tuples).\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences (e.g., 'earliest' or 'after_time').\n    \n    Returns:\n        Tuple of (start_time, end_time) in HH:MM format, or None if no slot found.\n    \"\"\"\n    # Convert work hours to minutes for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Collect all busy intervals and sort them\n    all_busy = []\n    for person in participants:\n        for start, end in person['busy']:\n            all_busy.append((start[0] * 60 + start[1], end[0] * 60 + end[1]))\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1] = (last_start, max(end, last_end))\n            else:\n                merged.append((start, end))\n    \n    # Check available slots between busy intervals and work hours\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available_start = prev_end\n            available_end = start\n            if available_end - available_start >= duration:\n                # Check if this slot meets preferences\n                if preferences and 'after_time' in preferences:\n                    after_min = preferences['after_time'][0] * 60 + preferences['after_time'][1]\n                    if available_start >= after_min:\n                        return (available_start, available_start + duration)\n                else:\n                    return (available_start, available_start + duration)\n        prev_end = max(prev_end, end)\n    \n    # Check after last busy interval\n    if work_end - prev_end >= duration:\n        if preferences and 'after_time' in preferences:\n            after_min = preferences['after_time'][0] * 60 + preferences['after_time'][1]\n            if prev_end >= after_min:\n                return (prev_end, prev_end + duration)\n        else:\n            return (prev_end, prev_end + duration)\n    \n    return None\n\n# Example usage for the given task\nparticipants = [\n    {\n        'name': 'Keith',\n        'busy': [(14, 0), (14, 30), (16, 0), (16, 30)]\n    },\n    {\n        'name': 'Christine',\n        'busy': []\n    },\n    {\n        'name': 'Cynthia',\n        'busy': [(9, 0), (10, 30), (11, 30), (17, 0)]\n    }\n]\n\nduration = 60  # 1 hour\nwork_hours = (9, 17)  # 9:00 to 17:00\n\nmeeting_time = find_meeting_time(participants, duration, work_hours)\nif meeting_time:\n    start_h, start_m = divmod(meeting_time[0], 60)\n    end_h, end_m = divmod(meeting_time[1], 60)\n    print(f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_55"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Find the earliest available meeting time for all participants.\n    \n    Args:\n        participants: List of dicts with each participant's busy times.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional constraints like earliest start time.\n    \n    Returns:\n        Tuple of (start_time, end_time) in HH:MM format.\n    \"\"\"\n    # Convert work hours to minutes for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Collect all busy slots and convert to minutes\n    busy_slots = []\n    for person in participants:\n        for busy in person['busy']:\n            start_h, start_m = map(int, busy[0].split(':'))\n            end_h, end_m = map(int, busy[1].split(':'))\n            busy_start = start_h * 60 + start_m\n            busy_end = end_h * 60 + end_m\n            busy_slots.append((busy_start, busy_end))\n    \n    # Sort busy slots by start time\n    busy_slots.sort()\n    \n    # Merge overlapping or adjacent busy slots\n    merged = []\n    for start, end in busy_slots:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Check available slots between busy times and work hours\n    available = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n    \n    # Filter based on preferences (e.g., earliest start time)\n    if preferences and 'earliest_start' in preferences:\n        earliest_start = preferences['earliest_start']\n        earliest_min = earliest_start[0] * 60 + earliest_start[1]\n        available = [(s, e) for s, e in available if s >= earliest_min and e - s >= duration]\n    \n    # Find the first available slot that fits the duration\n    for start, end in available:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = start + duration\n            # Convert back to HH:MM format\n            start_h = meeting_start // 60\n            start_m = meeting_start % 60\n            end_h = meeting_end // 60\n            end_m = meeting_end % 60\n            return (f\"{start_h:02d}:{start_m:02d}\", f\"{end_h:02d}:{end_m:02d}\")\n    \n    return None\n\n# Example usage for the current task\nparticipants = [\n    {\n        'name': 'Jeremy',\n        'busy': [('12:00', '13:00'), ('13:30', '14:00'), ('15:00', '15:30')]\n    },\n    {\n        'name': 'Donna',\n        'busy': [('09:30', '10:00'), ('13:00', '13:30'), ('16:00', '17:00')]\n    },\n    {\n        'name': 'Robert',\n        'busy': [('09:00', '11:00'), ('11:30', '12:00'), ('12:30', '17:00')]\n    }\n]\n\nduration = 30  # minutes\nwork_hours = (9, 17)  # 9:00 to 17:00\n\nmeeting_time = find_meeting_time(participants, duration, work_hours)\nif meeting_time:\n    print(f\"{meeting_time[0]}:{meeting_time[1]}\")\nelse:\n    print(\"No available time found.\")\n```",
            "count": "calendar_scheduling_example_56"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest meeting time that fits all participants' schedules and constraints.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times (list of tuples).\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start, end) times for the workday.\n        preferences: Optional dict with preferences like 'earliest_time' or 'avoid_before'.\n    \n    Returns:\n        Tuple of (start, end) times for the meeting, or None if no time found.\n    \"\"\"\n    # Convert all times to minutes since 9:00 (540 minutes) for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to make 9:00 as 0\n    \n    def minutes_to_time(minutes):\n        hh = (minutes + 540) // 60\n        mm = (minutes + 540) % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = work_hours\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration\n    \n    # Collect all busy intervals for all participants\n    all_busy = []\n    for person in participants:\n        for busy_start, busy_end in person['busy']:\n            start_min = time_to_minutes(busy_start)\n            end_min = time_to_minutes(busy_end)\n            all_busy.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by inverting busy intervals\n    free_intervals = []\n    prev_end = work_start_min\n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n    \n    # Apply preferences (e.g., avoid before a certain time)\n    if preferences and 'avoid_before' in preferences:\n        avoid_before_min = time_to_minutes(preferences['avoid_before'])\n        free_intervals = [(s, e) for s, e in free_intervals if s >= avoid_before_min]\n    \n    # Find the first free interval that can fit the meeting\n    for start, end in free_intervals:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return (minutes_to_time(meeting_start), minutes_to_time(meeting_end))\n    \n    return None\n\n# Define participants and their busy times\nparticipants = [\n    {\n        'name': 'Virginia',\n        'busy': [('10:00', '12:00')]\n    },\n    {\n        'name': 'Charles',\n        'busy': [('12:00', '12:30'), ('13:00', '13:30')]\n    },\n    {\n        'name': 'Megan',\n        'busy': [('09:00', '12:00'), ('13:30', '16:00'), ('16:30', '17:00')]\n    }\n]\n\n# Define preferences\npreferences = {\n    'avoid_before': '14:30'\n}\n\n# Find meeting time\nmeeting_time = find_meeting_time(\n    participants,\n    duration=30,\n    work_hours=('09:00', '17:00'),\n    preferences=preferences\n)\n\n# Output the result in HH:MM:HH:MM format\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{{{start}:{end}}}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_57"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times (list of tuples).\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences (e.g., 'earliest_time').\n    \n    Returns:\n        Tuple of (start_time, end_time) as strings in HH:MM format.\n    \"\"\"\n    # Convert work hours to minutes\n    start_work = work_hours[0] * 60\n    end_work = work_hours[1] * 60\n    \n    # Collect all busy intervals\n    busy_intervals = []\n    for person in participants:\n        for start, end in person['busy']:\n            busy_start = start[0] * 60 + start[1]\n            busy_end = end[0] * 60 + end[1]\n            busy_intervals.append((busy_start, busy_end))\n    \n    # Sort busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1] = (last_start, max(end, last_end))\n            else:\n                merged.append((start, end))\n    \n    # Find free slots\n    free_slots = []\n    previous_end = start_work\n    for start, end in merged:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < end_work:\n        free_slots.append((previous_end, end_work))\n    \n    # Check preferences (e.g., earliest_time)\n    earliest_time = preferences.get('earliest_time', 0) * 60 if preferences else 0\n    \n    # Find the first free slot that fits duration and preferences\n    for start, end in free_slots:\n        if end - start >= duration and start >= earliest_time:\n            meeting_start = start\n            meeting_end = start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return (\n                f\"{start_hh:02d}:{start_mm:02d}\",\n                f\"{end_hh:02d}:{end_mm:02d}\"\n            )\n    \n    return None\n\n# Example usage for Joan, Theresa, Shirley\nparticipants = [\n    {\n        'name': 'Joan',\n        'busy': [((11, 0), (11, 30)), ((12, 30), (13, 0))]\n    },\n    {\n        'name': 'Theresa',\n        'busy': [((12, 0), (12, 30)), ((15, 0), (15, 30))]\n    },\n    {\n        'name': 'Shirley',\n        'busy': [((9, 30), (10, 30)), ((11, 0), (12, 0)), ((13, 0), (14, 0)), ((15, 30), (16, 30))]\n    }\n]\n\nduration = 60  # 1 hour\nwork_hours = (9, 17)  # 9:00 to 17:00\n\nmeeting_time = find_meeting_time(participants, duration, work_hours)\nif meeting_time:\n    print(f\"{{{meeting_time[0]}:{meeting_time[1]}}}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_58"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants within work hours.\n    \n    Args:\n        participants: List of dictionaries with 'name' and 'busy' times.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dictionary of preferences (e.g., 'earliest_time').\n    \n    Returns:\n        Tuple of (start_time, end_time) as strings in HH:MM format.\n    \"\"\"\n    # Convert work hours to minutes since midnight\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Convert busy times to minutes since midnight\n    busy_slots = []\n    for person in participants:\n        for busy in person['busy']:\n            start_h, start_m = map(int, busy[0].split(':'))\n            end_h, end_m = map(int, busy[1].split(':'))\n            busy_start = start_h * 60 + start_m\n            busy_end = end_h * 60 + end_m\n            busy_slots.append((busy_start, busy_end))\n    \n    # Sort busy slots by start time\n    busy_slots.sort()\n    \n    # Merge overlapping or adjacent busy slots\n    merged = []\n    for start, end in busy_slots:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1] = (last_start, max(end, last_end))\n            else:\n                merged.append((start, end))\n    \n    # Find available slots between busy times and work hours\n    available = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n    \n    # Check preferences for earliest possible time\n    earliest_time = work_start\n    if preferences and 'earliest_time' in preferences:\n        h, m = map(int, preferences['earliest_time'].split(':'))\n        earliest_time = h * 60 + m\n    \n    # Find the first available slot that fits duration and preferences\n    for slot_start, slot_end in available:\n        if slot_end - slot_start >= duration:\n            start = max(slot_start, earliest_time)\n            if start + duration <= slot_end:\n                # Convert back to HH:MM format\n                start_h = start // 60\n                start_m = start % 60\n                end = start + duration\n                end_h = end // 60\n                end_m = end % 60\n                return (f\"{start_h:02d}:{start_m:02d}\", f\"{end_h:02d}:{end_m:02d}\")\n    \n    return None\n\n# Define participants and their busy times\nparticipants = [\n    {\n        'name': 'Jeffrey',\n        'busy': []\n    },\n    {\n        'name': 'Jack',\n        'busy': [\n            ('10:30', '11:30'),\n            ('13:00', '13:30'),\n            ('14:00', '14:30'),\n            ('16:00', '17:00')\n        ]\n    },\n    {\n        'name': 'Judith',\n        'busy': [\n            ('9:00', '10:00'),\n            ('10:30', '11:00'),\n            ('11:30', '14:00'),\n            ('14:30', '15:00'),\n            ('15:30', '17:00')\n        ]\n    }\n]\n\n# Define meeting duration (30 minutes)\nduration = 30\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (9, 17)\n\n# Define preferences (Jeffrey does not want to meet before 14:00)\npreferences = {\n    'earliest_time': '14:00'\n}\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants, duration, work_hours, preferences)\n\n# Output the result in the required format\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{{{start}:{end}}}\")\nelse:\n    print(\"No available time slot found.\")\n```",
            "count": "calendar_scheduling_example_59"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, preferences=None):\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Initialize a list to hold all busy intervals\n    busy_intervals = []\n\n    # Process each participant's schedule\n    for participant in participants:\n        for busy in participant['busy']:\n            start, end = busy.split(' to ')\n            start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n            end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n            busy_intervals.append((start_min, end_min))\n\n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n\n    # Find all free intervals by inverting busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n\n    # Apply preferences if any\n    if preferences:\n        for pref in preferences:\n            if pref['type'] == 'avoid_before':\n                avoid_time = int(pref['time'].split(':')[0]) * 60 + int(pref['time'].split(':')[1])\n                free_intervals = [(s, e) for s, e in free_intervals if s >= avoid_time or e > avoid_time]\n            elif pref['type'] == 'avoid_after':\n                avoid_time = int(pref['time'].split(':')[0]) * 60 + int(pref['time'].split(':')[1])\n                free_intervals = [(s, e) for s, e in free_intervals if e <= avoid_time or s < avoid_time]\n\n    # Find the earliest free interval that can accommodate the meeting (30 minutes)\n    meeting_duration = 30\n    for start, end in free_intervals:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return None\n\n# Define participants and their busy times\nparticipants = [\n    {\n        'name': 'Lisa',\n        'busy': ['10:30 to 11:00', '11:30 to 12:00', '14:00 to 15:00']\n    },\n    {\n        'name': 'Dorothy',\n        'busy': []\n    },\n    {\n        'name': 'Raymond',\n        'busy': ['9:00 to 10:00', '10:30 to 11:00', '11:30 to 15:00', '16:00 to 17:00']\n    }\n]\n\n# Define Dorothy's preference to avoid meetings after 10:30\npreferences = [\n    {\n        'name': 'Dorothy',\n        'type': 'avoid_after',\n        'time': '10:30'\n    }\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants, preferences)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_60"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:30:14:30}",
            "type_error": "TypeError",
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times (list of tuples).\n        duration: Meeting duration in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences (e.g., 'earliest' or 'after_time').\n    \n    Returns:\n        Tuple of (start_time, end_time) in HH:MM format, or None if no slot found.\n    \"\"\"\n    # Convert work hours to minutes for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Collect all busy intervals and sort them\n    all_busy = []\n    for person in participants:\n        for start, end in person['busy']:\n            all_busy.append((start[0] * 60 + start[1], end[0] * 60 + end[1]))\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1] = (last_start, max(end, last_end))\n            else:\n                merged.append((start, end))\n    \n    # Check available slots between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Filter slots that meet duration and preferences\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            if preferences and 'after_time' in preferences:\n                after_min = preferences['after_time'][0] * 60 + preferences['after_time'][1]\n                if slot_start < after_min:\n                    continue\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = (slot_start + duration) // 60\n            end_mm = (slot_start + duration) % 60\n            return (f\"{start_hh:02d}:{start_mm:02d}\", f\"{end_hh:02d}:{end_mm:02d}\")\n    \n    return None\n\n# Example usage for Robert, Lisa, Patrick\nparticipants = [\n    {\n        'name': 'Robert',\n        'busy': []\n    },\n    {\n        'name': 'Lisa',\n        'busy': [(9, 30), (10, 0)],  # 9:30-10:00\n        'busy': [(11, 30), (12, 0)]   # 11:30-12:00\n    },\n    {\n        'name': 'Patrick',\n        'busy': [(9, 30), (11, 30)],  # 9:30-11:30\n        'busy': [(12, 30), (13, 30)],  # 12:30-13:30\n        'busy': [(16, 0), (17, 0)]     # 16:00-17:00\n    }\n]\n\n# Duration is 60 minutes\nduration = 60\nwork_hours = (9, 17)\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants, duration, work_hours)\nif meeting_time:\n    print(f\"{{{meeting_time[0]}:{meeting_time[1]}}}\")\nelse:\n    print(\"No available slot found.\")\n```",
            "count": "calendar_scheduling_example_61"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    # Convert work hours to minutes for easier calculation\n    start_work, end_work = [int(t.split(':')[0]) * 60 + int(t.split(':')[1]) for t in work_hours.split(' to ')]\n    \n    # Initialize the free slots for all participants\n    free_slots = []\n    for participant in participants:\n        # Convert busy slots to minutes\n        busy_slots = []\n        for busy in participant['busy']:\n            start, end = [int(t.split(':')[0]) * 60 + int(t.split(':')[1]) for t in busy.split(' to ')]\n            busy_slots.append((start, end))\n        \n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Calculate free slots\n        free = []\n        prev_end = start_work\n        for start, end in busy_slots:\n            if start > prev_end:\n                free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < end_work:\n            free.append((prev_end, end_work))\n        \n        free_slots.append(free)\n    \n    # Find overlapping free slots\n    common_free = free_slots[0]\n    for slots in free_slots[1:]:\n        new_common = []\n        i = j = 0\n        while i < len(common_free) and j < len(slots):\n            start1, end1 = common_free[i]\n            start2, end2 = slots[j]\n            \n            # Find the overlap\n            start = max(start1, start2)\n            end = min(end1, end2)\n            if start < end:\n                new_common.append((start, end))\n            \n            # Move the pointer which ends first\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free = new_common\n    \n    # Apply preferences if any\n    if preferences:\n        if 'earliest' in preferences and preferences['earliest']:\n            common_free.sort()\n        if 'after' in preferences:\n            after_time = int(preferences['after'].split(':')[0]) * 60 + int(preferences['after'].split(':')[1])\n            common_free = [slot for slot in common_free if slot[0] >= after_time]\n    \n    # Find the first slot that can fit the duration\n    duration_min = duration * 60\n    for slot in common_free:\n        start, end = slot\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return None\n\n# Define the participants and their busy times\nparticipants = [\n    {\n        'name': 'Abigail',\n        'busy': []\n    },\n    {\n        'name': 'Michael',\n        'busy': []\n    },\n    {\n        'name': 'Sharon',\n        'busy': ['9:00 to 13:00', '14:00 to 17:00']\n    }\n]\n\n# Define the meeting duration in hours\nduration = 1\n\n# Define the work hours\nwork_hours = '9:00 to 17:00'\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants, duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_62"
        },
        {
            "final_program_time": "{16:00:17:00}",
            "expected_time": "{16:00:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Find the earliest available meeting time for all participants within work hours.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times (list of tuples).\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict of preferences (e.g., 'earliest' or 'after_time').\n    \n    Returns:\n        Tuple of (start_time, end_time) as strings in HH:MM format.\n    \"\"\"\n    # Convert work hours to minutes since midnight\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Collect all busy intervals and convert to minutes\n    busy_intervals = []\n    for person in participants:\n        for start, end in person['busy']:\n            busy_start = start[0] * 60 + start[1]\n            busy_end = end[0] * 60 + end[1]\n            busy_intervals.append((busy_start, busy_end))\n    \n    # Sort busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots between merged busy intervals and work hours\n    available = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n    \n    # Check for slots that can fit the meeting duration\n    for slot_start, slot_end in available:\n        if slot_end - slot_start >= duration:\n            # Apply preferences if any\n            if preferences and 'after_time' in preferences:\n                after_time = preferences['after_time'][0] * 60 + preferences['after_time'][1]\n                if slot_start >= after_time:\n                    meeting_start = slot_start\n                    meeting_end = meeting_start + duration\n                    return (meeting_start, meeting_end)\n            else:\n                meeting_start = slot_start\n                meeting_end = meeting_start + duration\n                return (meeting_start, meeting_end)\n    \n    return None\n\n# Example usage for the given task\nparticipants = [\n    {\n        'name': 'Madison',\n        'busy': []\n    },\n    {\n        'name': 'Judith',\n        'busy': [\n            ((10, 0), (10, 30)),\n            ((11, 0), (12, 0)),\n            ((12, 30), (13, 0))\n        ]\n    },\n    {\n        'name': 'Roger',\n        'busy': [\n            ((9, 0), (9, 30)),\n            ((10, 30), (11, 0)),\n            ((12, 0), (12, 30)),\n            ((13, 0), (13, 30)),\n            ((14, 0), (16, 0))\n        ]\n    }\n]\n\nduration = 60  # minutes\nwork_hours = (9, 17)  # 9:00 to 17:00\n\nmeeting_time = find_meeting_time(participants, duration, work_hours)\nif meeting_time:\n    start_h, start_m = divmod(meeting_time[0], 60)\n    end_h, end_m = divmod(meeting_time[1], 60)\n    print(f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\")\nelse:\n    print(\"No available time slot found.\")\n```",
            "count": "calendar_scheduling_example_63"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours, preferences=None):\n    \"\"\"\n    Find the earliest available meeting time for all participants.\n    \n    Args:\n        participants_schedules: List of dictionaries with 'busy' times for each participant.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional constraints like 'no meetings before X time'.\n    \n    Returns:\n        String with proposed time in 'HH:MM-HH:MM' format.\n    \"\"\"\n    # Convert work hours to minutes for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Process each participant's busy slots into minutes\n    busy_slots = []\n    for schedule in participants_schedules:\n        participant_busy = []\n        for busy in schedule['busy']:\n            start_h, start_m = map(int, busy[0].split(':'))\n            end_h, end_m = map(int, busy[1].split(':'))\n            start = start_h * 60 + start_m\n            end = end_h * 60 + end_m\n            participant_busy.append((start, end))\n        busy_slots.append(participant_busy)\n    \n    # Merge all busy slots into a single list of unavailable times\n    all_busy = []\n    for participant in busy_slots:\n        for slot in participant:\n            all_busy.append(slot)\n    all_busy.sort()\n    \n    # Generate available slots by finding gaps between busy times\n    available = []\n    prev_end = work_start\n    for start, end in all_busy:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n    \n    # Apply preferences (e.g., no meetings before a certain time)\n    if preferences and 'no_before' in preferences:\n        no_before = preferences['no_before']\n        no_before_min = int(no_before.split(':')[0]) * 60 + int(no_before.split(':')[1])\n        available = [(s, e) for s, e in available if s >= no_before_min]\n    \n    # Find the first available slot that fits the duration\n    for slot in available:\n        start, end = slot\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = start + duration\n            # Convert back to HH:MM format\n            start_h = meeting_start // 60\n            start_m = meeting_start % 60\n            end_h = meeting_end // 60\n            end_m = meeting_end % 60\n            return f\"{start_h:02d}:{start_m:02d}-{end_h:02d}:{end_m:02d}\"\n    \n    return \"No available time found.\"\n\n# Example usage for the given task\nparticipants_schedules = [\n    {'busy': [('9:30', '10:00'), ('11:00', '11:30'), ('14:30', '15:00'), ('16:30', '17:00')]},  # Mason\n    {'busy': []},  # Bruce\n    {'busy': [('9:30', '10:30'), ('11:30', '12:30'), ('15:00', '17:00')]}  # Christopher\n]\n\nduration = 30  # minutes\nwork_hours = (9, 17)  # 9:00 to 17:00\npreferences = {'no_before': '12:30'}  # Mason's preference\n\nproposed_time = find_meeting_time(participants_schedules, duration, work_hours, preferences)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_64"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration, preferences=None):\n    # Convert work hours to minutes\n    start_work = convert_time_to_minutes(work_hours[0])\n    end_work = convert_time_to_minutes(work_hours[1])\n    \n    # Generate all possible time slots within work hours\n    time_slots = []\n    current_time = start_work\n    while current_time + duration <= end_work:\n        time_slots.append((current_time, current_time + duration))\n        current_time += 30  # Assuming 30-minute increments for simplicity\n    \n    # Filter time slots based on preferences (if any)\n    if preferences:\n        preferred_start = convert_time_to_minutes(preferences.get('after', '00:00'))\n        time_slots = [slot for slot in time_slots if slot[0] >= preferred_start]\n    \n    # Check each time slot against each participant's busy times\n    for slot in time_slots:\n        slot_start, slot_end = slot\n        valid = True\n        for participant in participants_busy_times:\n            for busy in participant:\n                busy_start = convert_time_to_minutes(busy[0])\n                busy_end = convert_time_to_minutes(busy[1])\n                # Check if slot overlaps with any busy time\n                if not (slot_end <= busy_start or slot_start >= busy_end):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return (slot_start, slot_end)\n    return None\n\ndef convert_time_to_minutes(time_str):\n    hours, minutes = map(int, time_str.split(':'))\n    return hours * 60 + minutes\n\ndef convert_minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Define the task\nparticipants_busy_times = [\n    [(\"12:30\", \"13:00\"), (\"15:30\", \"16:00\")],  # John\n    [(\"09:00\", \"09:30\"), (\"11:00\", \"12:30\"), (\"15:00\", \"15:30\"), (\"16:00\", \"16:30\")],  # Andrea\n    [(\"09:00\", \"10:00\"), (\"10:30\", \"11:00\"), (\"12:00\", \"12:30\"), (\"14:00\", \"15:30\"), (\"16:00\", \"16:30\")]  # Lisa\n]\nwork_hours = (\"09:00\", \"17:00\")\nduration = 30  # minutes\npreferences = {'after': '16:30'}  # Andrea cannot meet after 16:30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours, duration, preferences)\n\n# Output the result\nif meeting_time:\n    start_time = convert_minutes_to_time(meeting_time[0])\n    end_time = convert_minutes_to_time(meeting_time[1])\n    print(f\"{{{start_time}:{end_time}}}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_65"
        },
        {
            "final_program_time": "{11:31:12:31}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants within work hours.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times (list of tuples).\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences (e.g., 'earliest' or 'after_time').\n    \n    Returns:\n        Tuple of (start_time, end_time) in HH:MM format if found, else None.\n    \"\"\"\n    # Convert work hours to minutes since midnight for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Collect all busy intervals and sort them\n    all_busy = []\n    for person in participants:\n        for start, end in person['busy']:\n            all_busy.append((start[0] * 60 + start[1], end[0] * 60 + end[1]))\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1] = (last_start, max(end, last_end))\n            else:\n                merged.append((start, end))\n    \n    # Add boundaries for work hours\n    merged.insert(0, (-1, work_start - 1))\n    merged.append((work_end + 1, 24 * 60 + 1))\n    \n    # Find gaps between busy intervals that can fit the meeting\n    for i in range(len(merged) - 1):\n        current_end = merged[i][1]\n        next_start = merged[i + 1][0]\n        gap_start = current_end + 1\n        gap_end = next_start - 1\n        gap_duration = gap_end - gap_start\n        \n        if gap_duration >= duration:\n            # Check if this gap satisfies any preferences\n            valid = True\n            if preferences:\n                if 'after_time' in preferences:\n                    after_min = preferences['after_time'][0] * 60 + preferences['after_time'][1]\n                    if gap_start < after_min:\n                        valid = False\n            if valid:\n                # Convert back to HH:MM\n                start_h = gap_start // 60\n                start_m = gap_start % 60\n                end_h = (gap_start + duration) // 60\n                end_m = (gap_start + duration) % 60\n                return (f\"{start_h:02d}:{start_m:02d}\", f\"{end_h:02d}:{end_m:02d}\")\n    \n    return None\n\n# Define participants and their busy times\nparticipants = [\n    {\n        'name': 'Ronald',\n        'busy': []\n    },\n    {\n        'name': 'Maria',\n        'busy': []\n    },\n    {\n        'name': 'Charles',\n        'busy': [\n            ((9, 0), (10, 30)),\n            ((11, 0), (11, 30)),\n            ((13, 30), (14, 0)),\n            ((14, 30), (15, 0)),\n            ((15, 30), (16, 30))\n        ]\n    }\n]\n\n# Meeting duration in minutes (1 hour)\nduration = 60\n\n# Work hours (9:00 to 17:00)\nwork_hours = (9, 17)\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants, duration, work_hours)\n\n# Output the result in the required format\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{{{start}:{end}}}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_66"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Find the earliest meeting time that fits all participants' schedules.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences like 'earliest' or 'after_time'.\n    \n    Returns:\n        Tuple of (start_time, end_time) as strings in HH:MM format.\n    \"\"\"\n    # Convert work hours to minutes\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Initialize all possible time slots\n    slots = []\n    current_time = work_start\n    while current_time + duration <= work_end:\n        slots.append((current_time, current_time + duration))\n        current_time += 30  # Assuming 30-minute increments for simplicity\n    \n    # Process each participant's busy times\n    busy_slots = []\n    for participant in participants:\n        participant_busy = []\n        for busy in participant['busy']:\n            start = busy[0] * 60\n            end = busy[1] * 60\n            participant_busy.append((start, end))\n        busy_slots.append(participant_busy)\n    \n    # Find the first slot where no one is busy\n    for slot in slots:\n        slot_start, slot_end = slot\n        conflict = False\n        \n        # Check against each participant's busy slots\n        for participant_busy in busy_slots:\n            for busy_start, busy_end in participant_busy:\n                if not (slot_end <= busy_start or slot_start >= busy_end):\n                    conflict = True\n                    break\n            if conflict:\n                break\n        \n        if not conflict:\n            # Check preferences if any\n            if preferences:\n                if 'after_time' in preferences:\n                    after_min = preferences['after_time'] * 60\n                    if slot_start < after_min:\n                        continue\n                if 'before_time' in preferences:\n                    before_min = preferences['before_time'] * 60\n                    if slot_start >= before_min:\n                        continue\n            \n            # Convert slot back to HH:MM\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}\", f\"{end_hh:02d}:{end_mm:02d}\"\n    \n    return None\n\n# Define the task\nparticipants = [\n    {\n        'name': 'Jacqueline',\n        'busy': [(13, 13.5), (16, 16.5)]\n    },\n    {\n        'name': 'Christian',\n        'busy': []\n    },\n    {\n        'name': 'Linda',\n        'busy': [(9, 10.5), (11.5, 12.5), (14, 14.5), (15.5, 16.5)]\n    }\n]\nduration = 30\nwork_hours = (9, 17)\npreferences = {\n    'before_time': 14  # Linda cannot meet after 14:00\n}\n\n# Find the meeting time\nstart_time, end_time = find_meeting_time(participants, duration, work_hours, preferences)\nprint(f\"{start_time}:{end_time}\")\n```",
            "count": "calendar_scheduling_example_67"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times.\n        duration: Meeting duration in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences like 'earliest_time'.\n    \n    Returns:\n        String with proposed meeting time in \"HH:MM-HH:MM\" format.\n    \"\"\"\n    # Convert work hours to minutes since midnight for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Initialize all available slots as the entire work day\n    available_slots = [(work_start, work_end)]\n    \n    # Process each participant's busy times\n    for person in participants:\n        busy_slots = []\n        for busy in person['busy']:\n            start = busy[0] * 60 + busy[1]\n            end = busy[2] * 60 + busy[3]\n            busy_slots.append((start, end))\n        \n        # Merge overlapping busy slots\n        busy_slots.sort()\n        merged_busy = []\n        for busy in busy_slots:\n            if not merged_busy:\n                merged_busy.append(busy)\n            else:\n                last_start, last_end = merged_busy[-1]\n                current_start, current_end = busy\n                if current_start <= last_end:\n                    new_end = max(last_end, current_end)\n                    merged_busy[-1] = (last_start, new_end)\n                else:\n                    merged_busy.append(busy)\n        \n        # Subtract busy times from available slots\n        new_available = []\n        for avail_start, avail_end in available_slots:\n            current_start = avail_start\n            for busy_start, busy_end in merged_busy:\n                if busy_end <= current_start:\n                    continue\n                if busy_start >= avail_end:\n                    break\n                if busy_start > current_start:\n                    new_available.append((current_start, busy_start))\n                current_start = max(current_start, busy_end)\n            if current_start < avail_end:\n                new_available.append((current_start, avail_end))\n        available_slots = new_available\n    \n    # Apply preferences if any\n    if preferences and 'earliest_time' in preferences:\n        earliest_min = preferences['earliest_time'][0] * 60 + preferences['earliest_time'][1]\n        available_slots = [slot for slot in available_slots if slot[1] > earliest_min]\n        available_slots = [(max(slot[0], earliest_min), slot[1]) for slot in available_slots]\n    \n    # Find the first available slot that fits the duration\n    for slot in available_slots:\n        slot_duration = slot[1] - slot[0]\n        if slot_duration >= duration:\n            # Convert back to HH:MM format\n            start_h = slot[0] // 60\n            start_m = slot[0] % 60\n            end_time = slot[0] + duration\n            end_h = end_time // 60\n            end_m = end_time % 60\n            return f\"{start_h:02d}:{start_m:02d}-{end_h:02d}:{end_m:02d}\"\n    \n    return \"No available time slot found\"\n\n# Define participants and their busy times\nparticipants = [\n    {\n        'name': 'Michael',\n        'busy': [(10, 0, 10, 30), (11, 30, 12, 0), (13, 30, 14, 0), (15, 30, 16, 0)]\n    },\n    {\n        'name': 'Bryan',\n        'busy': []\n    },\n    {\n        'name': 'Lauren',\n        'busy': [(9, 0, 10, 30), (14, 30, 17, 0)]\n    }\n]\n\n# Define meeting parameters\nduration = 30  # minutes\nwork_hours = (9, 17)  # 9:00 to 17:00\npreferences = {'earliest_time': (9, 0)}  # Earliest availability\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants, duration, work_hours, preferences)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_68"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:00:11:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest meeting time that fits all participants' schedules.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times (list of tuples).\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences (e.g., 'earliest_time').\n    \n    Returns:\n        Tuple of (start_time, end_time) as strings in HH:MM format.\n    \"\"\"\n    # Convert work hours to minutes\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Collect all busy intervals\n    busy_intervals = []\n    for person in participants:\n        for start, end in person['busy']:\n            busy_start = start[0] * 60 + start[1]\n            busy_end = end[0] * 60 + end[1]\n            busy_intervals.append((busy_start, busy_end))\n    \n    # Sort busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_end = max(end, last_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Check for available slots between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Check for slots that can fit the meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            # Apply preferences if any (e.g., earliest_time)\n            if preferences and 'earliest_time' in preferences:\n                pref_time = preferences['earliest_time'][0] * 60 + preferences['earliest_time'][1]\n                if slot_start < pref_time:\n                    if slot_end - pref_time >= duration:\n                        slot_start = pref_time\n                    else:\n                        continue\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return (f\"{start_hh:02d}:{start_mm:02d}\", f\"{end_hh:02d}:{end_mm:02d}\")\n    \n    return None\n\n# Example usage for the given task\nparticipants = [\n    {\n        'name': 'Shirley',\n        'busy': [(11, 0, 11, 30), (14, 0, 15, 0), (16, 0, 16, 30)]\n    },\n    {\n        'name': 'Stephen',\n        'busy': [(13, 0, 13, 30), (15, 30, 16, 0)]\n    },\n    {\n        'name': 'Paul',\n        'busy': [(9, 0, 10, 0), (11, 0, 17, 0)]\n    }\n]\n\nduration = 60  # 1 hour\nwork_hours = (9, 17)  # 9:00 to 17:00\n\nmeeting_time = find_meeting_time(participants, duration, work_hours)\nif meeting_time:\n    print(f\"{{{meeting_time[0]}:{meeting_time[1]}}}\")\nelse:\n    print(\"No available time slot found.\")\n```",
            "count": "calendar_scheduling_example_69"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Find the earliest available meeting time for all participants.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences (e.g., 'earliest' or 'after_time').\n    \n    Returns:\n        A string with the proposed meeting time in HH:MM-HH:MM format.\n    \"\"\"\n    # Convert work hours to minutes for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Initialize the free slots for all participants\n    free_slots = []\n    for participant in participants:\n        busy_slots = participant['busy']\n        # Convert busy slots to minutes\n        busy_minutes = []\n        for slot in busy_slots:\n            start, end = slot\n            start_min = start[0] * 60 + start[1]\n            end_min = end[0] * 60 + end[1]\n            busy_minutes.append((start_min, end_min))\n        \n        # Sort busy slots by start time\n        busy_minutes.sort()\n        \n        # Calculate free slots\n        participant_free = []\n        prev_end = work_start\n        for busy_start, busy_end in busy_minutes:\n            if busy_start > prev_end:\n                participant_free.append((prev_end, busy_start))\n            prev_end = max(prev_end, busy_end)\n        if prev_end < work_end:\n            participant_free.append((prev_end, work_end))\n        \n        free_slots.append(participant_free)\n    \n    # Find overlapping free slots\n    common_free = free_slots[0]\n    for participant_free in free_slots[1:]:\n        new_common = []\n        i = j = 0\n        while i < len(common_free) and j < len(participant_free):\n            start1, end1 = common_free[i]\n            start2, end2 = participant_free[j]\n            # Find the overlap\n            overlap_start = max(start1, start2)\n            overlap_end = min(end1, end2)\n            if overlap_start < overlap_end:\n                new_common.append((overlap_start, overlap_end))\n            # Move the pointer which ends first\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free = new_common\n    \n    # Apply preferences if any\n    if preferences:\n        if 'after_time' in preferences:\n            after_min = preferences['after_time'][0] * 60 + preferences['after_time'][1]\n            common_free = [(s, e) for s, e in common_free if s >= after_min]\n    \n    # Find the earliest slot that fits the duration\n    duration_min = duration\n    for slot in common_free:\n        start, end = slot\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}-{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available slot found\"\n\n# Define the participants and their busy times\nparticipants = [\n    {\n        'name': 'Denise',\n        'busy': [\n            ((12, 0), (12, 30)),\n            ((15, 30), (16, 0))\n        ]\n    },\n    {\n        'name': 'Angela',\n        'busy': []\n    },\n    {\n        'name': 'Natalie',\n        'busy': [\n            ((9, 0), (11, 30)),\n            ((12, 0), (13, 0)),\n            ((14, 0), (14, 30)),\n            ((15, 0), (17, 0))\n        ]\n    }\n]\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (9, 17)\n\n# Define meeting duration (30 minutes)\nduration = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants, duration, work_hours, preferences={'earliest': True})\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_70"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, preferences=None):\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert schedules to minutes and find busy slots for all participants\n    busy_slots = []\n    for person, schedule in participants.items():\n        for busy in schedule:\n            start = busy[0].split(':')\n            end = busy[1].split(':')\n            start_min = int(start[0]) * 60 + int(start[1])\n            end_min = int(end[0]) * 60 + int(end[1])\n            busy_slots.append((start_min, end_min))\n    \n    # Sort busy slots by start time\n    busy_slots.sort()\n    \n    # Find free slots by inverting busy slots\n    free_slots = []\n    prev_end = work_start\n    for start, end in busy_slots:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Apply preferences if any\n    if preferences:\n        if 'earliest' in preferences and preferences['earliest']:\n            pass  # already looking for earliest\n        if 'not_before' in preferences:\n            not_before = preferences['not_before']\n            not_before_min = int(not_before.split(':')[0]) * 60 + int(not_before.split(':')[1])\n            free_slots = [(s, e) for s, e in free_slots if s >= not_before_min]\n        if 'not_after' in preferences:\n            not_after = preferences['not_after']\n            not_after_min = int(not_after.split(':')[0]) * 60 + int(not_after.split(':')[1])\n            free_slots = [(s, e) for s, e in free_slots if e <= not_after_min]\n    \n    # Find the first free slot that can accommodate the meeting (30 minutes)\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return None\n\n# Define participants and their schedules\nparticipants = {\n    'Nicole': [],\n    'John': [('12:30', '13:00'), ('16:30', '17:00')],\n    'Ethan': [('09:00', '10:00'), ('11:30', '14:00'), ('14:30', '17:00')]\n}\n\n# Define preferences\npreferences = {\n    'not_after': '12:00'\n}\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants, preferences)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_71"
        },
        {
            "final_program_time": "{13:30:14:30}",
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_start, work_end, preferences=None):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Generate busy slots for each participant\n    busy_slots = []\n    for participant in participants:\n        participant_busy = []\n        for busy in participant['busy']:\n            start, end = busy.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            participant_busy.append((start_min, end_min))\n        busy_slots.append(participant_busy)\n    \n    # Find all free slots for all participants\n    all_free_slots = []\n    for participant_busy in busy_slots:\n        free_slots = []\n        prev_end = work_start_min\n        for start, end in sorted(participant_busy, key=lambda x: x[0]):\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end_min:\n            free_slots.append((prev_end, work_end_min))\n        all_free_slots.append(free_slots)\n    \n    # Find overlapping free slots\n    common_free_slots = []\n    if not all_free_slots:\n        return f\"{work_start}:{work_start.split(':')[0]}:{int(work_start.split(':')[1]) + duration}\"\n    \n    # Start with the first participant's free slots\n    common_free_slots = all_free_slots[0]\n    \n    for participant_slots in all_free_slots[1:]:\n        new_common_slots = []\n        i = j = 0\n        while i < len(common_free_slots) and j < len(participant_slots):\n            start1, end1 = common_free_slots[i]\n            start2, end2 = participant_slots[j]\n            \n            # Find the overlap\n            overlap_start = max(start1, start2)\n            overlap_end = min(end1, end2)\n            \n            if overlap_start < overlap_end:\n                new_common_slots.append((overlap_start, overlap_end))\n            \n            # Move the pointer which ends first\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free_slots = new_common_slots\n    \n    # Apply preferences if any\n    if preferences:\n        if 'earliest' in preferences:\n            for slot in common_free_slots:\n                start, end = slot\n                if end - start >= duration_min:\n                    meeting_start = start\n                    meeting_end = meeting_start + duration_min\n                    return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n        if 'after_time' in preferences:\n            after_time_min = time_to_minutes(preferences['after_time'])\n            for slot in common_free_slots:\n                start, end = slot\n                if start >= after_time_min and end - start >= duration_min:\n                    meeting_start = start\n                    meeting_end = meeting_start + duration_min\n                    return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    # Find the first suitable slot\n    for slot in common_free_slots:\n        start, end = slot\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Example usage for the last task\nparticipants = [\n    {'name': 'Mason', 'busy': []},\n    {'name': 'Amy', 'busy': ['9:30 to 11:30', '13:00 to 13:30', '16:30 to 17:00']},\n    {'name': 'Christopher', 'busy': ['9:00 to 10:00', '12:00 to 13:30', '14:30 to 15:00', '15:30 to 16:30']}\n]\n\nduration = 1  # in hours\nwork_start = '9:00'\nwork_end = '17:00'\n\nprint(find_meeting_time(participants, duration, work_start, work_end))\n```",
            "count": "calendar_scheduling_example_72"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Find the earliest available meeting time for all participants within work hours.\n    \n    Args:\n        participants (list): List of dictionaries with 'name' and 'busy' times.\n        duration (int): Duration of the meeting in minutes.\n        work_hours (tuple): Start and end of work hours as (HH:MM, HH:MM).\n        preferences (dict): Optional preferences like 'earliest' or 'after_time'.\n    \n    Returns:\n        str: Proposed meeting time as \"HH:MM-HH:MM\" or None if no slot found.\n    \"\"\"\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = work_hours\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Collect all busy intervals for all participants\n    all_busy = []\n    for person in participants:\n        for busy in person['busy']:\n            start, end = busy.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            all_busy.append((start_min, end_min))\n    \n    # Sort busy intervals by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy intervals\n    free_slots = []\n    prev_end = work_start_min\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > prev_end:\n            free_slots.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n    \n    if prev_end < work_end_min:\n        free_slots.append((prev_end, work_end_min))\n    \n    # Filter free slots that meet duration and preferences\n    for slot_start, slot_end in free_slots:\n        slot_duration = slot_end - slot_start\n        if slot_duration >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            \n            # Check preferences (e.g., earliest or after a certain time)\n            if preferences and 'after_time' in preferences:\n                after_min = time_to_minutes(preferences['after_time'])\n                if meeting_start < after_min:\n                    continue\n            \n            return f\"{minutes_to_time(meeting_start)}-{minutes_to_time(meeting_end)}\"\n    \n    return None\n\n# Define the participants and their busy times\nparticipants = [\n    {\n        'name': 'Bradley',\n        'busy': ['9:30 to 10:00', '13:00 to 13:30', '14:30 to 15:00', '16:30 to 17:00']\n    },\n    {\n        'name': 'Andrew',\n        'busy': ['9:00 to 9:30', '12:30 to 13:30', '14:00 to 14:30', '15:00 to 16:00']\n    },\n    {\n        'name': 'Melissa',\n        'busy': ['9:00 to 9:30', '10:00 to 10:30', '11:00 to 14:00', '15:00 to 15:30', '16:00 to 16:30']\n    }\n]\n\n# Define meeting parameters\nduration = 30  # minutes\nwork_hours = ('9:00', '17:00')\n\n# Find the meeting time\nproposed_time = find_meeting_time(participants, duration, work_hours)\n\n# Output the result\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_73"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants within work hours.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times (list of tuples).\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences (e.g., 'earliest' or time constraints).\n    \n    Returns:\n        Tuple of (start_time, end_time) in HH:MM format, or None if no slot found.\n    \"\"\"\n    # Convert work hours to minutes for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Collect all busy intervals and merge them\n    all_busy = []\n    for person in participants:\n        for start, end in person['busy']:\n            all_busy.append((start[0] * 60 + start[1], end[0] * 60 + end[1]))\n    \n    # Sort busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Find free slots by checking gaps between busy intervals and work hours\n    free_slots = []\n    previous_end = work_start\n    for start, end in merged_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Filter free slots based on duration and preferences\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            # Check if the slot meets any preferences\n            if preferences:\n                if 'earliest' in preferences and preferences['earliest']:\n                    pass  # Already checking earliest first\n                if 'not_before' in preferences:\n                    not_before = preferences['not_before'][0] * 60 + preferences['not_before'][1]\n                    if slot_start < not_before:\n                        continue\n                if 'not_after' in preferences:\n                    not_after = preferences['not_after'][0] * 60 + preferences['not_after'][1]\n                    if slot_start + duration > not_after:\n                        continue\n            # Convert slot back to HH:MM format\n            start_h = slot_start // 60\n            start_m = slot_start % 60\n            end_h = (slot_start + duration) // 60\n            end_m = (slot_start + duration) % 60\n            return (f\"{start_h:02d}:{start_m:02d}\", f\"{end_h:02d}:{end_m:02d}\")\n    \n    return None\n\n# Example usage for the current task\nparticipants = [\n    {\n        'name': 'Eric',\n        'busy': [((10, 0), (12, 0))],\n    },\n    {\n        'name': 'Albert',\n        'busy': [((12, 0), (12, 30)), ((15, 30), (16, 0))],\n    },\n    {\n        'name': 'Katherine',\n        'busy': [((10, 0), (11, 0)), ((11, 30), (14, 0)), ((15, 0), (15, 30))],\n    },\n]\n\nduration = 60  # 1 hour\nwork_hours = (9, 17)  # 9:00 to 17:00\npreferences = {\n    'not_after': (15, 30),  # Eric does not want to meet after 15:30\n}\n\nmeeting_time = find_meeting_time(participants, duration, work_hours, preferences)\nif meeting_time:\n    print(f\"{{{meeting_time[0]}:{meeting_time[1]}}}\")\nelse:\n    print(\"No suitable time found.\")\n```\n\nThe output of this script will be `{14:00:15:00}`, which is the earliest available one-hour slot that fits all constraints.",
            "count": "calendar_scheduling_example_74"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants within work hours.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences (e.g., 'earliest_after').\n    \n    Returns:\n        String with proposed meeting time in \"HH:MM-HH:MM\" format or None if no slot found.\n    \"\"\"\n    # Convert work hours to minutes since midnight for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Process each participant's busy slots into minutes\n    busy_slots = []\n    for person in participants:\n        person_busy = []\n        for slot in person['busy']:\n            start, end = slot\n            start_min = start[0] * 60 + start[1]\n            end_min = end[0] * 60 + end[1]\n            person_busy.append((start_min, end_min))\n        busy_slots.append(person_busy)\n    \n    # Generate all possible meeting slots and check availability\n    for time in range(work_start, work_end - duration + 1):\n        end_time = time + duration\n        slot_ok = True\n        \n        # Check against each participant's busy slots\n        for person_busy in busy_slots:\n            for busy_start, busy_end in person_busy:\n                if not (end_time <= busy_start or time >= busy_end):\n                    slot_ok = False\n                    break\n            if not slot_ok:\n                break\n        \n        # Check preferences (e.g., earliest after a certain time)\n        if slot_ok and preferences:\n            if 'earliest_after' in preferences:\n                earliest_after = preferences['earliest_after'][0] * 60 + preferences['earliest_after'][1]\n                if time < earliest_after:\n                    slot_ok = False\n        \n        if slot_ok:\n            # Convert back to HH:MM format\n            start_hh = time // 60\n            start_mm = time % 60\n            end_hh = end_time // 60\n            end_mm = end_time % 60\n            return f\"{start_hh:02d}:{start_mm:02d}-{end_hh:02d}:{end_mm:02d}\"\n    \n    return None\n\n# Example usage for the given task:\nparticipants = [\n    {\n        'name': 'Jacob',\n        'busy': [\n            ((9, 0), (9, 30)),\n            ((12, 30), (13, 0)),\n            ((14, 30), (15, 0)),\n            ((16, 30), (17, 0))\n        ]\n    },\n    {\n        'name': 'Amanda',\n        'busy': [\n            ((10, 0), (10, 30)),\n            ((12, 0), (12, 30))\n        ]\n    },\n    {\n        'name': 'Lisa',\n        'busy': [\n            ((11, 0), (13, 0)),\n            ((14, 30), (16, 30))\n        ]\n    }\n]\n\nduration = 60  # 1 hour\nwork_hours = (9, 17)  # 9:00 to 17:00\n\nproposed_time = find_meeting_time(participants, duration, work_hours)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_75"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest meeting time that fits all participants' schedules.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times.\n        duration: Meeting duration in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences like 'earliest_time'.\n    \n    Returns:\n        Tuple of (start_time, end_time) in HH:MM format.\n    \"\"\"\n    # Convert work hours to minutes\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Generate all possible time slots\n    slots = []\n    current = work_start\n    while current + duration <= work_end:\n        slots.append((current, current + duration))\n        current += 30  # Assuming 30-minute increments for simplicity\n    \n    # Check each slot against participants' busy times\n    for slot_start, slot_end in slots:\n        valid = True\n        for participant in participants:\n            for busy_start, busy_end in participant['busy']:\n                busy_start_min = busy_start[0] * 60 + busy_start[1]\n                busy_end_min = busy_end[0] * 60 + busy_end[1]\n                # Check if slot overlaps with busy time\n                if not (slot_end <= busy_start_min or slot_start >= busy_end_min):\n                    valid = False\n                    break\n            if not valid:\n                break\n        \n        # Check preferences if any\n        if valid and preferences:\n            if 'earliest_time' in preferences:\n                pref_time = preferences['earliest_time'][0] * 60 + preferences['earliest_time'][1]\n                if slot_start < pref_time:\n                    valid = False\n            # Add other preference checks here\n        \n        if valid:\n            # Convert back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}-{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available slot found\"\n\n# Define participants' busy times (in HH:MM format converted to tuples)\nparticipants = [\n    {\n        'name': 'Joyce',\n        'busy': []\n    },\n    {\n        'name': 'Beverly',\n        'busy': [\n            ((9, 30), (10, 0)),\n            ((11, 0), (11, 30)),\n            ((12, 30), (13, 0)),\n            ((14, 0), (14, 30)),\n            ((15, 30), (16, 0)),\n            ((16, 30), (17, 0))\n        ]\n    },\n    {\n        'name': 'Peter',\n        'busy': [\n            ((9, 30), (10, 30)),\n            ((11, 30), (13, 0)),\n            ((14, 30), (15, 30)),\n            ((16, 30), (17, 0))\n        ]\n    }\n]\n\n# Define meeting parameters\nduration = 60  # minutes\nwork_hours = (9, 17)  # 9:00 to 17:00\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants, duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_76"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants within work hours.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times (list of tuples).\n        duration: Meeting duration in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences like 'earliest' or 'after_time'.\n    \n    Returns:\n        Tuple of (start_time, end_time) as strings in HH:MM format.\n    \"\"\"\n    # Convert work hours to minutes since midnight\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Initialize all available slots as free\n    free_slots = []\n    current_start = work_start\n    \n    # Collect all busy times\n    busy_times = []\n    for person in participants:\n        for start, end in person['busy']:\n            busy_start = start[0] * 60 + start[1]\n            busy_end = end[0] * 60 + end[1]\n            busy_times.append((busy_start, busy_end))\n    \n    # Sort busy times by start time\n    busy_times.sort()\n    \n    # Find free slots between busy times\n    for busy_start, busy_end in busy_times:\n        if busy_start > current_start:\n            free_slots.append((current_start, busy_start))\n        current_start = max(current_start, busy_end)\n    \n    # Add the slot after last busy time if within work hours\n    if current_start < work_end:\n        free_slots.append((current_start, work_end))\n    \n    # Check preferences\n    if preferences:\n        if 'after_time' in preferences:\n            after_time = preferences['after_time'][0] * 60 + preferences['after_time'][1]\n            free_slots = [(s, e) for s, e in free_slots if s >= after_time]\n        if 'earliest' in preferences and preferences['earliest']:\n            free_slots.sort(key=lambda x: x[0])\n    \n    # Find the first slot that fits the duration\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}\", f\"{end_hh:02d}:{end_mm:02d}\"\n    \n    return None\n\n# Define participants and their busy times\nparticipants = [\n    {\n        'name': 'Donald',\n        'busy': [(10, 0, 10, 30), (11, 0, 11, 30), (12, 0, 12, 30), (13, 0, 13, 30), (15, 30, 16, 30)]\n    },\n    {\n        'name': 'Joyce',\n        'busy': [(11, 0, 13, 0), (14, 30, 15, 0), (16, 0, 16, 30)]\n    },\n    {\n        'name': 'Abigail',\n        'busy': [(9, 30, 10, 0), (11, 30, 12, 0), (13, 0, 14, 0), (15, 0, 17, 0)]\n    }\n]\n\n# Define meeting duration (30 minutes)\nduration = 30\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (9, 17)\n\n# Define preferences (Donald does not want to meet after 12:00)\npreferences = {\n    'after_time': (9, 0),  # Can't be before 9:00\n    'earliest': True,       # Prefer earliest possible\n    'before_time': (12, 0)  # Donald's preference\n}\n\n# Adjust free slots to respect Donald's preference\ndef adjust_for_preferences(free_slots, before_time):\n    before_min = before_time[0] * 60 + before_time[1]\n    adjusted_slots = []\n    for start, end in free_slots:\n        if start < before_min:\n            adjusted_end = min(end, before_min)\n            if adjusted_end > start:\n                adjusted_slots.append((start, adjusted_end))\n    return adjusted_slots\n\n# Find initial free slots\nfree_slots = []\nwork_start = work_hours[0] * 60\nwork_end = work_hours[1] * 60\ncurrent_start = work_start\n\n# Collect all busy times\nbusy_times = []\nfor person in participants:\n    for start_hh, start_mm, end_hh, end_mm in person['busy']:\n        busy_start = start_hh * 60 + start_mm\n        busy_end = end_hh * 60 + end_mm\n        busy_times.append((busy_start, busy_end))\n\n# Sort busy times\nbusy_times.sort()\n\n# Generate free slots\nfor busy_start, busy_end in busy_times:\n    if busy_start > current_start:\n        free_slots.append((current_start, busy_start))\n    current_start = max(current_start, busy_end)\n\n# Add final slot if needed\nif current_start < work_end:\n    free_slots.append((current_start, work_end))\n\n# Apply Donald's preference\nfree_slots = adjust_for_preferences(free_slots, preferences['before_time'])\n\n# Find the first suitable slot\nmeeting_time = None\nfor slot_start, slot_end in free_slots:\n    if slot_end - slot_start >= duration:\n        meeting_start = slot_start\n        meeting_end = meeting_start + duration\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        meeting_time = f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n        break\n\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_77"
        },
        {
            "final_program_time": "{12:30:13:30}",
            "expected_time": "{12:30:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration, preferences=None):\n    # Convert work hours to minutes\n    start_h, start_m = map(int, work_hours[0].split(':'))\n    end_h, end_m = map(int, work_hours[1].split(':'))\n    work_start = start_h * 60 + start_m\n    work_end = end_h * 60 + end_m\n    \n    # Process each participant's busy times\n    busy_slots = []\n    for busy_times in participants_busy_times:\n        slots = []\n        for busy in busy_times:\n            start, end = busy.split(' to ')\n            s_h, s_m = map(int, start.split(':'))\n            e_h, e_m = map(int, end.split(':'))\n            slots.append((s_h * 60 + s_m, e_h * 60 + e_m))\n        busy_slots.append(slots)\n    \n    # Generate all possible slots\n    possible_slots = []\n    current_time = work_start\n    while current_time + duration <= work_end:\n        slot_end = current_time + duration\n        valid = True\n        # Check against each participant's busy times\n        for i in range(len(busy_slots)):\n            for busy_start, busy_end in busy_slots[i]:\n                if not (slot_end <= busy_start or current_time >= busy_end):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            possible_slots.append((current_time, slot_end))\n        current_time += 30  # Check in 30-minute increments\n    \n    # Apply preferences if any\n    if preferences:\n        if 'earliest' in preferences:\n            possible_slots.sort(key=lambda x: x[0])\n        if 'after' in preferences:\n            after_time = preferences['after']\n            a_h, a_m = map(int, after_time.split(':'))\n            after_min = a_h * 60 + a_m\n            possible_slots = [slot for slot in possible_slots if slot[0] >= after_min]\n    \n    if not possible_slots:\n        return None\n    \n    selected_slot = possible_slots[0]\n    start_h = selected_slot[0] // 60\n    start_m = selected_slot[0] % 60\n    end_h = selected_slot[1] // 60\n    end_m = selected_slot[1] % 60\n    \n    return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n\n# Example usage for the last task\nparticipants_busy_times = [\n    [\"9:00 to 10:00\", \"11:00 to 12:00\"],  # Ronald\n    [\"10:30 to 11:00\", \"14:00 to 14:30\"],  # Teresa\n    [\"9:00 to 12:30\", \"14:00 to 15:30\", \"16:00 to 17:00\"]  # Carol\n]\nwork_hours = (\"9:00\", \"17:00\")\nduration = 60  # minutes\n\nproposed_time = find_meeting_time(participants_busy_times, work_hours, duration)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_78"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences like 'earliest_time'.\n    \n    Returns:\n        String with proposed meeting time in \"HH:MM-HH:MM\" format.\n    \"\"\"\n    # Convert work hours to minutes\n    start_h, end_h = work_hours\n    work_start = start_h * 60\n    work_end = end_h * 60\n    \n    # Parse all busy intervals into minutes\n    busy_intervals = []\n    for person in participants:\n        for interval in person['busy']:\n            start, end = interval\n            start_m = start[0] * 60 + start[1]\n            end_m = end[0] * 60 + end[1]\n            busy_intervals.append((start_m, end_m))\n    \n    # Sort all busy intervals\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                new_end = max(last_end, current_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append(interval)\n    \n    # Check available slots\n    available_slots = []\n    prev_end = work_start\n    \n    for interval in merged:\n        current_start, current_end = interval\n        if current_start > prev_end:\n            available_slots.append((prev_end, current_start))\n        prev_end = max(prev_end, current_end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Filter slots that meet duration and preferences\n    for slot in available_slots:\n        start, end = slot\n        if end - start >= duration:\n            if preferences and 'earliest_time' in preferences:\n                earliest = preferences['earliest_time']\n                earliest_m = earliest[0] * 60 + earliest[1]\n                if start >= earliest_m:\n                    return format_time(start, start + duration)\n            else:\n                return format_time(start, start + duration)\n    \n    return \"No available time found\"\n\ndef format_time(start_m, end_m):\n    \"\"\"Converts minutes to HH:MM format.\"\"\"\n    start_h = start_m // 60\n    start_min = start_m % 60\n    end_h = end_m // 60\n    end_min = end_m % 60\n    return f\"{start_h:02d}:{start_min:02d}-{end_h:02d}:{end_min:02d}\"\n\n# Example usage for Amy, Emma, John\nparticipants = [\n    {\n        'name': 'Amy',\n        'busy': [((11, 0), (11, 30)), ((12, 0), (12, 30))]\n    },\n    {\n        'name': 'Emma',\n        'busy': []\n    },\n    {\n        'name': 'John',\n        'busy': [((10, 0), (10, 30)), ((11, 30), (12, 0)), ((12, 30), (16, 0)), ((16, 30), (17, 0))]\n    }\n]\n\nduration = 60  # 1 hour\nwork_hours = (9, 17)  # 9:00 to 17:00\n\nproposed_time = find_meeting_time(participants, duration, work_hours)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_79"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, preferences=None):\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30       # 30 minutes\n    \n    # Convert each participant's busy slots to minutes\n    busy_slots = []\n    for participant in participants:\n        participant_busy = []\n        for busy in participant['busy']:\n            start, end = busy.split(' to ')\n            start_h, start_m = map(int, start.split(':'))\n            end_h, end_m = map(int, end.split(':'))\n            start_min = start_h * 60 + start_m\n            end_min = end_h * 60 + end_m\n            participant_busy.append((start_min, end_min))\n        busy_slots.append(participant_busy)\n    \n    # Generate all possible time slots within work hours\n    possible_slots = []\n    current_time = work_hours_start\n    while current_time + meeting_duration <= work_hours_end:\n        slot_end = current_time + meeting_duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 15  # Check every 15 minutes for efficiency\n    \n    # Filter slots where all participants are free\n    valid_slots = []\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        all_free = True\n        for participant_busy in busy_slots:\n            for busy_start, busy_end in participant_busy:\n                if not (slot_end <= busy_start or slot_start >= busy_end):\n                    all_free = False\n                    break\n            if not all_free:\n                break\n        if all_free:\n            # Check preferences if any\n            if preferences:\n                if 'before' in preferences and slot_start >= preferences['before'] * 60:\n                    continue\n                if 'after' in preferences and slot_end <= preferences['after'] * 60:\n                    continue\n            valid_slots.append(slot)\n    \n    if not valid_slots:\n        return None\n    \n    # Choose the earliest valid slot\n    chosen_slot = valid_slots[0]\n    start_h, start_m = divmod(chosen_slot[0], 60)\n    end_h, end_m = divmod(chosen_slot[1], 60)\n    \n    return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n\n# Define participants and their busy times\nparticipants = [\n    {\n        'name': 'Michelle',\n        'busy': ['9:30 to 10:00', '12:30 to 13:00']\n    },\n    {\n        'name': 'Billy',\n        'busy': ['10:30 to 11:00', '11:30 to 12:00', '14:30 to 15:00', '16:00 to 16:30']\n    },\n    {\n        'name': 'Alexis',\n        'busy': ['9:30 to 10:30', '11:00 to 12:00', '12:30 to 13:00', '13:30 to 14:30', '16:00 to 16:30']\n    }\n]\n\n# Define preferences (Alexis would rather not meet after 15:00)\npreferences = {\n    'before': 15  # 15:00\n}\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants, preferences)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_80"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants within work hours.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times (list of tuples).\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start, end) in 'HH:MM' format.\n        preferences: Optional dict with preferences (e.g., 'earliest' or 'after' time).\n    \n    Returns:\n        Tuple of (start, end) in 'HH:MM' format or None if no slot found.\n    \"\"\"\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = map(time_to_minutes, work_hours)\n    duration_min = duration\n    \n    # Collect all busy intervals\n    busy_intervals = []\n    for person in participants:\n        for start, end in person['busy']:\n            busy_start = time_to_minutes(start)\n            busy_end = time_to_minutes(end)\n            busy_intervals.append((busy_start, busy_end))\n    \n    # Sort all busy intervals\n    busy_intervals.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Filter slots that meet duration and preferences\n    valid_slots = []\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration_min:\n            valid_slots.append((slot_start, slot_end))\n    \n    # Apply preferences if any\n    if preferences:\n        if 'after' in preferences:\n            after_time = time_to_minutes(preferences['after'])\n            valid_slots = [(s, e) for s, e in valid_slots if s >= after_time]\n    \n    if not valid_slots:\n        return None\n    \n    # Select the earliest valid slot\n    meeting_start = valid_slots[0][0]\n    meeting_end = meeting_start + duration_min\n    \n    return (minutes_to_time(meeting_start), minutes_to_time(meeting_end))\n\n# Define participants and their busy times\nparticipants = [\n    {\n        'name': 'Jeremy',\n        'busy': [('14:30', '15:30')]\n    },\n    {\n        'name': 'Lawrence',\n        'busy': [('15:30', '16:00'), ('16:30', '17:00')]\n    },\n    {\n        'name': 'Helen',\n        'busy': [('09:30', '10:00'), ('10:30', '11:00'), ('11:30', '12:00'), \n                 ('13:00', '14:00'), ('15:00', '15:30'), ('16:00', '17:00')]\n    }\n]\n\n# Find meeting time (1 hour duration, work hours 9:00-17:00)\nmeeting_time = find_meeting_time(participants, 60, ('09:00', '17:00'))\n\n# Output the result\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{{{start}:{end}}}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_81"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:00:12:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours_start, work_hours_end, preferences=None):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's busy slots\n    for participant in participants:\n        busy_slots = participants[participant]\n        new_free_slots = []\n        for slot in free_slots:\n            current_start = slot[0]\n            for busy in busy_slots:\n                busy_start = time_to_minutes(busy[0])\n                busy_end = time_to_minutes(busy[1])\n                if busy_start > current_start:\n                    new_free_slots.append((current_start, busy_start))\n                current_start = max(current_start, busy_end)\n            if current_start < slot[1]:\n                new_free_slots.append((current_start, slot[1]))\n        free_slots = new_free_slots\n    \n    # Apply preferences if any\n    if preferences:\n        preferred_slots = []\n        for slot in free_slots:\n            if preferences.get('before'):\n                pref_time = time_to_minutes(preferences['before'])\n                if slot[0] < pref_time:\n                    preferred_slots.append(slot)\n            elif preferences.get('after'):\n                pref_time = time_to_minutes(preferences['after'])\n                if slot[0] >= pref_time:\n                    preferred_slots.append(slot)\n            else:\n                preferred_slots.append(slot)\n        free_slots = preferred_slots\n    \n    # Find the earliest slot that fits the duration\n    duration_min = duration * 60\n    for slot in free_slots:\n        if slot[1] - slot[0] >= duration_min:\n            meeting_start = slot[0]\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants and their busy slots\nparticipants = {\n    'Michael': [('09:30', '10:30'), ('15:00', '15:30'), ('16:00', '16:30')],\n    'Eric': [],\n    'Arthur': [('09:00', '12:00'), ('13:00', '15:00'), ('15:30', '16:00'), ('16:30', '17:00')]\n}\n\n# Call the function and print the result\nprint(find_meeting_time(participants, 0.5, '09:00', '17:00'))\n```",
            "count": "calendar_scheduling_example_82"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:00:11:00}",
            "type_error": "NoCodeGenerated",
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants within work hours.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times (list of tuples).\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict of preferences (e.g., 'earliest' or 'after_time').\n    \n    Returns:\n        Tuple of (start_time, end_time) in HH:MM format, or None if no slot found.\n    \"\"\"\n    # Convert work hours to minutes for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Collect all busy intervals and sort them\n    all_busy = []\n    for person in participants:\n        for start, end in person['busy']:\n            all_busy.append((start[0] * 60 + start[1], end[0] * 60 + end[1]))\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1] = (last_start, max(end, last_end))\n            else:\n                merged.append((start, end))\n    \n    # Check available slots between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Filter slots that meet duration and preferences\n    for slot_start, slot_end in available_slots:\n        if (slot_end - slot_start) >= duration:\n            if preferences and 'after_time' in preferences:\n                after_min = preferences['after_time'][0] * 60 + preferences['after_time'][1]\n                if slot_start < after_min:\n                    continue\n            return (\n                (slot_start // 60, slot_start % 60),\n                ((slot_start + duration) // 60, (slot_start + duration) % 60)\n            )\n    \n    return None\n\n# Example usage for the given task\nparticipants = [\n    {\n        'name': 'Anthony',\n        'busy': [\n            ((14, 0), (14, 30)),\n            ((15, 0), (15, 30))\n        ]\n    },\n    {\n        'name': 'Ronald',\n        'busy': [\n            ((9, 0), (10, 0)),\n            ((12, 0), (12, 30)),\n            ((13, 30), (14, 0))\n        ]\n    },\n    {\n        'name': 'Jonathan',\n        'busy': [\n            ((9, 0), (10, 0)),\n            ((11, 0), (11, 30)),\n            ((12, 0), (13, 0)),\n            ((14, 0), (14, 30)),\n            ((15, 0), (17, 0))\n        ]\n    }\n]\n\nduration = 60  # minutes\nwork_hours = (9, 17)  # 9:00 to 17:00\n\nmeeting_time = find_meeting_time(participants, duration, work_hours)\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{start[0]:02d}:{start[1]:02d}:{end[0]:02d}:{end[1]:02d}\")\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_83"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants within work hours.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times (list of tuples).\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences (e.g., 'earliest_after').\n    \n    Returns:\n        Tuple of (start_time, end_time) as strings in HH:MM format.\n    \"\"\"\n    # Convert work hours to minutes for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Collect all busy intervals and sort them\n    all_busy = []\n    for person in participants:\n        for start, end in person['busy']:\n            all_busy.append((start[0] * 60 + start[1], end[0] * 60 + end[1]))\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1] = (last_start, max(end, last_end))\n            else:\n                merged.append((start, end))\n    \n    # Add work hours boundaries\n    merged.insert(0, (0, work_start))\n    merged.append((work_end, 24 * 60))\n    \n    # Find available slots\n    available = []\n    for i in range(len(merged) - 1):\n        prev_end = merged[i][1]\n        next_start = merged[i + 1][0]\n        if next_start - prev_end >= duration:\n            available.append((prev_end, next_start))\n    \n    # Apply preferences (e.g., earliest after a certain time)\n    if preferences and 'earliest_after' in preferences:\n        earliest_after = preferences['earliest_after'][0] * 60 + preferences['earliest_after'][1]\n        available = [(s, e) for s, e in available if s >= earliest_after]\n    \n    if not available:\n        return None\n    \n    # Select the earliest available slot\n    start, end = available[0]\n    start_time = f\"{start // 60:02d}:{start % 60:02d}\"\n    end_time = f\"{(start + duration) // 60:02d}:{(start + duration) % 60:02d}\"\n    return start_time, end_time\n\n# Example usage for the given task\nparticipants = [\n    {\n        'name': 'Kevin',\n        'busy': [((9, 30), (10, 0)), ((10, 30), (11, 0)), ((15, 0), (16, 0))]\n    },\n    {\n        'name': 'Ryan',\n        'busy': [((10, 30), (11, 30)), ((12, 30), (13, 0)), ((13, 30), (14, 0))]\n    },\n    {\n        'name': 'Eugene',\n        'busy': [((9, 0), (9, 30)), ((10, 0), (11, 0)), ((12, 30), (17, 0))]\n    }\n]\n\nduration = 60  # minutes\nwork_hours = (9, 17)  # 9:00 to 17:00\n\nmeeting_time = find_meeting_time(participants, duration, work_hours)\nif meeting_time:\n    print(f\"{{{meeting_time[0]}:{meeting_time[1]}}}\")\nelse:\n    print(\"No available time slot found.\")\n```",
            "count": "calendar_scheduling_example_84"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:11:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest meeting time that fits all participants' schedules and constraints.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times (list of tuples).\n        duration: Meeting duration in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences like 'earliest' or 'after_time'.\n    \n    Returns:\n        Tuple of (start_time, end_time) as strings in HH:MM format, or None if no slot found.\n    \"\"\"\n    # Convert work hours to minutes since midnight\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Initialize available slots as the entire work day\n    available_slots = [(work_start, work_end)]\n    \n    # Process each participant's busy times\n    for person in participants:\n        busy_slots = []\n        for busy in person['busy']:\n            start = busy[0] * 60\n            end = busy[1] * 60\n            busy_slots.append((start, end))\n        \n        # Subtract busy slots from available slots\n        new_available_slots = []\n        for slot in available_slots:\n            slot_start, slot_end = slot\n            for busy_start, busy_end in busy_slots:\n                if busy_end <= slot_start or busy_start >= slot_end:\n                    continue\n                # Busy time overlaps with slot\n                if busy_start > slot_start:\n                    new_available_slots.append((slot_start, busy_start))\n                slot_start = max(slot_start, busy_end)\n                if slot_start >= slot_end:\n                    break\n            if slot_start < slot_end:\n                new_available_slots.append((slot_start, slot_end))\n        available_slots = new_available_slots\n    \n    # Apply preferences if any\n    if preferences:\n        if 'after_time' in preferences:\n            after_min = preferences['after_time'] * 60\n            available_slots = [slot for slot in available_slots if slot[0] >= after_min]\n        if 'earliest' in preferences and preferences['earliest']:\n            available_slots.sort(key=lambda x: x[0])\n    \n    # Find the first available slot that fits the duration\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            end_time = slot_start + duration\n            # Convert back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = end_time // 60\n            end_mm = end_time % 60\n            return (f\"{start_hh:02d}:{start_mm:02d}\", f\"{end_hh:02d}:{end_mm:02d}\")\n    \n    return None\n\n# Define the participants and their busy times\nparticipants = [\n    {\n        'name': 'Kelly',\n        'busy': []\n    },\n    {\n        'name': 'Julia',\n        'busy': [(9.5, 10.0), (14.0, 14.5), (15.0, 15.5), (16.5, 17.0)]\n    },\n    {\n        'name': 'Martha',\n        'busy': [(9.0, 11.0), (12.0, 15.0)]\n    }\n]\n\n# Julia does not want to meet after 13:30\npreferences = {'after_time': 9.0}  # After 9:00, but also need to enforce Julia's 13:30 limit\n# To enforce Julia's 13:30 limit, we can treat it as a busy time after 13:30\nparticipants[1]['busy'].append((13.5, 17.0))\n\n# Meeting duration in minutes (half hour)\nduration = 30\n\n# Work hours (9:00 to 17:00)\nwork_hours = (9, 17)\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants, duration, work_hours, preferences)\n\n# Output the result in the required format\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{{{start}:{end}}}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_85"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants within work hours.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times (list of tuples).\n        duration: Meeting duration in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences (e.g., 'earliest' or 'after_time').\n    \n    Returns:\n        Tuple of (start_time, end_time) as strings in HH:MM format, or None if no slot found.\n    \"\"\"\n    # Convert work hours to minutes since midnight for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Collect all busy intervals and convert to minutes\n    busy_intervals = []\n    for person in participants:\n        for start, end in person['busy']:\n            busy_start = start[0] * 60 + start[1]\n            busy_end = end[0] * 60 + end[1]\n            busy_intervals.append((busy_start, busy_end))\n    \n    # Sort busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1] = (last_start, max(end, last_end))\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Filter slots that can accommodate the meeting duration\n    possible_slots = []\n    for start, end in available_slots:\n        if end - start >= duration:\n            possible_slots.append((start, end))\n    \n    # Apply preferences if specified (e.g., earliest or after a certain time)\n    if preferences:\n        if 'after_time' in preferences:\n            after_min = preferences['after_time'][0] * 60 + preferences['after_time'][1]\n            possible_slots = [slot for slot in possible_slots if slot[0] >= after_min]\n    \n    if not possible_slots:\n        return None\n    \n    # Select the earliest possible slot\n    chosen_slot = possible_slots[0]\n    start_time = chosen_slot[0]\n    end_time = start_time + duration\n    \n    # Convert back to HH:MM format\n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n    \n    return (minutes_to_time(start_time), minutes_to_time(end_time))\n\n# Example usage for Samuel, Emma, and Brittany\nparticipants = [\n    {\n        'name': 'Samuel',\n        'busy': [((9, 0), (9, 30)), ((10, 0), (10, 30)), ((12, 0), (12, 30)), ((14, 0), (15, 0)), ((16, 0), (16, 30))]\n    },\n    {\n        'name': 'Emma',\n        'busy': []\n    },\n    {\n        'name': 'Brittany',\n        'busy': [((11, 30), (14, 30)), ((15, 0), (15, 30)), ((16, 30), (17, 0))]\n    }\n]\n\nduration = 60  # 1 hour\nwork_hours = (9, 17)  # 9:00 to 17:00\n\nmeeting_time = find_meeting_time(participants, duration, work_hours)\nif meeting_time:\n    print(f\"{{{meeting_time[0]}:{meeting_time[1]}}}\")\nelse:\n    print(\"No available time slot found.\")\n```",
            "count": "calendar_scheduling_example_86"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Find the earliest available meeting time for all participants.\n    \n    Args:\n        participants: List of dictionaries with 'name' and 'busy' times.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start, end) times in 'HH:MM' format.\n        preferences: Optional dictionary with preferences (e.g., 'earliest').\n    \n    Returns:\n        A string with the proposed time slot in 'HH:MM-HH:MM' format.\n    \"\"\"\n    # Convert work hours to minutes\n    start_work = int(work_hours[0].split(':')[0]) * 60 + int(work_hours[0].split(':')[1])\n    end_work = int(work_hours[1].split(':')[0]) * 60 + int(work_hours[1].split(':')[1])\n    \n    # Initialize all possible slots within work hours\n    all_slots = []\n    current = start_work\n    while current + duration <= end_work:\n        all_slots.append((current, current + duration))\n        current += 1  # Check every minute\n    \n    # Process each participant's busy times\n    busy_slots = []\n    for person in participants:\n        person_busy = []\n        for busy in person['busy']:\n            start, end = busy.split(' to ')\n            start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n            end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n            person_busy.append((start_min, end_min))\n        busy_slots.append(person_busy)\n    \n    # Find slots where no one is busy\n    available_slots = []\n    for slot in all_slots:\n        slot_start, slot_end = slot\n        conflict = False\n        for i in range(len(participants)):\n            for busy in busy_slots[i]:\n                busy_start, busy_end = busy\n                if not (slot_end <= busy_start or slot_start >= busy_end):\n                    conflict = True\n                    break\n            if conflict:\n                break\n        if not conflict:\n            available_slots.append(slot)\n    \n    # Apply preferences (e.g., earliest)\n    if available_slots:\n        if preferences and preferences.get('earliest', False):\n            chosen_slot = available_slots[0]\n        else:\n            chosen_slot = available_slots[0]  # Default to earliest\n        \n        # Convert back to HH:MM format\n        start_h = chosen_slot[0] // 60\n        start_m = chosen_slot[0] % 60\n        end_h = chosen_slot[1] // 60\n        end_m = chosen_slot[1] % 60\n        return f\"{start_h:02d}:{start_m:02d}-{end_h:02d}:{end_m:02d}\"\n    else:\n        return \"No available slot found.\"\n\n# Example usage for the given task\nparticipants = [\n    {\n        'name': 'Brittany',\n        'busy': ['12:00 to 13:30', '14:30 to 15:00', '15:30 to 16:00', '16:30 to 17:00']\n    },\n    {\n        'name': 'Wayne',\n        'busy': ['9:30 to 10:00', '13:00 to 15:00', '16:30 to 17:00']\n    },\n    {\n        'name': 'Charles',\n        'busy': ['9:00 to 9:30', '10:00 to 10:30', '11:30 to 13:30', '14:30 to 16:30']\n    }\n]\n\nduration = 30  # minutes\nwork_hours = ('9:00', '17:00')\npreferences = {'earliest': True}\n\nproposed_time = find_meeting_time(participants, duration, work_hours, preferences)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_87"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:30}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours_start, work_hours_end, preferences=None):\n    # Convert work hours to minutes for easier calculation\n    work_start = work_hours_start * 60\n    work_end = work_hours_end * 60\n    \n    # Initialize the free slots for all participants\n    free_slots = []\n    for participant in participans:\n        busy_slots = participant['busy']\n        free = []\n        prev_end = work_start\n        \n        for start, end in sorted(busy_slots):\n            start_min = start[0] * 60 + start[1]\n            end_min = end[0] * 60 + end[1]\n            if prev_end < start_min:\n                free.append((prev_end, start_min))\n            prev_end = max(prev_end, end_min)\n        \n        if prev_end < work_end:\n            free.append((prev_end, work_end))\n        \n        free_slots.append(free)\n    \n    # Find overlapping free slots\n    common_free = free_slots[0]\n    for slots in free_slots[1:]:\n        new_common = []\n        i = j = 0\n        while i < len(common_free) and j < len(slots):\n            start1, end1 = common_free[i]\n            start2, end2 = slots[j]\n            \n            overlap_start = max(start1, start2)\n            overlap_end = min(end1, end2)\n            \n            if overlap_start < overlap_end:\n                new_common.append((overlap_start, overlap_end))\n            \n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free = new_common\n    \n    # Apply preferences if any (e.g., earliest, not before a time)\n    if preferences:\n        if 'earliest' in preferences and preferences['earliest']:\n            common_free.sort()\n        if 'not_before' in preferences:\n            not_before = preferences['not_before'][0] * 60 + preferences['not_before'][1]\n            common_free = [(s, e) for s, e in common_free if s >= not_before]\n    \n    # Find the first slot that can fit the duration\n    duration_min = duration * 60\n    for slot in common_free:\n        start, end = slot\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}-{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found.\"\n\n# Example usage for the last task:\nparticipants = [\n    {'name': 'Dennis', 'busy': []},\n    {'name': 'Joseph', 'busy': [(9, 0, 9, 30), (12, 30, 13, 0)]},\n    {'name': 'Isabella', 'busy': [(9, 0, 10, 30), (11, 30, 12, 0), (13, 30, 14, 0), (14, 30, 17, 0)]}\n]\n\n# Convert busy times to tuples of (HH, MM, HH, MM)\nfor participant in participants:\n    participant['busy'] = [(s_hh, s_mm, e_hh, e_mm) for (s_hh, s_mm, e_hh, e_mm) in participant['busy']]\n\nmeeting_time = find_meeting_time(participants, 1, 9, 17)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_88"
        },
        {
            "final_program_time": "{15:00:16:00}",
            "expected_time": "{15:00:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest meeting time that fits all participants' schedules.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences like 'earliest_time'.\n    \n    Returns:\n        Tuple of (start_time, end_time) as strings in HH:MM format.\n    \"\"\"\n    # Convert work hours to minutes\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Generate all possible time slots\n    time_slots = []\n    current_time = work_start\n    while current_time + duration <= work_end:\n        time_slots.append((current_time, current_time + duration))\n        current_time += 30  # Assuming 30-minute increments for simplicity\n    \n    # Check each time slot against participants' schedules\n    for slot in time_slots:\n        slot_start, slot_end = slot\n        valid = True\n        \n        # Check against preferences\n        if preferences and 'earliest_time' in preferences:\n            pref_time = preferences['earliest_time']\n            pref_minutes = pref_time[0] * 60 + pref_time[1]\n            if slot_start < pref_minutes:\n                valid = False\n        \n        if not valid:\n            continue\n        \n        # Check against each participant's busy times\n        for participant in participants:\n            for busy in participant['busy']:\n                busy_start = busy[0] * 60 + busy[1]\n                busy_end = busy[2] * 60 + busy[3]\n                \n                # Check for overlap\n                if not (slot_end <= busy_start or slot_start >= busy_end):\n                    valid = False\n                    break\n            \n            if not valid:\n                break\n        \n        if valid:\n            # Convert back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}\", f\"{end_hh:02d}:{end_mm:02d}\"\n    \n    return None\n\n# Define participants and their busy times\nparticipants = [\n    {\n        'name': 'Michelle',\n        'busy': [(11, 0, 12, 0), (14, 0, 15, 0)]\n    },\n    {\n        'name': 'Andrea',\n        'busy': [(9, 0, 9, 30), (11, 30, 12, 30), (13, 30, 14, 0), (14, 30, 15, 0), (16, 0, 16, 30)]\n    },\n    {\n        'name': 'Douglas',\n        'busy': [(9, 0, 9, 30), (10, 0, 10, 30), (11, 0, 15, 0), (16, 0, 17, 0)]\n    }\n]\n\n# Define meeting duration (1 hour) and work hours (9:00 to 17:00)\nduration = 60\nwork_hours = (9, 17)\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants, duration, work_hours)\n\n# Output the result\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{{{start}:{end}}}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_89"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants within work hours.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times (list of tuples).\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start, end) in 'HH:MM' format.\n        preferences: Optional dict with preferences (e.g., 'earliest' or 'avoid_after').\n    \n    Returns:\n        Tuple of (start, end) in 'HH:MM' format or None if no time found.\n    \"\"\"\n    # Convert work hours to minutes\n    start_work = sum(x * int(t) for x, t in zip([60, 1], work_hours[0].split(':')))\n    end_work = sum(x * int(t) for x, t in zip([60, 1], work_hours[1].split(':')))\n    \n    # Initialize free slots as the entire work day\n    free_slots = [(start_work, end_work)]\n    \n    # Process each participant's busy times\n    for person in participants:\n        busy_slots = []\n        for busy in person['busy']:\n            start_busy = sum(x * int(t) for x, t in zip([60, 1], busy[0].split(':')))\n            end_busy = sum(x * int(t) for x, t in zip([60, 1], busy[1].split(':')))\n            busy_slots.append((start_busy, end_busy))\n        \n        # Subtract busy slots from free slots\n        new_free_slots = []\n        for free_start, free_end in free_slots:\n            current_start = free_start\n            for busy_start, busy_end in sorted(busy_slots):\n                if busy_start >= free_end:\n                    break\n                if busy_end <= current_start:\n                    continue\n                if busy_start > current_start:\n                    new_free_slots.append((current_start, busy_start))\n                current_start = max(current_start, busy_end)\n            if current_start < free_end:\n                new_free_slots.append((current_start, free_end))\n        free_slots = new_free_slots\n    \n    # Apply preferences\n    if preferences:\n        if 'avoid_after' in preferences:\n            avoid_after = sum(x * int(t) for x, t in zip([60, 1], preferences['avoid_after'].split(':')))\n            free_slots = [slot for slot in free_slots if slot[1] <= avoid_after]\n        if 'earliest' in preferences and preferences['earliest']:\n            free_slots.sort(key=lambda x: x[0])\n    \n    # Find the first slot that fits the duration\n    for slot in free_slots:\n        slot_duration = slot[1] - slot[0]\n        if slot_duration >= duration:\n            start_time = slot[0]\n            end_time = start_time + duration\n            # Convert back to HH:MM format\n            start_str = f\"{start_time // 60:02d}:{start_time % 60:02d}\"\n            end_str = f\"{end_time // 60:02d}:{end_time % 60:02d}\"\n            return (start_str, end_str)\n    \n    return None\n\n# Example usage for the given task\nparticipants = [\n    {\n        'name': 'Adam',\n        'busy': [('09:30', '10:00'), ('10:30', '11:00'), ('11:30', '12:00'), ('16:30', '17:00')]\n    },\n    {\n        'name': 'Willie',\n        'busy': [('09:00', '09:30'), ('15:30', '16:00')]\n    },\n    {\n        'name': 'Gloria',\n        'busy': [('09:30', '12:30'), ('13:00', '13:30'), ('15:30', '16:00')],\n    }\n]\n\nduration = 30  # minutes\nwork_hours = ('09:00', '17:00')\npreferences = {'avoid_after': '15:30'}\n\nmeeting_time = find_meeting_time(participants, duration, work_hours, preferences)\nif meeting_time:\n    print(f\"{{{meeting_time[0]}:{meeting_time[1]}}}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_90"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants.\n    \n    Args:\n        participants: List of dictionaries with 'name' and 'busy' times.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dictionary of preferences (e.g., 'earliest' or 'after_time').\n    \n    Returns:\n        A tuple of (start_time, end_time) in HH:MM format, or None if no slot found.\n    \"\"\"\n    # Convert work hours to minutes\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Collect all busy intervals\n    busy_intervals = []\n    for person in participants:\n        for busy in person['busy']:\n            start = busy[0] * 60\n            end = busy[1] * 60\n            busy_intervals.append((start, end))\n    \n    # Sort busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find free intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check preferences\n    if preferences and 'after_time' in preferences:\n        after_time = preferences['after_time'] * 60\n        free_intervals = [(s, e) for s, e in free_intervals if s >= after_time]\n    \n    # Find the first suitable slot\n    duration_min = duration * 60\n    for start, end in free_intervals:\n        if end - start >= duration_min:\n            meeting_end = start + duration_min\n            return (start // 60, start % 60), (meeting_end // 60, meeting_end % 60)\n    \n    return None\n\n# Example usage for the given task\nparticipants = [\n    {\n        'name': 'Danielle',\n        'busy': [(9, 10), (10.5, 11), (14.5, 15), (15.5, 16), (16.5, 17)]\n    },\n    {\n        'name': 'Bruce',\n        'busy': [(11, 11.5), (12.5, 13), (14, 14.5), (15.5, 16)]\n    },\n    {\n        'name': 'Eric',\n        'busy': [(9, 9.5), (10, 11), (11.5, 13), (14.5, 15.5)]\n    }\n]\n\nduration = 60  # 1 hour\nwork_hours = (9, 17)  # 9:00 to 17:00\n\nmeeting_time = find_meeting_time(participants, duration, work_hours)\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{start[0]:02d}:{start[1]:02d}:{end[0]:02d}:{end[1]:02d}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_91"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants within work hours.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times (list of tuples).\n        duration: Meeting duration in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict of preferences (e.g., 'earliest' or 'after_time').\n    \n    Returns:\n        Tuple of (start_time, end_time) in HH:MM format, or None if no slot found.\n    \"\"\"\n    # Convert work hours to minutes since midnight\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Collect all busy intervals and convert to minutes\n    busy_intervals = []\n    for person in participants:\n        for start, end in person['busy']:\n            busy_start = start[0] * 60 + start[1]\n            busy_end = end[0] * 60 + end[1]\n            busy_intervals.append((busy_start, busy_end))\n    \n    # Sort busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_end = max(end, last_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find free slots between work hours and busy intervals\n    free_slots = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Check each free slot for availability of duration\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            # Apply preferences if any\n            if preferences:\n                if 'after_time' in preferences:\n                    after_min = preferences['after_time'][0] * 60 + preferences['after_time'][1]\n                    if slot_start < after_min:\n                        continue\n            # Convert start time back to HH:MM\n            start_h = slot_start // 60\n            start_m = slot_start % 60\n            end_h = (slot_start + duration) // 60\n            end_m = (slot_start + duration) % 60\n            return (start_h, start_m, end_h, end_m)\n    \n    return None\n\n# Example usage for Jacqueline, Henry, William\nparticipants = [\n    {\n        'name': 'Jacqueline',\n        'busy': [((9, 30), (10, 0)), ((16, 30), (17, 0))]\n    },\n    {\n        'name': 'Henry',\n        'busy': []\n    },\n    {\n        'name': 'William',\n        'busy': [((9, 30), (10, 30)), ((12, 30), (15, 0)), ((15, 30), (17, 0))]\n    }\n]\n\nduration = 60  # 1 hour\nwork_hours = (9, 17)  # 9:00 to 17:00\n\nmeeting_time = find_meeting_time(participants, duration, work_hours)\nif meeting_time:\n    print(f\"{meeting_time[0]:02d}:{meeting_time[1]:02d}:{meeting_time[2]:02d}:{meeting_time[3]:02d}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_92"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants within work hours.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times (list of tuples).\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dict with preferences (e.g., 'earliest_time').\n    \n    Returns:\n        Tuple of (start_time, end_time) in HH:MM format, or None if no slot found.\n    \"\"\"\n    # Convert work hours to minutes since midnight\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Collect all busy intervals and convert to minutes\n    busy_intervals = []\n    for person in participants:\n        for start, end in person['busy']:\n            busy_start = start[0] * 60 + start[1]\n            busy_end = end[0] * 60 + end[1]\n            busy_intervals.append((busy_start, busy_end))\n    \n    # Sort busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_end = max(end, last_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Check available slots between merged busy intervals and work hours\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Check each available slot for duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            # Check preferences (e.g., earliest_time)\n            if preferences and 'earliest_time' in preferences:\n                earliest_min = preferences['earliest_time'][0] * 60 + preferences['earliest_time'][1]\n                if slot_start < earliest_min:\n                    if slot_end - earliest_min >= duration:\n                        slot_start = earliest_min\n                    else:\n                        continue\n            # Convert back to HH:MM\n            start_h = slot_start // 60\n            start_m = slot_start % 60\n            end_h = (slot_start + duration) // 60\n            end_m = (slot_start + duration) % 60\n            return (f\"{start_h:02d}:{start_m:02d}\", f\"{end_h:02d}:{end_m:02d}\")\n    \n    return None\n\n# Example usage for the given task\nparticipants = [\n    {\n        'name': 'Austin',\n        'busy': [(10, 30, 11, 0), (13, 30, 14, 0)]\n    },\n    {\n        'name': 'Danielle',\n        'busy': [(9, 0, 10, 0), (11, 0, 12, 0), (13, 0, 13, 30), (15, 30, 16, 0)]\n    },\n    {\n        'name': 'Charles',\n        'busy': [(9, 0, 11, 30), (12, 0, 12, 30), (13, 0, 17, 0)]\n    }\n]\n\nduration = 30  # minutes\nwork_hours = (9, 17)  # 9:00 to 17:00\n\nmeeting_time = find_meeting_time(participants, duration, work_hours)\nif meeting_time:\n    print(f\"{{{meeting_time[0]}:{meeting_time[1]}}}\")\nelse:\n    print(\"No available time slot found.\")\n```",
            "count": "calendar_scheduling_example_93"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Find the earliest available meeting time for all participants.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start, end) in 'HH:MM' format.\n        preferences: Optional dict with preferences (e.g., 'earliest_time').\n    \n    Returns:\n        A tuple of (start, end) in 'HH:MM' format or None if no slot found.\n    \"\"\"\n    # Convert work hours to minutes\n    start_work = convert_time_to_minutes(work_hours[0])\n    end_work = convert_time_to_minutes(work_hours[1])\n    \n    # Collect all busy intervals and convert to minutes\n    busy_intervals = []\n    for person in participants:\n        for interval in person['busy']:\n            start, end = interval.split(' to ')\n            busy_intervals.append((\n                convert_time_to_minutes(start),\n                convert_time_to_minutes(end)\n            ))\n    \n    # Add preferences as constraints (e.g., no meetings before X)\n    if preferences and 'earliest_time' in preferences:\n        earliest = convert_time_to_minutes(preferences['earliest_time'])\n        busy_intervals.append((start_work, earliest))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find the earliest available slot\n    previous_end = start_work\n    for start, end in busy_intervals:\n        if start > previous_end:\n            available_duration = start - previous_end\n            if available_duration >= duration:\n                return (\n                    convert_minutes_to_time(previous_end),\n                    convert_minutes_to_time(previous_end + duration)\n                )\n        previous_end = max(previous_end, end)\n    \n    # Check after last busy interval\n    if end_work - previous_end >= duration:\n        return (\n            convert_minutes_to_time(previous_end),\n            convert_minutes_to_time(previous_end + duration)\n        )\n    \n    return None\n\ndef convert_time_to_minutes(time_str):\n    \"\"\"Convert 'HH:MM' to minutes since midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(':'))\n    return hours * 60 + minutes\n\ndef convert_minutes_to_time(minutes):\n    \"\"\"Convert minutes since midnight to 'HH:MM'.\"\"\"\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Task: Schedule for Nicholas, Elizabeth, Sandra\nparticipants = [\n    {\n        'name': 'Nicholas',\n        'busy': []\n    },\n    {\n        'name': 'Elizabeth',\n        'busy': [\n            '09:30 to 10:00',\n            '11:30 to 12:00',\n            '13:30 to 14:30',\n            '15:00 to 15:30',\n            '16:30 to 17:00'\n        ]\n    },\n    {\n        'name': 'Sandra',\n        'busy': [\n            '09:00 to 09:30',\n            '10:00 to 10:30',\n            '11:30 to 13:30',\n            '15:30 to 16:30'\n        ]\n    }\n]\n\n# Sandra cannot meet before 13:00\npreferences = {\n    'earliest_time': '13:00'\n}\n\n# Find the earliest 30-minute slot between 9:00 and 17:00\nmeeting_time = find_meeting_time(\n    participants,\n    duration=30,\n    work_hours=('09:00', '17:00'),\n    preferences=preferences\n)\n\nif meeting_time:\n    print(f\"{{{meeting_time[0]}:{meeting_time[1]}}}\")\nelse:\n    print(\"No available slot found.\")\n```",
            "count": "calendar_scheduling_example_94"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants within work hours.\n    \n    Args:\n        participants: List of dicts with 'name' and 'busy' times (list of tuples).\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start, end) in 'HH:MM' format.\n        preferences: Optional dict with preferences (e.g., 'earliest_time').\n    \n    Returns:\n        Tuple of (start, end) in 'HH:MM' format or None if no slot found.\n    \"\"\"\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = work_hours\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration\n    \n    # Collect all busy intervals\n    busy_intervals = []\n    for person in participants:\n        for busy in person['busy']:\n            start, end = busy\n            busy_intervals.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_end = max(end, last_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find free slots\n    free_slots = []\n    prev_end = work_start_min\n    for start, end in merged:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        free_slots.append((prev_end, work_end_min))\n    \n    # Apply preferences (e.g., earliest_time)\n    earliest_time_min = work_start_min\n    if preferences and 'earliest_time' in preferences:\n        earliest_time_min = time_to_minutes(preferences['earliest_time'])\n    \n    # Find the first suitable slot\n    for slot_start, slot_end in free_slots:\n        slot_start = max(slot_start, earliest_time_min)\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return (minutes_to_time(meeting_start), minutes_to_time(meeting_end))\n    \n    return None\n\n# Example usage for Jennifer, Gary, Frances\nparticipants = [\n    {\n        'name': 'Jennifer',\n        'busy': [('12:00', '12:30'), ('16:00', '16:30')]\n    },\n    {\n        'name': 'Gary',\n        'busy': [('9:30', '10:00'), ('10:30', '11:00'), ('11:30', '12:30'), ('14:00', '14:30'), ('16:30', '17:00')]\n    },\n    {\n        'name': 'Frances',\n        'busy': [('9:00', '11:00'), ('11:30', '12:30'), ('13:00', '17:00')]\n    }\n]\n\nduration = 30  # minutes\nwork_hours = ('9:00', '17:00')\npreferences = {'earliest_time': '12:30'}  # Jennifer's preference\n\nmeeting_time = find_meeting_time(participants, duration, work_hours, preferences)\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{{{start}:{end}}}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_95"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours_start, work_hours_end, preferences=None):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration_min = duration * 60\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's busy slots\n    for participant in participants:\n        busy_slots = participant.get('busy', [])\n        participant_free_slots = []\n        \n        # Start with the entire work day\n        current_start = work_start\n        \n        for busy in busy_slots:\n            busy_start = time_to_minutes(busy[0])\n            busy_end = time_to_minutes(busy[1])\n            \n            if busy_start > current_start:\n                participant_free_slots.append((current_start, busy_start))\n            \n            current_start = max(current_start, busy_end)\n        \n        if current_start < work_end:\n            participant_free_slots.append((current_start, work_end))\n        \n        # Intersect with the current free_slots\n        new_free_slots = []\n        i = j = 0\n        while i < len(free_slots) and j < len(participant_free_slots):\n            slot_start, slot_end = free_slots[i]\n            part_start, part_end = participant_free_slots[j]\n            \n            # Find the overlap\n            overlap_start = max(slot_start, part_start)\n            overlap_end = min(slot_end, part_end)\n            \n            if overlap_start < overlap_end:\n                new_free_slots.append((overlap_start, overlap_end))\n            \n            # Move the pointer which ends first\n            if slot_end < part_end:\n                i += 1\n            else:\n                j += 1\n        \n        free_slots = new_free_slots\n    \n    # Apply preferences if any\n    if preferences:\n        preferred_start = time_to_minutes(preferences.get('after', '00:00'))\n        free_slots = [(start, end) for start, end in free_slots if start >= preferred_start]\n    \n    # Find the earliest slot that fits the duration\n    for slot in free_slots:\n        start, end = slot\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Example usage for the given task\nparticipants = [\n    {\n        'name': 'Christopher',\n        'busy': [('09:30', '10:00'), ('10:30', '11:00'), ('11:30', '13:00'), ('15:00', '15:30')]\n    },\n    {\n        'name': 'Robert',\n        'busy': [('09:30', '10:00'), ('11:00', '11:30'), ('12:00', '12:30'), ('13:30', '14:30'), ('15:00', '15:30')]\n    },\n    {\n        'name': 'Wayne',\n        'busy': [('10:00', '17:00')]\n    }\n]\n\n# Wayne is busy from 10:00 to 17:00, so the only available time is before 10:00\n# Checking Christopher and Robert's availability before 10:00\n# Christopher is busy 9:30-10:00, Robert is busy 9:30-10:00\n# So the only possible time is 9:00-9:30\nprint(find_meeting_time(participants, 30, '09:00', '17:00'))\n```",
            "count": "calendar_scheduling_example_96"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:00:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants within work hours.\n    \n    Args:\n        participants: List of dictionaries with 'busy' times in HH:MM format.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start, end) times in HH:MM format.\n        preferences: Optional dictionary of preferences (e.g., 'earliest_after').\n    \n    Returns:\n        String with proposed meeting time in HH:MM-HH:MM format.\n    \"\"\"\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = work_hours\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration\n    \n    # Collect all busy intervals\n    busy_intervals = []\n    for person in participants:\n        for busy in person['busy']:\n            start, end = busy\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            busy_intervals.append((start_min, end_min))\n    \n    # Sort busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find free intervals\n    free_intervals = []\n    prev_end = work_start_min\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n    \n    # Apply preferences (e.g., earliest after a certain time)\n    if preferences and 'earliest_after' in preferences:\n        earliest_after = time_to_minutes(preferences['earliest_after'])\n        free_intervals = [(s, e) for s, e in free_intervals if e > earliest_after]\n        free_intervals = [(max(s, earliest_after), e) for s, e in free_intervals]\n    \n    # Find the first free interval that can fit the meeting\n    for start, end in free_intervals:\n        if end - start >= duration_min:\n            meeting_end = start + duration_min\n            return f\"{minutes_to_time(start)}-{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time found.\"\n\n# Task: Schedule for Joseph, Kyle, Joan for 1 hour between 9:00-17:00 on Monday\n# Joseph's constraints: before 14:30 is not allowed\nparticipants = [\n    {\n        'busy': [\n            ('10:30', '11:00'),\n            ('12:30', '13:00'),\n            ('14:30', '15:30')\n        ]\n    },\n    {\n        'busy': [\n            ('12:30', '13:30')\n        ]\n    },\n    {\n        'busy': [\n            ('10:00', '10:30'),\n            ('11:00', '11:30'),\n            ('12:30', '14:00'),\n            ('14:30', '15:00'),\n            ('15:30', '16:00')\n        ]\n    }\n]\n\n# Preferences: Joseph does not want to meet before 14:30\npreferences = {\n    'earliest_after': '14:30'\n}\n\n# Work hours and duration\nwork_hours = ('09:00', '17:00')\nduration = 60  # minutes\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants, duration, work_hours, preferences)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_97"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:30:14:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest available meeting time for all participants within work hours.\n    \n    Args:\n        participants: List of dictionaries with 'name' and 'busy' times.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        preferences: Optional dictionary with preferences (e.g., 'earliest' or 'after_time').\n    \n    Returns:\n        A string with the proposed meeting time in 'HH:MM-HH:MM' format.\n    \"\"\"\n    # Convert work hours to minutes since midnight for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's busy times to find common free slots\n    for person in participants:\n        busy_slots = []\n        for busy in person['busy']:\n            start = busy[0] * 60\n            end = busy[1] * 60\n            busy_slots.append((start, end))\n        \n        # Merge overlapping or adjacent busy slots\n        busy_slots.sort()\n        merged_busy = []\n        for slot in busy_slots:\n            if not merged_busy:\n                merged_busy.append(slot)\n            else:\n                last_start, last_end = merged_busy[-1]\n                current_start, current_end = slot\n                if current_start <= last_end:\n                    new_end = max(last_end, current_end)\n                    merged_busy[-1] = (last_start, new_end)\n                else:\n                    merged_busy.append(slot)\n        \n        # Subtract busy times from free_slots\n        new_free_slots = []\n        for free_start, free_end in free_slots:\n            current_start = free_start\n            for busy_start, busy_end in merged_busy:\n                if busy_start > current_start:\n                    new_free_slots.append((current_start, busy_start))\n                current_start = max(current_start, busy_end)\n            if current_start < free_end:\n                new_free_slots.append((current_start, free_end))\n        free_slots = new_free_slots\n    \n    # Apply preferences if any\n    if preferences:\n        if 'after_time' in preferences:\n            after_min = preferences['after_time'] * 60\n            free_slots = [(s, e) for s, e in free_slots if s >= after_min]\n    \n    # Find the earliest slot that fits the duration\n    for slot in free_slots:\n        start, end = slot\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}-{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time slot found.\"\n\n# Define the participants and their busy times\nparticipants = [\n    {\n        'name': 'Juan',\n        'busy': [(9.0, 10.5), (15.5, 16.0)]\n    },\n    {\n        'name': 'Marilyn',\n        'busy': [(11.0, 11.5), (12.5, 13.0)]\n    },\n    {\n        'name': 'Ronald',\n        'busy': [(9.0, 10.5), (12.0, 12.5), (13.0, 13.5), (14.0, 16.5)]\n    }\n]\n\n# Define preferences (Juan cannot meet after 16:00)\npreferences = {\n    'after_time': 0  # No preference for earliest, but Juan's constraint is handled by busy times\n}\n\n# Find the meeting time\nmeeting_time = find_meeting_time(\n    participants,\n    duration=30,\n    work_hours=(9, 17),\n    preferences=preferences\n)\n\n# Output the result in the required format\noutput = \"{\" + meeting_time.replace(\"-\", \":\") + \"}\"\nprint(output)\n```",
            "count": "calendar_scheduling_example_98"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:00:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_hours, preferences=None):\n    \"\"\"\n    Finds the earliest meeting time that fits all participants' schedules and constraints.\n    \n    Args:\n        participants: List of dictionaries with 'name' and 'busy' times.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start, end) times in 'HH:MM' format.\n        preferences: Optional dictionary with preferences like 'earliest_time' or 'avoid_before'.\n    \n    Returns:\n        A tuple of (start, end) times in 'HH:MM' format or None if no time found.\n    \"\"\"\n    # Convert work hours to minutes\n    start_work = sum(x * int(t) for x, t in zip([60, 1], work_hours[0].split(':')))\n    end_work = sum(x * int(t) for x, t in zip([60, 1], work_hours[1].split(':')))\n    \n    # Convert all busy times to minutes\n    busy_slots = []\n    for person in participants:\n        for slot in person['busy']:\n            start = sum(x * int(t) for x, t in zip([60, 1], slot[0].split(':')))\n            end = sum(x * int(t) for x, t in zip([60, 1], slot[1].split(':')))\n            busy_slots.append((start, end))\n    \n    # Sort busy slots\n    busy_slots.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = start_work\n    for start, end in busy_slots:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < end_work:\n        free_slots.append((prev_end, end_work))\n    \n    # Apply preferences\n    if preferences:\n        avoid_before = preferences.get('avoid_before')\n        if avoid_before:\n            avoid_min = sum(x * int(t) for x, t in zip([60, 1], avoid_before.split(':')))\n            free_slots = [(s, e) for s, e in free_slots if s >= avoid_min]\n    \n    # Find the earliest slot that fits the duration\n    duration_min = duration * 60\n    for start, end in free_slots:\n        if end - start >= duration_min:\n            meeting_end = start + duration_min\n            # Convert back to HH:MM\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return (f\"{start_hh:02d}:{start_mm:02d}\", f\"{end_hh:02d}:{end_mm:02d}\")\n    \n    return None\n\n# Example usage for the current task\nparticipants = [\n    {\n        'name': 'Stephanie',\n        'busy': [('09:00', '09:30'), ('13:30', '14:00')]\n    },\n    {\n        'name': 'Mark',\n        'busy': []\n    },\n    {\n        'name': 'Scott',\n        'busy': [('09:00', '10:00'), ('11:00', '12:30'), ('14:30', '15:00'), ('16:00', '17:00')]\n    }\n]\n\nduration = 60  # 1 hour\nwork_hours = ('09:00', '17:00')\npreferences = {'avoid_before': '15:00'}\n\nmeeting_time = find_meeting_time(participants, duration, work_hours, preferences)\nif meeting_time:\n    print(f\"{{{meeting_time[0]}:{meeting_time[1]}}}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_99"
        }
    ]
}