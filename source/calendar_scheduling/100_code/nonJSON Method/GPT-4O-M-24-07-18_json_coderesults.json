{
    "0shot": [
        {
            "final_program_time": "{23:00:0:00}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Function to check availability for a given time range\ndef is_time_available(start_time, end_time, schedules):\n    for schedule in schedules:\n        for busy_start, busy_end in schedule:\n            if not (end_time <= busy_start or start_time >= busy_end):\n                return False\n    return True\n\n# Main function to find a suitable meeting time\ndef find_meeting_time():\n    # Define the schedules in terms of (start, end) in minutes from 09:00\n    michelle_schedule = [(660, 720)]  # 11:00 to 12:00\n    steven_schedule = [(540, 570), (690, 720), (810, 840), (930, 960)]  # Various blocks\n    jerry_schedule = [(540, 570), (600, 660), (690, 780), (780, 840), (930, 960), (990, 1020)]  # Various blocks\n\n    # Combine all schedules\n    schedules = [michelle_schedule, steven_schedule, jerry_schedule]\n\n    # Define work hours\n    work_start = 540  # 09:00\n    work_end = 1020   # 17:00\n    meeting_duration = 60  # duration in minutes\n\n    # Check for available slots\n    for start in range(work_start, work_end - meeting_duration + 1):\n        end = start + meeting_duration\n        if is_time_available(start, end, schedules):\n            meeting_start = datetime(2023, 10, 2, 9, 0) + timedelta(minutes=start)\n            meeting_end = meeting_start + timedelta(minutes=meeting_duration)\n            return f\"{meeting_start.strftime('%H:%M')}:{meeting_end.strftime('%H:%M')}\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_0"
        },
        {
            "final_program_time": "{9:30:9:30}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Participants' schedules\nraymond = [\n    (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n    (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n    (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n    (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\")),\n]\n\nbilly = [\n    (datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n    (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n    (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\")),\n]\n\ndonald = [\n    (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n    (datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n    (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n    (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\")),\n    (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\")),\n]\n\n# Meeting duration\nmeeting_duration = timedelta(minutes=30)\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"17:00\", \"%H:%M\")\n\ndef find_meeting_time():\n    current_time = work_start\n\n    while current_time + meeting_duration <= work_end:\n        if not is_time_conflicted(current_time):\n            return current_time.strftime(\"%H:%M:%H:%M\")\n        current_time += timedelta(minutes=30)  # Check every 30 minutes\n\ndef is_time_conflicted(start_time):\n    end_time = start_time + meeting_duration\n    for busy_time in raymond + billy + donald:\n        if not (end_time <= busy_time[0] or start_time >= busy_time[1]):\n            return True\n    return False\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_1"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the schedules as lists of tuples representing blocked time periods\nroy_schedule = [\n    (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n    (datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n    (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n    (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n]\n\nkathryn_schedule = [\n    (datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n    (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\")),\n]\n\namy_schedule = [\n    (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\")),\n    (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\")),\n    (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\")),\n]\n\n# Define the meeting duration\nmeeting_duration = timedelta(minutes=30)\n\n# Define work hours\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"17:00\", \"%H:%M\")\n\n# Create a full day's schedule combining everyone's blocks\ncombined_schedule = roy_schedule + kathryn_schedule + amy_schedule\n\n# Function to find a suitable time for the meeting\ndef find_meeting_time():\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        # Check if the current_time is free for all participants\n        is_free = True\n        for start, end in combined_schedule:\n            if current_time < end and current_time + meeting_duration > start:\n                is_free = False\n                break\n                \n        if is_free and current_time <= datetime.strptime(\"15:30\", \"%H:%M\"):\n            return current_time.strftime(\"%H:%M\") + \":\" + (current_time + meeting_duration).strftime(\"%H:%M\")\n        \n        current_time += timedelta(minutes=30)\n\n# Get the proposed meeting time\nproposed_time = find_meeting_time()\nprint(proposed_time)\n```\n",
            "count": "calendar_scheduling_example_2"
        },
        {
            "final_program_time": "{9:30:10:30}",
            "expected_time": "{9:30:10:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Function to check if the time slot is available for all participants\ndef is_time_slot_available(start_time, end_time, schedules):\n    for schedule in schedules:\n        for busy_start, busy_end in schedule:\n            if not (end_time <= busy_start or start_time >= busy_end):\n                return False\n    return True\n\n# Schedule for each participant (busy time slots)\nschedules = {\n    \"Arthur\": [(datetime(2023, 10, 23, 9, 0), datetime(2023, 10, 23, 9, 30)),\n               (datetime(2023, 10, 23, 10, 30), datetime(2023, 10, 23, 12, 0)),\n               (datetime(2023, 10, 23, 16, 0), datetime(2023, 10, 23, 17, 0))],\n    \"Michael\": [(datetime(2023, 10, 23, 13, 0), datetime(2023, 10, 23, 13, 30)),\n                (datetime(2023, 10, 23, 14, 0), datetime(2023, 10, 23, 14, 30))],\n    \"Samantha\": [(datetime(2023, 10, 23, 10, 30), datetime(2023, 10, 23, 11, 0)),\n                 (datetime(2023, 10, 23, 12, 0), datetime(2023, 10, 23, 15, 0)),\n                 (datetime(2023, 10, 23, 15, 30), datetime(2023, 10, 23, 17, 0))],\n}\n\n# Meeting duration\nmeeting_duration = timedelta(hours=1)\n\n# Work hours\nwork_start = datetime(2023, 10, 23, 9, 0)\nwork_end = datetime(2023, 10, 23, 17, 0)\n\n# Find available time slot\npossible_start_time = work_start\n\nwhile possible_start_time + meeting_duration <= work_end:\n    possible_end_time = possible_start_time + meeting_duration\n    if is_time_slot_available(possible_start_time, possible_end_time, schedules.values()):\n        print(f\"{possible_start_time.strftime('%H:%M')}:{possible_end_time.strftime('%H:%M')}\")\n        break\n    possible_start_time += timedelta(minutes=30)\n```",
            "count": "calendar_scheduling_example_3"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\n# Function to find a suitable time for a meeting\ndef find_meeting_time(participants_busy_times, meeting_duration, work_hours):\n    # Convert work_hours to time range\n    work_start, work_end = work_hours\n    available_times = []\n\n    # Check each time slot within the work hours\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        is_free = True\n        for busy_times in participants_busy_times:\n            for start, end in busy_times:\n                if current_time < end and current_time + meeting_duration > start:\n                    is_free = False\n                    break\n            if not is_free:\n                break\n        if is_free:\n            available_times.append(current_time)\n        current_time += 1  # Incrementing by one hour\n    \n    # Return the first available time in HH:MM:HH:MM format\n    if available_times:\n        start_time = available_times[0]\n        end_time = start_time + meeting_duration\n        return f\"{start_time:02}:00:{end_time:02}:00\"\n\n# Participant's busy schedules on Monday\nparticipants_busy_times = [\n    [(14, 14.5), (15.5, 16)],  # Donna's busy times\n    [(11, 11.5), (16.5, 17)],  # John's busy times\n    [(9, 10), (10.5, 14), (14.5, 17)]  # Billy's busy times\n]\n\n# Meeting duration in hours\nmeeting_duration = 0.5  # 30 minutes\n\n# Work hours from 9:00 to 17:00\nwork_hours = (9, 17)\n\n# Find the suitable meeting time\nmeeting_time = find_meeting_time(participants_busy_times, meeting_duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_4"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\n# Define the busy times for each participant\nkathryn_busy = [(9, 30), (10, 30), (11, 30), (13, 30), (16, 30)]\ncharlotte_busy = [(12, 0), (16, 0)]\nlauren_busy = [(9, 0), (12, 0), (13, 30), (15, 0), (16, 30)]\nmeeting_duration = 30  # in minutes\n\n# Function to convert hours and minutes into a single time integer\ndef time_to_minutes(hour, minute):\n    return hour * 60 + minute\n\n# Function to find a suitable meeting time\ndef find_meeting_time():\n    work_start = time_to_minutes(9, 0)\n    work_end = time_to_minutes(17, 0)\n\n    # Create a list of busy times combined from all participants\n    busy_times = []\n    for busy in kathryn_busy + charlotte_busy + lauren_busy:\n        busy_start = time_to_minutes(busy[0], busy[1])\n        if busy[0] == 10 and busy[1] == 30:  # Kathryn's schedule conflict\n            busy_end = time_to_minutes(11, 0)\n        else:\n            busy_end = busy_start + meeting_duration\n        busy_times.append((busy_start, busy_end))\n\n    # Sort busy times for processing\n    busy_times.sort()\n\n    # Find free time slots in the work hours\n    last_end = work_start\n    for start, end in busy_times:\n        if last_end + meeting_duration <= start and last_end <= work_end:\n            return f\"{last_end // 60:02}:{last_end % 60:02}:{last_end + meeting_duration // 60:02}:{(last_end + meeting_duration) % 60:02}\"\n        last_end = max(last_end, end)\n\n    # Check for a time slot after the last busy time until work end\n    if last_end + meeting_duration <= work_end:\n        return f\"{last_end // 60:02}:{last_end % 60:02}:{last_end + meeting_duration // 60:02}:{(last_end + meeting_duration) % 60:02}\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_5"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the work hours and participants' schedules\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"17:00\", \"%H:%M\")\nmeeting_duration = timedelta(hours=1)\n\n# Thomas's schedule (open)\nthomas_schedule = [(work_start, work_end)]\n\n# Dylan's schedule (busy)\ndylan_schedule = [\n    (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n    (datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\"))\n]\n\n# Jerry's schedule (busy)\njerry_schedule = [\n    (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n    (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\")),\n    (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))\n]\n\n# Function to find a suitable time slot for the meeting\ndef find_meeting_time(thomas, dylan, jerry, duration):\n    # Create a list of busy slots from Dylan and Jerry\n    busy_slots = dylan + jerry\n    busy_slots.sort(key=lambda x: x[0])  # Sort by start time\n\n    # Generate free slots in Thomas's schedule\n    free_slots = []\n    current_start = thomas[0][0]\n    \n    for start, end in busy_slots:\n        if current_start < start:  # Free time available\n            free_slots.append((current_start, start))\n        current_start = max(current_start, end)\n\n    if current_start < thomas[0][1]:  # Check for free time after the last busy slot\n        free_slots.append((current_start, thomas[0][1]))\n\n    # Find a suitable slot for the meeting\n    for start, end in free_slots:\n        if end - start >= duration:  # Enough time for the meeting\n            proposed_start = start\n            proposed_end = proposed_start + duration\n            return proposed_start.strftime(\"%H:%M\"), proposed_end.strftime(\"%H:%M\")\n    \n    return None\n\n# Find a meeting time\nmeeting_time = find_meeting_time(thomas_schedule, dylan_schedule, jerry_schedule, meeting_duration)\nif meeting_time:\n    print(f\"{{{meeting_time[0]}:{meeting_time[1]}}}\")\nelse:\n    print(\"No available time slot for the meeting.\")\n```",
            "count": "calendar_scheduling_example_6"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the working hours and participants' schedules\nworking_hours_start = datetime.strptime(\"09:00\", \"%H:%M\")\nworking_hours_end = datetime.strptime(\"17:00\", \"%H:%M\")\nparticipants_schedules = {\n    \"Heather\": [\n        (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n        (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n        (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\")),\n        (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n        (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))\n    ],\n    \"Nicholas\": [],\n    \"Zachary\": [\n        (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n        (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n        (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n        (datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))\n    ]\n}\n\nmeeting_duration = timedelta(minutes=30)  # 30 minutes\n\n# Create a list of busy slots for all participants\nbusy_slots = []\nfor schedule in participants_schedules.values():\n    busy_slots.extend(schedule)\n\n# Define function to find a suitable time for the meeting\ndef find_meeting_time(start, end, busy_slots, duration):\n    current_time = start\n    while current_time + duration <= end:\n        meeting_slot = (current_time, current_time + duration)\n        if all(not (meeting_slot[0] < busy[1] and meeting_slot[1] > busy[0]) for busy in busy_slots):\n            if current_time < datetime.strptime(\"14:00\", \"%H:%M\"):\n                return current_time.strftime(\"%H:%M\") + \":\" + (current_time + duration).strftime(\"%H:%M\")\n        current_time += timedelta(minutes=1)\n    return None\n\n# Find the meeting time considering the constraints\nmeeting_time = find_meeting_time(working_hours_start, working_hours_end, busy_slots, meeting_duration)\nif meeting_time:\n    print(f\"{meeting_time}\")\n```",
            "count": "calendar_scheduling_example_7"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:11:30}",
            "type_error": "ValueError",
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants_schedules, meeting_duration, work_start, work_end):\n    # Setting time boundaries for the meeting\n    work_start = datetime.strptime(work_start, \"%H:%M\")\n    work_end = datetime.strptime(work_end, \"%H:%M\")\n    \n    # Calculate end time of the meeting based on the duration\n    meeting_duration = timedelta(minutes=meeting_duration)\n    \n    # Create a list of time slots from work_start to work_end\n    time_slots = []\n    current_time = work_start\n    \n    while current_time + meeting_duration <= work_end:\n        time_slots.append(current_time)\n        current_time += timedelta(minutes=30)  # Increment by 30 minutes for next potential slot\n    \n    valid_slots = []\n    \n    for slot in time_slots:\n        meeting_start = slot\n        meeting_end = slot + meeting_duration\n        \n        if all(not (meeting_start < end and meeting_end > start) for (start, end) in participants_schedules):\n            valid_slots.append((meeting_start, meeting_end))\n    \n    # Return the first valid time slot in the desired format HH:MM:HH:MM\n    if valid_slots:\n        start_time = valid_slots[0][0].strftime(\"%H:%M\")\n        end_time = valid_slots[0][1].strftime(\"%H:%M\")\n        return f\"{start_time}:{end_time}\"\n    \n    return None\n\n# Schedules for each participant\nparticipants_schedules = [\n    [(datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n     (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n     (datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\"))],  # Adam\n\n    [(datetime.strptime(\"9:00\", \"%H:%M\"), datetime.strptime(\"9:30\", \"%H:%M\")),\n     (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n     (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\"))],  # Jerry\n\n    [(datetime.strptime(\"9:30\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n     (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n     (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\")),\n     (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]   # Matthew\n]\n\n# Finding a suitable time\nmeeting_duration = 30  # minutes\nwork_start = \"09:00\"\nwork_end = \"17:00\"\n\nprint(find_meeting_time(participants_schedules, meeting_duration, work_start, work_end))\n```",
            "count": "calendar_scheduling_example_8"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Participants' busy schedules\ndiane_schedule = [(datetime(2023, 10, 2, 9, 0), datetime(2023, 10, 2, 9, 30)),\n                  (datetime(2023, 10, 2, 12, 0), datetime(2023, 10, 2, 12, 30)),\n                  (datetime(2023, 10, 2, 14, 30), datetime(2023, 10, 2, 15, 30))]\n\nkelly_schedule = [(datetime(2023, 10, 2, 9, 30), datetime(2023, 10, 2, 10, 0)),\n                  (datetime(2023, 10, 2, 10, 30), datetime(2023, 10, 2, 11, 0))]\n\ndeborah_schedule = [(datetime(2023, 10, 2, 9, 0), datetime(2023, 10, 2, 9, 30)),\n                    (datetime(2023, 10, 2, 10, 0), datetime(2023, 10, 2, 14, 0)),\n                    (datetime(2023, 10, 2, 14, 30), datetime(2023, 10, 2, 17, 0))]\n\n# Meeting duration\nmeeting_duration = timedelta(minutes=30)\n\n# Work hours\nwork_start = datetime(2023, 10, 2, 9, 0)\nwork_end = datetime(2023, 10, 2, 17, 0)\n\n# Function to check availability for a meeting\ndef is_available(start_time, duration):\n    end_time = start_time + duration\n    for busy_slot in diane_schedule + kelly_schedule + deborah_schedule:\n        if start_time < busy_slot[1] and end_time > busy_slot[0]:\n            return False\n    return True\n\n# Finding a suitable time\ncurrent_time = work_start\nwhile current_time + meeting_duration <= work_end:\n    if is_available(current_time, meeting_duration):\n        print(f\"{current_time.strftime('%H:%M')}:{(current_time + meeting_duration).strftime('%H:%M')}\")\n        break\n    current_time += timedelta(minutes=1)\n```",
            "count": "calendar_scheduling_example_9"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define participants' schedules and constraints\ndiana_schedule = [(datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n                  (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\"))]\n\nethan_schedule = []  # No meetings all day\n\njanet_schedule = [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n                  (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n                  (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n                  (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n\n# Meeting duration\nmeeting_duration = timedelta(minutes=30)\n\n# Define work hours\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"17:00\", \"%H:%M\")\n\n# Function to check if the time slot is free for all participants\ndef time_slot_free(start_time, duration):\n    end_time = start_time + duration\n    \n    for start, end in diana_schedule:\n        if start_time < end and end_time > start:\n            return False\n            \n    for start, end in janet_schedule:\n        if start_time < end and end_time > start:\n            return False\n            \n    return True\n\n# Find a suitable time\ncurrent_time = work_start\nwhile current_time + meeting_duration <= work_end:\n    if time_slot_free(current_time, meeting_duration):\n        proposed_start = current_time.strftime(\"%H:%M\")\n        proposed_end = (current_time + meeting_duration).strftime(\"%H:%M\")\n        print(f'{{{proposed_start}:{proposed_end}}}')\n        break\n    current_time += timedelta(minutes=30)\n```",
            "count": "calendar_scheduling_example_10"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(schedules, meeting_duration):\n    start_time = datetime.strptime(\"09:00\", \"%H:%M\")\n    end_time = datetime.strptime(\"17:00\", \"%H:%M\")\n    meeting_duration = timedelta(minutes=meeting_duration)\n\n    # Create a list of busy times for all participants\n    busy_times = []\n    for schedule in schedules:\n        for busy_time in schedule:\n            busy_times.append(busy_time)\n\n    # Sort and merge overlapping busy times\n    busy_times.sort()\n    merged_busy_times = []\n    for current_start, current_end in busy_times:\n        if not merged_busy_times or merged_busy_times[-1][1] < current_start:\n            merged_busy_times.append((current_start, current_end))\n        else:\n            merged_busy_times[-1] = (merged_busy_times[-1][0], max(merged_busy_times[-1][1], current_end))\n\n    # Find a suitable time slot for the meeting\n    last_end_time = start_time\n    for busy_start, busy_end in merged_busy_times:\n        if last_end_time + meeting_duration <= busy_start:\n            return (last_end_time.strftime(\"%H:%M\"), (last_end_time + meeting_duration).strftime(\"%H:%M\"))\n        last_end_time = max(last_end_time, busy_end)\n\n    # Check if there's time at the end of the day\n    if last_end_time + meeting_duration <= end_time:\n        return (last_end_time.strftime(\"%H:%M\"), (last_end_time + meeting_duration).strftime(\"%H:%M\"))\n\n    return None\n\n# Participants' schedules\nschedules = [\n    [(datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n     (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n     (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n     (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n     (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))],  # Alexander's schedule\n\n    [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n     (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n     (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\"))],  # Elizabeth's schedule\n\n    [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\")),\n     (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]  # Walter's schedule\n]\n\nmeeting_duration = 30  # Meeting duration in minutes\nresult = find_meeting_time(schedules, meeting_duration)\nif result:\n    print(f\"{result[0]}:{result[1]}\")\n```",
            "count": "calendar_scheduling_example_11"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define the working hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define the participants' schedules in minutes\n    david_schedule = []  # David has no meetings\n    debra_schedule = [(9 * 60 + 30, 10 * 60), (11 * 60, 11 * 60 + 30), \n                      (12 * 60, 13 * 60), (14 * 60, 14 * 60 + 30), \n                      (16 * 60, 16 * 60 + 30)]\n    kevin_schedule = [(9 * 60, 12 * 60), (14 * 60, 17 * 60)]\n    \n    # Check all possible meeting slots\n    for start_time in range(work_start, work_end * 60 - 60 + 1):\n        end_time = start_time + 60  # Meeting duration is 1 hour\n        \n        # Check if the slot is free for Debra\n        debra_free = True\n        for start, end in debra_schedule:\n            if start_time < end and end_time > start:  # There is a conflict\n                debra_free = False\n                break\n                \n        # Check if the slot is free for Kevin\n        kevin_free = True\n        for start, end in kevin_schedule:\n            if start_time < end and end_time > start:  # There is a conflict\n                kevin_free = False\n                break\n        \n        # If both are free, we found a suitable time\n        if debra_free and kevin_free:\n            return f\"{start_time // 60:02}:{start_time % 60:02}:{end_time // 60:02}:{end_time % 60:02}\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_12"
        },
        {
            "final_program_time": "{9:00:0:09}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the participants' schedules\nschedules = {\n    \"Gerald\": [\n        (\"09:00\", \"09:30\"), \n        (\"13:00\", \"14:00\"), \n        (\"15:00\", \"15:30\"), \n        (\"16:00\", \"17:00\")\n    ],\n    \"Roy\": [],\n    \"Barbara\": [\n        (\"09:30\", \"10:00\"), \n        (\"11:30\", \"14:00\"), \n        (\"14:30\", \"15:00\"), \n        (\"15:30\", \"17:00\")\n    ]\n}\n\n# Meeting duration\nmeeting_duration = timedelta(minutes=30)\n\n# Work hours\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"17:00\", \"%H:%M\")\n\n# Function to find available time for the meeting\ndef find_meeting_time(schedules, meeting_duration, work_start, work_end):\n    # Create a list for all busy times\n    busy_times = []\n    \n    # Collect all busy intervals\n    for participant, times in schedules.items():\n        for start, end in times:\n            busy_times.append((datetime.strptime(start, \"%H:%M\"), datetime.strptime(end, \"%H:%M\")))\n\n    # Add boundaries\n    busy_times.append((work_start, work_start))\n    busy_times.append((work_end, work_end))\n\n    # Sort busy times\n    busy_times.sort(key=lambda x: x[0])\n\n    # Check for gaps between busy times\n    for i in range(1, len(busy_times)):\n        end_of_previous = busy_times[i - 1][1]\n        start_of_current = busy_times[i][0]\n        \n        # Calculate the gap\n        gap = start_of_current - end_of_previous\n        if gap >= meeting_duration:\n            # Found a suitable time range\n            meeting_start = end_of_previous\n            meeting_end = meeting_start + meeting_duration\n            \n            # Check if the proposed meeting is within work hours\n            if meeting_end <= work_end:\n                return meeting_start.strftime(\"%H:%M:%S\") + \":\" + meeting_end.strftime(\"%H:%M:%S\")\n\n# Calculate the proposed meeting time\nproposed_time = find_meeting_time(schedules, meeting_duration, work_start, work_end)\nprint(proposed_time)  # Output the proposed time\n```\n",
            "count": "calendar_scheduling_example_13"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(work_start, work_end, duration, schedules, preferences):\n    # Convert string time to datetime object\n    work_start = datetime.strptime(work_start, \"%H:%M\")\n    work_end = datetime.strptime(work_end, \"%H:%M\")\n    \n    # Create a list of busy times\n    busy_times = []\n    for schedule in schedules:\n        for busy_start, busy_end in schedule:\n            busy_times.append((datetime.strptime(busy_start, \"%H:%M\"), datetime.strptime(busy_end, \"%H:%M\")))\n    \n    # Add preferred avoidance time for Brandon\n    if preferences.get('Brandon', {}).get('avoid_before'):\n        avoid_time = datetime.strptime(preferences['Brandon']['avoid_before'], \"%H:%M\")\n        busy_times.append((work_start, avoid_time))\n    \n    # Sort busy times\n    busy_times.sort()\n\n    # Find gaps in the schedule\n    last_end = work_start\n    for busy_start, busy_end in busy_times:\n        if busy_start > last_end:\n            gap_start = last_end\n            gap_end = busy_start\n            if gap_end - gap_start >= timedelta(minutes=duration):\n                return f\"{gap_start.strftime('%H:%M')}:{(gap_start + timedelta(minutes=duration)).strftime('%H:%M')}\"\n        last_end = max(last_end, busy_end)\n    \n    # Check for a gap after the last busy time until work_end\n    if last_end < work_end:\n        gap_start = last_end\n        gap_end = work_end\n        if gap_end - gap_start >= timedelta(minutes=duration):\n            return f\"{gap_start.strftime('%H:%M')}:{(gap_start + timedelta(minutes=duration)).strftime('%H:%M')}\"\n    \n    return None \n\n# Define work hours and meeting duration\nwork_hours = (\"09:00\", \"17:00\")\nmeeting_duration = 30  # in minutes\n\n# Existing schedules for each participant (start time, end time)\nschedules = {\n    \"Brandon\": [(\"13:00\", \"14:00\"), (\"15:30\", \"16:00\"), (\"16:30\", \"17:00\")],\n    \"Jerry\": [],\n    \"Bradley\": [(\"09:00\", \"11:30\"), (\"12:00\", \"15:00\"), (\"16:00\", \"16:30\")],\n}\n\n# Preferences regarding avoiding meetings\npreferences = {\n    \"Brandon\": {\n        \"avoid_before\": \"14:30\"\n    }\n}\n\n# Gather all into a list for processing\nschedules_list = [schedules[\"Brandon\"], schedules[\"Jerry\"], schedules[\"Bradley\"]]\n\n# Call the scheduling function\nmeeting_time = find_meeting_time(work_hours[0], work_hours[1], meeting_duration, schedules_list, preferences)\nprint(meeting_time)  # Output should be in the format HH:MM:HH:MM\n```",
            "count": "calendar_scheduling_example_14"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define participant schedules\njoyce_schedule = [(datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n                  (datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\")),\n                  (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))]\n\nalexander_schedule = [(datetime.strptime(\"9:00\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n                      (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n                      (datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n                      (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\")),\n                      (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n\n# Define meeting constraints\nmeeting_duration = timedelta(minutes=30)\nstart_of_day = datetime.strptime(\"09:00\", \"%H:%M\")\nend_of_day = datetime.strptime(\"17:00\", \"%H:%M\")\n\n# Function to find a suitable meeting time\ndef find_meeting_time():\n    current_time = start_of_day\n\n    while current_time + meeting_duration <= end_of_day:\n        # Check if the current time slot is free for all participants\n        meeting_start = current_time\n        meeting_end = current_time + meeting_duration\n\n        # Check Joyce's schedule\n        if any(joyce_start < meeting_end and joyce_end > meeting_start for joyce_start, joyce_end in joyce_schedule):\n            current_time += timedelta(minutes=5)  # Move to next slot\n            continue\n            \n        # Check Alexander's schedule\n        if any(alex_start < meeting_end and alex_end > meeting_start for alex_start, alex_end in alexander_schedule):\n            current_time += timedelta(minutes=5)  # Move to next slot\n            continue\n        \n        # Check Christine's availability (not available before 12:00)\n        if meeting_start < datetime.strptime(\"12:00\", \"%H:%M\"):\n            current_time += timedelta(minutes=5)\n            continue\n        \n        # If we reach here, a suitable time was found\n        return meeting_start.strftime(\"%H:%M\") + \":\" + meeting_end.strftime(\"%H:%M\")\n    \n    return None  # If no suitable time found\n\n# Get proposed meeting time\nproposed_time = find_meeting_time()\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_15"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:00}",
            "type_error": "ValueError",
            "full_response": "```python\n# Define the schedules and meeting duration\nscott_schedule = [(9, 30, 10, 30), (13, 30, 14, 0), (14, 30, 15, 0), (15, 30, 16, 0), (16, 30, 17, 0)]\ngabriel_schedule = []  # No meetings all day\nchristine_schedule = [(9, 0, 10, 0), (10, 30, 12, 30), (13, 0, 17, 0)]\nmeeting_duration = 30  # minutes\n\n# Define work hours\nwork_start = (9, 0)\nwork_end = (17, 0)\n\n# Function to check availability\ndef is_available(start, end, schedule):\n    for busy_start, busy_end in schedule:\n        if not (end <= (busy_start[0], busy_start[1]) or start >= (busy_end[0], busy_end[1])):\n            return False\n    return True\n\n# Find a suitable meeting time\ndef find_meeting_time():\n    for hour in range(work_start[0], work_end[0]):\n        for minute in range(0, 60, 30):  # Check every 30 minutes\n            start_time = (hour, minute)\n            end_time = (hour, minute + meeting_duration) if minute + meeting_duration < 60 else (hour + 1, 0)\n            if end_time[0] >= work_end[0]:  # If end time goes beyond work hours\n                break\n\n            if is_available(start_time, end_time, scott_schedule) and \\\n               is_available(start_time, end_time, gabriel_schedule) and \\\n               is_available(start_time, end_time, christine_schedule):\n                return f\"{start_time[0]:02}:{start_time[1]:02}:{end_time[0]:02}:{end_time[1]:02}\"\n\n# Output proposed meeting time\nproposed_time = find_meeting_time()\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_16"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the participants and their schedules\nparticipants = {\n    \"Margaret\": [\n        (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n        (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n        (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n        (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n        (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\")),\n    ],\n    \"Donna\": [\n        (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n        (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\")),\n    ],\n    \"Helen\": [\n        (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n        (datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n        (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\")),\n        (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n        (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\")),\n    ],\n}\n\n# Meeting constraints\nmeeting_duration = timedelta(minutes=30)\nend_of_work_hours = datetime.strptime(\"17:00\", \"%H:%M\")\nmeeting_start_time = datetime.strptime(\"09:00\", \"%H:%M\")\nmeeting_end_time = datetime.strptime(\"13:30\", \"%H:%M\")\n\n# Find available slots\ndef find_meeting_time():\n    busy_times = []\n    for schedule in participants.values():\n        busy_times.extend(schedule)\n    \n    # Sort the busy times\n    busy_times.sort(key=lambda x: x[0])\n    \n    # Create a list of free slots\n    last_end_time = meeting_start_time\n    for start, end in busy_times:\n        if last_end_time + meeting_duration <= start:\n            # Found a free slot\n            return last_end_time.strftime(\"%H:%M\"), (last_end_time + meeting_duration).strftime(\"%H:%M\")\n        last_end_time = max(last_end_time, end)\n    \n    # Check after last busy time till the end of work hours\n    if last_end_time + meeting_duration <= end_of_work_hours:\n        return last_end_time.strftime(\"%H:%M\"), (last_end_time + meeting_duration).strftime(\"%H:%M\")\n    \n    return None\n\nstart, end = find_meeting_time()\nprint(f'{start}:{end}')\n```",
            "count": "calendar_scheduling_example_17"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Participants' busy schedules\nbilly_busy = [\n    (datetime.strptime('10:00', '%H:%M'), datetime.strptime('10:30', '%H:%M')),\n    (datetime.strptime('11:30', '%H:%M'), datetime.strptime('12:00', '%H:%M')),\n    (datetime.strptime('14:00', '%H:%M'), datetime.strptime('14:30', '%H:%M')),\n    (datetime.strptime('16:30', '%H:%M'), datetime.strptime('17:00', '%H:%M')),\n]\n\npatricia_busy = [\n    (datetime.strptime('9:00', '%H:%M'), datetime.strptime('12:30', '%H:%M')),\n    (datetime.strptime('13:30', '%H:%M'), datetime.strptime('14:00', '%H:%M')),\n    (datetime.strptime('14:30', '%H:%M'), datetime.strptime('16:00', '%H:%M')),\n    (datetime.strptime('16:30', '%H:%M'), datetime.strptime('17:00', '%H:%M')),\n]\n\n# Meeting duration\nmeeting_duration = timedelta(minutes=30)\n\n# Work hours\nwork_start = datetime.strptime('9:00', '%H:%M')\nwork_end = datetime.strptime('17:00', '%H:%M')\n\n# Function to find available meeting time\ndef find_meeting_time():\n    current_time = work_start\n    \n    while current_time + meeting_duration <= work_end:\n        end_time = current_time + meeting_duration\n        if all(not (start < end_time and current_time < finish) for start, finish in billy_busy) and \\\n           all(not (start < end_time and current_time < finish) for start, finish in patricia_busy):\n            # Check Billy's preference to not meet after 15:30\n            if current_time.time() <= datetime.strptime('15:30', '%H:%M').time():\n                return current_time.strftime('%H:%M') + ':' + end_time.strftime('%H:%M')\n        current_time += timedelta(minutes=1)\n    \n    return None\n\n# Get proposed time\nproposed_time = find_meeting_time()\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_18"
        },
        {
            "final_program_time": "{11:30:0:12}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participant_schedules, meeting_duration, work_start, work_end):\n    # Work hours as datetime objects\n    work_start = datetime.strptime(work_start, \"%H:%M\")\n    work_end = datetime.strptime(work_end, \"%H:%M\")\n    \n    # Create a list of busy times for each participant\n    busy_intervals = []\n    for busy_times in participant_schedules.values():\n        for start, end in busy_times:\n            busy_intervals.append((start, end))\n\n    # Sort intervals\n    busy_intervals.sort()\n\n    # Convert meeting_duration to timedelta\n    meeting_duration = timedelta(hours=meeting_duration)\n\n    # Find free slots\n    last_end = work_start\n    for start, end in busy_intervals:\n        if last_end + meeting_duration <= start:\n            return f\"{last_end.time()}:{(last_end + meeting_duration).time()}\"\n        last_end = max(last_end, end)\n    \n    # Check if there's time after the last busy interval before work_end\n    if last_end + meeting_duration <= work_end:\n        return f\"{last_end.time()}:{(last_end + meeting_duration).time()}\"\n\n    return None\n\n# Example schedules\nschedules = {\n    'Stephen': [(datetime.strptime('10:00', \"%H:%M\"), datetime.strptime('10:30', \"%H:%M\")),\n                (datetime.strptime('13:00', \"%H:%M\"), datetime.strptime('13:30', \"%H:%M\")),\n                (datetime.strptime('14:30', \"%H:%M\"), datetime.strptime('15:00', \"%H:%M\")),\n                (datetime.strptime('16:00', \"%H:%M\"), datetime.strptime('16:30', \"%H:%M\"))],\n    'Edward': [(datetime.strptime('09:00', \"%H:%M\"), datetime.strptime('09:30', \"%H:%M\")),\n               (datetime.strptime('10:00', \"%H:%M\"), datetime.strptime('10:30', \"%H:%M\")),\n               (datetime.strptime('13:30', \"%H:%M\"), datetime.strptime('14:30', \"%H:%M\")),\n               (datetime.strptime('15:00', \"%H:%M\"), datetime.strptime('16:00', \"%H:%M\"))],\n    'Angela': [(datetime.strptime('09:00', \"%H:%M\"), datetime.strptime('11:30', \"%H:%M\")),\n               (datetime.strptime('12:30', \"%H:%M\"), datetime.strptime('13:00', \"%H:%M\")),\n               (datetime.strptime('13:30', \"%H:%M\"), datetime.strptime('15:30', \"%H:%M\")),\n               (datetime.strptime('16:00', \"%H:%M\"), datetime.strptime('17:00', \"%H:%M\"))]\n}\n\n# Duration of the meeting in hours\nmeeting_duration = 1  # 1 hour\n\n# Work hours\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\n\n# Find a suitable time\nmeeting_time = find_meeting_time(schedules, meeting_duration, work_hours_start, work_hours_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_19"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef is_time_slot_free(start, end, busy_slots):\n    for slot_start, slot_end in busy_slots:\n        if (start < slot_end and end > slot_start):\n            return False\n    return True\n\ndef find_meeting_time(participants, meeting_duration):\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    \n    current_time = work_start\n    meeting_duration_timedelta = timedelta(minutes=meeting_duration)\n\n    while current_time + meeting_duration_timedelta <= work_end:\n        end_time = current_time + meeting_duration_timedelta\n        if all(is_time_slot_free(current_time, end_time, busy_slots) for busy_slots in participants.values()):\n            return current_time.strftime(\"%H:%M\") + \":\" + end_time.strftime(\"%H:%M\")\n        current_time += timedelta(minutes=30)  # Check next half-hour slot\n\n    return None\n\n# Schedule constraints\nparticipants_schedules = {\n    \"Ralph\": [(datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\")),\n              (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\"))],\n    \"Peter\": [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n              (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n              (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))],\n    \"Daniel\": [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n               (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\")),\n               (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))],\n}\n\nmeeting_duration = 30  # in minutes\nproposed_time = find_meeting_time(participants_schedules, meeting_duration)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_20"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(bobby_avail, scott_avail, kimberly_avail, meeting_duration):\n    work_start = datetime.strptime('09:00', '%H:%M')\n    work_end = datetime.strptime('17:00', '%H:%M')\n\n    # Create a list of all time slots during the work hours\n    time_slots = []\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        time_slots.append(current_time)\n        current_time += timedelta(minutes=30)  # Check every 30 minutes\n\n    # Check each time slot against participant availability\n    for start_time in time_slots:\n        end_time = start_time + meeting_duration\n        if (start_time in bobby_avail and \n            start_time in scott_avail and \n            start_time in kimberly_avail and \n            end_time in bobby_avail and \n            end_time in scott_avail and \n            end_time in kimberly_avail):\n            return start_time.strftime(\"%H:%M\") + \":\" + end_time.strftime(\"%H:%M\")\n    \n    return None\n\n# Define available times for each participant as sets\nbobby_available = {datetime.strptime('09:00', '%H:%M') + timedelta(minutes=30 * i) for i in range(16)}\nscott_available = {datetime.strptime('09:00', '%H:%M'), datetime.strptime('09:30', '%H:%M'), datetime.strptime('10:00', '%H:%M'), datetime.strptime('10:30', '%H:%M'),\n                   datetime.strptime('12:00', '%H:%M'), datetime.strptime('12:30', '%H:%M'), datetime.strptime('13:00', '%H:%M'), datetime.strptime('13:30', '%H:%M'),\n                   datetime.strptime('14:00', '%H:%M'), datetime.strptime('14:30', '%H:%M'), datetime.strptime('15:00', '%H:%M')}\nkimberly_available = {datetime.strptime('09:00', '%H:%M'), datetime.strptime('09:30', '%H:%M'), datetime.strptime('10:00', '%H:%M'), \n                      datetime.strptime('10:30', '%H:%M'), datetime.strptime('12:00', '%H:%M'), datetime.strptime('13:00', '%H:%M'), \n                      datetime.strptime('13:30', '%H:%M'), datetime.strptime('15:00', '%H:%M'), datetime.strptime('15:30', '%H:%M')}\n\n# Meeting duration\nmeeting_duration = timedelta(hours=1)\n\n# Find a suitable time\nproposed_time = find_meeting_time(bobby_available, scott_available, kimberly_available, meeting_duration)\nprint(proposed_time)  # This will output the valid proposed time\n```",
            "count": "calendar_scheduling_example_21"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the schedule of each participant in terms of busy slots\nschedule = {\n    \"Theresa\": [(\"09:00\", \"09:30\"), (\"12:30\", \"13:30\"), (\"14:00\", \"15:00\"), (\"16:30\", \"17:00\")],\n    \"Charles\": [(\"10:00\", \"10:30\"), (\"11:30\", \"12:30\"), (\"14:00\", \"15:30\")],\n    \"Betty\": [(\"09:00\", \"10:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"14:00\"), (\"15:00\", \"16:00\")]\n}\n\n# Meeting duration in hours\nmeeting_duration = timedelta(hours=1)\n\n# Work hours\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"17:00\", \"%H:%M\")\n\n# Generate a list of all busy time slots\nbusy_times = []\nfor participant, busy_slots in schedule.items():\n    for start, end in busy_slots:\n        busy_times.append((datetime.strptime(start, \"%H:%M\"), datetime.strptime(end, \"%H:%M\")))\n\n# Function to check if time slot is available\ndef is_available(start_time, end_time):\n    for busy_start, busy_end in busy_times:\n        if start_time < busy_end and end_time > busy_start:\n            return False\n    return True\n\n# Find a suitable time for the meeting\ndef find_meeting_time():\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        end_time = current_time + meeting_duration\n        if is_available(current_time, end_time):\n            return f\"{current_time.strftime('%H:%M')}:{end_time.strftime('%H:%M')}\"\n        current_time += timedelta(minutes=30)  # Increment by 30 mins\n    return None\n\n# Execute the function and print the proposed meeting time\nmeeting_time = find_meeting_time()\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_22"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define working hours\nstart_time = datetime.strptime(\"09:00\", \"%H:%M\")\nend_time = datetime.strptime(\"17:00\", \"%H:%M\")\nmeeting_duration = timedelta(hours=1)\n\n# Define participants' busy schedules\nbilly_busy = [(datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n               (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n               (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))]\n\nmaria_busy = [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n               (datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n               (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n               (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\"))]\n\nwilliam_busy = [(datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n                 (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n                 (datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n                 (datetime.strptime(\"15:30\", \"%H:%M\"), end_time)]\n\n# Function to check if a time slot is free for all participants\ndef is_time_slot_free(start, end):\n    for busy in billy_busy:\n        if start < busy[1] and end > busy[0]:\n            return False\n    for busy in maria_busy:\n        if start < busy[1] and end > busy[0]:\n            return False\n    for busy in william_busy:\n        if start < busy[1] and end > busy[0]:\n            return False\n    return True\n\n# Find a free time slot\ncurrent_time = start_time\nwhile current_time + meeting_duration <= end_time:\n    next_time = current_time + meeting_duration\n    if is_time_slot_free(current_time, next_time):\n        print(f\"{current_time.strftime('%H:%M')}:{next_time.strftime('%H:%M')}\")\n        break\n    current_time += timedelta(minutes=30)  # check every 30 minutes\n```",
            "count": "calendar_scheduling_example_23"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define work hours and meeting duration\nwork_start = datetime.strptime('09:00', '%H:%M')\nwork_end = datetime.strptime('17:00', '%H:%M')\nmeeting_duration = timedelta(minutes=30)\n\n# Participants' schedules\nbenjamin_free_before = datetime.strptime('09:30', '%H:%M')\nhannah_free = (work_start, work_end)\nbrenda_schedule = [\n    (datetime.strptime('09:30', '%H:%M'), datetime.strptime('10:00', '%H:%M')),\n    (datetime.strptime('11:30', '%H:%M'), datetime.strptime('12:30', '%H:%M')),\n    (datetime.strptime('14:00', '%H:%M'), datetime.strptime('16:30', '%H:%M')),\n]\n\n# Create a list of free time slots for Brenda\nbrenda_free_slots = []\nlast_end = work_start\n\nfor start, end in brenda_schedule:\n    if last_end < start:\n        brenda_free_slots.append((last_end, start))\n    last_end = end\n\nif last_end < work_end:\n    brenda_free_slots.append((last_end, work_end))\n\n# Find a suitable time slot\nfor start, end in brenda_free_slots:\n    # Check if it fits in Benjamin's constraint and the meeting duration\n    if start >= work_start and end <= benjamin_free_before and end - start >= meeting_duration:\n        proposed_time_start = start\n        proposed_time_end = proposed_time_start + meeting_duration\n        if proposed_time_end <= end:\n            print(f\"{proposed_time_start.strftime('%H:%M')}:{proposed_time_end.strftime('%H:%M')}\")\n            break\n```",
            "count": "calendar_scheduling_example_24"
        },
        {
            "final_program_time": "{13:30:14:30}",
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Work hours\n    work_start = 9 * 60  # 9:00 AM in minutes\n    work_end = 17 * 60   # 5:00 PM in minutes\n\n    # Existing schedules in minutes\n    anthony_schedule = [(9 * 60 + 30, 10 * 60), (12 * 60, 13 * 60), (16 * 60, 16 * 60 + 30)]\n    pamela_schedule = [(9 * 60 + 30, 10 * 60), (16 * 60 + 30, 17 * 60)]\n    zachary_schedule = [(9 * 60, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), \n                        (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60), \n                        (16 * 60, 17 * 60)]\n\n    # Pamela's preference\n    pamela_pref_end = 14 * 60 + 30  # 2:30 PM in minutes\n\n    # Combine all schedules into busy slots\n    busy_slots = anthony_schedule + pamela_schedule + zachary_schedule\n    busy_slots.sort()\n\n    # Free time slots detection\n    free_slots = []\n    last_end = work_start\n    for start, end in busy_slots:\n        if last_end < start:\n            free_slots.append((last_end, start))\n        last_end = max(last_end, end)\n    \n    if last_end < work_end:\n        free_slots.append((last_end, work_end))\n\n    # Check for one-hour meeting time\n    for start, end in free_slots:\n        if end - start >= 60:  # 60 minutes for the meeting\n            # Ensure it falls within Pamela's preferences\n            if start <= pamela_pref_end:\n                proposed_start = start\n                proposed_end = start + 60\n                return f\"{proposed_start // 60:02}:{proposed_start % 60:02}:{proposed_end // 60:02}:{proposed_end % 60:02}\"\n\nresult = find_meeting_time()\nprint(result)\n```",
            "count": "calendar_scheduling_example_25"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:30:16:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Participant schedules\nkatherine_schedule = [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\nnicole_schedule = [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\nkevin_schedule = [\n    (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n    (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n    (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\")),\n    (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))\n]\n\n# Meeting duration\nmeeting_duration = timedelta(hours=1)\n\n# Function to find free time slots for each participant\ndef get_free_slots(schedule, work_start, work_end):\n    free_slots = []\n    last_end = work_start\n    for start, end in schedule:\n        if last_end < start:\n            free_slots.append((last_end, start))\n        last_end = max(last_end, end)\n    if last_end < work_end:\n        free_slots.append((last_end, work_end))\n    return free_slots\n\n# Constructing the work hours for Monday\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"17:00\", \"%H:%M\")\n\n# Get free slots for each participant\nkatherine_free_slots = get_free_slots(katherine_schedule, work_start, work_end)\nnicole_free_slots = get_free_slots(nicole_schedule, work_start, work_end)\nkevin_free_slots = get_free_slots(kevin_schedule, work_start, work_end)\n\n# Finding a suitable time for the meeting\ndef find_meeting_time(katherine_slots, nicole_slots, kevin_slots, duration):\n    for start_k, end_k in katherine_slots:\n        for start_n, end_n in nicole_slots:\n            for start_v, end_v in kevin_slots:\n                # Find overlapping intervals\n                start_time = max(start_k, start_n, start_v)\n                end_time = min(end_k, end_n, end_v)\n\n                if (end_time - start_time) >= duration:\n                    return start_time, start_time + duration\n    return None, None\n\n# Find and print the meeting time\nmeeting_start, meeting_end = find_meeting_time(katherine_free_slots, nicole_free_slots, kevin_free_slots, meeting_duration)\n\nif meeting_start and meeting_end:\n    output_time = f\"{meeting_start.strftime('%H:%M')}:{meeting_end.strftime('%H:%M')}\"\n    print(output_time)\nelse:\n    print(\"No suitable meeting time found.\")\n```",
            "count": "calendar_scheduling_example_26"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:9:30}",
            "type_error": "TypeError",
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(schedules, meeting_duration):\n    # Setting work hours\n    start_of_day = datetime.strptime(\"09:00\", \"%H:%M\")\n    end_of_day = datetime.strptime(\"17:00\", \"%H:%M\")\n\n    # Convert schedules to time blocks\n    busy_slots = []\n    for participant in schedules:\n        busy_slots.extend(participant)\n\n    # Create a merged list of busy times\n    busy_slots.sort()\n\n    # Initialize the current time to the start of the day\n    current_time = start_of_day\n\n    # Check for available slots\n    for start, end in busy_slots:\n        while current_time + meeting_duration <= start:  # Check for free time before the busy slot\n            proposed_meeting_end = current_time + meeting_duration\n            if proposed_meeting_end <= end_of_day:\n                return f\"{current_time.strftime('%H:%M')}:{proposed_meeting_end.strftime('%H:%M')}\"\n            current_time += meeting_duration\n        \n        current_time = max(current_time, end)  # Move forward to the end of the busy slot\n\n    # Finally check for time after the last busy slot\n    if current_time + meeting_duration <= end_of_day:\n        proposed_meeting_end = current_time + meeting_duration\n        return f\"{current_time.strftime('%H:%M')}:{proposed_meeting_end.strftime('%H:%M')}\"\n    \n    return None\n\n# Define schedules in (start, end) tuples\njesse_schedule = [(\"10:00\", \"10:30\"), (\"15:30\", \"16:00\")]\nkathryn_schedule = []  # No busy timings\nmegan_schedule = [(\"10:30\", \"11:00\"), (\"11:30\", \"12:30\"), (\"13:30\", \"14:30\"), (\"15:00\", \"16:30\")]\n\n# Convert string times to datetime objects\nschedules = [\n    [(datetime.strptime(start, \"%H:%M\"), datetime.strptime(end, \"%H:%M\")) for start, end in [tuple(jesse_schedule)]],\n    [(datetime.strptime(start, \"%H:%M\"), datetime.strptime(end, \"%H:%M\")) for start, end in [(None, None)]],  # No blocked time\n    [(datetime.strptime(start, \"%H:%M\"), datetime.strptime(end, \"%H:%M\")) for start, end in [tuple(megan_schedule)]],\n]\n\nmeeting_duration = timedelta(minutes=30)\n\n# Find a meeting time\nproposed_time = find_meeting_time(schedules, meeting_duration)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_27"
        },
        {
            "final_program_time": "{11:00:11:00}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the participants' schedules\nschedules = {\n    \"Brittany\": [(datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n                 (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))],\n    \"Emily\": [],\n    \"Doris\": [(datetime.strptime(\"9:00\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n              (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\")),\n              (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n}\n\n# Meeting duration\nmeeting_duration = timedelta(minutes=30)\n\n# Work hours\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"17:00\", \"%H:%M\")\n\n# Find the first available time slot\ndef find_meeting_time(schedules, meeting_duration, work_start, work_end):\n    # Create a list of busy times\n    busy_times = []\n    for busy_slots in schedules.values():\n        busy_times.extend(busy_slots)\n    \n    # Sort busy times\n    busy_times.sort(key=lambda x: x[0])\n\n    # Check for free time slots between work hours\n    current_time = work_start\n    for busy_start, busy_end in busy_times:\n        if current_time + meeting_duration <= busy_start:\n            return current_time.strftime(\"%H:%M:%H:%M\")\n        \n        # Move the current time to the end of the busy slot if it overlaps\n        if current_time < busy_end:\n            current_time = busy_end\n\n    # Check for a slot at the end of the day\n    if current_time + meeting_duration <= work_end:\n        return current_time.strftime(\"%H:%M:%H:%M\")\n    \n    # No suitable time found\n    return None\n\n# Output the proposed meeting time\nprint(find_meeting_time(schedules, meeting_duration, work_start, work_end))\n```",
            "count": "calendar_scheduling_example_28"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the participant's busy schedules\nschedules = {\n    \"Madison\": [(datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n                (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\"))],\n    \"Diana\": [(datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n              (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\"))],\n    \"Shirley\": [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n                (datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n                (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n}\n\n# Meeting duration in minutes\nmeeting_duration = 60\n# Work hours start and end\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"17:00\", \"%H:%M\")\n\n# Create a list of busy times for all participants\nbusy_times = []\nfor times in schedules.values():\n    busy_times.extend(times)\n\n# Sort busy times and create a complete list of busy time slots\nbusy_times.sort()\n\n# Function to find a free slot\ndef find_free_slot(meeting_duration):\n    end_time = work_start\n    for start, end in busy_times:\n        # Check if the gap before the next busy time is enough for a meeting\n        if end_time + timedelta(minutes=meeting_duration) <= start:\n            return (end_time, end_time + timedelta(minutes=meeting_duration))\n        # Move the end_time forward to the end of the busy time\n        if end_time < end:\n            end_time = end\n            \n    # Check the remaining time after the last busy time\n    if end_time + timedelta(minutes=meeting_duration) <= work_end:\n        return (end_time, end_time + timedelta(minutes=meeting_duration))\n\n    return None\n\n# Get the free time slot\nfree_slot = find_free_slot(meeting_duration)\n\n# Output\nif free_slot:\n    print(f\"{free_slot[0].strftime('%H:%M')}:{free_slot[1].strftime('%H:%M')}\")\nelse:\n    print(\"No available slots\")\n```",
            "count": "calendar_scheduling_example_29"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the work schedule and busy times for each participant\nparticipants = {\n    \"Jeffrey\": [(datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n                (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\"))],\n    \"Virginia\": [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n                 (datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n                 (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n                 (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))],\n    \"Melissa\": [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n                (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n                (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n                (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n}\n\n# Define the meeting duration\nmeeting_duration = timedelta(minutes=30)\n\n# Define the working hours\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"17:00\", \"%H:%M\")\n\n# Create a list to hold all busy times\nall_busy_times = []\n\n# Extract busy intervals from all participants\nfor busy_times in participants.values():\n    all_busy_times.extend(busy_times)\n\n# Sort the busy times\nall_busy_times.sort(key=lambda x: x[0])\n\n# Create free time slots based on the busy times\nfree_times = []\nlast_end = work_start\n\nfor start, end in all_busy_times:\n    if last_end < start:\n        free_times.append((last_end, start))\n    last_end = max(last_end, end)\n\n# Don't forget to check for available time after the last busy time until work end\nif last_end < work_end:\n    free_times.append((last_end, work_end))\n\n# Now find a suitable time slot for the meeting\nfor start, end in free_times:\n    if end - start >= meeting_duration:\n        proposed_start = start\n        proposed_end = proposed_start + meeting_duration\n        if proposed_end.time() <= datetime.strptime(\"14:00\", \"%H:%M\").time():\n            # Output the proposed time in the required format\n            print(f\"{proposed_start.strftime('%H:%M')}:{proposed_end.strftime('%H:%M')}\")\n            break\n```",
            "count": "calendar_scheduling_example_30"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the work hours and meeting duration\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"17:00\", \"%H:%M\")\nmeeting_duration = timedelta(minutes=30)\n\n# Existing schedules\nrichard_schedule = [(datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\")),\n                    (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\"))]\nmartha_schedule = [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n                   (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\"))]\nkimberly_schedule = [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n                     (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n                     (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n                     (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\"))]\n\n# Combine all busy time slots\nbusy_slots = richard_schedule + martha_schedule + kimberly_schedule\n\n# Generate a list of potential meeting times\ndef find_meeting_time():\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        # Check if the current time slot intersects with anyone's busy schedule\n        meeting_end = current_time + meeting_duration\n        if all(not (current_time < end and meeting_end > start) for start, end in busy_slots):\n            if current_time >= datetime.strptime(\"14:00\", \"%H:%M\"):\n                return f\"{current_time.strftime('%H:%M')}:{meeting_end.strftime('%H:%M')}\"\n        current_time += timedelta(minutes=1)  # Increment by minute\n    return None\n\nproposed_time = find_meeting_time()\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_31"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the work hours\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"17:00\", \"%H:%M\")\n\n# Define the meetings for each participant\nemily_schedule = [(datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n                  (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n                  (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n                  (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))]\n\nmelissa_schedule = [(datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n                    (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\"))]\n\nfrank_schedule = [(datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n                  (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n                  (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n                  (datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\")),\n                  (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\")),\n                  (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n\n# Define meeting duration\nmeeting_duration = timedelta(minutes=30)\n\n# Function to check if a time slot is free\ndef is_free(time_slot, busy_slots):\n    for start, end in busy_slots:\n        if (time_slot < end and time_slot + meeting_duration > start):\n            return False\n    return True\n\n# Generate potential meeting slots and check availability\ncurrent_time = work_start\nwhile current_time + meeting_duration <= work_end:\n    if is_free(current_time, emily_schedule) and is_free(current_time, melissa_schedule) and is_free(current_time, frank_schedule):\n        proposed_time = current_time.strftime(\"%H:%M\")\n        print(f\"{{{proposed_time}:{(current_time + meeting_duration).strftime('%H:%M')}}}\")\n        break\n    current_time += timedelta(minutes=10)\n```",
            "count": "calendar_scheduling_example_32"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define participants' schedules\nschedules = {\n    \"Lisa\": [\n        (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n        (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n        (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n        (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\")),\n    ],\n    \"Bobby\": [\n        (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n        (datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n        (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n        (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\")),\n    ],\n    \"Randy\": [\n        (datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n        (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n        (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n        (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n        (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\")),\n        (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\")),\n    ]\n}\n\n# Meeting duration\nmeeting_duration = timedelta(minutes=30)\n\n# Work hours\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"17:00\", \"%H:%M\")\n\n# Function to check if a time slot is available for all participants\ndef is_slot_available(start, end):\n    for schedule in schedules.values():\n        for busy_start, busy_end in schedule:\n            if not (end <= busy_start or start >= busy_end):\n                return False\n    return True\n\n# Find a suitable time slot\ndef find_meeting_slot():\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        end_time = current_time + meeting_duration\n        if is_slot_available(current_time, end_time):\n            return f\"{current_time.strftime('%H:%M')}:{end_time.strftime('%H:%M')}\"\n        current_time += timedelta(minutes=1)  # Check the next minute\n    return None\n\n# Get the proposed time slot\nproposed_time = find_meeting_slot()\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_33"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:10:00}",
            "type_error": "TypeError",
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define work hours and existing schedules\nwork_start = datetime.strptime('09:00', '%H:%M')\nwork_end = datetime.strptime('17:00', '%H:%M')\nmeeting_duration = timedelta(hours=1)\n\n# Existing schedules as (start, end) tuples\nwillie_schedule = [(work_start, work_end)]\nrichard_schedule = [\n    (work_start, datetime.strptime('10:00', '%H:%M')),\n    (datetime.strptime('10:30', '%H:%M'), datetime.strptime('11:00', '%H:%M')),\n    (datetime.strptime('12:00', '%H:%M'), datetime.strptime('13:00', '%H:%M')),\n    (datetime.strptime('14:00', '%H:%M'), datetime.strptime('16:00', '%H:%M')),\n    (datetime.strptime('16:30', '%H:%M'), work_end)\n]\nnoah_schedule = [\n    (work_start, datetime.strptime('10:00', '%H:%M')),\n    (datetime.strptime('10:30', '%H:%M'), datetime.strptime('11:30', '%H:%M')),\n    (datetime.strptime('13:00', '%H:%M'), datetime.strptime('13:30', '%H:%M')),\n    (datetime.strptime('14:00', '%H:%M'), datetime.strptime('14:30', '%H:%M')),\n    (datetime.strptime('17:00', '%H:%M'), work_end)\n]\n\n# Combine schedules and find free slots\ndef find_free_slots(schedules):\n    free_slots = []\n    all_times = []\n\n    for schedule in schedules:\n        for start, end in schedule:\n            all_times.append((start, 'start'))\n            all_times.append((end, 'end'))\n\n    all_times.sort()\n\n    current_time = work_start\n    for time, type in all_times:\n        if current_time < time:\n            free_slots.append((current_time, time))\n        current_time = time if type == 'end' else current_time\n\n    return free_slots\n\n# Get free slots for each participant\nwillie_free_slots = find_free_slots([willie_schedule])\nrichard_free_slots = find_free_slots(richard_schedule)\nnoah_free_slots = find_free_slots(noah_schedule)\n\n# Find common free slots for all participants\ncommon_free_slots = []\nfor w_start, w_end in willie_free_slots:\n    for r_start, r_end in richard_free_slots:\n        for n_start, n_end in noah_free_slots:\n            start = max(w_start, r_start, n_start)\n            end = min(w_end, r_end, n_end)\n            if (end - start) >= meeting_duration:\n                common_free_slots.append((start, start + meeting_duration))\n\n# Select the first available time slot for the meeting\nif common_free_slots:\n    proposed_time = common_free_slots[0][0]\n    print(f\"{proposed_time.strftime('%H:%M')}:{(proposed_time + meeting_duration).strftime('%H:%M')}\")\n```\n",
            "count": "calendar_scheduling_example_34"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define the time slots for each participant\n    bradley_free_slots = [(9, 17)]  # Free all day\n    zachary_busy_slots = [(10, 10.5), (15, 15.5)]\n    teresa_busy_slots = [(9, 10.5), (11, 12.5), (13, 14), (14.5, 16.5)]\n    \n    # Define the desired meeting duration\n    meeting_duration = 0.5  # 30 minutes in hours\n    \n    # Bradley's preference\n    bradley_preferred_start = 14.5  # 14:30 in hours\n\n    # Create a list of all time slots for Bradley\n    possible_times = []\n    \n    for start in range(9, 17):\n        end = start + meeting_duration\n        # Check if this slot is within Bradley's preference\n        if start < bradley_preferred_start:\n            continue\n        \n        # Check if the current slot is busy for Zachary or Teresa\n        is_free = True\n        \n        # Check Zachary's busy slots\n        for busy_start, busy_end in zachary_busy_slots:\n            if (start < busy_end) and (end > busy_start):\n                is_free = False\n                break\n        \n        # Check Teresa's busy slots\n        for busy_start, busy_end in teresa_busy_slots:\n            if (start < busy_end) and (end > busy_start):\n                is_free = False\n                break\n\n        # If the slot is free for both Zachary and Teresa, and meets Bradley's constraints, add it\n        if is_free:\n            possible_times.append((start, end))\n    \n    # Return the first valid time slot in the required format\n    if possible_times:\n        proposed_time = possible_times[0]\n        return f\"{int(proposed_time[0]):02d}:00:{int(proposed_time[1]):02d}:00\"\n    \n    return None\n\n# Main execution\nmeeting_time = find_meeting_time()\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_35"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:30}",
            "type_error": "SyntaxError",
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, meeting_duration, work_hours):\n    start_time = datetime.strptime(work_hours[0], '%H:%M')\n    end_time = datetime.strptime(work_hours[1], '%H:%M')\n    \n    current_time = start_time\n    \n    while current_time + meeting_duration <= end_time:\n        is_available = True\n        \n        for schedule in participants:\n            for busy_start, busy_end in schedule:\n                if current_time < busy_end and current_time + meeting_duration > busy_start:\n                    is_available = False\n                    break\n                    \n            if not is_available:\n                break\n        \n        if is_available:\n            return current_time.strftime(\"%H:%M\") + ':' + (current_time + meeting_duration).strftime(\"%H:%M\")\n        \n        current_time += timedelta(minutes=30)  # Check next half-hour slot\n    \n    return None\n\nparticipants = [\n    [(datetime.strptime(\"09:00\", '%H:%M'), datetime.strptime(\"09:30\", '%H:%M')),\n     (datetime.strptime(\"12:30\", '%H:%M'), datetime.strptime(\"13:00\", '%H:%M\"))],  # Ryan's schedule\n     \n    [],  # Ruth's empty schedule\n    \n    [(datetime.strptime(\"09:30\", '%H:%M'), datetime.strptime(\"10:30\", '%H:%M')),\n     (datetime.strptime(\"12:00\", '%H:%M'), datetime.strptime(\"13:00\", '%H:%M')),\n     (datetime.strptime(\"14:30\", '%H:%M'), datetime.strptime(\"16:30\", '%H:%M\"))]  # Denise's schedule\n]\n\nmeeting_duration = timedelta(hours=1)\nwork_hours = [\"09:00\", \"17:00\"]\n\navailable_time = find_meeting_time(participants, meeting_duration, work_hours)\nprint(available_time)  # Output the suggested meeting time\n```",
            "count": "calendar_scheduling_example_36"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define participants' schedules\nschedules = {\n    'Gregory': [(datetime(2023, 10, 2, 11, 0), datetime(2023, 10, 2, 11, 30)),\n                (datetime(2023, 10, 2, 12, 0), datetime(2023, 10, 2, 12, 30)),\n                (datetime(2023, 10, 2, 15, 30), datetime(2023, 10, 2, 16, 30))],\n    'Teresa': [],\n    'Carol': [(datetime(2023, 10, 2, 9, 0), datetime(2023, 10, 2, 10, 30)),\n              (datetime(2023, 10, 2, 11, 0), datetime(2023, 10, 2, 16, 0)),\n              (datetime(2023, 10, 2, 16, 30), datetime(2023, 10, 2, 17, 0))]\n}\n\n# Meeting duration\nmeeting_duration = timedelta(minutes=30)\n\n# Work hours\nwork_start = datetime(2023, 10, 2, 9, 0)\nwork_end = datetime(2023, 10, 2, 17, 0)\n\n# Function to find a suitable time slot\ndef find_meeting_time(schedules, meeting_duration, work_start, work_end):\n    # Create a list of all busy times\n    busy_times = []\n    for schedule in schedules.values():\n        busy_times.extend(schedule)\n\n    # Add work hours to the busy list\n    busy_times.append((work_start, work_end))\n\n    # Finding free time slots\n    busy_times.sort()\n    available_start = work_start\n\n    for start, end in busy_times:\n        if available_start + meeting_duration <= start:\n            return available_start.strftime(\"%H:%M\"), (available_start + meeting_duration).strftime(\"%H:%M\")\n        available_start = max(available_start, end)\n\n    return None\n\n# Get the proposed meeting time\nmeeting_time = find_meeting_time(schedules, meeting_duration, work_start, work_end)\nif meeting_time:\n    print(f\"{meeting_time[0]}:{meeting_time[1]}\")\n```",
            "count": "calendar_scheduling_example_37"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define participant availability\ncatherine_schedule = [(datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n                      (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n                      (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\"))]\n\nmichael_schedule = [(datetime.strptime(\"9:30\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n                    (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n                    (datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\")),\n                    (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\"))]\n\nalexander_schedule = [(datetime.strptime(\"9:00\", \"%H:%M\"), datetime.strptime(\"9:30\", \"%H:%M\")),\n                      (datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n                      (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n                      (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n                      (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\")),\n                      (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n\n# Define the meeting duration\nmeeting_duration = timedelta(minutes=30)\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"17:00\", \"%H:%M\")\n\n# Find common available time slots\ndef find_available_time_slots(schedule, work_start, work_end):\n    available_time_slots = []\n    last_end = work_start\n\n    for start, end in sorted(schedule):\n        if last_end < start:\n            available_time_slots.append((last_end, start))\n        last_end = max(last_end, end)\n    \n    if last_end < work_end:\n        available_time_slots.append((last_end, work_end))\n    \n    return available_time_slots\n\ncatherine_available = find_available_time_slots(catherine_schedule, work_start, work_end)\nmichael_available = find_available_time_slots(michael_schedule, work_start, work_end)\nalexander_available = find_available_time_slots(alexander_schedule, work_start, work_end)\n\n# Intersect the available time slots\ndef intersect_time_slots(slots1, slots2):\n    result = []\n    i, j = 0, 0\n\n    while i < len(slots1) and j < len(slots2):\n        start1, end1 = slots1[i]\n        start2, end2 = slots2[j]\n        \n        start = max(start1, start2)\n        end = min(end1, end2)\n\n        if start < end:\n            result.append((start, end))\n\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n\n    return result\n\ncommon_slots = intersect_time_slots(catherine_available, michael_available)\ncommon_available_slots = intersect_time_slots(common_slots, alexander_available)\n\n# Find a suitable time\nfor start, end in common_available_slots:\n    if end - start >= meeting_duration:\n        proposed_start = start\n        proposed_end = start + meeting_duration\n        print(f\"{proposed_start.strftime('%H:%M')}:{proposed_end.strftime('%H:%M')}\")\n        break\n```",
            "count": "calendar_scheduling_example_38"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define participants' schedules as tuples of (start, end) times\nemily_schedule = [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\nvictoria_schedule = [\n    (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n    (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\")),\n    (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\")),\n    (datetime.strptime(\"17:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\")),\n]\nnancy_schedule = [\n    (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\")),\n    (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\")),\n    (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\")),\n]\n\n# Meeting duration\nmeeting_duration = timedelta(minutes=30)\n\n# Find available time slots\ndef find_available_slot(schedules, meeting_duration):\n    # Create a timeline of busy periods\n    times = []\n    for schedule in schedules:\n        for start, end in schedule:\n            times.append((start, 'start'))\n            times.append((end, 'end'))\n    \n    # Sort all times\n    times.sort()\n    \n    # Check for available time slots\n    free_periods = []\n    current_time = datetime.strptime(\"09:00\", \"%H:%M\")\n    \n    for time, type_of_time in times:\n        if type_of_time == 'start':\n            if current_time < time:\n                free_periods.append((current_time, time))\n            current_time = time\n        else:\n            current_time = time\n\n    if current_time < datetime.strptime(\"17:00\", \"%H:%M\"):\n        free_periods.append((current_time, datetime.strptime(\"17:00\", \"%H:%M\")))\n\n    # Find a slot that can accommodate the meeting\n    for start, end in free_periods:\n        if end - start >= meeting_duration:\n            return start, start + meeting_duration\n\n# Call the function and find the suitable slot\nsuitable_slot = find_available_slot([emily_schedule, victoria_schedule, nancy_schedule], meeting_duration)\n\n# Output the result\nif suitable_slot:\n    meeting_start, meeting_end = suitable_slot\n    print(f\"{meeting_start.strftime('%H:%M')}:{meeting_end.strftime('%H:%M')}\")\n```",
            "count": "calendar_scheduling_example_39"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(schedules, duration, work_start, work_end):\n    work_start = datetime.strptime(work_start, '%H:%M')\n    work_end = datetime.strptime(work_end, '%H:%M')\n    \n    # Create a range for the whole workday\n    time_slots = [(work_start + timedelta(minutes=i), work_start + timedelta(minutes=i + duration)) \n                  for i in range(0, (work_end - work_start).seconds // 60)]\n    \n    # Convert schedules to time slots\n    busy_times = []\n    for schedule in schedules:\n        for start_time, end_time in schedule:\n            busy_times.append((start_time, end_time))\n\n    # Find a time slot that works for everyone\n    for start, end in time_slots:\n        meeting_end = start + timedelta(minutes=duration)\n        if meeting_end <= work_end:\n            if all(not (start < busy_end and meeting_end > busy_start) for busy_start, busy_end in busy_times):\n                return f\"{start.strftime('%H:%M')}:{meeting_end.strftime('%H:%M')}\"\n    \n    return None\n\nschedules = [\n    [(datetime.strptime('10:00', '%H:%M'), datetime.strptime('11:00', '%H:%M')),\n     (datetime.strptime('11:30', '%H:%M'), datetime.strptime('12:00', '%H:%M')),\n     (datetime.strptime('16:00', '%H:%M'), datetime.strptime('16:30', '%H:%M'))],\n     \n    [(datetime.strptime('9:30', '%H:%M'), datetime.strptime('11:30', '%H:%M')),\n     (datetime.strptime('13:00', '%H:%M'), datetime.strptime('13:30', '%H:%M')),\n     (datetime.strptime('15:00', '%H:%M'), datetime.strptime('15:30', '%H:%M'))],\n     \n    [(datetime.strptime('9:00', '%H:%M'), datetime.strptime('9:30', '%H:%M')),\n     (datetime.strptime('10:30', '%H:%M'), datetime.strptime('11:00', '%H:%M')),\n     (datetime.strptime('11:30', '%H:%M'), datetime.strptime('12:00', '%H:%M')),\n     (datetime.strptime('12:30', '%H:%M'), datetime.strptime('14:00', '%H:%M')),\n     (datetime.strptime('15:30', '%H:%M'), datetime.strptime('16:30', '%H:%M'))]\n]\n\nmeeting_duration = 60  # in minutes\nwork_hours_start = '09:00'\nwork_hours_end = '17:00'\n\nproposed_time = find_meeting_time(schedules, meeting_duration, work_hours_start, work_hours_end)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_40"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the meeting participants and their schedules\nparticipants = {\n    \"Alan\": {\"available\": [(9, 17)], \"not_before\": (14, 30)},\n    \"Nancy\": {\"available\": [(9, 11), (12, 13), (13, 14), (15, 17)], \"not_before\": None},\n    \"Patricia\": {\"available\": [(9, 10), (12, 12.5), (16, 17)], \"not_before\": None},\n}\n\n# Meeting duration\nmeeting_duration = timedelta(minutes=30)\n\n# Define available time slots\navailable_slots = []\n\n# Finding the common available slots\nfor start_hour in range(9, 17):\n    for end_hour in range(start_hour + 1, 18):  # End must be after start\n        start_time = datetime.strptime(f\"{start_hour}:00\", \"%H:%M\")\n        end_time = datetime.strptime(f\"{end_hour}:00\", \"%H:%M\")\n        \n        can_schedule = True\n        \n        # Check each participant's availability\n        for participant, schedule in participants.items():\n            # Check if there's a blocked time\n            for busy_start, busy_end in schedule[\"available\"]:\n                if (start_hour >= busy_start and start_hour < busy_end) or (end_hour > busy_start and end_hour <= busy_end):\n                    can_schedule = False\n                    break\n            \n            # Check not_before constraint\n            if schedule[\"not_before\"]:\n                not_before_time = datetime.strptime(f\"{schedule['not_before'][0]}:{schedule['not_before'][1]}\", \"%H:%M\")\n                if start_time < not_before_time:\n                    can_schedule = False\n\n            if not can_schedule:\n                break\n        \n        if can_schedule and end_time - start_time >= meeting_duration:\n            available_slots.append((start_time, end_time))\n\n# Output the first suitable time slot for the meeting\nif available_slots:\n    meeting_start = available_slots[0][0]\n    meeting_end = meeting_start + meeting_duration\n    print(f\"{meeting_start.strftime('%H:%M')}:{meeting_end.strftime('%H:%M')}\")\nelse:\n    print(\"No available time slots found.\")\n```",
            "count": "calendar_scheduling_example_41"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the work hours and meeting duration\nwork_start = datetime.strptime('09:00', '%H:%M')\nwork_end = datetime.strptime('17:00', '%H:%M')\nmeeting_duration = timedelta(hours=1)\n\n# Define the existing schedules\njulie_schedule = [\n    (datetime.strptime('09:00', '%H:%M'), datetime.strptime('09:30', '%H:%M')),\n    (datetime.strptime('11:00', '%H:%M'), datetime.strptime('11:30', '%H:%M')),\n    (datetime.strptime('12:00', '%H:%M'), datetime.strptime('12:30', '%H:%M')),\n    (datetime.strptime('13:30', '%H:%M'), datetime.strptime('14:00', '%H:%M')),\n    (datetime.strptime('16:00', '%H:%M'), work_end)\n]\n\nsean_schedule = [\n    (datetime.strptime('09:00', '%H:%M'), datetime.strptime('09:30', '%H:%M')),\n    (datetime.strptime('13:00', '%H:%M'), datetime.strptime('13:30', '%H:%M')),\n    (datetime.strptime('15:00', '%H:%M'), datetime.strptime('15:30', '%H:%M')),\n    (datetime.strptime('16:00', '%H:%M'), datetime.strptime('16:30', '%H:%M'))\n]\n\nlori_schedule = [\n    (datetime.strptime('10:00', '%H:%M'), datetime.strptime('10:30', '%H:%M')),\n    (datetime.strptime('11:00', '%H:%M'), datetime.strptime('13:00', '%H:%M')),\n    (datetime.strptime('15:30', '%H:%M'), work_end)\n]\n\n# Function to check if a time slot is free for all participants\ndef is_slot_free(start_time, end_time):\n    for schedule in [julie_schedule, sean_schedule, lori_schedule]:\n        for busy_start, busy_end in schedule:\n            if (start_time < busy_end and end_time > busy_start):\n                return False\n    return True\n\n# Find available slot\ncurrent_time = work_start\nwhile current_time + meeting_duration <= work_end:\n    next_time = current_time + meeting_duration\n    if is_slot_free(current_time, next_time):\n        print(f\"{current_time.strftime('%H:%M')}:{next_time.strftime('%H:%M')}\")\n        break\n    current_time += timedelta(minutes=30)  # Check next possible slot in 30 mins\n```",
            "count": "calendar_scheduling_example_42"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Participant schedules\nalbert_schedule = [\n    (datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n    (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n    (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\")),\n    (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\")),\n    (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\")),\n]\n\ngregory_schedule = [\n    (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n    (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n    (datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\")),\n    (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\")),\n]\n\nbenjamin_schedule = [\n    (datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n    (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n    (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n    (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n    (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\")),\n    (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\")),\n]\n\n# Meeting duration\nmeeting_duration = timedelta(minutes=30)\n\n# Work hours\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"17:00\", \"%H:%M\")\n\n# Function to find the earliest time for the meeting\ndef find_earliest_meeting_time():\n    time = work_start\n    while time + meeting_duration <= work_end:\n        is_available = True\n        \n        # Check Albert's schedule\n        for start, end in albert_schedule:\n            if start <= time < end or start < time + meeting_duration <= end:\n                is_available = False\n                break\n        \n        # Check Gregory's schedule\n        for start, end in gregory_schedule:\n            if start <= time < end or start < time + meeting_duration <= end:\n                is_available = False\n                break\n        \n        # Check Benjamin's schedule\n        for start, end in benjamin_schedule:\n            if start <= time < end or start < time + meeting_duration <= end:\n                is_available = False\n                break\n        \n        if is_available:\n            return time, time + meeting_duration\n        \n        time += timedelta(minutes=1)  # Increment to check the next minute\n\n# Get the proposed meeting time\nstart_time, end_time = find_earliest_meeting_time()\n\n# Format the output correctly\noutput = f\"{start_time.strftime('%H:%M')}:{end_time.strftime('%H:%M')}\"\nprint(output)\n```",
            "count": "calendar_scheduling_example_43"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the work hours and meeting duration\nstart_time = datetime.strptime(\"09:00\", \"%H:%M\")\nend_time = datetime.strptime(\"17:00\", \"%H:%M\")\nmeeting_duration = timedelta(minutes=30)\n\n# Define participants' busy schedules\nronald_busy_times = [(datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n                     (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\")),\n                     (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n\namanda_busy_times = [(datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n                     (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n                     (datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\")),\n                     (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n\n# Define the available time slots\nfree_slots = []\ncurrent_time = start_time\n\nwhile current_time + meeting_duration <= end_time:\n    meeting_start = current_time\n    meeting_end = current_time + meeting_duration\n    \n    # Check if either participant is busy during the proposed meeting time\n    is_busy = False\n    for busy_start, busy_end in ronald_busy_times + amanda_busy_times:\n        if not (meeting_end <= busy_start or meeting_start >= busy_end):\n            is_busy = True\n            break\n            \n    # Check Isabella's preference\n    if is_busy or current_time > datetime.strptime(\"13:00\", \"%H:%M\"):\n        current_time += timedelta(minutes=30)\n        continue\n        \n    # If not busy, record the free slot\n    free_slots.append((meeting_start, meeting_end))\n    break  # We only need one suitable slot\n\n# Output the first available time slot found\nif free_slots:\n    proposed_time = free_slots[0]\n    print(f\"{proposed_time[0].strftime('%H:%M')}:{proposed_time[1].strftime('%H:%M')}\")\n```",
            "count": "calendar_scheduling_example_44"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the working hours\nworking_hours_start = datetime.strptime(\"09:00\", \"%H:%M\")\nworking_hours_end = datetime.strptime(\"17:00\", \"%H:%M\")\n\n# Participant schedules\nandrew_schedule = [(working_hours_start, working_hours_end)]\ngrace_schedule = [(working_hours_start, working_hours_end)]\nsamuel_schedule = [\n    (working_hours_start, datetime.strptime(\"10:30\", \"%H:%M\")),\n    (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n    (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n    (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\")),\n    (datetime.strptime(\"16:30\", \"%H:%M\"), working_hours_end)\n]\n\n# Merge all participant schedules into one\nbusy_slots = []\nfor schedule in [andrew_schedule, grace_schedule, samuel_schedule]:\n    for slot in schedule:\n        busy_slots.append(slot)\n\n# Create a timeline for available slots\nfree_slots = []\ncurrent_time = working_hours_start\n\nwhile current_time < working_hours_end:\n    end_time = current_time + timedelta(minutes=30)\n    available = True\n    \n    for start, end in busy_slots:\n        if current_time < end and end_time > start:\n            available = False\n            break\n            \n    if available:\n        free_slots.append((current_time, end_time))\n    \n    current_time += timedelta(minutes=30)\n\n# Find the earliest available slot for a 30-minute meeting\nif free_slots:\n    first_slot = free_slots[0]\n    print(f\"{first_slot[0].strftime('%H:%M')}:{first_slot[1].strftime('%H:%M')}\")\nelse:\n    print(\"No available slots\")\n```",
            "count": "calendar_scheduling_example_45"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the working hours and participants' schedules\nworking_hours_start = datetime.strptime(\"09:00\", \"%H:%M\")\nworking_hours_end = datetime.strptime(\"17:00\", \"%H:%M\")\n\n# Participants' schedules (start, end) in blocked time\narthur_schedule = [(datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n                   (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\"))]\n\ntheresa_schedule = [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n                    (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n                    (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))]\n\ncarl_schedule = [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n                 (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\")),\n                 (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n\n# Duration of the meeting\nmeeting_duration = timedelta(minutes=30)\n\n# Function to find the available time\ndef find_available_time(working_hours_start, working_hours_end, *schedules):\n    # Create a list of all busy times\n    busy_times = []\n    for schedule in schedules:\n        busy_times.extend(schedule)\n\n    # Add working hours to busy times\n    busy_times.append((working_hours_start, working_hours_start))\n    busy_times.append((working_hours_end, working_hours_end))\n\n    # Sort busy times\n    busy_times.sort()\n\n    # Find gaps between busy times\n    last_end_time = working_hours_start\n    for start, end in busy_times:\n        if last_end_time + meeting_duration <= start:\n            return last_end_time.strftime(\"%H:%M\") + \":\" + (last_end_time + meeting_duration).strftime(\"%H:%M\")\n        last_end_time = max(last_end_time, end)\n\n    return None\n\n# Call the function and print the proposed time\nproposed_time = find_available_time(working_hours_start, working_hours_end, arthur_schedule, theresa_schedule, carl_schedule)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_46"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the work hours\nwork_start = datetime.strptime('09:00', '%H:%M')\nwork_end = datetime.strptime('17:00', '%H:%M')\n\n# Define existing schedules\ndavid_schedule = []  # No meetings for David\neric_schedule = [(datetime.strptime('09:00', '%H:%M'), datetime.strptime('09:30', '%H:%M')),\n                 (datetime.strptime('10:30', '%H:%M'), datetime.strptime('11:30', '%H:%M')),\n                 (datetime.strptime('15:00', '%H:%M'), datetime.strptime('15:30', '%H:%M'))]\nroger_schedule = [(datetime.strptime('09:30', '%H:%M'), datetime.strptime('10:30', '%H:%M')),\n                  (datetime.strptime('11:00', '%H:%M'), datetime.strptime('12:00', '%H:%M')),\n                  (datetime.strptime('12:30', '%H:%M'), datetime.strptime('13:00', '%H:%M')),\n                  (datetime.strptime('14:30', '%H:%M'), datetime.strptime('15:00', '%H:%M')),\n                  (datetime.strptime('15:30', '%H:%M'), datetime.strptime('16:30', '%H:%M'))]\n\n# Meeting duration\nmeeting_duration = timedelta(hours=1)\n\ndef find_meeting_time(start, end):\n    # Create a list of busy times\n    busy_times = eric_schedule + roger_schedule  # David has no busy times\n    busy_times.sort()\n\n    # Check free slots in the schedule\n    current_time = start\n    while current_time + meeting_duration <= end:\n        # Check if current_time is busy\n        is_busy = any(start <= current_time < end for (start, end) in busy_times)\n        \n        if not is_busy:\n            # Check if there is enough time available\n            is_time_sufficient = all(not (current_time < end and current_time + meeting_duration > start)\n                                     for (start, end) in busy_times)\n            if is_time_sufficient:\n                return current_time.strftime('%H:%M'), (current_time + meeting_duration).strftime('%H:%M')\n\n        current_time += timedelta(minutes=30)  # Check every 30 minutes\n\n    return None\n\n# Finding a suitable time\nmeeting_time = find_meeting_time(work_start, work_end)\nif meeting_time:\n    start_time, end_time = meeting_time\n    print(f\"{start_time}:{end_time}\")\nelse:\n    print(\"No suitable time found.\")\n```\n",
            "count": "calendar_scheduling_example_47"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(janet_busy, rachel_busy, cynthia_busy, meeting_duration, preferred_start_time):\n    # Define available time slots for each participant\n    janet_free_times = [(9, 30), (10, 30), (11, 30), (12, 30), (14, 30), (17, 0)]\n    rachel_free_times = [(9, 0), (17, 0)]\n    cynthia_free_times = [(9, 0), (11, 30), (14, 30), (17, 0)]\n\n    # Exclude busy times\n    janet_free_times = [(t[0], t[1]) for t in janet_free_times if not (t[0], t[1]) in janet_busy]\n    cynthia_free_times = [(t[0], t[1]) for t in cynthia_free_times if not (t[0], t[1]) in cynthia_busy]\n\n    # Time slots for all participants\n    available_times = []\n    for j_time in janet_free_times:\n        if j_time in rachel_free_times and j_time in cynthia_free_times:\n            available_times.append(j_time)\n\n    meeting_time = None\n    for time in available_times:\n        start_hour, start_minute = time\n        start_time_in_minutes = start_hour * 60 + start_minute\n\n        # Check if we can fit the meeting duration\n        if (start_time_in_minutes + meeting_duration) <= (17 * 60):\n            if start_time_in_minutes >= (preferred_start_time[0] * 60 + preferred_start_time[1]):\n                meeting_time = (start_hour, start_minute)\n                break\n\n    if meeting_time:\n        return f\"{meeting_time[0]:02}:{meeting_time[1]:02}:{meeting_time[0]:02}:{meeting_time[1] + meeting_duration}\"\n    else:\n        return \"No suitable time found.\"\n\n# Constraints\njanet_busy = [(9, 30), (12, 30), (14, 0)]\nrachel_busy = []  # Rachel has no meetings all day\ncynthia_busy = [(9, 30), (11, 0), (12, 30), (16, 0)]\n\n# Meeting duration in minutes\nmeeting_duration = 60\n\n# Preferred start time (13:30)\npreferred_start_time = (13, 30)\n\n# Finding a meeting time\nprint(find_meeting_time(janet_busy, rachel_busy, cynthia_busy, meeting_duration, preferred_start_time))\n```",
            "count": "calendar_scheduling_example_48"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(teresa_busy, kathleen_busy, patricia_busy, meeting_duration, pref_time, work_start, work_end):\n    # Creating a time range for the work hours\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        # Check if current_time is free for all participants\n        if (not is_time_busy(current_time, teresa_busy) and\n                not is_time_busy(current_time, kathleen_busy) and\n                not is_time_busy(current_time, patricia_busy)):\n            # Check Kathleen's preference\n            if current_time >= pref_time:\n                return f\"{current_time.strftime('%H:%M')}:{(current_time + meeting_duration).strftime('%H:%M')}\"\n        current_time += timedelta(minutes=30)  # Increment by 30 minutes\n    return None\n\ndef is_time_busy(current_time, busy_schedule):\n    for interval in busy_schedule:\n        if interval[0] <= current_time < interval[1]:\n            return True\n    return False\n\n# Busy schedules (start, end) in datetime format\nteresa_busy = [(datetime.strptime('09:00', '%H:%M'), datetime.strptime('10:00', '%H:%M')),\n                (datetime.strptime('13:00', '%H:%M'), datetime.strptime('13:30', '%H:%M')),\n                (datetime.strptime('14:00', '%H:%M'), datetime.strptime('14:30', '%H:%M')),\n                (datetime.strptime('15:00', '%H:%M'), datetime.strptime('15:30', '%H:%M')),\n                (datetime.strptime('16:30', '%H:%M'), datetime.strptime('17:00', '%H:%M'))]\n\nkathleen_busy = [(datetime.strptime('09:00', '%H:%M'), datetime.strptime('09:30', '%H:%M')),\n                  (datetime.strptime('12:30', '%H:%M'), datetime.strptime('13:00', '%H:%M')),\n                  (datetime.strptime('13:30', '%H:%M'), datetime.strptime('14:00', '%H:%M')),\n                  (datetime.strptime('15:00', '%H:%M'), datetime.strptime('15:30', '%H:%M'))]\n\npatricia_busy = [(datetime.strptime('09:00', '%H:%M'), datetime.strptime('10:30', '%H:%M')),\n                  (datetime.strptime('11:30', '%H:%M'), datetime.strptime('12:00', '%H:%M')),\n                  (datetime.strptime('13:00', '%H:%M'), datetime.strptime('13:30', '%H:%M')),\n                  (datetime.strptime('14:00', '%H:%M'), datetime.strptime('14:30', '%H:%M')),\n                  (datetime.strptime('15:30', '%H:%M'), datetime.strptime('16:00', '%H:%M')),\n                  (datetime.strptime('16:30', '%H:%M'), datetime.strptime('17:00', '%H:%M'))]\n\n# Meeting duration and preferences\nmeeting_duration = timedelta(minutes=30)\npref_time = datetime.strptime('14:30', '%H:%M')  # Kathleen prefers to meet before or at this time\nwork_start = datetime.strptime('09:00', '%H:%M')\nwork_end = datetime.strptime('17:00', '%H:%M')\n\n# Find a suitable meeting time\nproposed_time = find_meeting_time(teresa_busy, kathleen_busy, patricia_busy, meeting_duration, pref_time, work_start, work_end)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_49"
        },
        {
            "final_program_time": "{13:30:14:30}",
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the meeting duration in hours\nmeeting_duration = timedelta(hours=1)\n\n# Define the work hours and constraints for each participant\nparticipants_schedule = {\n    \"Daniel\": [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))],  # All day\n    \"Roy\": [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))],  # All day\n    \"Emma\": [\n        (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n        (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n        (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n        (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\")),\n        (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\")),\n    ],\n}\n\n# Generate list of busy times from Emma's schedule\nbusy_times = []\nfor busy in participants_schedule[\"Emma\"]:\n    busy_times.append(busy)\n\n# Find a suitable time for the meeting\nstart_time = datetime.strptime(\"09:00\", \"%H:%M\")\nend_time = datetime.strptime(\"17:00\", \"%H:%M\")\n\n# Check for available slots\nwhile start_time + meeting_duration <= end_time:\n    meeting_start = start_time\n    meeting_end = start_time + meeting_duration\n    \n    # Check if the meeting time overlaps with any busy times\n    overlap = False\n    for busy_start, busy_end in busy_times:\n        if (meeting_start < busy_end and meeting_end > busy_start):\n            overlap = True\n            break\n            \n    if not overlap:\n        # If no overlap found, it's a suitable time\n        print(f\"{meeting_start.strftime('%H:%M')}:{meeting_end.strftime('%H:%M')}\")\n        break\n        \n    # Increment the start_time by 15 minutes\n    start_time += timedelta(minutes=15)\n```",
            "count": "calendar_scheduling_example_50"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:30:15:30}",
            "type_error": "ValueError",
            "full_response": "```python\nimport datetime\n\n# Participant schedules represented as lists of time blocks (start, end)\nbrandon_schedule = [(datetime.time(11, 30), datetime.time(12, 0)),\n                    (datetime.time(12, 30), datetime.time(13, 30)),\n                    (datetime.time(14, 0), datetime.time(14, 30))]\n\ndonna_schedule = [(datetime.time(10, 0), datetime.time(10, 30)),\n                  (datetime.time(12, 0), datetime.time(12, 30))]\n\njack_schedule = [(datetime.time(9, 30), datetime.time(10, 0)),\n                 (datetime.time(10, 30), datetime.time(11, 0)),\n                 (datetime.time(11, 30), datetime.time(12, 30)),\n                 (datetime.time(13, 0), datetime.time(14, 30)),\n                 (datetime.time(15, 30), datetime.time(17, 0))]\n\n# Convert schedule into unavailable time blocks\nunavailable = []\nfor schedule in [brandon_schedule, donna_schedule, jack_schedule]:\n    unavailable.extend(schedule)\n\n# Define work hours\nwork_start = datetime.time(9, 0)\nwork_end = datetime.time(17, 0)\n\n# Create list for full day availability\nminutes = [(datetime.time(hour, minute), datetime.time(hour, minute+1))\n           for hour in range(work_start.hour, work_end.hour + 1)\n           for minute in range(60) if minute < 60]\n\n# Check for availability\ndef is_time_available(start, end):\n    for busy_start, busy_end in unavailable:\n        if (start < busy_end and end > busy_start):\n            return False\n    return True\n\n# Find a one-hour slot\nfor start_time, end_time in minutes:\n    if end_time.hour == start_time.hour and (end_time.minute - start_time.minute == 1):\n        continue  # Ignore if there's only 1 minute\n\n    one_hour_later = (datetime.datetime.combine(datetime.date.today(), start_time) +\n                       datetime.timedelta(hours=1)).time()\n    \n    if is_time_available(start_time, one_hour_later):\n        print(f\"{start_time.strftime('%H:%M')}:{one_hour_later.strftime('%H:%M')}\")\n        break\n```",
            "count": "calendar_scheduling_example_51"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define work hours and meeting duration\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"17:00\", \"%H:%M\")\nmeeting_duration = timedelta(hours=1)\n\n# Define existing schedules for each participant\ngrace_schedule = [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n                  (datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n                  (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))]\n\nrandy_schedule = [(datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n                  (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))]\n\nsusan_schedule = [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\")),\n                  (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\"))]\n\n# Function to check if a proposed time is free for all participants\ndef is_time_free(start_time, participants_schedules):\n    end_time = start_time + meeting_duration\n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            if (start_time < busy_end and end_time > busy_start):\n                return False\n    return True\n\n# Check available times between work hours\ntime_slots = []\ncurrent_time = work_start\nwhile current_time + meeting_duration <= work_end:\n    if is_time_free(current_time, [grace_schedule, randy_schedule, susan_schedule]):\n        time_slots.append(current_time)\n    current_time += timedelta(minutes=30)  # Check every 30 minutes\n\n# Take the first available time slot\nif time_slots:\n    proposed_time = time_slots[0]\n    print(f\"{proposed_time.strftime('%H:%M')}:{(proposed_time + meeting_duration).strftime('%H:%M')}\")\nelse:\n    print(\"No available time for the meeting.\")\n```",
            "count": "calendar_scheduling_example_52"
        },
        {
            "final_program_time": "{15:30:16:30}",
            "expected_time": "{15:30:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, duration, work_start, work_end):\n    # Convert time to minutes from midnight for easier calculations\n    def time_to_minutes(t):\n        h, m = map(int, t.split(':'))\n        return h * 60 + m\n\n    # Convert minutes back to HH:MM format\n    def minutes_to_time(m):\n        h = m // 60\n        m = m % 60\n        return f\"{h:02}:{m:02}\"\n\n    work_start_minutes = time_to_minutes(work_start)\n    work_end_minutes = time_to_minutes(work_end)\n    duration_minutes = duration\n\n    # Create a time block representing the availability of each participant\n    busy_times = []\n    for schedule in participants:\n        for busy_start, busy_end in schedule:\n            busy_times.append((time_to_minutes(busy_start), time_to_minutes(busy_end)))\n\n    # Sort busy times\n    busy_times.sort()\n\n    # Calculate free blocks of time\n    free_times = []\n    current_start = work_start_minutes\n\n    for start, end in busy_times:\n        if current_start < start:\n            free_times.append((current_start, start))\n        current_start = max(current_start, end)\n\n    if current_start < work_end_minutes:\n        free_times.append((current_start, work_end_minutes))\n\n    # Look for a suitable time for the meeting\n    for start, end in free_times:\n        if end - start >= duration_minutes:\n            return f\"{minutes_to_time(start)}:{minutes_to_time(start + duration_minutes)}\"\n\n    return None  # In case no suitable time is found\n\n\nparticipants_schedules = [\n    [(\"09:30\", \"10:00\"), (\"12:30\", \"13:00\"), (\"14:30\", \"15:00\"), (\"16:30\", \"17:00\")],  # Alice\n    [(\"09:00\", \"09:30\"), (\"10:00\", \"11:00\"), (\"11:30\", \"12:00\"), (\"13:00\", \"14:00\"), \n     (\"15:00\", \"15:30\"), (\"16:30\", \"17:00\")]  # Arthur\n]\n\nmeeting_duration = 60  # in minutes\nwork_start_time = \"09:00\"\nwork_end_time = \"17:00\"\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, meeting_duration, work_start_time, work_end_time)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_53"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Existing schedules\nisabella_schedule = [(datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n                     (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\"))]\n\ntyler_schedule = [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\"))]\n\njordan_schedule = [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n                   (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n                   (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n                   (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\")),\n                   (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\"))]\n\n# Meeting constraints\nmeeting_duration = timedelta(hours=1)\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"17:00\", \"%H:%M\")\n\n# Merging schedules for unavailability\ncombined_schedule = isabella_schedule + tyler_schedule + jordan_schedule\n\n# Finding available time slot\ndef find_available_slot():\n    current_time = work_start\n\n    while current_time + meeting_duration <= work_end:\n        end_time = current_time + meeting_duration\n        is_available = True\n\n        for start, end in combined_schedule:\n            if (current_time < end) and (end_time > start):\n                is_available = False\n                break\n        \n        if is_available:\n            return current_time, end_time\n        \n        current_time += timedelta(minutes=30)  # Increment by 30 minutes\n\navailable_start, available_end = find_available_slot()\n\n# Output in requested format\nprint(f\"{available_start.strftime('%H:%M')}:{available_end.strftime('%H:%M')}\")\n```",
            "count": "calendar_scheduling_example_54"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(schedules, meeting_duration):\n    work_start = 9 * 60  # Work starts at 9:00 AM in minutes\n    work_end = 17 * 60    # Work ends at 5:00 PM in minutes\n\n    # Convert time schedules into a list of busy intervals\n    busy_intervals = []\n    for schedule in schedules:\n        busy_intervals.extend(schedule)\n\n    # Sort busy intervals by start time\n    busy_intervals.sort()\n\n    free_time_slots = []\n    last_end_time = work_start\n\n    # Check for free intervals based on busy times\n    for start, end in busy_intervals:\n        if last_end_time < start:\n            free_time_slots.append((last_end_time, start))\n        last_end_time = max(last_end_time, end)\n\n    # Check for free time after the last busy interval until work ends\n    if last_end_time < work_end:\n        free_time_slots.append((last_end_time, work_end))\n\n    # Find a suitable time slot for the meeting\n    for start, end in free_time_slots:\n        if (end - start) >= meeting_duration:\n            meeting_start = start\n            meeting_end = start + meeting_duration\n            return f'{meeting_start//60:02}:{meeting_start%60:02}:{meeting_end//60:02}:{meeting_end%60:02}'\n\n# Schedules\nkeith_schedule = [(14 * 60, 14 * 60 + 30), (16 * 60, 16 * 60 + 30)]\nchristine_schedule = []  # Free all day\ncynthia_schedule = [(9 * 60, 10 * 60 + 30), (11 * 60 + 30, 17 * 60)]\n\nparticipants_schedules = [keith_schedule, christine_schedule, cynthia_schedule]\nmeeting_duration = 60  # 1 hour in minutes\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_55"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(jeremy_schedule, donna_schedule, robert_schedule, meeting_duration):\n    # Define working hours\n    start_time = datetime.strptime(\"09:00\", \"%H:%M\")\n    end_time = datetime.strptime(\"17:00\", \"%H:%M\")\n    \n    # Create a list of all busy periods\n    busy_periods = []\n\n    # Add Jeremy's busy times\n    for start, end in jeremy_schedule:\n        busy_periods.append((start, end))\n\n    # Add Donna's busy times\n    for start, end in donna_schedule:\n        busy_periods.append((start, end))\n\n    # Add Robert's busy times\n    for start, end in robert_schedule:\n        busy_periods.append((start, end))\n\n    # Merge busy periods\n    busy_periods.sort()\n    merged_busy_periods = []\n    \n    for period in busy_periods:\n        if not merged_busy_periods or merged_busy_periods[-1][1] < period[0]:\n            merged_busy_periods.append(period)\n        else:\n            merged_busy_periods[-1] = (merged_busy_periods[-1][0], max(merged_busy_periods[-1][1], period[1]))\n\n    # Find a free slot\n    last_end_time = start_time\n    \n    for start, end in merged_busy_periods:\n        if last_end_time + meeting_duration <= start:\n            return f\"{last_end_time.strftime('%H:%M')}:{(last_end_time + meeting_duration).strftime('%H:%M')}\"\n        last_end_time = max(last_end_time, end)\n    \n    # After the last busy period, check if there's time till the end of workday\n    if last_end_time + meeting_duration <= end_time:\n        return f\"{last_end_time.strftime('%H:%M')}:{(last_end_time + meeting_duration).strftime('%H:%M')}\"\n        \n    return \"No available slot\"\n\n# Define the busy schedules\njeremy_schedule = [\n    (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n    (datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\")),\n    (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\")),\n]\n\ndonna_schedule = [\n    (datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n    (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n    (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\")),\n]\n\nrobert_schedule = [\n    (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n    (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n    (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\")),\n]\n\n# Meeting duration\nmeeting_duration = timedelta(minutes=30)\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(jeremy_schedule, donna_schedule, robert_schedule, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_56"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the working hours\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"17:00\", \"%H:%M\")\nmeeting_duration = timedelta(minutes=30)\n\n# Define the existing schedules\nvirginia_busy = [(datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\"))]\ncharles_busy = [\n    (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n    (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\"))\n]\nmegan_busy = [\n    (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n    (datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\")),\n    (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))\n]\n\n# Combine busy slots into a single list and sort them\nbusy_slots = virginia_busy + charles_busy + megan_busy\nbusy_slots.sort()\n\n# Function to check if a time slot is free\ndef is_time_slot_free(start, end):\n    for busy_start, busy_end in busy_slots:\n        if start < busy_end and end > busy_start:\n            return False\n    return True\n\n# Try to find a suitable time slot\nfor hour in range(9, 17):\n    proposed_start = datetime.strptime(f\"{hour}:00\", \"%H:%M\")\n    proposed_end = proposed_start + meeting_duration\n\n    if proposed_end <= work_end and is_time_slot_free(proposed_start, proposed_end):\n        # Charles's preference: avoid meetings before 14:30\n        if proposed_end >= datetime.strptime(\"14:30\", \"%H:%M\"):\n            print(f\"{proposed_start.strftime('%H:%M')}:{proposed_end.strftime('%H:%M')}\")\n            break\n```",
            "count": "calendar_scheduling_example_57"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the working hours\nworking_start = datetime.strptime(\"09:00\", \"%H:%M\")\nworking_end = datetime.strptime(\"17:00\", \"%H:%M\")\nmeeting_duration = timedelta(hours=1)\n\n# Participants' schedules (busy times)\nschedules = {\n    \"Joan\": [(datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n              (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\"))],\n    \"Theresa\": [(datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n                (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\"))],\n    \"Shirley\": [(datetime.strptime(\"9:30\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n                (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n                (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\")),\n                (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))]\n}\n\n# Function to check if a time slot is available for all participants\ndef is_time_slot_available(start_time, end_time):\n    for participant, busy_slots in schedules.items():\n        for busy_start, busy_end in busy_slots:\n            if (start_time < busy_end and end_time > busy_start):\n                return False\n    return True\n\n# Find a suitable time slot\ncurrent_time = working_start\nwhile current_time + meeting_duration <= working_end:\n    if is_time_slot_available(current_time, current_time + meeting_duration):\n        proposed_start = current_time.strftime(\"%H:%M\")\n        proposed_end = (current_time + meeting_duration).strftime(\"%H:%M\")\n        print(f\"{{{proposed_start}:{proposed_end}}}\")\n        break\n    current_time += timedelta(minutes=30)  # Check next half-hour\n```",
            "count": "calendar_scheduling_example_58"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Participants' constraints\njeffrey_schedule = [(datetime.strptime('09:00', '%H:%M'), datetime.strptime('14:00', '%H:%M')), \n                    (datetime.strptime('14:00', '%H:%M'), datetime.strptime('17:00', '%H:%M'))]\njack_schedule = [(datetime.strptime('10:30', '%H:%M'), datetime.strptime('11:30', '%H:%M')),\n                 (datetime.strptime('13:00', '%H:%M'), datetime.strptime('13:30', '%H:%M')),\n                 (datetime.strptime('14:00', '%H:%M'), datetime.strptime('14:30', '%H:%M')),\n                 (datetime.strptime('16:00', '%H:%M'), datetime.strptime('17:00', '%H:%M'))]\njudith_schedule = [(datetime.strptime('09:00', '%H:%M'), datetime.strptime('10:00', '%H:%M')),\n                   (datetime.strptime('10:30', '%H:%M'), datetime.strptime('11:00', '%H:%M')),\n                   (datetime.strptime('11:30', '%H:%M'), datetime.strptime('14:00', '%H:%M')),\n                   (datetime.strptime('14:30', '%H:%M'), datetime.strptime('15:00', '%H:%M')),\n                   (datetime.strptime('15:30', '%H:%M'), datetime.strptime('17:00', '%H:%M'))]\n\nmeeting_duration = timedelta(minutes=30)\n\n# Function to find a common available time\ndef find_meeting_time(jeffrey_schedule, jack_schedule, judith_schedule, meeting_duration):\n    # Only consider Jeffrey's available time after 14:00\n    possible_times = []\n    for start_time in jeffrey_schedule:\n        if start_time[0] < datetime.strptime('14:00', '%H:%M'):\n            continue\n        end_time = start_time[1]\n        \n        while start_time[0] + meeting_duration <= end_time:\n            possible_times.append(start_time[0])\n            start_time = (start_time[0] + timedelta(minutes=1), end_time)\n\n    # Check for conflicts with Jack and Judith\n    for proposed_time in possible_times:\n        conflict = False\n        for (start, end) in jack_schedule + judith_schedule:\n            if proposed_time < end and proposed_time + meeting_duration > start:\n                conflict = True\n                break\n        if not conflict:\n            return f\"{proposed_time.strftime('%H:%M')}:{(proposed_time + meeting_duration).strftime('%H:%M')}\"\n\n# Find the time for the meeting\nmeeting_time = find_meeting_time(jeffrey_schedule, jack_schedule, judith_schedule, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_59"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the working hours\nstart_time = datetime.strptime(\"09:00\", \"%H:%M\")\nend_time = datetime.strptime(\"17:00\", \"%H:%M\")\n\n# Define the blocked times for each participant\nlisa_busy = [(datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n             (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n             (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\"))]\n\nraymond_busy = [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n                (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n                (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n                (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n\n# This indicates that Dorothy is free throughout the day\ndorothy_busy = []\n\n# Function to check if a proposed time slot is free for all participants\ndef is_free(start, end):\n    for busy in lisa_busy + raymond_busy + dorothy_busy:\n        if (start < busy[1] and end > busy[0]):  # Overlap check\n            return False\n    return True\n\n# Meeting duration\nmeeting_duration = timedelta(minutes=30)\n\n# Find available time slot\ncurrent_time = start_time\nwhile current_time + meeting_duration <= end_time:\n    if is_free(current_time, current_time + meeting_duration):\n        proposed_start = current_time.strftime(\"%H:%M\")\n        proposed_end = (current_time + meeting_duration).strftime(\"%H:%M\")\n        print(f\"{proposed_start}:{proposed_end}\")\n        break\n    current_time += timedelta(minutes=1)\n```",
            "count": "calendar_scheduling_example_60"
        },
        {
            "final_program_time": "{13:30:14:30}",
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedule, meeting_duration):\n    work_start = 9 * 60  # 9:00 AM in minutes\n    work_end = 17 * 60    # 5:00 PM in minutes\n\n    # Convert busy schedules into minutes\n    busy_times = []\n    for schedule in participants_schedule:\n        for busy_period in schedule:\n            busy_start = busy_period[0] * 60 + busy_period[1]\n            busy_end = busy_period[2] * 60 + busy_period[3]\n            busy_times.append((busy_start, busy_end))\n\n    # Sort busy times\n    busy_times.sort()\n\n    # Determine free times\n    free_times = []\n    current_start = work_start\n\n    for busy_start, busy_end in busy_times:\n        if current_start < busy_start:\n            free_times.append((current_start, busy_start))\n        current_start = max(current_start, busy_end)\n\n    if current_start < work_end:\n        free_times.append((current_start, work_end))\n\n    # Find a slot that fits the meeting duration\n    for start, end in free_times:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            return f\"{meeting_start // 60:02}:{meeting_start % 60:02}:{meeting_end // 60:02}:{meeting_end % 60:02}\"\n\nparticipants_schedule = [\n    [(9, 30, 10, 0), (11, 30, 12, 0)],  # Lisa's busy times\n    [(9, 30, 11, 30), (12, 30, 13, 30), (16, 0, 17, 0)]  # Patrick's busy times\n]\n\nmeeting_duration = 60  # 1 hour in minutes\n\nprint(find_meeting_time(participants_schedule, meeting_duration))\n```",
            "count": "calendar_scheduling_example_61"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the work hours and constraints\nwork_start = datetime.strptime('09:00', '%H:%M')\nwork_end = datetime.strptime('17:00', '%H:%M')\nmeeting_duration = timedelta(hours=1)\n\n# Participant availability\nabigail_availability = (work_start, work_end)\nmichael_availability = (work_start, work_end)\nsharon_availability = (datetime.strptime('13:00', '%H:%M'), datetime.strptime('14:00', '%H:%M'))\n\n# Function to find a suitable meeting time\ndef find_meeting_time(abigail, michael, sharon):\n    # Check for time slots from 9:00 to 17:00\n    start_time = abigail[0]\n    end_time = abigail[1]\n\n    while start_time + meeting_duration <= end_time:\n        # Check if the time slot is free for all participants\n        if (start_time < sharon_availability[0] or start_time + meeting_duration <= sharon_availability[0]) or \\\n           (start_time >= sharon_availability[1]):\n            return f\"{start_time.strftime('%H:%M')}:{(start_time + meeting_duration).strftime('%H:%M')}\"\n        start_time += timedelta(minutes=30)\n\n    return None\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(abigail_availability, michael_availability, sharon_availability)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_62"
        },
        {
            "final_program_time": "{16:00:17:00}",
            "expected_time": "{16:00:17:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the working hours\nstart_time = datetime.strptime(\"09:00\", \"%H:%M\")\nend_time = datetime.strptime(\"17:00\", \"%H:%M\")\n\n# Define participants' availabilities\nmadison_free = [(start_time, end_time)]\njudith_busy = [(datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n                (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n                (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\"))]\nroger_busy = [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n               (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n               (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n               (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n               (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\"))]\n\n# Duration of the meeting\nmeeting_duration = timedelta(hours=1)\n\n# Function to find available time slot\ndef find_meeting_time(madison_free, judith_busy, roger_busy, meeting_duration):\n    # Collect all busy times and create a full schedule\n    busy_times = judith_busy + roger_busy\n    busy_times.sort(key=lambda x: x[0])  # Sort by start time\n\n    for start in madison_free:\n        current_start = start[0]\n        while current_start + meeting_duration <= start[1]:\n            # Check against busy times\n            is_busy = any(current_start < end and current_start + meeting_duration > start for start, end in busy_times)\n            if not is_busy:\n                return (current_start.strftime(\"%H:%M\"), (current_start + meeting_duration).strftime(\"%H:%M\"))\n            current_start += timedelta(minutes=1)\n\n# Execute the function\nmeeting_time = find_meeting_time(madison_free, judith_busy, roger_busy, meeting_duration)\nprint(f\"{meeting_time[0]}:{meeting_time[1]}\")\n```",
            "count": "calendar_scheduling_example_63"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the working hours and the duration of the meeting\nworking_start = datetime.strptime(\"09:00\", \"%H:%M\")\nworking_end = datetime.strptime(\"17:00\", \"%H:%M\")\nmeeting_duration = timedelta(hours=1)\n\n# Existing schedules for participants as lists of tuples (start_time, end_time)\nnancy_schedule = [(datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n                  (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\"))]\n\nalbert_schedule = []  # No meetings\n\nnathan_schedule = [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n                   (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\")),\n                   (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n\n# Function to find the available slot\ndef find_meeting_time(working_start, working_end, meeting_duration, schedules):\n    current_time = working_start\n    \n    while current_time + meeting_duration <= working_end:\n        available = True\n        \n        # Check if the current_time conflicts with any participant's schedule\n        for schedule in schedules:\n            for start, end in schedule:\n                if start < current_time + meeting_duration and end > current_time:\n                    available = False\n                    break\n            if not available:\n                break\n        \n        if available:\n            return current_time.strftime(\"%H:%M\") + \":\" + (current_time + meeting_duration).strftime(\"%H:%M\")\n        \n        current_time += timedelta(minutes=30)  # Increment in half an hour slots\n    \n    return None  # If no time found\n\n# Combine schedules\ncombined_schedules = [nancy_schedule, albert_schedule, nathan_schedule]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(working_start, working_end, meeting_duration, combined_schedules)\n\nprint(meeting_time)  # Output the proposed meeting time\n```",
            "count": "calendar_scheduling_example_64"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the participants' busy schedules\njohn_busy = [(datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n             (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\"))]\n\nandrea_busy = [(datetime.strptime(\"9:00\", \"%H:%M\"), datetime.strptime(\"9:30\", \"%H:%M\")),\n               (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n               (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\")),\n               (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))]\n\nlisa_busy = [(datetime.strptime(\"9:00\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n             (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n             (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n             (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\")),\n             (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))]\n\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"17:00\", \"%H:%M\")\nmeeting_duration = timedelta(minutes=30)\n\n# Function to check if time is available for all participants\ndef is_time_available(start_time, end_time):\n    for start, end in john_busy + andrea_busy + lisa_busy:\n        if end_time > start and start_time < end:\n            return False\n    return True\n\n# Find a suitable time slot\ncurrent_time = work_start\nwhile current_time + meeting_duration <= work_end:\n    next_time = current_time + meeting_duration\n    if is_time_available(current_time, next_time):\n        print(f\"{current_time.strftime('%H:%M')}:{next_time.strftime('%H:%M')}\")\n        break\n    current_time += timedelta(minutes=1)\n```",
            "count": "calendar_scheduling_example_65"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the work hours and meeting duration\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"17:00\", \"%H:%M\")\nmeeting_duration = timedelta(hours=1)\n\n# Define participant availability\ncharles_availability = [\n    (work_start, datetime.strptime(\"09:00\", \"%H:%M\")),\n    (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n    (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n    (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\")),\n    (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\")),\n    (datetime.strptime(\"16:30\", \"%H:%M\"), work_end)\n]\n\n# Find available time slot\ndef find_meeting_time(availabilities, duration):\n    for start, end in availabilities:\n        while start + duration <= end:\n            free_slots.append((start, start + duration))\n            start += timedelta(minutes=30)\n    return free_slots\n\nfree_slots = []\nfind_meeting_time(charles_availability, meeting_duration)\n\n# Choose the first available slot for the meeting\nif free_slots:\n    meeting_start = free_slots[0][0]\n    meeting_end = meeting_start + meeting_duration\n    print(f\"{{{meeting_start.strftime('%H:%M')}:{meeting_end.strftime('%H:%M')}}}\")\n```",
            "count": "calendar_scheduling_example_66"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants_schedules, meeting_duration, work_start_time, work_end_time):\n    # Convert work hours to datetime objects\n    work_start = datetime.strptime(work_start_time, \"%H:%M\")\n    work_end = datetime.strptime(work_end_time, \"%H:%M\")\n    \n    # Build a list of busy time slots\n    busy_times = []\n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            busy_times.append((datetime.strptime(busy_start, \"%H:%M\"), datetime.strptime(busy_end, \"%H:%M\")))\n    \n    # Sort busy times\n    busy_times.sort()\n    \n    # Free time calculation\n    free_start = work_start\n    for busy_start, busy_end in busy_times:\n        # If there's a gap between free_start and busy_start, check for meeting slot\n        if free_start + timedelta(minutes=meeting_duration) <= busy_start:\n            return f\"{free_start.strftime('%H:%M')}:{(free_start + timedelta(minutes=meeting_duration)).strftime('%H:%M')}\"\n        # Move free_start to the end of the current busy slot\n        free_start = max(free_start, busy_end)\n\n    # Finally, check if there's time left at the end of the workday\n    if free_start + timedelta(minutes=meeting_duration) <= work_end:\n        return f\"{free_start.strftime('%H:%M')}:{(free_start + timedelta(minutes=meeting_duration)).strftime('%H:%M')}\"\n    \n    return None\n\n# Participants schedules\nparticipants_schedules = [\n    [(\"13:00\", \"13:30\")],  # Jacqueline's busy times\n    [],                     # Christian's busy times\n    [(\"09:00\", \"10:30\"), (\"11:30\", \"12:30\"), (\"14:00\", \"14:30\"), (\"15:30\", \"16:30\")]  # Linda's busy times\n]\n\nmeeting_duration = 30  # in minutes\nwork_start_time = \"09:00\"\nwork_end_time = \"17:00\"\n\nproposed_time = find_meeting_time(participants_schedules, meeting_duration, work_start_time, work_end_time)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_67"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define participant schedules\nmichael_schedule = [(datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n                    (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n                    (datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\")),\n                    (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\"))]\n\nlauren_schedule = [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n                   (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n\n# Meeting duration\nmeeting_duration = timedelta(minutes=30)\n\n# Function to find the earliest available time slot\ndef find_meeting_time(michael_schedule, lauren_schedule, meeting_duration):\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n\n    # Create a list of all busy times\n    all_busy_times = michael_schedule + lauren_schedule\n\n    # Create a list of free time slots\n    free_slots = []\n    current_time = work_start\n\n    while current_time < work_end:\n        # Check if the current time is busy\n        is_busy = any(start <= current_time < end for start, end in all_busy_times)\n\n        if not is_busy:\n            # Check if the meeting can fit in this free slot\n            if current_time + meeting_duration <= work_end:\n                free_slots.append(current_time)\n        current_time += timedelta(minutes=1)\n\n    # Return the earliest start time for the meeting\n    for start_time in free_slots:\n        if all(not (start_time < start < start_time + meeting_duration) for start, end in all_busy_times):\n            return start_time\n\n# Get proposed meeting time\nproposed_time = find_meeting_time(michael_schedule, lauren_schedule, meeting_duration)\n\n# Format output \noutput_time = f\"{proposed_time.strftime('%H:%M')}:{(proposed_time + meeting_duration).strftime('%H:%M')}\"\nprint(output_time)  # Example output: 12:00:12:30\n```",
            "count": "calendar_scheduling_example_68"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{10:00:11:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Working hours and meeting duration\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"17:00\", \"%H:%M\")\nmeeting_duration = timedelta(hours=1)\n\n# Participant schedules\nshirley_schedule = [(datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n                    (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n                    (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))]\n\nstephen_schedule = [(datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n                    (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\"))]\n\npaul_schedule = [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n                 (datetime.strptime(\"11:00\", \"%H:%M\"), work_end)]\n\n# Function to find a free slot\ndef find_free_slot():\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        # Check if current_time slot is free for everyone\n        meeting_start = current_time\n        meeting_end = current_time + meeting_duration\n        \n        if all(not (meeting_start < end and meeting_end > start) for start, end in shirley_schedule) and \\\n           all(not (meeting_start < end and meeting_end > start) for start, end in stephen_schedule) and \\\n           all(not (meeting_start < end and meeting_end > start) for start, end in paul_schedule):\n            return f\"{meeting_start.strftime('%H:%M')}:{meeting_end.strftime('%H:%M')}\"\n        \n        current_time += timedelta(minutes=30)  # Check next half hour\n\n# Get the proposed time\nproposed_time = find_free_slot()\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_69"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the working hours and time constraints\nstart_time = datetime.strptime('09:00', '%H:%M')\nend_time = datetime.strptime('17:00', '%H:%M')\nmeeting_duration = timedelta(minutes=30)\n\n# Define participants' schedules\ndenise_schedule = [(datetime.strptime('12:00', '%H:%M'), datetime.strptime('12:30', '%H:%M')),\n                   (datetime.strptime('15:30', '%H:%M'), datetime.strptime('16:00', '%H:%M'))]\nangela_schedule = []  # No meetings for Angela\nnatalie_schedule = [(datetime.strptime('09:00', '%H:%M'), datetime.strptime('11:30', '%H:%M')),\n                    (datetime.strptime('12:00', '%H:%M'), datetime.strptime('13:00', '%H:%M')),\n                    (datetime.strptime('14:00', '%H:%M'), datetime.strptime('14:30', '%H:%M')),\n                    (datetime.strptime('15:00', '%H:%M'), datetime.strptime('17:00', '%H:%M'))]\n\n# Combine schedules for all participants\ncombined_schedule = denise_schedule + natalie_schedule\n\n# Check for availability\ndef is_time_available(schedule, start, duration):\n    end = start + duration\n    for busy_start, busy_end in schedule:\n        if (start < busy_end and end > busy_start):\n            return False\n    return True\n\n# Find earliest available time\ncurrent_time = start_time\nwhile current_time + meeting_duration <= end_time:\n    if is_time_available(combined_schedule, current_time, meeting_duration):\n        print(f\"{current_time.strftime('%H:%M')}:{(current_time + meeting_duration).strftime('%H:%M')}\")\n        break\n    current_time += timedelta(minutes=1)\n```",
            "count": "calendar_scheduling_example_70"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define working hours and participants' schedules\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"17:00\", \"%H:%M\")\nmeeting_duration = timedelta(minutes=30)\n\n# Schedules of participants\nnicole_schedule = []  # Nicole is free the entire day\njohn_schedule = [\n    (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n    (datetime.strptime(\"16:30\", \"%H:%M\"), work_end)\n]\nethan_schedule = [\n    (work_start, datetime.strptime(\"10:00\", \"%H:%M\")),\n    (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\")),\n    (datetime.strptime(\"14:30\", \"%H:%M\"), work_end)\n]\n\n# Create a function to find a free slot\ndef find_meeting_time(work_start, work_end, meeting_duration, john_schedule, ethan_schedule):\n    # Create a list of busy times for John's and Ethan's schedules\n    busy_times = []\n    busy_times.extend(john_schedule)\n    busy_times.extend(ethan_schedule)\n    \n    # Generate free times based on busy times\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        is_free = True\n        for start, end in busy_times:\n            if current_time < end and current_time + meeting_duration > start:\n                is_free = False\n                break\n        if is_free:\n            return current_time.strftime(\"%H:%M\") + \":\" + (current_time + meeting_duration).strftime(\"%H:%M\")\n        current_time += timedelta(minutes=30)\n\n# Call the function to find the meeting time\nproposed_time = find_meeting_time(work_start, work_end, meeting_duration, john_schedule, ethan_schedule)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_71"
        },
        {
            "final_program_time": "{13:30:14:30}",
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define work hours\nstart_time = datetime.strptime(\"09:00\", \"%H:%M\")\nend_time = datetime.strptime(\"17:00\", \"%H:%M\")\nmeeting_duration = timedelta(hours=1)\n\n# Define existing schedules (blocked times)\namy_schedule = [\n    (datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n    (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n    (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))\n]\n\nchristopher_schedule = [\n    (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n    (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n    (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n    (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))\n]\n\n# Collect all blocked times\nblocked_times = amy_schedule + christopher_schedule\n\n# Check each time slot in work hours\ncurrent_time = start_time\nwhile current_time + meeting_duration <= end_time:\n    # Check if current time is free\n    is_free = True\n    for start, end in blocked_times:\n        if current_time < end and (current_time + meeting_duration) > start:\n            is_free = False\n            break\n    \n    if is_free:\n        proposed_time = current_time.strftime(\"%H:%M\")\n        meeting_time_window = (current_time + meeting_duration).strftime(\"%H:%M\")\n        print(f\"{proposed_time}:{meeting_time_window}\")\n        break\n    \n    current_time += timedelta(minutes=30)  # Check every 30 minutes\n```",
            "count": "calendar_scheduling_example_72"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the work hours and meeting duration\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"17:00\", \"%H:%M\")\nmeeting_duration = timedelta(minutes=30)\n\n# Define the schedules\nschedule_bradley = [\n    (datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n    (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n    (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n    (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))\n]\n\nschedule_andrew = [\n    (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n    (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n    (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\")),\n    (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\"))\n]\n\nschedule_melissa = [\n    (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n    (datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n    (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\")),\n    (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\")),\n    (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))\n]\n\n# Create a function to find available time slot\ndef find_meeting_time():\n    current_time = work_start\n    while current_time <= work_end - meeting_duration:\n        meeting_end = current_time + meeting_duration\n        if (all(not (current_time < end and meeting_end > start) for start, end in schedule_bradley) and\n            all(not (current_time < end and meeting_end > start) for start, end in schedule_andrew) and\n            all(not (current_time < end and meeting_end > start) for start, end in schedule_melissa)):\n            return current_time.strftime(\"%H:%M\") + \":\" + meeting_end.strftime(\"%H:%M\")\n        current_time += timedelta(minutes=1)  # Increment time minute by minute\n    return None\n\n# Get the proposed meeting time\nproposed_time = find_meeting_time()\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_73"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define participant schedules and constraints\nparticipant_busy_times = {\n    'Eric': [(datetime.strptime('10:00', '%H:%M'), datetime.strptime('12:00', '%H:%M'))],\n    'Albert': [(datetime.strptime('12:00', '%H:%M'), datetime.strptime('12:30', '%H:%M')),\n               (datetime.strptime('15:30', '%H:%M'), datetime.strptime('16:00', '%H:%M'))],\n    'Katherine': [(datetime.strptime('10:00', '%H:%M'), datetime.strptime('11:00', '%H:%M')),\n                  (datetime.strptime('11:30', '%H:%M'), datetime.strptime('14:00', '%H:%M')),\n                  (datetime.strptime('15:00', '%H:%M'), datetime.strptime('15:30', '%H:%M'))]\n}\n\n# Meeting duration\nmeeting_duration = timedelta(hours=1)\n\n# Working hours\nwork_hours_start = datetime.strptime('09:00', '%H:%M')\nwork_hours_end = datetime.strptime('17:00', '%H:%M')\n\n# Gather all busy times by all participants\nbusy_times = []\nfor busy_slots in participant_busy_times.values():\n    busy_times.extend(busy_slots)\n\n# Sort busy times\nbusy_times.sort()\n\n# Check for available slots\ncurrent_time = work_hours_start\nfor start, end in busy_times:\n    # If current_time is before the busy time\n    if current_time + meeting_duration <= start:\n        proposed_start = current_time\n        proposed_end = proposed_start + meeting_duration\n        if proposed_end <= work_hours_end:\n            print(f\"{proposed_start.strftime('%H:%M')}:{proposed_end.strftime('%H:%M')}\")\n            break\n    # Move current_time to end of the busy slot\n    if current_time < end:\n        current_time = end\n# If time has not been set, check the last interval till work_hours_end\nif current_time + meeting_duration <= work_hours_end:\n    proposed_start = current_time\n    proposed_end = proposed_start + meeting_duration\n    print(f\"{proposed_start.strftime('%H:%M')}:{proposed_end.strftime('%H:%M')}\")\n```",
            "count": "calendar_scheduling_example_74"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the working hours\nstart_time = datetime.strptime(\"09:00\", \"%H:%M\")\nend_time = datetime.strptime(\"17:00\", \"%H:%M\")\nmeeting_duration = timedelta(hours=1)\n\n# Define the busy schedules for each participant\njacob_busy = [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n               (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n               (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n               (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n\namanda_busy = [(datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n                (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\"))]\n\nlisa_busy = [(datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n              (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))]\n\n# Function to check if a given time slot is free for all participants\ndef is_slot_free(start, end):\n    for busy in jacob_busy:\n        if start < busy[1] and end > busy[0]:\n            return False\n    for busy in amanda_busy:\n        if start < busy[1] and end > busy[0]:\n            return False\n    for busy in lisa_busy:\n        if start < busy[1] and end > busy[0]:\n            return False\n    return True\n\n# Find a suitable time slot\ncurrent_start = start_time\nwhile current_start + meeting_duration <= end_time:\n    current_end = current_start + meeting_duration\n    if is_slot_free(current_start, current_end):\n        print(f\"{current_start.strftime('%H:%M')}:{current_end.strftime('%H:%M')}\")\n        break\n    current_start += timedelta(minutes=30)  # Check next half-hour slot\n```",
            "count": "calendar_scheduling_example_75"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define work hours\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"17:00\", \"%H:%M\")\n\n# Define meetings for Beverly and Peter\nbeverly_meetings = [\n    (datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n    (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n    (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n    (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\")),\n    (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\")),\n    (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))\n]\n\npeter_meetings = [\n    (datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n    (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n    (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\")),\n    (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))\n]\n\nmeeting_duration = timedelta(hours=1)\n\n# Function to find a suitable time for the meeting\ndef find_meeting_time(beverly_meetings, peter_meetings, work_start, work_end, meeting_duration):\n    available_slots = []\n    \n    current_time = work_start\n    \n    while current_time + meeting_duration <= work_end:\n        end_time = current_time + meeting_duration\n        \n        # Check availability for Beverly\n        is_available_for_beverly = all(not (start < end_time and current_time < end) for start, end in beverly_meetings)\n        # Check availability for Peter\n        is_available_for_peter = all(not (start < end_time and current_time < end) for start, end in peter_meetings)\n        \n        if is_available_for_beverly and is_available_for_peter:\n            available_slots.append((current_time, end_time))\n        \n        current_time += timedelta(minutes=1)  # Increment by 1 minute to check the next slot\n    \n    return available_slots\n\navailable_slots = find_meeting_time(beverly_meetings, peter_meetings, work_start, work_end, meeting_duration)\n\nif available_slots:\n    meeting_time = available_slots[0]  # Take the first available slot\n    print(f\"{meeting_time[0].strftime('%H:%M')}:{meeting_time[1].strftime('%H:%M')}\")\nelse:\n    print(\"No available meeting time found.\")\n```",
            "count": "calendar_scheduling_example_76"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\n# Define the participants' schedules and preferences\nfrom datetime import datetime, timedelta\n\n# Participants' busy times in tuples of (start_time, end_time)\ndonald_busy = [(datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n               (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n               (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n               (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n               (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))]\n\njoyce_busy = [(datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n              (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n              (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))]\n\nabigail_busy = [(datetime.strptime(\"9:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n                (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n                (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\")),\n                (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n\n# Meeting duration\nmeeting_duration = timedelta(minutes=30)\n\n# Work hours\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"17:00\", \"%H:%M\")\n\n# Find available time slots\ndef find_meeting_time(donald_busy, joyce_busy, abigail_busy, meeting_duration):\n    # Combine all busy times\n    all_busy = donald_busy + joyce_busy + abigail_busy\n    all_busy.sort(key=lambda x: x[0])  # Sort by start time\n\n    # Check available times between work_start and work_end\n    current_start = work_start\n\n    for busy_start, busy_end in all_busy:\n        # If there is free time before the next busy period\n        if current_start + meeting_duration <= busy_start:\n            return current_start, current_start + meeting_duration\n        \n        # Move current_start to the end of the busy period\n        if current_start < busy_end:\n            current_start = busy_end\n\n    # Check if there is time after the last busy period until work_end\n    if current_start + meeting_duration <= work_end:\n        return current_start, current_start + meeting_duration\n\n    return None\n\n# Get meeting time\nmeeting_time = find_meeting_time(donald_busy, joyce_busy, abigail_busy, meeting_duration)\n\n# Format the output\nif meeting_time:\n    start_time, end_time = meeting_time\n    print(f\"{start_time.strftime('%H:%M')}:{end_time.strftime('%H:%M')}\")\nelse:\n    print(\"No available meeting time found.\")\n```",
            "count": "calendar_scheduling_example_77"
        },
        {
            "final_program_time": "{12:30:13:30}",
            "expected_time": "{12:30:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participant_schedules, meeting_duration, work_hours):\n    # Parse the work hours\n    start_time, end_time = work_hours.split(\" to \")\n    \n    # Convert time to minutes from midnight for easier calculations\n    def time_to_minutes(t):\n        h, m = map(int, t.split(':'))\n        return h * 60 + m\n    \n    # Convert minutes to HH:MM format\n    def minutes_to_time(m):\n        return f\"{m // 60:02}:{m % 60:02}\"\n    \n    # Create a time block for the participant schedules\n    busy_times = []\n    for schedule in participant_schedules:\n        for busy_time in schedule:\n            busy_start, busy_end = map(time_to_minutes, busy_time)\n            busy_times.append((busy_start, busy_end))\n\n    # Sort busy times\n    busy_times.sort()\n    \n    # Initialize available time windows\n    available_times = []\n    last_end = time_to_minutes(start_time)\n    \n    for busy_start, busy_end in busy_times:\n        if last_end < busy_start:\n            available_times.append((last_end, busy_start))\n        last_end = max(last_end, busy_end)\n    \n    if last_end < time_to_minutes(end_time):\n        available_times.append((last_end, time_to_minutes(end_time)))\n    \n    # Check for available slots with the required meeting duration\n    for start, end in available_times:\n        if end - start >= meeting_duration:\n            return f\"{minutes_to_time(start)}:{minutes_to_time(start + meeting_duration)}\"\n\n# Define participants' busy schedules\nronald_schedule = [(\"09:00\", \"10:00\"), (\"11:00\", \"12:00\")]\nteresa_schedule = [(\"10:30\", \"11:00\"), (\"14:00\", \"14:30\")]\ncarol_schedule = [(\"09:00\", \"12:30\"), (\"14:00\", \"15:30\"), (\"16:00\", \"17:00\")]\n\n# Combine participants' schedules\nschedules = [ronald_schedule, teresa_schedule, carol_schedule]\n\n# Meeting duration and work hours\nmeeting_duration = 60  # in minutes\nwork_hours = \"09:00 to 17:00\"\n\n# Find a meeting time\nproposed_time = find_meeting_time(schedules, meeting_duration, work_hours)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_78"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time():\n    # Define work hours\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    \n    # Existing schedules (busy times for each participant)\n    amy_busy = [(datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n                (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\"))]\n    \n    john_busy = [(datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n                 (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n                 (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\")),\n                 (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n    \n    # Meeting duration\n    meeting_duration = timedelta(hours=1)\n\n    # Create a list of all busy times\n    all_busy_times = amy_busy + john_busy\n\n    # Check for available slots\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        # Check if the current time falls within any busy time\n        is_busy = any(start <= current_time < end for start, end in all_busy_times)\n        if not is_busy:\n            # Check if the next hour is free\n            is_busy_next_hour = any(start <= current_time + meeting_duration <= end for start, end in all_busy_times)\n            if not is_busy_next_hour:\n                return f\"{current_time.strftime('%H:%M')}:{(current_time + meeting_duration).strftime('%H:%M')}\"\n        \n        current_time += timedelta(minutes=30)  # Check every half hour\n\n# Get proposed meeting time\nproposed_time = find_meeting_time()\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_79"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the working hours and the participants' schedules\nworking_hours_start = datetime.strptime(\"09:00\", \"%H:%M\")\nworking_hours_end = datetime.strptime(\"17:00\", \"%H:%M\")\nmeeting_duration = timedelta(minutes=30)\n\n# Existing schedules for everyone\nmichelle_schedule = [\n    (datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n    (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n]\n\nbilly_schedule = [\n    (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n    (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n    (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n    (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\")),\n]\n\nalexis_schedule = [\n    (datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n    (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n    (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n    (datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\")),\n    (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\")),\n]\n\n# Function to check if a time slot is free for all participants\ndef is_time_slot_free(start_time, end_time):\n    for busy in michelle_schedule + billy_schedule + alexis_schedule:\n        if start_time < busy[1] and end_time > busy[0]:\n            return False\n    return True\n\n# Find a suitable time\ncurrent_time = working_hours_start\nwhile current_time + meeting_duration <= working_hours_end:\n    if is_time_slot_free(current_time, current_time + meeting_duration):\n        proposed_start = current_time\n        proposed_end = current_time + meeting_duration\n        print(f'{proposed_start.strftime(\"%H:%M\")}:{proposed_end.strftime(\"%H:%M\")}')\n        break\n    current_time += timedelta(minutes=30)  # Increment by 30 minutes\n```",
            "count": "calendar_scheduling_example_80"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Participants' schedules\njeremy_schedule = [(datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\"))]\nlawrence_schedule = [(datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\")),\n                     (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\nhelen_schedule = [(datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n                  (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n                  (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n                  (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\")),\n                  (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\")),\n                  (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n\n# Meeting duration\nmeeting_duration = timedelta(hours=1)\n\n# Work hours\nstart_of_work = datetime.strptime(\"09:00\", \"%H:%M\")\nend_of_work = datetime.strptime(\"17:00\", \"%H:%M\")\n\n# Function to find a suitable time for the meeting\ndef find_meeting_time(jeremy, lawrence, helen, duration, start, end):\n    available_slots = []\n    \n    # Check for available slots in the working hours\n    current_time = start\n    while current_time + duration <= end:\n        occupied = False\n        for start_time, end_time in jeremy:\n            if current_time < end_time and current_time + duration > start_time:\n                occupied = True\n                break\n        for start_time, end_time in lawrence:\n            if current_time < end_time and current_time + duration > start_time:\n                occupied = True\n                break\n        for start_time, end_time in helen:\n            if current_time < end_time and current_time + duration > start_time:\n                occupied = True\n                break\n        if not occupied:\n            available_slots.append(current_time)\n        current_time += timedelta(minutes=30)  # Increment by 30 minutes to check for the next slot\n\n    # Return the first available time slot\n    if available_slots:\n        return available_slots[0]\n\n# Find proposed time for the meeting\nproposed_time = find_meeting_time(jeremy_schedule, lawrence_schedule, helen_schedule, meeting_duration, start_of_work, end_of_work)\n\n# Format output\nformatted_time = f\"{proposed_time.strftime('%H:%M')}:{(proposed_time + meeting_duration).strftime('%H:%M')}\"\nprint(formatted_time)\n```",
            "count": "calendar_scheduling_example_81"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the work hours and the time constraints for each participant\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"17:00\", \"%H:%M\")\nmeeting_duration = timedelta(minutes=30)\n\n# Existing schedules\nmichael_schedule = [(datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n                    (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\")),\n                    (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))]\n\narthur_schedule = [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n                   (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n                   (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\")),\n                   (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n\n# Eric's schedule is empty, so we don't need any constraints for him\n\ndef is_time_available(start_time, end_time, schedules):\n    for sch_start, sch_end in schedules:\n        if not (end_time <= sch_start or start_time >= sch_end):\n            return False\n    return True\n\n# Finding a suitable time slot for the meeting\ncurrent_time = work_start\nwhile current_time + meeting_duration <= work_end:\n    end_time = current_time + meeting_duration\n    if is_time_available(current_time, end_time, michael_schedule) and \\\n       is_time_available(current_time, end_time, arthur_schedule):\n        print(f\"{current_time.strftime('%H:%M')}:{end_time.strftime('%H:%M')}\")\n        break\n    current_time += timedelta(minutes=1)\n```",
            "count": "calendar_scheduling_example_82"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{10:00:11:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define work hours and meeting duration\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"17:00\", \"%H:%M\")\nmeeting_duration = timedelta(hours=1)\n\n# Define busy schedules for each participant\nbusy_slots = {\n    \"Anthony\": [\n        (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\")),\n        (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\")),\n    ],\n    \"Ronald\": [\n        (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n        (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n        (datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\")),\n    ],\n    \"Jonathan\": [\n        (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n        (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n        (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n        (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\")),\n        (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\")),\n    ]\n}\n\n# Function to check if a time slot is free for all participants\ndef is_free(start_time, end_time):\n    for slots in busy_slots.values():\n        for start, end in slots:\n            if start < end_time and end > start_time:\n                return False\n    return True\n\n# Find a suitable time for the meeting\ncurrent_time = work_start\nwhile current_time + meeting_duration <= work_end:\n    if is_free(current_time, current_time + meeting_duration):\n        meeting_start = current_time\n        meeting_end = current_time + meeting_duration\n        print(f\"{meeting_start.strftime('%H:%M')}:{meeting_end.strftime('%H:%M')}\")\n        break\n    current_time += timedelta(minutes=30)\n```",
            "count": "calendar_scheduling_example_83"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef get_available_times(participants_busy_times, meeting_duration, work_start, work_end):\n    current_time = work_start\n    available_times = []\n\n    while current_time + meeting_duration <= work_end:\n        is_available = True\n        for busy_times in participants_busy_times:\n            for start, end in busy_times:\n                if current_time < end and current_time + meeting_duration > start:\n                    is_available = False\n                    break\n            if not is_available:\n                break\n        if is_available:\n            available_times.append(current_time)\n        current_time += timedelta(minutes=30)  # Check every half-hour\n    \n    return available_times\n\n# Define schedules in busy time slots for each participant\nkevin_busy = [(datetime(2023, 10, 2, 9, 30), datetime(2023, 10, 2, 10, 0)),\n              (datetime(2023, 10, 2, 10, 30), datetime(2023, 10, 2, 11, 0)),\n              (datetime(2023, 10, 2, 15, 0), datetime(2023, 10, 2, 16, 0))]\n\nryan_busy = [(datetime(2023, 10, 2, 10, 30), datetime(2023, 10, 2, 11, 30)),\n              (datetime(2023, 10, 2, 12, 30), datetime(2023, 10, 2, 13, 0)),\n              (datetime(2023, 10, 2, 13, 30), datetime(2023, 10, 2, 14, 0))]\n\neugene_busy = [(datetime(2023, 10, 2, 9, 0), datetime(2023, 10, 2, 9, 30)),\n                (datetime(2023, 10, 2, 10, 0), datetime(2023, 10, 2, 11, 0)),\n                (datetime(2023, 10, 2, 12, 30), datetime(2023, 10, 2, 17, 0))]\n\nparticipants_busy_times = [kevin_busy, ryan_busy, eugene_busy]\n\nmeeting_duration = timedelta(hours=1)\nwork_start = datetime(2023, 10, 2, 9, 0)\nwork_end = datetime(2023, 10, 2, 17, 0)\n\navailable_times = get_available_times(participants_busy_times, meeting_duration, work_start, work_end)\n\nif available_times:\n    start_time = available_times[0]\n    end_time = start_time + meeting_duration\n    print(f\"{{{start_time.strftime('%H:%M')}:{end_time.strftime('%H:%M')}}}\")\nelse:\n    print(\"No available time found for the meeting.\")\n```",
            "count": "calendar_scheduling_example_84"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Function to check if two time ranges overlap\ndef is_overlapping(start1, end1, start2, end2):\n    return start1 < end2 and start2 < end1\n\n# Define the work hours and participants' schedules\nwork_start = datetime.strptime('09:00', '%H:%M')\nwork_end = datetime.strptime('17:00', '%H:%M')\n\nkelly_free = [(work_start, work_end)]\n\n# Julia's busy schedule\njulia_busy = [\n    (datetime.strptime('09:30', '%H:%M'), datetime.strptime('10:00', '%H:%M')),\n    (datetime.strptime('14:00', '%H:%M'), datetime.strptime('14:30', '%H:%M')),\n    (datetime.strptime('15:00', '%H:%M'), datetime.strptime('15:30', '%H:%M')),\n    (datetime.strptime('16:30', '%H:%M'), datetime.strptime('17:00', '%H:%M')),\n]\n\n# Martha's busy schedule\nmartha_busy = [\n    (datetime.strptime('09:00', '%H:%M'), datetime.strptime('11:00', '%H:%M')),\n    (datetime.strptime('12:00', '%H:%M'), datetime.strptime('15:00', '%H:%M')),\n]\n\n# Meeting duration\nmeeting_duration = timedelta(minutes=30)\n\n# Create a function to find available time for the meeting\ndef find_meeting_time():\n    current_time = work_start\n\n    while current_time + meeting_duration <= work_end:\n        meeting_end = current_time + meeting_duration\n\n        # Check if the current time overlaps with any busy schedule\n        if all(not is_overlapping(current_time, meeting_end, start, end) for start, end in julia_busy) and \\\n           all(not is_overlapping(current_time, meeting_end, start, end) for start, end in martha_busy):\n\n            # Julia's preference that the meeting should end by 13:30\n            if meeting_end <= datetime.strptime('13:30', '%H:%M'):\n                return current_time.strftime('%H:%M'), meeting_end.strftime('%H:%M')\n\n        current_time += timedelta(minutes=1)  # Check the next minute\n\n# Get the proposed meeting time\nstart_time, end_time = find_meeting_time()\nprint(f'{{{start_time}:{end_time}}}')\n```",
            "count": "calendar_scheduling_example_85"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(schedules, meeting_duration):\n    # Parse the participants' schedules\n    # The schedules dictionary is of the format {participant_name: [(start_time, end_time)]}\n    \n    # Define the work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60  # 17:00 in minutes\n    \n    # Combine all busy times into one list\n    busy_times = []\n    for participant, times in schedules.items():\n        for start, end in times:\n            busy_times.append((start, end))\n    \n    # Sort the busy times\n    busy_times.sort()\n    \n    # Initialize available start time\n    available_start_time = work_start\n    \n    # Iterate through each busy time to find gaps\n    for start, end in busy_times:\n        if available_start_time + meeting_duration <= start:\n            # Found a gap\n            return format_time(available_start_time, meeting_duration)\n        available_start_time = max(available_start_time, end)\n    \n    # Check if there is time after the last busy period until the end of work hours\n    if available_start_time + meeting_duration <= work_end:\n        return format_time(available_start_time, meeting_duration)\n    \n    return None\n\ndef format_time(start_time, duration):\n    start_hour = start_time // 60\n    start_minute = start_time % 60\n    end_time = start_time + duration\n    end_hour = end_time // 60\n    end_minute = end_time % 60\n    return f\"{start_hour:02d}:{start_minute:02d}:{end_hour:02d}:{end_minute:02d}\"\n\n# Sample schedules\nschedules = {\n    \"Samuel\": [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), \n               (12 * 60, 12 * 60 + 30), (14 * 60, 15 * 60), \n               (16 * 60, 16 * 60 + 30)],\n    \"Emma\": [],\n    \"Brittany\": [(11 * 60 + 30, 14 * 60 + 30), \n                 (15 * 60, 15 * 60 + 30), \n                 (16 * 60 + 30, 17 * 60)],\n}\n\nmeeting_duration = 60  # duration of the meeting in minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(schedules, meeting_duration)\n\nprint(meeting_time)  # This will output a valid time in the required format\n```",
            "count": "calendar_scheduling_example_86"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the participants' schedules\nschedules = {\n    \"Brittany\": [(datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n                 (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n                 (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\")),\n                 (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))],\n    \"Wayne\": [(datetime.strptime(\"9:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n              (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n              (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))],\n    \"Charles\": [(datetime.strptime(\"9:00\", \"%H:%M\"), datetime.strptime(\"9:30\", \"%H:%M\")),\n                (datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n                (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n                (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))]\n}\n\n# Define meeting duration\nmeeting_duration = timedelta(minutes=30)\n\n# Work hours\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"17:00\", \"%H:%M\")\n\ndef is_time_available(start_time, end_time):\n    for participant, busy_slots in schedules.items():\n        for (busy_start, busy_end) in busy_slots:\n            if (start_time < busy_end and end_time > busy_start):\n                return False\n    return True\n\n# Find a suitable meeting time\ncurrent_time = work_start\nwhile current_time + meeting_duration <= work_end:\n    if is_time_available(current_time, current_time + meeting_duration):\n        print(f\"{current_time.strftime('%H:%M')}:{(current_time + meeting_duration).strftime('%H:%M')}\")\n        break\n    current_time += timedelta(minutes=30)  # Check the next half-hour slot\n```",
            "count": "calendar_scheduling_example_87"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(dennis_schedule, joseph_schedule, isabella_schedule, meeting_duration):\n    # Define work hours\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    meeting_duration = timedelta(hours=meeting_duration)\n  \n    # Create time slots for the day\n    current_time = work_start\n    available_slots = []\n\n    while current_time + meeting_duration <= work_end:\n        # Check if the current time slot is free for all participants\n        slot_start = current_time\n        slot_end = current_time + meeting_duration\n        \n        if (slot_start not in dennis_schedule and slot_end not in dennis_schedule and\n            slot_start not in joseph_schedule and slot_end not in joseph_schedule and\n            slot_start not in isabella_schedule and slot_end not in isabella_schedule):\n            available_slots.append((slot_start, slot_end))\n        \n        current_time += timedelta(minutes=30)  # Increment by half hour\n\n    # Return the first available slot\n    if available_slots:\n        return available_slots[0]\n    return None\n\n# Existing schedules represented by the start of busy time slots\ndennis_schedule = []\njoseph_schedule = [datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\"),\n                   datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")]\nisabella_schedule = [datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\"),\n                     datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\"),\n                     datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\"),\n                     datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\")]\n\nmeeting_duration = 1  # 1 hour\nproposed_time = find_meeting_time(dennis_schedule, joseph_schedule, isabella_schedule, meeting_duration)\n\nif proposed_time:\n    output_format = f\"{proposed_time[0].strftime('%H:%M')}:{proposed_time[1].strftime('%H:%M')}\"\n    print(output_format)\nelse:\n    print(\"No available time slots found.\")\n```",
            "count": "calendar_scheduling_example_88"
        },
        {
            "final_program_time": "{15:00:16:00}",
            "expected_time": "{15:00:16:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the meeting duration\nmeeting_duration = timedelta(hours=1)\n\n# Define the work hours\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"17:00\", \"%H:%M\")\n\n# Existing schedules for each participant\nmichelle_busy_times = [(datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n                       (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\"))]\n\nandrea_busy_times = [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n                     (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n                     (datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\")),\n                     (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n                     (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))]\n\ndouglas_busy_times = [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n                      (datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n                      (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n                      (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n\n# Function to check if a time slot is free for all participants\ndef is_time_free(start, end):\n    for busy_time in michelle_busy_times + andrea_busy_times + douglas_busy_times:\n        if start < busy_time[1] and end > busy_time[0]:\n            return False\n    return True\n\n# Try to find a free slot within working hours\ndef find_meeting_time():\n    time_slot_start = work_start\n    \n    while time_slot_start + meeting_duration <= work_end:\n        time_slot_end = time_slot_start + meeting_duration\n        if is_time_free(time_slot_start, time_slot_end):\n            return f\"{time_slot_start.strftime('%H:%M')}:{time_slot_end.strftime('%H:%M')}\"\n        time_slot_start += timedelta(minutes=30)  # Increment by 30 minutes to check the next slot\n    \n    return None\n\n# Get the proposed meeting time\nproposed_time = find_meeting_time()\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_89"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\nimport datetime\n\n# Define the busy schedules of each participant\nadam_busy = [\n    (datetime.time(9, 30), datetime.time(10, 0)),\n    (datetime.time(10, 30), datetime.time(11, 0)),\n    (datetime.time(11, 30), datetime.time(12, 0)),\n    (datetime.time(16, 30), datetime.time(17, 0)),\n]\n\nwillie_busy = [\n    (datetime.time(9, 0), datetime.time(9, 30)),\n    (datetime.time(15, 30), datetime.time(16, 0)),\n]\n\ngloria_busy = [\n    (datetime.time(9, 30), datetime.time(12, 30)),\n    (datetime.time(13, 0), datetime.time(13, 30)),\n    (datetime.time(15, 30), datetime.time(16, 0)),\n]\n\n# Meeting constraints\nmeeting_duration = datetime.timedelta(minutes=30)\nwork_start = datetime.time(9, 0)\nwork_end = datetime.time(17, 0)\n\n# Function to check if a time slot is free for all participants\ndef is_free(start_time, end_time):\n    for busy_start, busy_end in adam_busy + willie_busy + gloria_busy:\n        if (start_time < busy_end) and (end_time > busy_start):\n            return False\n    return True\n\n# Try to schedule the meeting within the work hours\ndef schedule_meeting():\n    current_time = datetime.datetime.combine(datetime.date.today(), work_start)\n    work_end_dt = datetime.datetime.combine(datetime.date.today(), work_end)\n\n    while current_time + meeting_duration <= work_end_dt:\n        start_time = current_time.time()\n        end_time = (current_time + meeting_duration).time()\n        if is_free(start_time, end_time):\n            return f\"{start_time.strftime('%H:%M')}:{end_time.strftime('%H:%M')}\"\n        current_time += datetime.timedelta(minutes=1)\n\nprint(schedule_meeting())\n```",
            "count": "calendar_scheduling_example_90"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participant_schedules, duration, work_hours):\n    # Parse work hours\n    work_start = datetime.strptime(work_hours[0], '%H:%M')\n    work_end = datetime.strptime(work_hours[1], '%H:%M')\n    \n    # Create a list of available time slots\n    available_slots = [(work_start, work_end)]\n    \n    # Block out times based on participants' schedules\n    for schedule in participant_schedules:\n        new_slots = []\n        for start, end in available_slots:\n            if end <= schedule[0] or start >= schedule[1]:\n                new_slots.append((start, end))\n            else:\n                if start < schedule[0]:\n                    new_slots.append((start, schedule[0]))\n                if end > schedule[1]:\n                    new_slots.append((schedule[1], end))\n        available_slots = new_slots\n    \n    # Find a suitable time slot of required duration\n    for start, end in available_slots:\n        while start + duration <= end:\n            return f\"{start.strftime('%H:%M')}:{(start + duration).strftime('%H:%M')}\"\n            start += timedelta(minutes=1)  # Increment time by one minute if exact match not found\n\n# Participants' schedules\ndanielle_schedule = [(datetime.strptime(\"09:00\", '%H:%M'), datetime.strptime(\"10:00\", '%H:%M')),\n                     (datetime.strptime(\"10:30\", '%H:%M'), datetime.strptime(\"11:00\", '%H:%M')),\n                     (datetime.strptime(\"14:30\", '%H:%M'), datetime.strptime(\"15:00\", '%H:%M')),\n                     (datetime.strptime(\"15:30\", '%H:%M'), datetime.strptime(\"16:00\", '%H:%M')),\n                     (datetime.strptime(\"16:30\", '%H:%M'), datetime.strptime(\"17:00\", '%H:%M'))]\n\nbruce_schedule = [(datetime.strptime(\"11:00\", '%H:%M'), datetime.strptime(\"11:30\", '%H:%M')),\n                  (datetime.strptime(\"12:30\", '%H:%M'), datetime.strptime(\"13:00\", '%H:%M')),\n                  (datetime.strptime(\"14:00\", '%H:%M'), datetime.strptime(\"14:30\", '%H:%M')),\n                  (datetime.strptime(\"15:30\", '%H:%M'), datetime.strptime(\"16:00\", '%H:%M'))]\n\neric_schedule = [(datetime.strptime(\"09:00\", '%H:%M'), datetime.strptime(\"09:30\", '%H:%M')),\n                 (datetime.strptime(\"10:00\", '%H:%M'), datetime.strptime(\"11:00\", '%H:%M')),\n                 (datetime.strptime(\"11:30\", '%H:%M'), datetime.strptime(\"13:00\", '%H:%M')),\n                 (datetime.strptime(\"14:30\", '%H:%M'), datetime.strptime(\"15:30\", '%H:%M'))]\n\n# Combining participants' schedules\nschedules = danielle_schedule + bruce_schedule + eric_schedule\n\n# Meeting duration\nmeeting_duration = timedelta(hours=1)\n\n# Work hours\nwork_hours = (\"09:00\", \"17:00\")\n\n# Finding the meeting time\nmeeting_time = find_meeting_time(schedules, meeting_duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_91"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the work hours and participants' schedules\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"17:00\", \"%H:%M\")\nmeeting_duration = timedelta(hours=1)\n\n# Existing schedules\njacqueline_busy = [(datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n                   (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n\nhenry_busy = []  # Henry is free all day\n\nwilliam_busy = [(datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n                 (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n                 (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n\n\ndef find_free_time(start, end, busy_times, meeting_duration):\n    current_time = start\n    while current_time + meeting_duration <= end:\n        is_free = True\n        for busy_start, busy_end in busy_times:\n            if not (current_time + meeting_duration <= busy_start or current_time >= busy_end):\n                is_free = False\n                break\n        \n        if is_free:\n            return current_time.strftime(\"%H:%M\") + \":\" + (current_time + meeting_duration).strftime(\"%H:%M\")\n        \n        current_time += timedelta(minutes=30)  # Increment time in 30-minute intervals\n\n    return None\n\n\n# Combine busy times of all participants\ncombined_busy_times = jacqueline_busy + william_busy\n\n# Find a suitable time for the meeting\nmeeting_time = find_free_time(work_start, work_end, combined_busy_times, meeting_duration)\n\nprint(meeting_time)  # Output the result\n```",
            "count": "calendar_scheduling_example_92"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define work hours\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"17:00\", \"%H:%M\")\nmeeting_duration = timedelta(minutes=30)\n\n# Existing schedules for each participant\naustin_busy = [(datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n               (datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\"))]\ndanielle_busy = [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n                 (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n                 (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n                 (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\"))]\ncharles_busy = [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n                 (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n                 (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n\n# Function to find available time slot for the meeting\ndef find_meeting_time():\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        end_time = current_time + meeting_duration\n        \n        # Check if the current time slot is free for all participants\n        slot_is_free = True\n        \n        for busy in austin_busy + danielle_busy + charles_busy:\n            if not (end_time <= busy[0] or current_time >= busy[1]):\n                slot_is_free = False\n                break\n        \n        if slot_is_free:\n            return f\"{current_time.strftime('%H:%M')}:{end_time.strftime('%H:%M')}\"\n        \n        current_time += timedelta(minutes=1)  # Check the next minute\n\n# Output the meeting time\nmeeting_time = find_meeting_time()\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_93"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(nicholas_avail, elizabeth_avail, sandra_avail, meeting_duration):\n    start_time = datetime.strptime(\"09:00\", \"%H:%M\")\n    end_time = datetime.strptime(\"17:00\", \"%H:%M\")\n    \n    # Generate all time slots based on availability of each participant\n    time_slots = {}\n    \n    # Check each possible meeting start time\n    current_time = start_time\n    while current_time + meeting_duration <= end_time:\n        meeting_end_time = current_time + meeting_duration\n        \n        # Check if all participants are available\n        if (current_time >= nicholas_avail[0] and meeting_end_time <= nicholas_avail[1] and\n            current_time >= elizabeth_avail[0] and meeting_end_time <= elizabeth_avail[1] and\n            current_time >= sandra_avail[0] and meeting_end_time <= sandra_avail[1]):\n            return f\"{current_time.strftime('%H:%M')}:{meeting_end_time.strftime('%H:%M')}\"\n\n        current_time += timedelta(minutes=30)  # Increment by 30 minutes for next slot\n\n# Participant's availability\nnicholas_avail = (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))\nelizabeth_avail = (datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))\nsandra_avail = (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))\n\nmeeting_duration = timedelta(minutes=30)\n\n# Finding a suitable meeting time\nmeeting_time = find_meeting_time(nicholas_avail, elizabeth_avail, sandra_avail, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_94"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Participants' schedules\njennifer_schedule = [(datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n                     (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))]\n\ngary_schedule = [(datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n                 (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n                 (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n                 (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\")),\n                 (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n\nfrances_schedule = [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n                    (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n                    (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n\n# Meeting duration\nmeeting_duration = timedelta(minutes=30)\n\n# Work hours\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"17:00\", \"%H:%M\")\n\n# Function to check if time slot is free for all participants\ndef is_time_slot_free(start_time, end_time):\n    for busy_time in jennifer_schedule + gary_schedule + frances_schedule:\n        if start_time < busy_time[1] and end_time > busy_time[0]:\n            return False\n    return True\n\n# Finding a suitable time\ncurrent_time = work_start\nwhile current_time + meeting_duration <= work_end:\n    if current_time >= datetime.strptime(\"12:30\", \"%H:%M\") and is_time_slot_free(current_time, current_time + meeting_duration):\n        print(f\"{current_time.strftime('%H:%M')}:{(current_time + meeting_duration).strftime('%H:%M')}\")\n        break\n    current_time += timedelta(minutes=30)\n```",
            "count": "calendar_scheduling_example_95"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Participants' schedules\nschedules = {\n    \"Christopher\": [(\"09:30\", \"10:00\"), (\"10:30\", \"11:00\"), (\"11:30\", \"13:00\"), (\"15:00\", \"15:30\")],\n    \"Robert\": [(\"09:30\", \"10:00\"), (\"11:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:30\", \"14:30\"), (\"15:00\", \"15:30\")],\n    \"Wayne\": [(\"10:00\", \"17:00\")]\n}\n\n# Convert string time to datetime object\ndef convert_to_time(t):\n    return datetime.strptime(t, \"%H:%M\")\n\n# Define work hours\nwork_start = convert_to_time(\"09:00\")\nwork_end = convert_to_time(\"17:00\")\nmeeting_duration = timedelta(minutes=30)\n\n# Create a list of all busy times\nbusy_times = []\nfor participant, times in schedules.items():\n    for start, end in times:\n        busy_times.append((convert_to_time(start), convert_to_time(end)))\n\n# Sort busy times\nbusy_times.sort()\n\n# Combine overlapping busy times\nmerged_busy_times = []\nfor start, end in busy_times:\n    if not merged_busy_times or merged_busy_times[-1][1] < start:\n        merged_busy_times.append((start, end))\n    else:\n        merged_busy_times[-1] = (merged_busy_times[-1][0], max(merged_busy_times[-1][1], end))\n\n# Find available time for the meeting\ncurrent_time = work_start\nfor start, end in merged_busy_times:\n    # Check for available time before the busy period\n    if current_time + meeting_duration <= start:\n        print(f\"{current_time.strftime('%H:%M')}:{(current_time + meeting_duration).strftime('%H:%M')}\")\n        break\n    # Move current_time to the end of the busy period\n    current_time = max(current_time, end)\n\n# Check for available time after the last busy period until work end\nif current_time + meeting_duration <= work_end:\n    print(f\"{current_time.strftime('%H:%M')}:{(current_time + meeting_duration).strftime('%H:%M')}\")\n```",
            "count": "calendar_scheduling_example_96"
        },
        {
            "final_program_time": "{16:00:17:00}",
            "expected_time": "{16:00:17:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Participant schedules\njoseph_busy = [\n    (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n    (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n    (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n    (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\")),\n]\n\nkyle_busy = [\n    (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n]\n\njoan_busy = [\n    (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n    (datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n    (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n    (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\")),\n    (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n    (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\")),\n]\n\n# Meeting duration\nmeeting_duration = timedelta(hours=1)\n\n# Check available slots\ndef find_meeting_slot():\n    # Start work hours\n    start_hour = datetime.strptime(\"09:00\", \"%H:%M\")\n    end_hour = datetime.strptime(\"17:00\", \"%H:%M\")\n    \n    current_time = datetime.strptime(\"14:30\", \"%H:%M\")  # Joseph's preference\n    while current_time + meeting_duration <= end_hour:\n        slot_start = current_time\n        slot_end = current_time + meeting_duration\n        \n        # Check if the slot is free for all participants\n        def is_slot_free(slot_start, slot_end):\n            for busy in joseph_busy + kyle_busy + joan_busy:\n                if not (slot_end <= busy[0] or slot_start >= busy[1]):\n                    return False\n            return True\n        \n        if is_slot_free(slot_start, slot_end):\n            return f\"{slot_start.strftime('%H:%M')}:{slot_end.strftime('%H:%M')}\"\n        \n        # Move to the next possible slot\n        current_time += timedelta(minutes=30)  # Check every 30 minutes until close of work hours\n\n# Output proposed meeting time\nproposed_time = find_meeting_slot()\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_97"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define work hours and the participants' availability\nstart_time = datetime.strptime(\"09:00\", \"%H:%M\")\nend_time = datetime.strptime(\"17:00\", \"%H:%M\")\nmeeting_duration = timedelta(minutes=30)\n\n# Participants' schedules\njuan_busy = [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n             (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\"))]\nmarilyn_busy = [(datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n                (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\"))]\nronald_busy = [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n                (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n                (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n                (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))]\n\n# Function to find a suitable meeting time\ndef find_meeting_time():\n    current_time = start_time\n    while current_time + meeting_duration <= end_time:\n        # Check if the time is free for all participants\n        is_free = True\n        for busy in juan_busy:\n            if busy[0] <= current_time < busy[1] or busy[0] < current_time + meeting_duration <= busy[1]:\n                is_free = False\n                break\n        for busy in marilyn_busy:\n            if busy[0] <= current_time < busy[1] or busy[0] < current_time + meeting_duration <= busy[1]:\n                is_free = False\n                break\n        for busy in ronald_busy:\n            if busy[0] <= current_time < busy[1] or busy[0] < current_time + meeting_duration <= busy[1]:\n                is_free = False\n                break\n        \n        if is_free:\n            return f\"{current_time.strftime('%H:%M')}:{(current_time + meeting_duration).strftime('%H:%M')}\"\n        \n        current_time += timedelta(minutes=1)  # Increment the time by one minute\n\n# Finding the meeting time\nproposed_time = find_meeting_time()\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_98"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:00:16:00}",
            "type_error": null,
            "full_response": "```python\n# Define the schedules and constraints for each participant\nschedule = {\n    \"Stephanie\": [(9, 30), (13, 30), (14, 0)],  # Busy from 9:00-9:30, 13:30-14:00\n    \"Mark\": [],  # No constraints\n    \"Scott\": [(9, 10), (11, 12, 30), (14, 30), (16, 0)]  # Busy from 9:00-10:00, 11:00-12:30, 14:30-15:00, 16:00-17:00\n}\n\nmeeting_duration = 1  # 1 hour meeting\nwork_hours_start = 9  # 9:00 AM\nwork_hours_end = 17   # 5:00 PM\nmark_preference_start = 15  # Mark's preference to start after 15:00\n\n# Define a function to check if a time slot is available\ndef is_time_slot_available(start_hour, end_hour):\n    for participant, busy_times in schedule.items():\n        for busy_start, busy_end in busy_times:\n            if start_hour < busy_end and end_hour > busy_start:\n                return False\n    return True\n\n# Find a suitable time for the meeting\ndef find_meeting_time():\n    for hour in range(work_hours_start, work_hours_end - meeting_duration + 1):\n        if hour >= mark_preference_start:  # Respect Mark's preference\n            start_hour = hour\n            end_hour = hour + meeting_duration\n            if is_time_slot_available(start_hour, end_hour):\n                return f\"{start_hour:02}:00:{end_hour:02}:00\"\n\n# Output the proposed meeting time\nproposed_time = find_meeting_time()\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_99"
        }
    ],
    "5shot": [
        {
            "final_program_time": null,
            "expected_time": "{14:30:15:30}",
            "type_error": "TypeError",
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef is_time_available(start, end, schedule):\n    for busy_start, busy_end in schedule:\n        if (start < busy_end and end > busy_start):\n            return False\n    return True\n\ndef schedule_meeting(participants_schedules, meeting_duration, work_hours):\n    start_of_day = datetime.strptime(work_hours[0], \"%H:%M\")\n    end_of_day = datetime.strptime(work_hours[1], \"%H:%M\")\n    current_time = start_of_day\n\n    while current_time + meeting_duration <= end_of_day:\n        meeting_end = current_time + meeting_duration\n        if all(is_time_available(current_time, meeting_end, schedule) for schedule in participants_schedules):\n            return current_time.strftime(\"%H:%M\"), meeting_end.strftime(\"%H:%M\")\n        current_time += timedelta(minutes=30)\n    \n    return None\n\n# Example usage:\nparticipants_schedules = [\n    [(11, 12)],\n    [(9, 9.5), (11.5, 12)],\n    [(9, 9.5), (10, 11), (11.5, 12.5)]\n]\n\nwork_hours = [\"09:00\", \"17:00\"]\nmeeting_duration = timedelta(hours=1)\n\nproposed_time = schedule_meeting(participants_schedules, meeting_duration, work_hours)\nif proposed_time:\n    print(f\"{proposed_time[0]}:{proposed_time[1]}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_0"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants_schedule, meeting_duration_minutes=30, work_start=\"09:00\", work_end=\"17:00\"):\n    work_start_time = datetime.strptime(work_start, \"%H:%M\")\n    work_end_time = datetime.strptime(work_end, \"%H:%M\")\n    meeting_duration = timedelta(minutes=meeting_duration_minutes)\n\n    # Creating a list of busy time slots\n    busy_slots = []\n    for schedule in participants_schedule:\n        for busy_time in schedule:\n            busy_slots.append((datetime.strptime(busy_time[0], \"%H:%M\"), datetime.strptime(busy_time[1], \"%H:%M\")))\n\n    # Finding available slots based on busy times\n    available_slots = []\n    current_time = work_start_time\n\n    while current_time + meeting_duration <= work_end_time:\n        # Check if the current time slot is available\n        end_time = current_time + meeting_duration\n        is_available = all(not (start < end_time and current_time < end) for start, end in busy_slots)\n\n        if is_available:\n            available_slots.append((current_time, end_time))\n\n        current_time += timedelta(minutes=1)  # Move to the next minute\n\n    # Return the first available time slot\n    if available_slots:\n        proposed_time = available_slots[0]\n        return f\"{proposed_time[0].strftime('%H:%M')} - {proposed_time[1].strftime('%H:%M')}\"\n    return None\n\n# Participants schedules\nparticipants_schedule = [\n    [(\"09:00\", \"09:30\"), (\"11:30\", \"12:00\"), (\"13:00\", \"13:30\"), (\"15:00\", \"15:30\")],  # Raymond\n    [(\"10:00\", \"10:30\"), (\"12:00\", \"13:00\"), (\"16:30\", \"17:00\")],                     # Billy\n    [(\"09:00\", \"09:30\"), (\"10:00\", \"11:00\"), (\"12:00\", \"13:00\"), (\"14:00\", \"14:30\"), (\"16:00\", \"17:00\")]  # Donald\n]\n\n# Calculate the proposed time\nproposed_time = find_meeting_time(participants_schedule)\nprint(f\"Here is the proposed time: {proposed_time}\")\n```",
            "count": "calendar_scheduling_example_1"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_available_time(participants, meeting_duration):\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    \n    # Create a list of busy slots\n    busy_slots = []\n    for participant in participants:\n        busy_slots.extend(participant)\n        \n    # Sort busy slots\n    busy_slots.sort()\n    \n    # Check for available time slots\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        next_time = current_time + meeting_duration\n        \n        # Check if the current time is in any busy slot\n        if all(not (start < current_time < end) and not (start < next_time < end) for start, end in busy_slots):\n            return current_time.strftime(\"%H:%M\") + \" - \" + next_time.strftime(\"%H:%M\")\n        \n        current_time += timedelta(minutes=1)  # Increment by 1 minute to find next available slot\n    \n    return None  # In case no time was found\n\n# Sample usage with Roy, Kathryn and Amy\nparticipants = [\n    [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n     (datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n     (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n     (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\"))],\n    \n    [(datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n     (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))],\n    \n    [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\")),\n     (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\")),\n     (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n]\n\nmeeting_duration = timedelta(minutes=30)\nproposed_time = find_available_time(participants, meeting_duration)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_2"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:30:10:30}",
            "type_error": "TypeError",
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, duration_minutes, work_hours):\n    work_start, work_end = work_hours\n    current_time = work_start\n    \n    # Sort participants' busy schedules\n    busy_slots = []\n    for participant in participants:\n        busy_slots.extend(participant['busy'])\n    \n    busy_slots.sort()\n\n    # Merge overlapping busy slots\n    merged_busy_slots = []\n    for slot in busy_slots:\n        if not merged_busy_slots or merged_busy_slots[-1][1] < slot[0]:\n            merged_busy_slots.append(slot)\n        else:\n            merged_busy_slots[-1][1] = max(merged_busy_slots[-1][1], slot[1])\n    \n    # Find open slots\n    open_slots = []\n    previous_end = work_start\n\n    for start, end in merged_busy_slots:\n        if previous_end < start:\n            open_slots.append((previous_end, start))\n        previous_end = end\n    \n    # Final open slot at the end of the workday\n    if previous_end < work_end:\n        open_slots.append((previous_end, work_end))\n\n    # Search for adequate slot for the required duration\n    for open_start, open_end in open_slots:\n        if (open_end - open_start) >= timedelta(minutes=duration_minutes):\n            proposed_start = open_start\n            proposed_end = open_start + timedelta(minutes=duration_minutes)\n            return proposed_start.strftime('%H:%M'), proposed_end.strftime('%H:%M')\n\n# Test case setup\nparticipants = [\n    {'name': 'Arthur', 'busy': [(datetime(2023,10,2,9,0), datetime(2023,10,2,9,30)),\n                                (datetime(2023,10,2,10,30), datetime(2023,10,2,12,0)),\n                                (datetime(2023,10,2,16,0), datetime(2023,10,2,17,0))]},\n    {'name': 'Michael', 'busy': [(datetime(2023,10,2,13,0), datetime(2023,10,2,13,30)),\n                                  (datetime(2023,10,2,14,0), datetime(2023,10,2,14,30))]},\n    {'name': 'Samantha', 'busy': [(datetime(2023,10,2,10,30), datetime(2023,10,2,11,0)),\n                                   (datetime(2023,10,2,12,0), datetime(2023,10,2,15,0)),\n                                   (datetime(2023,10,2,15,30), datetime(2023,10,2,17,0))]}\n]\n\nwork_hours = (datetime(2023,10,2,9,0), datetime(2023,10,2,17,0))\nduration_minutes = 60\n\n# Finding the meeting time\nproposed_start, proposed_end = find_meeting_time(participants, duration_minutes, work_hours)\n\n# Output\nprint(f\"{proposed_start}:{proposed_end}\")\n```",
            "count": "calendar_scheduling_example_3"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(availability, meeting_duration):\n    work_hours_start = datetime.strptime('09:00', '%H:%M')\n    work_hours_end = datetime.strptime('17:00', '%H:%M')\n    meeting_duration_timedelta = timedelta(minutes=meeting_duration)\n    \n    # Create a list of busy times for all participants\n    busy_times = []\n    for schedule in availability:\n        for busy_slot in schedule:\n            busy_start = datetime.strptime(busy_slot[0], '%H:%M')\n            busy_end = datetime.strptime(busy_slot[1], '%H:%M')\n            busy_times.append((busy_start, busy_end))\n    \n    # Sort the busy times\n    busy_times.sort()\n    \n    # Check for potential meeting slots\n    last_end = work_hours_start\n    for start, end in busy_times:\n        # Calculate free time before the current busy slot\n        if last_end + meeting_duration_timedelta <= start:\n            return f\"{last_end.strftime('%H:%M')} - {(last_end + meeting_duration_timedelta).strftime('%H:%M')}\"\n        last_end = max(last_end, end)\n\n    # Check the time after the last busy slot until work hours end\n    if last_end + meeting_duration_timedelta <= work_hours_end:\n        return f\"{last_end.strftime('%H:%M')} - {(last_end + meeting_duration_timedelta).strftime('%H:%M')}\"\n    \n    return \"No available time\"\n\n# Example usage:\navailability = [\n    [('09:00', '10:00'), ('10:30', '11:00'), ('11:30', '12:00'), \n     ('12:30', '13:00'), ('14:00', '15:00'), ('15:30', '16:00')],\n    [('10:30', '12:00'), ('13:00', '13:30'), ('14:00', '14:30'), \n     ('15:30', '16:00')],\n    [('09:00', '12:30'), ('13:30', '17:00')]\n]\n\nmeeting_duration = 30  # minutes\nproposed_time = find_meeting_time(availability, meeting_duration)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_4"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:00}",
            "type_error": "TypeError",
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(schedules, meeting_duration):\n    start_time = datetime.strptime(\"09:00\", \"%H:%M\")\n    end_time = datetime.strptime(\"17:00\", \"%H:%M\")\n    current_time = start_time\n    \n    while current_time + timedelta(minutes=meeting_duration) <= end_time:\n        meeting_start = current_time\n        meeting_end = current_time + timedelta(minutes=meeting_duration)\n        \n        if all(not (meeting_start < schedule[1] and meeting_end > schedule[0]) for schedule in schedules):\n            return f\"{meeting_start.strftime('%H:%M')}:{meeting_end.strftime('%H:%M')}\"\n        \n        current_time += timedelta(minutes=30)  # Check the next 30 minutes interval\n\n    return None\n\n# Example usage\nschedules = [\n    [(9, 0), (9, 30)],   # Kathryn\n    [(12, 0), (12, 30)], # Charlotte\n    [(9, 0), (10, 0)],   # Lauren\n]\n\nmeeting_duration = 30  # 30 minutes\nproposed_time = find_meeting_time(schedules, meeting_duration)\nprint(proposed_time)  # Output format: HH:MM:HH:MM\n```",
            "count": "calendar_scheduling_example_5"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:30:15:30}",
            "type_error": "TypeError",
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef schedule_meeting(participants, duration, work_start, work_end):\n    # Define work hours\n    work_start_time = datetime.strptime(work_start, \"%H:%M\")\n    work_end_time = datetime.strptime(work_end, \"%H:%M\")\n\n    # Create a list of busy slots for every participant\n    busy_slots = []\n\n    for participant in participants:\n        busy_slots.extend(participant['busy'])\n\n    # Create a list of time slots for the whole work day\n    current_time = work_start_time\n    while current_time + timedelta(minutes=duration) <= work_end_time:\n        is_free = True\n        for start, end in busy_slots:\n            if not (current_time + timedelta(minutes=duration) <= start or current_time >= end):\n                is_free = False\n                break\n        if is_free:\n            return f\"{current_time.strftime('%H:%M')} - {(current_time + timedelta(minutes=duration)).strftime('%H:%M')}\"\n        current_time += timedelta(minutes=1)\n\n# Example participants schedule\nparticipants = [\n    {\n        \"name\": \"Thomas\",\n        \"busy\": []\n    },\n    {\n        \"name\": \"Dylan\",\n        \"busy\": [(\"10:30\", \"11:00\"), (\"13:30\", \"14:00\")]\n    },\n    {\n        \"name\": \"Jerry\",\n        \"busy\": [(\"09:00\", \"11:00\"), (\"11:30\", \"14:30\"), (\"16:00\", \"17:00\")]\n    }\n]\n\n# Schedule a 1-hour meeting\nmeeting_duration = 60  # in minutes\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\n\n# Get proposed time\nproposed_time = schedule_meeting(participants, meeting_duration, work_hours_start, work_hours_end)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_6"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants_schedule, meeting_duration):\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    meeting_duration = timedelta(minutes=meeting_duration)\n\n    # Create a list of all busy intervals\n    busy_intervals = []\n    for schedule in participants_schedule:\n        for start, end in schedule:\n            busy_intervals.append((start, end))\n\n    # Sort intervals\n    busy_intervals.sort()\n\n    # Combine overlapping intervals\n    combined_intervals = []\n    for start, end in busy_intervals:\n        if not combined_intervals or combined_intervals[-1][1] < start:\n            combined_intervals.append((start, end))\n        else:\n            combined_intervals[-1] = (combined_intervals[-1][0], max(combined_intervals[-1][1], end))\n\n    # Check for available slots\n    last_end = work_start\n    for start, end in combined_intervals:\n        if last_end + meeting_duration <= start:\n            return (last_end, last_end + meeting_duration)\n        last_end = end\n\n    # Check if there's time after the last busy interval\n    if last_end + meeting_duration <= work_end:\n        return (last_end, last_end + meeting_duration)\n\n    return None\n\ndef format_time(time_tuple):\n    start, end = time_tuple\n    return f\"{start.strftime('%H:%M')}:{end.strftime('%H:%M')}\"\n\n# Example usage\nparticipants_schedule = [\n    [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n     (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n     (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\")),\n     (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n     (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))],\n    \n    [],  # No meetings\n    [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n     (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n     (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n     (datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))]\n]\n\nmeeting_duration = 30  # in minutes\navailable_time = find_meeting_time(participants_schedule, meeting_duration)\nif available_time:\n    print(format_time(available_time))\n```",
            "count": "calendar_scheduling_example_7"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:11:30}",
            "type_error": "TypeError",
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(schedules, duration, work_start, work_end):\n    # Convert time strings to datetime objects\n    work_start = datetime.strptime(work_start, '%H:%M')\n    work_end = datetime.strptime(work_end, '%H:%M')\n    \n    # Create a timeline for each hour within the work day\n    free_slots = []\n    current_time = work_start\n    \n    while current_time + duration <= work_end:\n        meeting_start = current_time\n        meeting_end = current_time + duration\n        \n        # Check if the current slot overlaps with any participant's busy schedule\n        if all(not (meeting_start < end and meeting_end > start) for busy_slots in schedules.values() for start, end in busy_slots):\n            free_slots.append((meeting_start, meeting_end))\n        \n        current_time += timedelta(minutes=30)  # Check every half hour\n\n    # Return the first available time slot\n    if free_slots:\n        start_time = free_slots[0][0].strftime('%H:%M')\n        end_time = free_slots[0][1].strftime('%H:%M')\n        return f\"{start_time}:{end_time}\"\n    else:\n        return \"No available time.\"\n\n# Example schedule input\nschedules = {\n    'Adam': [('10:00', '10:30'), ('12:30', '13:00'), ('13:30', '14:30')],\n    'Jerry': [('09:00', '09:30'), ('12:00', '12:30'), ('15:00', '16:00')],\n    'Matthew': [('09:30', '11:00'), ('11:30', '12:30'), ('13:00', '14:00'), ('14:30', '17:00')],\n}\n\n# Define meeting parameters\nmeeting_duration = timedelta(minutes=30)\nwork_hours_start = '09:00'\nwork_hours_end = '17:00'\n\n# Call the function to find a meeting time\nproposed_time = find_meeting_time(schedules, meeting_duration, work_hours_start, work_hours_end)\nprint(proposed_time)  # Output format: HH:MM:HH:MM\n```",
            "count": "calendar_scheduling_example_8"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(schedules, meeting_duration):\n    start_of_day = datetime.strptime(\"09:00\", \"%H:%M\")\n    end_of_day = datetime.strptime(\"17:00\", \"%H:%M\")\n    \n    # Convert meeting duration from minutes to timedelta\n    meeting_duration = timedelta(minutes=meeting_duration)\n    \n    # Create a list of busy slots\n    busy_slots = []\n    for schedule in schedules:\n        for slot in schedule:\n            busy_slots.append((datetime.strptime(slot[0], \"%H:%M\"), datetime.strptime(slot[1], \"%H:%M\")))\n    \n    # Sort busy slots\n    busy_slots.sort()\n    \n    # Merge overlapping busy slots\n    merged_busy_slots = []\n    for slot in busy_slots:\n        if not merged_busy_slots or merged_busy_slots[-1][1] < slot[0]:\n            merged_busy_slots.append(slot)\n        else:\n            merged_busy_slots[-1] = (merged_busy_slots[-1][0], max(merged_busy_slots[-1][1], slot[1]))\n    \n    # Check for availability between busy slots and within work hours\n    current_start = start_of_day\n    \n    for busy_start, busy_end in merged_busy_slots:\n        if current_start + meeting_duration <= busy_start:\n            return f\"{current_start.strftime('%H:%M')} - {(current_start + meeting_duration).strftime('%H:%M')}\"\n        \n        current_start = max(current_start, busy_end)\n\n    # Check if there's time after the last busy slot until the end of the day\n    if current_start + meeting_duration <= end_of_day:\n        return f\"{current_start.strftime('%H:%M')} - {(current_start + meeting_duration).strftime('%H:%M')}\"\n\n    return None\n\n# Schedules for Diane, Kelly, and Deborah\nschedules = [\n    [(\"09:00\", \"09:30\"), (\"12:00\", \"12:30\"), (\"14:30\", \"15:30\")],  # Diane's schedule\n    [(\"09:30\", \"10:00\"), (\"10:30\", \"11:00\")],                      # Kelly's schedule\n    [(\"09:00\", \"09:30\"), (\"10:00\", \"14:00\"), (\"14:30\", \"17:00\")]   # Deborah's schedule\n]\n\n# Finding a suitable meeting time for half an hour (30 minutes)\nmeeting_duration = 30  # in minutes\nproposed_time = find_meeting_time(schedules, meeting_duration)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_9"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants_schedules, meeting_duration, start_time, end_time):\n    # Convert string time to datetime\n    start_time = datetime.strptime(start_time, '%H:%M')\n    end_time = datetime.strptime(end_time, '%H:%M')\n    \n    # Create a list of free time blocks for each participant\n    free_time_blocks = []\n    \n    for schedule in participants_schedules:\n        busy_times = []\n        for busy_start, busy_end in schedule:\n            busy_times.append((datetime.strptime(busy_start, '%H:%M'), datetime.strptime(busy_end, '%H:%M')))\n        \n        # Calculate free time segments for the participant\n        free_times = []\n        current_time = start_time\n        \n        for busy_start, busy_end in busy_times:\n            if current_time < busy_start:\n                free_times.append((current_time, busy_start))\n            current_time = max(current_time, busy_end)\n\n        if current_time < end_time:\n            free_times.append((current_time, end_time))\n        free_time_blocks.append(free_times)\n\n    # Find common free time and check for meeting duration\n    common_free_times = set(tuple(block) for block in free_time_blocks[0])\n    for f_time in free_time_blocks[1:]:\n        common_free_times.intersection_update(set(tuple(block) for block in f_time))\n\n    # Check if there is a common time that can accommodate the meeting duration\n    for start, end in sorted(common_free_times):\n        if (end - start) >= timedelta(minutes=meeting_duration):\n            proposed_end_time = start + timedelta(minutes=meeting_duration)\n            if proposed_end_time <= end:\n                return (start.strftime('%H:%M'), proposed_end_time.strftime('%H:%M'))\n\n    return None\n\n# Define participants' schedules\nparticipants_schedules = [\n    [(\"9:00\", \"10:00\"), (\"10:30\", \"11:00\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"14:00\", \"15:30\"), (\"16:00\", \"17:00\")], # Roger\n    [(\"10:00\", \"10:30\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"14:00\", \"15:00\"), (\"15:30\", \"16:00\")], # Karen\n    [(\"9:00\", \"10:00\"), (\"10:30\", \"11:00\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"14:00\", \"15:30\"), (\"16:00\", \"17:00\")]  # Dorothy\n]\n\n# Define meeting duration and working hours\nmeeting_duration = 30\nstart_time = \"09:00\"\nend_time = \"17:00\"\n\n# Find and print the proposed time\nproposed_time = find_meeting_time(participants_schedules, meeting_duration, start_time, end_time)\nif proposed_time:\n    print(f\"{proposed_time[0]} - {proposed_time[1]}\")\n```",
            "count": "calendar_scheduling_example_10"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, meeting_duration_minutes=30, work_start='09:00', work_end='17:00'):\n    from datetime import datetime, timedelta\n\n    work_start = datetime.strptime(work_start, '%H:%M')\n    work_end = datetime.strptime(work_end, '%H:%M')\n    meeting_duration = timedelta(minutes=meeting_duration_minutes)\n\n    # Create a list of busy times for each participant\n    busy_times = []\n    for schedule in participants_schedules:\n        for busy_time in schedule:\n            busy_start = datetime.strptime(busy_time[0], '%H:%M')\n            busy_end = datetime.strptime(busy_time[1], '%H:%M')\n            busy_times.append((busy_start, busy_end))\n\n    # Sort busy times\n    busy_times.sort()\n\n    # Merge overlapping busy times\n    merged_busy_times = []\n    for start, end in busy_times:\n        if not merged_busy_times or merged_busy_times[-1][1] < start:\n            merged_busy_times.append((start, end))\n        else:\n            merged_busy_times[-1] = (merged_busy_times[-1][0], max(merged_busy_times[-1][1], end))\n\n    # Check for available time slots\n    available_start = work_start\n    for busy_start, busy_end in merged_busy_times:\n        if available_start + meeting_duration <= busy_start:\n            return f\"{available_start.strftime('%H:%M')} - {(available_start + meeting_duration).strftime('%H:%M')}\"\n        available_start = max(available_start, busy_end)\n\n    # Check if there's time after the last busy time till work_end\n    if available_start + meeting_duration <= work_end:\n        return f\"{available_start.strftime('%H:%M')} - {(available_start + meeting_duration).strftime('%H:%M')}\"\n\n    return \"No available time\"\n\nparticipants_schedules = [\n    [(\"09:30\", \"10:00\"), (\"11:00\", \"11:30\"), (\"14:30\", \"15:00\"), (\"16:30\", \"17:00\")],  # Mason\n    [],  # Bruce\n    [(\"09:30\", \"10:30\"), (\"11:30\", \"12:30\"), (\"15:00\", \"17:00\")]  # Christopher\n]\n\nprint(find_meeting_time(participants_schedules, meeting_duration_minutes=30))\n```",
            "count": "calendar_scheduling_example_11"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, duration_minutes):\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    duration = timedelta(minutes=duration_minutes)\n\n    # Create a list of busy times for all participants\n    busy_times = []\n    for participant in participants:\n        busy_times.extend(participant)\n\n    # Sort busy times and merge overlapping intervals\n    busy_times.sort()\n    merged_busy_times = []\n\n    for start, end in busy_times:\n        if not merged_busy_times or merged_busy_times[-1][1] < start:\n            merged_busy_times.append((start, end))\n        else:\n            merged_busy_times[-1] = (merged_busy_times[-1][0], max(merged_busy_times[-1][1], end))\n\n    # Check for free slots in the work day\n    free_start = work_start\n    for start, end in merged_busy_times:\n        # Check if there's a free slot before the busy time\n        if free_start + duration <= start:\n            return f\"{free_start.strftime('%H:%M')}:{(free_start + duration).strftime('%H:%M')}\"\n        free_start = max(free_start, end)\n\n    # After last busy time, check if there's free time till work end\n    if free_start + duration <= work_end:\n        return f\"{free_start.strftime('%H:%M')}:{(free_start + duration).strftime('%H:%M')}\"\n    \n    return None  # This should not happen according to the problem statement\n\n# Define participants' schedules\nparticipants = [\n    # (start_time, end_time) tuples for each participant\n    [(datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n     (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n     (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n     (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))],  # Mason\n\n    [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))],  # Bruce\n\n    [(datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n     (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n     (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]  # Christopher\n]\n\n# Find meeting time for half an hour meeting\nproposed_time = find_meeting_time(participants, 30)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_12"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(schedules, meeting_duration):\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Initialize calendar with full availability\n    available_times = [(work_start, work_end)]\n    \n    # Process each person's schedule\n    for busy_schedule in schedules:\n        new_available_times = []\n        for start, end in available_times:\n            # Find gaps in available time\n            if busy_schedule[0] > start and busy_schedule[0] < end:\n                new_available_times.append((start, busy_schedule[0]))\n            if busy_schedule[1] > start and busy_schedule[1] < end:\n                new_available_times.append((busy_schedule[1], end))\n            if busy_schedule[0] <= start and busy_schedule[1] >= end:\n                continue  # busy schedule blocks the entire time\n            elif busy_schedule[0] > start and busy_schedule[1] < end:\n                new_available_times.append((start, busy_schedule[0]))\n                new_available_times.append((busy_schedule[1], end))\n        \n        # Set available times to the newly found slots\n        available_times = new_available_times\n    \n    # Check available times for a meeting slot\n    for start, end in available_times:\n        if (end - start) >= meeting_duration:\n            meeting_start = start\n            meeting_end = start + meeting_duration\n            return f\"{meeting_start // 60:02}:{meeting_start % 60:02}:{meeting_end // 60:02}:{meeting_end % 60:02}\"\n    \n    return None  # In case there's no valid time found\n\n# Example usage\nschedules = [\n    (9 * 60 + 0, 9 * 60 + 30),  # Gerald\n    (9 * 60 + 30, 10 * 60 + 0),  # Barbara\n    (13 * 60 + 0, 14 * 60 + 0)    # Gerald\n]\nmeeting_duration = 30  # in minutes\n\nprint(find_meeting_time(schedules, meeting_duration))\n```",
            "count": "calendar_scheduling_example_13"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(schedules, meeting_duration):\n    # Define working hours\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n\n    # Create a time block for the whole day\n    free_time = []\n    \n    # Initialize the free time list with the full work hours\n    free_time.append((work_start, work_end))\n\n    # Iterate over each participant's schedule\n    for participant in schedules:\n        busy_times = schedules[participant]\n        updated_free_time = []\n        \n        # For each busy time, subtract from the available free time\n        for free_start, free_end in free_time:\n            for busy_start, busy_end in busy_times:\n                # If there's a conflict with busy times\n                if busy_start < free_end and busy_end > free_start:\n                    # Adjust the free time periods\n                    if busy_start > free_start:\n                        updated_free_time.append((free_start, busy_start))  # Free time before busy\n                    if busy_end < free_end:\n                        updated_free_time.append((busy_end, free_end))      # Free time after busy\n                    # Break once we found the conflict\n                    free_start = free_end\n                    break\n            else:\n                # No conflicts, keep the existing free time\n                updated_free_time.append((free_start, free_end))\n\n        free_time = updated_free_time\n\n    # Check for available time slots for the required duration\n    for start, end in free_time:\n        while start + meeting_duration <= end:\n            return start.strftime(\"%H:%M\") + ':' + (start + meeting_duration).strftime(\"%H:%M\")\n            start += timedelta(minutes=1)\n\n# Example usage\nschedules = {\n    \"Brandon\": [(datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\")),\n                (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\")),\n                (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))],\n    \"Jerry\": [],\n    \"Bradley\": [(datetime.strptime(\"9:00\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n                (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n                (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))]\n}\n\n# Define meeting duration (30 minutes)\nmeeting_duration = timedelta(minutes=30)\n\n# Get proposed time\nproposed_time = find_meeting_time(schedules, meeting_duration)\nprint(f'Proposed time: {proposed_time}')\n```",
            "count": "calendar_scheduling_example_14"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Function to convert time in string format to a datetime object\ndef str_to_time(time_str):\n    return datetime.strptime(time_str, \"%H:%M\")\n\n# Function to convert datetime object to string format\ndef time_to_str(time_obj):\n    return time_obj.strftime(\"%H:%M\")\n\n# Function to find a suitable meeting time\ndef find_meeting_time(participants, duration):\n    work_start = str_to_time(\"09:00\")\n    work_end = str_to_time(\"17:00\")\n    duration_timedelta = timedelta(minutes=duration)\n\n    # Create a list of busy time slots\n    busy_intervals = []\n    for schedule in participants:\n        for busy_time in schedule:\n            busy_intervals.append((str_to_time(busy_time[0]), str_to_time(busy_time[1])))\n\n    # Sort busy intervals\n    busy_intervals.sort()\n\n    # Combine overlapping intervals\n    merged_intervals = []\n    for start, end in busy_intervals:\n        if not merged_intervals or merged_intervals[-1][1] < start:\n            merged_intervals.append((start, end))\n        else:\n            merged_intervals[-1] = (merged_intervals[-1][0], max(merged_intervals[-1][1], end))\n\n    # Check for available slots\n    last_end_time = work_start\n    for start, end in merged_intervals:\n        if last_end_time + duration_timedelta <= start:\n            return f\"{time_to_str(last_end_time)}:{time_to_str(last_end_time + duration_timedelta)}\"\n        last_end_time = end\n\n    # Check if there's time after last busy interval\n    if last_end_time + duration_timedelta <= work_end:\n        return f\"{time_to_str(last_end_time)}:{time_to_str(last_end_time + duration_timedelta)}\"\n    \n    return None\n\n# Example usage\nparticipants_schedules = [\n    [('11:00', '11:30'), ('13:30', '14:00'), ('14:30', '16:30')],  # Joyce\n    [],  # Christine\n    [('09:00', '11:00'), ('12:00', '12:30'), ('13:30', '15:00'), ('15:30', '16:00'), ('16:30', '17:00')]  # Alexander\n]\n\n# Meeting duration in minutes\nmeeting_duration = 30\n\n# Get the proposed meeting time\nproposed_time = find_meeting_time(participants_schedules, meeting_duration)\nprint(proposed_time)  # Example output\n```",
            "count": "calendar_scheduling_example_15"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, duration):\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n\n    # Create a list of all busy slots in minutes from start of the day\n    busy_times = []\n    for participant in participants:\n        for busy_time in participant['busy_slots']:\n            start_time = datetime.strptime(busy_time[0], \"%H:%M\")\n            end_time = datetime.strptime(busy_time[1], \"%H:%M\")\n            busy_times.append((start_time, end_time))\n\n    busy_times.sort()\n    \n    # Merge overlapping busy slots\n    merged_busy_times = []\n    for start, end in busy_times:\n        if not merged_busy_times or merged_busy_times[-1][1] < start:\n            merged_busy_times.append((start, end))\n        else:\n            merged_busy_times[-1] = (merged_busy_times[-1][0], max(merged_busy_times[-1][1], end))\n    \n    # Finding the first available time slot\n    last_end_time = work_start\n    for start, end in merged_busy_times:\n        if last_end_time + timedelta(minutes=duration) <= start:\n            return f\"{last_end_time.strftime('%H:%M')}:{(last_end_time + timedelta(minutes=duration)).strftime('%H:%M')}\"\n        last_end_time = end\n    \n    # Check if there's time after the last busy slot until work ends\n    if last_end_time + timedelta(minutes=duration) <= work_end:\n        return f\"{last_end_time.strftime('%H:%M')}:{(last_end_time + timedelta(minutes=duration)).strftime('%H:%M')}\"\n    \n    return None\n\n# Example participants with their busy times\nparticipants = [\n    {'name': 'Scott', 'busy_slots': [('09:30', '10:30'), ('13:30', '14:00'), ('14:30', '15:00'), ('15:30', '16:00'), ('16:30', '17:00')]},\n    {'name': 'Gabriel', 'busy_slots': []},\n    {'name': 'Christine', 'busy_slots': [('09:00', '10:00'), ('10:30', '12:30'), ('13:00', '17:00')]}\n]\n\n# Duration of meeting in minutes\nduration = 30\n\n# Find and print the proposed time\nproposed_time = find_meeting_time(participants, duration)\nprint(proposed_time) # Output format will be like 'HH:MM:HH:MM'\n```",
            "count": "calendar_scheduling_example_16"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants_schedules, duration, start_time, end_time):\n    # Create a timeline of the day\n    current_time = start_time\n    while current_time + duration <= end_time:\n        # Check if all participants are available at the current time\n        if all(not is_busy(schedule, current_time, duration) for schedule in participants_schedules):\n            return current_time\n        current_time += timedelta(minutes=30)  # Increment check by 30 mins\n        \n    return None\n\ndef is_busy(schedule, start_time, duration):\n    end_time = start_time + duration\n    for busy_start, busy_end in schedule:\n        if (start_time < busy_end and end_time > busy_start):\n            return True\n    return False\n\n# Participant schedules\nroger_schedule = []\nkaren_schedule = [(10, 0, 10, 30), (11, 30, 12, 0), (12, 30, 13, 0), (14, 0, 15, 0), (15, 30, 16, 0)]\ndorothy_schedule = [(9, 0, 10, 0), (10, 30, 11, 0), (11, 30, 12, 0), (12, 30, 13, 0), (14, 0, 15, 30), (16, 0, 17, 0)]\n\n# Convert the schedule tuples into datetime objects\nparticipants_schedules = []\nfor schedule in [roger_schedule, karen_schedule, dorothy_schedule]:\n    busy_times = [(datetime(2023, 10, 2, start_hour, start_minute), \n                   datetime(2023, 10, 2, end_hour, end_minute)) \n                  for start_hour, start_minute, end_hour, end_minute in schedule]\n    participants_schedules.append(busy_times)\n\n# Set meeting parameters\nmeeting_duration = timedelta(minutes=30)\nwork_start_time = datetime(2023, 10, 2, 9, 0)\nwork_end_time = datetime(2023, 10, 2, 17, 0)\n\n# Find proposed meeting time\nmeeting_time = find_meeting_time(participants_schedules, meeting_duration, work_start_time, work_end_time)\n\nif meeting_time:\n    print(f\"{meeting_time.strftime('%H:%M')} - {(meeting_time + meeting_duration).strftime('%H:%M')}\")\nelse:\n    print(\"No available time found.\")\n```",
            "count": "calendar_scheduling_example_17"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:00}",
            "type_error": "TypeError",
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef available_slot(participants, duration):\n    # Assume work hours are from 9:00 to 17:00\n    start_of_day = datetime.strptime('09:00', '%H:%M')\n    end_of_day = datetime.strptime('17:00', '%H:%M')\n    \n    # Create a timeline representing free/busy slots\n    time_slots = []\n    current_time = start_of_day\n    \n    while current_time < end_of_day:\n        busy_until = current_time + duration\n        \n        # Check if this time slot is free for all participants\n        if all(is_slot_available(current_time, busy_until, participant) for participant in participants):\n            return current_time.strftime('%H:%M') + '-' + busy_until.strftime('%H:%M')\n        \n        # Advance to the next time slot\n        current_time += timedelta(minutes=30)\n\ndef is_slot_available(start_time, end_time, busy_slots):\n    for (busy_start, busy_end) in busy_slots:\n        if not (end_time <= busy_start or start_time >= busy_end):\n            return False\n    return True\n\ndef main():\n    # Participants busy schedules\n    participants = [\n        [(\"10:00\", \"10:30\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"14:00\", \"15:00\"), (\"15:30\", \"16:00\")],  # Karen\n        [(\"9:00\", \"10:00\"), (\"10:30\", \"11:00\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"14:00\", \"15:30\"), (\"16:00\", \"17:00\")],  # Dorothy\n        []  # Roger\n    ]\n\n    # Meeting duration of 30 minutes\n    duration = timedelta(minutes=30)\n\n    proposed_time = available_slot(participants, duration)\n    print(proposed_time)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "count": "calendar_scheduling_example_18"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, meeting_duration):\n    time_format = \"%H:%M\"\n    work_start = datetime.strptime(\"09:00\", time_format)\n    work_end = datetime.strptime(\"17:00\", time_format)\n    \n    # Create blocks of busy times for each participant\n    busy_slots = []\n    \n    for schedules in participants.values():\n        for start, end in schedules:\n            busy_slots.append((datetime.strptime(start, time_format), datetime.strptime(end, time_format)))\n    \n    # Sort busy slots\n    busy_slots.sort()\n\n    # Merge overlapping busy slots\n    merged_slots = []\n    current_start, current_end = busy_slots[0]\n    \n    for start, end in busy_slots[1:]:\n        if start <= current_end:  # Overlapping or touching slots\n            current_end = max(current_end, end)\n        else:\n            merged_slots.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_slots.append((current_start, current_end))  # Add the last slot\n\n    # Find the first available time slot\n    current_time = work_start\n    \n    for start, end in merged_slots:\n        if current_time + meeting_duration <= start:\n            return (current_time.strftime(time_format), (current_time + meeting_duration).strftime(time_format))\n        current_time = max(current_time, end)  # Update current_time to the end of the busy slot\n    \n    # Check the time after the last busy slot\n    if current_time + meeting_duration <= work_end:\n        return (current_time.strftime(time_format), (current_time + meeting_duration).strftime(time_format))\n\n    return None\n\n# Example usage\nparticipants_schedule = {\n    \"Stephen\": [(\"10:00\", \"10:30\"), (\"13:00\", \"13:30\"), (\"14:30\", \"15:00\"), (\"16:00\", \"16:30\")],\n    \"Edward\": [(\"09:00\", \"09:30\"), (\"10:00\", \"10:30\"), (\"13:30\", \"14:30\"), (\"15:00\", \"16:00\")],\n    \"Angela\": [(\"09:00\", \"11:30\"), (\"12:30\", \"13:00\"), (\"13:30\", \"15:30\"), (\"16:00\", \"17:00\")]\n}\n\nmeeting_duration = timedelta(hours=1)\nproposed_time = find_meeting_time(participants_schedule, meeting_duration)\n\nif proposed_time:\n    print(f\"{proposed_time[0]}:{proposed_time[1]}\")\nelse:\n    print(\"No available time found.\")\n```",
            "count": "calendar_scheduling_example_19"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define the work hours\nwork_hours_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_hours_end = datetime.strptime(\"17:00\", \"%H:%M\")\n\n# Define the meetings for Ralph, Peter, and Daniel\nmeetings = {\n    \"Ralph\": [(datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\"))],\n    \"Peter\": [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n              (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n              (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))],\n    \"Daniel\": [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n               (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\")),\n               (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n}\n\n# Meeting duration\nmeeting_duration = timedelta(minutes=30)\n\n# Function to check if a time slot is free for all participants\ndef is_time_slot_free(start_time, end_time):\n    for person, busy_times in meetings.items():\n        for busy_start, busy_end in busy_times:\n            if (start_time < busy_end and end_time > busy_start):\n                return False\n    return True\n\n# Finding the earliest available time for the meeting\ncurrent_time = work_hours_start\nwhile current_time + meeting_duration <= work_hours_end:\n    if is_time_slot_free(current_time, current_time + meeting_duration):\n        proposed_time_start = current_time.strftime(\"%H:%M\")\n        proposed_time_end = (current_time + meeting_duration).strftime(\"%H:%M\")\n        print(f\"{proposed_time_start}:{proposed_time_end}\")\n        break\n    current_time += timedelta(minutes=30)  # Check the next half hour\n```",
            "count": "calendar_scheduling_example_20"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:10:00}",
            "type_error": "TypeError",
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, duration, work_hours):\n    work_start, work_end = work_hours\n    free_times = []\n\n    # Convert times to datetime objects\n    work_start = datetime.strptime(work_start, '%H:%M')\n    work_end = datetime.strptime(work_end, '%H:%M')\n    duration = timedelta(minutes=duration)\n    \n    # Generate busy time intervals from each participant's schedule\n    busy_times = []\n    for participant in participants:\n        busy_times.extend(participant['busy_times'])\n\n    # Calculate free times from work hours minus busy times\n    current_time = work_start\n    while current_time + duration <= work_end:\n        if all(not (current_time < busy_end and current_time + duration > busy_start) for busy_start, busy_end in busy_times):\n            free_times.append(current_time)\n        current_time += timedelta(minutes=1)\n\n    # Return the first available time for the meeting\n    if free_times:\n        proposed_time = free_times[0]\n        return f\"{proposed_time.strftime('%H:%M')} - {(proposed_time + duration).strftime('%H:%M')}\"\n    return None\n\n# Example usage:\nparticipants = [\n    {'name': 'Bobby', 'busy_times': []},\n    {'name': 'Scott', 'busy_times': [('11:30', '12:00'), ('15:30', '16:00')]},\n    {'name': 'Kimberly', 'busy_times': [('11:00', '12:00'), ('12:30', '13:00'), ('13:30', '14:00'), ('14:30', '15:00'), ('15:30', '17:00')]}\n]\n\n# Define work hours and meeting duration\nwork_hours = ('9:00', '17:00')\nmeeting_duration = 60  # 1 hour\n\n# Find suitable meeting time\nmeeting_time = find_meeting_time(participants, meeting_duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_21"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, meeting_duration):\n    work_start = datetime.strptime('09:00', '%H:%M')\n    work_end = datetime.strptime('17:00', '%H:%M')\n    \n    # Create a list of busy times for each participant\n    busy_times = []\n    for participant in participants:\n        for time in participant['busy_times']:\n            busy_start = datetime.strptime(time[0], '%H:%M')\n            busy_end = datetime.strptime(time[1], '%H:%M')\n            busy_times.append((busy_start, busy_end))\n\n    # Sort busy times\n    busy_times.sort()\n\n    # Check available time slots\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        # Check if current_time is not busy\n        is_busy = False\n        for busy_start, busy_end in busy_times:\n            if current_time < busy_end and current_time + meeting_duration > busy_start:\n                is_busy = True\n                break\n        if not is_busy:\n            return f\"{current_time.strftime('%H:%M')} - {(current_time + meeting_duration).strftime('%H:%M')}\"\n        current_time += timedelta(minutes=1)\n    \n    return \"No available time found\"\n\n# Participants' schedules\nparticipants = [\n    {'name': 'Theresa', 'busy_times': [('09:00', '09:30'), ('12:30', '13:30'), ('14:00', '15:00'), ('16:30', '17:00')]},\n    {'name': 'Charles', 'busy_times': [('10:00', '10:30'), ('11:30', '12:30'), ('14:00', '15:30')]},\n    {'name': 'Betty', 'busy_times': [('09:00', '10:30'), ('12:00', '12:30'), ('13:00', '14:00'), ('15:00', '16:00')]}\n]\n\n# Meeting duration\nmeeting_duration = timedelta(hours=1)\n\n# Find the proposed time\nproposed_time = find_meeting_time(participants, meeting_duration)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_22"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(schedules, meeting_duration):\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    \n    # Create a list of free time blocks for each participant within working hours\n    free_times = []\n    for schedule in schedules:\n        busy_times = []\n        for start, end in schedule:\n            busy_times.append((datetime.strptime(start, \"%H:%M\"), datetime.strptime(end, \"%H:%M\")))\n        \n        busy_times.sort()  # Sort busy times\n        \n        # Find free blocks\n        free_blocks = []\n        current_time = work_start\n        \n        for busy_start, busy_end in busy_times:\n            if current_time < busy_start:\n                free_blocks.append((current_time, busy_start))\n            current_time = max(current_time, busy_end)\n        \n        if current_time < work_end:\n            free_blocks.append((current_time, work_end))\n        \n        free_times.append(free_blocks)\n    \n    # Find a common free slot across all participant's free times\n    for start, end in free_times[0]:\n        available = True\n        possible_end = start + timedelta(minutes=meeting_duration)\n        \n        for blocks in free_times[1:]:\n            # Check if the slot (start, possible_end) fits in the next participant's free blocks\n            if not any(block_start <= start < block_end and block_start < possible_end <= block_end for block_start, block_end in blocks):\n                available = False\n                break\n        \n        if available and start + timedelta(minutes=meeting_duration) <= end:\n            return f\"{start.strftime('%H:%M')} - {possible_end.strftime('%H:%M')}\"\n    \n    return \"No available time\"\n\n# Example schedules\nschedules = [\n    [(\"09:30\", \"10:00\"), (\"11:00\", \"11:30\"), (\"14:30\", \"15:00\"), (\"16:30\", \"17:00\")],  # Mason\n    [(\"09:00\", \"17:00\")],  # Bruce\n    [(\"09:30\", \"10:30\"), (\"11:30\", \"12:30\"), (\"15:00\", \"17:00\")]  # Christopher\n]\n\n# Meeting duration in minutes\nmeeting_duration = 30\n\n# Find and print the proposed meeting time\nproposed_time = find_meeting_time(schedules, meeting_duration)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_23"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, meeting_duration, preferences):\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    \n    # Create a list to hold the busy times\n    busy_times = []\n    \n    # Populate busy_times based on participants' schedules\n    for participant in participants:\n        busy_times.extend(participant['busy_times'])\n\n    # Flatten the busy times and convert to datetime objects\n    busy_times = sorted([datetime.strptime(time, \"%H:%M\") for time in busy_times])\n    \n    # Time slots to check, starting from work_start to work_end\n    current_time = work_start\n    \n    while current_time + timedelta(minutes=meeting_duration) <= work_end:\n        # Check if the current time slot is free\n        end_time = current_time + timedelta(minutes=meeting_duration)\n        is_free = True\n        \n        for busy in busy_times:\n            busy_end = busy + timedelta(minutes=30)  # Considering 30 minutes as busy time for participants\n            \n            if (current_time < busy_end and end_time > busy):\n                is_free = False\n                break\n                \n        if is_free:\n            # Check against preferences\n            if 'after' in preferences:\n                if current_time < preferences['after']:\n                    current_time = preferences['after']\n                    continue\n            # Return the found time as a string in HH:MM:HH:MM format\n            return f\"{current_time.strftime('%H:%M')}:{end_time.strftime('%H:%M')}\"\n        \n        # Increment time by 30 minutes\n        current_time += timedelta(minutes=30)\n    \n    return None\n\n# Example input\nparticipants = [\n    {'name': 'Benjamin', 'busy_times': []},\n    {'name': 'Hannah', 'busy_times': []},\n    {'name': 'Brenda', 'busy_times': ['09:30', '11:30', '14:00']}\n]\n\nmeeting_duration = 30  # in minutes\npreferences = {'after': datetime.strptime(\"09:30\", \"%H:%M\")}\n\n# Find the time\nprint(find_meeting_time(participants, meeting_duration, preferences))\n```",
            "count": "calendar_scheduling_example_24"
        },
        {
            "final_program_time": "{13:30:14:30}",
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, meeting_duration):\n    # Convert the meeting duration from minutes to timedelta\n    meeting_duration = timedelta(minutes=meeting_duration)\n    \n    # Initialize working hours\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    \n    # Create a list of all busy times\n    busy_times = []\n    for participant in participants:\n        busy_times.extend(participant['busy_times'])\n    \n    # Sort the busy times\n    busy_times.sort()\n    \n    # Merge overlapping busy times\n    merged_busy_times = []\n    for start, end in busy_times:\n        if not merged_busy_times or merged_busy_times[-1][1] < start:\n            merged_busy_times.append((start, end))\n        else:\n            merged_busy_times[-1] = (merged_busy_times[-1][0], max(merged_busy_times[-1][1], end))\n\n    # Check available slots between busy times\n    available_start = work_start\n    for start, end in merged_busy_times:\n        if available_start + meeting_duration <= start:\n            return f\"{available_start.strftime('%H:%M')}:{(available_start + meeting_duration).strftime('%H:%M')}\"\n        available_start = max(available_start, end)\n    \n    # Check after the last busy time until work end\n    if available_start + meeting_duration <= work_end:\n        return f\"{available_start.strftime('%H:%M')}:{(available_start + meeting_duration).strftime('%H:%M')}\"\n    \n    return None\n\n# Example Call\nparticipants = [\n    {'name': 'Anthony', 'busy_times': [(datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n                                        (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n                                        (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))]},\n    {'name': 'Pamela', 'busy_times': [(datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n                                       (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]},\n    {'name': 'Zachary', 'busy_times': [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n                                        (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n                                        (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n                                        (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n                                        (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]},\n]\n\nmeeting_duration = 60  # in minutes\nprint(find_meeting_time(participants, meeting_duration))\n```",
            "count": "calendar_scheduling_example_25"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:30:16:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef schedule_meeting(participants, duration):\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    duration = timedelta(minutes=duration)\n\n    # Create a list of busy intervals for all participants\n    busy_intervals = []\n    for participant in participants:\n        for busy_time in participant['busy_times']:\n            start_time = datetime.strptime(busy_time[0], \"%H:%M\")\n            end_time = datetime.strptime(busy_time[1], \"%H:%M\")\n            busy_intervals.append((start_time, end_time))\n    \n    # Sort the busy intervals\n    busy_intervals.sort()\n\n    # Merge overlapping busy intervals\n    merged_intervals = []\n    for start, end in busy_intervals:\n        if not merged_intervals or merged_intervals[-1][1] < start:\n            merged_intervals.append((start, end))\n        else:\n            merged_intervals[-1] = (merged_intervals[-1][0], max(merged_intervals[-1][1], end))\n    \n    # Find available time slots\n    available_slots = []\n    current_time = work_start\n\n    for start, end in merged_intervals:\n        if current_time + duration <= start:\n            available_slots.append((current_time, start))\n        current_time = max(current_time, end)\n\n    if current_time + duration <= work_end:\n        available_slots.append((current_time, work_end))\n\n    # Return the first available slot\n    if available_slots:\n        proposed_start = available_slots[0][0]\n        proposed_end = proposed_start + duration\n        return proposed_start.strftime(\"%H:%M\") + \" - \" + proposed_end.strftime(\"%H:%M\")\n    return None\n\n# Defining participants' busy schedules\nparticipants = [\n    {\"name\": \"Katherine\", \"busy_times\": []},\n    {\"name\": \"Nicole\", \"busy_times\": []},\n    {\"name\": \"Kevin\", \"busy_times\": [(\"09:00\", \"10:00\"), (\"10:30\", \"11:30\"), (\"12:00\", \"15:30\"), (\"16:30\", \"17:00\")]}\n]\n\n# Desired meeting duration (in minutes)\nduration = 60\n\n# Calculate proposed time\nproposed_time = schedule_meeting(participants, duration)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_26"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, duration_minutes, start_hour=9, end_hour=17):\n    # Create full work hours for participants\n    work_hours = [(datetime.strptime(f\"{hour}:00\", \"%H:%M\"), datetime.strptime(f\"{hour + 1}:00\", \"%H:%M\")) for hour in range(start_hour, end_hour)]\n    \n    # Create a list to save busy times for each participant\n    busy_times = []\n    \n    # Populate busy times based on each participant's schedule\n    for schedule in participants.values():\n        busy_times.extend(schedule)\n    \n    # Calculate available time slots\n    available_slots = []\n    \n    for start, end in work_hours:\n        current_time = start\n        while current_time + timedelta(minutes=duration_minutes) <= end:\n            free = True\n            for busy_start, busy_end in busy_times:\n                if (current_time < busy_end and current_time + timedelta(minutes=duration_minutes) > busy_start):\n                    free = False\n                    break\n            if free:\n                available_slots.append(current_time)\n            current_time += timedelta(minutes=30)  # increment in 30-minute blocks to find the first available time\n    \n    # Return the earliest time in the required format\n    if available_slots:\n        first_slot = available_slots[0]\n        return f\"{first_slot.strftime('%H:%M')}:{(first_slot + timedelta(minutes=duration_minutes)).strftime('%H:%M')}\"\n    else:\n        return \"No available slot\"\n\nparticipants = {\n    'Jesse': [(datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n              (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\"))],\n    'Kathryn': [],\n    'Megan': [(datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n              (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n              (datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\")),\n              (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))]\n}\n\n# Meeting for half an hour\nmeeting_duration = 30\nresult = find_meeting_time(participants, meeting_duration)\nprint(result)\n```",
            "count": "calendar_scheduling_example_27"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(schedules, duration=30):\n    work_start = datetime.strptime('09:00', '%H:%M')\n    work_end = datetime.strptime('17:00', '%H:%M')\n    meeting_duration = timedelta(minutes=duration)\n\n    # Create a list of unavailable slots\n    unavailable_slots = []\n    for schedule in schedules:\n        for busy_start, busy_end in schedule:\n            unavailable_slots.append((busy_start, busy_end))\n    \n    # Sort unavailable slots by start time\n    unavailable_slots.sort()\n\n    # Merge overlapping slots\n    merged_slots = []\n    for start, end in unavailable_slots:\n        if not merged_slots or merged_slots[-1][1] < start:\n            merged_slots.append((start, end))\n        else:\n            merged_slots[-1] = (merged_slots[-1][0], max(merged_slots[-1][1], end))\n\n    # Check for available time slots\n    last_end = work_start\n    for start, end in merged_slots:\n        if last_end + meeting_duration <= start:\n            return last_end.strftime('%H:%M') + \":\" + (last_end + meeting_duration).strftime('%H:%M')\n        last_end = end\n\n    # Check after the last unavailable slot until work end\n    if last_end + meeting_duration <= work_end:\n        return last_end.strftime('%H:%M') + \":\" + (last_end + meeting_duration).strftime('%H:%M')\n\n    return None\n\n# Example usage\nschedules = [\n    [(datetime.strptime('09:00', '%H:%M'), datetime.strptime('11:00', '%H:%M'))], # Brittany\n    [],  # Emily\n    [(datetime.strptime('09:00', '%H:%M'), datetime.strptime('11:00', '%H:%M')), \n     (datetime.strptime('11:30', '%H:%M'), datetime.strptime('14:30', '%H:%M')), \n     (datetime.strptime('15:00', '%H:%M'), datetime.strptime('17:00', '%H:%M'))]  # Doris\n]\n\nproposed_time = find_meeting_time(schedules)\nprint(proposed_time)  # Example output could be \"11:00:11:30\"\n```",
            "count": "calendar_scheduling_example_28"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, meeting_duration):\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Marking busy times in a workday timeline\n    timeline = [0] * (work_end - work_start)  # 0 means free, 1 means busy\n\n    for schedule in participants_schedules:\n        for start, end in schedule:\n            start_index = max(work_start, start) - work_start\n            end_index = max(work_start, end) - work_start\n            for i in range(start_index, end_index):\n                timeline[i] = 1  # Mark as busy\n\n    # Finding a suitable time slot\n    current_free_length = 0\n    for start_time in range(len(timeline)):\n        if timeline[start_time] == 0:\n            current_free_length += 1\n            if current_free_length * 30 >= meeting_duration:  # Check if we have enough space for the meeting\n                meeting_start = start_time - current_free_length + 1\n                proposed_time = f\"{(meeting_start + work_start) // 60:02}:{(meeting_start + work_start) % 60:02}:{(meeting_start + work_start + meeting_duration) // 60:02}:{(meeting_start + work_start + meeting_duration) % 60:02}\"\n                return proposed_time\n        else:\n            current_free_length = 0\n\n# Example usage\nparticipants_schedules = [\n    [(10 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60), (14 * 60, 15 * 60), (15 * 60 + 30, 16 * 60)],  # Karen\n    [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60), (14 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)]  # Dorothy\n]\n\nmeeting_duration = 30  # 30 minutes\nprint(find_meeting_time(participants_schedules, meeting_duration))\n```",
            "count": "calendar_scheduling_example_29"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(schedules, meeting_duration):\n    work_start = 9 * 60  # 9:00 AM in minutes\n    work_end = 17 * 60    # 5:00 PM in minutes\n\n    # Convert meeting duration to minutes\n    meeting_duration = meeting_duration * 60\n\n    # Create busy slots for all participants\n    busy_slots = []\n    for schedule in schedules:\n        for time_range in schedule:\n            start, end = time_range\n            busy_slots.append((start, end))\n\n    # Sort all busy slots\n    busy_slots.sort()\n\n    # Find available slots by checking gaps between busy slots\n    available_slots = []\n    previous_end = work_start\n\n    for start, end in busy_slots:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check the end of the day\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n\n    # Find a suitable time slot for the meeting\n    for start, end in available_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = start + meeting_duration\n            return f\"{meeting_start // 60:02}:{meeting_start % 60:02}:{meeting_end // 60:02}:{meeting_end % 60:02}\"\n\n# Example input for the meeting\nschedules = [\n    [(9 * 60 + 30, 10 * 60)],  # Example schedule for Jeffrey\n    [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (14 * 60 + 30, 15 * 60), (16 * 60, 16 * 60 + 30)],  # Virginia\n    [(9 * 60, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (13 * 60, 15 * 60), (16 * 60, 17 * 60)]  # Melissa\n]\n\n# Desired meeting length in hours\nmeeting_duration = 0.5  # Half hour\n\n# Calculate the proposed time\nproposed_time = find_meeting_time(schedules, meeting_duration)\nprint(proposed_time)  # This will print the proposed meeting time in the format HH:MM:HH:MM\n```",
            "count": "calendar_scheduling_example_30"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants_schedules, meeting_duration):\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    \n    # Generate a list of all busy times for all participants\n    busy_times = []\n    for participant in participants_schedules:\n        for busy_period in participant:\n            start_time = datetime.strptime(busy_period[0], \"%H:%M\")\n            end_time = datetime.strptime(busy_period[1], \"%H:%M\")\n            busy_times.append((start_time, end_time))\n\n    # Sort busy times\n    busy_times.sort(key=lambda x: x[0])\n    \n    # Find available slots\n    available_start = work_start\n    for start, end in busy_times:\n        if available_start + meeting_duration <= start:\n            return available_start.strftime(\"%H:%M\") + \":\" + (available_start + meeting_duration).strftime(\"%H:%M\")\n        available_start = max(available_start, end)\n    \n    # Final check after the last busy period\n    if available_start + meeting_duration <= work_end:\n        return available_start.strftime(\"%H:%M\") + \":\" + (available_start + meeting_duration).strftime(\"%H:%M\")\n\n# Example Execution\nparticipants = [\n    [(\"13:30\", \"14:00\"), (\"15:00\", \"15:30\")],  # Richard's schedule\n    [(\"09:00\", \"09:30\"), (\"13:00\", \"13:30\")],  # Martha's schedule\n    [(\"09:00\", \"11:00\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"14:00\", \"16:00\")]  # Kimberly's schedule\n]\n\nmeeting_duration = timedelta(minutes=30)\n\n# Finding meeting time\nproposed_time = find_meeting_time(participants, meeting_duration)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_31"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(schedule, duration):\n    # Convert string times to datetime objects\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    \n    # Create a list of busy times\n    busy_times = []\n    for person, times in schedule.items():\n        for time in times:\n            start_time, end_time = map(lambda x: datetime.strptime(x, \"%H:%M\"), time)\n            busy_times.append((start_time, end_time))\n    \n    # Sort busy times\n    busy_times.sort()\n\n    # Find the first available slot for the meeting\n    current_time = work_start\n    while current_time + duration <= work_end:\n        # Check if current_time is free\n        is_free = True\n        for start, end in busy_times:\n            if current_time < end and current_time + duration > start:\n                is_free = False\n                current_time = end  # Move current_time to the end of the busy slot\n                break\n        if is_free:\n            return current_time.strftime(\"%H:%M\") + \":\" + (current_time + duration).strftime(\"%H:%M\")\n    \n    return None\n\n# Define participant schedules (start: end)\nparticipant_schedules = {\n    \"Emily\": [(\"10:00\", \"10:30\"), (\"11:30\", \"12:30\"), (\"14:00\", \"15:00\"), (\"16:00\", \"16:30\")],\n    \"Melissa\": [(\"09:30\", \"10:00\"), (\"14:30\", \"15:00\")],\n    \"Frank\": [(\"10:00\", \"10:30\"), (\"11:00\", \"11:30\"), (\"12:30\", \"13:00\"), (\"13:30\", \"14:30\"),\n              (\"15:00\", \"16:00\"), (\"16:30\", \"17:00\")]\n}\n\n# Duration of the meeting\nmeeting_duration = timedelta(minutes=30)\n\n# Find the meeting time\nproposed_time = find_meeting_time(participant_schedules, meeting_duration)\nprint(proposed_time)  # This will output the proposed time\n```",
            "count": "calendar_scheduling_example_32"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(schedule, meeting_duration):\n    # Define the working hours\n    start_of_day = datetime.strptime(\"09:00\", \"%H:%M\")\n    end_of_day = datetime.strptime(\"17:00\", \"%H:%M\")\n    \n    # Create a list of free time slots\n    free_slots = []\n    last_end = start_of_day\n\n    for start, end in schedule:\n        # If there is a gap between last end and the next start\n        if last_end < start:\n            free_slots.append((last_end, start))\n        last_end = end\n\n    # Consider the time after the last scheduled meeting\n    if last_end < end_of_day:\n        free_slots.append((last_end, end_of_day))\n\n    # Check for available time slots that fit the meeting duration\n    for start, end in free_slots:\n        if (end - start) >= timedelta(minutes=meeting_duration):\n            proposed_start = start\n            proposed_end = start + timedelta(minutes=meeting_duration)\n            return proposed_start.strftime(\"%H:%M\") + \":\" + proposed_end.strftime(\"%H:%M\")\n\n    return None\n\n# Define the schedules\nmason_schedule = [(datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n                  (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n                  (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n                  (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n\nbobby_schedule = [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n                  (datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n                  (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n                  (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\"))]\n\nrandy_schedule = [(datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n                  (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n                  (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n                  (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n                  (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\")),\n                  (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))]\n\n# Combine schedules into one list\ncombined_schedule = sorted(mason_schedule + bobby_schedule + randy_schedule)\n\n# Determine the meeting duration\nmeeting_duration = 30  # minutes\n\n# Find the meeting time\nproposed_time = find_meeting_time(combined_schedule, meeting_duration)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_33"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef schedule_meeting(participants, duration, work_hours):\n    # Parse work hours\n    work_start, work_end = map(lambda x: datetime.strptime(x, \"%H:%M\"), work_hours)\n    \n    # Create a list of busy intervals\n    busy_intervals = []\n    for participant in participants:\n        for busy_slot in participant['busy']:\n            busy_intervals.append((datetime.strptime(busy_slot[0], \"%H:%M\"), \n                                    datetime.strptime(busy_slot[1], \"%H:%M\")))\n\n    # Sort and merge busy intervals\n    busy_intervals.sort()\n    \n    merged_intervals = []\n    for start, end in busy_intervals:\n        if not merged_intervals or merged_intervals[-1][1] < start:\n            merged_intervals.append((start, end))\n        else:\n            merged_intervals[-1] = (merged_intervals[-1][0], max(merged_intervals[-1][1], end))\n    \n    # Find available slots\n    available_slots = []\n    last_end = work_start\n    \n    for start, end in merged_intervals:\n        if last_end + timedelta(minutes=duration) <= start:\n            available_slots.append((last_end, start))\n        last_end = end\n    \n    if last_end < work_end:\n        available_slots.append((last_end, work_end))\n    \n    # Return the earliest available slot that satisfies the duration\n    for start, end in available_slots:\n        if (end - start) >= timedelta(minutes=duration):\n            meeting_start = start\n            meeting_end = start + timedelta(minutes=duration)\n            return f\"{meeting_start.strftime('%H:%M')} - {meeting_end.strftime('%H:%M')}\"\n    \n    return \"No available time found\"\n\n# Example usage\nparticipants = [\n    {'name': 'Willie', 'busy': []},\n    {'name': 'Richard', 'busy': [('10:00', '10:30'), ('11:00', '12:00'), ('13:00', '14:00'), ('16:00', '16:30')]},\n    {'name': 'Noah', 'busy': [('10:00', '10:30'), ('11:30', '13:00'), ('13:30', '14:00'), ('14:30', '17:00')]}\n]\n\nduration = 60  # in minutes\nwork_hours = [\"09:00\", \"17:00\"]\n\n# Call the function and print the result\nresult = schedule_meeting(participants, duration, work_hours)\nprint(result)  # Output would be in the desired format\n```",
            "count": "calendar_scheduling_example_34"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, meeting_duration):\n    working_hours_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    working_hours_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    meeting_duration = timedelta(minutes=meeting_duration)\n\n    # Create a fully open schedule\n    schedule = {p: [] for p in participants}\n    \n    # Fill individual schedules based on their busy times\n    for participant, busy_times in participants.items():\n        for busy_start, busy_end in busy_times:\n            start_time = max(busy_start, working_hours_start)\n            end_time = min(busy_end, working_hours_end)\n            if start_time < end_time:\n                schedule[participant].append((start_time, end_time))\n\n    # Determine free slots\n    free_slots = []\n    \n    # Check all times within working hours\n    current_time = working_hours_start\n    while current_time + meeting_duration <= working_hours_end:\n        if all(any(not (current_time < busy_end and busy_start < current_time + meeting_duration)\n                   for busy_start, busy_end in schedule[p]) for p in participants):\n            free_slots.append(current_time)\n        current_time += timedelta(minutes=1)\n\n    # Return the earliest meeting time found as HH:MM:HH:MM\n    if free_slots:\n        first_free_slot = free_slots[0]\n        return f\"{first_free_slot.strftime('%H:%M')}:{(first_free_slot + meeting_duration).strftime('%H:%M')}\"\n    else:\n        return None\n\n# Example usage with task\nparticipants = {\n    \"Mason\": [(datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n              (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n              (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n              (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))],\n    \"Bruce\": [],\n    \"Christopher\": [(datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n                     (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n                     (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n}\n\nproposed_time = find_meeting_time(participants, 30)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_35"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants_availability, meeting_duration):\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    \n    # Create a list of available time slots\n    available_slots = []\n    \n    # Analyze each participant's availability\n    for time_range in participants_availability:\n        start, end = time_range\n        available_slots.append((max(work_start, start), min(work_end, end)))\n\n    # Find overlapping time slots\n    latest_start = max(slot[0] for slot in available_slots)\n    earliest_end = min(slot[1] for slot in available_slots)\n\n    # Check for available time for the duration of the meeting\n    current_time = latest_start\n    while current_time + meeting_duration <= earliest_end:\n        # If an overlapping time slot is found, return it\n        return f\"{current_time.strftime('%H:%M')}:{(current_time + meeting_duration).strftime('%H:%M')}\"\n        current_time += timedelta(minutes=1)\n\n    return \"No available time found.\"\n\n# Example schedules for testing\nparticipants_availability = [\n    (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n    (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\")),\n    (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n]\n\nmeeting_duration = timedelta(minutes=30)  # Meeting duration\n\n# Find proposed time for meeting\nproposed_time = find_meeting_time(participants_availability, meeting_duration)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_36"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants_availability, meeting_duration_minutes):\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    meeting_duration = timedelta(minutes=meeting_duration_minutes)\n\n    # Create a list of available time slots\n    available_slots = []\n    current_time = work_start\n\n    while current_time + meeting_duration <= work_end:\n        # Check if the current time slot is available for all participants\n        slot_start = current_time\n        slot_end = current_time + meeting_duration\n        if all(not (slot_start < busy_start and slot_end > busy_end)\n               for busy_times in participants_availability\n               for busy_start, busy_end in busy_times):\n            available_slots.append((slot_start, slot_end))\n        current_time += timedelta(minutes=30)  # Check every 30 minutes\n\n    # Return the first available time slot in the required format\n    if available_slots:\n        start_time, end_time = available_slots[0]\n        return f\"{start_time.strftime('%H:%M')}:{end_time.strftime('%H:%M')}\"\n    else:\n        return None\n\n# Define availability for each participant (busy times)\nparticipants_availability = [\n    [(datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n     (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n     (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))], # Gregory\n     \n    [], # Teresa (wide open)\n    \n    [(datetime.strptime(\"9:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n     (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\")),\n     (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))] # Carol\n]\n\n# Call the function to find the proposed meeting time\nproposed_time = find_meeting_time(participants_availability, 30)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_37"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participant_schedules, meeting_duration_minutes, work_hours):\n    work_start, work_end = [datetime.strptime(time, '%H:%M') for time in work_hours]\n    meeting_duration = timedelta(minutes=meeting_duration_minutes)\n\n    # Collect all busy times\n    busy_times = []\n    for schedule in participant_schedules:\n        for busy_slot in schedule:\n            busy_start, busy_end = [datetime.strptime(time, '%H:%M') for time in busy_slot]\n            busy_times.append((busy_start, busy_end))\n\n    # Merge overlapping busy times\n    busy_times.sort()\n    merged_busy_times = []\n    current_start, current_end = busy_times[0]\n    \n    for start, end in busy_times[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged_busy_times.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_busy_times.append((current_start, current_end))\n\n    # Find available slots\n    available_slots = []\n    current_time = work_start\n\n    for busy_start, busy_end in merged_busy_times:\n        if current_time + meeting_duration <= busy_start:\n            available_slots.append((current_time, busy_start))\n        current_time = max(current_time, busy_end)\n    \n    if current_time + meeting_duration <= work_end:\n        available_slots.append((current_time, work_end))\n\n    if available_slots:\n        proposed_start = available_slots[0][0]\n        proposed_end = proposed_start + meeting_duration\n        return f\"{proposed_start.strftime('%H:%M')} - {proposed_end.strftime('%H:%M')}\"\n    return None\n\n# Example usage\nparticipant_schedules = [\n    [(\"9:30\", \"10:00\"), (\"11:00\", \"11:30\"), (\"14:30\", \"15:00\"), (\"16:30\", \"17:00\")],\n    [(\"9:30\", \"10:30\"), (\"11:30\", \"12:30\"), (\"15:00\", \"17:00\")],\n    [(\"9:00\", \"9:30\"), (\"10:00\", \"10:30\"), (\"11:30\", \"12:30\"), (\"15:00\", \"17:00\")]\n]\n\nmeeting_duration_minutes = 30\nwork_hours = (\"09:00\", \"17:00\")\n\nprint(find_meeting_time(participant_schedules, meeting_duration_minutes, work_hours))\n```",
            "count": "calendar_scheduling_example_38"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:00:14:30}",
            "type_error": "TypeError",
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, meeting_duration, work_hours):\n    work_start, work_end = work_hours\n    available_times = []\n    \n    # Create a list of free time slots for each participant\n    for schedule in participants:\n        free_times = []\n        last_end_time = work_start\n        \n        for start, end in sorted(schedule):\n            if start > last_end_time:\n                free_times.append((last_end_time, start))\n            last_end_time = max(last_end_time, end)\n        \n        if last_end_time < work_end:\n            free_times.append((last_end_time, work_end))\n        \n        available_times.append(free_times)\n    \n    # Merge the available times to find common slots\n    common_times = available_times[0]\n    \n    for free_times in available_times[1:]:\n        new_common_times = []\n        for start1, end1 in common_times:\n            for start2, end2 in free_times:\n                start = max(start1, start2)\n                end = min(end1, end2)\n                if start < end:\n                    new_common_times.append((start, end))\n        common_times = new_common_times\n    \n    # Find a time slot that fits the meeting duration\n    for start, end in common_times:\n        if (end - start) >= meeting_duration:\n            proposed_time_start = start\n            proposed_time_end = proposed_time_start + meeting_duration\n            return proposed_time_start.strftime(\"%H:%M\") + \" - \" + proposed_time_end.strftime(\"%H:%M\")\n    \n    return None\n\n# Example usage:\nparticipants = [\n    [],  # Roger's free all day\n    [(10, 10.5), (11.5, 12), (12.5, 13), (14, 15), (15.5, 16)],  # Karen's schedule\n    [(9, 10), (10.5, 11), (11.5, 12), (12.5, 13), (14, 15.5), (16, 17)]  # Dorothy's schedule\n]\n\nwork_hours = (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))\nmeeting_duration = timedelta(minutes=30)\n\nprint(find_meeting_time(participants, meeting_duration, work_hours))\n```",
            "count": "calendar_scheduling_example_39"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef convert_to_minutes(time_str):\n    \"\"\"Convert time string 'HH:MM' to minutes since midnight.\"\"\"\n    time = datetime.strptime(time_str, '%H:%M')\n    return time.hour * 60 + time.minute\n\ndef convert_to_time_str(minutes):\n    \"\"\"Convert minutes since midnight back to 'HH:MM' format.\"\"\"\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02}:{mins:02}\"\n\ndef find_meeting_time(participants, duration):\n    work_start = convert_to_minutes(\"09:00\")\n    work_end = convert_to_minutes(\"17:00\")\n    \n    busy_times = []\n    \n    # Collect all busy time slots from all participants\n    for schedule in participants:\n        for busy_slot in schedule:\n            start, end = map(convert_to_minutes, busy_slot)\n            busy_times.append((start, end))\n\n    # Mark all minutes that are busy\n    busy_minutes = [False] * (work_end - work_start)\n    for start, end in busy_times:\n        for i in range(max(start, work_start), min(end, work_end)):\n            busy_minutes[i - work_start] = True\n\n    # Find the first available slot for the meeting duration\n    meeting_start = None\n    count = 0\n    \n    for i in range(len(busy_minutes)):\n        if not busy_minutes[i]:\n            count += 1\n            if count == 1:\n                meeting_start = i\n            if count == duration:\n                return f\"{convert_to_time_str(meeting_start + work_start)}:{convert_to_time_str(meeting_start + duration + work_start)}\"\n        else:\n            count = 0\n            meeting_start = None\n            \n    return \"No available slot found\"\n\n# Example usage\nparticipants = [\n    [(\"10:00\", \"11:00\"), (\"11:30\", \"12:00\"), (\"16:00\", \"16:30\")],  # Jacob\n    [(\"9:30\", \"11:30\"), (\"13:00\", \"13:30\"), (\"15:00\", \"15:30\")],  # Gabriel\n    [(\"09:00\", \"09:30\"), (\"10:30\", \"11:00\"), (\"11:30\", \"12:00\"), (\"12:30\", \"14:00\"), (\"15:30\", \"16:30\")]  # Matthew\n]\n\nduration = 60  # one hour\nprint(find_meeting_time(participants, duration))\n```",
            "count": "calendar_scheduling_example_40"
        },
        {
            "final_program_time": "{9:00:9:00}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participant_schedules, meeting_duration, work_start, work_end):\n    # Convert time strings to minutes for easier comparison\n    def time_to_minutes(t):\n        hours, minutes = map(int, t.split(':'))\n        return hours * 60 + minutes\n\n    # Create a list to track free time slots in minutes\n    all_minutes = [1] * (time_to_minutes(work_end) - time_to_minutes(work_start))\n    \n    for schedule in participant_schedules:\n        for start, end in schedule:\n            start_min = time_to_minutes(start) - time_to_minutes(work_start)\n            end_min = time_to_minutes(end) - time_to_minutes(work_start)\n            for i in range(start_min, end_min):\n                all_minutes[i] = 0  # Mark this time as busy\n\n    # Find the first available slot for the meeting duration\n    duration_minutes = meeting_duration // 60 * 60  # Duration in minutes\n    for i in range(len(all_minutes) - duration_minutes + 1):\n        if sum(all_minutes[i:i + duration_minutes]) == duration_minutes:\n            # Found a free block\n            start_time = time_to_minutes(work_start) + i\n            start_hour = start_time // 60\n            start_minute = start_time % 60\n            end_time = start_time + duration_minutes\n            end_hour = end_time // 60\n            end_minute = end_time % 60\n            return f\"{start_hour:02}:{start_minute:02}:{end_hour:02}:{end_minute:02}\"\n\n# Example usage\nparticipant_schedules = [\n    [(\"10:00\", \"12:30\")],  # Alan's schedule\n    [(\"11:00\", \"12:30\"), (\"13:00\", \"13:30\"), (\"14:00\", \"15:00\")],  # Nancy's schedule\n    [(\"10:00\", \"12:00\"), (\"12:30\", \"13:00\"), (\"13:30\", \"16:00\")]  # Patricia's schedule\n]\n\nmeeting_duration = 30  # Half an hour\nwork_start = \"09:00\"\nwork_end = \"17:00\"\n\nprint(find_meeting_time(participant_schedules, meeting_duration, work_start, work_end))\n```",
            "count": "calendar_scheduling_example_41"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(schedules, duration_minutes=30, work_start=\"09:00\", work_end=\"17:00\"):\n    work_start_time = datetime.strptime(work_start, \"%H:%M\")\n    work_end_time = datetime.strptime(work_end, \"%H:%M\")\n    duration = timedelta(minutes=duration_minutes)\n\n    # Extract all busy times into a list of tuples (start, end)\n    busy_times = []\n    for busy_schedule in schedules:\n        for busy_start, busy_end in busy_schedule:\n            busy_times.append((datetime.strptime(busy_start, \"%H:%M\"), datetime.strptime(busy_end, \"%H:%M\")))\n\n    # Sort busy times\n    busy_times.sort()\n\n    # Initialize free slots\n    free_slots = []\n    last_end_time = work_start_time\n\n    for busy_start, busy_end in busy_times:\n        if last_end_time < busy_start:\n            free_slots.append((last_end_time, busy_start))\n        last_end_time = max(last_end_time, busy_end)\n\n    if last_end_time < work_end_time:\n        free_slots.append((last_end_time, work_end_time))\n\n    # Find a suitable time that fits the duration\n    for free_start, free_end in free_slots:\n        if free_end - free_start >= duration:\n            proposed_start = free_start\n            proposed_end = proposed_start + duration\n            return proposed_start.strftime(\"%H:%M\") + \":\" + proposed_end.strftime(\"%H:%M\")\n\n    return None\n\n# Example usage:\nschedules = [\n    [(\"09:00\", \"09:30\"), (\"11:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:30\", \"14:00\"), (\"16:00\", \"17:00\")],  # Julie\n    [(\"09:00\", \"09:30\"), (\"13:00\", \"13:30\"), (\"15:00\", \"15:30\"), (\"16:00\", \"16:30\")],  # Sean\n    [(\"10:00\", \"10:30\"), (\"11:00\", \"13:00\"), (\"15:30\", \"17:00\")]  # Lori\n]\n\nproposed_time = find_meeting_time(schedules, duration_minutes=60)\nprint(f'Proposed time: {proposed_time}')\n```",
            "count": "calendar_scheduling_example_42"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, meeting_duration_minutes=30):\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    meeting_duration = timedelta(minutes=meeting_duration_minutes)\n\n    # Create a list of busy times\n    busy_times = []\n    for schedule in participants.values():\n        for busy_time in schedule:\n            busy_times.append(busy_time)\n\n    # Sort busy times\n    busy_times.sort()\n\n    # Find available time slots\n    available_start = work_start\n    for busy_start, busy_end in busy_times:\n        if available_start + meeting_duration <= busy_start:\n            return available_start.strftime(\"%H:%M\") + \"-\" + (available_start + meeting_duration).strftime(\"%H:%M\")\n        # Move the available start time if it is in a busy period\n        if available_start < busy_end:\n            available_start = busy_end\n\n    # Check at the end of the work day\n    if available_start + meeting_duration <= work_end:\n        return available_start.strftime(\"%H:%M\") + \"-\" + (available_start + meeting_duration).strftime(\"%H:%M\")\n\n    return None\n\n# Example input schedules\nparticipants = {\n    \"Albert\": [(\"09:30\", \"10:30\"), (\"12:00\", \"12:30\"), (\"14:00\", \"14:30\"), (\"15:00\", \"15:30\"), (\"16:30\", \"17:00\")],\n    \"Gregory\": [(\"11:00\", \"11:30\"), (\"12:30\", \"13:00\"), (\"13:30\", \"14:00\"), (\"15:30\", \"16:00\")],\n    \"Benjamin\": [(\"09:30\", \"10:00\"), (\"10:30\", \"11:00\"), (\"11:30\", \"13:30\"), (\"14:00\", \"15:00\"), (\"15:30\", \"16:00\"), (\"16:30\", \"17:00\")]\n}\n\n# Convert string times to datetime objects for processing\nfor participant in participants:\n    participants[participant] = [(datetime.strptime(start, \"%H:%M\"), datetime.strptime(end, \"%H:%M\")) for start, end in participants[participant]]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_43"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, duration=30):\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    \n    # Create a list of busy times\n    busy_times = []\n    for participant in participants:\n        busy_times.extend(participant['busy'])\n\n    # Sort and merge overlapping busy times\n    busy_times.sort()\n    merged_busy_times = []\n    for start, end in busy_times:\n        if not merged_busy_times or merged_busy_times[-1][1] < start:\n            merged_busy_times.append((start, end))\n        else:\n            merged_busy_times[-1] = (merged_busy_times[-1][0], max(merged_busy_times[-1][1], end))\n    \n    # Check available time slots\n    last_end = work_start\n    for start, end in merged_busy_times:\n        if last_end + timedelta(minutes=duration) <= start:\n            return (last_end.strftime(\"%H:%M\"), (last_end + timedelta(minutes=duration)).strftime(\"%H:%M\"))\n        last_end = end\n\n    if last_end + timedelta(minutes=duration) <= work_end:\n        return (last_end.strftime(\"%H:%M\"), (last_end + timedelta(minutes=duration)).strftime(\"%H:%M\"))\n\n    return None\n\n# Example participant schedules\nparticipants = [\n    {\"name\": \"Isabella\", \"busy\": []},\n    {\"name\": \"Ronald\", \"busy\": [(datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")), \n                                 (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\")),\n                                 (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]},\n    {\"name\": \"Amanda\", \"busy\": [(datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")), \n                                 (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n                                 (datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\")),\n                                 (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]},\n]\n\ntime_slot = find_meeting_time(participants)\nif time_slot:\n    print(f\"Here is the proposed time: {time_slot[0]} - {time_slot[1]}\")\nelse:\n    print(\"No available time found.\")\n```",
            "count": "calendar_scheduling_example_44"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, duration_minutes, work_hours):\n    work_start, work_end = work_hours\n    times = []\n    \n    # Create list of busy times for all participants\n    busy_times = []\n    for participant in participants:\n        busy_times.extend(participant)\n\n    # Check all time slots within work hours\n    current_time = work_start\n    while current_time + timedelta(minutes=duration_minutes) <= work_end:\n        end_time = current_time + timedelta(minutes=duration_minutes)\n        if all(not (current_time < busy_end and end_time > busy_start) for busy_start, busy_end in busy_times):\n            times.append((current_time, end_time))\n        current_time += timedelta(minutes=1)\n\n    # Return the earliest meeting time found\n    if times:\n        return times[0]\n    return None\n\ndef format_time(start, end):\n    return f\"{start.strftime('%H:%M')}:{end.strftime('%H:%M')}\"\n\n# Example use case\nif __name__ == \"__main__\":\n    work_hours = (datetime.strptime('09:00', '%H:%M'), datetime.strptime('17:00', '%H:%M'))\n\n    # Participant busy times in (start, end) format\n    participants = [\n        [(datetime.strptime('13:00', '%H:%M'), datetime.strptime('13:30', '%H:%M')),\n         (datetime.strptime('14:00', '%H:%M'), datetime.strptime('14:30', '%H:%M'))],  # Alan's schedule\n        [(datetime.strptime('09:00', '%H:%M'), datetime.strptime('09:30', '%H:%M')),\n         (datetime.strptime('11:00', '%H:%M'), datetime.strptime('11:30', '%H:%M'))],  # Elizabeth's schedule\n        [(datetime.strptime('09:00', '%H:%M'), datetime.strptime('10:00', '%H:%M')),\n         (datetime.strptime('10:30', '%H:%M'), datetime.strptime('11:30', '%H:%M')),\n         (datetime.strptime('12:30', '%H:%M'), datetime.strptime('13:00', '%H:%M')),\n         (datetime.strptime('13:30', '%H:%M'), datetime.strptime('14:00', '%H:%M')),\n         (datetime.strptime('14:30', '%H:%M'), datetime.strptime('16:00', '%H:%M')),\n         (datetime.strptime('16:30', '%H:%M'), datetime.strptime('17:00', '%H:%M'))]   # Denise's schedule\n    ]\n\n    duration_minutes = 30\n    meeting_time = find_meeting_time(participants, duration_minutes, work_hours)\n    if meeting_time:\n        print(format_time(meeting_time[0], meeting_time[1]))\n```\n",
            "count": "calendar_scheduling_example_45"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(schedules, duration_minutes=30):\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    \n    # Create a list of busy intervals\n    busy_intervals = []\n    for schedule in schedules:\n        for start, end in schedule:\n            busy_intervals.append((start, end))\n    \n    # Combine and merge intervals\n    busy_intervals.sort()\n    merged_intervals = []\n    for start, end in busy_intervals:\n        if not merged_intervals or merged_intervals[-1][1] < start:\n            merged_intervals.append((start, end))\n        else:\n            merged_intervals[-1] = (merged_intervals[-1][0], max(merged_intervals[-1][1], end))\n\n    # Find available time slots for the meeting\n    available_time_slots = []\n    prev_end = work_start\n    \n    for start, end in merged_intervals:\n        if prev_end < start:\n            available_time_slots.append((prev_end, start))\n        prev_end = end\n    \n    if prev_end < work_end:\n        available_time_slots.append((prev_end, work_end))\n\n    # Check for a suitable time slot for the meeting\n    meeting_duration = timedelta(minutes=duration_minutes)\n    for start, end in available_time_slots:\n        if end - start >= meeting_duration:\n            proposed_start = start\n            proposed_end = start + meeting_duration\n            return proposed_start.strftime(\"%H:%M\"), proposed_end.strftime(\"%H:%M\")\n    \n    return None\n\n# Example schedules for Arthur, Theresa, and Carl\nschedules = [\n    [(datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\"))],\n    [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n     (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n     (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))],\n    [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n     (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\")),\n     (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))],\n]\n\nproposed_time = find_meeting_time(schedules)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_46"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants_schedule, meeting_duration_minutes, work_hours):\n    # Convert work_hours to datetime objects\n    start_time = datetime.strptime(work_hours[0], \"%H:%M\")\n    end_time = datetime.strptime(work_hours[1], \"%H:%M\")\n    meeting_duration = timedelta(minutes=meeting_duration_minutes)\n\n    # Create a list of all minutes in the work hours\n    busy_slots = []\n    for schedule in participants_schedule:\n        for start, end in schedule:\n            busy_slots.append((datetime.strptime(start, \"%H:%M\"), datetime.strptime(end, \"%H:%M\")))\n    \n    # Sort busy slots by start time\n    busy_slots.sort()\n\n    # Check every minute in the work range\n    current_time = start_time\n    while current_time + meeting_duration <= end_time:\n        # Check if current_time is free\n        meeting_start = current_time\n        meeting_end = meeting_start + meeting_duration\n        \n        # Check against all busy slots\n        is_conflicted = False\n        for busy_start, busy_end in busy_slots:\n            if (meeting_start < busy_end and meeting_end > busy_start):\n                is_conflicted = True\n                break\n        \n        if not is_conflicted:\n            return f\"{meeting_start.strftime('%H:%M')}:{meeting_end.strftime('%H:%M')}\"\n        \n        current_time += timedelta(minutes=1)\n\n    return None\n\n# Example schedule for participants: each tuple is (start_time, end_time)\nparticipants_schedule = [\n    [(\"9:30\", \"10:30\"), (\"11:00\", \"12:00\"), (\"12:30\", \"13:00\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:30\")],  # Roger\n    [(\"9:00\", \"9:30\"), (\"10:30\", \"11:30\"), (\"15:00\", \"15:30\")],  # Eric\n    []  # David (no meetings)\n]\n\nwork_hours = (\"9:00\", \"17:00\")  # Work hours\nmeeting_duration_minutes = 60  # Duration in minutes\n\n# Find the meeting time\nresult = find_meeting_time(participants_schedule, meeting_duration_minutes, work_hours)\nprint(result)\n```",
            "count": "calendar_scheduling_example_47"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:30:15:30}",
            "type_error": "NameError",
            "full_response": "```python\ndef schedule_meeting(participants_schedules, meeting_duration, preferred_start_time='09:00', end_time='17:00'):\n    from datetime import datetime, timedelta\n\n    # Convert time strings to datetime objects\n    WORK_START = datetime.strptime(preferred_start_time, \"%H:%M\")\n    WORK_END = datetime.strptime(end_time, \"%H:%M\")\n    meeting_duration = timedelta(minutes=meeting_duration)\n\n    # Create time slots based on participants' schedules\n    free_slots = []\n    current_time = WORK_START\n\n    # Loop through every half hour slot from the start to end of work hours\n    while current_time + meeting_duration <= WORK_END:\n        # Check if all participants are available at this time slot\n        is_available = True\n        for schedule in participants_schedules:\n            for busy_start, busy_end in schedule:\n                if busy_start < current_time + meeting_duration and current_time < busy_end:\n                    is_available = False\n                    break\n            if not is_available:\n                break\n        \n        if is_available:\n            free_slots.append(current_time)\n\n        current_time += timedelta(minutes=30)  # Check every half hour\n\n    # Return the earliest available time slot formatted as required\n    if free_slots:\n        proposed_time = free_slots[0]\n        return f\"{proposed_time.strftime('%H:%M')}:{(proposed_time + meeting_duration).strftime('%H:%M')}\"\n    else:\n        return None\n\n\n# Example usage\nparticipants_schedules = [\n    [(datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n     (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n     (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n     (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n     (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\"))],  # Karen's schedule\n    \n    [(datetime.strptime(\"9:00\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n     (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n     (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n     (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n     (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\")),\n     (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))],  # Dorothy's schedule\n\n    []  # Roger's schedule is empty\n]\n\nmeeting_duration = 30  # minutes\nresult = schedule_meeting(participants_schedules, meeting_duration)\nprint(result)  # Output should be a valid format like HH:MM:HH:MM\n```",
            "count": "calendar_scheduling_example_48"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, meeting_duration, work_hours):\n    # Convert work hours to datetime objects\n    start_work = datetime.strptime(work_hours[0], '%H:%M')\n    end_work = datetime.strptime(work_hours[1], '%H:%M')\n    \n    # Get all potential meeting slots\n    potential_slots = []\n    \n    current_time = start_work\n    while current_time + meeting_duration <= end_work:\n        potential_slots.append(current_time)\n        current_time += timedelta(minutes=30)  # Check next 30 minutes\n    \n    # Check each slot against participants' schedules\n    for slot in potential_slots:\n        slot_end = slot + meeting_duration\n        if all(is_slot_free(slot, slot_end, busy_times) for busy_times in participants.values()):\n            return slot.strftime('%H:%M') + ':' + slot_end.strftime('%H:%M')\n    \n    return \"No available time found\"\n\ndef is_slot_free(start, end, busy_times):\n    # Check if the busy times overlap with the meeting slot\n    for busy_start, busy_end in busy_times:\n        if (start < busy_end) and (end > busy_start):\n            return False\n    return True\n\n# Participants' busy schedules\nparticipants = {\n    'Teresa': [(datetime.strptime('09:00', '%H:%M'), datetime.strptime('10:00', '%H:%M')),\n               (datetime.strptime('13:00', '%H:%M'), datetime.strptime('13:30', '%H:%M')),\n               (datetime.strptime('14:00', '%H:%M'), datetime.strptime('14:30', '%H:%M')),\n               (datetime.strptime('15:00', '%H:%M'), datetime.strptime('15:30', '%H:%M')),\n               (datetime.strptime('16:30', '%H:%M'), datetime.strptime('17:00', '%H:%M'))],\n    'Kathleen': [(datetime.strptime('09:00', '%H:%M'), datetime.strptime('09:30', '%H:%M')),\n                 (datetime.strptime('12:30', '%H:%M'), datetime.strptime('13:00', '%H:%M')),\n                 (datetime.strptime('13:30', '%H:%M'), datetime.strptime('14:00', '%H:%M')),\n                 (datetime.strptime('15:00', '%H:%M'), datetime.strptime('15:30', '%H:%M'))],\n    'Patricia': [(datetime.strptime('09:00', '%H:%M'), datetime.strptime('10:30', '%H:%M')),\n                 (datetime.strptime('11:30', '%H:%M'), datetime.strptime('12:00', '%H:%M')),\n                 (datetime.strptime('13:00', '%H:%M'), datetime.strptime('13:30', '%H:%M')),\n                 (datetime.strptime('14:00', '%H:%M'), datetime.strptime('14:30', '%H:%M')),\n                 (datetime.strptime('15:30', '%H:%M'), datetime.strptime('16:00', '%H:%M')),\n                 (datetime.strptime('16:30', '%H:%M'), datetime.strptime('17:00', '%H:%M'))]\n}\n\nmeeting_duration = timedelta(minutes=30)\nwork_hours = ['09:00', '17:00']\n\n# Find proposed meeting time\nproposed_time = find_meeting_time(participants, meeting_duration, work_hours)\nprint(f\"Here is the proposed time: {proposed_time}\")\n```",
            "count": "calendar_scheduling_example_49"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(schedule, duration_minutes=30):\n    # Define the work hours\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    \n    # Create a list of busy times from individual schedules\n    busy_times = []\n    for times in schedule.values():\n        for start, end in times:\n            busy_times.append((datetime.strptime(start, \"%H:%M\"), datetime.strptime(end, \"%H:%M\")))\n\n    # Sort the busy times\n    busy_times.sort()\n    \n    # Initialize the search start time\n    current_time = work_start\n    \n    # Iterate through the busy times to find a suitable slot\n    for busy_start, busy_end in busy_times:\n        # If there's available time before the next busy slot\n        if current_time + timedelta(minutes=duration_minutes) <= busy_start:\n            return current_time.strftime(\"%H:%M\") + \" - \" + (current_time + timedelta(minutes=duration_minutes)).strftime(\"%H:%M\")\n        # Move the current time to the end of the busy period\n        current_time = max(current_time, busy_end)\n    \n    # Check if the last time slot can accommodate the meeting until work_end\n    if current_time + timedelta(minutes=duration_minutes) <= work_end:\n        return current_time.strftime(\"%H:%M\") + \" - \" + (current_time + timedelta(minutes=duration_minutes)).strftime(\"%H:%M\")\n\n# Example Usage\nschedule = {\n    'Daniel': [],\n    'Roy': [],\n    'Emma': [('09:00', '10:30'), ('11:00', '12:00'), ('12:30', '13:30'), ('14:30', '15:30'), ('16:00', '16:30')]\n}\n\nproposed_time = find_meeting_time(schedule, duration_minutes=60)\nprint(f\"Here is the proposed time: {proposed_time}\")\n```",
            "count": "calendar_scheduling_example_50"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, duration=30):\n    work_start = timedelta(hours=9, minutes=0)\n    work_end = timedelta(hours=17, minutes=0)\n    duration = timedelta(minutes=duration)\n\n    # Convert participant schedules to a list of busy intervals\n    busy_intervals = []\n    for schedule in participants:\n        for busy_time in schedule:\n            start_time = timedelta(hours=busy_time[0], minutes=busy_time[1])\n            end_time = start_time + duration\n            busy_intervals.append((start_time, end_time))\n\n    # Sort intervals by start time\n    busy_intervals.sort()\n\n    # Find free slots\n    free_slots = []\n    current_start = work_start\n\n    for start, end in busy_intervals:\n        if current_start + duration <= start:\n            free_slots.append((current_start, current_start + duration))\n        current_start = max(current_start, end)\n\n    # Check at the end of the workday\n    if current_start + duration <= work_end:\n        free_slots.append((current_start, current_start + duration))\n\n    # Return the first available slot\n    if free_slots:\n        start_time = free_slots[0][0]\n        return f\"{str(int(start_time.total_seconds() // 3600)).zfill(2)}:{str(int((start_time.total_seconds() % 3600) // 60)).zfill(2)} - {str(int((start_time + duration).total_seconds() // 3600)).zfill(2)}:{str(int(((start_time + duration).total_seconds() % 3600) // 60)).zfill(2)}\"\n    else:\n        return \"No available slot\"\n\n# Example usage:\nparticipants_schedule = [\n    [(10, 0), (12, 0)],                   # participant 1\n    [(10, 30), (12, 30)],                 # participant 2\n    [(9, 30), (11, 0)],                   # participant 3\n]\n\nmeeting_time = find_meeting_time(participants_schedule, duration=30)\nprint(meeting_time)  # This will output the proposed meeting time in the format HH:MM - HH:MM\n```",
            "count": "calendar_scheduling_example_51"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef available_meeting_time(schedules, meeting_duration, work_start, work_end):\n    # Convert work hours to datetime objects\n    start_time = datetime.strptime(work_start, \"%H:%M\")\n    end_time = datetime.strptime(work_end, \"%H:%M\")\n    \n    # Create a list of all the busy times\n    busy_intervals = []\n    for schedule in schedules:\n        for busy_time in schedule:\n            busy_intervals.append((datetime.strptime(busy_time[0], \"%H:%M\"), datetime.strptime(busy_time[1], \"%H:%M\")))\n    \n    # Sort busy intervals\n    busy_intervals.sort()\n    \n    # Check for available time slots\n    current_time = start_time\n    while current_time + timedelta(minutes=meeting_duration) <= end_time:\n        is_available = True\n        \n        for busy_start, busy_end in busy_intervals:\n            if current_time < busy_end and current_time + timedelta(minutes=meeting_duration) > busy_start:\n                is_available = False\n                break\n        \n        if is_available:\n            # Return the proposed time in required format\n            end_meeting_time = current_time + timedelta(minutes=meeting_duration)\n            return f\"{current_time.strftime('%H:%M')}:{end_meeting_time.strftime('%H:%M')}\"\n        \n        # Move to the next minute\n        current_time += timedelta(minutes=1)\n\n# Example participant schedules (meeting start and end times)\nschedules = [\n    [(\"09:30\", \"10:00\"), (\"11:00\", \"11:30\"), (\"14:30\", \"15:00\"), (\"16:30\", \"17:00\")],  # Mason\n    [(\"09:00\", \"17:00\")],  # Bruce\n    [(\"09:30\", \"10:30\"), (\"11:30\", \"12:30\"), (\"15:00\", \"17:00\")]  # Christopher\n]\n\nmeeting_duration = 30  # Duration in minutes\nwork_start = \"09:00\"\nwork_end = \"17:00\"\n\n# Get the proposed time\nproposed_time = available_meeting_time(schedules, meeting_duration, work_start, work_end)\nprint(proposed_time)  # Output will be a valid time like HH:MM:HH:MM\n```",
            "count": "calendar_scheduling_example_52"
        },
        {
            "final_program_time": "{15:30:16:30}",
            "expected_time": "{15:30:16:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, meeting_duration):\n    # Work hours\n    work_start = datetime.strptime('09:00', '%H:%M')\n    work_end = datetime.strptime('17:00', '%H:%M')\n    \n    # Create a list of busy slots\n    busy_slots = []\n    for participant in participants:\n        for busy_start, busy_end in participant['busy_slots']:\n            busy_slots.append((busy_start, busy_end))\n    \n    # Merge overlapping busy slots\n    busy_slots.sort(key=lambda x: x[0])\n    merged_slots = []\n    current_start, current_end = busy_slots[0]\n\n    for i in range(1, len(busy_slots)):\n        next_start, next_end = busy_slots[i]\n        if next_start <= current_end:  # Overlapping\n            current_end = max(current_end, next_end)\n        else:  # No overlap\n            merged_slots.append((current_start, current_end))\n            current_start, current_end = next_start, next_end\n            \n    merged_slots.append((current_start, current_end))  # add last slot\n\n    # Find suitable time slot\n    current_time = work_start\n    for start, end in merged_slots:\n        while current_time + timedelta(minutes=meeting_duration) <= start:\n            return f\"{current_time.strftime('%H:%M')}:{(current_time + timedelta(minutes=meeting_duration)).strftime('%H:%M')}\"\n        current_time = max(current_time, end)\n\n    # Check if there's remaining time after the last busy slot\n    if current_time + timedelta(minutes=meeting_duration) <= work_end:\n        return f\"{current_time.strftime('%H:%M')}:{(current_time + timedelta(minutes=meeting_duration)).strftime('%H:%M')}\"\n\n# Define participants' schedules\nparticipants = [\n    {\n        'name': 'Noah',\n        'busy_slots': []\n    },\n    {\n        'name': 'Alice',\n        'busy_slots': [\n            (datetime.strptime('09:30', '%H:%M'), datetime.strptime('10:00', '%H:%M')),\n            (datetime.strptime('12:30', '%H:%M'), datetime.strptime('13:00', '%H:%M')),\n            (datetime.strptime('14:30', '%H:%M'), datetime.strptime('15:00', '%H:%M')),\n            (datetime.strptime('16:30', '%H:%M'), datetime.strptime('17:00', '%H:%M')),\n        ]\n    },\n    {\n        'name': 'Arthur',\n        'busy_slots': [\n            (datetime.strptime('09:00', '%H:%M'), datetime.strptime('09:30', '%H:%M')),\n            (datetime.strptime('10:00', '%H:%M'), datetime.strptime('11:00', '%H:%M')),\n            (datetime.strptime('11:30', '%H:%M'), datetime.strptime('12:00', '%H:%M')),\n            (datetime.strptime('13:00', '%H:%M'), datetime.strptime('14:00', '%H:%M')),\n            (datetime.strptime('15:00', '%H:%M'), datetime.strptime('15:30', '%H:%M')),\n            (datetime.strptime('16:30', '%H:%M'), datetime.strptime('17:00', '%H:%M')),\n        ]\n    }\n]\n\n# Meeting duration in minutes\nmeeting_duration = 60\n\n# Find and print the meeting time\nproposed_time = find_meeting_time(participants, meeting_duration)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_53"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants_schedules, meeting_duration, work_hours):\n    # Convert work hours to datetime objects\n    work_start = datetime.strptime(work_hours[0], '%H:%M')\n    work_end = datetime.strptime(work_hours[1], '%H:%M')\n\n    # Create a list of busy times based on participants' schedules\n    busy_times = []\n    for schedule in participants_schedules:\n        for busy_slot in schedule:\n            busy_start = datetime.strptime(busy_slot[0], '%H:%M')\n            busy_end = datetime.strptime(busy_slot[1], '%H:%M')\n            busy_times.append((busy_start, busy_end))\n\n    # Merge overlapping busy times\n    busy_times.sort()\n    merged_busy_times = []\n    current_start, current_end = busy_times[0]\n    \n    for start, end in busy_times[1:]:\n        if start <= current_end:  # Overlapping schedules\n            current_end = max(current_end, end)\n        else:\n            merged_busy_times.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_busy_times.append((current_start, current_end))\n\n    # Find available time slots based on merged busy times\n    available_slots = []\n    last_end = work_start\n\n    for start, end in merged_busy_times:\n        if last_end + timedelta(minutes=meeting_duration) <= start:\n            available_slots.append((last_end, start))\n        last_end = end\n\n    # Check for available slot after the last busy time until work end\n    if last_end + timedelta(minutes=meeting_duration) <= work_end:\n        available_slots.append((last_end, work_end))\n\n    # Return the earliest available time slot that fits the meeting duration\n    for start, end in available_slots:\n        if (end - start).total_seconds() >= meeting_duration * 60:\n            proposed_time_start = start\n            proposed_time_end = start + timedelta(minutes=meeting_duration)\n            return proposed_time_start.strftime('%H:%M'), proposed_time_end.strftime('%H:%M')\n\n# Example usage\nparticipants_schedules = [\n    [(\"10:00\", \"10:30\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"14:00\", \"15:00\"), (\"15:30\", \"16:00\")],  # Karen\n    [(\"9:00\", \"10:00\"), (\"10:30\", \"11:00\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"14:00\", \"15:30\"), (\"16:00\", \"17:00\")],  # Dorothy\n    []  # Roger is free all day\n]\n\nmeeting_duration = 30  # in minutes\nwork_hours = ['09:00', '17:00']\n\nstart_time, end_time = find_meeting_time(participants_schedules, meeting_duration, work_hours)\nprint(f'{{{start_time}:{end_time}}}')\n```",
            "count": "calendar_scheduling_example_54"
        },
        {
            "final_program_time": "{10:30:0:11}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, work_start, work_end, duration):\n    # Convert time strings to datetime objects\n    work_start = datetime.strptime(work_start, \"%H:%M\")\n    work_end = datetime.strptime(work_end, \"%H:%M\")\n    duration_timedelta = timedelta(minutes=duration)\n\n    # Create a list to hold busy times for each participant\n    busy_times = []\n\n    # Collect all busy times\n    for schedule in participants:\n        for busy_period in schedule:\n            busy_start = datetime.strptime(busy_period[0], \"%H:%M\")\n            busy_end = datetime.strptime(busy_period[1], \"%H:%M\")\n            busy_times.append((busy_start, busy_end))\n\n    # Sort busy times\n    busy_times.sort()\n\n    # Merge overlapping busy times\n    merged_busy_times = []\n    for start, end in busy_times:\n        if not merged_busy_times or merged_busy_times[-1][1] < start:\n            merged_busy_times.append((start, end))\n        else:\n            merged_busy_times[-1] = (merged_busy_times[-1][0], max(merged_busy_times[-1][1], end))\n\n    # Find the available time slot\n    previous_end = work_start\n    for busy_start, busy_end in merged_busy_times:\n        if previous_end + duration_timedelta <= busy_start:\n            return previous_end.time(), (previous_end + duration_timedelta).time()\n        previous_end = busy_end\n\n    # Check at the end of the work hours\n    if previous_end + duration_timedelta <= work_end:\n        return previous_end.time(), (previous_end + duration_timedelta).time()\n\n    return None\n\n# Example usage\nparticipants_schedules = [\n    [(\"14:00\", \"14:30\"), (\"16:00\", \"16:30\")],  # Keith\n    [],  # Christine\n    [(\"09:00\", \"10:30\"), (\"11:30\", \"17:00\")]  # Cynthia\n]\n\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 60  # in minutes\n\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration)\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{start}:{end}\")\nelse:\n    print(\"No available time found.\")\n```",
            "count": "calendar_scheduling_example_55"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants, meeting_duration):\n    work_hours = (9 * 60, 17 * 60)  # Work hours in minutes\n    free_time_slots = []\n\n    # Initialize free time as the entire work hours\n    last_end_time = work_hours[0]\n\n    # Check each participant's schedule\n    for participant in participants:\n        busy_times = participant['schedule']\n        for start, end in sorted(busy_times):\n            if start > last_end_time:\n                free_time_slots.append((last_end_time, start))\n            last_end_time = max(last_end_time, end)\n    \n    # Add remaining free time until work hours end\n    if last_end_time < work_hours[1]:\n        free_time_slots.append((last_end_time, work_hours[1]))\n\n    # Find a time slot that can fit the meeting\n    for start, end in free_time_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = start + meeting_duration\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n# Example usage:\nparticipants = [\n    {'name': 'Jeremy', 'schedule': [(12 * 60, 13 * 60), (13 * 60 + 30, 14 * 60), (15 * 60, 15 * 60 + 30)]},\n    {'name': 'Donna', 'schedule': [(9 * 60 + 30, 10 * 60), (13 * 60, 13 * 60 + 30), (16 * 60, 17 * 60)]},\n    {'name': 'Robert', 'schedule': [(9 * 60, 11 * 60), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 17 * 60)]}\n]\n\nmeeting_duration = 30  # in minutes\nprint(find_meeting_time(participants, meeting_duration))\n```",
            "count": "calendar_scheduling_example_56"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(schedules, duration):\n    working_hours_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    working_hours_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    meeting_duration = timedelta(minutes=duration)\n    \n    # Create an array to mark busy times\n    busy_slots = []\n    \n    for schedule in schedules:\n        for start, end in schedule:\n            busy_slots.append((start, end))\n    \n    # Sort the busy slots by start time\n    busy_slots.sort()\n    \n    # Merge overlapping busy slots\n    merged_busy_slots = []\n    current_start, current_end = busy_slots[0]\n    \n    for start, end in busy_slots[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged_busy_slots.append((current_start, current_end))\n            current_start, current_end = start, end\n            \n    merged_busy_slots.append((current_start, current_end))\n    \n    # Find the available time slots\n    last_end = working_hours_start\n    for start, end in merged_busy_slots:\n        if last_end + meeting_duration <= start:\n            return f\"{last_end.strftime('%H:%M')}:{(last_end + meeting_duration).strftime('%H:%M')}\"\n        last_end = max(last_end, end)\n    \n    # After the last busy slot, check if there's time before the end of the working hours\n    if last_end + meeting_duration <= working_hours_end:\n        return f\"{last_end.strftime('%H:%M')}:{(last_end + meeting_duration).strftime('%H:%M')}\"\n    \n    return None  # No available time found\n    \n# Define the schedules\nschedules = [\n    [(datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\"))],  # Virginia\n    [(datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n     (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\"))],  # Charles\n    [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n     (datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\")),\n     (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]   # Megan\n]\n\n# Meeting duration in minutes\nduration = 30\n\n# Get the proposed time\nproposed_time = find_meeting_time(schedules, duration)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_57"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(schedules, duration):\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n\n    # Convert each schedule into datetime ranges\n    busy_slots = []\n    for schedule in schedules:\n        for time_range in schedule:\n            start_time = datetime.strptime(time_range[0], \"%H:%M\")\n            end_time = datetime.strptime(time_range[1], \"%H:%M\")\n            busy_slots.append((start_time, end_time))\n\n    # Sort the busy slots\n    busy_slots.sort()\n\n    # Find free slots in the work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in busy_slots:\n        if previous_end < start:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check free slots for a suitable time for the meeting\n    for start, end in free_slots:\n        if (end - start) >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{meeting_start.strftime('%H:%M')}:{meeting_end.strftime('%H:%M')}\"\n\n    return None\n\n# Example usage for Joan, Theresa, and Shirley\nschedules = [\n    [(\"11:00\", \"11:30\"), (\"12:30\", \"13:00\")], # Joan's schedule\n    [(\"12:00\", \"12:30\"), (\"15:00\", \"15:30\")], # Theresa's schedule\n    [(\"09:30\", \"10:30\"), (\"11:00\", \"12:00\"), (\"13:00\", \"14:00\"), (\"15:30\", \"16:30\")] # Shirley's schedule\n]\n\nduration = timedelta(hours=1)  # 1 hour meeting\nmeeting_time = find_meeting_time(schedules, duration)\nprint(meeting_time)  # Output in HH:MM:HH:MM format\n```",
            "count": "calendar_scheduling_example_58"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, meeting_duration, start_time, end_time):\n    # Create a list of busy times for each participant\n    busy_times = []\n    for participant in participants:\n        busy_times.extend(participant['busy_times'])\n\n    # Create a list of available slots\n    available_slots = []\n    current_time = start_time\n\n    while current_time <= end_time:\n        # Check if the current slot is free for all participants\n        slot_end_time = current_time + meeting_duration\n        if all(not (current_time < busy_end and slot_end_time > busy_start) for busy_start, busy_end in busy_times):\n            available_slots.append((current_time, slot_end_time))\n        current_time += timedelta(minutes=30)  # Check next half-hour\n\n    # Find the earliest available time\n    if available_slots:\n        earliest_slot = available_slots[0]\n        return f\"{earliest_slot[0].strftime('%H:%M')}:{earliest_slot[1].strftime('%H:%M')}\"\n    else:\n        return None\n\n# Example usage for the last task\nparticipants = [\n    {'name': 'Jeffrey', 'busy_times': []},\n    {'name': 'Jack', 'busy_times': [(datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n                                    (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n                                    (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\")),\n                                    (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]},\n    {'name': 'Judith', 'busy_times': [(datetime.strptime(\"9:00\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n                                       (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n                                       (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\")),\n                                       (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n                                       (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]}\n]\n\nmeeting_duration = timedelta(minutes=30)\nstart_time = datetime.strptime(\"14:00\", \"%H:%M\")  # Jeffrey preference to start after 14:00\nend_time = datetime.strptime(\"17:00\", \"%H:%M\")\n\nproposed_time = find_meeting_time(participants, meeting_duration, start_time, end_time)\nprint(proposed_time)  # Expected output: 14:30:15:00\n```",
            "count": "calendar_scheduling_example_59"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(schedule, duration, work_start, work_end):\n    work_hours = [work_start, work_end]\n    current_time = work_start\n\n    while current_time < work_end:\n        meeting_start = current_time\n        meeting_end = current_time + duration\n        \n        if meeting_end <= work_end and all(\n            not (meeting_start < busy_end and meeting_end > busy_start) for busy_start, busy_end in schedule\n        ):\n            return f\"{meeting_start.strftime('%H:%M')} - {meeting_end.strftime('%H:%M')}\"\n        \n        current_time += timedelta(minutes=30)  # Check every 30 minutes\n\n    return None\n\n# Sample Input\nparticipants_schedules = {\n    \"Lisa\": [(datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n             (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n             (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\"))],\n    \"Dorothy\": [],\n    \"Raymond\": [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n                (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n                (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n                (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n}\n\n# Meeting Duration\nmeeting_duration = timedelta(minutes=30)\n\n# Work hours\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"17:00\", \"%H:%M\")\n\n# Collecting all busy times from participants\nall_busy_times = []\nfor schedule in participants_schedules.values():\n    all_busy_times.extend(schedule)\n\n# Finding a suitable meeting time\nproposed_time = find_meeting_time(all_busy_times, meeting_duration, work_start, work_end)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_60"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants_availability, meeting_duration):\n    # Convert strings to datetime objects for easier comparison\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    duration = timedelta(minutes=meeting_duration)\n\n    # Create a list of all busy intervals\n    busy_intervals = []\n    for availability in participants_availability:\n        busy_intervals.extend(availability)\n\n    # Sort the busy intervals by start time\n    busy_intervals.sort(key=lambda x: x[0])\n\n    # Start searching for a free time slot\n    last_end_time = work_start\n\n    for start, end in busy_intervals:\n        # Check if there's a gap between the last end time and the start of the next busy interval\n        if last_end_time + duration <= start:\n            meeting_start = last_end_time\n            meeting_end = last_end_time + duration\n            if meeting_end <= work_end:\n                return (meeting_start.strftime(\"%H:%M\"), meeting_end.strftime(\"%H:%M\"))\n\n        # Move the last end time to the end of the current busy interval if it overlaps\n        if end > last_end_time:\n            last_end_time = end\n\n    # Check after the last busy interval until work end\n    if last_end_time + duration <= work_end:\n        meeting_start = last_end_time\n        meeting_end = last_end_time + duration\n        return (meeting_start.strftime(\"%H:%M\"), meeting_end.strftime(\"%H:%M\"))\n\n    return None\n\n# Define availability of participants: (start time, end time) in a list of tuples\nparticipants_availability = [\n    [(datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n     (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n     (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n     (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))],  # Mason\n\n    [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))],  # Bruce - free all day\n\n    [(datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n     (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n     (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]  # Christopher\n]\n\nmeeting_duration = 30  # Meeting duration in minutes\n\n# Find a suitable meeting time\nmeeting_time = find_meeting_time(participants_availability, meeting_duration)\nif meeting_time:\n    print(f\"Proposed time: {{{meeting_time[0]}:{meeting_time[1]}}}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_61"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(schedules, meeting_duration):\n    # Work hours\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    \n    # Prepare a list of availability slots\n    availability = [(work_start, work_end)]\n    \n    # Process each participant's schedule\n    for busy_start, busy_end in schedules:\n        new_availability = []\n        for available_start, available_end in availability:\n            # If the busy schedule does not overlap with available time\n            if busy_end <= available_start or busy_start >= available_end:\n                new_availability.append((available_start, available_end))\n            else:\n                # Adjust available start to be before the busy time\n                if available_start < busy_start:\n                    new_availability.append((available_start, busy_start))\n                # Adjust available end to be after the busy time\n                if available_end > busy_end:\n                    new_availability.append((busy_end, available_end))\n        \n        availability = new_availability\n\n    # Now check for a meeting slot\n    for start, end in availability:\n        # Check for a sufficient duration in each slot\n        while start + meeting_duration <= end:\n            return f\"{start.strftime('%H:%M')}:{(start + meeting_duration).strftime('%H:%M')}\"\n        start += timedelta(minutes=1)  # Move to the next minute to check again\n\n    return \"No available time\"\n\n# Example usage\nschedules = [\n    (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n    (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\")),\n]\nmeeting_duration = timedelta(minutes=60)  # 1 hour\nprint(find_meeting_time(schedules, meeting_duration))\n```",
            "count": "calendar_scheduling_example_62"
        },
        {
            "final_program_time": "{16:00:17:00}",
            "expected_time": "{16:00:17:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Function to convert string time to datetime object\ndef time_to_datetime(time_str):\n    return datetime.strptime(time_str, '%H:%M')\n\n# Function to convert datetime object back to string time\ndef datetime_to_time_str(dt):\n    return dt.strftime('%H:%M')\n\n# Function to find available time slots\ndef find_meeting_time(participant_schedules, meeting_duration):\n    work_start = time_to_datetime('09:00')\n    work_end = time_to_datetime('17:00')\n\n    # Create a list of busy times\n    busy_times = []\n    for busy_schedule in participant_schedules:\n        for busy_time in busy_schedule:\n            busy_times.append((time_to_datetime(busy_time[0]), time_to_datetime(busy_time[1])))\n\n    # Merge overlapping busy times\n    busy_times.sort()\n    merged_busy_times = []\n    for current_start, current_end in busy_times:\n        if not merged_busy_times or merged_busy_times[-1][1] < current_start:\n            merged_busy_times.append((current_start, current_end))\n        else:\n            merged_busy_times[-1] = (merged_busy_times[-1][0], max(merged_busy_times[-1][1], current_end))\n\n    # Find available time slots\n    available_slots = []\n    prev_end = work_start\n    for start, end in merged_busy_times:\n        if prev_end < start:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Check for available slots that can accommodate the meeting time\n    for start, end in available_slots:\n        if (end - start) >= timedelta(minutes=meeting_duration):\n            proposed_start = start\n            proposed_end = start + timedelta(minutes=meeting_duration)\n            return f\"{datetime_to_time_str(proposed_start)}:{datetime_to_time_str(proposed_end)}\"\n\n# Example participant schedules: (start_time, end_time)\nparticipant_schedules = [\n    [(\"09:00\", \"09:30\"), (\"10:30\", \"11:00\"), (\"12:00\", \"12:30\"), (\"13:00\", \"13:30\"), (\"14:00\", \"16:00\")], # Roger\n    [(\"10:00\", \"10:30\"), (\"11:00\", \"12:00\"), (\"12:30\", \"13:00\")], # Judith\n    [] # Madison\n]\n\n# Meeting duration in minutes\nmeeting_duration = 60\n\n# Get proposed meeting time\nproposed_time = find_meeting_time(participant_schedules, meeting_duration)\nprint(proposed_time)  # Example Output: 12:30:13:30\n```",
            "count": "calendar_scheduling_example_63"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(availability, meeting_duration):\n    start_of_day = datetime.strptime(\"09:00\", \"%H:%M\")\n    end_of_day = datetime.strptime(\"17:00\", \"%H:%M\")\n    meeting_duration = timedelta(minutes=meeting_duration)\n\n    # Generate availability intervals\n    intervals = []\n    current_time = start_of_day\n    while current_time < end_of_day:\n        # Check if current time slot is available for everyone\n        end_time = current_time + meeting_duration\n        if end_time > end_of_day:\n            break\n        if all(start <= current_time and end >= end_time for start, end in availability):\n            intervals.append((current_time, end_time))\n        current_time += timedelta(minutes=1)\n\n    # Returning the earliest available time slot\n    if intervals:\n        return intervals[0]  # return the first available slot\n    else:\n        return None\n\ndef format_time(start, end):\n    return f\"{start.strftime('%H:%M')}:{end.strftime('%H:%M')}\"\n\n# Participant schedules (as (start, end) tuples, in minutes)\nroger_schedule = []\nkaren_schedule = [(datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n                  (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n                  (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n                  (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n                  (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\"))]\ndorothy_schedule = [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n                    (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n                    (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n                    (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n                    (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\")),\n                    (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n\n# Convert schedules into intervals for availability check (block intervals)\navailability = []\nfor schedule in [roger_schedule, karen_schedule, dorothy_schedule]:\n    for busy_start, busy_end in schedule:\n        availability.append((busy_start, busy_end))\n\n# Find the time slot for a 30-minute meeting\nmeeting_duration = 30\nmeeting_time = find_meeting_time(availability, meeting_duration)\n\nif meeting_time:\n    print(format_time(meeting_time[0], meeting_time[1]))\nelse:\n    print(\"No available time slot found.\")\n```",
            "count": "calendar_scheduling_example_64"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants_availability, meeting_duration):\n    start_of_workday = datetime.strptime(\"09:00\", \"%H:%M\")\n    end_of_workday = datetime.strptime(\"17:00\", \"%H:%M\")\n    \n    meeting_duration_delta = timedelta(minutes=meeting_duration)\n\n    # Generate the busy slots from the availability of each participant\n    busy_slots = []\n    for availability in participants_availability:\n        for busy_start, busy_end in availability:\n            busy_slots.append((busy_start, busy_end))\n\n    # Sort the busy slots\n    busy_slots.sort()\n\n    # Merge overlapping busy slots\n    merged_busy_slots = []\n    for start, end in busy_slots:\n        if not merged_busy_slots or merged_busy_slots[-1][1] < start:\n            merged_busy_slots.append((start, end))\n        else:\n            merged_busy_slots[-1] = (merged_busy_slots[-1][0], max(merged_busy_slots[-1][1], end))\n\n    # Find the first available slot for the meeting\n    current_time = start_of_workday\n    for busy_start, busy_end in merged_busy_slots:\n        if current_time + meeting_duration_delta <= busy_start:\n            return current_time.strftime(\"%H:%M\") + \" - \" + (current_time + meeting_duration_delta).strftime(\"%H:%M\")\n        current_time = max(current_time, busy_end)\n\n    # Check at the end of the day\n    if current_time + meeting_duration_delta <= end_of_workday:\n        return current_time.strftime(\"%H:%M\") + \" - \" + (current_time + meeting_duration_delta).strftime(\"%H:%M\")\n\n    return None\n\n# Example usage\nparticipants_availability = [\n    [(datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\"))],\n    [(datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\"))],\n    [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n     (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n     (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n     (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\")),\n     (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))]\n]\n\nmeeting_duration = 30\nproposed_time = find_meeting_time(participants_availability, meeting_duration)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_65"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, meeting_duration):\n    # Define the work hours\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    \n    # Create a list to store all busy slots\n    busy_slots = []\n    \n    # Fill busy slots from participants' calendars\n    for schedule in participants:\n        for busy_time in schedule:\n            start_time = datetime.strptime(busy_time[0], \"%H:%M\")\n            end_time = datetime.strptime(busy_time[1], \"%H:%M\")\n            busy_slots.append((start_time, end_time))\n    \n    # Mark the calendar as free\n    free_slots = [(work_start, work_end)]\n    \n    # Remove busy slots from free slots\n    for busy_start, busy_end in sorted(busy_slots):\n        new_free_slots = []\n        for free_start, free_end in free_slots:\n            # If the free slot ends before the busy slot starts, keep it\n            if free_end <= busy_start:\n                new_free_slots.append((free_start, free_end))\n            # If the free slot starts after the busy slot ends, keep it\n            elif free_start >= busy_end:\n                new_free_slots.append((free_start, free_end))\n            # We need to adjust the free slots\n            else:\n                # Adjust the start of the free slot\n                if free_start < busy_start:\n                    new_free_slots.append((free_start, busy_start))\n                # Adjust the end of the free slot\n                if busy_end < free_end:\n                    new_free_slots.append((busy_end, free_end))\n        free_slots = new_free_slots\n    \n    # Find a free slot that fits the meeting duration\n    for free_start, free_end in free_slots:\n        if (free_end - free_start) >= meeting_duration:\n            proposed_start = free_start\n            proposed_end = free_start + meeting_duration\n            if proposed_end <= free_end:\n                return proposed_start.strftime(\"%H:%M\") + ':' + proposed_end.strftime(\"%H:%M\")\n\n# Example participants and meeting duration\nparticipants = [\n    [(\"09:00\", \"10:00\"), (\"10:30\", \"11:00\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"14:00\", \"15:30\"), (\"16:00\", \"17:00\")],\n    [],\n    [(\"09:00\", \"10:00\"), (\"10:00\", \"10:30\"), (\"10:30\", \"11:30\"), (\"12:30\", \"13:00\"), (\"14:00\", \"14:30\"), (\"14:30\", \"17:00\")],\n]\n\nmeeting_duration = timedelta(minutes=30)\n\n# Find and print the meeting time\nprint(find_meeting_time(participants, meeting_duration))\n```",
            "count": "calendar_scheduling_example_66"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:30:14:00}",
            "type_error": "TypeError",
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, meeting_duration):\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    \n    # Create a list of all hours in the work day\n    time_slots = []\n    current_time = work_start\n    while current_time < work_end:\n        time_slots.append(current_time)\n        current_time += timedelta(minutes=30)  # 30-minute slots\n\n    # Check each time slot for availability\n    for start_time in time_slots:\n        end_time = start_time + timedelta(minutes=meeting_duration)\n        if end_time > work_end:\n            continue\n        \n        # Check if all participants are available\n        if all(is_available(participant, start_time, end_time) for participant in participants):\n            return f\"{start_time.strftime('%H:%M')} - {end_time.strftime('%H:%M')}\"\n\n    return None\n\ndef is_available(schedule, start_time, end_time):\n    for busy_start, busy_end in schedule:\n        if (start_time < busy_end) and (end_time > busy_start):\n            return False\n    return True\n\n# Example schedules as a list of tuples with (start_time, end_time) in minutes\nparticipants_schedules = [\n    [(13*60, 13*60+30), (16*60, 16*60+30)],  # Jacqueline's busy times\n    [],  # Christian's busy times (free all day)\n    [(9*60, 10*60+30), (11*60+30, 12*60+30), (14*60, 14*60+30), (15*60+30, 16*60+30)]  # Linda's busy times\n]\n\nmeeting_duration_minutes = 30\nproposed_time = find_meeting_time(participants_schedules, meeting_duration_minutes)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_67"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(schedules, duration, work_hours):\n    start_time = datetime.strptime(work_hours[0], '%H:%M')\n    end_time = datetime.strptime(work_hours[1], '%H:%M')\n    \n    # Create a list of all busy times\n    busy_times = []\n    for schedule in schedules.values():\n        busy_times.extend(schedule)\n    \n    # Convert busy times into a list of tuples representing unavailable time intervals\n    unavailable_intervals = []\n    for time in busy_times:\n        start, end = time\n        unavailable_intervals.append((datetime.strptime(start, '%H:%M'), datetime.strptime(end, '%H:%M')))\n\n    # Sort intervals by starting time\n    unavailable_intervals.sort()\n\n    # Check for available slots between work hours\n    last_end = start_time\n    for start, end in unavailable_intervals:\n        if last_end + duration <= start and last_end >= start_time:\n            return last_end.strftime('%H:%M') + ':' + (last_end + duration).strftime('%H:%M')\n        last_end = max(last_end, end)\n\n    if last_end + duration <= end_time:\n        return last_end.strftime('%H:%M') + ':' + (last_end + duration).strftime('%H:%M')\n    \n    return None\n\n# Define participants' schedules\nschedules = {\n    'Michael': [('10:00', '10:30'), ('11:30', '12:00'), ('13:30', '14:00'), ('15:30', '16:00')],\n    'Bryan': [],\n    'Lauren': [('09:00', '10:30'), ('14:30', '17:00')]\n}\n\n# Define meeting duration and work hours\nmeeting_duration = timedelta(minutes=30)\nwork_hours = ('09:00', '17:00')\n\n# Find and print the proposed meeting time\nproposed_time = find_meeting_time(schedules, meeting_duration, work_hours)\nprint(proposed_time)  # Output should be in format HH:MM:HH:MM\n```",
            "count": "calendar_scheduling_example_68"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:00:11:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(available_times, duration):\n    for start, end in available_times:\n        if end - start >= duration:\n            proposed_start = start\n            proposed_end = proposed_start + duration\n            if proposed_end <= end:\n                return proposed_start, proposed_end\n    return None, None\n\ndef convert_to_str(time):\n    return time.strftime(\"%H:%M\")\n\n# Schedules in (start_time, end_time) format\n# Example for the last task\nschedules = {\n    \"Shirley\": [(datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n                (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n                (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))],\n    \"Stephen\": [(datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n                (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\"))],\n    \"Paul\": [(datetime.strptime(\"9:00\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n             (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n}\n\n# Define the meeting duration\nmeeting_duration = timedelta(hours=1)\n\n# Generate available times based on schedules\navailable_times = []\nstart_window = datetime.strptime(\"09:00\", \"%H:%M\")\nend_window = datetime.strptime(\"17:00\", \"%H:%M\")\n\n# Create a list of busy times\nbusy_times = []\nfor participant, times in schedules.items():\n    busy_times.extend(times)\n\n# Sort busy times and find gaps\nbusy_times.sort(key=lambda x: x[0])\ncurrent_time = start_window\n\nfor start, end in busy_times:\n    if current_time < start:\n        available_times.append((current_time, start))\n    current_time = max(current_time, end)\n\n# Check for time after last busy period\nif current_time < end_window:\n    available_times.append((current_time, end_window))\n\n# Find a valid time for the meeting\nproposed_start, proposed_end = find_meeting_time(available_times, meeting_duration)\n\nif proposed_start and proposed_end:\n    print(f\"Here is the proposed time: {convert_to_str(proposed_start)} - {convert_to_str(proposed_end)}\")\nelse:\n    print(\"No available time found.\")\n```",
            "count": "calendar_scheduling_example_69"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, meeting_duration):\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    slots = []\n\n    # Create a list of busy slots\n    for participant in participants:\n        for busy_slot in participant['busy_slots']:\n            start_time = datetime.strptime(busy_slot[0], \"%H:%M\")\n            end_time = datetime.strptime(busy_slot[1], \"%H:%M\")\n            slots.append((start_time, end_time))\n\n    # Sort the busy slots\n    slots.sort()\n\n    # Merge the busy slots to find free slots\n    merged_slots = []\n    for start, end in slots:\n        if not merged_slots or merged_slots[-1][1] < start:\n            merged_slots.append((start, end))\n        else:\n            merged_slots[-1] = (merged_slots[-1][0], max(merged_slots[-1][1], end))\n\n    # Find available time slots\n    last_end = work_start\n    for start, end in merged_slots:\n        if last_end + meeting_duration <= start:\n            return f\"{last_end.strftime('%H:%M')}:{(last_end + meeting_duration).strftime('%H:%M')}\"\n        last_end = end\n\n    # Check the end of the workday\n    if last_end + meeting_duration <= work_end:\n        return f\"{last_end.strftime('%H:%M')}:{(last_end + meeting_duration).strftime('%H:%M')}\"\n\n# Example usage\nparticipants = [\n    {'name': 'Denise', 'busy_slots': [('12:00', '12:30'), ('15:30', '16:00')]},\n    {'name': 'Angela', 'busy_slots': []},\n    {'name': 'Natalie', 'busy_slots': [('09:00', '11:30'), ('12:00', '13:00'), ('14:00', '14:30'), ('15:00', '17:00')]},\n]\n\nmeeting_duration = timedelta(minutes=30)\nproposed_time = find_meeting_time(participants, meeting_duration)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_70"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:00:10:30}",
            "type_error": "TypeError",
            "full_response": "```python\ndef find_meeting_time(participant_schedules, duration, preferences, work_hours):\n    work_start, work_end = work_hours\n    meeting_duration_minutes = duration\n    meeting_start = work_start\n\n    # Convert time string to minutes\n    def time_to_minutes(t):\n        hours, minutes = map(int, t.split(':'))\n        return hours * 60 + minutes\n\n    # Convert minutes back to time string\n    def minutes_to_time(m):\n        hours = m // 60\n        minutes = m % 60\n        return f\"{hours:02}:{minutes:02}\"\n\n    # Check if a meeting can be scheduled at the given start time\n    def can_schedule_meeting(start_time):\n        for participant, busy_times in participant_schedules.items():\n            for busy_start, busy_end in busy_times:\n                if not (start_time + meeting_duration_minutes <= busy_start or start_time >= busy_end):\n                    return False\n        return True\n\n    # Check preference for meeting time\n    preferred_start = time_to_minutes(preferences['earliest'])\n    preferred_end = time_to_minutes(preferences['latest'])\n\n    # Explore available times\n    while meeting_start + meeting_duration_minutes <= time_to_minutes(work_end):\n        if meeting_start >= preferred_start and meeting_start + meeting_duration_minutes <= preferred_end:\n            if can_schedule_meeting(meeting_start):\n                return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_start + meeting_duration_minutes)}\"\n        meeting_start += 1\n\n    return None  # If no meeting time is found\n\n# Example usage\nparticipant_schedules = {\n    'Nicole': [],\n    'John': [('12:30', '13:00'), ('16:30', '17:00')],\n    'Ethan': [('09:00', '10:00'), ('11:30', '14:00'), ('14:30', '17:00')]\n}\nduration = 30  # minutes\npreferences = {'earliest': '09:00', 'latest': '12:00'}\nwork_hours = ('09:00', '17:00')\n\nproposed_time = find_meeting_time(participant_schedules, duration, preferences, work_hours)\nprint(proposed_time)  # Output format: HH:MM:HH:MM\n```",
            "count": "calendar_scheduling_example_71"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants_availability, meeting_duration):\n    # Convert the list of availability time into datetime objects\n    busy_slots = []\n    for participant in participants_availability:\n        for slot in participant['busy_slots']:\n            busy_slots.append((datetime.strptime(slot[0], \"%H:%M\"), datetime.strptime(slot[1], \"%H:%M\")))\n\n    # Sorting the busy slots for easier management\n    busy_slots.sort()\n\n    # Merging overlapping slots\n    merged_slots = []\n    for start, end in busy_slots:\n        if not merged_slots or merged_slots[-1][1] < start:\n            merged_slots.append((start, end))\n        else:\n            merged_slots[-1] = (merged_slots[-1][0], max(merged_slots[-1][1], end))\n\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    \n    # Checking for gaps in the merged busy slots\n    prev_end = work_start\n    for start, end in merged_slots:\n        if (start - prev_end) >= timedelta(minutes=meeting_duration):\n            meeting_start = prev_end\n            meeting_end = prev_end + timedelta(minutes=meeting_duration)\n            if meeting_end <= start:\n                return meeting_start.strftime(\"%H:%M\") + '-' + meeting_end.strftime(\"%H:%M\")\n        prev_end = end\n    \n    # Check after the last busy slot until work end\n    if prev_end < work_end and (work_end - prev_end) >= timedelta(minutes=meeting_duration):\n        meeting_start = prev_end\n        meeting_end = prev_end + timedelta(minutes=meeting_duration)\n        return meeting_start.strftime(\"%H:%M\") + '-' + meeting_end.strftime(\"%H:%M\")\n\n# Example usage\nparticipants_availability = [\n    {'name': 'Mason', 'busy_slots': []},\n    {'name': 'Amy', 'busy_slots': [('09:30', '11:30'), ('13:00', '13:30'), ('16:30', '17:00')]},\n    {'name': 'Christopher', 'busy_slots': [('09:00', '10:00'), ('12:00', '13:30'), ('14:30', '15:00'), ('15:30', '16:30')]}\n]\n\nmeeting_duration = 60  # in minutes\nprint(find_meeting_time(participants_availability, meeting_duration))\n```",
            "count": "calendar_scheduling_example_72"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, duration_minutes, work_start, work_end):\n    # Parse work hours\n    work_start_time = datetime.strptime(work_start, \"%H:%M\")\n    work_end_time = datetime.strptime(work_end, \"%H:%M\")\n    \n    # Make a busy schedule based on participant availability\n    busy_times = []\n    for participant in participants:\n        for busy_start, busy_end in participant['schedule']:\n            busy_times.append((datetime.strptime(busy_start, \"%H:%M\"), datetime.strptime(busy_end, \"%H:%M\")))\n    \n    # Sort busy times\n    busy_times.sort()\n    \n    # Initialize potential time\n    current_time = work_start_time\n\n    # Loop through the entire workday\n    while current_time + timedelta(minutes=duration_minutes) <= work_end_time:\n        # Check if the current proposed time conflicts with busy times\n        proposed_end_time = current_time + timedelta(minutes=duration_minutes)\n        conflict = False\n        \n        for busy_start, busy_end in busy_times:\n            if current_time < busy_end and proposed_end_time > busy_start:\n                conflict = True\n                break\n        \n        # If no conflict was found, return the proposed time\n        if not conflict:\n            return f\"{current_time.strftime('%H:%M')}:{proposed_end_time.strftime('%H:%M')}\"\n        \n        # Move to the next time slot\n        current_time += timedelta(minutes=1)\n\n# Define participants and their schedules\nparticipants = [\n    {'name': 'Bradley', 'schedule': [('9:30', '10:00'), ('13:00', '13:30'), ('14:30', '15:00'), ('16:30', '17:00')]},\n    {'name': 'Andrew', 'schedule': [('9:00', '9:30'), ('12:30', '13:30'), ('14:00', '14:30'), ('15:00', '16:00')]},\n    {'name': 'Melissa', 'schedule': [('9:00', '9:30'), ('10:00', '10:30'), ('11:00', '14:00'), ('15:00', '15:30'), ('16:00', '16:30')]},\n]\n\n# Call the function and output the result \nmeeting_time = find_meeting_time(participants, 30, '9:00', '17:00')\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_73"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef schedule_meeting(participants_schedules, meeting_duration, work_hours):\n    start_time = datetime.strptime(work_hours[0], \"%H:%M\")\n    end_time = datetime.strptime(work_hours[1], \"%H:%M\")\n    \n    # Block off busy times\n    busy_times = []\n    for schedule in participants_schedules:\n        for busy_period in schedule:\n            busy_start = datetime.strptime(busy_period[0], \"%H:%M\")\n            busy_end = datetime.strptime(busy_period[1], \"%H:%M\")\n            busy_times.append((busy_start, busy_end))\n    \n    # Merge overlapping busy times\n    busy_times.sort()\n    merged_busy_times = []\n    for current_start, current_end in busy_times:\n        if not merged_busy_times or merged_busy_times[-1][1] < current_start:\n            merged_busy_times.append((current_start, current_end))\n        else:\n            merged_busy_times[-1] = (merged_busy_times[-1][0], max(merged_busy_times[-1][1], current_end))\n    \n    # Find available time slots\n    last_end_time = start_time\n    for busy_start, busy_end in merged_busy_times:\n        if last_end_time + timedelta(minutes=meeting_duration) <= busy_start:\n            available_start = last_end_time\n            available_end = last_end_time + timedelta(minutes=meeting_duration)\n            if available_end <= busy_start:\n                return f\"{available_start.strftime('%H:%M')}:{available_end.strftime('%H:%M')}\"       \n        last_end_time = max(last_end_time, busy_end)\n    \n    # Check for time after last busy period\n    if last_end_time + timedelta(minutes=meeting_duration) <= end_time:\n        available_start = last_end_time\n        available_end = last_end_time + timedelta(minutes=meeting_duration)\n        if available_end <= end_time:\n            return f\"{available_start.strftime('%H:%M')}:{available_end.strftime('%H:%M')}\"\n\n# Example of input schedules and invocation\nparticipants_schedules = [\n    [(\"10:00\", \"12:00\")], # Eric\n    [(\"12:00\", \"12:30\"), (\"15:30\", \"16:00\")], # Albert\n    [(\"10:00\", \"11:00\"), (\"11:30\", \"14:00\"), (\"15:00\", \"15:30\")] # Katherine\n]\nmeeting_duration = 60 # minutes\nwork_hours = [\"09:00\", \"17:00\"]\n\n# Call the scheduling function\nproposed_time = schedule_meeting(participants_schedules, meeting_duration, work_hours)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_74"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef schedule_meeting(participants, meeting_duration, work_start, work_end):\n    # Initialize the calendar availability\n    work_start_time = datetime.strptime(work_start, '%H:%M')\n    work_end_time = datetime.strptime(work_end, '%H:%M')\n    \n    # Convert participants' schedules into unavailable time intervals\n    unavailable_intervals = []\n    for participant in participants:\n        for busy_time in participant['busy_times']:\n            start_time = datetime.strptime(busy_time[0], '%H:%M')\n            end_time = datetime.strptime(busy_time[1], '%H:%M')\n            unavailable_intervals.append((start_time, end_time))\n\n    # Sort the unavailable intervals\n    unavailable_intervals.sort()\n\n    # Find available time slots\n    last_end_time = work_start_time\n    for start, end in unavailable_intervals:\n        if last_end_time + meeting_duration <= start:\n            return f\"{last_end_time.strftime('%H:%M')} - {(last_end_time + meeting_duration).strftime('%H:%M')}\"\n        last_end_time = max(last_end_time, end)\n\n    # Check for time after the last busy slot until work_end_time\n    if last_end_time + meeting_duration <= work_end_time:\n        return f\"{last_end_time.strftime('%H:%M')} - {(last_end_time + meeting_duration).strftime('%H:%M')}\"\n\n    return \"No available time slot\"\n\n# Participants' schedules: Example data\nparticipants = [\n    {'name': 'Jacob', 'busy_times': [('09:00', '09:30'), ('12:30', '13:00'), ('14:30', '15:00'), ('16:30', '17:00')]},\n    {'name': 'Amanda', 'busy_times': [('10:00', '10:30'), ('12:00', '12:30')]},\n    {'name': 'Lisa', 'busy_times': [('11:00', '13:00'), ('14:30', '16:30')]}\n]\n\n# Meeting duration and work hours\nmeeting_duration = timedelta(hours=1)  # 1 hour meeting\nwork_start = '09:00'\nwork_end = '17:00'\n\n# Get the proposed time for the meeting\nproposed_time = schedule_meeting(participants, meeting_duration, work_start, work_end)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_75"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, duration):\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    \n    # Convert participant schedules to busy intervals\n    busy_times = []\n    for participant in participants:\n        for busy_time in participant['busy']:\n            start = datetime.strptime(busy_time[0], \"%H:%M\")\n            end = datetime.strptime(busy_time[1], \"%H:%M\")\n            busy_times.append((start, end))\n    \n    # Sort busy times\n    busy_times.sort()\n\n    # Find free slots\n    free_times = []\n    last_end = work_start\n    \n    for start, end in busy_times:\n        if last_end < start:\n            free_times.append((last_end, start))\n        last_end = max(last_end, end)\n    \n    # Check the end of the work day\n    if last_end < work_end:\n        free_times.append((last_end, work_end))\n    \n    # Look for a suitable time for the meeting\n    for start, end in free_times:\n        if (end - start) >= timedelta(minutes=duration):\n            proposed_start = start\n            proposed_end = proposed_start + timedelta(minutes=duration)\n            return proposed_start.strftime(\"%H:%M\"), proposed_end.strftime(\"%H:%M\")\n    \n    return None\n\nparticipants = [\n    {\"name\": \"Joyce\", \"busy\": []},\n    {\"name\": \"Beverly\", \"busy\": [(\"09:30\", \"10:00\"), (\"11:00\", \"11:30\"), (\"12:30\", \"13:00\"), (\"14:00\", \"14:30\"), (\"15:30\", \"16:00\"), (\"16:30\", \"17:00\")]},\n    {\"name\": \"Peter\", \"busy\": [(\"09:30\", \"10:30\"), (\"11:30\", \"13:00\"), (\"14:30\", \"15:30\"), (\"16:30\", \"17:00\")]}\n]\n\nduration = 60  # 1 hour\nstart_time, end_time = find_meeting_time(participants, duration)\nprint(f\"Here is the proposed time: {start_time} - {end_time}\")\n```",
            "count": "calendar_scheduling_example_76"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(schedule, duration):\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    \n    # Create an array for all time slots\n    time_slots = []\n    current_time = work_start\n    while current_time < work_end:\n        time_slots.append(current_time)\n        current_time += timedelta(minutes=30)\n    \n    # Check each time slot for availability\n    for start in time_slots:\n        end = start + timedelta(minutes=duration)\n        if end > work_end:\n            continue\n        \n        if all(not (start < busy_end and end > busy_start) for busy_start, busy_end in schedule):\n            return f\"{start.strftime('%H:%M')}:{end.strftime('%H:%M')}\"\n    \n    return \"No available time slot found\"\n\n# Define the existing schedules for Donald, Joyce, and Abigail\ndonald_schedule = [(datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n                   (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n                   (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n                   (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n                   (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))]\n\njoyce_schedule = [(datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n                  (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n                  (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))]\n\nabigail_schedule = [(datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n                    (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n                    (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\")),\n                    (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n\n# Combine schedules\ncombined_schedule = donald_schedule + joyce_schedule + abigail_schedule\n\n# Find a meeting time for 30 minutes\nmeeting_duration = 30  # minutes\nresult = find_meeting_time(combined_schedule, meeting_duration)\nprint(result)\n```",
            "count": "calendar_scheduling_example_77"
        },
        {
            "final_program_time": "{12:30:13:30}",
            "expected_time": "{12:30:13:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(schedule, duration):\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    \n    # Create a list to hold busy intervals\n    busy_intervals = []\n    \n    # Convert participant schedules into busy intervals (tuples of start and end times)\n    for participant in schedule:\n        for busy_time in schedule[participant]:\n            start_time = datetime.strptime(busy_time[0], \"%H:%M\")\n            end_time = datetime.strptime(busy_time[1], \"%H:%M\")\n            busy_intervals.append((start_time, end_time))\n    \n    # Sort busy_intervals\n    busy_intervals.sort(key=lambda x: x[0])\n    \n    # Initialize the potential meeting start time\n    potential_start = work_start\n    \n    # Check for free slots\n    for start, end in busy_intervals:\n        # Check if there is enough time before the current busy interval\n        if potential_start + timedelta(minutes=duration) <= start:\n            return f\"{potential_start.strftime('%H:%M')}:{(potential_start + timedelta(minutes=duration)).strftime('%H:%M')}\"\n        # Update the potential start time to be after the busy interval\n        potential_start = max(potential_start, end)\n    \n    # Check if there's time after the last busy interval until work end\n    if potential_start + timedelta(minutes=duration) <= work_end:\n        return f\"{potential_start.strftime('%H:%M')}:{(potential_start + timedelta(minutes=duration)).strftime('%H:%M')}\"\n    \n    return \"No available time found\"\n\n# Example schedule\nschedule = {\n    \"Ronald\": [(\"09:00\", \"10:00\"), (\"11:00\", \"12:00\")],\n    \"Teresa\": [(\"10:30\", \"11:00\"), (\"14:00\", \"14:30\")],\n    \"Carol\": [(\"09:00\", \"12:30\"), (\"14:00\", \"15:30\"), (\"16:00\", \"17:00\")],\n}\n\nmeeting_duration = 60  # in minutes\nproposed_time = find_meeting_time(schedule, meeting_duration)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_78"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, duration_minutes=30):\n    work_start = datetime.strptime('09:00', '%H:%M')\n    work_end = datetime.strptime('17:00', '%H:%M')\n    duration = timedelta(minutes=duration_minutes)\n\n    # Initialize the free time slots for each participant\n    busy_slots = []\n    for participant in participants:\n        busy_slots.extend(participants[participant])\n    \n    # Sort the busy slots\n    busy_slots.sort()\n\n    # Combine overlapping busy slots\n    merged_busy_slots = []\n    for start, end in busy_slots:\n        if not merged_busy_slots or merged_busy_slots[-1][1] < start:\n            merged_busy_slots.append((start, end))\n        else:\n            merged_busy_slots[-1] = (merged_busy_slots[-1][0], max(merged_busy_slots[-1][1], end))\n\n    # Find free slots\n    free_slots = []\n    \n    # Check for the time before the first busy slot\n    if work_start < merged_busy_slots[0][0]:\n        free_slots.append((work_start, merged_busy_slots[0][0]))\n\n    # Check between busy slots\n    for i in range(1, len(merged_busy_slots)):\n        free_slots.append((merged_busy_slots[i-1][1], merged_busy_slots[i][0]))\n\n    # Check after the last busy slot\n    if merged_busy_slots[-1][1] < work_end:\n        free_slots.append((merged_busy_slots[-1][1], work_end))\n\n    # Now, find a suitable slot with the required duration\n    for start, end in free_slots:\n        if end - start >= duration:\n            proposed_time_start = start\n            proposed_time_end = start + duration\n            return f\"{proposed_time_start.strftime('%H:%M')}:{proposed_time_end.strftime('%H:%M')}\"\n    \n    return None\n\n# Example Usage\nparticipants = {\n    'Roger': [],\n    'Karen': [\n        (datetime.strptime('10:00', '%H:%M'), datetime.strptime('10:30', '%H:%M')),\n        (datetime.strptime('11:30', '%H:%M'), datetime.strptime('12:00', '%H:%M')),\n        (datetime.strptime('12:30', '%H:%M'), datetime.strptime('13:00', '%H:%M')),\n        (datetime.strptime('14:00', '%H:%M'), datetime.strptime('15:00', '%H:%M')),\n        (datetime.strptime('15:30', '%H:%M'), datetime.strptime('16:00', '%H:%M'))\n    ],\n    'Dorothy': [\n        (datetime.strptime('09:00', '%H:%M'), datetime.strptime('10:00', '%H:%M')),\n        (datetime.strptime('10:30', '%H:%M'), datetime.strptime('11:00', '%H:%M')),\n        (datetime.strptime('11:30', '%H:%M'), datetime.strptime('12:00', '%H:%M')),\n        (datetime.strptime('12:30', '%H:%M'), datetime.strptime('13:00', '%H:%M')),\n        (datetime.strptime('14:00', '%H:%M'), datetime.strptime('15:30', '%H:%M')),\n        (datetime.strptime('16:00', '%H:%M'), datetime.strptime('17:00', '%H:%M'))\n    ]\n}\n\nprint(find_meeting_time(participants, 30))  # Should output \"11:00:11:30\" based on the task example\n```",
            "count": "calendar_scheduling_example_79"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participant_schedules, meeting_duration):\n    # Work hours\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n\n    # Available times in minutes\n    time_slots = []\n\n    # Check the entire work day for available slots\n    for current_time in range(work_start.hour * 60 + work_start.minute, work_end.hour * 60 + work_end.minute):\n        start_time = datetime(2000, 1, 1, current_time // 60, current_time % 60)\n        end_time = start_time + meeting_duration\n        \n        if end_time <= work_end:\n            # Check if all participants are available\n            if all(not (start_time < busy_end and end_time > busy_start) \n                   for schedule in participant_schedules\n                   for busy_start, busy_end in schedule):\n                time_slots.append((start_time, end_time))\n\n    # Return the earliest available time slot as a formatted string\n    if time_slots:\n        earliest_start = min(start for start, end in time_slots)\n        earliest_end = earliest_start + meeting_duration\n        return f\"{earliest_start.strftime('%H:%M')}:{earliest_end.strftime('%H:%M')}\"\n    return \"No available time\"\n\n# Define participants' schedules\nmeeting_duration = timedelta(minutes=30)  # Meeting for half an hour\n\nparticipant_schedules = [\n    [  # Schedules of each participant\n        (datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n        (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n    ],  # Michelle\n    [\n        (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n        (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n        (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n        (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\")),\n    ],  # Billy\n    [\n        (datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n        (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n        (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n        (datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\")),\n        (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\")),\n    ],  # Alexis\n]\n\n# Find and print the proposed time\nproposed_time = find_meeting_time(participant_schedules, meeting_duration)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_80"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants_availability, meeting_duration):\n    work_hours_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_hours_end = datetime.strptime(\"17:00\", \"%H:%M\")\n\n    # Convert meeting duration from minutes to timedelta\n    meeting_duration_timedelta = timedelta(minutes=meeting_duration)\n\n    # Find the earliest common time for the meeting\n    current_time = work_hours_start\n    while current_time + meeting_duration_timedelta <= work_hours_end:\n        meeting_slot_available = True\n        for availability in participants_availability:\n            if not (current_time >= availability[0] and current_time + meeting_duration_timedelta <= availability[1]):\n                meeting_slot_available = False\n                break\n        if meeting_slot_available:\n            return f\"{current_time.strftime('%H:%M')}:{(current_time + meeting_duration_timedelta).strftime('%H:%M')}\"\n        current_time += timedelta(minutes=1)\n\n# Example participants' availability (start, end) for scheduling\nparticipants_availability = [\n    (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")), # Jeremy\n    (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\")), # Lawrence\n    (datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")), # Helen\n]\n\nmeeting_duration = 60  # in minutes\n\n# Find and print the proposed meeting time\nproposed_meeting_time = find_meeting_time(participants_availability, meeting_duration)\nprint(proposed_meeting_time)\n```",
            "count": "calendar_scheduling_example_81"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, meeting_duration_minutes):\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    meeting_duration = timedelta(minutes=meeting_duration_minutes)\n    \n    # Create availability blocks for each participant\n    schedule = {}\n    for participant, busy_times in participants.items():\n        availability = []\n        last_end = work_start\n\n        # Create blocks of free time\n        for busy_start, busy_end in busy_times:\n            if last_end < busy_start:\n                availability.append((last_end, busy_start))\n            last_end = max(last_end, busy_end)\n\n        if last_end < work_end:\n            availability.append((last_end, work_end))\n\n        schedule[participant] = availability\n\n    # Find common available time\n    for start_time, end_time in schedule[list(participants.keys())[0]]:\n        for participant in schedule:\n            available_time = [\n                (max(start_time, a_start), min(end_time, a_end))\n                for a_start, a_end in schedule[participant]\n                if max(start_time, a_start) < min(end_time, a_end)\n            ]\n            # Check if all participants can meet\n            if available_time:\n                for avail_start, avail_end in available_time:\n                    if (avail_end - avail_start) >= meeting_duration:\n                        proposed_start = avail_start\n                        proposed_end = proposed_start + meeting_duration\n                        if proposed_end <= end_time:\n                            return f\"{proposed_start.strftime('%H:%M')}:{proposed_end.strftime('%H:%M')}\"\n    \n    return \"No suitable time found\"\n\n# Example usage\nparticipants = {\n    'Michael': [(datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n                (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\")),\n                (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))],\n    'Eric': [],\n    'Arthur': [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n               (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n               (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\")),\n               (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n}\n\nproposed_time = find_meeting_time(participants, 30)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_82"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{10:00:11:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Define function to calculate the proposed meeting time\ndef find_meeting_time(participants, meeting_duration, work_hours):\n    # Parse work hours\n    work_start = datetime.strptime(work_hours[0], '%H:%M')\n    work_end = datetime.strptime(work_hours[1], '%H:%M')\n    meeting_duration = timedelta(minutes=meeting_duration)\n\n    # Find all busy intervals\n    busy_intervals = []\n    for schedule in participants.values():\n        for busy_time in schedule:\n            busy_start = datetime.strptime(busy_time[0], '%H:%M')\n            busy_end = datetime.strptime(busy_time[1], '%H:%M')\n            busy_intervals.append((busy_start, busy_end))\n\n    # Sort busy intervals and merge overlapping ones\n    busy_intervals.sort()\n    merged_busy_intervals = []\n    current_start, current_end = busy_intervals[0]\n    \n    for start, end in busy_intervals[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged_busy_intervals.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_busy_intervals.append((current_start, current_end))\n\n    # Find available slots\n    last_end = work_start\n    for start, end in merged_busy_intervals:\n        if last_end + meeting_duration <= start:\n            proposed_start = last_end\n            proposed_end = last_end + meeting_duration\n            if proposed_end <= work_end:\n                return f'{proposed_start.strftime(\"%H:%M\")}:{proposed_end.strftime(\"%H:%M\")}'\n        last_end = max(last_end, end)\n    \n    # Check the end of the workday after last busy interval\n    if last_end + meeting_duration <= work_end:\n        proposed_start = last_end\n        proposed_end = last_end + meeting_duration\n        return f'{proposed_start.strftime(\"%H:%M\")}:{proposed_end.strftime(\"%H:%M\")}'\n\n# Usage example\nparticipants_schedule = {\n    'Anthony': [('14:00', '14:30'), ('15:00', '15:30')],\n    'Ronald': [('09:00', '10:00'), ('12:00', '12:30'), ('13:30', '14:00')],\n    'Jonathan': [('09:00', '10:00'), ('11:00', '11:30'), ('12:00', '13:00'), ('14:00', '14:30'), ('15:00', '17:00')]\n}\n\nmeeting_duration_in_minutes = 60\nwork_hours = ['09:00', '17:00']\n\nproposed_time = find_meeting_time(participants_schedule, meeting_duration_in_minutes, work_hours)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_83"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:30:12:30}",
            "type_error": "TypeError",
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participant_schedules, meeting_duration):\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    \n    # Convert all schedules to datetime objects\n    busy_times = []\n    for schedule in participant_schedules:\n        busy_times.extend(schedule)\n    \n    # Sort busy times\n    busy_times.sort(key=lambda x: x[0])\n    \n    # Check for gaps in the schedule\n    current_time = work_start\n    for start, end in busy_times:\n        if current_time + meeting_duration <= start:\n            return (current_time.strftime(\"%H:%M\"), (current_time + meeting_duration).strftime(\"%H:%M\"))\n        current_time = max(current_time, end)\n    \n    # Final check until work end\n    if current_time + meeting_duration <= work_end:\n        return (current_time.strftime(\"%H:%M\"), (current_time + meeting_duration).strftime(\"%H:%M\"))\n    \n    return None\n\n# Define the meeting duration\nmeeting_duration = timedelta(minutes=30)\n\n# Define participant schedules as tuples of (start, end) in datetime format\nparticipant_schedules = [\n    [(datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n     (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n     (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n     (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n     (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\"))],\n    \n    [(datetime.strptime(\"9:00\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n     (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n     (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n     (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n     (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\")),\n     (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))],\n    \n    [(datetime.strptime(\"9:00\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n     (datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n]\n\n# Flatten the schedules into a single list of busy times\nall_schedules = [schedule for sublist in participant_schedules for schedule in sublist]\n\n# Find a meeting time\nproposed_time = find_meeting_time(all_schedules, meeting_duration)\n\nif proposed_time:\n    print(f'{{{proposed_time[0]}:{proposed_time[1]}}}')\nelse:\n    print(\"No available time found.\")\n```",
            "count": "calendar_scheduling_example_84"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participant_schedules, meeting_duration):\n    # Define working hours\n    start_of_work_day = datetime.strptime('09:00', '%H:%M')\n    end_of_work_day = datetime.strptime('17:00', '%H:%M')\n    \n    # Create a list of all available time slots\n    available_slots = []\n    \n    # Populate the busy time slots\n    busy_slots = []\n    for schedule in participant_schedules:\n        for busy_start, busy_end in schedule:\n            busy_slots.append((busy_start, busy_end))\n    \n    # Create a continuous time range to check for availability\n    current_time = start_of_work_day\n    while current_time + meeting_duration <= end_of_work_day:\n        end_time = current_time + meeting_duration\n        \n        # Check if this slot is busy\n        is_busy = any(busy_start <= current_time < busy_end or \n                      busy_start < end_time <= busy_end for busy_start, busy_end in busy_slots)\n        \n        if not is_busy:\n            # If not busy, add to available slots\n            available_slots.append((current_time, end_time))\n        \n        # Move to the next time slot\n        current_time += timedelta(minutes=30)  # Check every half hour\n    \n    # Return the earliest available slot\n    if available_slots:\n        earliest_slot = available_slots[0]\n        return f\"{earliest_slot[0].strftime('%H:%M')} - {earliest_slot[1].strftime('%H:%M')}\"\n    return None\n\n# Example schedules\nparticipant_schedules = [\n    [(datetime.strptime('10:00', '%H:%M'), datetime.strptime('10:30', '%H:%M')),\n     (datetime.strptime('12:00', '%H:%M'), datetime.strptime('12:30', '%H:%M')),\n     (datetime.strptime('14:00', '%H:%M'), datetime.strptime('14:30', '%H:%M')),\n     (datetime.strptime('15:00', '%H:%M'), datetime.strptime('15:30', '%H:%M'))],  # Joshua\n    [],  # Denise\n    [(datetime.strptime('09:30', '%H:%M'), datetime.strptime('10:30', '%H:%M')),\n     (datetime.strptime('12:00', '%H:%M'), datetime.strptime('13:00', '%H:%M')),\n     (datetime.strptime('13:30', '%H:%M'), datetime.strptime('14:00', '%H:%M')),\n     (datetime.strptime('14:30', '%H:%M'), datetime.strptime('15:00', '%H:%M')),\n     (datetime.strptime('15:30', '%H:%M'), datetime.strptime('17:00', '%H:%M'))]  # Jeremy\n]\n\n# Define meeting duration\nmeeting_duration = timedelta(minutes=30)\n\n# Find and print the proposed meeting time\nproposed_time = find_meeting_time(participant_schedules, meeting_duration)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_85"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, duration_hours=0.5, start_time='09:00', end_time='17:00'):\n    # Convert string times to datetime objects for comparison\n    start = datetime.strptime(start_time, \"%H:%M\")\n    end = datetime.strptime(end_time, \"%H:%M\")\n    duration = timedelta(hours=duration_hours)\n    \n    # Create a list of busy intervals\n    busy_times = []\n    for schedule in participants:\n        busy_times.extend(schedule)\n\n    # Sort busy times\n    busy_times.sort()\n    \n    # Create a space for available times\n    current_time = start\n    while current_time + duration <= end:\n        is_free = True\n        for busy_start, busy_end in busy_times:\n            if current_time < busy_end and current_time + duration > busy_start:\n                is_free = False\n                current_time = busy_end  # Jump to the end of the busy time\n                break\n        \n        if is_free:\n            return f\"{current_time.strftime('%H:%M')} - {(current_time + duration).strftime('%H:%M')}\"\n        \n    return \"No available time\"\n\n# Example schedules as tuples of busy intervals (start, end)\nparticipants_schedules = [\n    [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n     (datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n     (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n     (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n     (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))],\n    \n    [(datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\")),\n     (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\")),\n     (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))],\n\n    []  # Free entire day\n]\n\n# Call the function\nproposed_time = find_meeting_time(participants_schedules)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_86"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participant_schedules, meeting_duration):\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    meeting_duration = timedelta(minutes=meeting_duration)\n\n    # Find all busy periods in the schedules\n    busy_times = []\n    for schedule in participant_schedules:\n        for busy_time in schedule:\n            busy_start = datetime.strptime(busy_time[0], \"%H:%M\")\n            busy_end = datetime.strptime(busy_time[1], \"%H:%M\")\n            busy_times.append((busy_start, busy_end))\n\n    # Create a timeline sorted by start time\n    busy_times.sort(key=lambda x: x[0])\n    \n    # Generate free time slots based on busy times\n    free_times = []\n    current_start = work_start\n\n    for busy_start, busy_end in busy_times:\n        if current_start < busy_start:\n            free_times.append((current_start, busy_start))\n        current_start = max(current_start, busy_end)\n\n    if current_start < work_end:\n        free_times.append((current_start, work_end))\n\n    # Find a suitable time slot for the meeting\n    for free_start, free_end in free_times:\n        if free_end - free_start >= meeting_duration:\n            proposed_start = free_start\n            proposed_end = proposed_start + meeting_duration\n            if proposed_end <= free_end:\n                return f\"{proposed_start.strftime('%H:%M')}:{proposed_end.strftime('%H:%M')}\"\n\n    return None  # if no suitable time found\n\n# Example usage:\nparticipant_schedules = [\n    [(\"12:00\", \"12:30\")],  # Douglas\n    [(\"10:30\", \"12:00\"), (\"13:00\", \"13:30\"), (\"14:00\", \"14:30\"), (\"15:30\", \"16:00\")],  # Lawrence\n    [(\"09:00\", \"12:30\"), (\"13:30\", \"17:00\")]  # Isabella\n]\n\nmeeting_duration = 30  # minutes\nproposed_time = find_meeting_time(participant_schedules, meeting_duration)\nprint(proposed_time)  # Outputs: 12:30:13:00\n```",
            "count": "calendar_scheduling_example_87"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants_schedules, meeting_duration):\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    \n    # Create a list of busy times across all participants\n    busy_times = []\n    for schedule in participants_schedules:\n        busy_times.extend(schedule)\n    \n    # Sort the busy times\n    busy_times.sort(key=lambda x: x[0])\n    \n    # Merge overlapping busy times\n    merged_busy_times = []\n    for start, end in busy_times:\n        if not merged_busy_times or merged_busy_times[-1][1] < start:\n            merged_busy_times.append((start, end))\n        else:\n            merged_busy_times[-1] = (merged_busy_times[-1][0], max(merged_busy_times[-1][1], end))\n    \n    # Check for free time slots\n    current_time = work_start\n    for start, end in merged_busy_times:\n        if current_time + meeting_duration <= start:\n            # We found a gap big enough for the meeting\n            return f\"{current_time.strftime('%H:%M')} - {(current_time + meeting_duration).strftime('%H:%M')}\"\n        current_time = max(current_time, end)  # Move to the end of the busy time\n    \n    if current_time + meeting_duration <= work_end:\n        # If there's still time at the end of the day\n        return f\"{current_time.strftime('%H:%M')} - {(current_time + meeting_duration).strftime('%H:%M')}\"\n    \n    return \"No available time found\"\n\n# Sample schedules in the format of tuples (start_time, end_time)\nparticipants_schedules = [\n    [(datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\"))],  # Joseph\n    [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")), \n     (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")), \n     (datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\")), \n     (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]  # Isabella\n]\n\nmeeting_duration = timedelta(hours=1)  # 1 hour meeting\n\n# Find the proposed meeting time\nproposed_time = find_meeting_time(participants_schedules, meeting_duration)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_88"
        },
        {
            "final_program_time": "{15:00:16:00}",
            "expected_time": "{15:00:16:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(schedule, meeting_duration):\n    # Define work hours\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    \n    # Create a list of busy times\n    busy_times = []\n    for times in schedule.values():\n        for start, end in times:\n            busy_times.append((start, end))\n    \n    # Sort busy times\n    busy_times.sort()\n\n    # Merge overlapping busy times\n    merged_busy_times = []\n    current_start, current_end = busy_times[0]\n    \n    for start, end in busy_times[1:]:\n        if start <= current_end:  # overlapping or touching\n            current_end = max(current_end, end)\n        else:\n            merged_busy_times.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_busy_times.append((current_start, current_end))\n\n    # Search for a free slot\n    prev_end = work_start\n    for start, end in merged_busy_times:\n        if prev_end + meeting_duration <= start:\n            return prev_end.strftime(\"%H:%M\") + \":\" + (prev_end + meeting_duration).strftime(\"%H:%M\")\n        prev_end = end\n\n    # Check after last busy time until end of work day\n    if prev_end + meeting_duration <= work_end:\n        return prev_end.strftime(\"%H:%M\") + \":\" + (prev_end + meeting_duration).strftime(\"%H:%M\")\n\n    return None\n\n# Define the schedule for each participant\nparticipants_schedule = {\n    \"Michelle\": [\n        (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n        (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n    ],\n    \"Andrea\": [\n        (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n        (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n        (datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\")),\n        (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n        (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\")),\n    ],\n    \"Douglas\": [\n        (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n        (datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n        (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n        (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\")),\n    ]\n}\n\n# Define the duration of the meeting\nmeeting_duration = timedelta(hours=1)  # 1 hour meeting\n\n# Find and print the proposed time\nproposed_time = find_meeting_time(participants_schedule, meeting_duration)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_89"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participant_schedules, meeting_duration):\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    meeting_duration = timedelta(minutes=meeting_duration)\n\n    # Find all busy times for all participants\n    busy_times = []\n    for schedule in participant_schedules:\n        for busy_start, busy_end in schedule:\n            busy_times.append((busy_start, busy_end))\n\n    # Sort busy times\n    busy_times.sort()\n\n    # Merge overlapping busy times\n    merged_busy_times = []\n    current_start, current_end = busy_times[0]\n    \n    for start, end in busy_times[1:]:\n        if start <= current_end:  # Overlapping\n            current_end = max(current_end, end)\n        else:  # Not overlapping, add the previous one\n            merged_busy_times.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_busy_times.append((current_start, current_end))  # Add the last one\n\n    # Attempt to find a free slot\n    current_time = work_start\n    for busy_start, busy_end in merged_busy_times:\n        if current_time + meeting_duration <= busy_start:\n            # Found a free slot\n            return f\"{current_time.strftime('%H:%M')}:{(current_time + meeting_duration).strftime('%H:%M')}\"\n        # Move current time to the end of the busy period\n        current_time = max(current_time, busy_end)\n\n    # Check if there's time after the last busy period\n    if current_time + meeting_duration <= work_end:\n        return f\"{current_time.strftime('%H:%M')}:{(current_time + meeting_duration).strftime('%H:%M')}\"\n\n    return None  # No valid time found\n\n# Example usage\nparticipant_schedules = [\n    [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n     (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n     (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n     (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\"))],\n    [(datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n     (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n     (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n     (datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n     (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n]\n\nmeeting_duration = 30  # in minutes\n\nproposed_time = find_meeting_time(participant_schedules, meeting_duration)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_90"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\n# Function to find a suitable meeting time\ndef find_meeting_time(participants_schedules, meeting_duration):\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    meeting_duration = timedelta(minutes=meeting_duration)\n\n    # Create a list of all busy slots\n    busy_slots = []\n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            busy_slots.append((busy_start, busy_end))\n\n    # Sort busy slots\n    busy_slots.sort()\n    \n    # Merge overlapping busy slots\n    merged_busy_slots = []\n    for start, end in busy_slots:\n        if not merged_busy_slots or merged_busy_slots[-1][1] < start:\n            merged_busy_slots.append((start, end))\n        else:\n            merged_busy_slots[-1] = (merged_busy_slots[-1][0], max(merged_busy_slots[-1][1], end))\n\n    # Find available time slots\n    available_start = work_start\n    for start, end in merged_busy_slots:\n        if available_start + meeting_duration <= start:\n            return f\"{available_start.strftime('%H:%M')} - {(available_start + meeting_duration).strftime('%H:%M')}\"\n        available_start = max(available_start, end)\n\n    # Check availability after the last busy slot\n    if available_start + meeting_duration <= work_end:\n        return f\"{available_start.strftime('%H:%M')} - {(available_start + meeting_duration).strftime('%H:%M')}\"\n\n# Example participant schedules and meeting duration\nparticipant_schedules = [\n    [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n     (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\"))],\n    [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n     (datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\"))],\n    [(datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n     (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\"))],\n]\n\n# Meeting duration in minutes\nmeeting_duration = 30  # Example: 30 minutes meeting\n\n# Call the function and print the result\nproposed_time = find_meeting_time(participant_schedules, meeting_duration)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_91"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(schedules, meeting_duration, work_hours):\n    work_start, work_end = work_hours\n    work_start = datetime.strptime(work_start, '%H:%M')\n    work_end = datetime.strptime(work_end, '%H:%M')\n    \n    # Create busy slots\n    busy_slots = []\n    for person in schedules:\n        for busy_time in schedules[person]:\n            busy_start, busy_end = busy_time\n            busy_slots.append((datetime.strptime(busy_start, '%H:%M'), datetime.strptime(busy_end, '%H:%M')))\n    \n    # Sort busy slots\n    busy_slots.sort()\n    \n    # Merge overlapping busy slots\n    merged_busy_slots = []\n    current_start, current_end = busy_slots[0]\n    \n    for start, end in busy_slots[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged_busy_slots.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_busy_slots.append((current_start, current_end))\n    \n    # Find free slots\n    free_slots = []\n    \n    # Check from work_start to the first busy slot\n    if merged_busy_slots[0][0] > work_start:\n        free_slots.append((work_start, merged_busy_slots[0][0]))\n    \n    # Check between busy slots\n    for i in range(len(merged_busy_slots) - 1):\n        free_slots.append((merged_busy_slots[i][1], merged_busy_slots[i + 1][0]))\n        \n    # Check from the last busy slot to work_end\n    if merged_busy_slots[-1][1] < work_end:\n        free_slots.append((merged_busy_slots[-1][1], work_end))\n    \n    # Look for a suitable free slot that can accommodate the meeting duration\n    required_time = timedelta(minutes=meeting_duration)\n    \n    for start, end in free_slots:\n        if end - start >= required_time:\n            proposed_start = start\n            proposed_end = start + required_time\n            return proposed_start.strftime('%H:%M') + ':' + proposed_end.strftime('%H:%M')\n    \n    return None\n\n# Example schedules\nschedules = {\n    'Jacqueline': [('09:30', '10:00'), ('16:30', '17:00')],\n    'Henry': [],\n    'William': [('09:30', '10:30'), ('12:30', '15:00'), ('15:30', '17:00')]\n}\n\nmeeting_duration = 60  # in minutes\nwork_hours = ('09:00', '17:00')\n\n# Find meeting time\nproposed_time = find_meeting_time(schedules, meeting_duration, work_hours)\nprint(proposed_time)  # Output in the required format\n```",
            "count": "calendar_scheduling_example_92"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_available_time(participants, meeting_duration_minutes):\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n\n    # Create a list to mark busy times\n    busy_times = []\n    \n    for schedule in participants.values():\n        for start_time, end_time in schedule:\n            busy_times.append((start_time, end_time))\n    \n    # Merge overlapping busy times\n    busy_times.sort()\n    merged_busy_times = []\n    \n    for start_time, end_time in busy_times:\n        if not merged_busy_times or merged_busy_times[-1][1] < start_time:\n            merged_busy_times.append((start_time, end_time))\n        else:\n            merged_busy_times[-1] = (merged_busy_times[-1][0], max(merged_busy_times[-1][1], end_time))\n    \n    # Find available slots\n    available_start = work_start\n    for busy_start, busy_end in merged_busy_times:\n        if available_start + timedelta(minutes=meeting_duration_minutes) <= busy_start:\n            return f\"{available_start.strftime('%H:%M')}:{(available_start + timedelta(minutes=meeting_duration_minutes)).strftime('%H:%M')}\"\n        available_start = max(available_start, busy_end)\n\n    # Check if there's time after the last busy time\n    if available_start + timedelta(minutes=meeting_duration_minutes) <= work_end:\n        return f\"{available_start.strftime('%H:%M')}:{(available_start + timedelta(minutes=meeting_duration_minutes)).strftime('%H:%M')}\"\n\nparticipants = {\n    \"Austin\": [(datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n               (datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\"))],\n    \"Danielle\": [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n                 (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n                 (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n                 (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\"))],\n    \"Charles\": [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n                (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n                (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))],\n}\n\nmeeting_duration = 30  # in minutes\nproposed_time = find_available_time(participants, meeting_duration)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_93"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, meeting_duration):\n    # Define working hours\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    \n    # Create a list to track busy times\n    busy_slots = []\n\n    # Fill busy slots based on participants' schedules\n    for participant in participants:\n        for busy_time in participant['busy_times']:\n            busy_start = datetime.strptime(busy_time[0], \"%H:%M\")\n            busy_end = datetime.strptime(busy_time[1], \"%H:%M\")\n            busy_slots.append((busy_start, busy_end))\n    \n    # Sort busy slots by start time\n    busy_slots.sort()\n\n    # Find available time slot\n    current_time = work_start\n    \n    for busy_start, busy_end in busy_slots:\n        # Check for available time before the busy slot\n        if current_time + timedelta(minutes=meeting_duration) <= busy_start:\n            # Propose the earliest available time\n            return f\"{current_time.strftime('%H:%M')}:{(current_time + timedelta(minutes=meeting_duration)).strftime('%H:%M')}\"\n        current_time = max(current_time, busy_end)\n\n    # Check if there's time after the last busy slot\n    if current_time + timedelta(minutes=meeting_duration) <= work_end:\n        return f\"{current_time.strftime('%H:%M')}:{(current_time + timedelta(minutes=meeting_duration)).strftime('%H:%M')}\"\n    \n    return None\n\n# Example participant data for testing\nparticipants = [\n    {\n        'name': 'Nicholas',\n        'busy_times': []\n    },\n    {\n        'name': 'Elizabeth',\n        'busy_times': [('09:30', '10:00'), ('11:30', '12:00'), ('13:30', '14:30'), ('15:00', '15:30'), ('16:30', '17:00')]\n    },\n    {\n        'name': 'Sandra',\n        'busy_times': [('09:00', '09:30'), ('10:00', '10:30'), ('11:30', '13:30'), ('15:30', '16:30')]\n    },\n]\n\n# Define meeting duration in minutes\nmeeting_duration = 30\n\n# Find proposed time\nproposed_time = find_meeting_time(participants, meeting_duration)\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_94"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef schedule_meeting(participants, meeting_duration):\n    # Define work hours\n    work_start = datetime.strptime('09:00', '%H:%M')\n    work_end = datetime.strptime('17:00', '%H:%M')\n    \n    # Create a list to track busy times\n    busy_times = []\n    \n    for schedule in participants:\n        busy_times.extend(schedule)\n\n    # Find available slots for meeting\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        for busy_start, busy_end in busy_times:\n            if current_time < busy_end and current_time + meeting_duration > busy_start:\n                break\n        else:\n            return f\"{current_time.strftime('%H:%M')}:{(current_time + meeting_duration).strftime('%H:%M')}\"\n        current_time += timedelta(minutes=1)\n\n# Example usage with constraints specified in the tasks\nparticipants = [\n    [(datetime.strptime('09:00', '%H:%M'), datetime.strptime('11:00', '%H:%M')), \n     (datetime.strptime('11:30', '%H:%M'), datetime.strptime('12:30', '%H:%M')),\n     (datetime.strptime('14:00', '%H:%M'), datetime.strptime('15:00', '%H:%M')),\n     (datetime.strptime('15:30', '%H:%M'), datetime.strptime('16:00', '%H:%M'))], # Karen\n    [(datetime.strptime('09:00', '%H:%M'), datetime.strptime('10:00', '%H:%M')),\n     (datetime.strptime('10:30', '%H:%M'), datetime.strptime('11:00', '%H:%M')),\n     (datetime.strptime('11:30', '%H:%M'), datetime.strptime('12:00', '%H:%M')),\n     (datetime.strptime('12:30', '%H:%M'), datetime.strptime('13:00', '%H:%M')),\n     (datetime.strptime('14:00', '%H:%M'), datetime.strptime('15:30', '%H:%M')),\n     (datetime.strptime('16:00', '%H:%M'), datetime.strptime('17:00', '%H:%M'))], # Dorothy\n]\n\nmeeting_duration = timedelta(minutes=30)\nprint(schedule_meeting(participants, meeting_duration))\n```",
            "count": "calendar_scheduling_example_95"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(schedule, duration):\n    work_start = datetime.strptime('09:00', '%H:%M')\n    work_end = datetime.strptime('17:00', '%H:%M')\n    \n    # Collect all busy time intervals for each participant\n    busy_intervals = []\n    for times in schedule.values():\n        for start, end in times:\n            busy_intervals.append((start, end))\n    \n    # Sort the busy intervals by start time\n    busy_intervals.sort()\n\n    # Merge overlapping intervals\n    merged_busy_intervals = []\n    \n    for start, end in busy_intervals:\n        if not merged_busy_intervals or merged_busy_intervals[-1][1] < start:\n            merged_busy_intervals.append((start, end))\n        else:\n            merged_busy_intervals[-1] = (merged_busy_intervals[-1][0], max(merged_busy_intervals[-1][1], end))\n\n    # Find the first available time slot\n    previous_end = work_start\n    for start, end in merged_busy_intervals:\n        if previous_end + timedelta(minutes=duration) <= start:\n            proposed_time_start = previous_end\n            proposed_time_end = previous_end + timedelta(minutes=duration)\n            if proposed_time_end <= work_end:\n                return proposed_time_start.strftime('%H:%M'), proposed_time_end.strftime('%H:%M')\n        previous_end = end\n\n    # Check after the last busy interval until the end of work\n    if previous_end + timedelta(minutes=duration) <= work_end:\n        proposed_time_start = previous_end\n        proposed_time_end = previous_end + timedelta(minutes=duration)\n        return proposed_time_start.strftime('%H:%M'), proposed_time_end.strftime('%H:%M')\n\n# Example case for scheduling\nschedule = {\n    'Christopher': [(datetime.strptime('09:30', '%H:%M'), datetime.strptime('10:00', '%H:%M')),\n                    (datetime.strptime('10:30', '%H:%M'), datetime.strptime('11:00', '%H:%M')),\n                    (datetime.strptime('11:30', '%H:%M'), datetime.strptime('13:00', '%H:%M')),\n                    (datetime.strptime('15:00', '%H:%M'), datetime.strptime('15:30', '%H:%M'))],\n    \n    'Robert': [(datetime.strptime('09:30', '%H:%M'), datetime.strptime('10:00', '%H:%M')),\n               (datetime.strptime('11:00', '%H:%M'), datetime.strptime('11:30', '%H:%M')),\n               (datetime.strptime('12:00', '%H:%M'), datetime.strptime('12:30', '%H:%M')),\n               (datetime.strptime('13:30', '%H:%M'), datetime.strptime('14:30', '%H:%M')),\n               (datetime.strptime('15:00', '%H:%M'), datetime.strptime('15:30', '%H:%M'))],\n    \n    'Wayne': [(datetime.strptime('10:00', '%H:%M'), datetime.strptime('17:00', '%H:%M'))]\n}\n\nduration = 30  # meeting duration in minutes\nstart_time, end_time = find_meeting_time(schedule, duration)\nprint(f\"{start_time}:{end_time}\")\n```",
            "count": "calendar_scheduling_example_96"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{16:00:17:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, duration):\n    # Work hours\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    \n    # Convert duration from minutes to timedelta\n    meeting_duration = timedelta(minutes=duration)\n    \n    # Create a list to store everyone's busy times\n    busy_times = []\n    \n    for person in participants:\n        for busy_period in person['busy_times']:\n            start_time = datetime.strptime(busy_period[0], \"%H:%M\")\n            end_time = datetime.strptime(busy_period[1], \"%H:%M\")\n            busy_times.append((start_time, end_time))\n    \n    # Populate free times between work hours\n    free_times = []\n    current_time = work_start\n    \n    while current_time < work_end:\n        # Check for clashes with busy times\n        is_busy = any(start <= current_time < end for start, end in busy_times)\n        \n        if not is_busy:\n            free_end_time = current_time + meeting_duration\n            \n            # Ensure free time is within work hours and check for clashes again\n            if free_end_time <= work_end and not any(start < free_end_time and end > current_time for start, end in busy_times):\n                free_times.append((current_time, free_end_time))\n                \n        current_time += timedelta(minutes=1)  # Check next time slot\n    \n    # Return the earliest free time found\n    if free_times:\n        earliest_time = free_times[0]\n        return f\"{earliest_time[0].strftime('%H:%M')}:{earliest_time[1].strftime('%H:%M')}\"\n    \n# Example participant schedules\nparticipants = [\n    {'name': 'Joseph', 'busy_times': [('09:00', '10:00'), ('10:30', '11:00'), ('12:30', '13:00'), ('14:30', '15:30')]},\n    {'name': 'Kyle', 'busy_times': [('12:30', '13:30')]},\n    {'name': 'Joan', 'busy_times': [('09:00', '09:30'), ('10:00', '10:30'), ('11:00', '11:30'), ('12:30', '14:00'), ('14:30', '15:00'), ('15:30', '16:00')]}\n]\n\n# Set meeting duration to 60 minutes\nmeeting_duration = 60\n\n# Find and print the meeting time\nprint(find_meeting_time(participants, meeting_duration))\n```",
            "count": "calendar_scheduling_example_97"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants_schedules, meeting_duration):\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    \n    # Convert schedules from time strings to (start, end) tuples\n    busy_times = []\n    for schedule in participants_schedules:\n        for busy_time in schedule:\n            start_time = datetime.strptime(busy_time[0], \"%H:%M\")\n            end_time = datetime.strptime(busy_time[1], \"%H:%M\")\n            busy_times.append((start_time, end_time))\n    \n    # Sort busy times\n    busy_times.sort()\n    \n    # Find free time slots\n    current_time = work_start\n    for start, end in busy_times:\n        if current_time + meeting_duration <= start:\n            return (current_time.strftime(\"%H:%M\"), (current_time + meeting_duration).strftime(\"%H:%M\"))\n        current_time = max(current_time, end)\n    \n    if current_time + meeting_duration <= work_end:\n        return (current_time.strftime(\"%H:%M\"), (current_time + meeting_duration).strftime(\"%H:%M\"))\n    \n    return None\n\n# Example usage\nparticipants_schedules = [\n    [(\"09:00\", \"10:30\"), (\"15:30\", \"16:00\")],  # Juan\n    [(\"11:00\", \"11:30\"), (\"12:30\", \"13:00\")],  # Marilyn\n    [(\"09:00\", \"10:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"13:30\"), (\"14:00\", \"16:30\")]  # Ronald\n]\nmeeting_duration = timedelta(minutes=30)\n\nproposed_time = find_meeting_time(participants_schedules, meeting_duration)\nif proposed_time:\n    print(f\"{{ {proposed_time[0]} : {proposed_time[1]} }}\")\n```",
            "count": "calendar_scheduling_example_98"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{15:00:16:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, meeting_duration, work_hours):\n    work_start, work_end = map(lambda x: datetime.strptime(x, \"%H:%M\"), work_hours)\n    meeting_duration = timedelta(minutes=meeting_duration)\n\n    # Create a list of busy times\n    busy_times = []\n    for schedule in participants.values():\n        for busy_start, busy_end in schedule:\n            busy_times.append((busy_start, busy_end))\n    \n    # Sort busy times\n    busy_times.sort()\n\n    # Merge overlapping busy times\n    merged_busy_times = []\n    current_start, current_end = busy_times[0]\n    \n    for start, end in busy_times[1:]:\n        if start <= current_end:  # Overlapping\n            current_end = max(current_end, end)\n        else:\n            merged_busy_times.append((current_start, current_end))\n            current_start, current_end = start, end\n\n    merged_busy_times.append((current_start, current_end))\n\n    # Check for available slots between work hours\n    available_start = work_start\n    for busy_start, busy_end in merged_busy_times:\n        if available_start + meeting_duration <= busy_start:\n            proposed_start = available_start\n            proposed_end = available_start + meeting_duration\n            if proposed_end <= work_end:\n                return f\"{proposed_start.strftime('%H:%M')}:{proposed_end.strftime('%H:%M')}\"\n        available_start = max(available_start, busy_end)\n    \n    # Check if there's time after the last busy interval\n    if available_start + meeting_duration <= work_end:\n        proposed_start = available_start\n        proposed_end = available_start + meeting_duration\n        return f\"{proposed_start.strftime('%H:%M')}:{proposed_end.strftime('%H:%M')}\"\n\n# Participants' schedules input\nparticipants = {\n    \"Stephanie\": [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n                  (datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\"))],\n    \"Mark\": [],\n    \"Scott\": [(datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n              (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n              (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n              (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))]\n}\n\nmeeting_duration = 60  # in minutes\nwork_hours = (\"09:00\", \"17:00\")\n\n# Call the function and print the output\nprint(find_meeting_time(participants, meeting_duration, work_hours))\n```",
            "count": "calendar_scheduling_example_99"
        }
    ]
}