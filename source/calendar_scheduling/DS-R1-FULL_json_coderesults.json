{
    "0shot": [
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert all time strings to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = map(time_to_minutes, work_hours.split(' to '))\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules.values():\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability of all participants\n    for interval in free_intervals:\n        start, end = interval\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = {\n    \"Michelle\": [\"11:00 to 12:00\"],\n    \"Steven\": [\"9:00 to 9:30\", \"11:30 to 12:00\", \"13:30 to 14:00\", \"15:30 to 16:00\"],\n    \"Jerry\": [\"9:00 to 9:30\", \"10:00 to 11:00\", \"11:30 to 12:30\", \"13:00 to 14:30\", \"15:30 to 16:00\", \"16:30 to 17:00\"]\n}\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nmeeting_duration = 60  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, meeting_duration))\n```",
            "count": "calendar_scheduling_example_0"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each participant's busy slots to minutes\n    raymond_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    billy_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (12 * 60, 13 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    donald_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 11 * 60),\n        (12 * 60, 13 * 60),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n\n    # Billy's preference: avoid after 15:00\n    billy_preference_end = 15 * 60\n\n    # Generate all possible slots\n    possible_slots = []\n    current_time = work_start\n\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        # Check if the slot is free for all and respects Billy's preference\n        raymond_free = all(not (start <= current_time < end or start < slot_end <= end) for start, end in raymond_busy)\n        billy_free = all(not (start <= current_time < end or start < slot_end <= end) for start, end in billy_busy)\n        donald_free = all(not (start <= current_time < end or start < slot_end <= end) for start, end in donald_busy)\n        billy_preference_ok = slot_end <= billy_preference_end\n\n        if raymond_free and billy_free and donald_free and billy_preference_ok:\n            possible_slots.append((current_time, slot_end))\n        \n        current_time += 30  # Check in 30-minute increments\n\n    # Select the first available slot\n    if possible_slots:\n        start, end = possible_slots[0]\n        # Convert back to HH:MM format\n        start_hh = start // 60\n        start_mm = start % 60\n        end_hh = end // 60\n        end_mm = end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_1"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define each person's busy slots in minutes since midnight\n    roy_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60)\n    ]\n    \n    kathryn_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    amy_busy = [\n        (9 * 60, 14 * 60 + 30),\n        (15 * 60, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Amy's preference: not after 15:30\n    amy_preference_end = 15 * 60 + 30\n    \n    # Generate all possible slots within work hours\n    possible_slots = []\n    current_time = work_start\n    \n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 15  # check every 15 minutes for efficiency\n    \n    # Check each slot against everyone's schedule and Amy's preference\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        \n        # Check Amy's preference\n        if slot_start >= amy_preference_end:\n            continue\n        \n        # Check Roy's availability\n        roy_available = True\n        for busy_start, busy_end in roy_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                roy_available = False\n                break\n        if not roy_available:\n            continue\n        \n        # Check Kathryn's availability\n        kathryn_available = True\n        for busy_start, busy_end in kathryn_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                kathryn_available = False\n                break\n        if not kathryn_available:\n            continue\n        \n        # Check Amy's availability\n        amy_available = True\n        for busy_start, busy_end in amy_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                amy_available = False\n                break\n        if not amy_available:\n            continue\n        \n        # If all checks passed, return this slot\n        return f\"{slot_start // 60:02d}:{slot_start % 60:02d}:{slot_end // 60:02d}:{slot_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_2"
        },
        {
            "final_program_time": "{9:30:10:30}",
            "expected_time": "{9:30:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Convert each person's busy slots to minutes\n    arthur_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 12 * 60),\n        (16 * 60, 17 * 60)\n    ]\n    michael_busy = [\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30)\n    ]\n    samantha_busy = [\n        (10 * 60 + 30, 11 * 60),\n        (12 * 60, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n\n    # Combine all busy slots and sort them\n    all_busy = arthur_busy + michael_busy + samantha_busy\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    prev_end = work_start\n\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        if end > prev_end:\n            prev_end = end\n\n    if work_end > prev_end:\n        free_slots.append((prev_end, work_end))\n\n    # Check each free slot for availability for all participants\n    for slot_start, slot_end in free_slots:\n        slot_duration = slot_end - slot_start\n        if slot_duration >= meeting_duration:\n            # Check if the slot is free for all\n            arthur_free = all(not (s < slot_start + meeting_duration and e > slot_start) for s, e in arthur_busy)\n            michael_free = all(not (s < slot_start + meeting_duration and e > slot_start) for s, e in michael_busy)\n            samantha_free = all(not (s < slot_start + meeting_duration and e > slot_start) for s, e in samantha_busy)\n\n            if arthur_free and michael_free and samantha_free:\n                # Convert minutes back to HH:MM format\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_hh = (slot_start + meeting_duration) // 60\n                end_mm = (slot_start + meeting_duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_3"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Parse work hours\n    start_work, end_work = work_hours\n    start_h, start_m = map(int, start_work.split(':'))\n    end_h, end_m = map(int, end_work.split(':'))\n    \n    # Convert work hours to minutes\n    work_start = start_h * 60 + start_m\n    work_end = end_h * 60 + end_m\n    \n    # Initialize busy slots for all participants\n    busy_slots = []\n    for busy in participants_busy:\n        slots = []\n        for slot in busy:\n            start, end = slot\n            s_h, s_m = map(int, start.split(':'))\n            e_h, e_m = map(int, end.split(':'))\n            slots.append((s_h * 60 + s_m, e_h * 60 + e_m))\n        busy_slots.append(slots)\n    \n    # Find all possible slots\n    possible_slots = []\n    current_time = work_start\n    while current_time + duration <= work_end:\n        slot_end = current_time + duration\n        valid = True\n        for participant in busy_slots:\n            for busy_start, busy_end in participant:\n                if not (slot_end <= busy_start or current_time >= busy_end):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            possible_slots.append((current_time, slot_end))\n        current_time += 15  # Check in 15-minute increments\n    \n    if not possible_slots:\n        return None\n    \n    # Return the first possible slot\n    start, end = possible_slots[0]\n    start_h = start // 60\n    start_m = start % 60\n    end_h = end // 60\n    end_m = end % 60\n    return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n\n# Define participants' busy times\nparticipants_busy = [\n    [(\"14:00\", \"14:30\"), (\"15:30\", \"16:00\")],  # Donna\n    [(\"11:00\", \"11:30\"), (\"16:30\", \"17:00\")],  # John\n    [(\"09:00\", \"10:00\"), (\"10:30\", \"14:00\"), (\"14:30\", \"17:00\")]  # Billy\n]\n\n# Define work hours and meeting duration\nwork_hours = (\"09:00\", \"17:00\")\nduration = 30  # minutes\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_4"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert blocked times to minutes since midnight\n    kathryn_blocked = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60 + 30, 14 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    charlotte_blocked = [\n        (12 * 60, 12 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    lauren_blocked = [\n        (9 * 60, 10 * 60),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60 + 30, 14 * 60 + 30),\n        (15 * 60, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    charlotte_no_meet_after = 13 * 60 + 30  # 13:30\n\n    # Generate all possible slots\n    possible_slots = []\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 1  # Check every minute\n\n    # Check each slot against constraints\n    for slot_start, slot_end in possible_slots:\n        # Check Charlotte's \"no meet after 13:30\" constraint\n        if slot_start >= charlotte_no_meet_after:\n            continue\n\n        # Check Kathryn's availability\n        kathryn_available = True\n        for block_start, block_end in kathryn_blocked:\n            if not (slot_end <= block_start or slot_start >= block_end):\n                kathryn_available = False\n                break\n        if not kathryn_available:\n            continue\n\n        # Check Charlotte's availability\n        charlotte_available = True\n        for block_start, block_end in charlotte_blocked:\n            if not (slot_end <= block_start or slot_start >= block_end):\n                charlotte_available = False\n                break\n        if not charlotte_available:\n            continue\n\n        # Check Lauren's availability\n        lauren_available = True\n        for block_start, block_end in lauren_blocked:\n            if not (slot_end <= block_start or slot_start >= block_end):\n                lauren_available = False\n                break\n        if not lauren_available:\n            continue\n\n        # If all checks passed, return this slot\n        return f\"{slot_start // 60:02d}:{slot_start % 60:02d}:{slot_end // 60:02d}:{slot_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_5"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration):\n    # Convert all time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 9:00 (0 minutes)\n    \n    # Convert work hours to minutes\n    work_start = time_to_minutes(work_hours[0])\n    work_end = time_to_minutes(work_hours[1])\n    \n    # Collect all busy times for all participants\n    all_busy_times = []\n    for busy_times in participants_busy_times:\n        for start, end in busy_times:\n            all_busy_times.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy times by start time\n    all_busy_times.sort()\n    \n    # Find free slots by merging all busy times\n    merged_busy = []\n    for start, end in all_busy_times:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Check the time before the first busy slot\n    if merged_busy and merged_busy[0][0] > work_start:\n        if merged_busy[0][0] - work_start >= duration:\n            return work_hours[0], minutes_to_time(work_start + duration)\n    \n    # Check the time between busy slots\n    for i in range(1, len(merged_busy)):\n        prev_end = merged_busy[i-1][1]\n        curr_start = merged_busy[i][0]\n        if curr_start - prev_end >= duration:\n            start_time = minutes_to_time(prev_end + 540)  # Add 540 to convert back to HH:MM\n            end_time = minutes_to_time(prev_end + duration + 540)\n            return start_time, end_time\n    \n    # Check the time after the last busy slot\n    if merged_busy and merged_busy[-1][1] < work_end:\n        if work_end - merged_busy[-1][1] >= duration:\n            start_time = minutes_to_time(merged_busy[-1][1] + 540)\n            end_time = minutes_to_time(merged_busy[-1][1] + duration + 540)\n            return start_time, end_time\n    \n    # If no busy times, the entire work hours are free\n    if not merged_busy and (work_end - work_start) >= duration:\n        return work_hours[0], minutes_to_time(work_start + duration + 540)\n    \n    return None\n\ndef minutes_to_time(minutes):\n    hh = (minutes) // 60\n    mm = (minutes) % 60\n    return f\"{hh:02d}:{mm:02d}\"\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 60  # minutes\n\n# Define participants' busy times in HH:MM format\nparticipants_busy_times = [\n    [],  # Thomas has no busy times\n    [(\"10:30\", \"11:00\"), (\"13:30\", \"14:00\")],  # Dylan's busy times\n    [(\"9:00\", \"11:00\"), (\"11:30\", \"14:30\"), (\"16:00\", \"17:00\")],  # Jerry's busy times\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours, duration)\n\n# Format the output as HH:MM:HH:MM\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{start}:{end}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_6"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each participant's blocked times to minutes since 9:00\n    heather_blocked = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 11 * 60),\n        (13 * 60, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    nicholas_blocked = []  # No meetings\n    zachary_blocked = [\n        (9 * 60, 10 * 60 + 30),\n        (11 * 60, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 16 * 60 + 30)\n    ]\n    zachary_preference_end = 14 * 60  # Prefers not to meet after 14:00\n\n    # Combine all blocked times for each participant\n    blocked_times = {\n        'Heather': heather_blocked,\n        'Nicholas': nicholas_blocked,\n        'Zachary': zachary_blocked\n    }\n\n    # Find all possible slots that work for everyone\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        # Check if the slot is before Zachary's preference\n        if slot_end > zachary_preference_end:\n            current_time += 1\n            continue\n        # Check if the slot is free for all participants\n        all_free = True\n        for participant, blocks in blocked_times.items():\n            for block_start, block_end in blocks:\n                if not (slot_end <= block_start or current_time >= block_end):\n                    all_free = False\n                    break\n            if not all_free:\n                break\n        if all_free:\n            # Convert back to HH:MM format\n            start_hh = current_time // 60\n            start_mm = current_time % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n        current_time += 1  # Increment by 1 minute to check next slot\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_7"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes, work_start, work_end):\n    # Convert all time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start_min\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n    \n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nadam_schedule = [\n    \"10:00 to 10:30\",\n    \"12:30 to 13:00\",\n    \"13:30 to 14:30\"\n]\n\njerry_schedule = [\n    \"09:00 to 09:30\",\n    \"12:00 to 12:30\",\n    \"15:00 to 16:00\"\n]\n\nmatthew_schedule = [\n    \"09:30 to 11:00\",\n    \"11:30 to 12:30\",\n    \"13:00 to 14:00\",\n    \"14:30 to 17:00\"\n]\n\n# Combine all schedules\nparticipants_schedules = [adam_schedule, jerry_schedule, matthew_schedule]\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, 30, \"09:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_8"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\ndiane_schedule = [\n    \"9:00 to 9:30\",\n    \"12:00 to 12:30\",\n    \"14:30 to 15:30\"\n]\n\nkelly_schedule = [\n    \"9:30 to 10:00\",\n    \"10:30 to 11:00\"\n]\n\ndeborah_schedule = [\n    \"9:00 to 9:30\",\n    \"10:00 to 14:00\",\n    \"14:30 to 17:00\"\n]\n\n# Combine all schedules\nparticipants_schedules = [diane_schedule, kelly_schedule, deborah_schedule]\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_9"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define busy slots for each participant in minutes since midnight\n    diana_busy = [(11 * 60 + 30, 12 * 60), (13 * 60, 13 * 60 + 30)]\n    ethan_busy = []  # No meetings\n    janet_busy = [(9 * 60, 10 * 60), (12 * 60 + 30, 13 * 60), (14 * 60, 15 * 60), (15 * 60 + 30, 17 * 60)]\n    janet_preference_end = 12 * 60  # Janet doesn't want to meet after 12:00\n\n    # Combine all busy slots and sort them\n    all_busy = diana_busy + ethan_busy + janet_busy\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check each free slot for availability and Janet's preference\n    for slot_start, slot_end in free_slots:\n        # Calculate the latest possible start time in this slot\n        latest_start = slot_end - meeting_duration\n        if latest_start >= slot_start:\n            # The slot can accommodate the meeting\n            actual_start = max(slot_start, latest_start)\n            actual_end = actual_start + meeting_duration\n            # Check Janet's preference (not after 12:00)\n            if actual_end <= janet_preference_end:\n                # Format the time as HH:MM:HH:MM\n                return f\"{actual_start // 60:02d}:{actual_start % 60:02d}:{actual_end // 60:02d}:{actual_end % 60:02d}\"\n\n    # If no slot found (though the problem states there is one)\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_10"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert all time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's busy slots\n    for busy_slots in participants_busy:\n        new_free_slots = []\n        for busy_start, busy_end in busy_slots:\n            busy_start_min = time_to_minutes(busy_start)\n            busy_end_min = time_to_minutes(busy_end)\n            temp_slots = []\n            for slot_start, slot_end in free_slots:\n                if busy_end_min <= slot_start or busy_start_min >= slot_end:\n                    # No overlap, keep the slot as is\n                    temp_slots.append((slot_start, slot_end))\n                else:\n                    # There is an overlap, split the slot\n                    if slot_start < busy_start_min:\n                        temp_slots.append((slot_start, busy_start_min))\n                    if slot_end > busy_end_min:\n                        temp_slots.append((busy_end_min, slot_end))\n            free_slots = temp_slots\n        if not free_slots:\n            return None  # No possible slot\n    \n    # Now find the intersection of all free slots (already done in the loop)\n    # Check if any remaining slot can fit the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return (minutes_to_time(meeting_start), minutes_to_time(meeting_end))\n    \n    return None\n\n# Define the participants' busy times\nparticipants_busy = [\n    [(\"09:30\", \"10:00\"), (\"10:30\", \"11:00\"), (\"12:30\", \"13:00\"), (\"14:30\", \"15:00\"), (\"16:00\", \"17:00\")],  # Alexander\n    [(\"09:00\", \"09:30\"), (\"11:30\", \"12:30\"), (\"13:00\", \"14:30\")],  # Elizabeth\n    [(\"09:00\", \"14:30\"), (\"15:30\", \"17:00\")]  # Walter\n]\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nmeeting_duration = 30  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, meeting_duration)\n\n# Output the result in the required format\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{start}:{end}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_11"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:14:00}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert all time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = work_hours\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start_min, work_end_min)]\n    \n    # Process each participant's schedule to find common free slots\n    for schedule in participents_schedules:\n        busy_slots = []\n        for slot in schedule:\n            start, end = map(time_to_minutes, slot.split(':'))\n            busy_slots.append((start, end))\n        # Sort the busy slots by start time\n        busy_slots.sort()\n        # Merge overlapping or adjacent busy slots\n        merged_busy = []\n        for start, end in busy_slots:\n            if not merged_busy:\n                merged_busy.append((start, end))\n            else:\n                last_start, last_end = merged_busy[-1]\n                if start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = last_start\n                    new_end = max(last_end, end)\n                    merged_busy[-1] = (new_start, new_end)\n                else:\n                    merged_busy.append((start, end))\n        # Calculate free slots for this participant\n        participant_free = []\n        prev_end = work_start_min\n        for start, end in merged_busy:\n            if start > prev_end:\n                participant_free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end_min:\n            participant_free.append((prev_end, work_end_min))\n        # Intersect with current free slots\n        new_free_slots = []\n        i = j = 0\n        while i < len(free_slots) and j < len(participant_free):\n            fs_start, fs_end = free_slots[i]\n            pf_start, pf_end = participant_free[j]\n            # Find the overlap\n            overlap_start = max(fs_start, pf_start)\n            overlap_end = min(fs_end, pf_end)\n            if overlap_start < overlap_end:\n                new_free_slots.append((overlap_start, overlap_end))\n            # Move the pointer which ends first\n            if fs_end < pf_end:\n                i += 1\n            else:\n                j += 1\n        free_slots = new_free_slots\n    \n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= duration_min:\n            meeting_end = start + duration_min\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    return \"No suitable time found\"\n\n# Define the schedules and constraints\nparticipants_schedules = [\n    [],  # David has no meetings\n    [\"09:30:10:00\", \"11:00:11:30\", \"12:00:13:00\", \"14:00:14:30\", \"16:00:16:30\"],  # Debra\n    [\"09:00:12:00\", \"14:00:17:00\"],  # Kevin\n]\nwork_hours = (\"09:00\", \"17:00\")\nduration = 1  # hour\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_12"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Gerald's busy slots in minutes (9:00-9:30, 13:00-14:00, 15:00-15:30, 16:00-17:00)\n    gerald_busy = [(9*60, 9*60 + 30), (13*60, 14*60), (15*60, 15*60 + 30), (16*60, 17*60)]\n    # Gerald prefers no meetings before 13:00\n    gerald_preferred_start = 13 * 60\n\n    # Barbara's busy slots in minutes (9:30-10:00, 11:30-14:00, 14:30-15:00, 15:30-17:00)\n    barbara_busy = [(9*60 + 30, 10*60), (11*60 + 30, 14*60), (14*60 + 30, 15*60), (15*60 + 30, 17*60)]\n\n    # Roy is free all day, so no constraints\n\n    # Generate all possible slots starting from 13:00 to 17:00 - meeting_duration\n    possible_slots = []\n    current_time = max(work_start, gerald_preferred_start)\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        # Check if the slot is free for Gerald and Barbara\n        gerald_free = True\n        for start, end in gerald_busy:\n            if not (slot_end <= start or current_time >= end):\n                gerald_free = False\n                break\n        barbara_free = True\n        for start, end in barbara_busy:\n            if not (slot_end <= start or current_time >= end):\n                barbara_free = False\n                break\n        if gerald_free and barbara_free:\n            possible_slots.append((current_time, slot_end))\n        current_time += 15  # Check every 15 minutes\n\n    # Select the first available slot\n    if possible_slots:\n        start, end = possible_slots[0]\n        # Convert back to HH:MM format\n        start_hh = start // 60\n        start_mm = start % 60\n        end_hh = end // 60\n        end_mm = end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_13"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' schedules and constraints\n    brandon_busy = [\n        (13 * 60, 14 * 60),    # 13:00-14:00\n        (15 * 60 + 30, 16 * 60),  # 15:30-16:00\n        (16 * 60 + 30, 17 * 60)   # 16:30-17:00\n    ]\n    brandon_preference_start = 14 * 60 + 30  # 14:30\n\n    jerry_busy = []  # No meetings\n\n    bradley_busy = [\n        (9 * 60, 11 * 60 + 30),  # 9:00-11:30\n        (12 * 60, 15 * 60),      # 12:00-15:00\n        (16 * 60, 16 * 60 + 30)   # 16:00-16:30\n    ]\n\n    # Combine all busy times and sort\n    all_busy = brandon_busy + bradley_busy  # Jerry has no busy times\n    all_busy.sort()\n\n    # Find available slots\n    available_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n\n    # Filter slots based on duration (30 minutes) and Brandon's preference\n    meeting_duration = 30\n    valid_slots = []\n\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration:\n            actual_start = max(slot_start, brandon_preference_start)\n            if actual_start + meeting_duration <= slot_end:\n                valid_slots.append((actual_start, actual_start + meeting_duration))\n\n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start, meeting_end = valid_slots[0]\n    else:\n        return None\n\n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n\n    start_time = minutes_to_time(meeting_start)\n    end_time = minutes_to_time(meeting_end)\n\n    return f\"{start_time}:{end_time}\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_14"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Define participants' schedules and constraints\n    joyce_busy = [\n        (11 * 60, 11 * 60 + 30),    # 11:00-11:30\n        (13 * 60 + 30, 14 * 60),    # 13:30-14:00\n        (14 * 60 + 30, 16 * 60 + 30) # 14:30-16:30\n    ]\n    christine_busy = []  # No meetings\n    christine_constraint = (12 * 60, work_end)  # Can't meet before 12:00\n    alexander_busy = [\n        (9 * 60, 11 * 60),          # 9:00-11:00\n        (12 * 60, 12 * 60 + 30),    # 12:00-12:30\n        (13 * 60 + 30, 15 * 60),    # 13:30-15:00\n        (15 * 60 + 30, 16 * 60),    # 15:30-16:00\n        (16 * 60 + 30, 17 * 60)    # 16:30-17:00\n    ]\n\n    # Meeting duration in minutes\n    duration = 30\n\n    # Generate all possible slots\n    possible_slots = []\n    current_time = work_start\n\n    while current_time + duration <= work_end:\n        slot_start = current_time\n        slot_end = current_time + duration\n\n        # Check Christine's constraint (can't meet before 12:00)\n        if slot_start < 12 * 60:\n            current_time += 15  # Check in 15-minute increments\n            continue\n\n        # Check Joyce's availability\n        joyce_available = True\n        for busy_start, busy_end in joyce_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                joyce_available = False\n                break\n\n        # Check Alexander's availability\n        alexander_available = True\n        for busy_start, busy_end in alexander_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                alexander_available = False\n                break\n\n        # If all are available, add the slot\n        if joyce_available and alexander_available:\n            possible_slots.append((slot_start, slot_end))\n\n        current_time += 15  # Check in 15-minute increments\n\n    # Select the first available slot\n    if possible_slots:\n        meeting_start, meeting_end = possible_slots[0]\n        # Convert minutes back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        print(f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\")\n    else:\n        print(\"No available time slot found.\")\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_15"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work_hours start at 9:00\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = 9 + minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split('-')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Initialize free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's schedule to find common free slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = busy.split('-')\n            busy_start = time_to_minutes(start)\n            busy_end = time_to_minutes(end)\n            busy_slots.append((busy_start, busy_end))\n        \n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Calculate free slots for this participant\n        current_free = []\n        prev_end = work_start\n        for start, end in busy_slots:\n            if start > prev_end:\n                current_free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            current_free.append((prev_end, work_end))\n        \n        # Intersect current_free with existing free_slots\n        new_free_slots = []\n        i = j = 0\n        while i < len(free_slots) and j < len(current_free):\n            start1, end1 = free_slots[i]\n            start2, end2 = current_free[j]\n            \n            # Find overlapping interval\n            start = max(start1, start2)\n            end = min(end1, end2)\n            if start < end:\n                new_free_slots.append((start, end))\n            \n            # Move the pointer which ends first\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        \n        free_slots = new_free_slots\n    \n    # Find the first slot that can fit the meeting duration\n    duration_min = duration * 60\n    for start, end in free_slots:\n        if end - start >= duration_min:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration_min)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"09:30-10:30\", \"13:30-14:00\", \"14:30-15:00\", \"15:30-16:00\", \"16:30-17:00\"],  # Scott\n    [],  # Gabriel\n    [\"09:00-10:00\", \"10:30-12:30\", \"13:00-17:00\"],  # Christine\n]\n\n# Define meeting duration in hours (0.5 hours = 30 minutes)\nduration = 0.5\nwork_hours = \"9:00-17:00\"\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_16"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Convert blocked times to minutes since midnight\n    margaret_blocked = [\n        (9 * 60, 10 * 60),    # 9:00-10:00\n        (10 * 60 + 30, 11 * 60),  # 10:30-11:00\n        (11 * 60 + 30, 12 * 60),  # 11:30-12:00\n        (13 * 60, 13 * 60 + 30),  # 13:00-13:30\n        (15 * 60, 15 * 60 + 30)   # 15:00-15:30\n    ]\n    donna_blocked = [\n        (14 * 60 + 30, 15 * 60),  # 14:30-15:00\n        (16 * 60, 16 * 60 + 30)   # 16:00-16:30\n    ]\n    helen_blocked = [\n        (9 * 60, 9 * 60 + 30),    # 9:00-9:30\n        (10 * 60, 11 * 60 + 30),  # 10:00-11:30\n        (13 * 60, 14 * 60),        # 13:00-14:00\n        (14 * 60 + 30, 15 * 60),  # 14:30-15:00\n        (15 * 60 + 30, 17 * 60)   # 15:30-17:00\n    ]\n    helen_no_meet_after = 13 * 60 + 30  # 13:30\n\n    meeting_duration = 30  # minutes\n\n    # Combine all blocked times and sort them\n    all_blocked = []\n    for start, end in margaret_blocked:\n        all_blocked.append((start, end, 'Margaret'))\n    for start, end in donna_blocked:\n        all_blocked.append((start, end, 'Donna'))\n    for start, end in helen_blocked:\n        all_blocked.append((start, end, 'Helen'))\n    all_blocked.sort()\n\n    # Find available slots\n    available_slots = []\n    current_time = work_start\n\n    for start, end, person in all_blocked:\n        if start > current_time:\n            available_slots.append((current_time, start))\n        current_time = max(current_time, end)\n    if current_time < work_end:\n        available_slots.append((current_time, work_end))\n\n    # Filter slots based on Helen's preference (before 13:30)\n    filtered_slots = []\n    for start, end in available_slots:\n        if end <= helen_no_meet_after:\n            filtered_slots.append((start, end))\n\n    # Find the first slot that fits the meeting duration\n    for start, end in filtered_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_17"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Billy's busy slots in minutes\n    billy_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    # Patricia's busy slots in minutes\n    patricia_busy = [\n        (9 * 60, 12 * 60 + 30),\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    # Billy's preference to avoid meetings after 15:30\n    billy_preference_end = 15 * 60 + 30\n\n    # Generate all possible meeting slots\n    possible_slots = []\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        # Check if the slot works for everyone\n        billy_free = all(not (start < slot_end and end > current_time) for start, end in billy_busy)\n        patricia_free = all(not (start < slot_end and end > current_time) for start, end in patricia_busy)\n        # Check Billy's preference\n        billy_preference_ok = slot_end <= billy_preference_end\n        if billy_free and patricia_free and billy_preference_ok:\n            possible_slots.append((current_time, slot_end))\n        current_time += 30  # Check every 30 minutes\n\n    # Select the first available slot\n    if possible_slots:\n        start, end = possible_slots[0]\n        # Convert minutes back to HH:MM format\n        start_hh = start // 60\n        start_mm = start % 60\n        end_hh = end // 60\n        end_mm = end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_18"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration_hours):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_hours * 60\n    \n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy_times in participants_busy_times:\n        for interval in busy_times:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Check the available slots between work hours and busy intervals\n    prev_end = work_start\n    available_slots = []\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define the participants' busy times\nstephen_busy = [\"10:00 to 10:30\", \"13:00 to 13:30\", \"14:30 to 15:00\", \"16:00 to 16:30\"]\nedward_busy = [\"9:00 to 9:30\", \"10:00 to 10:30\", \"13:30 to 14:30\", \"15:00 to 16:00\"]\nangela_busy = [\"9:00 to 11:30\", \"12:30 to 13:00\", \"13:30 to 15:30\", \"16:00 to 17:00\"]\n\n# Combine all busy times\nparticipants_busy_times = [stephen_busy, edward_busy, angela_busy]\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_hours = 1\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_19"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert each person's busy slots to minutes\n    ralph_busy = [\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60)\n    ]\n    peter_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (11 * 60, 13 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    daniel_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 15 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n    daniel_preference = 13 * 60 + 30  # Prefers no meetings after 13:30\n\n    # Combine all busy slots\n    all_busy = ralph_busy + peter_busy + daniel_busy\n    all_busy.sort()  # Sort by start time\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check each free slot for a 30-minute window that fits all constraints\n    meeting_duration = 30\n    for slot_start, slot_end in free_slots:\n        current_start = slot_start\n        while current_start + meeting_duration <= slot_end:\n            current_end = current_start + meeting_duration\n            # Check if it's before Daniel's preference (13:30)\n            if current_end <= daniel_preference:\n                return f\"{current_start // 60:02d}:{current_start % 60:02d}:{current_end // 60:02d}:{current_end % 60:02d}\"\n            current_start += 1  # Increment by 1 minute to check next possible slot\n\n    # If no slot found before preference, check after (though not preferred)\n    for slot_start, slot_end in free_slots:\n        current_start = slot_start\n        while current_start + meeting_duration <= slot_end:\n            current_end = current_start + meeting_duration\n            return f\"{current_start // 60:02d}:{current_start % 60:02d}:{current_end // 60:02d}:{current_end % 60:02d}\"\n            current_start += 1\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_20"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration):\n    # Convert all time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 (9:00)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    work_start, work_end = work_hours.split(' to ')\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Generate all busy intervals in minutes\n    all_busy = []\n    for busy_times in participants_busy_times.values():\n        for busy in busy_times:\n            start, end = busy.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            all_busy.append((start_min, end_min))\n    \n    # Sort all busy intervals\n    all_busy.sort()\n    \n    # Find free intervals\n    free_intervals = []\n    prev_end = work_start_min\n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n    \n    # Find the first free interval that can fit the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' busy times\nparticipants_busy_times = {\n    'Bobby': [],\n    'Scott': ['11:30 to 12:00', '15:30 to 16:00'],\n    'Kimberly': ['11:00 to 12:00', '12:30 to 13:00', '13:30 to 14:00', '14:30 to 15:00', '15:30 to 17:00']\n}\n\n# Define work hours and meeting duration\nwork_hours = '9:00 to 17:00'\nmeeting_duration = 60  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy_times, work_hours, meeting_duration))\n```",
            "count": "calendar_scheduling_example_21"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    duration = 60        # 1 hour in minutes\n\n    # Convert each person's busy times to minutes since midnight\n    theresa_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (12 * 60 + 30, 13 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    charles_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (14 * 60, 15 * 60 + 30)\n    ]\n    betty_busy = [\n        (9 * 60, 10 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 14 * 60),\n        (15 * 60, 16 * 60)\n    ]\n\n    # Combine all busy times into a single list\n    all_busy = theresa_busy + charles_busy + betty_busy\n\n    # Sort busy times by start time\n    all_busy.sort()\n\n    # Find the earliest available slot\n    current_time = work_start\n    for busy_start, busy_end in all_busy:\n        if busy_start > current_time:\n            if busy_start - current_time >= duration:\n                # Found a slot\n                end_time = current_time + duration\n                return f\"{current_time // 60:02d}:{current_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n        if busy_end > current_time:\n            current_time = busy_end\n\n    # Check after the last busy slot\n    if work_end - current_time >= duration:\n        end_time = current_time + duration\n        return f\"{current_time // 60:02d}:{current_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n\n    return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_22"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = work_hours\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = busy\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            busy_intervals.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start_min\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        available_slots.append((prev_end, work_end_min))\n    \n    # Check each available slot for sufficient duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [(\"11:30\", \"12:00\"), (\"13:00\", \"15:00\"), (\"16:00\", \"16:30\")],  # Billy\n    [(\"09:00\", \"09:30\"), (\"10:00\", \"10:30\"), (\"13:00\", \"13:30\"), (\"14:00\", \"14:30\")],  # Maria\n    [(\"09:30\", \"10:00\"), (\"12:00\", \"12:30\"), (\"13:30\", \"15:00\"), (\"15:30\", \"17:00\")],  # William\n]\n\n# Define work hours and meeting duration\nwork_hours = (\"09:00\", \"17:00\")\nduration = 1  # hour\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_23"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define Brenda's busy slots in minutes\n    brenda_busy = [\n        (9 * 60 + 30, 10 * 60),      # 9:30 to 10:00\n        (11 * 60 + 30, 12 * 60 + 30), # 11:30 to 12:30\n        (14 * 60, 16 * 60 + 30)       # 14:00 to 16:30\n    ]\n    \n    # Benjamin's constraint: cannot meet after 9:30\n    benjamin_constraint = 9 * 60 + 30  # 9:30 in minutes\n    \n    # Generate all possible 30-minute slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + 30 <= work_end:\n        slot_end = current_time + 30\n        # Check if the slot is before Benjamin's constraint\n        if slot_end <= benjamin_constraint:\n            # Check if Brenda is free during this slot\n            brenda_free = True\n            for busy_start, busy_end in brenda_busy:\n                if not (slot_end <= busy_start or current_time >= busy_end):\n                    brenda_free = False\n                    break\n            if brenda_free:\n                possible_slots.append((current_time, slot_end))\n        current_time += 15  # Check every 15 minutes for flexibility\n    \n    # Select the first available slot\n    if possible_slots:\n        meeting_start, meeting_end = possible_slots[0]\n        # Convert minutes back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_24"
        },
        {
            "final_program_time": "{13:30:14:30}",
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define busy intervals in minutes for each participant\n    anthony_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (12 * 60, 13 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    pamela_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    zachary_busy = [\n        (9 * 60, 11 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60, 17 * 60)\n    ]\n\n    # Pamela's constraint: no meetings after 14:30\n    pamela_no_meet_after = 14 * 60 + 30\n\n    # Meeting duration in minutes\n    duration = 60\n\n    # Generate all possible slots within work hours\n    possible_slots = []\n    current_start = work_start\n    while current_start + duration <= work_end:\n        possible_slots.append((current_start, current_start + duration))\n        current_start += 30  # Check every 30 minutes for efficiency\n\n    # Check each slot against all constraints\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n\n        # Check Pamela's time constraint\n        if slot_start >= pamela_no_meet_after:\n            continue\n\n        # Check Anthony's availability\n        anthony_available = True\n        for busy_start, busy_end in anthony_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                anthony_available = False\n                break\n        if not anthony_available:\n            continue\n\n        # Check Pamela's availability\n        pamela_available = True\n        for busy_start, busy_end in pamela_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                pamela_available = False\n                break\n        if not pamela_available:\n            continue\n\n        # Check Zachary's availability\n        zachary_available = True\n        for busy_start, busy_end in zachary_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                zachary_available = False\n                break\n        if not zachary_available:\n            continue\n\n        # If all checks passed, return this slot\n        return f\"{slot_start // 60:02d}:{slot_start % 60:02d}:{slot_end // 60:02d}:{slot_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_25"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:30:16:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(schedules, duration, work_start, work_end):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for person in schedules:\n        for interval in schedules[person]:\n            start, end = map(time_to_minutes, interval.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start_min\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        available_slots.append((prev_end, work_end_min))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define the schedules\nschedules = {\n    \"Katherine\": [],\n    \"Nicole\": [],\n    \"Kevin\": [\"9:00:10:00\", \"10:30:11:30\", \"12:00:15:30\", \"16:30:17:00\"]\n}\n\n# Find a 1-hour meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(schedules, 1, \"9:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_26"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability\n    duration_min = duration * 60\n    for start, end in free_intervals:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"10:00 to 10:30\", \"15:30 to 16:00\"],  # Jesse\n    [],                                    # Kathryn\n    [\"10:30 to 11:00\", \"11:30 to 12:30\", \"13:30 to 14:30\", \"15:00 to 16:30\"]  # Megan\n]\n\n# Define meeting parameters\nmeeting_duration = 30  # minutes\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\n\n# Find the earliest available meeting time\nmeeting_time = find_meeting_time(participants_schedules, meeting_duration, work_hours_start, work_hours_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_27"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_start=\"09:00\", work_end=\"17:00\"):\n    # Convert time strings to minutes since 00:00 for easier calculations\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Initialize the busy slots for all participants\n    busy_slots = []\n    for schedule in participants_schedules:\n        person_busy = []\n        for slot in schedule:\n            start, end = map(time_to_minutes, slot.split(' to '))\n            person_busy.append((start, end))\n        busy_slots.append(person_busy)\n    \n    # Find all possible meeting slots that fit within work hours\n    possible_slots = []\n    current_time = work_start_min\n    \n    while current_time + duration_minutes <= work_end_min:\n        slot_end = current_time + duration_minutes\n        valid = True\n        \n        # Check if the slot is free for all participants\n        for person_busy in busy_slots:\n            for start, end in person_busy:\n                if not (slot_end <= start or current_time >= end):\n                    valid = False\n                    break\n            if not valid:\n                break\n        \n        if valid:\n            possible_slots.append((current_time, slot_end))\n        \n        current_time += 15  # Check in 15-minute increments\n    \n    if not possible_slots:\n        return None\n    \n    # Find the earliest available slot\n    earliest_slot = possible_slots[0]\n    start_min, end_min = earliest_slot\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_time = minutes_to_time(start_min)\n    end_time = minutes_to_time(end_min)\n    \n    return f\"{start_time}:{end_time}\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"13:00 to 13:30\", \"16:00 to 16:30\"],  # Brittany\n    [],                                    # Emily (free all day)\n    [\"09:00 to 11:00\", \"11:30 to 14:30\", \"15:00 to 17:00\"],  # Doris\n]\n\n# Find the earliest meeting time\nmeeting_time = find_meeting_time(participants_schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_28"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:00:13:00}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    # Initialize the free slots within work hours\n    start_work = time_to_minutes(work_hours[0])\n    end_work = time_to_minutes(work_hours[1])\n    free_slots = [(start_work, end_work)]\n\n    # Function to subtract busy slots from free slots\n    def subtract_busy_slots(free_slots, busy_start, busy_end):\n        new_slots = []\n        for slot_start, slot_end in free_slots:\n            if busy_start >= slot_end or busy_end <= slot_start:\n                new_slots.append((slot_start, slot_end))\n            else:\n                if slot_start < busy_start:\n                    new_slots.append((slot_start, busy_start))\n                if slot_end > busy_end:\n                    new_slots.append((busy_end, slot_end))\n        return new_slots\n\n    # Process each participant's schedule\n    for schedule in participents_schedules:\n        for busy in schedule:\n            busy_start = time_to_minutes(busy[0])\n            busy_end = time_to_minutes(busy[1])\n            free_slots = subtract_busy_slots(free_slots, busy_start, busy_end)\n\n    # Find the first slot that can fit the duration\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No suitable time found\"\n\n# Define the participants' schedules\nmadison_schedule = [(\"09:30\", \"10:00\"), (\"11:30\", \"12:00\")]\ndiana_schedule = [(\"11:00\", \"11:30\"), (\"13:00\", \"13:30\")]\nshirley_schedule = [(\"09:00\", \"12:00\"), (\"13:30\", \"15:00\"), (\"15:30\", \"17:00\")]\n\nparticipants_schedules = [madison_schedule, diana_schedule, shirley_schedule]\nwork_hours = (\"09:00\", \"17:00\")\nduration = 60  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_29"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy times in minutes since midnight\n    jeffrey_busy = [\n        (9 * 60 + 30, 10 * 60),    # 9:30-10:00\n        (10 * 60 + 30, 11 * 60)    # 10:30-11:00\n    ]\n    \n    virginia_busy = [\n        (9 * 60, 9 * 60 + 30),     # 9:00-9:30\n        (10 * 60, 10 * 60 + 30),   # 10:00-10:30\n        (14 * 60 + 30, 15 * 60),   # 14:30-15:00\n        (16 * 60, 16 * 60 + 30)    # 16:00-16:30\n    ]\n    \n    melissa_busy = [\n        (9 * 60, 11 * 60 + 30),    # 9:00-11:30\n        (12 * 60, 12 * 60 + 30),   # 12:00-12:30\n        (13 * 60, 15 * 60),        # 13:00-15:00\n        (16 * 60, 17 * 60)         # 16:00-17:00\n    ]\n    \n    # Melissa's preference: not after 14:00\n    preference_end = 14 * 60\n    \n    # Meeting duration in minutes\n    duration = 30\n    \n    # Generate all possible slots within work hours, considering Melissa's preference\n    possible_slots = []\n    current_time = work_start\n    \n    while current_time + duration <= min(work_end, preference_end):\n        # Check if the slot is free for all participants\n        jeffrey_free = all(not (start <= current_time < end or start < current_time + duration <= end) \n                           for start, end in jeffrey_busy)\n        virginia_free = all(not (start <= current_time < end or start < current_time + duration <= end) \n                           for start, end in virginia_busy)\n        melissa_free = all(not (start <= current_time < end or start < current_time + duration <= end) \n                          for start, end in melissa_busy)\n        \n        if jeffrey_free and virginia_free and melissa_free:\n            possible_slots.append((current_time, current_time + duration))\n        \n        current_time += 15  # Check every 15 minutes for efficiency\n    \n    # Select the first available slot\n    if possible_slots:\n        start, end = possible_slots[0]\n        # Convert minutes back to HH:MM format\n        start_hh = start // 60\n        start_mm = start % 60\n        end_hh = end // 60\n        end_mm = end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_30"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each participant's busy times to minutes since midnight\n    richard_busy = [\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    martha_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (13 * 60, 13 * 60 + 30)\n    ]\n    kimberly_busy = [\n        (9 * 60, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60, 16 * 60)\n    ]\n\n    # Martha's preference: not before 14:00\n    martha_preference_start = 14 * 60\n\n    # Combine all busy times and sort\n    all_busy = []\n    for start, end in richard_busy:\n        all_busy.append((start, end, 'Richard'))\n    for start, end in martha_busy:\n        all_busy.append((start, end, 'Martha'))\n    for start, end in kimberly_busy:\n        all_busy.append((start, end, 'Kimberly'))\n    all_busy.sort()\n\n    # Find available slots\n    available_slots = []\n    current_time = max(work_start, martha_preference_start)\n\n    while current_time + meeting_duration <= work_end:\n        conflict = False\n        for busy_start, busy_end, person in all_busy:\n            if not (current_time + meeting_duration <= busy_start or current_time >= busy_end):\n                conflict = True\n                current_time = busy_end\n                break\n        if not conflict:\n            available_slots.append((current_time, current_time + meeting_duration))\n            current_time += meeting_duration\n\n    # Return the first available slot\n    if available_slots:\n        start, end = available_slots[0]\n        start_hr = start // 60\n        start_min = start % 60\n        end_hr = end // 60\n        end_min = end % 60\n        return f\"{start_hr:02d}:{start_min:02d}:{end_hr:02d}:{end_min:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_31"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' busy times in minutes since midnight\n    emily_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    melissa_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (14 * 60 + 30, 15 * 60)\n    ]\n    frank_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60 + 30),\n        (15 * 60, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    # Frank's constraint: doesn't want to meet after 9:30 (but his busy times already reflect this)\n    # Meeting duration is 30 minutes\n    duration = 30\n\n    # Combine all busy times and sort them\n    all_busy = emily_busy + melissa_busy + frank_busy\n    all_busy.sort()\n\n    # Find the earliest available slot\n    previous_end = work_start\n    for start, end in all_busy:\n        if start > previous_end and (start - previous_end) >= duration:\n            # Check if the slot is before Frank's constraint (before or at 9:30)\n            if previous_end <= 9 * 60 + 30 - duration:\n                return format_time(previous_end, previous_end + duration)\n        previous_end = max(previous_end, end)\n    \n    # Check after the last busy slot\n    if work_end - previous_end >= duration and previous_end <= 9 * 60 + 30 - duration:\n        return format_time(previous_end, previous_end + duration)\n    \n    # If no slot found (though the problem states there is one)\n    return \"No time found\"\n\ndef format_time(start_min, end_min):\n    start_h = start_min // 60\n    start_m = start_min % 60\n    end_h = end_min // 60\n    end_m = end_min % 60\n    return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n\n# Execute and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_32"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define each person's busy times in minutes (start, end)\n    lisa_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    bobby_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    randy_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n\n    # Bobby's preference: avoid after 15:00\n    bobby_preference_end = 15 * 60\n\n    # Combine all busy times and sort them\n    all_busy = lisa_busy + bobby_busy + randy_busy\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Add the slot after the last busy time if within work hours\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Filter free slots that are at least 30 minutes and respect Bobby's preference\n    meeting_duration = 30\n    valid_slots = []\n\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Check if the slot is entirely before Bobby's preference end time\n            if end <= bobby_preference_end:\n                valid_slots.append((start, end))\n            # Or if the slot starts early enough to fit the meeting before preference\n            elif start <= bobby_preference_end - meeting_duration:\n                valid_slots.append((start, min(end, bobby_preference_end)))\n\n    # Find the earliest valid slot\n    if valid_slots:\n        earliest_slot = min(valid_slots)\n        meeting_start = earliest_slot[0]\n        meeting_end = meeting_start + meeting_duration\n    else:\n        # If no slot before preference, check all free slots (though problem states a solution exists)\n        for start, end in free_slots:\n            if end - start >= meeting_duration:\n                meeting_start = start\n                meeting_end = start + meeting_duration\n                break\n\n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n\n    start_time = minutes_to_time(meeting_start)\n    end_time = minutes_to_time(meeting_end)\n\n    return f\"{start_time}:{end_time}\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_33"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert all time strings to minutes since start of the day\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Initialize the free time slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Function to subtract busy slots from free slots\n    def subtract_busy(free_slots, busy_start, busy_end):\n        new_slots = []\n        for start, end in free_slots:\n            if busy_end <= start or busy_start >= end:\n                new_slots.append((start, end))\n            else:\n                if start < busy_start:\n                    new_slots.append((start, busy_start))\n                if end > busy_end:\n                    new_slots.append((busy_end, end))\n        return new_slots\n    \n    # Process each participant's busy slots\n    for busy_slots in participants_busy:\n        for busy in busy_slots:\n            busy_start, busy_end = map(time_to_minutes, busy.split(' to '))\n            free_slots = subtract_busy(free_slots, busy_start, busy_end)\n    \n    # Find the first free slot that can accommodate the meeting\n    duration_min = duration * 60\n    for start, end in free_slots:\n        if end - start >= duration_min:\n            meeting_end = start + duration_min\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' busy slots\nparticipants_busy = [\n    [\"10:00 to 10:30\", \"11:00 to 12:00\", \"13:00 to 14:00\", \"16:00 to 16:30\"],  # Richard\n    [\"10:00 to 10:30\", \"11:30 to 13:00\", \"13:30 to 14:00\", \"14:30 to 17:00\"],  # Noah\n]\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nduration = 1  # hour\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_34"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' schedules and constraints in minutes\n    # Bradley: free all day but doesn't want to meet before 14:30\n    bradley_constraint = 14 * 60 + 30  # 14:30 in minutes\n    \n    # Zachary's meetings\n    zachary_busy = [\n        (10 * 60, 10 * 60 + 30),   # 10:00-10:30\n        (15 * 60, 15 * 60 + 30)     # 15:00-15:30\n    ]\n    \n    # Teresa's blocked times\n    teresa_busy = [\n        (9 * 60, 10 * 60 + 30),     # 9:00-10:30\n        (11 * 60, 12 * 60 + 30),    # 11:00-12:30\n        (13 * 60, 14 * 60),         # 13:00-14:00\n        (14 * 60 + 30, 16 * 60 + 30) # 14:30-16:30\n    ]\n    \n    meeting_duration = 30  # minutes\n    \n    # Generate all possible 30-minute slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 1  # Check every minute\n    \n    # Check each slot against all constraints\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        \n        # Bradley's constraint: not before 14:30\n        if slot_start < bradley_constraint:\n            continue\n        \n        # Check Zachary's busy times\n        zachary_conflict = False\n        for busy_start, busy_end in zachary_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                zachary_conflict = True\n                break\n        if zachary_conflict:\n            continue\n        \n        # Check Teresa's busy times\n        teresa_conflict = False\n        for busy_start, busy_end in teresa_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                teresa_conflict = True\n                break\n        if teresa_conflict:\n            continue\n        \n        # If no conflicts, return this slot\n        start_h = slot_start // 60\n        start_m = slot_start % 60\n        end_h = slot_end // 60\n        end_m = slot_end % 60\n        return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_35"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    duration = 60          # 1 hour in minutes\n\n    # Busy intervals for each participant in minutes since midnight\n    ryan_busy = [(9 * 60, 9 * 60 + 30), (12 * 60 + 30, 13 * 60)]\n    ruth_busy = []  # No meetings\n    denise_busy = [(9 * 60 + 30, 10 * 60 + 30), (12 * 60, 13 * 60), (14 * 60 + 30, 16 * 60 + 30)]\n    denise_no_meet_after = 12 * 60 + 30  # Denise doesn't want to meet after 12:30\n\n    # Combine all busy intervals and sort them\n    all_busy = ryan_busy + ruth_busy + denise_busy\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy intervals and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Filter free slots that meet duration and Denise's constraint\n    valid_slots = []\n    for start, end in free_slots:\n        slot_start = start\n        slot_end = end\n        # Ensure the slot is at least 'duration' long\n        if slot_end - slot_start >= duration:\n            # Check Denise's constraint: meeting must end by 12:30\n            if slot_start + duration <= denise_no_meet_after:\n                valid_slots.append((slot_start, slot_end))\n\n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No valid time slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_36"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, meeting_duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes  # Add 540 to convert back to 24-hour format\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n\n    # Initialize the free slots for the day (work hours)\n    free_slots = [(work_start, work_end)]\n\n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        blocked_slots = []\n        for block in schedule:\n            start, end = block.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            blocked_slots.append((start_min, end_min))\n        \n        # Sort blocked slots by start time\n        blocked_slots.sort()\n\n        # Update free_slots by subtracting blocked slots\n        new_free_slots = []\n        for free_start, free_end in free_slots:\n            current_start = free_start\n            for block_start, block_end in blocked_slots:\n                if block_start > current_start:\n                    new_free_slots.append((current_start, block_start))\n                current_start = max(current_start, block_end)\n            if current_start < free_end:\n                new_free_slots.append((current_start, free_end))\n        free_slots = new_free_slots\n\n    # Find the first slot that can fit the meeting\n    meeting_duration_min = meeting_duration * 60\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration_min:\n            meeting_end = slot_start + meeting_duration_min\n            return f\"{minutes_to_time(slot_start)}:{minutes_to_time(meeting_end)}\"\n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"11:00 to 11:30\", \"12:00 to 12:30\", \"15:30 to 16:30\"],  # Gregory\n    [],  # Teresa\n    [\"9:00 to 10:30\", \"11:00 to 16:00\", \"16:30 to 17:00\"],  # Carol\n]\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nmeeting_duration = 0.5  # in hours\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, meeting_duration))\n```",
            "count": "calendar_scheduling_example_37"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(schedules, duration, work_hours):\n    # Convert all time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start, work_end = map(time_to_minutes, work_hours.split(' to '))\n    \n    # Collect all busy intervals for each participant\n    busy_intervals = []\n    for person in schedules.values():\n        for interval in person:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Check for available slots between work hours and busy intervals\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            \n            meeting_start = minutes_to_time(slot_start)\n            meeting_end = minutes_to_time(slot_start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No available slot found\"\n\n# Define the schedules\nschedules = {\n    \"Catherine\": [\"10:30 to 11:00\", \"12:30 to 13:30\", \"14:30 to 15:00\"],\n    \"Michael\": [\"9:30 to 10:30\", \"12:00 to 13:00\", \"13:30 to 14:00\", \"15:00 to 15:30\"],\n    \"Alexander\": [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:00 to 12:00\", \"13:00 to 13:30\", \"14:00 to 16:00\", \"16:30 to 17:00\"]\n}\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_hours = \"9:00 to 17:00\"\n\n# Find and print the meeting time\nprint(find_meeting_time(schedules, duration, work_hours))\n```",
            "count": "calendar_scheduling_example_38"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration_minutes):\n    # Convert work hours and schedules to minutes for easier calculation\n    work_start, work_end = work_hours\n    work_start_min = work_start[0] * 60 + work_start[1]\n    work_end_min = work_end[0] * 60 + work_end[1]\n    \n    # Initialize the free slots for all participants within work hours\n    free_slots = []\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start = busy[0][0] * 60 + busy[0][1]\n            end = busy[1][0] * 60 + busy[1][1]\n            busy_slots.append((start, end))\n        \n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Generate free slots by finding gaps between busy slots and work hours\n        current_time = work_start_min\n        free = []\n        for busy_start, busy_end in busy_slots:\n            if busy_start > current_time:\n                free.append((current_time, busy_start))\n            current_time = max(current_time, busy_end)\n        if current_time < work_end_min:\n            free.append((current_time, work_end_min))\n        \n        free_slots.append(free)\n    \n    # Find overlapping free slots across all participants\n    common_free_slots = free_slots[0]\n    for participant_free in free_slots[1:]:\n        new_common = []\n        i = j = 0\n        while i < len(common_free_slots) and j < len(participant_free):\n            slot1 = common_free_slots[i]\n            slot2 = participant_free[j]\n            # Find the overlap between slot1 and slot2\n            overlap_start = max(slot1[0], slot2[0])\n            overlap_end = min(slot1[1], slot2[1])\n            if overlap_start < overlap_end:\n                new_common.append((overlap_start, overlap_end))\n            # Move the pointer which ends first\n            if slot1[1] < slot2[1]:\n                i += 1\n            else:\n                j += 1\n        common_free_slots = new_common\n    \n    # Find the earliest slot that can fit the meeting duration\n    for slot in common_free_slots:\n        start, end = slot\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return None\n\n# Define work hours (9:00 to 17:00)\nwork_hours = ((9, 0), (17, 0))\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Emily is free the entire day\n    [   # Victoria's busy slots\n        ((13, 30), (14, 0)),\n        ((14, 30), (15, 30)),\n        ((16, 30), (17, 0))\n    ],\n    [   # Nancy's busy slots\n        ((9, 0), (14, 0)),\n        ((14, 30), (15, 30))\n    ]\n]\n\n# Meeting duration is 30 minutes\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_39"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = map(time_to_minutes, work_hours.split(' to '))\n    duration_min = duration * 60\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        busy = []\n        for meeting in schedule:\n            start, end = map(time_to_minutes, meeting.split(' to '))\n            busy.append((start, end))\n        all_busy.append(busy)\n    \n    # Find all possible free slots for each participant\n    all_free_slots = []\n    for busy in all_busy:\n        free_slots = []\n        # Start from work start time\n        prev_end = work_start\n        for start, end in sorted(busy, key=lambda x: x[0]):\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        # Check the time after last meeting until work end\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        all_free_slots.append(free_slots)\n    \n    # Find overlapping free slots across all participants\n    common_free_slots = all_free_slots[0]\n    for free_slots in all_free_slots[1:]:\n        new_common_slots = []\n        i = j = 0\n        while i < len(common_free_slots) and j < len(free_slots):\n            start1, end1 = common_free_slots[i]\n            start2, end2 = free_slots[j]\n            # Find the overlap\n            overlap_start = max(start1, start2)\n            overlap_end = min(end1, end2)\n            if overlap_start < overlap_end:\n                new_common_slots.append((overlap_start, overlap_end))\n            # Move the pointer which ends first\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free_slots = new_common_slots\n    \n    # Find the first slot that can fit the duration\n    for start, end in common_free_slots:\n        if end - start >= duration_min:\n            meeting_end = start + duration_min\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\njacob_schedule = [\"10:00 to 11:00\", \"11:30 to 12:00\", \"16:00 to 16:30\"]\ngabriel_schedule = [\"9:30 to 11:30\", \"13:00 to 13:30\", \"15:00 to 15:30\"]\nmatthew_schedule = [\"9:00 to 9:30\", \"10:30 to 11:00\", \"11:30 to 12:00\", \"12:30 to 14:00\", \"15:30 to 16:30\"]\n\nparticipants_schedules = [jacob_schedule, gabriel_schedule, matthew_schedule]\nwork_hours = \"9:00 to 17:00\"\nmeeting_duration = 1  # in hours\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_40"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Alan's constraints: available after 14:30\n    alan_start = 14 * 60 + 30  # 14:30 in minutes\n    alan_end = work_end\n\n    # Nancy's busy times in minutes since midnight\n    nancy_busy = [\n        (11 * 60, 12 * 60 + 30),  # 11:00-12:30\n        (13 * 60, 13 * 60 + 30),  # 13:00-13:30\n        (14 * 60, 15 * 60)        # 14:00-15:00\n    ]\n\n    # Patricia's busy times in minutes since midnight\n    patricia_busy = [\n        (10 * 60, 12 * 60),       # 10:00-12:00\n        (12 * 60 + 30, 13 * 60),  # 12:30-13:00\n        (13 * 60 + 30, 16 * 60)   # 13:30-16:00\n    ]\n\n    # Combine all busy times for Nancy and Patricia\n    combined_busy = nancy_busy + patricia_busy\n    # Sort by start time\n    combined_busy.sort()\n\n    # Find potential slots after Alan's start time\n    potential_start = alan_start\n    for busy_start, busy_end in combined_busy:\n        if busy_start > potential_start:\n            # Check if the slot is long enough\n            if busy_start - potential_start >= meeting_duration:\n                # Found a valid slot\n                end_time = potential_start + meeting_duration\n                return f\"{potential_start // 60:02d}:{potential_start % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n        # Update potential_start to the end of the current busy period if it's later\n        if busy_end > potential_start:\n            potential_start = busy_end\n\n    # Check the slot after the last busy period\n    if work_end - potential_start >= meeting_duration:\n        end_time = potential_start + meeting_duration\n        return f\"{potential_start // 60:02d}:{potential_start % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n\n    # Default return (though the problem states a solution exists)\n    return \"No time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_41"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work_hours start at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = 9 + minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    start_min = time_to_minutes(work_hours[0])\n    end_min = time_to_minutes(work_hours[1])\n    duration_min = duration * 60\n\n    # Initialize a list to track busy intervals for all participants\n    busy_intervals = []\n\n    # Collect all busy intervals for each participant\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start = time_to_minutes(busy[0])\n            end = time_to_minutes(busy[1])\n            busy_intervals.append((start, end))\n\n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find the first available slot\n    prev_end = start_min\n    for start, end in merged:\n        if start - prev_end >= duration_min:\n            # Found a slot\n            meeting_start = prev_end\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n        prev_end = max(prev_end, end)\n\n    # Check after the last busy interval\n    if end_min - prev_end >= duration_min:\n        meeting_start = prev_end\n        meeting_end = meeting_start + duration_min\n        return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No available slot found\"\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration_hours = 1\n\n# Define participants' schedules\nparticipants_schedules = [\n    [(\"9:00\", \"9:30\"), (\"11:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:30\", \"14:00\"), (\"16:00\", \"17:00\")],  # Julie\n    [(\"9:00\", \"9:30\"), (\"13:00\", \"13:30\"), (\"15:00\", \"15:30\"), (\"16:00\", \"16:30\")],  # Sean\n    [(\"10:00\", \"10:30\"), (\"11:00\", \"13:00\"), (\"15:30\", \"17:00\")],  # Lori\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_42"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Convert each participant's meetings to minutes\n    albert_meetings = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    gregory_meetings = [\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    benjamin_meetings = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 13 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n\n    # Combine all meetings and blocked times\n    all_busy = []\n    for meeting in albert_meetings + gregory_meetings + benjamin_meetings:\n        all_busy.append(meeting)\n    all_busy.sort()\n\n    # Find the earliest available 30-minute slot\n    current_time = work_start\n    meeting_duration = 30\n\n    for busy_start, busy_end in all_busy:\n        if current_time + meeting_duration <= busy_start:\n            # Check if all participants are free during this slot\n            if (not is_busy(current_time, current_time + meeting_duration, albert_meetings) and\n                not is_busy(current_time, current_time + meeting_duration, gregory_meetings) and\n                not is_busy(current_time, current_time + meeting_duration, benjamin_meetings)):\n                # Format the time as HH:MM:HH:MM\n                start_hh = current_time // 60\n                start_mm = current_time % 60\n                end_hh = (current_time + meeting_duration) // 60\n                end_mm = (current_time + meeting_duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n        current_time = max(current_time, busy_end)\n\n    # Check after the last busy time\n    if current_time + meeting_duration <= work_end:\n        start_hh = current_time // 60\n        start_mm = current_time % 60\n        end_hh = (current_time + meeting_duration) // 60\n        end_mm = (current_time + meeting_duration) % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No available time found\"\n\ndef is_busy(start, end, meetings):\n    for busy_start, busy_end in meetings:\n        if not (end <= busy_start or start >= busy_end):\n            return True\n    return False\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_43"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each participant's busy slots to minutes\n    ronald_busy = [\n        (11 * 60 + 30, 12 * 60),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n    amanda_busy = [\n        (9 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    isabella_preference_end = 13 * 60  # Prefers not after 13:00\n\n    # Generate all possible 30-minute slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 1  # Check every minute for a slot\n\n    # Check each slot against constraints\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        # Check Isabella's preference (not after 13:00)\n        if slot_start >= isabella_preference_end:\n            continue\n        # Check Ronald's availability\n        ronald_available = True\n        for busy_start, busy_end in ronald_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                ronald_available = False\n                break\n        if not ronald_available:\n            continue\n        # Check Amanda's availability\n        amanda_available = True\n        for busy_start, busy_end in amanda_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                amanda_available = False\n                break\n        if not amanda_available:\n            continue\n        # If all checks passed, return this slot\n        return f\"{slot_start // 60:02d}:{slot_start % 60:02d}:{slot_end // 60:02d}:{slot_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_44"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert all time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = work_hours.split(' to ')\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participans_schedules.values():\n        for interval in schedule:\n            start, end = interval.split(' to ')\n            busy_intervals.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals during work hours\n    free_intervals = []\n    prev_end = work_start_min\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n    \n    # Check each free interval for availability of all participants\n    for start, end in free_intervals:\n        available_duration = end - start\n        if available_duration >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define the participants' schedules\nparticipants_schedules = {\n    \"Andrew\": [],\n    \"Grace\": [],\n    \"Samuel\": [\"9:00 to 10:30\", \"11:30 to 12:00\", \"13:00 to 13:30\", \"14:00 to 16:00\", \"16:30 to 17:00\"]\n}\n\n# Meeting duration in minutes (half an hour)\nduration = 30\n\n# Work hours\nwork_hours = \"9:00 to 17:00\"\n\n# Find the earliest available meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_45"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:30:12:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append(interval)\n    \n    # Find available slots by checking gaps between merged intervals and work hours\n    available_slots = []\n    previous_end = work_start\n    \n    for interval in merged:\n        current_start, current_end = interval\n        if current_start > previous_end:\n            available_slots.append((previous_end, current_start))\n        previous_end = max(previous_end, current_end)\n    \n    # Check the slot after the last busy interval\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Find the first available slot that can accommodate the meeting\n    for slot in available_slots:\n        start, end = slot\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return None\n\n# Define the participants' schedules\narthur_schedule = [\"09:30:10:00\", \"14:00:14:30\"]\ntheresa_schedule = [\"09:00:09:30\", \"12:00:13:00\", \"15:00:16:30\"]\ncarl_schedule = [\"09:00:11:30\", \"12:00:14:00\", \"14:30:17:00\"]\n\n# Combine all schedules\nparticipants_schedules = [arthur_schedule, theresa_schedule, carl_schedule]\n\n# Define work hours and meeting duration\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_46"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Parse work hours\n    work_start, work_end = work_hours.split(' to ')\n    work_start = int(work_start.split(':')[0]) * 60 + int(work_start.split(':')[1])\n    work_end = int(work_end.split(':')[0]) * 60 + int(work_end.split(':')[1])\n    \n    # Initialize busy slots for all participants\n    busy_slots = []\n    for schedule in participants_schedules:\n        person_busy = []\n        for meeting in schedule:\n            start, end = meeting.split(' to ')\n            start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n            end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n            person_busy.append((start_min, end_min))\n        busy_slots.append(person_busy)\n    \n    # Find all possible meeting slots\n    possible_slots = []\n    current_time = work_start\n    while current_time + duration <= work_end:\n        slot_valid = True\n        for person in busy_slots:\n            for meeting in person:\n                if not (current_time + duration <= meeting[0] or current_time >= meeting[1]):\n                    slot_valid = False\n                    break\n            if not slot_valid:\n                break\n        if slot_valid:\n            possible_slots.append((current_time, current_time + duration))\n        current_time += 15  # Check in 15-minute increments\n    \n    if not possible_slots:\n        return None\n    \n    # Return the first available slot\n    start, end = possible_slots[0]\n    start_h = start // 60\n    start_m = start % 60\n    end_h = end // 60\n    end_m = end % 60\n    return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n\n# Define participants' schedules\ndavid_schedule = []\neric_schedule = [\"9:00 to 9:30\", \"10:30 to 11:30\", \"15:00 to 15:30\"]\nroger_schedule = [\"9:30 to 10:30\", \"11:00 to 12:00\", \"12:30 to 13:00\", \"14:30 to 15:00\", \"15:30 to 16:30\"]\n\nparticipants_schedules = [david_schedule, eric_schedule, roger_schedule]\nwork_hours = \"9:00 to 17:00\"\nduration = 60  # minutes\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_47"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Convert each participant's busy slots to minutes\n    # Janet's busy slots: 9:30-10:30, 12:30-13:00, 14:00-14:30\n    janet_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60, 14 * 60 + 30)\n    ]\n    \n    # Rachel has no meetings\n    rachel_busy = []\n    \n    # Cynthia's busy slots: 9:30-10:00, 11:00-11:30, 12:30-14:30, 16:00-17:00\n    cynthia_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 14 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n    \n    # Cynthia's preference: not before 13:30\n    cynthia_preference_start = 13 * 60 + 30  # 13:30 in minutes\n\n    # Combine all busy slots\n    all_busy = []\n    for slot in janet_busy:\n        all_busy.append(('Janet', slot))\n    for slot in rachel_busy:\n        all_busy.append(('Rachel', slot))\n    for slot in cynthia_busy:\n        all_busy.append(('Cynthia', slot))\n    \n    # Sort all busy slots by start time\n    all_busy.sort(key=lambda x: x[1][0])\n\n    # Find potential meeting slots\n    potential_slots = []\n    previous_end = work_start\n\n    for _, (start, end) in all_busy:\n        if start > previous_end:\n            potential_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        potential_slots.append((previous_end, work_end))\n\n    # Filter slots that are long enough and meet Cynthia's preference\n    valid_slots = []\n    for slot in potential_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= meeting_duration and slot_start >= cynthia_preference_start:\n            valid_slots.append(slot)\n    \n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        print(f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\")\n    else:\n        print(\"No valid meeting time found.\")\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_48"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since midnight\n    teresa_busy = [\n        (9 * 60, 10 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    kathleen_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    patricia_busy = [\n        (9 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n\n    # Kathleen's preference: not after 14:30 (so before 14:30)\n    kathleen_preference_end = 14 * 60 + 30\n\n    # Generate all possible slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 1  # Check every minute\n\n    # Check each slot against everyone's schedule and preferences\n    for slot in possible_slots:\n        start, end = slot\n        # Check if the slot is before Kathleen's preference end time\n        if end > kathleen_preference_end:\n            continue\n        # Check Teresa's availability\n        teresa_available = True\n        for busy_start, busy_end in teresa_busy:\n            if not (end <= busy_start or start >= busy_end):\n                teresa_available = False\n                break\n        if not teresa_available:\n            continue\n        # Check Kathleen's availability\n        kathleen_available = True\n        for busy_start, busy_end in kathleen_busy:\n            if not (end <= busy_start or start >= busy_end):\n                kathleen_available = False\n                break\n        if not kathleen_available:\n            continue\n        # Check Patricia's availability\n        patricia_available = True\n        for busy_start, busy_end in patricia_busy:\n            if not (end <= busy_start or start >= busy_end):\n                patricia_available = False\n                break\n        if not patricia_available:\n            continue\n        # If all checks passed, return this slot\n        return f\"{start // 60:02d}:{start % 60:02d}:{end // 60:02d}:{end % 60:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_49"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:30:14:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(duration, work_start, work_end, schedules):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by looking at gaps between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start_min\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        available_slots.append((prev_end, work_end_min))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define the problem parameters\nduration = 1  # hours\nwork_start = \"09:00\"\nwork_end = \"17:00\"\n# Emma's schedule\nemma_schedule = [\"09:00:10:30\", \"11:00:12:00\", \"12:30:13:30\", \"14:30:15:30\", \"16:00:16:30\"]\n# Daniel and Roy have no meetings\ndaniel_schedule = []\nroy_schedule = []\nschedules = [daniel_schedule, roy_schedule, emma_schedule]\n\n# Find and print the meeting time\nprint(find_meeting_time(duration, work_start, work_end, schedules))\n```",
            "count": "calendar_scheduling_example_50"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work hours start at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = 9 + minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    # Initialize work hours in minutes\n    start_work = time_to_minutes(work_hours[0])\n    end_work = time_to_minutes(work_hours[1])\n\n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules.values():\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort intervals by start time\n    busy_intervals.sort()\n\n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = start_work\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < end_work:\n        free_intervals.append((prev_end, end_work))\n\n    # Find the first free interval that can fit the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"Brandon\": [\"11:30 to 12:00\", \"12:30 to 13:30\", \"14:00 to 14:30\"],\n    \"Donna\": [\"10:00 to 10:30\", \"12:00 to 12:30\"],\n    \"Jack\": [\"9:30 to 10:00\", \"10:30 to 11:00\", \"11:30 to 12:30\", \"13:00 to 14:30\", \"15:30 to 17:00\"]\n}\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 60  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_51"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Parse work hours\n    work_start, work_end = [int(time.split(':')[0]) + int(time.split(':')[1])/60 for time in work_hours.split(' to ')]\n    \n    # Initialize available slots as the entire work day\n    available_slots = [(work_start, work_end)]\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = [int(time.split(':')[0]) + int(time.split(':')[1])/60 for time in busy.split(' to ')]\n            busy_slots.append((start, end))\n        \n        # Merge overlapping busy slots\n        busy_slots.sort()\n        merged_busy = []\n        for busy in busy_slots:\n            if not merged_busy:\n                merged_busy.append(busy)\n            else:\n                last_start, last_end = merged_busy[-1]\n                current_start, current_end = busy\n                if current_start <= last_end:\n                    merged_busy[-1] = (last_start, max(last_end, current_end))\n                else:\n                    merged_busy.append(busy)\n        \n        # Subtract busy slots from available slots\n        new_available_slots = []\n        for avail_start, avail_end in available_slots:\n            current_start = avail_start\n            for busy_start, busy_end in merged_busy:\n                if busy_start > current_start and busy_start <= avail_end:\n                    new_available_slots.append((current_start, busy_start))\n                current_start = max(current_start, busy_end)\n            if current_start < avail_end:\n                new_available_slots.append((current_start, avail_end))\n        available_slots = new_available_slots\n    \n    # Find the first available slot that can fit the meeting\n    for slot in available_slots:\n        start, end = slot\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = int(meeting_start)\n            start_mm = int((meeting_start - start_hh) * 60)\n            end_hh = int(meeting_end)\n            end_mm = int((meeting_end - end_hh) * 60)\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No available slot found\"\n\n# Define participants' schedules\ngrace_schedule = [\n    \"9:00 to 9:30\",\n    \"10:00 to 11:00\",\n    \"16:00 to 16:30\"\n]\nrandy_schedule = [\n    \"12:30 to 13:00\",\n    \"16:00 to 16:30\"\n]\nsusan_schedule = [\n    \"9:00 to 14:30\",\n    \"15:30 to 16:00\"\n]\n\n# Define meeting constraints\nwork_hours = \"9:00 to 17:00\"\nduration = 1.0  # 1 hour\n\n# Find meeting time\nmeeting_time = find_meeting_time([grace_schedule, randy_schedule, susan_schedule], work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_52"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:30:16:30}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert all time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 9:00 (0 minutes)\n    \n    # Convert work hours to minutes\n    work_start, work_end = map(time_to_minutes, work_hours.split('-'))\n    \n    # Generate busy intervals in minutes for each participant\n    busy_intervals = []\n    for busy_slots in participents_busy.values():\n        participant_intervals = []\n        for slot in busy_slots:\n            start, end = map(time_to_minutes, slot.split('-'))\n            participant_intervals.append((start, end))\n        busy_intervals.append(participant_intervals)\n    \n    # Find all busy intervals for all participants\n    all_busy = []\n    for intervals in busy_intervals:\n        all_busy.extend(intervals)\n    all_busy.sort()\n    \n    # Merge overlapping busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append([start, end])\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1][1] = max(last_end, end)\n            else:\n                merged.append([start, end])\n    \n    # Find available slots\n    available = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n    \n    # Check for a slot that fits the duration\n    duration_min = duration * 60\n    for start, end in available:\n        if end - start >= duration_min:\n            # Convert back to HH:MM format\n            start_hh = (start + 540) // 60\n            start_mm = (start + 540) % 60\n            end_hh = (start + 540 + duration_min) // 60\n            end_mm = (start + 540 + duration_min) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}-{end_hh:02d}:{end_mm:02d}\"\n    return \"No available slot found\"\n\n# Define the participants' busy times\nparticipants_busy = {\n    \"Alice\": [\"9:30-10:00\", \"12:30-13:00\", \"14:30-15:00\", \"16:30-17:00\"],\n    \"Arthur\": [\"9:00-9:30\", \"10:00-11:00\", \"11:30-12:00\", \"13:00-14:00\", \"15:00-15:30\", \"16:30-17:00\"],\n    \"Noah\": []\n}\n\n# Define work hours and meeting duration\nwork_hours = \"9:00-17:00\"\nduration = 1  # in hours\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_53"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Convert blocked times to minutes since midnight\n    isabella_blocked = [(11 * 60, 11 * 60 + 30), (15 * 60 + 30, 16 * 60)]\n    tyler_blocked = [(9 * 60, 10 * 60)]\n    jordan_blocked = [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60), \n                      (12 * 60 + 30, 13 * 60 + 30), (14 * 60, 14 * 60 + 30),\n                      (15 * 60, 16 * 60)]\n\n    # Tyler cannot meet after 16:00\n    tyler_no_meet_after = 16 * 60\n\n    # Combine all blocked times for each participant\n    blocked_times = {\n        'Isabella': isabella_blocked,\n        'Tyler': tyler_blocked,\n        'Jordan': jordan_blocked\n    }\n\n    # Find all possible 1-hour slots that work for everyone\n    possible_slots = []\n    current_time = work_start\n    meeting_duration = 60  # 1 hour\n\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        slot_valid = True\n\n        # Check Isabella's availability\n        for start, end in blocked_times['Isabella']:\n            if not (slot_end <= start or current_time >= end):\n                slot_valid = False\n                break\n        if not slot_valid:\n            current_time += 15  # Check next 15-minute interval\n            continue\n\n        # Check Tyler's availability\n        for start, end in blocked_times['Tyler']:\n            if not (slot_end <= start or current_time >= end):\n                slot_valid = False\n                break\n        if not slot_valid:\n            current_time += 15\n            continue\n        if slot_end > tyler_no_meet_after:\n            slot_valid = False\n        if not slot_valid:\n            current_time += 15\n            continue\n\n        # Check Jordan's availability\n        for start, end in blocked_times['Jordan']:\n            if not (slot_end <= start or current_time >= end):\n                slot_valid = False\n                break\n        if not slot_valid:\n            current_time += 15\n            continue\n\n        if slot_valid:\n            possible_slots.append((current_time, slot_end))\n            break  # Return the first valid slot found\n\n        current_time += 15\n\n    if possible_slots:\n        start, end = possible_slots[0]\n        # Convert minutes back to HH:MM format\n        start_hh = start // 60\n        start_mm = start % 60\n        end_hh = end // 60\n        end_mm = end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_54"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability across all participants\n    # Since all participants' busy intervals are merged, any free interval is common\n    for start, end in free_intervals:\n        if end - start >= duration * 60:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration * 60)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"14:00 to 14:30\", \"16:00 to 16:30\"],  # Keith\n    [],                                    # Christine\n    [\"09:00 to 10:30\", \"11:30 to 17:00\"]   # Cynthia\n]\n\n# Define work hours and meeting duration\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 1  # in hours\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration))\n```",
            "count": "calendar_scheduling_example_55"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = (minutes + 540) // 60\n        mm = (minutes + 540) % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    # Parse work hours\n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n\n    # Initialize busy slots for all participants\n    busy_slots = []\n    for schedule in participants_schedules:\n        person_busy = []\n        for slot in schedule:\n            start, end = slot.split(' to ')\n            person_busy.append((time_to_minutes(start), time_to_minutes(end)))\n        busy_slots.append(person_busy)\n\n    # Find all possible slots\n    possible_slots = []\n    current_time = work_start\n    while current_time + duration <= work_end:\n        slot_valid = True\n        for person in busy_slots:\n            for busy_start, busy_end in person:\n                if not (current_time + duration <= busy_start or current_time >= busy_end):\n                    slot_valid = False\n                    break\n            if not slot_valid:\n                break\n        if slot_valid:\n            possible_slots.append((current_time, current_time + duration))\n        current_time += 15  # Check every 15 minutes\n\n    if not possible_slots:\n        return None\n\n    # Return the first available slot\n    start, end = possible_slots[0]\n    return f\"{minutes_to_time(start)}:{minutes_to_time(end)}\"\n\n# Define the problem\nparticipants_schedules = [\n    [\"12:00 to 13:00\", \"13:30 to 14:00\", \"15:00 to 15:30\"],  # Jeremy\n    [\"09:30 to 10:00\", \"13:00 to 13:30\", \"16:00 to 17:00\"],  # Donna\n    [\"09:00 to 11:00\", \"11:30 to 12:00\", \"12:30 to 17:00\"],  # Robert\n]\nwork_hours = \"09:00 to 17:00\"\nduration = 30  # minutes\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_56"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define each participant's busy times in minutes (start, end)\n    virginia_busy = [(10 * 60, 12 * 60)]\n    charles_busy = [(12 * 60, 12 * 30), (13 * 60, 13 * 30)]\n    megan_busy = [(9 * 60, 12 * 60), (13 * 30, 16 * 60), (16 * 30, 17 * 60)]\n    \n    # Charles' preference: avoid before 14:30\n    charles_preference_start = 14 * 60 + 30\n    \n    # Combine all busy times and sort\n    all_busy = virginia_busy + charles_busy + megan_busy\n    all_busy.sort()\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Check for a 30-minute slot that fits Charles' preference\n    meeting_duration = 30\n    for slot_start, slot_end in available_slots:\n        # Adjust slot_start to meet Charles' preference\n        adjusted_start = max(slot_start, charles_preference_start)\n        if adjusted_start + meeting_duration <= slot_end:\n            # Format the time as HH:MM:HH:MM\n            start_hh = adjusted_start // 60\n            start_mm = adjusted_start % 60\n            end_hh = (adjusted_start + meeting_duration) // 60\n            end_mm = (adjusted_start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_57"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for meeting in schedule:\n            start, end = map(time_to_minutes, meeting.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability for all participants\n    for interval in free_intervals:\n        start, end = interval\n        available_duration = end - start\n        if available_duration >= duration_minutes:\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration_minutes)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\njoan_schedule = [\"11:00 to 11:30\", \"12:30 to 13:00\"]\ntheresa_schedule = [\"12:00 to 12:30\", \"15:00 to 15:30\"]\nshirley_schedule = [\"9:30 to 10:30\", \"11:00 to 12:00\", \"13:00 to 14:00\", \"15:30 to 16:30\"]\n\nparticipants_schedules = [joan_schedule, theresa_schedule, shirley_schedule]\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 60  # 1 hour\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes))\n```",
            "count": "calendar_scheduling_example_58"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Jeffrey's constraints: available after 14:00\n    jeffrey_free = [(14 * 60, work_end)]\n\n    # Jack's busy times in minutes\n    jack_busy = [\n        (10 * 60 + 30, 11 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n    # Calculate Jack's free times\n    jack_free = []\n    prev_end = work_start\n    for start, end in sorted(jack_busy):\n        if start > prev_end:\n            jack_free.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        jack_free.append((prev_end, work_end))\n\n    # Judith's busy times in minutes\n    judith_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    # Calculate Judith's free times\n    judith_free = []\n    prev_end = work_start\n    for start, end in sorted(judith_busy):\n        if start > prev_end:\n            judith_free.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        judith_free.append((prev_end, work_end))\n\n    # Find overlapping free times for all three\n    meeting_duration = 30\n    possible_slots = []\n\n    # Iterate through Jeffrey's free times (only after 14:00)\n    for jf_start, jf_end in jeffrey_free:\n        # Iterate through Jack's free times\n        for jk_start, jk_end in jack_free:\n            # Find overlap between Jeffrey and Jack\n            overlap_start = max(jf_start, jk_start)\n            overlap_end = min(jf_end, jk_end)\n            if overlap_start >= overlap_end:\n                continue\n            # Iterate through Judith's free times\n            for ju_start, ju_end in judith_free:\n                # Find overlap with Judith\n                final_start = max(overlap_start, ju_start)\n                final_end = min(overlap_end, ju_end)\n                if final_start >= final_end:\n                    continue\n                # Check if there's enough time for the meeting\n                if final_end - final_start >= meeting_duration:\n                    possible_slots.append((final_start, final_start + meeting_duration))\n\n    # Select the earliest possible slot\n    if possible_slots:\n        best_slot = min(possible_slots)\n        start_h, start_m = divmod(best_slot[0], 60)\n        end_h, end_m = divmod(best_slot[1], 60)\n        print(f\"{int(start_h):02d}:{int(start_m):02d}:{int(end_h):02d}:{int(end_m):02d}\")\n    else:\n        print(\"No suitable time found.\")\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_59"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes\n    lisa_busy = [\n        (10 * 60 + 30, 11 * 60),    # 10:30-11:00\n        (11 * 60 + 30, 12 * 60),    # 11:30-12:00\n        (14 * 60, 15 * 60)          # 14:00-15:00\n    ]\n    raymond_busy = [\n        (9 * 60, 10 * 60),          # 9:00-10:00\n        (10 * 60 + 30, 11 * 60),    # 10:30-11:00\n        (11 * 60 + 30, 15 * 60),    # 11:30-15:00\n        (16 * 60, 17 * 60)          # 16:00-17:00\n    ]\n    # Dorothy is free all day but prefers no meetings after 10:30\n    dorothy_preference_end = 10 * 60 + 30  # 10:30\n\n    # Combine all busy slots\n    all_busy = lisa_busy + raymond_busy\n    # Sort by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check after last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Now check Dorothy's preference (no meetings after 10:30)\n    # So we only consider slots that start and end before or at 10:30\n    valid_slots = []\n    for start, end in free_slots:\n        slot_end = start + meeting_duration\n        if slot_end <= dorothy_preference_end and slot_end <= end:\n            valid_slots.append((start, slot_end))\n\n    # Select the first valid slot\n    if valid_slots:\n        meeting_start, meeting_end = valid_slots[0]\n    else:\n        return \"No valid time found\"\n\n    # Convert back to HH:MM format\n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n\n    start_time = minutes_to_time(meeting_start)\n    end_time = minutes_to_time(meeting_end)\n    return f\"{start_time}:{end_time}\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_60"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:30:14:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start, work_end = map(time_to_minutes, work_hours)\n    busy_slots = []\n    \n    for person in participants_busy:\n        for slot in participants_busy[person]:\n            start, end = map(time_to_minutes, slot)\n            busy_slots.append((start, end))\n    \n    # Sort all busy slots by start time\n    busy_slots.sort()\n    \n    # Find all free slots by merging busy intervals\n    merged_busy = []\n    for start, end in busy_slots:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Check the time before the first busy slot\n    if merged_busy:\n        first_busy_start, _ = merged_busy[0]\n        if first_busy_start - work_start >= duration:\n            return (work_start, work_start + duration)\n    \n    # Check the time between busy slots\n    for i in range(1, len(merged_busy)):\n        prev_end = merged_busy[i-1][1]\n        curr_start = merged_busy[i][0]\n        if curr_start - prev_end >= duration:\n            return (prev_end, prev_end + duration)\n    \n    # Check the time after the last busy slot\n    if merged_busy:\n        last_busy_end = merged_busy[-1][1]\n        if work_end - last_busy_end >= duration:\n            return (last_busy_end, last_busy_end + duration)\n    else:\n        # No busy slots, the entire work hours are free\n        return (work_start, work_start + duration)\n    \n    return None\n\ndef minutes_to_time(minutes):\n    hh = minutes // 60\n    mm = minutes % 60\n    return f\"{hh:02d}:{mm:02d}\"\n\n# Define participants' busy times\nparticipants_busy = {\n    'Robert': [],\n    'Lisa': ['9:30-10:00', '11:30-12:00'],\n    'Patrick': ['9:30-11:30', '12:30-13:30', '16:00-17:00'],\n}\n\n# Define work hours and meeting duration\nwork_hours = ('9:00', '17:00')\nduration_minutes = 60\n\n# Find a meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration_minutes)\n\nif meeting_time:\n    start, end = meeting_time\n    start_time = minutes_to_time(start)\n    end_time = minutes_to_time(end)\n    print(f\"{start_time}:{end_time}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_61"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(schedules, work_hours, duration):\n    start_work, end_work = work_hours\n    # Convert all times to minutes since midnight for easier calculation\n    work_start = start_work[0] * 60 + start_work[1]\n    work_end = end_work[0] * 60 + end_work[1]\n    \n    # Initialize the list of busy intervals\n    busy_intervals = []\n    \n    for schedule in schedules:\n        for interval in schedule:\n            start = interval[0][0] * 60 + interval[0][1]\n            end = interval[1][0] * 60 + interval[1][1]\n            busy_intervals.append((start, end))\n    \n    # Sort the busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find the free intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability\n    for start, end in free_intervals:\n        if end - start >= duration * 60:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = (start + duration * 60) // 60\n            end_mm = (start + duration * 60) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time slot found\"\n\n# Define the schedules\nabigail_schedule = []\nmichael_schedule = []\nsharon_schedule = [\n    ((9, 0), (13, 0)),\n    ((14, 0), (17, 0))\n]\n\nschedules = [abigail_schedule, michael_schedule, sharon_schedule]\nwork_hours = ((9, 0), (17, 0))\nduration = 1  # 1 hour\n\n# Find the meeting time\nmeeting_time = find_meeting_time(schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_62"
        },
        {
            "final_program_time": "{16:00:17:00}",
            "expected_time": "{16:00:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_work, end_work = work_hours\n    # Convert all times to minutes since midnight for easier calculation\n    start_min = start_work[0] * 60 + start_work[1]\n    end_min = end_work[0] * 60 + end_work[1]\n    \n    # Generate all possible slots within work hours\n    possible_slots = []\n    current_start = start_min\n    while current_start + duration <= end_min:\n        possible_slots.append((current_start, current_start + duration))\n        current_start += 30  # Check in 30-minute increments\n    \n    # Check each slot against all participants' schedules\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        valid = True\n        for schedule in participants_schedules:\n            for busy_start, busy_end in schedule:\n                busy_start_min = busy_start[0] * 60 + busy_start[1]\n                busy_end_min = busy_end[0] * 60 + busy_end[1]\n                # Check if slot overlaps with any busy period\n                if not (slot_end <= busy_start_min or slot_start >= busy_end_min):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            # Convert back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No valid slot found\"\n\n# Define work hours and meeting duration\nwork_hours = ((9, 0), (17, 0))  # 9:00 to 17:00\nduration = 60  # 1 hour in minutes\n\n# Define participants' schedules in (HH, MM) format\nmadison_schedule = []\njudith_schedule = [((10, 0), (10, 30)), ((11, 0), (12, 0)), ((12, 30), (13, 0))]\nroger_schedule = [((9, 0), (9, 30)), ((10, 30), (11, 0)), ((12, 0), (12, 30)), ((13, 0), (13, 30)), ((14, 0), (16, 0))]\n\nparticipants_schedules = [madison_schedule, judith_schedule, roger_schedule]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_63"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_work, end_work = work_hours\n    busy_slots = []\n    \n    # Collect all busy slots\n    for schedule in participants_schedules.values():\n        busy_slots.extend(schedule)\n    \n    # Sort busy slots by start time\n    busy_slots.sort()\n    \n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = start_work\n    \n    for start, end in busy_slots:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < end_work:\n        free_slots.append((previous_end, end_work))\n    \n    # Check each free slot for availability in all participants' schedules\n    for slot_start, slot_end in free_slots:\n        slot_duration = (slot_end - slot_start).total_seconds() / 3600\n        if slot_duration >= duration:\n            # Check if all participants are free during this slot\n            all_free = True\n            for schedule in participants_schedules.values():\n                for busy_start, busy_end in schedule:\n                    if busy_start < slot_end and busy_end > slot_start:\n                        all_free = False\n                        break\n                if not all_free:\n                    break\n            if all_free:\n                return slot_start, slot_start + timedelta(hours=duration)\n    \n    return None\n\n# Define work hours and meeting duration\nfrom datetime import datetime, timedelta\n\nwork_hours = (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))\nduration = 1  # hours\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"Nancy\": [\n        (datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n        (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\"))\n    ],\n    \"Albert\": [],\n    \"Nathan\": [\n        (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n        (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\")),\n        (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))\n    ]\n}\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\n\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{start.strftime('%H:%M')}:{end.strftime('%H:%M')}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_64"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define busy intervals in minutes since midnight\n    john_busy = [\n        (12 * 60 + 30, 13 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    andrea_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (11 * 60, 12 * 60 + 30),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    lisa_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (12 * 60, 12 * 60 + 30),\n        (14 * 60, 15 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    # Andrea cannot meet after 16:30\n    andrea_cutoff = 16 * 60 + 30\n    \n    # Meeting duration is 30 minutes\n    duration = 30\n    \n    # Generate all possible slots within work hours\n    for start in range(work_start, work_end - duration + 1, 15):  # Check every 15 minutes\n        end = start + duration\n        # Check if the slot is within Andrea's cutoff\n        if end > andrea_cutoff:\n            continue\n        # Check John's availability\n        john_available = True\n        for busy_start, busy_end in john_busy:\n            if not (end <= busy_start or start >= busy_end):\n                john_available = False\n                break\n        if not john_available:\n            continue\n        # Check Andrea's availability\n        andrea_available = True\n        for busy_start, busy_end in andrea_busy:\n            if not (end <= busy_start or start >= busy_end):\n                andrea_available = False\n                break\n        if not andrea_available:\n            continue\n        # Check Lisa's availability\n        lisa_available = True\n        for busy_start, busy_end in lisa_busy:\n            if not (end <= busy_start or start >= busy_end):\n                lisa_available = False\n                break\n        if lisa_available:\n            # Convert start and end back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = end // 60\n            end_mm = end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_65"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(schedules, duration, work_start, work_end):\n    # Convert all time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n    \n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Initialize the merged busy intervals\n    busy_intervals = []\n    for person, intervals in schedules.items():\n        for start, end in intervals:\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            busy_intervals.append((start_min, end_min))\n    \n    # Sort the intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                new_end = max(last_end, current_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append(interval)\n    \n    # Find the available slots\n    available = []\n    prev_end = 0\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        available.append((prev_end, work_end_min))\n    \n    # Check for a slot that can fit the duration\n    for start, end in available:\n        if end - start >= duration:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No available time slot found\"\n\n# Define the schedules\nschedules = {\n    \"Ronald\": [],\n    \"Maria\": [],\n    \"Charles\": [(\"9:00\", \"10:30\"), (\"11:00\", \"11:30\"), (\"13:30\", \"14:00\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:30\")]\n}\n\n# Define meeting parameters\nduration = 60  # 1 hour in minutes\nwork_start = \"9:00\"\nwork_end = \"17:00\"\n\n# Find and print the meeting time\nprint(find_meeting_time(schedules, duration, work_start, work_end))\n```",
            "count": "calendar_scheduling_example_66"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define busy intervals in minutes since midnight\n    jacqueline_busy = [\n        (13 * 60, 13 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    linda_busy = [\n        (9 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60 + 30, 16 * 60 + 30)\n    ]\n    # Linda cannot meet after 14:00\n    linda_no_meet_after = 14 * 60\n    \n    # Duration of the meeting in minutes\n    duration = 30\n    \n    # Generate all possible slots within work hours\n    possible_slots = []\n    current_time = work_start\n    \n    while current_time + duration <= work_end:\n        slot_end = current_time + duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 30  # Check every 30 minutes for efficiency\n    \n    # Check each slot against everyone's constraints\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        \n        # Check Jacqueline's availability\n        jacqueline_available = True\n        for busy_start, busy_end in jacqueline_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                jacqueline_available = False\n                break\n        if not jacqueline_available:\n            continue\n        \n        # Check Linda's availability and constraints\n        linda_available = True\n        for busy_start, busy_end in linda_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                linda_available = False\n                break\n        # Check if slot is after Linda's no-meet time\n        if slot_start >= linda_no_meet_after:\n            linda_available = False\n        if not linda_available:\n            continue\n        \n        # Christian is free all day, so no need to check\n        \n        # If we reach here, the slot is good for everyone\n        # Convert minutes back to HH:MM format\n        start_hh = slot_start // 60\n        start_mm = slot_start % 60\n        end_hh = slot_end // 60\n        end_mm = slot_end % 60\n        \n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_67"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration_minutes):\n    # Convert work hours and schedules to minutes since start of day\n    work_start, work_end = work_hours\n    work_start_min = work_start[0] * 60 + work_start[1]\n    work_end_min = work_end[0] * 60 + work_end[1]\n    \n    # Generate all possible time slots within work hours\n    possible_slots = []\n    current_time = work_start_min\n    while current_time + duration_minutes <= work_end_min:\n        possible_slots.append((current_time, current_time + duration_minutes))\n        current_time += 1  # Check every minute\n    \n    # Check each slot against all participants' schedules\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        valid = True\n        for schedule in participants_schedules:\n            for busy_start, busy_end in schedule:\n                busy_start_min = busy_start[0] * 60 + busy_start[1]\n                busy_end_min = busy_end[0] * 60 + busy_end[1]\n                # Check if slot overlaps with any busy period\n                if not (slot_end <= busy_start_min or slot_start >= busy_end_min):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            # Convert back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No available slot found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours = ((9, 0), (17, 0))\n\n# Define participants' schedules in HH:MM format\nmichael_schedule = [\n    ((10, 0), (10, 30)),\n    ((11, 30), (12, 0)),\n    ((13, 30), (14, 0)),\n    ((15, 30), (16, 0))\n]\nbryan_schedule = []\nlauren_schedule = [\n    ((9, 0), (10, 30)),\n    ((14, 30), (17, 0))\n]\n\nparticipants_schedules = [michael_schedule, bryan_schedule, lauren_schedule]\n\n# Find the earliest available 30-minute slot\nmeeting_time = find_meeting_time(participants_schedules, work_hours, 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_68"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:00:11:00}",
            "type_error": "SyntaxError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find the earliest available slot\n    prev_end = work_start\n    for busy_start, busy_end in all_busy:\n        if busy_start > prev_end:\n            available_start = prev_end\n            available_end = busy_start\n            if available_end - available_start >= duration:\n                return (minutes_to_time(available_start), (minutes_to_time(available_start + duration))\n        prev_end = max(prev_end, busy_end)\n    \n    # Check the slot after the last busy interval\n    if work_end - prev_end >= duration:\n        return (minutes_to_time(prev_end), (minutes_to_time(prev_end + duration)))\n    \n    return None\n\n# Define the schedules\nshirley_schedule = [\"11:00 to 11:30\", \"14:00 to 15:00\", \"16:00 to 16:30\"]\nstephen_schedule = [\"13:00 to 13:30\", \"15:30 to 16:00\"]\npaul_schedule = [\"9:00 to 10:00\", \"11:00 to 17:00\"]\n\nparticipants_schedules = [shirley_schedule, stephen_schedule, paul_schedule]\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration = 60  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration)\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{start}:{end}\")\nelse:\n    print(\"No available time slot found.\")\n```",
            "count": "calendar_scheduling_example_69"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration_minutes):\n    # Convert work hours and schedules to minutes since 9:00 (540 minutes)\n    work_start = 9 * 60\n    work_end = 17 * 60\n    duration = duration_minutes\n    \n    # Initialize a list to hold all busy intervals in minutes\n    busy_intervals = []\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start_h, start_m = map(int, busy.split(' to ')[0].split(':'))\n            end_h, end_m = map(int, busy.split(' to ')[1].split(':'))\n            start = start_h * 60 + start_m\n            end = end_h * 60 + end_m\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find the earliest available slot\n    prev_end = work_start\n    for start, end in merged:\n        if start - prev_end >= duration:\n            meeting_start = prev_end\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n        prev_end = max(prev_end, end)\n    \n    # Check after the last busy interval\n    if work_end - prev_end >= duration:\n        meeting_start = prev_end\n        meeting_end = meeting_start + duration\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\ndenise_schedule = [\"12:00 to 12:30\", \"15:30 to 16:00\"]\nangela_schedule = []\nnatalie_schedule = [\"9:00 to 11:30\", \"12:00 to 13:00\", \"14:00 to 14:30\", \"15:00 to 17:00\"]\n\nparticipants_schedules = [denise_schedule, angela_schedule, natalie_schedule]\nwork_hours = (\"9:00\", \"17:00\")\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_70"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define blocked times in minutes since midnight\n    john_blocked = [(12 * 60 + 30, 13 * 60), (16 * 60 + 30, 17 * 60)]\n    ethan_blocked = [(9 * 60, 10 * 60), (11 * 60 + 30, 14 * 60), (14 * 60 + 30, 17 * 60)]\n\n    # John's preference: not after 12:00\n    john_preference_end = 12 * 60\n\n    # Meeting duration in minutes\n    meeting_duration = 30\n\n    # Generate possible time slots\n    possible_slots = []\n    current_start = work_start\n\n    while current_start + meeting_duration <= work_end:\n        current_end = current_start + meeting_duration\n        # Check if the slot fits everyone's constraints\n        john_ok = True\n        for block_start, block_end in john_blocked:\n            if not (current_end <= block_start or current_start >= block_end):\n                john_ok = False\n                break\n        ethan_ok = True\n        for block_start, block_end in ethan_blocked:\n            if not (current_end <= block_start or current_start >= block_end):\n                ethan_ok = False\n                break\n        # Check John's preference\n        if john_ok and ethan_ok and current_end <= john_preference_end:\n            possible_slots.append((current_start, current_end))\n        current_start += 15  # Check every 15 minutes\n\n    if possible_slots:\n        # Select the earliest possible slot\n        meeting_start, meeting_end = possible_slots[0]\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_71"
        },
        {
            "final_program_time": "{13:30:14:30}",
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy)\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals_sorted = sorted(busy_intervals, key=lambda x: x[0])\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals_sorted:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    previous_end = work_start\n    for start, end in merged:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Find the first available slot that can fit the meeting duration\n    duration_minutes = duration * 60\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules\nmason_schedule = []  # No meetings\namy_schedule = [(\"09:30\", \"11:30\"), (\"13:00\", \"13:30\"), (\"16:30\", \"17:00\")]\nchristopher_schedule = [(\"09:00\", \"10:00\"), (\"12:00\", \"13:30\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:30\")]\n\nparticipants_schedules = [mason_schedule, amy_schedule, christopher_schedule]\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 1  # in hours\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules=participants_schedules, \n                       work_hours_start=work_hours_start, \n                       work_hours_end=work_hours_end, \n                       duration=meeting_duration))\n```",
            "count": "calendar_scheduling_example_72"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration):\n    # Convert all time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    all_busy_intervals = []\n    for busy_times in participants_busy_times:\n        for interval in busy_times:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            all_busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_intervals = []\n    for start, end in all_busy_intervals:\n        if not merged_intervals:\n            merged_intervals.append([start, end])\n        else:\n            last_start, last_end = merged_intervals[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                merged_intervals[-1][1] = max(end, last_end)\n            else:\n                merged_intervals.append([start, end])\n    \n    # Find available slots by checking gaps between merged intervals and work hours\n    available_slots = []\n    previous_end = work_start\n    for start, end in merged_intervals:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Check each available slot for sufficient duration\n    meeting_duration_min = meeting_duration * 60\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define the participants' busy times\nbradley_busy = [\"9:30 to 10:00\", \"13:00 to 13:30\", \"14:30 to 15:00\", \"16:30 to 17:00\"]\nandrew_busy = [\"9:00 to 9:30\", \"12:30 to 13:30\", \"14:00 to 14:30\", \"15:00 to 16:00\"]\nmelissa_busy = [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:00 to 14:00\", \"15:00 to 15:30\", \"16:00 to 16:30\"]\n\nparticipants_busy_times = [bradley_busy, andrew_busy, melissa_busy]\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 0.5  # in hours\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_73"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    duration = 60         # 1 hour in minutes\n\n    # Convert each person's busy times to minutes since 9:00\n    # Eric's busy times: 10:00-12:00\n    eric_busy = [(10 * 60, 12 * 60)]\n    # Albert's busy times: 12:00-12:30, 15:30-16:00\n    albert_busy = [(12 * 60, 12 * 60 + 30), (15 * 60 + 30, 16 * 60)]\n    # Katherine's busy times: 10:00-11:00, 11:30-14:00, 15:00-15:30\n    katherine_busy = [(10 * 60, 11 * 60), (11 * 60 + 30, 14 * 60), (15 * 60, 15 * 60 + 30)]\n\n    # Eric's constraint: no meetings after 15:30\n    eric_constraint = 15 * 60 + 30\n\n    # Combine all busy times and sort them\n    all_busy = eric_busy + albert_busy + katherine_busy\n    all_busy.sort()\n\n    # Find the earliest available slot\n    previous_end = work_start\n    for start, end in all_busy:\n        if start > previous_end:\n            # Check if the slot is long enough and before Eric's constraint\n            if (start - previous_end) >= duration and (previous_end + duration) <= eric_constraint:\n                # Convert back to HH:MM format\n                start_hh = previous_end // 60\n                start_mm = previous_end % 60\n                end_hh = (previous_end + duration) // 60\n                end_mm = (previous_end + duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n        previous_end = max(previous_end, end)\n\n    # Check after the last busy slot\n    if (work_end - previous_end) >= duration and (previous_end + duration) <= eric_constraint:\n        start_hh = previous_end // 60\n        start_mm = previous_end % 60\n        end_hh = (previous_end + duration) // 60\n        end_mm = (previous_end + duration) % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_74"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:14:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration_hours):\n    # Convert all times to minutes since midnight for easier calculation\n    start_min = work_hours_start * 60\n    end_min = work_hours_end * 60\n    duration_min = duration_hours * 60\n\n    # Initialize a list to keep track of all busy intervals\n    busy_intervals = []\n\n    # Collect all busy intervals from each participant\n    for person in participants_busy_times.values():\n        for interval in person:\n            start = interval[0] * 60\n            end = interval[1] * 60\n            busy_intervals.append((start, end))\n\n    # Sort the busy intervals by start time\n    busy_intervals_sorted = sorted(busy_intervals, key=lambda x: x[0])\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for interval in busy_intervals_sorted:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append(interval)\n\n    # Find available slots by checking gaps between merged intervals\n    available_slots = []\n    previous_end = start_min\n\n    for interval in merged:\n        current_start, current_end = interval\n        if current_start > previous_end:\n            available_slots.append((previous_end, current_start))\n        previous_end = max(previous_end, current_end)\n\n    # Check the slot after the last busy interval\n    if previous_end < end_min:\n        available_slots.append((previous_end, end_min))\n\n    # Find the first available slot that can fit the meeting duration\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No available slot found\"\n\n# Define the participants' busy times\nparticipants_busy_times = {\n    \"Jacob\": [(9.0, 9.5), (12.5, 13.0), (14.5, 15.0), (16.5, 17.0)],\n    \"Amanda\": [(10.0, 10.5), (12.0, 12.5)],\n    \"Lisa\": [(11.0, 13.0), (14.5, 16.5)]\n}\n\n# Define work hours and meeting duration\nwork_hours_start = 9.0\nwork_hours_end = 17.0\nduration_hours = 1.0\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_75"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    \"\"\"\n    Find a meeting time that fits all participants' schedules within work hours.\n    \n    Args:\n        participants_schedules: List of lists of busy intervals for each participant.\n        work_hours: Tuple (start, end) of the working day in HH:MM format.\n        duration: Duration of the meeting in minutes.\n    \n    Returns:\n        A string representing the proposed meeting time in HH:MM:HH:MM format.\n    \"\"\"\n    # Convert work hours and busy intervals to minutes since midnight for easier calculation\n    work_start = convert_to_minutes(work_hours[0])\n    work_end = convert_to_minutes(work_hours[1])\n    \n    # Collect all busy intervals from all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start = convert_to_minutes(interval[0])\n            end = convert_to_minutes(interval[1])\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots between work hours and busy intervals\n    available = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting duration\n    for slot in available:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return (f\"{convert_to_hhmm(meeting_start)}:{convert_to_hhmm(meeting_end)}\")\n    \n    return \"No available time slot found\"\n\ndef convert_to_minutes(time_str):\n    \"\"\"Convert HH:MM time string to minutes since midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(':'))\n    return hours * 60 + minutes\n\ndef convert_to_hhmm(minutes):\n    \"\"\"Convert minutes since midnight to HH:MM format.\"\"\"\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Define the participants' schedules\njoyce_schedule = []\nbeverly_schedule = [\n    (\"09:30\", \"10:00\"),\n    (\"11:00\", \"11:30\"),\n    (\"12:30\", \"13:00\"),\n    (\"14:00\", \"14:30\"),\n    (\"15:30\", \"16:00\"),\n    (\"16:30\", \"17:00\")\n]\npeter_schedule = [\n    (\"09:30\", \"10:30\"),\n    (\"11:30\", \"13:00\"),\n    (\"14:30\", \"15:30\"),\n    (\"16:30\", \"17:00\")\n]\n\n# Combine all schedules\nparticipants_schedules = [joyce_schedule, beverly_schedule, peter_schedule]\n\n# Define work hours and meeting duration\nwork_hours = (\"09:00\", \"17:00\")\nduration = 60  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_76"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    duration = 30         # meeting duration in minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    donald_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (15 * 60 + 30, 16 * 60 + 30)\n    ]\n    # Donald doesn't want to meet after 12:00\n    donald_busy.append((12 * 60, work_end))\n\n    joyce_busy = [\n        (11 * 60, 13 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n\n    abigail_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60, 14 * 60),\n        (15 * 60, 17 * 60)\n    ]\n\n    # Combine all busy slots\n    all_busy = donald_busy + joyce_busy + abigail_busy\n\n    # Sort busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check after last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_77"
        },
        {
            "final_program_time": "{12:30:13:30}",
            "expected_time": "{12:30:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours\n    start_min = time_to_minutes(start_work)\n    end_min = time_to_minutes(end_work)\n    \n    # Initialize the free time slots as the entire work day\n    free_slots = [(start_min, end_min)]\n    \n    # Process each participant's busy slots to find common free time\n    for busy_slots in participants_busy:\n        new_free_slots = []\n        for busy_start, busy_end in busy_slots:\n            busy_start_min = time_to_minutes(busy_start)\n            busy_end_min = time_to_minutes(busy_end)\n            updated_slots = []\n            for slot_start, slot_end in free_slots:\n                if busy_end_min <= slot_start or busy_start_min >= slot_end:\n                    # No overlap, keep the slot as is\n                    updated_slots.append((slot_start, slot_end))\n                else:\n                    # Overlap, split the slot\n                    if slot_start < busy_start_min:\n                        updated_slots.append((slot_start, busy_start_min))\n                    if busy_end_min < slot_end:\n                        updated_slots.append((busy_end_min, slot_end))\n            free_slots = updated_slots\n        if not free_slots:\n            return None  # No common free time\n    \n    # Merge adjacent or overlapping slots (not necessary here but good practice)\n    merged_slots = []\n    for slot in sorted(free_slots):\n        if not merged_slots:\n            merged_slots.append(slot)\n        else:\n            last_start, last_end = merged_slots[-1]\n            current_start, current_end = slot\n            if current_start <= last_end:\n                # Merge slots\n                new_slot = (last_start, max(last_end, current_end))\n                merged_slots[-1] = new_slot\n            else:\n                merged_slots.append(slot)\n    \n    # Find the first slot that can accommodate the meeting duration\n    duration_min = duration * 60\n    for slot_start, slot_end in merged_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_end = slot_start + duration_min\n            return f\"{minutes_to_time(slot_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return None\n\n# Define the participants' busy times\nparticipants_busy = [\n    [(\"9:00\", \"10:00\"), (\"11:00\", \"12:00\")],  # Ronald\n    [(\"10:30\", \"11:00\"), (\"14:00\", \"14:30\")],  # Teresa\n    [(\"9:00\", \"12:30\"), (\"14:00\", \"15:30\"), (\"16:00\", \"17:00\")],  # Carol\n]\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration_hours = 1\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_78"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:10:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert all time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start, work_end = map(time_to_minutes, work_hours.split(':'))\n    \n    # Initialize all available slots as free\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's busy slots\n    for busy_slots in participants_busy:\n        new_free_slots = []\n        for busy_start, busy_end in busy_slots:\n            busy_start = time_to_minutes(busy_start)\n            busy_end = time_to_minutes(busy_end)\n            updated_free_slots = []\n            for slot_start, slot_end in free_slots:\n                if busy_start >= slot_end or busy_end <= slot_start:\n                    # No overlap, keep the slot as is\n                    updated_free_slots.append((slot_start, slot_end))\n                else:\n                    # Split the slot around the busy time\n                    if slot_start < busy_start:\n                        updated_free_slots.append((slot_start, busy_start))\n                    if slot_end > busy_end:\n                        updated_free_slots.append((busy_end, slot_end))\n            free_slots = updated_free_slots\n    \n    # Find the first slot that can fit the meeting duration\n    duration_minutes = duration * 60\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    return None\n\n# Define the participants' busy times\namy_busy = [(\"11:00\", \"11:30\"), (\"12:00\", \"12:30\")]\nemma_busy = []\njohn_busy = [(\"10:00\", \"10:30\"), (\"11:30\", \"12:00\"), (\"12:30\", \"16:00\"), (\"16:30\", \"17:00\")]\n\n# Combine all busy times\nparticipants_busy = [amy_busy, emma_busy, john_busy]\n\n# Define work hours and meeting duration\nwork_hours = \"9:00:17:00\"\nduration_hours = 1\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_79"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since midnight\n    michelle_busy = [\n        (9 * 60 + 30, 10 * 60 + 0),\n        (12 * 60 + 30, 13 * 60 + 0)\n    ]\n    billy_busy = [\n        (10 * 60 + 30, 11 * 60 + 0),\n        (11 * 60 + 30, 12 * 60 + 0),\n        (14 * 60 + 30, 15 * 60 + 0),\n        (16 * 60 + 0, 16 * 60 + 30)\n    ]\n    alexis_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (11 * 60 + 0, 12 * 60 + 0),\n        (12 * 60 + 30, 13 * 60 + 0),\n        (13 * 60 + 30, 14 * 60 + 30),\n        (16 * 60 + 0, 16 * 60 + 30)\n    ]\n    alexis_preference_end = 15 * 60  # 15:00 in minutes\n\n    # Generate all possible time slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 1  # Check every minute\n\n    # Check each slot against everyone's busy times and Alexis's preference\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        # Check if slot is before Alexis's preference end time\n        if slot_start >= alexis_preference_end:\n            continue\n        # Check Michelle's availability\n        michelle_available = True\n        for busy_start, busy_end in michelle_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                michelle_available = False\n                break\n        if not michelle_available:\n            continue\n        # Check Billy's availability\n        billy_available = True\n        for busy_start, busy_end in billy_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                billy_available = False\n                break\n        if not billy_available:\n            continue\n        # Check Alexis's availability\n        alexis_available = True\n        for busy_start, busy_end in alexis_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                alexis_available = False\n                break\n        if not alexis_available:\n            continue\n        # If all checks passed, return this slot\n        start_hh = slot_start // 60\n        start_mm = slot_start % 60\n        end_hh = slot_end // 60\n        end_mm = slot_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_80"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 9:00 (540 minutes)\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes  # Add back 540 minutes to start from 9:00\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    # Parse work hours\n    work_start, work_end = map(time_to_minutes, work_hours.split(' to '))\n    work_end -= duration  # No meeting can start after this time\n\n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules.values():\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            busy_intervals.append((start, end))\n    busy_intervals.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1] = (last_start, max(last_end, end))\n            else:\n                merged.append((start, end))\n\n    # Find the first available slot\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end and start - prev_end >= duration:\n            meeting_start = prev_end\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n        prev_end = max(prev_end, end)\n    \n    # Check after last busy interval\n    if prev_end <= work_end and work_end + duration - prev_end >= duration:\n        meeting_start = prev_end\n        meeting_end = meeting_start + duration\n        return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"Jeremy\": [\"14:30 to 15:30\"],\n    \"Lawrence\": [\"15:30 to 16:00\", \"16:30 to 17:00\"],\n    \"Helen\": [\n        \"9:30 to 10:00\",\n        \"10:30 to 11:00\",\n        \"11:30 to 12:00\",\n        \"13:00 to 14:00\",\n        \"15:00 to 15:30\",\n        \"16:00 to 17:00\"\n    ]\n}\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nmeeting_duration = 60  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, meeting_duration))\n```",
            "count": "calendar_scheduling_example_81"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes, work_start, work_end):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration = duration_minutes\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start = time_to_minutes(busy[0])\n            end = time_to_minutes(busy[1])\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start_min\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n    \n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nmichael_schedule = [\n    (\"09:30\", \"10:30\"),\n    (\"15:00\", \"15:30\"),\n    (\"16:00\", \"16:30\")\n]\n\neric_schedule = []\n\narthur_schedule = [\n    (\"09:00\", \"12:00\"),\n    (\"13:00\", \"15:00\"),\n    (\"15:30\", \"16:00\"),\n    (\"16:30\", \"17:00\")\n]\n\nparticipants_schedules = [michael_schedule, eric_schedule, arthur_schedule]\nmeeting_duration = 30\nwork_start = \"09:00\"\nwork_end = \"17:00\"\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, meeting_duration, work_start, work_end))\n```",
            "count": "calendar_scheduling_example_82"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{10:00:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    all_busy_intervals = []\n    for busy_intervals in participants_busy_times.values():\n        for interval in busy_intervals:\n            start, end = interval.split(' to ')\n            all_busy_intervals.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in all_busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability of all participants\n    for interval in free_intervals:\n        start, end = interval\n        duration = end - start\n        if duration >= meeting_duration * 60:\n            meeting_end = start + meeting_duration * 60\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' busy times\nparticipants_busy_times = {\n    \"Anthony\": [\"14:00 to 14:30\", \"15:00 to 15:30\"],\n    \"Ronald\": [\"9:00 to 10:00\", \"12:00 to 12:30\", \"13:30 to 14:00\"],\n    \"Jonathan\": [\"9:00 to 10:00\", \"11:00 to 11:30\", \"12:00 to 13:00\", \"14:00 to 14:30\", \"15:00 to 17:00\"]\n}\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 1  # in hours\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration))\n```",
            "count": "calendar_scheduling_example_83"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration):\n    # Convert all time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = map(time_to_minutes, work_hours)\n    duration_minutes = duration * 60\n    \n    # Generate all busy intervals for each participant in minutes\n    busy_intervals = []\n    for person in participants_busy_times:\n        person_intervals = []\n        for interval in participants_busy_times[person]:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            person_intervals.append((start, end))\n        busy_intervals.append(person_intervals)\n    \n    # Combine all busy intervals and sort them\n    all_busy = []\n    for intervals in busy_intervals:\n        all_busy.extend(intervals)\n    all_busy.sort()\n    \n    # Find the earliest available slot\n    current_start = work_start\n    for start, end in all_busy:\n        if start > current_start and start - current_start >= duration_minutes:\n            return f\"{minutes_to_time(current_start)}:{minutes_to_time(current_start + duration_minutes)}\"\n        current_start = max(current_start, end)\n    \n    # Check after the last busy interval\n    if work_end - current_start >= duration_minutes:\n        return f\"{minutes_to_time(current_start)}:{minutes_to_time(current_start + duration_minutes)}\"\n    \n    return \"No available slot found\"\n\n# Define the participants' busy times\nparticipants_busy_times = {\n    \"Kevin\": [\"9:30 to 10:00\", \"10:30 to 11:00\", \"15:00 to 16:00\"],\n    \"Ryan\": [\"10:30 to 11:30\", \"12:30 to 13:00\", \"13:30 to 14:00\"],\n    \"Eugene\": [\"9:00 to 9:30\", \"10:00 to 11:00\", \"12:30 to 17:00\"]\n}\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 1  # in hours\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_84"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define busy intervals in minutes since midnight\n    # Kelly is free all day, so no busy intervals\n    kelly_busy = []\n    \n    # Julia's busy intervals\n    julia_busy = [\n        (9 * 60 + 30, 10 * 60),      # 9:30-10:00\n        (14 * 60, 14 * 60 + 30),     # 14:00-14:30\n        (15 * 60, 15 * 60 + 30),     # 15:00-15:30\n        (16 * 60 + 30, 17 * 60)      # 16:30-17:00\n    ]\n    # Julia's preference: not after 13:30 (so before 13:30)\n    julia_preference_end = 13 * 60 + 30  # 13:30 in minutes\n    \n    # Martha's busy intervals\n    martha_busy = [\n        (9 * 60, 11 * 60),           # 9:00-11:00\n        (12 * 60, 15 * 60)           # 12:00-15:00\n    ]\n    \n    # Combine all busy intervals for all participants\n    # Since Kelly is free, we only need to consider Julia and Martha\n    all_busy = julia_busy + martha_busy\n    \n    # Generate potential slots\n    potential_slots = []\n    current_start = work_start\n    \n    while current_start + meeting_duration <= work_end:\n        current_end = current_start + meeting_duration\n        slot_valid = True\n        \n        # Check if the slot overlaps with any busy interval\n        for busy_start, busy_end in all_busy:\n            if not (current_end <= busy_start or current_start >= busy_end):\n                slot_valid = False\n                break\n        \n        # Also check Julia's preference (must start and end before 13:30)\n        if current_start >= julia_preference_end:\n            slot_valid = False\n        \n        if slot_valid:\n            potential_slots.append((current_start, current_end))\n        \n        current_start += 15  # Check every 15 minutes for efficiency\n    \n    # Select the first valid slot\n    if potential_slots:\n        meeting_start, meeting_end = potential_slots[0]\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No valid slot found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_85"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for person in schedules:\n        for interval in schedules[person]:\n            start, end = interval.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            busy_intervals.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find free intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Find the first free interval that can fit the meeting\n    for start, end in free_intervals:\n        if end - start >= duration * 60:\n            meeting_start = start\n            meeting_end = meeting_start + duration * 60\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define schedules and constraints\nschedules = {\n    \"Samuel\": [\n        \"9:00 to 9:30\",\n        \"10:00 to 10:30\",\n        \"12:00 to 12:30\",\n        \"14:00 to 15:00\",\n        \"16:00 to 16:30\"\n    ],\n    \"Emma\": [],\n    \"Brittany\": [\n        \"11:30 to 14:30\",\n        \"15:00 to 15:30\",\n        \"16:30 to 17:00\"\n    ]\n}\nwork_hours = \"9:00 to 17:00\"\nduration = 1  # in hours\n\n# Find and print the meeting time\nprint(find_meeting_time(schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_86"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, duration, work_hours):\n    # Convert all time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    all_busy = []\n    for person in participants_busy.values():\n        for interval in person:\n            start, end = interval.split(' to ')\n            all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Merge overlapping or adjacent free intervals (though sorting should prevent overlaps)\n    merged = []\n    for start, end in free_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1] = (last_start, end)\n            else:\n                merged.append((start, end))\n    \n    # Check each free interval for sufficient duration\n    duration_min = duration * 60\n    for start, end in merged:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' busy times\nparticipants_busy = {\n    \"Brittany\": [\"12:00 to 13:30\", \"14:30 to 15:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"],\n    \"Wayne\": [\"9:30 to 10:00\", \"13:00 to 15:00\", \"16:30 to 17:00\"],\n    \"Charles\": [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:30 to 13:30\", \"14:30 to 16:30\"]\n}\n\n# Meeting duration in hours (0.5 hours = 30 minutes)\nmeeting_duration = 0.5\n\n# Work hours\nwork_hours = \"9:00 to 17:00\"\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, meeting_duration, work_hours))\n```",
            "count": "calendar_scheduling_example_87"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:30}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Parse work hours\n    work_start, work_end = work_hours.split(' to ')\n    work_start = int(work_start.split(':')[0]) * 60 + int(work_start.split(':')[1])\n    work_end = int(work_end.split(':')[0]) * 60 + int(work_end.split(':')[1])\n    \n    # Initialize busy slots for all participants\n    busy_slots = []\n    \n    # Process each participant's schedule\n    for schedule in participents_schedules:\n        participant_busy = []\n        for busy in schedule.split('; '):\n            if 'to' in busy:\n                start, end = busy.split(' to ')\n                start_time = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n                end_time = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n                participant_busy.append((start_time, end_time))\n        busy_slots.append(participant_busy)\n    \n    # Find all available slots\n    available_slots = []\n    current_time = work_start\n    \n    while current_time + duration <= work_end:\n        slot_available = True\n        slot_end = current_time + duration\n        \n        # Check if the slot is available for all participants\n        for participant in busy_slots:\n            for busy_start, busy_end in participant:\n                if not (slot_end <= busy_start or current_time >= busy_end):\n                    slot_available = False\n                    break\n            if not slot_available:\n                break\n        \n        if slot_available:\n            available_slots.append((current_time, slot_end))\n        \n        current_time += 15  # Check in 15-minute increments\n    \n    if not available_slots:\n        return None\n    \n    # Return the first available slot\n    first_slot = available_slots[0]\n    start_hour = first_slot[0] // 60\n    start_min = first_slot[0] % 60\n    end_hour = first_slot[1] // 60\n    end_min = first_slot[1] % 60\n    \n    return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n\n# Define the problem\nparticipants_schedules = [\n    \"\",  # Dennis has no meetings\n    \"9:00 to 9:30; 12:30 to 13:00\",  # Joseph\n    \"9:00 to 10:30; 11:30 to 12:00; 13:30 to 14:00; 14:30 to 17:00\"  # Isabella\n]\nwork_hours = \"9:00 to 17:00\"\nduration = 60  # 1 hour in minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_88"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:00:16:00}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 (9:00)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Initialize the free slots for all participants\n    free_slots = []\n    for schedule in participents_schedules:\n        busy = []\n        for block in schedule:\n            start, end = block.split(' to ')\n            busy.append((time_to_minutes(start), time_to_minutes(end)))\n        # Sort busy intervals\n        busy.sort()\n        # Calculate free intervals\n        free = []\n        prev_end = work_start\n        for start, end in busy:\n            if start > prev_end:\n                free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            free.append((prev_end, work_end))\n        free_slots.append(free)\n    \n    # Find common free slots\n    common_free = free_slots[0]\n    for slots in free_slots[1:]:\n        new_common = []\n        i = j = 0\n        while i < len(common_free) and j < len(slots):\n            start1, end1 = common_free[i]\n            start2, end2 = slots[j]\n            # Find the overlap\n            start = max(start1, start2)\n            end = min(end1, end2)\n            if start < end:\n                new_common.append((start, end))\n            # Move the pointer which ends first\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free = new_common\n    \n    # Find the first slot that can fit the duration\n    for start, end in common_free:\n        if end - start >= duration:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define the schedules\nmichelle_schedule = [\"11:00 to 12:00\", \"14:00 to 15:00\"]\nandrea_schedule = [\"9:00 to 9:30\", \"11:30 to 12:30\", \"13:30 to 14:00\", \"14:30 to 15:00\", \"16:00 to 16:30\"]\ndouglas_schedule = [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:00 to 15:00\", \"16:00 to 17:00\"]\n\nparticipants_schedules = [michelle_schedule, andrea_schedule, douglas_schedule]\nwork_hours = \"9:00 to 17:00\"\nduration = 60  # 1 hour in minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_89"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    adam_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    willie_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    gloria_busy = [\n        (9 * 60 + 30, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    # Gloria's preference: avoid after 15:30 (i.e., 15 * 60 + 30)\n    gloria_preference_end = 15 * 60 + 30\n\n    # Generate all possible slots and check availability\n    for start in range(work_start, work_end - meeting_duration + 1, 15):  # Check every 15 minutes\n        end = start + meeting_duration\n        # Check if the slot is within Gloria's preference\n        if end > gloria_preference_end:\n            continue\n        # Check Adam's availability\n        adam_available = True\n        for busy_start, busy_end in adam_busy:\n            if not (end <= busy_start or start >= busy_end):\n                adam_available = False\n                break\n        if not adam_available:\n            continue\n        # Check Willie's availability\n        willie_available = True\n        for busy_start, busy_end in willie_busy:\n            if not (end <= busy_start or start >= busy_end):\n                willie_available = False\n                break\n        if not willie_available:\n            continue\n        # Check Gloria's availability\n        gloria_available = True\n        for busy_start, busy_end in gloria_busy:\n            if not (end <= busy_start or start >= busy_end):\n                gloria_available = False\n                break\n        if not gloria_available:\n            continue\n        # If all are available, return the slot\n        start_time = f\"{start // 60:02d}:{start % 60:02d}\"\n        end_time = f\"{end // 60:02d}:{end % 60:02d}\"\n        return f\"{start_time}:{end_time}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_90"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:14:00}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert work hours and meeting times to minutes for easier calculation\n    work_start, work_end = work_hours\n    work_start_min = work_start[0] * 60 + work_start[1]\n    work_end_min = work_end[0] * 60 + work_end[1]\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    busy_intervals = []\n    \n    for person in participents_schedules:\n        for meeting in participents_schedules[person]:\n            start, end = meeting\n            start_min = start[0] * 60 + start[1]\n            end_min = end[0] * 60 + end[1]\n            busy_intervals.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    previous_end = work_start_min\n    \n    for start, end in merged:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy interval\n    if previous_end < work_end_min:\n        available_slots.append((previous_end, work_end_min))\n    \n    # Find the first available slot that can fit the duration\n    duration_min = duration * 60\n    for start, end in available_slots:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return None\n\n# Define the participants' schedules\nparticipants_schedules = {\n    \"Danielle\": [\n        ((9, 0), (10, 0)),\n        ((10, 30), (11, 0)),\n        ((14, 30), (15, 0)),\n        ((15, 30), (16, 0)),\n        ((16, 30), (17, 0))\n    ],\n    \"Bruce\": [\n        ((11, 0), (11, 30)),\n        ((12, 30), (13, 0)),\n        ((14, 0), (14, 30)),\n        ((15, 30), (16, 0))\n    ],\n    \"Eric\": [\n        ((9, 0), (9, 30)),\n        ((10, 0), (11, 0)),\n        ((11, 30), (13, 0)),\n        ((14, 30), (15, 30))\n    ]\n}\n\n# Define work hours and meeting duration\nwork_hours = ((9, 0), (17, 0))\nduration = 1  # in hours\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_91"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can accommodate the meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define the participants' schedules\njacqueline_schedule = [\"9:30 to 10:00\", \"16:30 to 17:00\"]\nhenry_schedule = []  # Free all day\nwilliam_schedule = [\"9:30 to 10:30\", \"12:30 to 15:00\", \"15:30 to 17:00\"]\n\nparticipants_schedules = [jacqueline_schedule, henry_schedule, william_schedule]\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 60  # 1 hour\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes))\n```",
            "count": "calendar_scheduling_example_92"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert all time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for busy_slots in participants_busy.values():\n        for slot in busy_slots:\n            start, end = slot.split(' to ')\n            busy_intervals.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for a slot that can fit the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' busy times\nparticipants_busy = {\n    \"Austin\": [\"10:30 to 11:00\", \"13:30 to 14:00\"],\n    \"Danielle\": [\"9:00 to 10:00\", \"11:00 to 12:00\", \"13:00 to 13:30\", \"15:30 to 16:00\"],\n    \"Charles\": [\"9:00 to 11:30\", \"12:00 to 12:30\", \"13:00 to 17:00\"],\n}\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nmeeting_duration = 30  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, work_hours, meeting_duration))\n```",
            "count": "calendar_scheduling_example_93"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' schedules and constraints\n    # Nicholas is free all day\n    nicholas_free = [(work_start, work_end)]\n\n    # Elizabeth's meetings in minutes\n    elizabeth_meetings = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60 + 30, 14 * 60 + 30),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    elizabeth_free = []\n    prev_end = work_start\n    for start, end in sorted(elizabeth_meetings):\n        if start > prev_end:\n            elizabeth_free.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        elizabeth_free.append((prev_end, work_end))\n\n    # Sandra's meetings in minutes and constraint (not before 13:00)\n    sandra_meetings = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 13 * 60 + 30),\n        (15 * 60 + 30, 16 * 60 + 30)\n    ]\n    sandra_free = []\n    prev_end = max(work_start, 13 * 60)  # Sandra can't meet before 13:00\n    for start, end in sorted(sandra_meetings):\n        if start > prev_end:\n            sandra_free.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        sandra_free.append((prev_end, work_end))\n\n    # Find overlapping free times for all participants\n    common_free = []\n    i = j = k = 0\n    while i < len(nicholas_free) and j < len(elizabeth_free) and k < len(sandra_free):\n        n_start, n_end = nicholas_free[i]\n        e_start, e_end = elizabeth_free[j]\n        s_start, s_end = sandra_free[k]\n\n        # Find the overlapping start and end\n        overlap_start = max(n_start, e_start, s_start)\n        overlap_end = min(n_end, e_end, s_end)\n\n        if overlap_start < overlap_end:\n            common_free.append((overlap_start, overlap_end))\n        \n        # Move the pointer which has the earliest end time\n        if n_end <= e_end and n_end <= s_end:\n            i += 1\n        elif e_end <= n_end and e_end <= s_end:\n            j += 1\n        else:\n            k += 1\n\n    # Find the first slot that can accommodate a 30-minute meeting\n    meeting_duration = 30\n    for slot in common_free:\n        start, end = slot\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_94"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' schedules and constraints in minutes\n    jennifer_busy = [\n        (12 * 60, 12 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    jennifer_preference = 12 * 60 + 30  # Not before 12:30\n\n    gary_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n\n    frances_busy = [\n        (9 * 60, 11 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (13 * 60, 17 * 60)\n    ]\n\n    # Duration of the meeting in minutes\n    duration = 30\n\n    # Generate all possible time slots\n    possible_slots = []\n    current_time = work_start\n\n    while current_time + duration <= work_end:\n        slot_end = current_time + duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 30  # Check every 30 minutes\n\n    # Check each slot against all constraints\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n\n        # Check Jennifer's availability and preference\n        jennifer_available = True\n        for busy_start, busy_end in jennifer_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                jennifer_available = False\n                break\n        if slot_start < jennifer_preference:\n            jennifer_available = False\n\n        # Check Gary's availability\n        gary_available = True\n        for busy_start, busy_end in gary_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                gary_available = False\n                break\n\n        # Check Frances' availability\n        frances_available = True\n        for busy_start, busy_end in frances_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                frances_available = False\n                break\n\n        # If all are available, return the slot\n        if jennifer_available and gary_available and frances_available:\n            # Convert minutes back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_95"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:9:30}",
            "type_error": "TypeError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # 9:00 is 540 minutes\n    \n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes  # Convert back to absolute minutes\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    start_min = time_to_minutes(start_work)\n    end_min = time_to_minutes(end_work)\n    \n    # Initialize a list to mark busy times\n    busy = [False] * (end_min - start_min)\n    \n    # Mark busy times for each participant\n    for schedule in participants_schedules:\n        for busy_range in schedule:\n            start, end = busy_range.split(' to ')\n            start_busy = time_to_minutes(start)\n            end_busy = time_to_minutes(end)\n            # Mark the range in the busy list\n            for i in range(max(0, start_busy - start_min), min(len(busy), end_busy - start_min)):\n                busy[i] = True\n    \n    # Find a free slot of duration minutes\n    duration_min = duration * 60  # Convert hours to minutes\n    current_start = 0\n    while current_start < len(busy):\n        if not busy[current_start]:\n            # Check if the next 'duration_min' slots are free\n            slot_available = True\n            for i in range(current_start, min(current_start + duration_min, len(busy))):\n                if busy[i]:\n                    slot_available = False\n                    current_start = i + 1\n                    break\n            if slot_available and (current_start + duration_min) <= len(busy):\n                end_slot = current_start + duration_min\n                start_time = minutes_to_time(current_start + start_min)\n                end_time = minutes_to_time(end_slot + start_min)\n                return f\"{start_time}:{end_time}\"\n        else:\n            current_start += 1\n    return \"No available slot found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"9:30 to 10:00\", \"10:30 to 11:00\", \"11:30 to 13:00\", \"15:00 to 15:30\"],  # Christopher\n    [\"9:30 to 10:00\", \"11:00 to 11:30\", \"12:00 to 12:30\", \"13:30 to 14:30\", \"15:00 to 15:30\"],  # Robert\n    [\"10:00 to 17:00\"]  # Wayne\n]\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nduration = 0.5  # half an hour\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_96"
        },
        {
            "final_program_time": "{16:00:17:00}",
            "expected_time": "{16:00:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n    \n    # Convert each person's busy slots to minutes since midnight\n    joseph_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60 + 30, 15 * 60 + 30)\n    ]\n    kyle_busy = [\n        (12 * 60 + 30, 13 * 60 + 30)\n    ]\n    joan_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    \n    # Joseph's constraint: not before 14:30\n    joseph_constraint = 14 * 60 + 30\n    \n    # Combine all busy slots\n    all_busy = []\n    for busy in [joseph_busy, kyle_busy, joan_busy]:\n        all_busy.extend(busy)\n    \n    # Sort busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that fits the meeting duration and Joseph's constraint\n    for start, end in free_slots:\n        slot_start = max(start, joseph_constraint)\n        if end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_97"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define busy intervals in minutes for each participant\n    juan_busy = [(9 * 60, 10 * 60 + 30), (15 * 60 + 30, 16 * 60)]\n    marilyn_busy = [(11 * 60, 11 * 60 + 30), (12 * 60 + 30, 13 * 60)]\n    ronald_busy = [(9 * 60, 10 * 60 + 30), (12 * 60, 12 * 60 + 30), \n                   (13 * 60, 13 * 60 + 30), (14 * 60, 16 * 60 + 30)]\n    \n    # Juan cannot meet after 16:00\n    juan_limit = 16 * 60\n    \n    # Combine all busy intervals and sort them\n    all_busy = juan_busy + marilyn_busy + ronald_busy\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy intervals\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the time after the last busy interval\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Check each free slot for a 30-minute window that fits all constraints\n    meeting_duration = 30\n    for slot_start, slot_end in free_slots:\n        current_start = slot_start\n        while current_start + meeting_duration <= slot_end:\n            # Check if the meeting fits and respects Juan's limit\n            if current_start + meeting_duration <= juan_limit:\n                return (\n                    f\"{current_start // 60:02d}:{current_start % 60:02d}:\"\n                    f\"{(current_start + meeting_duration) // 60:02d}:{(current_start + meeting_duration) % 60:02d}\"\n                )\n            current_start += 1  # Move to the next minute\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_98"
        },
        {
            "final_program_time": "{15:00:16:00}",
            "expected_time": "{15:00:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Define each person's busy times in minutes since midnight\n    stephanie_busy = [(9 * 60, 9 * 60 + 30), (13 * 60 + 30, 14 * 60)]\n    scott_busy = [(9 * 60, 10 * 60), (11 * 60, 12 * 60 + 30), (14 * 60 + 30, 15 * 60), (16 * 60, 17 * 60)]\n    mark_preference = (15 * 60, work_end)  # Mark prefers after 15:00\n\n    # Combine all busy times and sort\n    all_busy = stephanie_busy + scott_busy\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy times and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Filter free slots that meet the duration and Mark's preference\n    valid_slots = []\n    for start, end in free_slots:\n        slot_start = max(start, mark_preference[0])\n        slot_end = min(end, mark_preference[1])\n        if slot_end - slot_start >= meeting_duration:\n            valid_slots.append((slot_start, slot_end))\n\n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Format the output as HH:MM:HH:MM\n        return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    else:\n        return \"No valid time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_99"
        },
        {
            "final_program_time": "{11:00:12:00}",
            "expected_time": "{11:00:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy times for all participants\n    all_busy_times = []\n    for busy_times in participants_busy_times:\n        for start, end in busy_times:\n            all_busy_times.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy times by start time\n    all_busy_times.sort()\n    \n    # Find free slots by checking gaps between busy times and work hours\n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy_times:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Check each free slot for availability of duration\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' busy times\ndenise_busy = []\njoseph_busy = []\nhenry_busy = [(\"09:00\", \"09:30\"), (\"10:00\", \"10:30\"), (\"12:00\", \"14:30\"), (\"15:00\", \"16:00\"), (\"16:30\", \"17:00\")]\nchristian_busy = [(\"09:00\", \"11:00\"), (\"14:30\", \"15:30\"), (\"16:00\", \"17:00\")]\n\nparticipants_busy_times = [denise_busy, joseph_busy, henry_busy, christian_busy]\n\n# Define work hours and meeting duration\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 60  # 1 hour\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_100"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    start, end = work_hours\n    # Convert time strings to minutes since 9:00 for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 9 * 60  # Offset by 9:00 (540 minutes)\n\n    def minutes_to_time(minutes):\n        total_minutes = 9 * 60 + minutes\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    # Initialize the free slots for all participants\n    free_slots = []\n    for schedule in participants_schedules:\n        busy = []\n        for block in schedule:\n            s, e = block.split(' to ')\n            busy.append((time_to_minutes(s), time_to_minutes(e)))\n        # Generate free slots by finding gaps between busy blocks\n        free = []\n        prev_end = 0\n        for s, e in sorted(busy):\n            if s > prev_end:\n                free.append((prev_end, s))\n            prev_end = max(prev_end, e)\n        if prev_end < time_to_minutes(end):\n            free.append((prev_end, time_to_minutes(end)))\n        free_slots.append(free)\n\n    # Find overlapping free slots across all participants\n    common_free = free_slots[0]\n    for slots in free_slots[1:]:\n        new_common = []\n        i = j = 0\n        while i < len(common_free) and j < len(slots):\n            s1, e1 = common_free[i]\n            s2, e2 = slots[j]\n            # Find the overlap\n            overlap_s = max(s1, s2)\n            overlap_e = min(e1, e2)\n            if overlap_s < overlap_e:\n                new_common.append((overlap_s, overlap_e))\n            # Move the pointer which ends first\n            if e1 < e2:\n                i += 1\n            else:\n                j += 1\n        common_free = new_common\n\n    # Find the first slot that can fit the duration\n    for slot in common_free:\n        s, e = slot\n        if e - s >= duration:\n            meeting_start = minutes_to_time(s)\n            meeting_end = minutes_to_time(s + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n\n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"10:00 to 10:30\", \"14:30 to 15:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"],  # Madison\n    [],  # Linda\n    [\"9:00 to 12:00\", \"12:30 to 16:00\", \"16:30 to 17:00\"],  # Logan\n    [\"9:30 to 11:00\", \"11:30 to 12:00\", \"13:00 to 14:30\", \"15:00 to 15:30\", \"16:00 to 17:00\"],  # Virginia\n]\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_hours = (\"9:00\", \"17:00\")\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, duration, work_hours))\n```",
            "count": "calendar_scheduling_example_101"
        },
        {
            "final_program_time": "{11:00:12:00}",
            "expected_time": "{11:00:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert all schedules to minutes for easier comparison\n    # Each person's busy times are represented as (start, end) in minutes\n    dylan_busy = [(14 * 60, 15 * 60)]\n    kathryn_busy = [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30)]\n    hannah_busy = [(9 * 60, 10 * 60 + 30), (12 * 60 + 30, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)]\n    anna_busy = [(9 * 60, 11 * 60), (12 * 60, 14 * 60), (14 * 60 + 30, 15 * 60), (16 * 60, 16 * 60 + 30)]\n    \n    # Combine all busy times and sort them\n    all_busy = dylan_busy + kathryn_busy + hannah_busy + anna_busy\n    all_busy.sort()\n    \n    # Find the earliest available slot of 60 minutes\n    current_time = work_start\n    meeting_duration = 60\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > current_time:\n            if busy_start - current_time >= meeting_duration:\n                # Found a slot\n                end_time = current_time + meeting_duration\n                return f\"{current_time // 60:02d}:{current_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n        # Update current_time to the end of the busy period if it's later\n        if busy_end > current_time:\n            current_time = busy_end\n    \n    # Check the remaining time after the last busy period\n    if work_end - current_time >= meeting_duration:\n        end_time = current_time + meeting_duration\n        return f\"{current_time // 60:02d}:{current_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n    \n    # If no slot found (though the problem states there is one)\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_102"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all blocked time slots\n    blocked_slots = []\n    for schedule in participants_schedules:\n        for slot in schedule:\n            start, end = map(time_to_minutes, slot.split(' to '))\n            blocked_slots.append((start, end))\n    \n    # Sort blocked slots by start time\n    blocked_slots.sort()\n    \n    # Find available slots by checking gaps between blocked slots and work hours\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in blocked_slots:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Check each available slot for duration\n    duration = duration_minutes\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\ndiane_schedule = [\"9:30 to 10:00\", \"14:30 to 15:00\"]\njack_schedule = [\"13:30 to 14:00\", \"14:30 to 15:00\"]\neugene_schedule = [\"9:00 to 10:00\", \"10:30 to 11:30\", \"12:00 to 14:30\", \"15:00 to 16:30\"]\npatricia_schedule = [\"9:30 to 10:30\", \"11:00 to 12:00\", \"12:30 to 14:00\", \"15:00 to 16:30\"]\n\nall_schedules = [diane_schedule, jack_schedule, eugene_schedule, patricia_schedule]\n\n# Find meeting time\nmeeting_time = find_meeting_time(all_schedules, \"9:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_103"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time strings to minutes since 9:00 (work_hours_start)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - work_hours_start) * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = work_hours_start + (minutes // 60)\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        person_busy = []\n        for block in schedule:\n            start, end = block.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            person_busy.append((start_min, end_min))\n        busy_intervals.append(person_busy)\n    \n    # Find the earliest and latest possible times in minutes\n    earliest_start = 0\n    latest_end = (work_hours_end - work_hours_start) * 60\n    \n    # Generate all possible time slots and check for availability\n    for start in range(earliest_start, latest_end - duration_minutes + 1):\n        end = start + duration_minutes\n        if end > latest_end:\n            continue\n        # Check if the slot is free for all participants\n        all_free = True\n        for person_busy in busy_intervals:\n            person_free = True\n            for (busy_start, busy_end) in person_busy:\n                if not (end <= busy_start or start >= busy_end):\n                    person_free = False\n                    break\n            if not person_free:\n                all_free = False\n                break\n        if all_free:\n            start_time = minutes_to_time(start)\n            end_time = minutes_to_time(end)\n            return f\"{start_time}:{end_time}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"9:00 to 10:30\", \"16:30 to 17:00\"],  # Karen\n    [\"9:30 to 10:00\", \"10:30 to 11:00\", \"11:30 to 12:30\", \"15:30 to 16:00\", \"16:30 to 17:00\"],  # Brandon\n    [\"9:00 to 10:30\", \"11:00 to 14:00\", \"14:30 to 17:00\"],  # Donald\n    [\"9:00 to 9:30\", \"10:30 to 11:00\", \"11:30 to 12:00\", \"13:30 to 14:00\", \"14:30 to 15:30\", \"16:00 to 17:00\"]  # Kelly\n]\n\n# Define work hours and meeting duration\nwork_hours_start = 9\nwork_hours_end = 17\nduration_minutes = 30\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_104"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between merged intervals and work hours\n    available = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n    \n    # Check each available slot for the first that can fit the duration\n    duration_min = duration * 60\n    for start, end in available:\n        if end - start >= duration_min:\n            meeting_end = start + duration_min\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules\njason_schedule = [\n    \"9:00 to 10:00\",\n    \"10:30 to 11:00\",\n    \"11:30 to 12:00\",\n    \"12:30 to 13:00\",\n    \"14:00 to 14:30\"\n]\n\nwilliam_schedule = [\n    \"9:00 to 9:30\",\n    \"11:30 to 12:00\",\n    \"14:00 to 14:30\",\n    \"16:30 to 17:00\"\n]\n\nfrances_schedule = [\n    \"9:00 to 9:30\",\n    \"10:00 to 10:30\",\n    \"11:00 to 12:30\",\n    \"13:30 to 16:00\"\n]\n\nrachel_schedule = [\n    \"9:00 to 9:30\",\n    \"10:00 to 10:30\",\n    \"11:00 to 14:00\",\n    \"14:30 to 16:00\",\n    \"16:30 to 17:00\"\n]\n\n# Combine all schedules\nparticipants_schedules = [jason_schedule, william_schedule, frances_schedule, rachel_schedule]\n\n# Find a meeting time\nmeeting_time = find_meeting_time(participants_schedules, 30, \"9:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_105"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{10:00:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n    \n    # Check each available slot for sufficient duration\n    for slot in available:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"12:30 to 13:30\", \"14:30 to 15:00\", \"16:30 to 17:00\"],  # Olivia\n    [],  # Anna\n    [\"09:00 to 10:00\", \"11:30 to 16:00\", \"16:30 to 17:00\"],  # Virginia\n    [\"09:00 to 09:30\", \"11:00 to 11:30\", \"13:00 to 14:00\", \"14:30 to 16:00\", \"16:30 to 17:00\"],  # Paul\n]\n\n# Define meeting parameters\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 60  # 1 hour\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_106"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert all time strings to minutes since 9:00 (work_hours_start)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - work_hours_start * 60\n\n    work_hours_start_min = time_to_minutes(f\"{work_hours_start}:00\")\n    work_hours_end_min = time_to_minutes(f\"{work_hours_end}:00\")\n\n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append([start, end])\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1][1] = max(end, last_end)\n            else:\n                merged.append([start, end])\n\n    # Check the available slots before first busy interval, between intervals, and after last busy interval\n    available_slots = []\n    prev_end = work_hours_start_min\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = end\n    if prev_end < work_hours_end_min:\n        available_slots.append((prev_end, work_hours_end_min))\n\n    # Find the first available slot that can fit the meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = (minutes + work_hours_start * 60) // 60\n                mm = (minutes + work_hours_start * 60) % 60\n                return f\"{hh:02d}:{mm:02d}\"\n\n            meeting_start = minutes_to_time(slot_start)\n            meeting_end = minutes_to_time(slot_start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n\n    return \"No available slot found\"\n\n# Define the participants' schedules\npeter_schedule = [\n    \"9:00 to 9:30\",\n    \"10:30 to 11:00\",\n    \"11:30 to 12:00\",\n    \"12:30 to 13:00\"\n]\njudith_schedule = []\nkeith_schedule = [\n    \"11:30 to 12:00\",\n    \"12:30 to 15:00\",\n    \"15:30 to 16:00\",\n    \"16:30 to 17:00\"\n]\nevelyn_schedule = [\n    \"9:00 to 12:30\",\n    \"13:30 to 15:30\",\n    \"16:30 to 17:00\"\n]\n\nparticipants_schedules = [peter_schedule, judith_schedule, keith_schedule, evelyn_schedule]\nmeeting_duration = 30  # minutes\nwork_hours_start = 9\nwork_hours_end = 17\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, meeting_duration, work_hours_start, work_hours_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_107"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each person's busy slots to minutes\n    # Lisa's busy slots: 9:00-9:30, 10:00-10:30, 13:00-14:00, 15:00-16:00\n    lisa_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (13 * 60, 14 * 60),\n        (15 * 60, 16 * 60)\n    ]\n    \n    # Dorothy's busy slots: 9:00-9:30, 10:30-11:30, 13:30-14:00, 14:30-15:30\n    dorothy_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 11 * 60 + 30),\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60 + 30)\n    ]\n    \n    # Anthony's busy slots: 9:00-10:00, 11:00-12:30, 13:00-14:00, 15:00-16:30\n    anthony_busy = [\n        (9 * 60, 10 * 60),\n        (11 * 60, 12 * 60 + 30),\n        (13 * 60, 14 * 60),\n        (15 * 60, 16 * 60 + 30)\n    ]\n    \n    # Ryan's busy slots: 9:00-12:30, 13:00-16:30\n    ryan_busy = [\n        (9 * 60, 12 * 60 + 30),\n        (13 * 60, 16 * 60 + 30)\n    ]\n    \n    # Lisa cannot meet before 14:30\n    lisa_constraint = 14 * 60 + 30\n    \n    # Meeting duration is 30 minutes\n    duration = 30\n    \n    # Generate all possible slots and check for availability\n    for start in range(work_start, work_end - duration + 1, 15):  # Check every 15 minutes\n        end = start + duration\n        # Check Lisa's constraints\n        if start < lisa_constraint:\n            continue\n        # Check if the slot is free for everyone\n        lisa_free = all(not (s < end and e > start) for s, e in lisa_busy)\n        dorothy_free = all(not (s < end and e > start) for s, e in dorothy_busy)\n        anthony_free = all(not (s < end and e > start) for s, e in anthony_busy)\n        ryan_free = all(not (s < end and e > start) for s, e in ryan_busy)\n        \n        if lisa_free and dorothy_free and anthony_free and ryan_free:\n            # Convert start and end back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = end // 60\n            end_mm = end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_108"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy blocks to minutes since 9:00\n    marie_busy = [(11*60, 11*60 + 30), (15*60, 16*60 + 30)]\n    janice_busy = [(12*60 + 30, 13*60), (13*60 + 30, 15*60)]\n    elijah_busy = [(10*60, 13*60), (14*60 + 30, 15*60), (16*60, 16*60 + 30)]\n    theresa_busy = [(9*60 + 30, 10*60 + 30), (12*60, 13*60), (13*60 + 30, 14*60),\n                    (14*60 + 30, 15*60), (15*60 + 30, 16*60), (16*60 + 30, 17*60)]\n    theresa_no_meet_after = 12 * 60  # No meetings after 12:00\n\n    # Generate all possible 30-minute slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 1  # Check every minute for availability\n\n    # Check each slot against everyone's constraints\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n\n        # Check Theresa's preference (no meetings after 12:00)\n        if slot_start >= theresa_no_meet_after:\n            continue\n\n        # Check Marie's availability\n        marie_available = True\n        for busy_start, busy_end in marie_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                marie_available = False\n                break\n        if not marie_available:\n            continue\n\n        # Check Janice's availability\n        janice_available = True\n        for busy_start, busy_end in janice_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                janice_available = False\n                break\n        if not janice_available:\n            continue\n\n        # Check Elijah's availability\n        elijah_available = True\n        for busy_start, busy_end in elijah_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                elijah_available = False\n                break\n        if not elijah_available:\n            continue\n\n        # Check Theresa's availability\n        theresa_available = True\n        for busy_start, busy_end in theresa_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                theresa_available = False\n                break\n        if not theresa_available:\n            continue\n\n        # If all checks passed, return this slot\n        start_h = slot_start // 60\n        start_m = slot_start % 60\n        end_h = slot_end // 60\n        end_m = slot_end % 60\n        return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n\n    return \"No suitable time found\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_109"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define each person's busy times in minutes (start, end)\n    helen_busy = [\n        (9 * 60, 12 * 60),\n        (12 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    ashley_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    grace_preference_end = 15 * 60  # Grace prefers no meetings after 15:00\n\n    # Combine all busy times for Helen and Ashley\n    combined_busy = helen_busy + ashley_busy\n    # Sort by start time\n    combined_busy.sort()\n\n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = work_start\n\n    for busy_start, busy_end in combined_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    # Check the time after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Filter free slots that are at least 30 minutes and before Grace's preference\n    possible_slots = []\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= 30 and slot_start < grace_preference_end:\n            possible_slots.append((slot_start, slot_end))\n\n    # Select the earliest possible slot\n    if possible_slots:\n        meeting_start = possible_slots[0][0]\n        meeting_end = meeting_start + 30\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_110"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:00:12:30}",
            "type_error": "SyntaxError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours=('09:00', '17:00')):\n    # Convert time strings to minutes since 00:00 for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start, work_end = map(time_to_minutes, work_hours)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    \n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            all_busy.append((time_to_minutes(busy_start), time_to_minutes(busy_end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append([start, end])\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = [new_start, new_end]\n            else:\n                merged_busy.append([start, end])\n    \n    # Find available slots by looking at gaps between busy intervals\n    available_slots = []\n    previous_end = work_start\n    \n    for start, end in merged_busy:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy interval\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [('09:00', '10:00'), ('10:30', '11:30'), ('12:30', '13:00'), ('13:30', '14:00')],  # Gregory\n    [],  # Natalie\n    [('09:00', '11:30'), ('13:30', '17:00')],  # Christine\n    [('09:00', '09:30'), ('10:30', '12:00'), ('12:30', '14:00'), ('14:30', '17:00')],  # Vincent\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_111"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration_minutes):\n    # Convert work hours and schedules to minutes since start of day\n    work_start, work_end = work_hours\n    work_start_min = work_start[0] * 60 + work_start[1]\n    work_end_min = work_end[0] * 60 + work_end[1]\n    \n    # Initialize the free slots for all participants\n    free_slots = []\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start_min = busy[0][0] * 60 + busy[0][1]\n            end_min = busy[1][0] * 60 + busy[1][1]\n            busy_slots.append((start_min, end_min))\n        \n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Calculate free slots for the participant\n        participant_free = []\n        prev_end = work_start_min\n        for busy_start, busy_end in busy_slots:\n            if busy_start > prev_end:\n                participant_free.append((prev_end, busy_start))\n            prev_end = max(prev_end, busy_end)\n        if prev_end < work_end_min:\n            participant_free.append((prev_end, work_end_min))\n        \n        free_slots.append(participant_free)\n    \n    # Find overlapping free slots across all participants\n    common_free = free_slots[0]\n    for participant_free in free_slots[1:]:\n        new_common_free = []\n        i = j = 0\n        while i < len(common_free) and j < len(participant_free):\n            start1, end1 = common_free[i]\n            start2, end2 = participant_free[j]\n            \n            # Find overlap\n            overlap_start = max(start1, start2)\n            overlap_end = min(end1, end2)\n            \n            if overlap_start < overlap_end:\n                new_common_free.append((overlap_start, overlap_end))\n            \n            # Move the pointer which ends first\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free = new_common_free\n    \n    # Find the first slot that can accommodate the meeting\n    for slot in common_free:\n        start, end = slot\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return None\n\n# Define work hours (9:00 to 17:00)\nwork_hours = ((9, 0), (17, 0))\n\n# Define participants' schedules in HH:MM format converted to tuples\nparticipants_schedules = [\n    # Jean's schedule\n    [\n        ((11, 0), (11, 30)),\n        ((12, 30), (13, 30)),\n        ((14, 0), (14, 30)),\n        ((15, 0), (15, 30)),\n        ((16, 30), (17, 0))\n    ],\n    # Jose's schedule (no meetings)\n    [],\n    # Samuel's schedule\n    [\n        ((9, 0), (12, 0)),\n        ((12, 30), (16, 0)),\n        ((16, 30), (17, 0))\n    ],\n    # Henry's schedule\n    [\n        ((9, 0), (10, 30)),\n        ((14, 0), (14, 30)),\n        ((15, 0), (17, 0))\n    ]\n]\n\n# Meeting duration is 30 minutes\nduration = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_112"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:00:10:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find available slots by merging busy intervals\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nbradley_schedule = [\"9:30:10:00\", \"12:30:13:00\", \"13:30:14:00\", \"15:30:16:00\"]\nteresa_schedule = [\"10:30:11:00\", \"12:00:12:30\", \"13:00:13:30\", \"14:30:15:00\"]\nelizabeth_schedule = [\"9:00:9:30\", \"10:30:11:30\", \"13:00:13:30\", \"14:30:15:00\", \"15:30:17:00\"]\nchristian_schedule = [\"9:00:9:30\", \"10:30:17:00\"]\n\n# Combine all schedules\nparticipants_schedules = [bradley_schedule, teresa_schedule, elizabeth_schedule, christian_schedule]\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, \"9:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_113"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    stephanie_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    cheryl_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    bradley_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 11 * 60 + 30),\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    steven_busy = [\n        (9 * 60, 12 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 17 * 60)\n    ]\n\n    # Combine all busy slots\n    all_busy = []\n    for slot in stephanie_busy:\n        all_busy.append(('Stephanie', slot))\n    for slot in cheryl_busy:\n        all_busy.append(('Cheryl', slot))\n    for slot in bradley_busy:\n        all_busy.append(('Bradley', slot))\n    for slot in steven_busy:\n        all_busy.append(('Steven', slot))\n\n    # Sort all busy slots by start time\n    all_busy.sort(key=lambda x: x[1][0])\n\n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n\n    for person, (start, end) in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check if there's a free slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate 60 minutes\n    meeting_duration = 60\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Check if all participants are free during this slot\n            valid = True\n            # Check Stephanie\n            for s_start, s_end in stephanie_busy:\n                if not (end <= s_start or start >= s_end):\n                    valid = False\n                    break\n            if not valid:\n                continue\n            # Check Cheryl\n            for c_start, c_end in cheryl_busy:\n                if not (end <= c_start or start >= c_end):\n                    valid = False\n                    break\n            if not valid:\n                continue\n            # Check Bradley\n            for b_start, b_end in bradley_busy:\n                if not (end <= b_start or start >= b_end):\n                    valid = False\n                    break\n            if not valid:\n                continue\n            # Check Steven\n            for st_start, st_end in steven_busy:\n                if not (end <= st_start or start >= st_end):\n                    valid = False\n                    break\n            if valid:\n                # Convert minutes back to HH:MM format\n                start_hh = start // 60\n                start_mm = start % 60\n                end_hh = (start + meeting_duration) // 60\n                end_mm = (start + meeting_duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_114"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy times in minutes since midnight\n    busy_times = {\n        'Jose': [],\n        'Catherine': [(12 * 60, 12 * 60 + 30), (15 * 60, 15 * 60 + 30)],\n        'Rachel': [\n            (9 * 60, 9 * 60 + 30),\n            (10 * 60, 11 * 60),\n            (11 * 60 + 30, 12 * 60),\n            (12 * 60 + 30, 13 * 60),\n            (14 * 60, 16 * 60),\n            (16 * 60 + 30, 17 * 60)\n        ],\n        'Lori': [\n            (9 * 60, 12 * 60),\n            (13 * 60, 13 * 60 + 30),\n            (14 * 60 + 30, 15 * 60 + 30),\n            (16 * 60 + 30, 17 * 60)\n        ]\n    }\n    \n    # Catherine's preference: not before 14:00\n    preference_start = 14 * 60\n    \n    # Meeting duration in minutes\n    duration = 30\n    \n    # Generate all possible slots and check availability\n    for start in range(preference_start, work_end - duration + 1, 15):  # Check in 15-minute increments\n        end = start + duration\n        if end > work_end:\n            continue\n        \n        # Check if the slot is free for all participants\n        all_free = True\n        for participant, busy_slots in busy_times.items():\n            for busy_start, busy_end in busy_slots:\n                if not (end <= busy_start or start >= busy_end):\n                    all_free = False\n                    break\n            if not all_free:\n                break\n        \n        if all_free:\n            # Format the time as HH:MM:HH:MM\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = end // 60\n            end_mm = end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_115"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define busy intervals in minutes for each participant\n    adam_busy = [(14 * 60, 15 * 60)]\n    john_busy = [(13 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30), \n                 (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)]\n    stephanie_busy = [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 11 * 60), \n                      (11 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)]\n    anna_busy = [(9 * 60 + 30, 10 * 60), (12 * 60, 12 * 60 + 30), \n                 (13 * 60, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)]\n    \n    # Anna's preference: not before 14:30\n    anna_preference_start = 14 * 60 + 30\n    \n    # Meeting duration in minutes\n    meeting_duration = 30\n    \n    # Generate all possible slots starting from 14:30 to end of work day\n    for start in range(anna_preference_start, work_end - meeting_duration + 1, 15):\n        end = start + meeting_duration\n        # Check if the slot is free for all participants\n        adam_free = all(not (start < busy_end and end > busy_start) for busy_start, busy_end in adam_busy)\n        john_free = all(not (start < busy_end and end > busy_start) for busy_start, busy_end in john_busy)\n        stephanie_free = all(not (start < busy_end and end > busy_start) for busy_start, busy_end in stephanie_busy)\n        anna_free = all(not (start < busy_end and end > busy_start) for busy_start, busy_end in anna_busy)\n        \n        if adam_free and john_free and stephanie_free and anna_free:\n            # Format the time as HH:MM:HH:MM\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = end // 60\n            end_mm = end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_116"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    brian_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (12 * 60, 13 * 60),\n        (14 * 60, 14 * 60 + 30)\n    ]\n    ronald_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    denise_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    jesse_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 13 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n\n    # Jesse's preference: avoid after 15:00\n    jesse_preference_end = 15 * 60\n\n    # Generate all possible slots\n    possible_slots = []\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        # Check if the slot is before Jesse's preference\n        if slot_end > jesse_preference_end:\n            current_time += 1\n            continue\n        # Check if all are free\n        brian_free = all(not (start <= current_time < end or start < slot_end <= end) for start, end in brian_busy)\n        ronald_free = all(not (start <= current_time < end or start < slot_end <= end) for start, end in ronald_busy)\n        denise_free = all(not (start <= current_time < end or start < slot_end <= end) for start, end in denise_busy)\n        jesse_free = all(not (start <= current_time < end or start < slot_end <= end) for start, end in jesse_busy)\n        if brian_free and ronald_free and denise_free and jesse_free:\n            possible_slots.append((current_time, slot_end))\n        current_time += 1\n\n    # Select the first available slot\n    if possible_slots:\n        start, end = possible_slots[0]\n        # Convert back to HH:MM format\n        start_hh = start // 60\n        start_mm = start % 60\n        end_hh = end // 60\n        end_mm = end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_117"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for person in participants_schedules:\n        busy_intervals = []\n        for interval in participants_schedules[person]:\n            start, end = interval.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            busy_intervals.append((start_min, end_min))\n        all_busy_intervals.append(busy_intervals)\n    \n    # Find all possible free intervals for all participants\n    possible_start_times = []\n    \n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        valid = True\n        for busy_intervals in all_busy_intervals:\n            for start, end in busy_intervals:\n                if current_time < end and current_time + meeting_duration > start:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            possible_start_times.append(current_time)\n        current_time += 15  # Check every 15 minutes for efficiency\n    \n    if possible_start_times:\n        first_available = possible_start_times[0]\n        end_time = first_available + meeting_duration\n        return f\"{minutes_to_time(first_available)}:{minutes_to_time(end_time)}\"\n    else:\n        return \"No available time found\"\n\n# Define the participants' schedules\nparticipants_schedules = {\n    'Ruth': ['9:30 to 10:00', '11:00 to 11:30', '12:00 to 12:30', '13:00 to 13:30', '14:30 to 15:00', '16:00 to 16:30'],\n    'Angela': ['9:00 to 9:30', '12:30 to 13:00', '13:30 to 15:00', '16:00 to 16:30'],\n    'Lisa': ['10:30 to 11:00', '11:30 to 14:00', '14:30 to 15:30', '16:00 to 17:00'],\n    'Cheryl': ['9:00 to 10:30', '11:00 to 11:30', '12:30 to 14:00', '16:00 to 16:30']\n}\n\n# Define work hours and meeting duration\nwork_hours_start = '9:00'\nwork_hours_end = '17:00'\nmeeting_duration = 30  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_118"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours=('09:00', '17:00')):\n    # Convert work hours to minutes since midnight\n    work_start = int(work_hours[0].split(':')[0]) * 60 + int(work_hours[0].split(':')[1])\n    work_end = int(work_hours[1].split(':')[0]) * 60 + int(work_hours[1].split(':')[1])\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for schedule in participants_schedules:\n        busy_intervals = []\n        for interval in schedule:\n            start, end = interval.split(' to ')\n            start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n            end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n            busy_intervals.append((start_min, end_min))\n        all_busy_intervals.append(busy_intervals)\n    \n    # Find all possible slots where all participants are free\n    for time in range(work_start, work_end - duration_minutes + 1):\n        slot_start = time\n        slot_end = time + duration_minutes\n        valid = True\n        \n        for busy_intervals in all_busy_intervals:\n            overlap = False\n            for (busy_start, busy_end) in busy_intervals:\n                if not (slot_end <= busy_start or slot_start >= busy_end):\n                    overlap = True\n                    break\n            if overlap:\n                valid = False\n                break\n        \n        if valid:\n            # Format the time as HH:MM:HH:MM\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"09:00 to 09:30\", \"10:30 to 11:30\", \"13:30 to 14:00\", \"14:30 to 15:30\"],  # Scott\n    [\"10:00 to 10:30\", \"14:30 to 15:00\"],  # Laura\n    [\"09:00 to 09:30\", \"10:00 to 15:00\", \"15:30 to 17:00\"],  # Marilyn\n    [\"09:00 to 09:30\", \"10:00 to 10:30\", \"11:00 to 12:00\", \"12:30 to 16:00\", \"16:30 to 17:00\"]  # Natalie\n]\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules))\n```",
            "count": "calendar_scheduling_example_119"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    # Debra's busy slots: 9:00-10:00, 12:00-12:30, 13:00-14:30\n    debra_busy = [\n        (9 * 60, 10 * 60),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 14 * 60 + 30)\n    ]\n    \n    # Christopher's busy slots: 9:30-10:00, 12:00-13:00, 13:30-14:00, 14:30-15:00, 16:30-17:00\n    # Also, Christopher prefers no meetings after 13:00, so we add a constraint\n    christopher_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (12 * 60, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    christopher_preference_end = 13 * 60  # Prefers no meetings after 13:00\n    \n    # Evelyn's busy slots: 9:30-10:30, 11:30-12:00, 12:30-14:30, 15:30-16:00\n    evelyn_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 14 * 60 + 30),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    \n    # Wayne's busy slots: 9:00-9:30, 10:00-10:30, 11:00-12:30, 13:00-13:30, 14:00-16:00\n    wayne_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 16 * 60)\n    ]\n    \n    # Combine all busy slots for each person\n    schedules = {\n        'Debra': debra_busy,\n        'Christopher': christopher_busy,\n        'Evelyn': evelyn_busy,\n        'Wayne': wayne_busy\n    }\n    \n    # Find all possible slots where everyone is free\n    for start in range(work_start, work_end - meeting_duration + 1):\n        end = start + meeting_duration\n        # Check if the slot is within Christopher's preference (before 13:00)\n        if end <= christopher_preference_end:\n            all_free = True\n            for person, busy_slots in schedules.items():\n                for busy_start, busy_end in busy_slots:\n                    if not (end <= busy_start or start >= busy_end):\n                        all_free = False\n                        break\n                if not all_free:\n                    break\n            if all_free:\n                return f\"{start // 60:02d}:{start % 60:02d}:{end // 60:02d}:{end % 60:02d}\"\n    \n    # If no slot found before 13:00, check after (though Christopher prefers not)\n    for start in range(work_start, work_end - meeting_duration + 1):\n        end = start + meeting_duration\n        all_free = True\n        for person, busy_slots in schedules.items():\n            for busy_start, busy_end in busy_slots:\n                if not (end <= busy_start or start >= busy_end):\n                    all_free = False\n                    break\n            if not all_free:\n                break\n        if all_free:\n            return f\"{start // 60:02d}:{end // 60:02d}:{start % 60:02d}:{end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_120"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert all time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = map(time_to_minutes, work_hours.split(':'))\n    duration_minutes = duration * 60\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules.values():\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find available slots by merging busy intervals\n    available_slots = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define the participants' schedules\nparticipants_schedules = {\n    \"Jerry\": [\"11:30:12:00\", \"16:00:16:30\"],\n    \"Benjamin\": [],\n    \"Andrew\": [\"09:30:10:30\", \"11:30:12:30\", \"13:00:13:30\", \"14:00:15:30\"],\n    \"Anna\": [\"09:00:11:30\", \"12:00:12:30\", \"13:00:17:00\"]\n}\n\n# Define meeting duration (in hours) and work hours\nmeeting_duration = 0.5  # half an hour\nwork_hours = \"9:00:17:00\"\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, meeting_duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_121"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:00:15:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, meeting_duration):\n    # Convert time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work hours start at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = 9 + minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    start_work = time_to_minutes(work_hours[0])\n    end_work = time_to_minutes(work_hours[1])\n    duration = meeting_duration * 60\n\n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules.values():\n        for interval in schedule:\n            start = time_to_minutes(interval[0])\n            end = time_to_minutes(interval[1])\n            busy_intervals.append((start, end))\n\n    # Sort all busy intervals\n    busy_intervals.sort()\n\n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find available slots\n    available_slots = []\n    prev_end = start_work\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < end_work:\n        available_slots.append((prev_end, end_work))\n\n    # Check each available slot for sufficient duration\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            meeting_start = minutes_to_time(slot_start)\n            meeting_end = minutes_to_time(slot_start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n\n    return \"No available slot found\"\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nmeeting_duration = 0.5  # half an hour\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"Diana\": [(\"12:00\", \"13:30\"), (\"14:00\", \"15:00\"), (\"16:30\", \"17:00\")],\n    \"Rebecca\": [(\"9:00\", \"9:30\"), (\"10:00\", \"11:30\"), (\"13:00\", \"13:30\"), (\"14:30\", \"15:00\")],\n    \"Madison\": [(\"9:30\", \"10:30\"), (\"11:00\", \"12:30\"), (\"13:30\", \"15:00\"), (\"15:30\", \"16:30\")],\n    \"Carol\": [(\"9:00\", \"9:30\"), (\"10:00\", \"10:30\"), (\"11:00\", \"11:30\"), (\"12:00\", \"14:00\"), (\"14:30\", \"15:00\"), (\"16:00\", \"17:00\")]\n}\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_122"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define each participant's busy times in minutes since midnight\n    # Format: list of (start, end) tuples\n    thomas_busy = []\n    catherine_busy = [(13 * 60, 13 * 60 + 30), (14 * 60, 15 * 60 + 30)]\n    ruth_busy = [(9 * 60 + 30, 14 * 60 + 30), (15 * 60 + 30, 16 * 60 + 30)]\n    andrew_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60 + 30, 16 * 60)\n    ]\n\n    # Combine all busy times and sort them\n    all_busy = thomas_busy + catherine_busy + ruth_busy + andrew_busy\n    all_busy.sort()\n\n    # Find the earliest available slot\n    previous_end = work_start\n    for start, end in all_busy:\n        if start > previous_end and start - previous_end >= meeting_duration:\n            # Found a slot\n            proposed_start = previous_end\n            proposed_end = proposed_start + meeting_duration\n            return f\"{proposed_start // 60:02d}:{proposed_start % 60:02d}:{proposed_end // 60:02d}:{proposed_end % 60:02d}\"\n        previous_end = max(previous_end, end)\n\n    # Check after the last busy slot\n    if work_end - previous_end >= meeting_duration:\n        proposed_start = previous_end\n        proposed_end = proposed_start + meeting_duration\n        return f\"{proposed_start // 60:02d}:{proposed_start % 60:02d}:{proposed_end // 60:02d}:{proposed_end % 60:02d}\"\n\n    # If no slot found (though the problem states one exists)\n    return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_123"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    michael_busy = [(16 * 60, 17 * 60)]\n    hannah_busy = [(9 * 60 + 30, 10 * 60 + 30),\n                   (12 * 60, 12 * 60 + 30),\n                   (13 * 60 + 30, 14 * 60),\n                   (15 * 60 + 30, 16 * 60),\n                   (16 * 60 + 30, 17 * 60)]\n    brenda_busy = [(9 * 60 + 30, 11 * 60 + 30),\n                   (12 * 60, 13 * 60),\n                   (13 * 60 + 30, 14 * 60 + 30),\n                   (15 * 60, 17 * 60)]\n    anthony_busy = [(9 * 60, 11 * 60),\n                    (12 * 60, 12 * 60 + 30),\n                    (13 * 60 + 30, 14 * 60),\n                    (15 * 60 + 30, 16 * 60 + 30)]\n    \n    # Hannah's preference: not before 14:30\n    hannah_preference_start = 14 * 60 + 30\n\n    # Combine all busy slots\n    all_busy = []\n    for person_busy in [michael_busy, hannah_busy, brenda_busy, anthony_busy]:\n        all_busy.extend(person_busy)\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Filter free slots that are >= meeting_duration and after Hannah's preference\n    possible_slots = []\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration and slot_start >= hannah_preference_start:\n            possible_slots.append((slot_start, slot_end))\n    \n    # Select the earliest possible slot\n    if possible_slots:\n        meeting_start = possible_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_124"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define participants' busy times in minutes since midnight\n    jesse_busy = [(12 * 60 + 30, 13 * 60), (15 * 60, 15 * 60 + 30)]\n    alan_busy = [(9 * 60, 9 * 60 + 30), (16 * 60, 16 * 60 + 30)]\n    elijah_busy = [(9 * 60, 12 * 60), (12 * 60 + 30, 13 * 60), (14 * 60, 15 * 60), (15 * 60 + 30, 17 * 60)]\n    amy_busy = [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 12 * 60), (13 * 60, 13 * 60 + 30), (14 * 60, 15 * 60), (16 * 60, 16 * 60 + 30)]\n    \n    # Jesse's constraint: not before 12:30\n    jesse_constraint = 12 * 60 + 30\n    \n    # Meeting duration\n    duration = 30\n    \n    # Combine all busy times\n    all_busy = jesse_busy + alan_busy + elijah_busy + amy_busy\n    \n    # Generate free slots by finding gaps between busy times\n    all_busy.sort()\n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Filter free slots that meet duration and Jesse's constraint\n    valid_slots = []\n    for start, end in free_slots:\n        if end - start >= duration and start >= jesse_constraint:\n            valid_slots.append((start, end))\n    \n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + duration\n        # Format the output as HH:MM:HH:MM\n        return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    else:\n        return \"No valid time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_125"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Define participants' busy times in minutes since midnight\n    lawrence_busy = [(14 * 60, 16 * 60)]\n    sharon_busy = [(10 * 60 + 30, 11 * 60), (12 * 60 + 30, 13 * 60 + 30), (15 * 60, 15 * 60 + 30)]\n    aaron_busy = [(9 * 60 + 30, 11 * 60 + 30), (12 * 60, 14 * 60), (14 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)]\n    amy_busy = [(9 * 60 + 30, 11 * 60), (12 * 60, 13 * 60), (14 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)]\n\n    # Lawrence's preference: not before 13:00\n    preference_start = 13 * 60\n\n    # Combine all busy times\n    all_busy = []\n    for busy in [lawrence_busy, sharon_busy, aaron_busy, amy_busy]:\n        all_busy.extend(busy)\n\n    # Sort busy times by start time\n    all_busy.sort()\n\n    # Find free slots\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check for a 30-minute slot that fits Lawrence's preference\n    meeting_duration = 30\n    for start, end in free_slots:\n        if start >= preference_start:\n            available_start = start\n            available_end = min(end, available_start + meeting_duration)\n            if available_end - available_start >= meeting_duration:\n                # Convert back to HH:MM format\n                start_hh = available_start // 60\n                start_mm = available_start % 60\n                end_hh = (available_start + meeting_duration) // 60\n                end_mm = (available_start + meeting_duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    # If no slot found after preference, check before (though Lawrence prefers not)\n    for start, end in free_slots:\n        available_start = start\n        available_end = min(end, available_start + meeting_duration)\n        if available_end - available_start >= meeting_duration:\n            start_hh = available_start // 60\n            start_mm = available_start % 60\n            end_hh = (available_start + meeting_duration) // 60\n            end_mm = (available_start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_126"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert each participant's busy slots to minutes\n    # Kathleen: 13:00-14:00, 15:00-15:30, 16:00-16:30\n    kathleen_busy = [\n        (13 * 60, 14 * 60),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    # Kathleen doesn't want to meet before 13:30\n    kathleen_min_start = 13 * 60 + 30\n\n    # Frank: no meetings\n    frank_busy = []\n\n    # Christopher: 9:00-9:30, 10:00-11:30, 13:30-14:00, 15:30-17:00\n    christopher_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 11 * 60 + 30),\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n\n    # Kathryn: 9:00-10:00, 10:30-11:30, 12:30-13:00, 13:30-14:00, 14:30-15:00, 15:30-17:00\n    kathryn_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n\n    # Combine all busy slots for all participants\n    all_busy = kathleen_busy + frank_busy + christopher_busy + kathryn_busy\n\n    # Generate free slots by inverting busy slots within work hours\n    free_slots = []\n    previous_end = work_start\n    for start, end in sorted(all_busy):\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that is at least 30 minutes and meets Kathleen's constraint\n    meeting_duration = 30\n    for start, end in free_slots:\n        slot_start = max(start, kathleen_min_start)\n        if slot_start + meeting_duration <= end:\n            # Convert back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = (slot_start + meeting_duration) // 60\n            end_mm = (slot_start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_127"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Define participants' schedules and constraints\n    # Each entry is a list of (start, end) in minutes\n    catherine = [\n        (9 * 60, 10 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    harold = [\n        (12 * 60 + 30, 13 * 60),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    ann = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60, 15 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    randy = [\n        (9 * 60, 12 * 60),\n        (13 * 60, 14 * 60),\n        (14 * 60 + 30, 15 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n\n    # Harold cannot meet before 14:00\n    harold_constraint = 14 * 60\n\n    # Meeting duration is 30 minutes\n    duration = 30\n\n    # Combine all busy times and sort them\n    all_busy = []\n    for person in [catherine, harold, ann, randy]:\n        all_busy.extend(person)\n    all_busy.sort()\n\n    # Find available slots by checking gaps between busy times\n    available_slots = []\n    prev_end = work_start\n\n    for start, end in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n\n    if work_end > prev_end:\n        available_slots.append((prev_end, work_end))\n\n    # Filter slots that are >= duration and after Harold's constraint\n    possible_slots = []\n    for start, end in available_slots:\n        if end - start >= duration and start >= harold_constraint:\n            possible_slots.append((start, end))\n\n    # The first suitable slot is the earliest possible\n    if possible_slots:\n        meeting_start = possible_slots[0][0]\n        meeting_end = meeting_start + duration\n        # Format the output as HH:MM:HH:MM\n        return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_128"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    start_hour, end_hour = work_hours\n    # Convert work hours to minutes for easier calculation\n    work_start = start_hour * 60\n    work_end = end_hour * 60\n    \n    # Initialize a list to keep track of busy times for all participants\n    busy_times = []\n    \n    for schedule in participants_schedules:\n        personal_busy = []\n        for meeting in schedule:\n            start, end = meeting\n            start_min = start[0] * 60 + start[1]\n            end_min = end[0] * 60 + end[1]\n            personal_busy.append((start_min, end_min))\n        busy_times.append(personal_busy)\n    \n    # Check all possible time slots within work hours\n    for time in range(work_start, work_end - duration + 1):\n        end_time = time + duration\n        # Check if the time slot is free for all participants\n        all_free = True\n        for personal_busy in busy_times:\n            free = True\n            for (busy_start, busy_end) in personal_busy:\n                if not (end_time <= busy_start or time >= busy_end):\n                    free = False\n                    break\n            if not free:\n                all_free = False\n                break\n        if all_free:\n            # Convert back to HH:MM format\n            start_hh = time // 60\n            start_mm = time % 60\n            end_hh = end_time // 60\n            end_mm = end_time % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No available time slot found\"\n\n# Define the participants' schedules\njacqueline = [\n    ((10, 0), (10, 30)),\n    ((11, 0), (11, 30)),\n    ((12, 30), (13, 0)),\n    ((14, 0), (15, 0)),\n    ((16, 0), (16, 30))\n]\nadam = []\ngerald = [\n    ((9, 0), (11, 0)),\n    ((11, 30), (12, 0)),\n    ((14, 0), (15, 0)),\n    ((15, 30), (17, 0))\n]\nwayne = [\n    ((9, 0), (10, 0)),\n    ((10, 30), (11, 30)),\n    ((13, 0), (15, 0)),\n    ((15, 30), (16, 0)),\n    ((16, 30), (17, 0))\n]\n\nparticipants_schedules = [jacqueline, adam, gerald, wayne]\nmeeting_duration = 30  # minutes\nwork_hours = (9, 17)   # 9:00 to 17:00\n\n# Find the earliest available time\nmeeting_time = find_meeting_time(participants_schedules, meeting_duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_129"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals\n    busy_intervals = []\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals_sorted = sorted(busy_intervals, key=lambda x: x[0])\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals_sorted:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\njohn_schedule = [\n    \"9:00 to 9:30\",\n    \"10:00 to 10:30\",\n    \"11:00 to 11:30\",\n    \"13:00 to 14:30\"\n]\n\nralph_schedule = [\n    \"13:30 to 14:00\",\n    \"14:30 to 15:00\",\n    \"15:30 to 16:30\"\n]\n\ndaniel_schedule = [\n    \"9:00 to 9:30\",\n    \"10:30 to 11:00\",\n    \"12:00 to 13:00\",\n    \"13:30 to 16:30\"\n]\n\nkeith_schedule = [\n    \"10:30 to 14:30\",\n    \"15:00 to 17:00\"\n]\n\nparticipants_schedules = [john_schedule, ralph_schedule, daniel_schedule, keith_schedule]\nmeeting_duration = 30  # minutes\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, meeting_duration, work_hours_start, work_hours_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_130"
        },
        {
            "final_program_time": "{15:30:16:30}",
            "expected_time": "{15:30:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert all time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work_hours start at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = 9 + minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    start_work = time_to_minutes(work_hours[0])\n    end_work = time_to_minutes(work_hours[1]) - duration  # Latest possible start time\n\n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy_intervals in participants_busy.values():\n        for interval in busy_intervals:\n            start, end = interval.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            all_busy.append((start_min, end_min))\n\n    # Sort all busy intervals by start time\n    all_busy.sort()\n\n    # Find the first available slot\n    current_time = start_work\n    for start, end in all_busy:\n        if start > current_time and start - current_time >= duration:\n            # Found a slot\n            meeting_end = current_time + duration\n            return f\"{minutes_to_time(current_time)}:{minutes_to_time(meeting_end)}\"\n        current_time = max(current_time, end)\n    \n    # Check after the last busy interval\n    if current_time <= end_work:\n        meeting_end = current_time + duration\n        return f\"{minutes_to_time(current_time)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' busy times\nparticipants_busy = {\n    \"Walter\": [\"9:30 to 10:00\", \"13:00 to 13:30\"],\n    \"Jacob\": [\"11:00 to 11:30\", \"13:00 to 13:30\"],\n    \"Jennifer\": [\"9:30 to 10:30\", \"11:30 to 12:00\", \"12:30 to 15:00\"],\n    \"Joan\": [\"9:30 to 10:00\", \"10:30 to 11:30\", \"12:00 to 12:30\", \"13:00 to 14:00\", \"14:30 to 15:30\"],\n}\n\n# Work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 60  # minutes\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_131"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:30:10:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, duration_minutes, work_start, work_end):\n    # Convert all times to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration = duration_minutes\n    \n    # Collect all busy time slots\n    all_busy_slots = []\n    for busy_slots in participants_busy_times.values():\n        for slot in busy_slots:\n            start, end = map(time_to_minutes, slot.split(':'))\n            all_busy_slots.append((start, end))\n    \n    # Sort the busy slots by start time\n    all_busy_slots_sorted = sorted(all_busy_slots, key=lambda x: x[0])\n    \n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    prev_end = work_start_min\n    \n    for start, end in all_busy_slots_sorted:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        free_slots.append((prev_end, work_end_min))\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' busy times\nparticipants_busy_times = {\n    \"Diana\": [\"10:30:11:00\", \"12:30:13:00\", \"14:30:15:00\", \"15:30:16:00\"],\n    \"Harold\": [\"10:00:11:00\", \"11:30:16:30\"],\n    \"Philip\": [\"09:00:09:30\", \"10:30:12:00\", \"12:30:13:30\", \"14:00:17:00\"],\n    \"Joe\": []  # Joe has no busy times\n}\n\n# Parameters\nduration_minutes = 30\nwork_start = \"09:00\"\nwork_end = \"17:00\"\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, duration_minutes, work_start, work_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_132"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours_start, work_hours_end, duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n\n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy_intervals in participants_busy.values():\n        for interval in busy_intervals:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n\n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n\n    # Check each free interval for availability of duration\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' busy times\nparticipants_busy = {\n    \"Janice\": [\"11:30 to 12:30\"],\n    \"Isabella\": [],\n    \"Linda\": [\"9:30 to 11:30\", \"12:00 to 13:00\", \"13:30 to 16:30\"],\n    \"Billy\": [\"9:00 to 9:30\", \"10:30 to 11:30\", \"13:30 to 14:00\", \"14:30 to 16:00\", \"16:30 to 17:00\"]\n}\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30  # half an hour\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_133"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:13:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = work_hours\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start_min, work_end_min)]\n    \n    # Subtract busy slots from free slots for each participant\n    for person, busy_slots in participants_busy.items():\n        new_free_slots = []\n        for free_start, free_end in free_slots:\n            current_start = free_start\n            for busy_start, busy_end in busy_slots:\n                busy_start_min = time_to_minutes(busy_start)\n                busy_end_min = time_to_minutes(busy_end)\n                if busy_start_min >= free_end:\n                    break\n                if busy_end_min <= free_start:\n                    continue\n                if current_start < busy_start_min:\n                    new_free_slots.append((current_start, busy_start_min))\n                current_start = max(current_start, busy_end_min)\n            if current_start < free_end:\n                new_free_slots.append((current_start, free_end))\n        free_slots = new_free_slots\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_end = slot_start + duration_min\n            return f\"{minutes_to_time(slot_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 0.5  # half an hour\n\n# Define busy slots for each participant\nparticipants_busy = {\n    \"Alice\": [\n        (\"10:00\", \"10:30\"),\n        (\"14:30\", \"15:00\"),\n        (\"15:30\", \"16:30\")\n    ],\n    \"Charlotte\": [],\n    \"Stephanie\": [\n        (\"9:00\", \"9:30\"),\n        (\"10:30\", \"11:00\"),\n        (\"11:30\", \"13:00\"),\n        (\"13:30\", \"14:30\"),\n        (\"15:00\", \"15:30\")\n    ],\n    \"Ethan\": [\n        (\"9:00\", \"12:00\"),\n        (\"12:30\", \"13:00\"),\n        (\"13:30\", \"14:30\"),\n        (\"15:00\", \"15:30\"),\n        (\"16:00\", \"17:00\")\n    ]\n}\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_134"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    # Eric is free all day\n    eric_busy = []\n    \n    # Ashley's busy slots: 10:00-10:30, 11:00-12:00, 12:30-13:00, 15:00-16:00\n    ashley_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (15 * 60, 16 * 60)\n    ]\n    \n    # Ronald's busy slots: 9:00-9:30, 10:00-11:30, 12:30-14:00, 14:30-17:00\n    ronald_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 17 * 60)\n    ]\n    \n    # Larry's busy slots: 9:00-12:00, 13:00-17:00\n    larry_busy = [\n        (9 * 60, 12 * 60),\n        (13 * 60, 17 * 60)\n    ]\n    \n    # Combine all busy slots\n    all_busy = []\n    for person_busy in [eric_busy, ashley_busy, ronald_busy, larry_busy]:\n        all_busy.extend(person_busy)\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can fit the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_135"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' schedules and constraints\n    diana_busy = [(10*60+30, 11*60), (11*60+30, 12*60), (13*60+30, 14*60), (14*60+30, 15*60), (16*60, 17*60)]\n    diana_constraint = 9 * 60 + 30  # Cannot meet before 9:30\n\n    gerald_busy = [(9*60+30, 10*60), (12*60+30, 13*60), (15*60, 15*60+30), (16*60, 16*60+30)]\n\n    timothy_busy = [(10*60, 12*60), (12*60+30, 14*60), (14*60+30, 15*60), (16*60, 17*60)]\n\n    julie_busy = [(9*60+30, 10*60), (10*60+30, 11*60), (11*60+30, 15*60+30), (16*60, 17*60)]\n\n    # Combine all busy times\n    all_busy = []\n    for busy in [diana_busy, gerald_busy, timothy_busy, julie_busy]:\n        all_busy.extend(busy)\n\n    # Sort all busy times by start time\n    all_busy.sort()\n\n    # Find available slots\n    available_slots = []\n    prev_end = max(work_start, diana_constraint)\n\n    for start, end in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Find the first available slot that is at least 30 minutes\n    meeting_duration = 30\n    for slot in available_slots:\n        start, end = slot\n        if end - start >= meeting_duration:\n            # Convert start time to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_time = start + meeting_duration\n            end_hh = end_time // 60\n            end_mm = end_time % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_136"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy times in minutes (start, end)\n    rebecca_busy = [(10*60 + 30, 11*60), (12*60 + 30, 13*60)]\n    donald_busy = [(12*60, 12*60 + 30), (15*60, 15*60 + 30)]\n    diana_busy = [(9*60 + 30, 11*60), (12*60 + 30, 13*60), (13*60 + 30, 14*60), (14*60 + 30, 17*60)]\n    jesse_busy = [(9*60 + 30, 12*60 + 30), (13*60, 13*60 + 30), (14*60 + 30, 15*60), (16*60, 17*60)]\n    \n    # Diana cannot meet before 14:00\n    diana_min_time = 14 * 60\n    \n    # Combine all busy times\n    all_busy = rebecca_busy + donald_busy + diana_busy + jesse_busy\n    \n    # Sort busy times by start time\n    all_busy.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = work_start\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > prev_end:\n            free_slots.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Filter free slots that are at least 30 minutes and after Diana's min time\n    possible_slots = []\n    for start, end in free_slots:\n        if end - start >= 30 and start >= diana_min_time:\n            possible_slots.append((start, end))\n    \n    # Select the earliest possible slot\n    if possible_slots:\n        meeting_start = possible_slots[0][0]\n        meeting_end = meeting_start + 30\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_137"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' busy times in minutes since midnight\n    # Juan is free all day\n    emma_busy = [(9 * 60 + 30, 10 * 60 + 30), (12 * 60 + 30, 13 * 60 + 30)]\n    gloria_busy = [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), \n                    (11 * 60, 11 * 60 + 30), (12 * 60 + 30, 14 * 60),\n                    (16 * 60, 17 * 60)]\n    joan_busy = [(9 * 60, 9 * 60 + 30), (10 * 60, 12 * 60), \n                 (13 * 60, 14 * 60), (14 * 60 + 30, 17 * 60)]\n    \n    # Emma cannot meet before 12:30\n    emma_constraint = 12 * 60 + 30\n\n    # Combine all busy times and sort them\n    all_busy = emma_busy + gloria_busy + joan_busy\n    all_busy.sort()\n\n    # Initialize candidate start time\n    candidate_start = max(work_start, emma_constraint)\n\n    # Check for available slots\n    for busy_start, busy_end in all_busy:\n        if busy_start > candidate_start:\n            # Check if there's enough time before the next busy period\n            if busy_start - candidate_start >= 30:\n                # Format the time as HH:MM:HH:MM\n                start_hh = candidate_start // 60\n                start_mm = candidate_start % 60\n                end_hh = (candidate_start + 30) // 60\n                end_mm = (candidate_start + 30) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n        # Update candidate_start to the end of the current busy period\n        candidate_start = max(candidate_start, busy_end)\n    \n    # Check after the last busy period\n    if work_end - candidate_start >= 30:\n        start_hh = candidate_start // 60\n        start_mm = candidate_start % 60\n        end_hh = (candidate_start + 30) // 60\n        end_mm = (candidate_start + 30) % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_138"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours_start='9:00', work_hours_end='17:00'):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            all_busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_intervals = []\n    for start, end in all_busy_intervals:\n        if not merged_intervals:\n            merged_intervals.append([start, end])\n        else:\n            last_start, last_end = merged_intervals[-1]\n            if start <= last_end:\n                merged_intervals[-1][1] = max(end, last_end)\n            else:\n                merged_intervals.append([start, end])\n    \n    # Find the earliest available slot\n    prev_end = work_start\n    for start, end in merged_intervals:\n        if start - prev_end >= duration_minutes:\n            # Found a slot\n            meeting_start = prev_end\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n        prev_end = max(prev_end, end)\n    \n    # Check after the last busy interval\n    if work_end - prev_end >= duration_minutes:\n        meeting_start = prev_end\n        meeting_end = meeting_start + duration_minutes\n        def minutes_to_time(minutes):\n            hh = minutes // 60\n            mm = minutes % 60\n            return f\"{hh:02d}:{mm:02d}\"\n        return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"9:00 to 9:30\", \"12:00 to 12:30\", \"13:00 to 14:00\"],  # Jose\n    [\"10:30 to 11:00\", \"12:30 to 13:30\", \"14:30 to 15:00\"],  # Sean\n    [\"9:00 to 9:30\", \"10:00 to 11:30\", \"13:00 to 13:30\", \"14:00 to 14:30\", \"15:00 to 17:00\"],  # Denise\n    [\"9:00 to 10:00\", \"10:30 to 11:30\", \"12:00 to 17:00\"]  # Amanda\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_139"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    start_hour, end_hour = work_hours\n    # Convert work hours to minutes\n    start_time = start_hour * 60\n    end_time = end_hour * 60\n    \n    # Initialize a list to keep track of busy times for all participants\n    busy_times = []\n    \n    for schedule in participants_schedules:\n        for block in schedule:\n            start_block = block[0] * 60 + block[1]\n            end_block = block[2] * 60 + block[3]\n            busy_times.append((start_block, end_block))\n    \n    # Sort all busy times by start time\n    busy_times.sort()\n    \n    # Find all free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = start_time\n    \n    for start, end in busy_times:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy time\n    if previous_end < end_time:\n        free_slots.append((previous_end, end_time))\n    \n    # Now, merge overlapping or adjacent busy times to find common free slots\n    # But since we have all busy times, we can directly look for gaps >= duration\n    # in the merged busy times\n    merged_busy = []\n    for start, end in busy_times:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Now find free slots between merged busy times\n    common_free_slots = []\n    previous_end = start_time\n    \n    for start, end in merged_busy:\n        if start > previous_end:\n            common_free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy time\n    if previous_end < end_time:\n        common_free_slots.append((previous_end, end_time))\n    \n    # Now find the first slot that can fit the duration\n    for slot in common_free_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration * 60:\n            # Found a suitable slot\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration * 60\n            # Convert back to hours and minutes\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules in terms of (HH, MM, HH, MM) blocks\nwillie_schedule = [\n    (12, 0, 12, 30),\n    (15, 30, 16, 0)\n]\n\ncharlotte_schedule = [\n    (9, 30, 10, 0),\n    (14, 0, 14, 30),\n    (15, 0, 16, 0)\n]\n\nnoah_schedule = [\n    (10, 0, 10, 30),\n    (11, 0, 12, 0),\n    (13, 0, 15, 0),\n    (15, 30, 17, 0)\n]\n\nevelyn_schedule = [\n    (9, 0, 10, 0),\n    (10, 30, 11, 30),\n    (13, 30, 16, 0),\n    (16, 30, 17, 0)\n]\n\n# Combine all schedules\nall_schedules = [\n    willie_schedule,\n    charlotte_schedule,\n    noah_schedule,\n    evelyn_schedule\n]\n\n# Meeting duration in hours\nduration = 0.5  # half an hour\n\n# Work hours from 9:00 to 17:00\nwork_hours = (9, 17)\n\n# Find the meeting time\nmeeting_time = find_meeting_time(all_schedules, duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_140"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:00:15:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m - 540  # 540 minutes = 9:00\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        h = (minutes + 540) // 60\n        m = (minutes + 540) % 60\n        return f\"{h:02d}:{m:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    start_min = time_to_minutes(start_work)\n    end_min = time_to_minutes(end_work)\n    \n    # Initialize a list to track busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = busy.split(' to ')\n            start_busy = time_to_minutes(start)\n            end_busy = time_to_minutes(end)\n            busy_intervals.append((start_busy, end_busy))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = start_min\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < end_min:\n        free_intervals.append((prev_end, end_min))\n    \n    # Check each free interval for a slot that fits the meeting duration\n    duration_min = duration * 60  # Convert hours to minutes\n    for start, end in free_intervals:\n        if end - start >= duration_min:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration_min)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nlinda_schedule = [\n    \"10:00 to 11:30\",\n    \"12:00 to 12:30\",\n    \"13:00 to 14:00\"\n]\n\nsamantha_schedule = [\n    \"10:30 to 11:00\",\n    \"16:00 to 16:30\"\n]\n\nralph_schedule = [\n    \"9:00 to 10:00\",\n    \"10:30 to 12:00\",\n    \"12:30 to 13:30\",\n    \"14:00 to 15:00\",\n    \"16:30 to 17:00\"\n]\n\nkatherine_schedule = [\n    \"10:00 to 12:30\",\n    \"13:30 to 14:00\",\n    \"14:30 to 15:00\",\n    \"15:30 to 16:00\"\n]\n\nparticipants_schedules = [\n    linda_schedule,\n    samantha_schedule,\n    ralph_schedule,\n    katherine_schedule\n]\n\n# Find a 30-minute meeting time between 9:00 to 17:00\nmeeting_time = find_meeting_time(participants_schedules, 0.5, \"9:00 to 17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_141"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define each person's blocked times in minutes (start, end)\n    richard_blocked = [(9 * 60, 10 * 60)]\n    sarah_blocked = [(11 * 60, 11 * 60 + 30), (14 * 60, 14 * 60 + 30)]\n    gloria_blocked = [(9 * 60, 12 * 60 + 30), (13 * 60 + 30, 14 * 60), \n                      (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60)]\n    kathleen_blocked = [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 11 * 60),\n                        (12 * 60, 12 * 60 + 30), (13 * 60 + 30, 15 * 60 + 30),\n                        (16 * 60, 16 * 60 + 30)]\n\n    # Gloria's preference: not before 14:30\n    gloria_preference_start = 14 * 60 + 30\n\n    # Combine all blocked times\n    all_blocked = []\n    all_blocked.extend([(start, end, \"Richard\") for start, end in richard_blocked])\n    all_blocked.extend([(start, end, \"Sarah\") for start, end in sarah_blocked])\n    all_blocked.extend([(start, end, \"Gloria\") for start, end in gloria_blocked])\n    all_blocked.extend([(start, end, \"Kathleen\") for start, end in kathleen_blocked])\n\n    # Sort blocked times by start time\n    all_blocked.sort()\n\n    # Find available slots\n    available_slots = []\n    current_time = max(work_start, gloria_preference_start)\n\n    while current_time + meeting_duration <= work_end:\n        slot_available = True\n        slot_end = current_time + meeting_duration\n\n        for blocked_start, blocked_end, person in all_blocked:\n            if not (slot_end <= blocked_start or current_time >= blocked_end):\n                slot_available = False\n                current_time = blocked_end\n                break\n\n        if slot_available:\n            available_slots.append((current_time, slot_end))\n            current_time = slot_end\n        else:\n            # Move to the next possible start time\n            pass\n\n    if not available_slots:\n        return \"No available time slot found.\"\n\n    # Select the first available slot\n    meeting_start, meeting_end = available_slots[0]\n\n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n\n    start_time = minutes_to_time(meeting_start)\n    end_time = minutes_to_time(meeting_end)\n\n    return f\"{start_time}:{end_time}\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_142"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define busy intervals in minutes for each participant\n    marilyn_busy = [(9 * 60, 10 * 60)]\n    timothy_busy = [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30)]\n    peter_busy = [(9 * 60 + 30, 12 * 60 + 30), (13 * 60, 14 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)]\n    patrick_busy = [(9 * 60, 10 * 60), (11 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60, 15 * 60)]\n    \n    # Peter's preference: avoid meetings before 14:30\n    peter_preference_start = 14 * 60 + 30\n    \n    # Combine all busy intervals\n    all_busy = marilyn_busy + timothy_busy + peter_busy + patrick_busy\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by checking gaps between busy intervals\n    free_intervals = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the interval after the last busy interval\n    if previous_end < work_end:\n        free_intervals.append((previous_end, work_end))\n    \n    # Filter free intervals that are at least 30 minutes and after Peter's preference\n    meeting_duration = 30\n    suitable_intervals = []\n    \n    for start, end in free_intervals:\n        if end - start >= meeting_duration and start >= peter_preference_start:\n            suitable_intervals.append((start, end))\n    \n    # Select the earliest suitable interval\n    if suitable_intervals:\n        meeting_start = suitable_intervals[0][0]\n        meeting_end = meeting_start + meeting_duration\n    else:\n        # If no interval after preference, check all free intervals (though problem states solution exists)\n        for start, end in free_intervals:\n            if end - start >= meeting_duration:\n                meeting_start = start\n                meeting_end = meeting_start + meeting_duration\n                break\n    \n    # Format the output\n    start_hh = meeting_start // 60\n    start_mm = meeting_start % 60\n    end_hh = meeting_end // 60\n    end_mm = meeting_end % 60\n    \n    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_143"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:00:12:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 9:00 (0 minutes)\n    \n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Initialize the free slots for all participants\n    free_slots = []\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = busy.split(' to ')\n            busy_start = time_to_minutes(start)\n            busy_end = time_to_minutes(end)\n            busy_slots.append((busy_start, busy_end))\n        \n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Calculate free slots\n        current_time = work_start\n        free = []\n        for start, end in busy_slots:\n            if start > current_time:\n                free.append((current_time, start))\n            current_time = max(current_time, end)\n        if current_time < work_end:\n            free.append((current_time, work_end))\n        \n        free_slots.append(free)\n    \n    # Find intersection of all free slots\n    common_free = free_slots[0]\n    for slots in free_slots[1:]:\n        new_common = []\n        i = j = 0\n        while i < len(common_free) and j < len(slots):\n            start1, end1 = common_free[i]\n            start2, end2 = slots[j]\n            \n            # Find overlap\n            start = max(start1, start2)\n            end = min(end1, end2)\n            if start < end:\n                new_common.append((start, end))\n            \n            # Move the pointer which ends first\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free = new_common\n    \n    # Find the first slot that can fit the duration\n    duration_min = duration * 60\n    for start, end in common_free:\n        if end - start >= duration_min:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration_min)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Diane is free all day\n    [\"10:30 to 11:00\", \"16:00 to 16:30\"],  # Olivia\n    [\"9:00 to 9:30\", \"10:30 to 12:00\", \"12:30 to 15:00\", \"15:30 to 17:00\"],  # Vincent\n    [\"9:00 to 10:30\", \"11:00 to 12:00\", \"12:30 to 17:00\"],  # Steven\n]\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nduration = 0.5  # half hour\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_144"
        }
    ]
}