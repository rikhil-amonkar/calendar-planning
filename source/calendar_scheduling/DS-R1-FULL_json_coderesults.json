{
    "0shot": [
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert all time strings to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = map(time_to_minutes, work_hours.split(' to '))\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules.values():\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability of all participants\n    for interval in free_intervals:\n        start, end = interval\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = {\n    \"Michelle\": [\"11:00 to 12:00\"],\n    \"Steven\": [\"9:00 to 9:30\", \"11:30 to 12:00\", \"13:30 to 14:00\", \"15:30 to 16:00\"],\n    \"Jerry\": [\"9:00 to 9:30\", \"10:00 to 11:00\", \"11:30 to 12:30\", \"13:00 to 14:30\", \"15:30 to 16:00\", \"16:30 to 17:00\"]\n}\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nmeeting_duration = 60  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, meeting_duration))\n```",
            "count": "calendar_scheduling_example_0"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each participant's busy slots to minutes\n    raymond_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    billy_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (12 * 60, 13 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    donald_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 11 * 60),\n        (12 * 60, 13 * 60),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n\n    # Billy's preference: avoid after 15:00\n    billy_preference_end = 15 * 60\n\n    # Generate all possible slots\n    possible_slots = []\n    current_time = work_start\n\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        # Check if the slot is free for all and respects Billy's preference\n        raymond_free = all(not (start <= current_time < end or start < slot_end <= end) for start, end in raymond_busy)\n        billy_free = all(not (start <= current_time < end or start < slot_end <= end) for start, end in billy_busy)\n        donald_free = all(not (start <= current_time < end or start < slot_end <= end) for start, end in donald_busy)\n        billy_preference_ok = slot_end <= billy_preference_end\n\n        if raymond_free and billy_free and donald_free and billy_preference_ok:\n            possible_slots.append((current_time, slot_end))\n        \n        current_time += 30  # Check in 30-minute increments\n\n    # Select the first available slot\n    if possible_slots:\n        start, end = possible_slots[0]\n        # Convert back to HH:MM format\n        start_hh = start // 60\n        start_mm = start % 60\n        end_hh = end // 60\n        end_mm = end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_1"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define each person's busy slots in minutes since midnight\n    roy_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60)\n    ]\n    \n    kathryn_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    amy_busy = [\n        (9 * 60, 14 * 60 + 30),\n        (15 * 60, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Amy's preference: not after 15:30\n    amy_preference_end = 15 * 60 + 30\n    \n    # Generate all possible slots within work hours\n    possible_slots = []\n    current_time = work_start\n    \n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 15  # check every 15 minutes for efficiency\n    \n    # Check each slot against everyone's schedule and Amy's preference\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        \n        # Check Amy's preference\n        if slot_start >= amy_preference_end:\n            continue\n        \n        # Check Roy's availability\n        roy_available = True\n        for busy_start, busy_end in roy_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                roy_available = False\n                break\n        if not roy_available:\n            continue\n        \n        # Check Kathryn's availability\n        kathryn_available = True\n        for busy_start, busy_end in kathryn_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                kathryn_available = False\n                break\n        if not kathryn_available:\n            continue\n        \n        # Check Amy's availability\n        amy_available = True\n        for busy_start, busy_end in amy_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                amy_available = False\n                break\n        if not amy_available:\n            continue\n        \n        # If all checks passed, return this slot\n        return f\"{slot_start // 60:02d}:{slot_start % 60:02d}:{slot_end // 60:02d}:{slot_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_2"
        },
        {
            "final_program_time": "{9:30:10:30}",
            "expected_time": "{9:30:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Convert each person's busy slots to minutes\n    arthur_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 12 * 60),\n        (16 * 60, 17 * 60)\n    ]\n    michael_busy = [\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30)\n    ]\n    samantha_busy = [\n        (10 * 60 + 30, 11 * 60),\n        (12 * 60, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n\n    # Combine all busy slots and sort them\n    all_busy = arthur_busy + michael_busy + samantha_busy\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    prev_end = work_start\n\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        if end > prev_end:\n            prev_end = end\n\n    if work_end > prev_end:\n        free_slots.append((prev_end, work_end))\n\n    # Check each free slot for availability for all participants\n    for slot_start, slot_end in free_slots:\n        slot_duration = slot_end - slot_start\n        if slot_duration >= meeting_duration:\n            # Check if the slot is free for all\n            arthur_free = all(not (s < slot_start + meeting_duration and e > slot_start) for s, e in arthur_busy)\n            michael_free = all(not (s < slot_start + meeting_duration and e > slot_start) for s, e in michael_busy)\n            samantha_free = all(not (s < slot_start + meeting_duration and e > slot_start) for s, e in samantha_busy)\n\n            if arthur_free and michael_free and samantha_free:\n                # Convert minutes back to HH:MM format\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_hh = (slot_start + meeting_duration) // 60\n                end_mm = (slot_start + meeting_duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_3"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Parse work hours\n    start_work, end_work = work_hours\n    start_h, start_m = map(int, start_work.split(':'))\n    end_h, end_m = map(int, end_work.split(':'))\n    \n    # Convert work hours to minutes\n    work_start = start_h * 60 + start_m\n    work_end = end_h * 60 + end_m\n    \n    # Initialize busy slots for all participants\n    busy_slots = []\n    for busy in participants_busy:\n        slots = []\n        for slot in busy:\n            start, end = slot\n            s_h, s_m = map(int, start.split(':'))\n            e_h, e_m = map(int, end.split(':'))\n            slots.append((s_h * 60 + s_m, e_h * 60 + e_m))\n        busy_slots.append(slots)\n    \n    # Find all possible slots\n    possible_slots = []\n    current_time = work_start\n    while current_time + duration <= work_end:\n        slot_end = current_time + duration\n        valid = True\n        for participant in busy_slots:\n            for busy_start, busy_end in participant:\n                if not (slot_end <= busy_start or current_time >= busy_end):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            possible_slots.append((current_time, slot_end))\n        current_time += 15  # Check in 15-minute increments\n    \n    if not possible_slots:\n        return None\n    \n    # Return the first possible slot\n    start, end = possible_slots[0]\n    start_h = start // 60\n    start_m = start % 60\n    end_h = end // 60\n    end_m = end % 60\n    return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n\n# Define participants' busy times\nparticipants_busy = [\n    [(\"14:00\", \"14:30\"), (\"15:30\", \"16:00\")],  # Donna\n    [(\"11:00\", \"11:30\"), (\"16:30\", \"17:00\")],  # John\n    [(\"09:00\", \"10:00\"), (\"10:30\", \"14:00\"), (\"14:30\", \"17:00\")]  # Billy\n]\n\n# Define work hours and meeting duration\nwork_hours = (\"09:00\", \"17:00\")\nduration = 30  # minutes\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_4"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert blocked times to minutes since midnight\n    kathryn_blocked = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60 + 30, 14 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    charlotte_blocked = [\n        (12 * 60, 12 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    lauren_blocked = [\n        (9 * 60, 10 * 60),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60 + 30, 14 * 60 + 30),\n        (15 * 60, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    charlotte_no_meet_after = 13 * 60 + 30  # 13:30\n\n    # Generate all possible slots\n    possible_slots = []\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 1  # Check every minute\n\n    # Check each slot against constraints\n    for slot_start, slot_end in possible_slots:\n        # Check Charlotte's \"no meet after 13:30\" constraint\n        if slot_start >= charlotte_no_meet_after:\n            continue\n\n        # Check Kathryn's availability\n        kathryn_available = True\n        for block_start, block_end in kathryn_blocked:\n            if not (slot_end <= block_start or slot_start >= block_end):\n                kathryn_available = False\n                break\n        if not kathryn_available:\n            continue\n\n        # Check Charlotte's availability\n        charlotte_available = True\n        for block_start, block_end in charlotte_blocked:\n            if not (slot_end <= block_start or slot_start >= block_end):\n                charlotte_available = False\n                break\n        if not charlotte_available:\n            continue\n\n        # Check Lauren's availability\n        lauren_available = True\n        for block_start, block_end in lauren_blocked:\n            if not (slot_end <= block_start or slot_start >= block_end):\n                lauren_available = False\n                break\n        if not lauren_available:\n            continue\n\n        # If all checks passed, return this slot\n        return f\"{slot_start // 60:02d}:{slot_start % 60:02d}:{slot_end // 60:02d}:{slot_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_5"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration):\n    # Convert all time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 9:00 (0 minutes)\n    \n    # Convert work hours to minutes\n    work_start = time_to_minutes(work_hours[0])\n    work_end = time_to_minutes(work_hours[1])\n    \n    # Collect all busy times for all participants\n    all_busy_times = []\n    for busy_times in participants_busy_times:\n        for start, end in busy_times:\n            all_busy_times.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy times by start time\n    all_busy_times.sort()\n    \n    # Find free slots by merging all busy times\n    merged_busy = []\n    for start, end in all_busy_times:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Check the time before the first busy slot\n    if merged_busy and merged_busy[0][0] > work_start:\n        if merged_busy[0][0] - work_start >= duration:\n            return work_hours[0], minutes_to_time(work_start + duration)\n    \n    # Check the time between busy slots\n    for i in range(1, len(merged_busy)):\n        prev_end = merged_busy[i-1][1]\n        curr_start = merged_busy[i][0]\n        if curr_start - prev_end >= duration:\n            start_time = minutes_to_time(prev_end + 540)  # Add 540 to convert back to HH:MM\n            end_time = minutes_to_time(prev_end + duration + 540)\n            return start_time, end_time\n    \n    # Check the time after the last busy slot\n    if merged_busy and merged_busy[-1][1] < work_end:\n        if work_end - merged_busy[-1][1] >= duration:\n            start_time = minutes_to_time(merged_busy[-1][1] + 540)\n            end_time = minutes_to_time(merged_busy[-1][1] + duration + 540)\n            return start_time, end_time\n    \n    # If no busy times, the entire work hours are free\n    if not merged_busy and (work_end - work_start) >= duration:\n        return work_hours[0], minutes_to_time(work_start + duration + 540)\n    \n    return None\n\ndef minutes_to_time(minutes):\n    hh = (minutes) // 60\n    mm = (minutes) % 60\n    return f\"{hh:02d}:{mm:02d}\"\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 60  # minutes\n\n# Define participants' busy times in HH:MM format\nparticipants_busy_times = [\n    [],  # Thomas has no busy times\n    [(\"10:30\", \"11:00\"), (\"13:30\", \"14:00\")],  # Dylan's busy times\n    [(\"9:00\", \"11:00\"), (\"11:30\", \"14:30\"), (\"16:00\", \"17:00\")],  # Jerry's busy times\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours, duration)\n\n# Format the output as HH:MM:HH:MM\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{start}:{end}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_6"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each participant's blocked times to minutes since 9:00\n    heather_blocked = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 11 * 60),\n        (13 * 60, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    nicholas_blocked = []  # No meetings\n    zachary_blocked = [\n        (9 * 60, 10 * 60 + 30),\n        (11 * 60, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 16 * 60 + 30)\n    ]\n    zachary_preference_end = 14 * 60  # Prefers not to meet after 14:00\n\n    # Combine all blocked times for each participant\n    blocked_times = {\n        'Heather': heather_blocked,\n        'Nicholas': nicholas_blocked,\n        'Zachary': zachary_blocked\n    }\n\n    # Find all possible slots that work for everyone\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        # Check if the slot is before Zachary's preference\n        if slot_end > zachary_preference_end:\n            current_time += 1\n            continue\n        # Check if the slot is free for all participants\n        all_free = True\n        for participant, blocks in blocked_times.items():\n            for block_start, block_end in blocks:\n                if not (slot_end <= block_start or current_time >= block_end):\n                    all_free = False\n                    break\n            if not all_free:\n                break\n        if all_free:\n            # Convert back to HH:MM format\n            start_hh = current_time // 60\n            start_mm = current_time % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n        current_time += 1  # Increment by 1 minute to check next slot\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_7"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes, work_start, work_end):\n    # Convert all time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start_min\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n    \n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nadam_schedule = [\n    \"10:00 to 10:30\",\n    \"12:30 to 13:00\",\n    \"13:30 to 14:30\"\n]\n\njerry_schedule = [\n    \"09:00 to 09:30\",\n    \"12:00 to 12:30\",\n    \"15:00 to 16:00\"\n]\n\nmatthew_schedule = [\n    \"09:30 to 11:00\",\n    \"11:30 to 12:30\",\n    \"13:00 to 14:00\",\n    \"14:30 to 17:00\"\n]\n\n# Combine all schedules\nparticipants_schedules = [adam_schedule, jerry_schedule, matthew_schedule]\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, 30, \"09:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_8"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\ndiane_schedule = [\n    \"9:00 to 9:30\",\n    \"12:00 to 12:30\",\n    \"14:30 to 15:30\"\n]\n\nkelly_schedule = [\n    \"9:30 to 10:00\",\n    \"10:30 to 11:00\"\n]\n\ndeborah_schedule = [\n    \"9:00 to 9:30\",\n    \"10:00 to 14:00\",\n    \"14:30 to 17:00\"\n]\n\n# Combine all schedules\nparticipants_schedules = [diane_schedule, kelly_schedule, deborah_schedule]\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_9"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define busy slots for each participant in minutes since midnight\n    diana_busy = [(11 * 60 + 30, 12 * 60), (13 * 60, 13 * 60 + 30)]\n    ethan_busy = []  # No meetings\n    janet_busy = [(9 * 60, 10 * 60), (12 * 60 + 30, 13 * 60), (14 * 60, 15 * 60), (15 * 60 + 30, 17 * 60)]\n    janet_preference_end = 12 * 60  # Janet doesn't want to meet after 12:00\n\n    # Combine all busy slots and sort them\n    all_busy = diana_busy + ethan_busy + janet_busy\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check each free slot for availability and Janet's preference\n    for slot_start, slot_end in free_slots:\n        # Calculate the latest possible start time in this slot\n        latest_start = slot_end - meeting_duration\n        if latest_start >= slot_start:\n            # The slot can accommodate the meeting\n            actual_start = max(slot_start, latest_start)\n            actual_end = actual_start + meeting_duration\n            # Check Janet's preference (not after 12:00)\n            if actual_end <= janet_preference_end:\n                # Format the time as HH:MM:HH:MM\n                return f\"{actual_start // 60:02d}:{actual_start % 60:02d}:{actual_end // 60:02d}:{actual_end % 60:02d}\"\n\n    # If no slot found (though the problem states there is one)\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_10"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert all time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's busy slots\n    for busy_slots in participants_busy:\n        new_free_slots = []\n        for busy_start, busy_end in busy_slots:\n            busy_start_min = time_to_minutes(busy_start)\n            busy_end_min = time_to_minutes(busy_end)\n            temp_slots = []\n            for slot_start, slot_end in free_slots:\n                if busy_end_min <= slot_start or busy_start_min >= slot_end:\n                    # No overlap, keep the slot as is\n                    temp_slots.append((slot_start, slot_end))\n                else:\n                    # There is an overlap, split the slot\n                    if slot_start < busy_start_min:\n                        temp_slots.append((slot_start, busy_start_min))\n                    if slot_end > busy_end_min:\n                        temp_slots.append((busy_end_min, slot_end))\n            free_slots = temp_slots\n        if not free_slots:\n            return None  # No possible slot\n    \n    # Now find the intersection of all free slots (already done in the loop)\n    # Check if any remaining slot can fit the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return (minutes_to_time(meeting_start), minutes_to_time(meeting_end))\n    \n    return None\n\n# Define the participants' busy times\nparticipants_busy = [\n    [(\"09:30\", \"10:00\"), (\"10:30\", \"11:00\"), (\"12:30\", \"13:00\"), (\"14:30\", \"15:00\"), (\"16:00\", \"17:00\")],  # Alexander\n    [(\"09:00\", \"09:30\"), (\"11:30\", \"12:30\"), (\"13:00\", \"14:30\")],  # Elizabeth\n    [(\"09:00\", \"14:30\"), (\"15:30\", \"17:00\")]  # Walter\n]\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nmeeting_duration = 30  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, meeting_duration)\n\n# Output the result in the required format\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{start}:{end}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_11"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:14:00}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert all time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = work_hours\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start_min, work_end_min)]\n    \n    # Process each participant's schedule to find common free slots\n    for schedule in participents_schedules:\n        busy_slots = []\n        for slot in schedule:\n            start, end = map(time_to_minutes, slot.split(':'))\n            busy_slots.append((start, end))\n        # Sort the busy slots by start time\n        busy_slots.sort()\n        # Merge overlapping or adjacent busy slots\n        merged_busy = []\n        for start, end in busy_slots:\n            if not merged_busy:\n                merged_busy.append((start, end))\n            else:\n                last_start, last_end = merged_busy[-1]\n                if start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = last_start\n                    new_end = max(last_end, end)\n                    merged_busy[-1] = (new_start, new_end)\n                else:\n                    merged_busy.append((start, end))\n        # Calculate free slots for this participant\n        participant_free = []\n        prev_end = work_start_min\n        for start, end in merged_busy:\n            if start > prev_end:\n                participant_free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end_min:\n            participant_free.append((prev_end, work_end_min))\n        # Intersect with current free slots\n        new_free_slots = []\n        i = j = 0\n        while i < len(free_slots) and j < len(participant_free):\n            fs_start, fs_end = free_slots[i]\n            pf_start, pf_end = participant_free[j]\n            # Find the overlap\n            overlap_start = max(fs_start, pf_start)\n            overlap_end = min(fs_end, pf_end)\n            if overlap_start < overlap_end:\n                new_free_slots.append((overlap_start, overlap_end))\n            # Move the pointer which ends first\n            if fs_end < pf_end:\n                i += 1\n            else:\n                j += 1\n        free_slots = new_free_slots\n    \n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= duration_min:\n            meeting_end = start + duration_min\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    return \"No suitable time found\"\n\n# Define the schedules and constraints\nparticipants_schedules = [\n    [],  # David has no meetings\n    [\"09:30:10:00\", \"11:00:11:30\", \"12:00:13:00\", \"14:00:14:30\", \"16:00:16:30\"],  # Debra\n    [\"09:00:12:00\", \"14:00:17:00\"],  # Kevin\n]\nwork_hours = (\"09:00\", \"17:00\")\nduration = 1  # hour\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_12"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Gerald's busy slots in minutes (9:00-9:30, 13:00-14:00, 15:00-15:30, 16:00-17:00)\n    gerald_busy = [(9*60, 9*60 + 30), (13*60, 14*60), (15*60, 15*60 + 30), (16*60, 17*60)]\n    # Gerald prefers no meetings before 13:00\n    gerald_preferred_start = 13 * 60\n\n    # Barbara's busy slots in minutes (9:30-10:00, 11:30-14:00, 14:30-15:00, 15:30-17:00)\n    barbara_busy = [(9*60 + 30, 10*60), (11*60 + 30, 14*60), (14*60 + 30, 15*60), (15*60 + 30, 17*60)]\n\n    # Roy is free all day, so no constraints\n\n    # Generate all possible slots starting from 13:00 to 17:00 - meeting_duration\n    possible_slots = []\n    current_time = max(work_start, gerald_preferred_start)\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        # Check if the slot is free for Gerald and Barbara\n        gerald_free = True\n        for start, end in gerald_busy:\n            if not (slot_end <= start or current_time >= end):\n                gerald_free = False\n                break\n        barbara_free = True\n        for start, end in barbara_busy:\n            if not (slot_end <= start or current_time >= end):\n                barbara_free = False\n                break\n        if gerald_free and barbara_free:\n            possible_slots.append((current_time, slot_end))\n        current_time += 15  # Check every 15 minutes\n\n    # Select the first available slot\n    if possible_slots:\n        start, end = possible_slots[0]\n        # Convert back to HH:MM format\n        start_hh = start // 60\n        start_mm = start % 60\n        end_hh = end // 60\n        end_mm = end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_13"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' schedules and constraints\n    brandon_busy = [\n        (13 * 60, 14 * 60),    # 13:00-14:00\n        (15 * 60 + 30, 16 * 60),  # 15:30-16:00\n        (16 * 60 + 30, 17 * 60)   # 16:30-17:00\n    ]\n    brandon_preference_start = 14 * 60 + 30  # 14:30\n\n    jerry_busy = []  # No meetings\n\n    bradley_busy = [\n        (9 * 60, 11 * 60 + 30),  # 9:00-11:30\n        (12 * 60, 15 * 60),      # 12:00-15:00\n        (16 * 60, 16 * 60 + 30)   # 16:00-16:30\n    ]\n\n    # Combine all busy times and sort\n    all_busy = brandon_busy + bradley_busy  # Jerry has no busy times\n    all_busy.sort()\n\n    # Find available slots\n    available_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n\n    # Filter slots based on duration (30 minutes) and Brandon's preference\n    meeting_duration = 30\n    valid_slots = []\n\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration:\n            actual_start = max(slot_start, brandon_preference_start)\n            if actual_start + meeting_duration <= slot_end:\n                valid_slots.append((actual_start, actual_start + meeting_duration))\n\n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start, meeting_end = valid_slots[0]\n    else:\n        return None\n\n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n\n    start_time = minutes_to_time(meeting_start)\n    end_time = minutes_to_time(meeting_end)\n\n    return f\"{start_time}:{end_time}\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_14"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Define participants' schedules and constraints\n    joyce_busy = [\n        (11 * 60, 11 * 60 + 30),    # 11:00-11:30\n        (13 * 60 + 30, 14 * 60),    # 13:30-14:00\n        (14 * 60 + 30, 16 * 60 + 30) # 14:30-16:30\n    ]\n    christine_busy = []  # No meetings\n    christine_constraint = (12 * 60, work_end)  # Can't meet before 12:00\n    alexander_busy = [\n        (9 * 60, 11 * 60),          # 9:00-11:00\n        (12 * 60, 12 * 60 + 30),    # 12:00-12:30\n        (13 * 60 + 30, 15 * 60),    # 13:30-15:00\n        (15 * 60 + 30, 16 * 60),    # 15:30-16:00\n        (16 * 60 + 30, 17 * 60)    # 16:30-17:00\n    ]\n\n    # Meeting duration in minutes\n    duration = 30\n\n    # Generate all possible slots\n    possible_slots = []\n    current_time = work_start\n\n    while current_time + duration <= work_end:\n        slot_start = current_time\n        slot_end = current_time + duration\n\n        # Check Christine's constraint (can't meet before 12:00)\n        if slot_start < 12 * 60:\n            current_time += 15  # Check in 15-minute increments\n            continue\n\n        # Check Joyce's availability\n        joyce_available = True\n        for busy_start, busy_end in joyce_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                joyce_available = False\n                break\n\n        # Check Alexander's availability\n        alexander_available = True\n        for busy_start, busy_end in alexander_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                alexander_available = False\n                break\n\n        # If all are available, add the slot\n        if joyce_available and alexander_available:\n            possible_slots.append((slot_start, slot_end))\n\n        current_time += 15  # Check in 15-minute increments\n\n    # Select the first available slot\n    if possible_slots:\n        meeting_start, meeting_end = possible_slots[0]\n        # Convert minutes back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        print(f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\")\n    else:\n        print(\"No available time slot found.\")\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_15"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work_hours start at 9:00\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = 9 + minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split('-')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Initialize free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's schedule to find common free slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = busy.split('-')\n            busy_start = time_to_minutes(start)\n            busy_end = time_to_minutes(end)\n            busy_slots.append((busy_start, busy_end))\n        \n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Calculate free slots for this participant\n        current_free = []\n        prev_end = work_start\n        for start, end in busy_slots:\n            if start > prev_end:\n                current_free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            current_free.append((prev_end, work_end))\n        \n        # Intersect current_free with existing free_slots\n        new_free_slots = []\n        i = j = 0\n        while i < len(free_slots) and j < len(current_free):\n            start1, end1 = free_slots[i]\n            start2, end2 = current_free[j]\n            \n            # Find overlapping interval\n            start = max(start1, start2)\n            end = min(end1, end2)\n            if start < end:\n                new_free_slots.append((start, end))\n            \n            # Move the pointer which ends first\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        \n        free_slots = new_free_slots\n    \n    # Find the first slot that can fit the meeting duration\n    duration_min = duration * 60\n    for start, end in free_slots:\n        if end - start >= duration_min:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration_min)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"09:30-10:30\", \"13:30-14:00\", \"14:30-15:00\", \"15:30-16:00\", \"16:30-17:00\"],  # Scott\n    [],  # Gabriel\n    [\"09:00-10:00\", \"10:30-12:30\", \"13:00-17:00\"],  # Christine\n]\n\n# Define meeting duration in hours (0.5 hours = 30 minutes)\nduration = 0.5\nwork_hours = \"9:00-17:00\"\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_16"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Convert blocked times to minutes since midnight\n    margaret_blocked = [\n        (9 * 60, 10 * 60),    # 9:00-10:00\n        (10 * 60 + 30, 11 * 60),  # 10:30-11:00\n        (11 * 60 + 30, 12 * 60),  # 11:30-12:00\n        (13 * 60, 13 * 60 + 30),  # 13:00-13:30\n        (15 * 60, 15 * 60 + 30)   # 15:00-15:30\n    ]\n    donna_blocked = [\n        (14 * 60 + 30, 15 * 60),  # 14:30-15:00\n        (16 * 60, 16 * 60 + 30)   # 16:00-16:30\n    ]\n    helen_blocked = [\n        (9 * 60, 9 * 60 + 30),    # 9:00-9:30\n        (10 * 60, 11 * 60 + 30),  # 10:00-11:30\n        (13 * 60, 14 * 60),        # 13:00-14:00\n        (14 * 60 + 30, 15 * 60),  # 14:30-15:00\n        (15 * 60 + 30, 17 * 60)   # 15:30-17:00\n    ]\n    helen_no_meet_after = 13 * 60 + 30  # 13:30\n\n    meeting_duration = 30  # minutes\n\n    # Combine all blocked times and sort them\n    all_blocked = []\n    for start, end in margaret_blocked:\n        all_blocked.append((start, end, 'Margaret'))\n    for start, end in donna_blocked:\n        all_blocked.append((start, end, 'Donna'))\n    for start, end in helen_blocked:\n        all_blocked.append((start, end, 'Helen'))\n    all_blocked.sort()\n\n    # Find available slots\n    available_slots = []\n    current_time = work_start\n\n    for start, end, person in all_blocked:\n        if start > current_time:\n            available_slots.append((current_time, start))\n        current_time = max(current_time, end)\n    if current_time < work_end:\n        available_slots.append((current_time, work_end))\n\n    # Filter slots based on Helen's preference (before 13:30)\n    filtered_slots = []\n    for start, end in available_slots:\n        if end <= helen_no_meet_after:\n            filtered_slots.append((start, end))\n\n    # Find the first slot that fits the meeting duration\n    for start, end in filtered_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_17"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Billy's busy slots in minutes\n    billy_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    # Patricia's busy slots in minutes\n    patricia_busy = [\n        (9 * 60, 12 * 60 + 30),\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    # Billy's preference to avoid meetings after 15:30\n    billy_preference_end = 15 * 60 + 30\n\n    # Generate all possible meeting slots\n    possible_slots = []\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        # Check if the slot works for everyone\n        billy_free = all(not (start < slot_end and end > current_time) for start, end in billy_busy)\n        patricia_free = all(not (start < slot_end and end > current_time) for start, end in patricia_busy)\n        # Check Billy's preference\n        billy_preference_ok = slot_end <= billy_preference_end\n        if billy_free and patricia_free and billy_preference_ok:\n            possible_slots.append((current_time, slot_end))\n        current_time += 30  # Check every 30 minutes\n\n    # Select the first available slot\n    if possible_slots:\n        start, end = possible_slots[0]\n        # Convert minutes back to HH:MM format\n        start_hh = start // 60\n        start_mm = start % 60\n        end_hh = end // 60\n        end_mm = end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_18"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration_hours):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_hours * 60\n    \n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy_times in participants_busy_times:\n        for interval in busy_times:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Check the available slots between work hours and busy intervals\n    prev_end = work_start\n    available_slots = []\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define the participants' busy times\nstephen_busy = [\"10:00 to 10:30\", \"13:00 to 13:30\", \"14:30 to 15:00\", \"16:00 to 16:30\"]\nedward_busy = [\"9:00 to 9:30\", \"10:00 to 10:30\", \"13:30 to 14:30\", \"15:00 to 16:00\"]\nangela_busy = [\"9:00 to 11:30\", \"12:30 to 13:00\", \"13:30 to 15:30\", \"16:00 to 17:00\"]\n\n# Combine all busy times\nparticipants_busy_times = [stephen_busy, edward_busy, angela_busy]\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_hours = 1\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_19"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert each person's busy slots to minutes\n    ralph_busy = [\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60)\n    ]\n    peter_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (11 * 60, 13 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    daniel_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 15 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n    daniel_preference = 13 * 60 + 30  # Prefers no meetings after 13:30\n\n    # Combine all busy slots\n    all_busy = ralph_busy + peter_busy + daniel_busy\n    all_busy.sort()  # Sort by start time\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check each free slot for a 30-minute window that fits all constraints\n    meeting_duration = 30\n    for slot_start, slot_end in free_slots:\n        current_start = slot_start\n        while current_start + meeting_duration <= slot_end:\n            current_end = current_start + meeting_duration\n            # Check if it's before Daniel's preference (13:30)\n            if current_end <= daniel_preference:\n                return f\"{current_start // 60:02d}:{current_start % 60:02d}:{current_end // 60:02d}:{current_end % 60:02d}\"\n            current_start += 1  # Increment by 1 minute to check next possible slot\n\n    # If no slot found before preference, check after (though not preferred)\n    for slot_start, slot_end in free_slots:\n        current_start = slot_start\n        while current_start + meeting_duration <= slot_end:\n            current_end = current_start + meeting_duration\n            return f\"{current_start // 60:02d}:{current_start % 60:02d}:{current_end // 60:02d}:{current_end % 60:02d}\"\n            current_start += 1\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_20"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration):\n    # Convert all time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 (9:00)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    work_start, work_end = work_hours.split(' to ')\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Generate all busy intervals in minutes\n    all_busy = []\n    for busy_times in participants_busy_times.values():\n        for busy in busy_times:\n            start, end = busy.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            all_busy.append((start_min, end_min))\n    \n    # Sort all busy intervals\n    all_busy.sort()\n    \n    # Find free intervals\n    free_intervals = []\n    prev_end = work_start_min\n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n    \n    # Find the first free interval that can fit the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' busy times\nparticipants_busy_times = {\n    'Bobby': [],\n    'Scott': ['11:30 to 12:00', '15:30 to 16:00'],\n    'Kimberly': ['11:00 to 12:00', '12:30 to 13:00', '13:30 to 14:00', '14:30 to 15:00', '15:30 to 17:00']\n}\n\n# Define work hours and meeting duration\nwork_hours = '9:00 to 17:00'\nmeeting_duration = 60  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy_times, work_hours, meeting_duration))\n```",
            "count": "calendar_scheduling_example_21"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    duration = 60        # 1 hour in minutes\n\n    # Convert each person's busy times to minutes since midnight\n    theresa_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (12 * 60 + 30, 13 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    charles_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (14 * 60, 15 * 60 + 30)\n    ]\n    betty_busy = [\n        (9 * 60, 10 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 14 * 60),\n        (15 * 60, 16 * 60)\n    ]\n\n    # Combine all busy times into a single list\n    all_busy = theresa_busy + charles_busy + betty_busy\n\n    # Sort busy times by start time\n    all_busy.sort()\n\n    # Find the earliest available slot\n    current_time = work_start\n    for busy_start, busy_end in all_busy:\n        if busy_start > current_time:\n            if busy_start - current_time >= duration:\n                # Found a slot\n                end_time = current_time + duration\n                return f\"{current_time // 60:02d}:{current_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n        if busy_end > current_time:\n            current_time = busy_end\n\n    # Check after the last busy slot\n    if work_end - current_time >= duration:\n        end_time = current_time + duration\n        return f\"{current_time // 60:02d}:{current_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n\n    return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_22"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = work_hours\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = busy\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            busy_intervals.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start_min\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        available_slots.append((prev_end, work_end_min))\n    \n    # Check each available slot for sufficient duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [(\"11:30\", \"12:00\"), (\"13:00\", \"15:00\"), (\"16:00\", \"16:30\")],  # Billy\n    [(\"09:00\", \"09:30\"), (\"10:00\", \"10:30\"), (\"13:00\", \"13:30\"), (\"14:00\", \"14:30\")],  # Maria\n    [(\"09:30\", \"10:00\"), (\"12:00\", \"12:30\"), (\"13:30\", \"15:00\"), (\"15:30\", \"17:00\")],  # William\n]\n\n# Define work hours and meeting duration\nwork_hours = (\"09:00\", \"17:00\")\nduration = 1  # hour\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_23"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define Brenda's busy slots in minutes\n    brenda_busy = [\n        (9 * 60 + 30, 10 * 60),      # 9:30 to 10:00\n        (11 * 60 + 30, 12 * 60 + 30), # 11:30 to 12:30\n        (14 * 60, 16 * 60 + 30)       # 14:00 to 16:30\n    ]\n    \n    # Benjamin's constraint: cannot meet after 9:30\n    benjamin_constraint = 9 * 60 + 30  # 9:30 in minutes\n    \n    # Generate all possible 30-minute slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + 30 <= work_end:\n        slot_end = current_time + 30\n        # Check if the slot is before Benjamin's constraint\n        if slot_end <= benjamin_constraint:\n            # Check if Brenda is free during this slot\n            brenda_free = True\n            for busy_start, busy_end in brenda_busy:\n                if not (slot_end <= busy_start or current_time >= busy_end):\n                    brenda_free = False\n                    break\n            if brenda_free:\n                possible_slots.append((current_time, slot_end))\n        current_time += 15  # Check every 15 minutes for flexibility\n    \n    # Select the first available slot\n    if possible_slots:\n        meeting_start, meeting_end = possible_slots[0]\n        # Convert minutes back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_24"
        },
        {
            "final_program_time": "{13:30:14:30}",
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define busy intervals in minutes for each participant\n    anthony_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (12 * 60, 13 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    pamela_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    zachary_busy = [\n        (9 * 60, 11 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60, 17 * 60)\n    ]\n\n    # Pamela's constraint: no meetings after 14:30\n    pamela_no_meet_after = 14 * 60 + 30\n\n    # Meeting duration in minutes\n    duration = 60\n\n    # Generate all possible slots within work hours\n    possible_slots = []\n    current_start = work_start\n    while current_start + duration <= work_end:\n        possible_slots.append((current_start, current_start + duration))\n        current_start += 30  # Check every 30 minutes for efficiency\n\n    # Check each slot against all constraints\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n\n        # Check Pamela's time constraint\n        if slot_start >= pamela_no_meet_after:\n            continue\n\n        # Check Anthony's availability\n        anthony_available = True\n        for busy_start, busy_end in anthony_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                anthony_available = False\n                break\n        if not anthony_available:\n            continue\n\n        # Check Pamela's availability\n        pamela_available = True\n        for busy_start, busy_end in pamela_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                pamela_available = False\n                break\n        if not pamela_available:\n            continue\n\n        # Check Zachary's availability\n        zachary_available = True\n        for busy_start, busy_end in zachary_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                zachary_available = False\n                break\n        if not zachary_available:\n            continue\n\n        # If all checks passed, return this slot\n        return f\"{slot_start // 60:02d}:{slot_start % 60:02d}:{slot_end // 60:02d}:{slot_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_25"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:30:16:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(schedules, duration, work_start, work_end):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for person in schedules:\n        for interval in schedules[person]:\n            start, end = map(time_to_minutes, interval.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start_min\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        available_slots.append((prev_end, work_end_min))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define the schedules\nschedules = {\n    \"Katherine\": [],\n    \"Nicole\": [],\n    \"Kevin\": [\"9:00:10:00\", \"10:30:11:30\", \"12:00:15:30\", \"16:30:17:00\"]\n}\n\n# Find a 1-hour meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(schedules, 1, \"9:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_26"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability\n    duration_min = duration * 60\n    for start, end in free_intervals:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"10:00 to 10:30\", \"15:30 to 16:00\"],  # Jesse\n    [],                                    # Kathryn\n    [\"10:30 to 11:00\", \"11:30 to 12:30\", \"13:30 to 14:30\", \"15:00 to 16:30\"]  # Megan\n]\n\n# Define meeting parameters\nmeeting_duration = 30  # minutes\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\n\n# Find the earliest available meeting time\nmeeting_time = find_meeting_time(participants_schedules, meeting_duration, work_hours_start, work_hours_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_27"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_start=\"09:00\", work_end=\"17:00\"):\n    # Convert time strings to minutes since 00:00 for easier calculations\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Initialize the busy slots for all participants\n    busy_slots = []\n    for schedule in participants_schedules:\n        person_busy = []\n        for slot in schedule:\n            start, end = map(time_to_minutes, slot.split(' to '))\n            person_busy.append((start, end))\n        busy_slots.append(person_busy)\n    \n    # Find all possible meeting slots that fit within work hours\n    possible_slots = []\n    current_time = work_start_min\n    \n    while current_time + duration_minutes <= work_end_min:\n        slot_end = current_time + duration_minutes\n        valid = True\n        \n        # Check if the slot is free for all participants\n        for person_busy in busy_slots:\n            for start, end in person_busy:\n                if not (slot_end <= start or current_time >= end):\n                    valid = False\n                    break\n            if not valid:\n                break\n        \n        if valid:\n            possible_slots.append((current_time, slot_end))\n        \n        current_time += 15  # Check in 15-minute increments\n    \n    if not possible_slots:\n        return None\n    \n    # Find the earliest available slot\n    earliest_slot = possible_slots[0]\n    start_min, end_min = earliest_slot\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_time = minutes_to_time(start_min)\n    end_time = minutes_to_time(end_min)\n    \n    return f\"{start_time}:{end_time}\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"13:00 to 13:30\", \"16:00 to 16:30\"],  # Brittany\n    [],                                    # Emily (free all day)\n    [\"09:00 to 11:00\", \"11:30 to 14:30\", \"15:00 to 17:00\"],  # Doris\n]\n\n# Find the earliest meeting time\nmeeting_time = find_meeting_time(participants_schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_28"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:00:13:00}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    # Initialize the free slots within work hours\n    start_work = time_to_minutes(work_hours[0])\n    end_work = time_to_minutes(work_hours[1])\n    free_slots = [(start_work, end_work)]\n\n    # Function to subtract busy slots from free slots\n    def subtract_busy_slots(free_slots, busy_start, busy_end):\n        new_slots = []\n        for slot_start, slot_end in free_slots:\n            if busy_start >= slot_end or busy_end <= slot_start:\n                new_slots.append((slot_start, slot_end))\n            else:\n                if slot_start < busy_start:\n                    new_slots.append((slot_start, busy_start))\n                if slot_end > busy_end:\n                    new_slots.append((busy_end, slot_end))\n        return new_slots\n\n    # Process each participant's schedule\n    for schedule in participents_schedules:\n        for busy in schedule:\n            busy_start = time_to_minutes(busy[0])\n            busy_end = time_to_minutes(busy[1])\n            free_slots = subtract_busy_slots(free_slots, busy_start, busy_end)\n\n    # Find the first slot that can fit the duration\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No suitable time found\"\n\n# Define the participants' schedules\nmadison_schedule = [(\"09:30\", \"10:00\"), (\"11:30\", \"12:00\")]\ndiana_schedule = [(\"11:00\", \"11:30\"), (\"13:00\", \"13:30\")]\nshirley_schedule = [(\"09:00\", \"12:00\"), (\"13:30\", \"15:00\"), (\"15:30\", \"17:00\")]\n\nparticipants_schedules = [madison_schedule, diana_schedule, shirley_schedule]\nwork_hours = (\"09:00\", \"17:00\")\nduration = 60  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_29"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy times in minutes since midnight\n    jeffrey_busy = [\n        (9 * 60 + 30, 10 * 60),    # 9:30-10:00\n        (10 * 60 + 30, 11 * 60)    # 10:30-11:00\n    ]\n    \n    virginia_busy = [\n        (9 * 60, 9 * 60 + 30),     # 9:00-9:30\n        (10 * 60, 10 * 60 + 30),   # 10:00-10:30\n        (14 * 60 + 30, 15 * 60),   # 14:30-15:00\n        (16 * 60, 16 * 60 + 30)    # 16:00-16:30\n    ]\n    \n    melissa_busy = [\n        (9 * 60, 11 * 60 + 30),    # 9:00-11:30\n        (12 * 60, 12 * 60 + 30),   # 12:00-12:30\n        (13 * 60, 15 * 60),        # 13:00-15:00\n        (16 * 60, 17 * 60)         # 16:00-17:00\n    ]\n    \n    # Melissa's preference: not after 14:00\n    preference_end = 14 * 60\n    \n    # Meeting duration in minutes\n    duration = 30\n    \n    # Generate all possible slots within work hours, considering Melissa's preference\n    possible_slots = []\n    current_time = work_start\n    \n    while current_time + duration <= min(work_end, preference_end):\n        # Check if the slot is free for all participants\n        jeffrey_free = all(not (start <= current_time < end or start < current_time + duration <= end) \n                           for start, end in jeffrey_busy)\n        virginia_free = all(not (start <= current_time < end or start < current_time + duration <= end) \n                           for start, end in virginia_busy)\n        melissa_free = all(not (start <= current_time < end or start < current_time + duration <= end) \n                          for start, end in melissa_busy)\n        \n        if jeffrey_free and virginia_free and melissa_free:\n            possible_slots.append((current_time, current_time + duration))\n        \n        current_time += 15  # Check every 15 minutes for efficiency\n    \n    # Select the first available slot\n    if possible_slots:\n        start, end = possible_slots[0]\n        # Convert minutes back to HH:MM format\n        start_hh = start // 60\n        start_mm = start % 60\n        end_hh = end // 60\n        end_mm = end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_30"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each participant's busy times to minutes since midnight\n    richard_busy = [\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    martha_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (13 * 60, 13 * 60 + 30)\n    ]\n    kimberly_busy = [\n        (9 * 60, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60, 16 * 60)\n    ]\n\n    # Martha's preference: not before 14:00\n    martha_preference_start = 14 * 60\n\n    # Combine all busy times and sort\n    all_busy = []\n    for start, end in richard_busy:\n        all_busy.append((start, end, 'Richard'))\n    for start, end in martha_busy:\n        all_busy.append((start, end, 'Martha'))\n    for start, end in kimberly_busy:\n        all_busy.append((start, end, 'Kimberly'))\n    all_busy.sort()\n\n    # Find available slots\n    available_slots = []\n    current_time = max(work_start, martha_preference_start)\n\n    while current_time + meeting_duration <= work_end:\n        conflict = False\n        for busy_start, busy_end, person in all_busy:\n            if not (current_time + meeting_duration <= busy_start or current_time >= busy_end):\n                conflict = True\n                current_time = busy_end\n                break\n        if not conflict:\n            available_slots.append((current_time, current_time + meeting_duration))\n            current_time += meeting_duration\n\n    # Return the first available slot\n    if available_slots:\n        start, end = available_slots[0]\n        start_hr = start // 60\n        start_min = start % 60\n        end_hr = end // 60\n        end_min = end % 60\n        return f\"{start_hr:02d}:{start_min:02d}:{end_hr:02d}:{end_min:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_31"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' busy times in minutes since midnight\n    emily_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    melissa_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (14 * 60 + 30, 15 * 60)\n    ]\n    frank_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60 + 30),\n        (15 * 60, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    # Frank's constraint: doesn't want to meet after 9:30 (but his busy times already reflect this)\n    # Meeting duration is 30 minutes\n    duration = 30\n\n    # Combine all busy times and sort them\n    all_busy = emily_busy + melissa_busy + frank_busy\n    all_busy.sort()\n\n    # Find the earliest available slot\n    previous_end = work_start\n    for start, end in all_busy:\n        if start > previous_end and (start - previous_end) >= duration:\n            # Check if the slot is before Frank's constraint (before or at 9:30)\n            if previous_end <= 9 * 60 + 30 - duration:\n                return format_time(previous_end, previous_end + duration)\n        previous_end = max(previous_end, end)\n    \n    # Check after the last busy slot\n    if work_end - previous_end >= duration and previous_end <= 9 * 60 + 30 - duration:\n        return format_time(previous_end, previous_end + duration)\n    \n    # If no slot found (though the problem states there is one)\n    return \"No time found\"\n\ndef format_time(start_min, end_min):\n    start_h = start_min // 60\n    start_m = start_min % 60\n    end_h = end_min // 60\n    end_m = end_min % 60\n    return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n\n# Execute and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_32"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define each person's busy times in minutes (start, end)\n    lisa_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    bobby_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    randy_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n\n    # Bobby's preference: avoid after 15:00\n    bobby_preference_end = 15 * 60\n\n    # Combine all busy times and sort them\n    all_busy = lisa_busy + bobby_busy + randy_busy\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Add the slot after the last busy time if within work hours\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Filter free slots that are at least 30 minutes and respect Bobby's preference\n    meeting_duration = 30\n    valid_slots = []\n\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Check if the slot is entirely before Bobby's preference end time\n            if end <= bobby_preference_end:\n                valid_slots.append((start, end))\n            # Or if the slot starts early enough to fit the meeting before preference\n            elif start <= bobby_preference_end - meeting_duration:\n                valid_slots.append((start, min(end, bobby_preference_end)))\n\n    # Find the earliest valid slot\n    if valid_slots:\n        earliest_slot = min(valid_slots)\n        meeting_start = earliest_slot[0]\n        meeting_end = meeting_start + meeting_duration\n    else:\n        # If no slot before preference, check all free slots (though problem states a solution exists)\n        for start, end in free_slots:\n            if end - start >= meeting_duration:\n                meeting_start = start\n                meeting_end = start + meeting_duration\n                break\n\n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n\n    start_time = minutes_to_time(meeting_start)\n    end_time = minutes_to_time(meeting_end)\n\n    return f\"{start_time}:{end_time}\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_33"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert all time strings to minutes since start of the day\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Initialize the free time slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Function to subtract busy slots from free slots\n    def subtract_busy(free_slots, busy_start, busy_end):\n        new_slots = []\n        for start, end in free_slots:\n            if busy_end <= start or busy_start >= end:\n                new_slots.append((start, end))\n            else:\n                if start < busy_start:\n                    new_slots.append((start, busy_start))\n                if end > busy_end:\n                    new_slots.append((busy_end, end))\n        return new_slots\n    \n    # Process each participant's busy slots\n    for busy_slots in participants_busy:\n        for busy in busy_slots:\n            busy_start, busy_end = map(time_to_minutes, busy.split(' to '))\n            free_slots = subtract_busy(free_slots, busy_start, busy_end)\n    \n    # Find the first free slot that can accommodate the meeting\n    duration_min = duration * 60\n    for start, end in free_slots:\n        if end - start >= duration_min:\n            meeting_end = start + duration_min\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' busy slots\nparticipants_busy = [\n    [\"10:00 to 10:30\", \"11:00 to 12:00\", \"13:00 to 14:00\", \"16:00 to 16:30\"],  # Richard\n    [\"10:00 to 10:30\", \"11:30 to 13:00\", \"13:30 to 14:00\", \"14:30 to 17:00\"],  # Noah\n]\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nduration = 1  # hour\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_34"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' schedules and constraints in minutes\n    # Bradley: free all day but doesn't want to meet before 14:30\n    bradley_constraint = 14 * 60 + 30  # 14:30 in minutes\n    \n    # Zachary's meetings\n    zachary_busy = [\n        (10 * 60, 10 * 60 + 30),   # 10:00-10:30\n        (15 * 60, 15 * 60 + 30)     # 15:00-15:30\n    ]\n    \n    # Teresa's blocked times\n    teresa_busy = [\n        (9 * 60, 10 * 60 + 30),     # 9:00-10:30\n        (11 * 60, 12 * 60 + 30),    # 11:00-12:30\n        (13 * 60, 14 * 60),         # 13:00-14:00\n        (14 * 60 + 30, 16 * 60 + 30) # 14:30-16:30\n    ]\n    \n    meeting_duration = 30  # minutes\n    \n    # Generate all possible 30-minute slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 1  # Check every minute\n    \n    # Check each slot against all constraints\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        \n        # Bradley's constraint: not before 14:30\n        if slot_start < bradley_constraint:\n            continue\n        \n        # Check Zachary's busy times\n        zachary_conflict = False\n        for busy_start, busy_end in zachary_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                zachary_conflict = True\n                break\n        if zachary_conflict:\n            continue\n        \n        # Check Teresa's busy times\n        teresa_conflict = False\n        for busy_start, busy_end in teresa_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                teresa_conflict = True\n                break\n        if teresa_conflict:\n            continue\n        \n        # If no conflicts, return this slot\n        start_h = slot_start // 60\n        start_m = slot_start % 60\n        end_h = slot_end // 60\n        end_m = slot_end % 60\n        return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_35"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    duration = 60          # 1 hour in minutes\n\n    # Busy intervals for each participant in minutes since midnight\n    ryan_busy = [(9 * 60, 9 * 60 + 30), (12 * 60 + 30, 13 * 60)]\n    ruth_busy = []  # No meetings\n    denise_busy = [(9 * 60 + 30, 10 * 60 + 30), (12 * 60, 13 * 60), (14 * 60 + 30, 16 * 60 + 30)]\n    denise_no_meet_after = 12 * 60 + 30  # Denise doesn't want to meet after 12:30\n\n    # Combine all busy intervals and sort them\n    all_busy = ryan_busy + ruth_busy + denise_busy\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy intervals and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Filter free slots that meet duration and Denise's constraint\n    valid_slots = []\n    for start, end in free_slots:\n        slot_start = start\n        slot_end = end\n        # Ensure the slot is at least 'duration' long\n        if slot_end - slot_start >= duration:\n            # Check Denise's constraint: meeting must end by 12:30\n            if slot_start + duration <= denise_no_meet_after:\n                valid_slots.append((slot_start, slot_end))\n\n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No valid time slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_36"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, meeting_duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes  # Add 540 to convert back to 24-hour format\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n\n    # Initialize the free slots for the day (work hours)\n    free_slots = [(work_start, work_end)]\n\n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        blocked_slots = []\n        for block in schedule:\n            start, end = block.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            blocked_slots.append((start_min, end_min))\n        \n        # Sort blocked slots by start time\n        blocked_slots.sort()\n\n        # Update free_slots by subtracting blocked slots\n        new_free_slots = []\n        for free_start, free_end in free_slots:\n            current_start = free_start\n            for block_start, block_end in blocked_slots:\n                if block_start > current_start:\n                    new_free_slots.append((current_start, block_start))\n                current_start = max(current_start, block_end)\n            if current_start < free_end:\n                new_free_slots.append((current_start, free_end))\n        free_slots = new_free_slots\n\n    # Find the first slot that can fit the meeting\n    meeting_duration_min = meeting_duration * 60\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration_min:\n            meeting_end = slot_start + meeting_duration_min\n            return f\"{minutes_to_time(slot_start)}:{minutes_to_time(meeting_end)}\"\n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"11:00 to 11:30\", \"12:00 to 12:30\", \"15:30 to 16:30\"],  # Gregory\n    [],  # Teresa\n    [\"9:00 to 10:30\", \"11:00 to 16:00\", \"16:30 to 17:00\"],  # Carol\n]\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nmeeting_duration = 0.5  # in hours\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, meeting_duration))\n```",
            "count": "calendar_scheduling_example_37"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(schedules, duration, work_hours):\n    # Convert all time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start, work_end = map(time_to_minutes, work_hours.split(' to '))\n    \n    # Collect all busy intervals for each participant\n    busy_intervals = []\n    for person in schedules.values():\n        for interval in person:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Check for available slots between work hours and busy intervals\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            \n            meeting_start = minutes_to_time(slot_start)\n            meeting_end = minutes_to_time(slot_start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No available slot found\"\n\n# Define the schedules\nschedules = {\n    \"Catherine\": [\"10:30 to 11:00\", \"12:30 to 13:30\", \"14:30 to 15:00\"],\n    \"Michael\": [\"9:30 to 10:30\", \"12:00 to 13:00\", \"13:30 to 14:00\", \"15:00 to 15:30\"],\n    \"Alexander\": [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:00 to 12:00\", \"13:00 to 13:30\", \"14:00 to 16:00\", \"16:30 to 17:00\"]\n}\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_hours = \"9:00 to 17:00\"\n\n# Find and print the meeting time\nprint(find_meeting_time(schedules, duration, work_hours))\n```",
            "count": "calendar_scheduling_example_38"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration_minutes):\n    # Convert work hours and schedules to minutes for easier calculation\n    work_start, work_end = work_hours\n    work_start_min = work_start[0] * 60 + work_start[1]\n    work_end_min = work_end[0] * 60 + work_end[1]\n    \n    # Initialize the free slots for all participants within work hours\n    free_slots = []\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start = busy[0][0] * 60 + busy[0][1]\n            end = busy[1][0] * 60 + busy[1][1]\n            busy_slots.append((start, end))\n        \n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Generate free slots by finding gaps between busy slots and work hours\n        current_time = work_start_min\n        free = []\n        for busy_start, busy_end in busy_slots:\n            if busy_start > current_time:\n                free.append((current_time, busy_start))\n            current_time = max(current_time, busy_end)\n        if current_time < work_end_min:\n            free.append((current_time, work_end_min))\n        \n        free_slots.append(free)\n    \n    # Find overlapping free slots across all participants\n    common_free_slots = free_slots[0]\n    for participant_free in free_slots[1:]:\n        new_common = []\n        i = j = 0\n        while i < len(common_free_slots) and j < len(participant_free):\n            slot1 = common_free_slots[i]\n            slot2 = participant_free[j]\n            # Find the overlap between slot1 and slot2\n            overlap_start = max(slot1[0], slot2[0])\n            overlap_end = min(slot1[1], slot2[1])\n            if overlap_start < overlap_end:\n                new_common.append((overlap_start, overlap_end))\n            # Move the pointer which ends first\n            if slot1[1] < slot2[1]:\n                i += 1\n            else:\n                j += 1\n        common_free_slots = new_common\n    \n    # Find the earliest slot that can fit the meeting duration\n    for slot in common_free_slots:\n        start, end = slot\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return None\n\n# Define work hours (9:00 to 17:00)\nwork_hours = ((9, 0), (17, 0))\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Emily is free the entire day\n    [   # Victoria's busy slots\n        ((13, 30), (14, 0)),\n        ((14, 30), (15, 30)),\n        ((16, 30), (17, 0))\n    ],\n    [   # Nancy's busy slots\n        ((9, 0), (14, 0)),\n        ((14, 30), (15, 30))\n    ]\n]\n\n# Meeting duration is 30 minutes\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_39"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = map(time_to_minutes, work_hours.split(' to '))\n    duration_min = duration * 60\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        busy = []\n        for meeting in schedule:\n            start, end = map(time_to_minutes, meeting.split(' to '))\n            busy.append((start, end))\n        all_busy.append(busy)\n    \n    # Find all possible free slots for each participant\n    all_free_slots = []\n    for busy in all_busy:\n        free_slots = []\n        # Start from work start time\n        prev_end = work_start\n        for start, end in sorted(busy, key=lambda x: x[0]):\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        # Check the time after last meeting until work end\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        all_free_slots.append(free_slots)\n    \n    # Find overlapping free slots across all participants\n    common_free_slots = all_free_slots[0]\n    for free_slots in all_free_slots[1:]:\n        new_common_slots = []\n        i = j = 0\n        while i < len(common_free_slots) and j < len(free_slots):\n            start1, end1 = common_free_slots[i]\n            start2, end2 = free_slots[j]\n            # Find the overlap\n            overlap_start = max(start1, start2)\n            overlap_end = min(end1, end2)\n            if overlap_start < overlap_end:\n                new_common_slots.append((overlap_start, overlap_end))\n            # Move the pointer which ends first\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free_slots = new_common_slots\n    \n    # Find the first slot that can fit the duration\n    for start, end in common_free_slots:\n        if end - start >= duration_min:\n            meeting_end = start + duration_min\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\njacob_schedule = [\"10:00 to 11:00\", \"11:30 to 12:00\", \"16:00 to 16:30\"]\ngabriel_schedule = [\"9:30 to 11:30\", \"13:00 to 13:30\", \"15:00 to 15:30\"]\nmatthew_schedule = [\"9:00 to 9:30\", \"10:30 to 11:00\", \"11:30 to 12:00\", \"12:30 to 14:00\", \"15:30 to 16:30\"]\n\nparticipants_schedules = [jacob_schedule, gabriel_schedule, matthew_schedule]\nwork_hours = \"9:00 to 17:00\"\nmeeting_duration = 1  # in hours\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_40"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Alan's constraints: available after 14:30\n    alan_start = 14 * 60 + 30  # 14:30 in minutes\n    alan_end = work_end\n\n    # Nancy's busy times in minutes since midnight\n    nancy_busy = [\n        (11 * 60, 12 * 60 + 30),  # 11:00-12:30\n        (13 * 60, 13 * 60 + 30),  # 13:00-13:30\n        (14 * 60, 15 * 60)        # 14:00-15:00\n    ]\n\n    # Patricia's busy times in minutes since midnight\n    patricia_busy = [\n        (10 * 60, 12 * 60),       # 10:00-12:00\n        (12 * 60 + 30, 13 * 60),  # 12:30-13:00\n        (13 * 60 + 30, 16 * 60)   # 13:30-16:00\n    ]\n\n    # Combine all busy times for Nancy and Patricia\n    combined_busy = nancy_busy + patricia_busy\n    # Sort by start time\n    combined_busy.sort()\n\n    # Find potential slots after Alan's start time\n    potential_start = alan_start\n    for busy_start, busy_end in combined_busy:\n        if busy_start > potential_start:\n            # Check if the slot is long enough\n            if busy_start - potential_start >= meeting_duration:\n                # Found a valid slot\n                end_time = potential_start + meeting_duration\n                return f\"{potential_start // 60:02d}:{potential_start % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n        # Update potential_start to the end of the current busy period if it's later\n        if busy_end > potential_start:\n            potential_start = busy_end\n\n    # Check the slot after the last busy period\n    if work_end - potential_start >= meeting_duration:\n        end_time = potential_start + meeting_duration\n        return f\"{potential_start // 60:02d}:{potential_start % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n\n    # Default return (though the problem states a solution exists)\n    return \"No time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_41"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work_hours start at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = 9 + minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    start_min = time_to_minutes(work_hours[0])\n    end_min = time_to_minutes(work_hours[1])\n    duration_min = duration * 60\n\n    # Initialize a list to track busy intervals for all participants\n    busy_intervals = []\n\n    # Collect all busy intervals for each participant\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start = time_to_minutes(busy[0])\n            end = time_to_minutes(busy[1])\n            busy_intervals.append((start, end))\n\n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find the first available slot\n    prev_end = start_min\n    for start, end in merged:\n        if start - prev_end >= duration_min:\n            # Found a slot\n            meeting_start = prev_end\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n        prev_end = max(prev_end, end)\n\n    # Check after the last busy interval\n    if end_min - prev_end >= duration_min:\n        meeting_start = prev_end\n        meeting_end = meeting_start + duration_min\n        return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No available slot found\"\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration_hours = 1\n\n# Define participants' schedules\nparticipants_schedules = [\n    [(\"9:00\", \"9:30\"), (\"11:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:30\", \"14:00\"), (\"16:00\", \"17:00\")],  # Julie\n    [(\"9:00\", \"9:30\"), (\"13:00\", \"13:30\"), (\"15:00\", \"15:30\"), (\"16:00\", \"16:30\")],  # Sean\n    [(\"10:00\", \"10:30\"), (\"11:00\", \"13:00\"), (\"15:30\", \"17:00\")],  # Lori\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_42"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Convert each participant's meetings to minutes\n    albert_meetings = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    gregory_meetings = [\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    benjamin_meetings = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 13 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n\n    # Combine all meetings and blocked times\n    all_busy = []\n    for meeting in albert_meetings + gregory_meetings + benjamin_meetings:\n        all_busy.append(meeting)\n    all_busy.sort()\n\n    # Find the earliest available 30-minute slot\n    current_time = work_start\n    meeting_duration = 30\n\n    for busy_start, busy_end in all_busy:\n        if current_time + meeting_duration <= busy_start:\n            # Check if all participants are free during this slot\n            if (not is_busy(current_time, current_time + meeting_duration, albert_meetings) and\n                not is_busy(current_time, current_time + meeting_duration, gregory_meetings) and\n                not is_busy(current_time, current_time + meeting_duration, benjamin_meetings)):\n                # Format the time as HH:MM:HH:MM\n                start_hh = current_time // 60\n                start_mm = current_time % 60\n                end_hh = (current_time + meeting_duration) // 60\n                end_mm = (current_time + meeting_duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n        current_time = max(current_time, busy_end)\n\n    # Check after the last busy time\n    if current_time + meeting_duration <= work_end:\n        start_hh = current_time // 60\n        start_mm = current_time % 60\n        end_hh = (current_time + meeting_duration) // 60\n        end_mm = (current_time + meeting_duration) % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No available time found\"\n\ndef is_busy(start, end, meetings):\n    for busy_start, busy_end in meetings:\n        if not (end <= busy_start or start >= busy_end):\n            return True\n    return False\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_43"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each participant's busy slots to minutes\n    ronald_busy = [\n        (11 * 60 + 30, 12 * 60),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n    amanda_busy = [\n        (9 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    isabella_preference_end = 13 * 60  # Prefers not after 13:00\n\n    # Generate all possible 30-minute slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 1  # Check every minute for a slot\n\n    # Check each slot against constraints\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        # Check Isabella's preference (not after 13:00)\n        if slot_start >= isabella_preference_end:\n            continue\n        # Check Ronald's availability\n        ronald_available = True\n        for busy_start, busy_end in ronald_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                ronald_available = False\n                break\n        if not ronald_available:\n            continue\n        # Check Amanda's availability\n        amanda_available = True\n        for busy_start, busy_end in amanda_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                amanda_available = False\n                break\n        if not amanda_available:\n            continue\n        # If all checks passed, return this slot\n        return f\"{slot_start // 60:02d}:{slot_start % 60:02d}:{slot_end // 60:02d}:{slot_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_44"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert all time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = work_hours.split(' to ')\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participans_schedules.values():\n        for interval in schedule:\n            start, end = interval.split(' to ')\n            busy_intervals.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals during work hours\n    free_intervals = []\n    prev_end = work_start_min\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n    \n    # Check each free interval for availability of all participants\n    for start, end in free_intervals:\n        available_duration = end - start\n        if available_duration >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define the participants' schedules\nparticipants_schedules = {\n    \"Andrew\": [],\n    \"Grace\": [],\n    \"Samuel\": [\"9:00 to 10:30\", \"11:30 to 12:00\", \"13:00 to 13:30\", \"14:00 to 16:00\", \"16:30 to 17:00\"]\n}\n\n# Meeting duration in minutes (half an hour)\nduration = 30\n\n# Work hours\nwork_hours = \"9:00 to 17:00\"\n\n# Find the earliest available meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_45"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:30:12:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append(interval)\n    \n    # Find available slots by checking gaps between merged intervals and work hours\n    available_slots = []\n    previous_end = work_start\n    \n    for interval in merged:\n        current_start, current_end = interval\n        if current_start > previous_end:\n            available_slots.append((previous_end, current_start))\n        previous_end = max(previous_end, current_end)\n    \n    # Check the slot after the last busy interval\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Find the first available slot that can accommodate the meeting\n    for slot in available_slots:\n        start, end = slot\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return None\n\n# Define the participants' schedules\narthur_schedule = [\"09:30:10:00\", \"14:00:14:30\"]\ntheresa_schedule = [\"09:00:09:30\", \"12:00:13:00\", \"15:00:16:30\"]\ncarl_schedule = [\"09:00:11:30\", \"12:00:14:00\", \"14:30:17:00\"]\n\n# Combine all schedules\nparticipants_schedules = [arthur_schedule, theresa_schedule, carl_schedule]\n\n# Define work hours and meeting duration\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_46"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Parse work hours\n    work_start, work_end = work_hours.split(' to ')\n    work_start = int(work_start.split(':')[0]) * 60 + int(work_start.split(':')[1])\n    work_end = int(work_end.split(':')[0]) * 60 + int(work_end.split(':')[1])\n    \n    # Initialize busy slots for all participants\n    busy_slots = []\n    for schedule in participants_schedules:\n        person_busy = []\n        for meeting in schedule:\n            start, end = meeting.split(' to ')\n            start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n            end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n            person_busy.append((start_min, end_min))\n        busy_slots.append(person_busy)\n    \n    # Find all possible meeting slots\n    possible_slots = []\n    current_time = work_start\n    while current_time + duration <= work_end:\n        slot_valid = True\n        for person in busy_slots:\n            for meeting in person:\n                if not (current_time + duration <= meeting[0] or current_time >= meeting[1]):\n                    slot_valid = False\n                    break\n            if not slot_valid:\n                break\n        if slot_valid:\n            possible_slots.append((current_time, current_time + duration))\n        current_time += 15  # Check in 15-minute increments\n    \n    if not possible_slots:\n        return None\n    \n    # Return the first available slot\n    start, end = possible_slots[0]\n    start_h = start // 60\n    start_m = start % 60\n    end_h = end // 60\n    end_m = end % 60\n    return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n\n# Define participants' schedules\ndavid_schedule = []\neric_schedule = [\"9:00 to 9:30\", \"10:30 to 11:30\", \"15:00 to 15:30\"]\nroger_schedule = [\"9:30 to 10:30\", \"11:00 to 12:00\", \"12:30 to 13:00\", \"14:30 to 15:00\", \"15:30 to 16:30\"]\n\nparticipants_schedules = [david_schedule, eric_schedule, roger_schedule]\nwork_hours = \"9:00 to 17:00\"\nduration = 60  # minutes\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_47"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Convert each participant's busy slots to minutes\n    # Janet's busy slots: 9:30-10:30, 12:30-13:00, 14:00-14:30\n    janet_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60, 14 * 60 + 30)\n    ]\n    \n    # Rachel has no meetings\n    rachel_busy = []\n    \n    # Cynthia's busy slots: 9:30-10:00, 11:00-11:30, 12:30-14:30, 16:00-17:00\n    cynthia_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 14 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n    \n    # Cynthia's preference: not before 13:30\n    cynthia_preference_start = 13 * 60 + 30  # 13:30 in minutes\n\n    # Combine all busy slots\n    all_busy = []\n    for slot in janet_busy:\n        all_busy.append(('Janet', slot))\n    for slot in rachel_busy:\n        all_busy.append(('Rachel', slot))\n    for slot in cynthia_busy:\n        all_busy.append(('Cynthia', slot))\n    \n    # Sort all busy slots by start time\n    all_busy.sort(key=lambda x: x[1][0])\n\n    # Find potential meeting slots\n    potential_slots = []\n    previous_end = work_start\n\n    for _, (start, end) in all_busy:\n        if start > previous_end:\n            potential_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        potential_slots.append((previous_end, work_end))\n\n    # Filter slots that are long enough and meet Cynthia's preference\n    valid_slots = []\n    for slot in potential_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= meeting_duration and slot_start >= cynthia_preference_start:\n            valid_slots.append(slot)\n    \n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        print(f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\")\n    else:\n        print(\"No valid meeting time found.\")\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_48"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since midnight\n    teresa_busy = [\n        (9 * 60, 10 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    kathleen_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    patricia_busy = [\n        (9 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n\n    # Kathleen's preference: not after 14:30 (so before 14:30)\n    kathleen_preference_end = 14 * 60 + 30\n\n    # Generate all possible slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 1  # Check every minute\n\n    # Check each slot against everyone's schedule and preferences\n    for slot in possible_slots:\n        start, end = slot\n        # Check if the slot is before Kathleen's preference end time\n        if end > kathleen_preference_end:\n            continue\n        # Check Teresa's availability\n        teresa_available = True\n        for busy_start, busy_end in teresa_busy:\n            if not (end <= busy_start or start >= busy_end):\n                teresa_available = False\n                break\n        if not teresa_available:\n            continue\n        # Check Kathleen's availability\n        kathleen_available = True\n        for busy_start, busy_end in kathleen_busy:\n            if not (end <= busy_start or start >= busy_end):\n                kathleen_available = False\n                break\n        if not kathleen_available:\n            continue\n        # Check Patricia's availability\n        patricia_available = True\n        for busy_start, busy_end in patricia_busy:\n            if not (end <= busy_start or start >= busy_end):\n                patricia_available = False\n                break\n        if not patricia_available:\n            continue\n        # If all checks passed, return this slot\n        return f\"{start // 60:02d}:{start % 60:02d}:{end // 60:02d}:{end % 60:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_49"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:30:14:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(duration, work_start, work_end, schedules):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by looking at gaps between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start_min\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        available_slots.append((prev_end, work_end_min))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define the problem parameters\nduration = 1  # hours\nwork_start = \"09:00\"\nwork_end = \"17:00\"\n# Emma's schedule\nemma_schedule = [\"09:00:10:30\", \"11:00:12:00\", \"12:30:13:30\", \"14:30:15:30\", \"16:00:16:30\"]\n# Daniel and Roy have no meetings\ndaniel_schedule = []\nroy_schedule = []\nschedules = [daniel_schedule, roy_schedule, emma_schedule]\n\n# Find and print the meeting time\nprint(find_meeting_time(duration, work_start, work_end, schedules))\n```",
            "count": "calendar_scheduling_example_50"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work hours start at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = 9 + minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    # Initialize work hours in minutes\n    start_work = time_to_minutes(work_hours[0])\n    end_work = time_to_minutes(work_hours[1])\n\n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules.values():\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort intervals by start time\n    busy_intervals.sort()\n\n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = start_work\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < end_work:\n        free_intervals.append((prev_end, end_work))\n\n    # Find the first free interval that can fit the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"Brandon\": [\"11:30 to 12:00\", \"12:30 to 13:30\", \"14:00 to 14:30\"],\n    \"Donna\": [\"10:00 to 10:30\", \"12:00 to 12:30\"],\n    \"Jack\": [\"9:30 to 10:00\", \"10:30 to 11:00\", \"11:30 to 12:30\", \"13:00 to 14:30\", \"15:30 to 17:00\"]\n}\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 60  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_51"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Parse work hours\n    work_start, work_end = [int(time.split(':')[0]) + int(time.split(':')[1])/60 for time in work_hours.split(' to ')]\n    \n    # Initialize available slots as the entire work day\n    available_slots = [(work_start, work_end)]\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = [int(time.split(':')[0]) + int(time.split(':')[1])/60 for time in busy.split(' to ')]\n            busy_slots.append((start, end))\n        \n        # Merge overlapping busy slots\n        busy_slots.sort()\n        merged_busy = []\n        for busy in busy_slots:\n            if not merged_busy:\n                merged_busy.append(busy)\n            else:\n                last_start, last_end = merged_busy[-1]\n                current_start, current_end = busy\n                if current_start <= last_end:\n                    merged_busy[-1] = (last_start, max(last_end, current_end))\n                else:\n                    merged_busy.append(busy)\n        \n        # Subtract busy slots from available slots\n        new_available_slots = []\n        for avail_start, avail_end in available_slots:\n            current_start = avail_start\n            for busy_start, busy_end in merged_busy:\n                if busy_start > current_start and busy_start <= avail_end:\n                    new_available_slots.append((current_start, busy_start))\n                current_start = max(current_start, busy_end)\n            if current_start < avail_end:\n                new_available_slots.append((current_start, avail_end))\n        available_slots = new_available_slots\n    \n    # Find the first available slot that can fit the meeting\n    for slot in available_slots:\n        start, end = slot\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = int(meeting_start)\n            start_mm = int((meeting_start - start_hh) * 60)\n            end_hh = int(meeting_end)\n            end_mm = int((meeting_end - end_hh) * 60)\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No available slot found\"\n\n# Define participants' schedules\ngrace_schedule = [\n    \"9:00 to 9:30\",\n    \"10:00 to 11:00\",\n    \"16:00 to 16:30\"\n]\nrandy_schedule = [\n    \"12:30 to 13:00\",\n    \"16:00 to 16:30\"\n]\nsusan_schedule = [\n    \"9:00 to 14:30\",\n    \"15:30 to 16:00\"\n]\n\n# Define meeting constraints\nwork_hours = \"9:00 to 17:00\"\nduration = 1.0  # 1 hour\n\n# Find meeting time\nmeeting_time = find_meeting_time([grace_schedule, randy_schedule, susan_schedule], work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_52"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:30:16:30}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert all time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 9:00 (0 minutes)\n    \n    # Convert work hours to minutes\n    work_start, work_end = map(time_to_minutes, work_hours.split('-'))\n    \n    # Generate busy intervals in minutes for each participant\n    busy_intervals = []\n    for busy_slots in participents_busy.values():\n        participant_intervals = []\n        for slot in busy_slots:\n            start, end = map(time_to_minutes, slot.split('-'))\n            participant_intervals.append((start, end))\n        busy_intervals.append(participant_intervals)\n    \n    # Find all busy intervals for all participants\n    all_busy = []\n    for intervals in busy_intervals:\n        all_busy.extend(intervals)\n    all_busy.sort()\n    \n    # Merge overlapping busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append([start, end])\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1][1] = max(last_end, end)\n            else:\n                merged.append([start, end])\n    \n    # Find available slots\n    available = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n    \n    # Check for a slot that fits the duration\n    duration_min = duration * 60\n    for start, end in available:\n        if end - start >= duration_min:\n            # Convert back to HH:MM format\n            start_hh = (start + 540) // 60\n            start_mm = (start + 540) % 60\n            end_hh = (start + 540 + duration_min) // 60\n            end_mm = (start + 540 + duration_min) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}-{end_hh:02d}:{end_mm:02d}\"\n    return \"No available slot found\"\n\n# Define the participants' busy times\nparticipants_busy = {\n    \"Alice\": [\"9:30-10:00\", \"12:30-13:00\", \"14:30-15:00\", \"16:30-17:00\"],\n    \"Arthur\": [\"9:00-9:30\", \"10:00-11:00\", \"11:30-12:00\", \"13:00-14:00\", \"15:00-15:30\", \"16:30-17:00\"],\n    \"Noah\": []\n}\n\n# Define work hours and meeting duration\nwork_hours = \"9:00-17:00\"\nduration = 1  # in hours\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_53"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Convert blocked times to minutes since midnight\n    isabella_blocked = [(11 * 60, 11 * 60 + 30), (15 * 60 + 30, 16 * 60)]\n    tyler_blocked = [(9 * 60, 10 * 60)]\n    jordan_blocked = [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60), \n                      (12 * 60 + 30, 13 * 60 + 30), (14 * 60, 14 * 60 + 30),\n                      (15 * 60, 16 * 60)]\n\n    # Tyler cannot meet after 16:00\n    tyler_no_meet_after = 16 * 60\n\n    # Combine all blocked times for each participant\n    blocked_times = {\n        'Isabella': isabella_blocked,\n        'Tyler': tyler_blocked,\n        'Jordan': jordan_blocked\n    }\n\n    # Find all possible 1-hour slots that work for everyone\n    possible_slots = []\n    current_time = work_start\n    meeting_duration = 60  # 1 hour\n\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        slot_valid = True\n\n        # Check Isabella's availability\n        for start, end in blocked_times['Isabella']:\n            if not (slot_end <= start or current_time >= end):\n                slot_valid = False\n                break\n        if not slot_valid:\n            current_time += 15  # Check next 15-minute interval\n            continue\n\n        # Check Tyler's availability\n        for start, end in blocked_times['Tyler']:\n            if not (slot_end <= start or current_time >= end):\n                slot_valid = False\n                break\n        if not slot_valid:\n            current_time += 15\n            continue\n        if slot_end > tyler_no_meet_after:\n            slot_valid = False\n        if not slot_valid:\n            current_time += 15\n            continue\n\n        # Check Jordan's availability\n        for start, end in blocked_times['Jordan']:\n            if not (slot_end <= start or current_time >= end):\n                slot_valid = False\n                break\n        if not slot_valid:\n            current_time += 15\n            continue\n\n        if slot_valid:\n            possible_slots.append((current_time, slot_end))\n            break  # Return the first valid slot found\n\n        current_time += 15\n\n    if possible_slots:\n        start, end = possible_slots[0]\n        # Convert minutes back to HH:MM format\n        start_hh = start // 60\n        start_mm = start % 60\n        end_hh = end // 60\n        end_mm = end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_54"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability across all participants\n    # Since all participants' busy intervals are merged, any free interval is common\n    for start, end in free_intervals:\n        if end - start >= duration * 60:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration * 60)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"14:00 to 14:30\", \"16:00 to 16:30\"],  # Keith\n    [],                                    # Christine\n    [\"09:00 to 10:30\", \"11:30 to 17:00\"]   # Cynthia\n]\n\n# Define work hours and meeting duration\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 1  # in hours\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration))\n```",
            "count": "calendar_scheduling_example_55"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = (minutes + 540) // 60\n        mm = (minutes + 540) % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    # Parse work hours\n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n\n    # Initialize busy slots for all participants\n    busy_slots = []\n    for schedule in participants_schedules:\n        person_busy = []\n        for slot in schedule:\n            start, end = slot.split(' to ')\n            person_busy.append((time_to_minutes(start), time_to_minutes(end)))\n        busy_slots.append(person_busy)\n\n    # Find all possible slots\n    possible_slots = []\n    current_time = work_start\n    while current_time + duration <= work_end:\n        slot_valid = True\n        for person in busy_slots:\n            for busy_start, busy_end in person:\n                if not (current_time + duration <= busy_start or current_time >= busy_end):\n                    slot_valid = False\n                    break\n            if not slot_valid:\n                break\n        if slot_valid:\n            possible_slots.append((current_time, current_time + duration))\n        current_time += 15  # Check every 15 minutes\n\n    if not possible_slots:\n        return None\n\n    # Return the first available slot\n    start, end = possible_slots[0]\n    return f\"{minutes_to_time(start)}:{minutes_to_time(end)}\"\n\n# Define the problem\nparticipants_schedules = [\n    [\"12:00 to 13:00\", \"13:30 to 14:00\", \"15:00 to 15:30\"],  # Jeremy\n    [\"09:30 to 10:00\", \"13:00 to 13:30\", \"16:00 to 17:00\"],  # Donna\n    [\"09:00 to 11:00\", \"11:30 to 12:00\", \"12:30 to 17:00\"],  # Robert\n]\nwork_hours = \"09:00 to 17:00\"\nduration = 30  # minutes\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_56"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define each participant's busy times in minutes (start, end)\n    virginia_busy = [(10 * 60, 12 * 60)]\n    charles_busy = [(12 * 60, 12 * 30), (13 * 60, 13 * 30)]\n    megan_busy = [(9 * 60, 12 * 60), (13 * 30, 16 * 60), (16 * 30, 17 * 60)]\n    \n    # Charles' preference: avoid before 14:30\n    charles_preference_start = 14 * 60 + 30\n    \n    # Combine all busy times and sort\n    all_busy = virginia_busy + charles_busy + megan_busy\n    all_busy.sort()\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Check for a 30-minute slot that fits Charles' preference\n    meeting_duration = 30\n    for slot_start, slot_end in available_slots:\n        # Adjust slot_start to meet Charles' preference\n        adjusted_start = max(slot_start, charles_preference_start)\n        if adjusted_start + meeting_duration <= slot_end:\n            # Format the time as HH:MM:HH:MM\n            start_hh = adjusted_start // 60\n            start_mm = adjusted_start % 60\n            end_hh = (adjusted_start + meeting_duration) // 60\n            end_mm = (adjusted_start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_57"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for meeting in schedule:\n            start, end = map(time_to_minutes, meeting.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability for all participants\n    for interval in free_intervals:\n        start, end = interval\n        available_duration = end - start\n        if available_duration >= duration_minutes:\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration_minutes)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\njoan_schedule = [\"11:00 to 11:30\", \"12:30 to 13:00\"]\ntheresa_schedule = [\"12:00 to 12:30\", \"15:00 to 15:30\"]\nshirley_schedule = [\"9:30 to 10:30\", \"11:00 to 12:00\", \"13:00 to 14:00\", \"15:30 to 16:30\"]\n\nparticipants_schedules = [joan_schedule, theresa_schedule, shirley_schedule]\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 60  # 1 hour\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes))\n```",
            "count": "calendar_scheduling_example_58"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Jeffrey's constraints: available after 14:00\n    jeffrey_free = [(14 * 60, work_end)]\n\n    # Jack's busy times in minutes\n    jack_busy = [\n        (10 * 60 + 30, 11 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n    # Calculate Jack's free times\n    jack_free = []\n    prev_end = work_start\n    for start, end in sorted(jack_busy):\n        if start > prev_end:\n            jack_free.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        jack_free.append((prev_end, work_end))\n\n    # Judith's busy times in minutes\n    judith_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    # Calculate Judith's free times\n    judith_free = []\n    prev_end = work_start\n    for start, end in sorted(judith_busy):\n        if start > prev_end:\n            judith_free.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        judith_free.append((prev_end, work_end))\n\n    # Find overlapping free times for all three\n    meeting_duration = 30\n    possible_slots = []\n\n    # Iterate through Jeffrey's free times (only after 14:00)\n    for jf_start, jf_end in jeffrey_free:\n        # Iterate through Jack's free times\n        for jk_start, jk_end in jack_free:\n            # Find overlap between Jeffrey and Jack\n            overlap_start = max(jf_start, jk_start)\n            overlap_end = min(jf_end, jk_end)\n            if overlap_start >= overlap_end:\n                continue\n            # Iterate through Judith's free times\n            for ju_start, ju_end in judith_free:\n                # Find overlap with Judith\n                final_start = max(overlap_start, ju_start)\n                final_end = min(overlap_end, ju_end)\n                if final_start >= final_end:\n                    continue\n                # Check if there's enough time for the meeting\n                if final_end - final_start >= meeting_duration:\n                    possible_slots.append((final_start, final_start + meeting_duration))\n\n    # Select the earliest possible slot\n    if possible_slots:\n        best_slot = min(possible_slots)\n        start_h, start_m = divmod(best_slot[0], 60)\n        end_h, end_m = divmod(best_slot[1], 60)\n        print(f\"{int(start_h):02d}:{int(start_m):02d}:{int(end_h):02d}:{int(end_m):02d}\")\n    else:\n        print(\"No suitable time found.\")\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_59"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes\n    lisa_busy = [\n        (10 * 60 + 30, 11 * 60),    # 10:30-11:00\n        (11 * 60 + 30, 12 * 60),    # 11:30-12:00\n        (14 * 60, 15 * 60)          # 14:00-15:00\n    ]\n    raymond_busy = [\n        (9 * 60, 10 * 60),          # 9:00-10:00\n        (10 * 60 + 30, 11 * 60),    # 10:30-11:00\n        (11 * 60 + 30, 15 * 60),    # 11:30-15:00\n        (16 * 60, 17 * 60)          # 16:00-17:00\n    ]\n    # Dorothy is free all day but prefers no meetings after 10:30\n    dorothy_preference_end = 10 * 60 + 30  # 10:30\n\n    # Combine all busy slots\n    all_busy = lisa_busy + raymond_busy\n    # Sort by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check after last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Now check Dorothy's preference (no meetings after 10:30)\n    # So we only consider slots that start and end before or at 10:30\n    valid_slots = []\n    for start, end in free_slots:\n        slot_end = start + meeting_duration\n        if slot_end <= dorothy_preference_end and slot_end <= end:\n            valid_slots.append((start, slot_end))\n\n    # Select the first valid slot\n    if valid_slots:\n        meeting_start, meeting_end = valid_slots[0]\n    else:\n        return \"No valid time found\"\n\n    # Convert back to HH:MM format\n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n\n    start_time = minutes_to_time(meeting_start)\n    end_time = minutes_to_time(meeting_end)\n    return f\"{start_time}:{end_time}\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_60"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:30:14:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start, work_end = map(time_to_minutes, work_hours)\n    busy_slots = []\n    \n    for person in participants_busy:\n        for slot in participants_busy[person]:\n            start, end = map(time_to_minutes, slot)\n            busy_slots.append((start, end))\n    \n    # Sort all busy slots by start time\n    busy_slots.sort()\n    \n    # Find all free slots by merging busy intervals\n    merged_busy = []\n    for start, end in busy_slots:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Check the time before the first busy slot\n    if merged_busy:\n        first_busy_start, _ = merged_busy[0]\n        if first_busy_start - work_start >= duration:\n            return (work_start, work_start + duration)\n    \n    # Check the time between busy slots\n    for i in range(1, len(merged_busy)):\n        prev_end = merged_busy[i-1][1]\n        curr_start = merged_busy[i][0]\n        if curr_start - prev_end >= duration:\n            return (prev_end, prev_end + duration)\n    \n    # Check the time after the last busy slot\n    if merged_busy:\n        last_busy_end = merged_busy[-1][1]\n        if work_end - last_busy_end >= duration:\n            return (last_busy_end, last_busy_end + duration)\n    else:\n        # No busy slots, the entire work hours are free\n        return (work_start, work_start + duration)\n    \n    return None\n\ndef minutes_to_time(minutes):\n    hh = minutes // 60\n    mm = minutes % 60\n    return f\"{hh:02d}:{mm:02d}\"\n\n# Define participants' busy times\nparticipants_busy = {\n    'Robert': [],\n    'Lisa': ['9:30-10:00', '11:30-12:00'],\n    'Patrick': ['9:30-11:30', '12:30-13:30', '16:00-17:00'],\n}\n\n# Define work hours and meeting duration\nwork_hours = ('9:00', '17:00')\nduration_minutes = 60\n\n# Find a meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration_minutes)\n\nif meeting_time:\n    start, end = meeting_time\n    start_time = minutes_to_time(start)\n    end_time = minutes_to_time(end)\n    print(f\"{start_time}:{end_time}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_61"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(schedules, work_hours, duration):\n    start_work, end_work = work_hours\n    # Convert all times to minutes since midnight for easier calculation\n    work_start = start_work[0] * 60 + start_work[1]\n    work_end = end_work[0] * 60 + end_work[1]\n    \n    # Initialize the list of busy intervals\n    busy_intervals = []\n    \n    for schedule in schedules:\n        for interval in schedule:\n            start = interval[0][0] * 60 + interval[0][1]\n            end = interval[1][0] * 60 + interval[1][1]\n            busy_intervals.append((start, end))\n    \n    # Sort the busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find the free intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability\n    for start, end in free_intervals:\n        if end - start >= duration * 60:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = (start + duration * 60) // 60\n            end_mm = (start + duration * 60) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time slot found\"\n\n# Define the schedules\nabigail_schedule = []\nmichael_schedule = []\nsharon_schedule = [\n    ((9, 0), (13, 0)),\n    ((14, 0), (17, 0))\n]\n\nschedules = [abigail_schedule, michael_schedule, sharon_schedule]\nwork_hours = ((9, 0), (17, 0))\nduration = 1  # 1 hour\n\n# Find the meeting time\nmeeting_time = find_meeting_time(schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_62"
        },
        {
            "final_program_time": "{16:00:17:00}",
            "expected_time": "{16:00:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_work, end_work = work_hours\n    # Convert all times to minutes since midnight for easier calculation\n    start_min = start_work[0] * 60 + start_work[1]\n    end_min = end_work[0] * 60 + end_work[1]\n    \n    # Generate all possible slots within work hours\n    possible_slots = []\n    current_start = start_min\n    while current_start + duration <= end_min:\n        possible_slots.append((current_start, current_start + duration))\n        current_start += 30  # Check in 30-minute increments\n    \n    # Check each slot against all participants' schedules\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        valid = True\n        for schedule in participants_schedules:\n            for busy_start, busy_end in schedule:\n                busy_start_min = busy_start[0] * 60 + busy_start[1]\n                busy_end_min = busy_end[0] * 60 + busy_end[1]\n                # Check if slot overlaps with any busy period\n                if not (slot_end <= busy_start_min or slot_start >= busy_end_min):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            # Convert back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No valid slot found\"\n\n# Define work hours and meeting duration\nwork_hours = ((9, 0), (17, 0))  # 9:00 to 17:00\nduration = 60  # 1 hour in minutes\n\n# Define participants' schedules in (HH, MM) format\nmadison_schedule = []\njudith_schedule = [((10, 0), (10, 30)), ((11, 0), (12, 0)), ((12, 30), (13, 0))]\nroger_schedule = [((9, 0), (9, 30)), ((10, 30), (11, 0)), ((12, 0), (12, 30)), ((13, 0), (13, 30)), ((14, 0), (16, 0))]\n\nparticipants_schedules = [madison_schedule, judith_schedule, roger_schedule]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_63"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_work, end_work = work_hours\n    busy_slots = []\n    \n    # Collect all busy slots\n    for schedule in participants_schedules.values():\n        busy_slots.extend(schedule)\n    \n    # Sort busy slots by start time\n    busy_slots.sort()\n    \n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = start_work\n    \n    for start, end in busy_slots:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < end_work:\n        free_slots.append((previous_end, end_work))\n    \n    # Check each free slot for availability in all participants' schedules\n    for slot_start, slot_end in free_slots:\n        slot_duration = (slot_end - slot_start).total_seconds() / 3600\n        if slot_duration >= duration:\n            # Check if all participants are free during this slot\n            all_free = True\n            for schedule in participants_schedules.values():\n                for busy_start, busy_end in schedule:\n                    if busy_start < slot_end and busy_end > slot_start:\n                        all_free = False\n                        break\n                if not all_free:\n                    break\n            if all_free:\n                return slot_start, slot_start + timedelta(hours=duration)\n    \n    return None\n\n# Define work hours and meeting duration\nfrom datetime import datetime, timedelta\n\nwork_hours = (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))\nduration = 1  # hours\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"Nancy\": [\n        (datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n        (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\"))\n    ],\n    \"Albert\": [],\n    \"Nathan\": [\n        (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n        (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\")),\n        (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))\n    ]\n}\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\n\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{start.strftime('%H:%M')}:{end.strftime('%H:%M')}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_64"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define busy intervals in minutes since midnight\n    john_busy = [\n        (12 * 60 + 30, 13 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    andrea_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (11 * 60, 12 * 60 + 30),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    lisa_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (12 * 60, 12 * 60 + 30),\n        (14 * 60, 15 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    # Andrea cannot meet after 16:30\n    andrea_cutoff = 16 * 60 + 30\n    \n    # Meeting duration is 30 minutes\n    duration = 30\n    \n    # Generate all possible slots within work hours\n    for start in range(work_start, work_end - duration + 1, 15):  # Check every 15 minutes\n        end = start + duration\n        # Check if the slot is within Andrea's cutoff\n        if end > andrea_cutoff:\n            continue\n        # Check John's availability\n        john_available = True\n        for busy_start, busy_end in john_busy:\n            if not (end <= busy_start or start >= busy_end):\n                john_available = False\n                break\n        if not john_available:\n            continue\n        # Check Andrea's availability\n        andrea_available = True\n        for busy_start, busy_end in andrea_busy:\n            if not (end <= busy_start or start >= busy_end):\n                andrea_available = False\n                break\n        if not andrea_available:\n            continue\n        # Check Lisa's availability\n        lisa_available = True\n        for busy_start, busy_end in lisa_busy:\n            if not (end <= busy_start or start >= busy_end):\n                lisa_available = False\n                break\n        if lisa_available:\n            # Convert start and end back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = end // 60\n            end_mm = end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_65"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(schedules, duration, work_start, work_end):\n    # Convert all time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n    \n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Initialize the merged busy intervals\n    busy_intervals = []\n    for person, intervals in schedules.items():\n        for start, end in intervals:\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            busy_intervals.append((start_min, end_min))\n    \n    # Sort the intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                new_end = max(last_end, current_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append(interval)\n    \n    # Find the available slots\n    available = []\n    prev_end = 0\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        available.append((prev_end, work_end_min))\n    \n    # Check for a slot that can fit the duration\n    for start, end in available:\n        if end - start >= duration:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No available time slot found\"\n\n# Define the schedules\nschedules = {\n    \"Ronald\": [],\n    \"Maria\": [],\n    \"Charles\": [(\"9:00\", \"10:30\"), (\"11:00\", \"11:30\"), (\"13:30\", \"14:00\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:30\")]\n}\n\n# Define meeting parameters\nduration = 60  # 1 hour in minutes\nwork_start = \"9:00\"\nwork_end = \"17:00\"\n\n# Find and print the meeting time\nprint(find_meeting_time(schedules, duration, work_start, work_end))\n```",
            "count": "calendar_scheduling_example_66"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define busy intervals in minutes since midnight\n    jacqueline_busy = [\n        (13 * 60, 13 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    linda_busy = [\n        (9 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60 + 30, 16 * 60 + 30)\n    ]\n    # Linda cannot meet after 14:00\n    linda_no_meet_after = 14 * 60\n    \n    # Duration of the meeting in minutes\n    duration = 30\n    \n    # Generate all possible slots within work hours\n    possible_slots = []\n    current_time = work_start\n    \n    while current_time + duration <= work_end:\n        slot_end = current_time + duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 30  # Check every 30 minutes for efficiency\n    \n    # Check each slot against everyone's constraints\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        \n        # Check Jacqueline's availability\n        jacqueline_available = True\n        for busy_start, busy_end in jacqueline_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                jacqueline_available = False\n                break\n        if not jacqueline_available:\n            continue\n        \n        # Check Linda's availability and constraints\n        linda_available = True\n        for busy_start, busy_end in linda_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                linda_available = False\n                break\n        # Check if slot is after Linda's no-meet time\n        if slot_start >= linda_no_meet_after:\n            linda_available = False\n        if not linda_available:\n            continue\n        \n        # Christian is free all day, so no need to check\n        \n        # If we reach here, the slot is good for everyone\n        # Convert minutes back to HH:MM format\n        start_hh = slot_start // 60\n        start_mm = slot_start % 60\n        end_hh = slot_end // 60\n        end_mm = slot_end % 60\n        \n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_67"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration_minutes):\n    # Convert work hours and schedules to minutes since start of day\n    work_start, work_end = work_hours\n    work_start_min = work_start[0] * 60 + work_start[1]\n    work_end_min = work_end[0] * 60 + work_end[1]\n    \n    # Generate all possible time slots within work hours\n    possible_slots = []\n    current_time = work_start_min\n    while current_time + duration_minutes <= work_end_min:\n        possible_slots.append((current_time, current_time + duration_minutes))\n        current_time += 1  # Check every minute\n    \n    # Check each slot against all participants' schedules\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        valid = True\n        for schedule in participants_schedules:\n            for busy_start, busy_end in schedule:\n                busy_start_min = busy_start[0] * 60 + busy_start[1]\n                busy_end_min = busy_end[0] * 60 + busy_end[1]\n                # Check if slot overlaps with any busy period\n                if not (slot_end <= busy_start_min or slot_start >= busy_end_min):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            # Convert back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No available slot found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours = ((9, 0), (17, 0))\n\n# Define participants' schedules in HH:MM format\nmichael_schedule = [\n    ((10, 0), (10, 30)),\n    ((11, 30), (12, 0)),\n    ((13, 30), (14, 0)),\n    ((15, 30), (16, 0))\n]\nbryan_schedule = []\nlauren_schedule = [\n    ((9, 0), (10, 30)),\n    ((14, 30), (17, 0))\n]\n\nparticipants_schedules = [michael_schedule, bryan_schedule, lauren_schedule]\n\n# Find the earliest available 30-minute slot\nmeeting_time = find_meeting_time(participants_schedules, work_hours, 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_68"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:00:11:00}",
            "type_error": "SyntaxError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find the earliest available slot\n    prev_end = work_start\n    for busy_start, busy_end in all_busy:\n        if busy_start > prev_end:\n            available_start = prev_end\n            available_end = busy_start\n            if available_end - available_start >= duration:\n                return (minutes_to_time(available_start), (minutes_to_time(available_start + duration))\n        prev_end = max(prev_end, busy_end)\n    \n    # Check the slot after the last busy interval\n    if work_end - prev_end >= duration:\n        return (minutes_to_time(prev_end), (minutes_to_time(prev_end + duration)))\n    \n    return None\n\n# Define the schedules\nshirley_schedule = [\"11:00 to 11:30\", \"14:00 to 15:00\", \"16:00 to 16:30\"]\nstephen_schedule = [\"13:00 to 13:30\", \"15:30 to 16:00\"]\npaul_schedule = [\"9:00 to 10:00\", \"11:00 to 17:00\"]\n\nparticipants_schedules = [shirley_schedule, stephen_schedule, paul_schedule]\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration = 60  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration)\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{start}:{end}\")\nelse:\n    print(\"No available time slot found.\")\n```",
            "count": "calendar_scheduling_example_69"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration_minutes):\n    # Convert work hours and schedules to minutes since 9:00 (540 minutes)\n    work_start = 9 * 60\n    work_end = 17 * 60\n    duration = duration_minutes\n    \n    # Initialize a list to hold all busy intervals in minutes\n    busy_intervals = []\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start_h, start_m = map(int, busy.split(' to ')[0].split(':'))\n            end_h, end_m = map(int, busy.split(' to ')[1].split(':'))\n            start = start_h * 60 + start_m\n            end = end_h * 60 + end_m\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find the earliest available slot\n    prev_end = work_start\n    for start, end in merged:\n        if start - prev_end >= duration:\n            meeting_start = prev_end\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n        prev_end = max(prev_end, end)\n    \n    # Check after the last busy interval\n    if work_end - prev_end >= duration:\n        meeting_start = prev_end\n        meeting_end = meeting_start + duration\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\ndenise_schedule = [\"12:00 to 12:30\", \"15:30 to 16:00\"]\nangela_schedule = []\nnatalie_schedule = [\"9:00 to 11:30\", \"12:00 to 13:00\", \"14:00 to 14:30\", \"15:00 to 17:00\"]\n\nparticipants_schedules = [denise_schedule, angela_schedule, natalie_schedule]\nwork_hours = (\"9:00\", \"17:00\")\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_70"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define blocked times in minutes since midnight\n    john_blocked = [(12 * 60 + 30, 13 * 60), (16 * 60 + 30, 17 * 60)]\n    ethan_blocked = [(9 * 60, 10 * 60), (11 * 60 + 30, 14 * 60), (14 * 60 + 30, 17 * 60)]\n\n    # John's preference: not after 12:00\n    john_preference_end = 12 * 60\n\n    # Meeting duration in minutes\n    meeting_duration = 30\n\n    # Generate possible time slots\n    possible_slots = []\n    current_start = work_start\n\n    while current_start + meeting_duration <= work_end:\n        current_end = current_start + meeting_duration\n        # Check if the slot fits everyone's constraints\n        john_ok = True\n        for block_start, block_end in john_blocked:\n            if not (current_end <= block_start or current_start >= block_end):\n                john_ok = False\n                break\n        ethan_ok = True\n        for block_start, block_end in ethan_blocked:\n            if not (current_end <= block_start or current_start >= block_end):\n                ethan_ok = False\n                break\n        # Check John's preference\n        if john_ok and ethan_ok and current_end <= john_preference_end:\n            possible_slots.append((current_start, current_end))\n        current_start += 15  # Check every 15 minutes\n\n    if possible_slots:\n        # Select the earliest possible slot\n        meeting_start, meeting_end = possible_slots[0]\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_71"
        },
        {
            "final_program_time": "{13:30:14:30}",
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy)\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals_sorted = sorted(busy_intervals, key=lambda x: x[0])\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals_sorted:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    previous_end = work_start\n    for start, end in merged:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Find the first available slot that can fit the meeting duration\n    duration_minutes = duration * 60\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules\nmason_schedule = []  # No meetings\namy_schedule = [(\"09:30\", \"11:30\"), (\"13:00\", \"13:30\"), (\"16:30\", \"17:00\")]\nchristopher_schedule = [(\"09:00\", \"10:00\"), (\"12:00\", \"13:30\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:30\")]\n\nparticipants_schedules = [mason_schedule, amy_schedule, christopher_schedule]\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 1  # in hours\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules=participants_schedules, \n                       work_hours_start=work_hours_start, \n                       work_hours_end=work_hours_end, \n                       duration=meeting_duration))\n```",
            "count": "calendar_scheduling_example_72"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration):\n    # Convert all time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    all_busy_intervals = []\n    for busy_times in participants_busy_times:\n        for interval in busy_times:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            all_busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_intervals = []\n    for start, end in all_busy_intervals:\n        if not merged_intervals:\n            merged_intervals.append([start, end])\n        else:\n            last_start, last_end = merged_intervals[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                merged_intervals[-1][1] = max(end, last_end)\n            else:\n                merged_intervals.append([start, end])\n    \n    # Find available slots by checking gaps between merged intervals and work hours\n    available_slots = []\n    previous_end = work_start\n    for start, end in merged_intervals:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Check each available slot for sufficient duration\n    meeting_duration_min = meeting_duration * 60\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define the participants' busy times\nbradley_busy = [\"9:30 to 10:00\", \"13:00 to 13:30\", \"14:30 to 15:00\", \"16:30 to 17:00\"]\nandrew_busy = [\"9:00 to 9:30\", \"12:30 to 13:30\", \"14:00 to 14:30\", \"15:00 to 16:00\"]\nmelissa_busy = [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:00 to 14:00\", \"15:00 to 15:30\", \"16:00 to 16:30\"]\n\nparticipants_busy_times = [bradley_busy, andrew_busy, melissa_busy]\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 0.5  # in hours\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_73"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    duration = 60         # 1 hour in minutes\n\n    # Convert each person's busy times to minutes since 9:00\n    # Eric's busy times: 10:00-12:00\n    eric_busy = [(10 * 60, 12 * 60)]\n    # Albert's busy times: 12:00-12:30, 15:30-16:00\n    albert_busy = [(12 * 60, 12 * 60 + 30), (15 * 60 + 30, 16 * 60)]\n    # Katherine's busy times: 10:00-11:00, 11:30-14:00, 15:00-15:30\n    katherine_busy = [(10 * 60, 11 * 60), (11 * 60 + 30, 14 * 60), (15 * 60, 15 * 60 + 30)]\n\n    # Eric's constraint: no meetings after 15:30\n    eric_constraint = 15 * 60 + 30\n\n    # Combine all busy times and sort them\n    all_busy = eric_busy + albert_busy + katherine_busy\n    all_busy.sort()\n\n    # Find the earliest available slot\n    previous_end = work_start\n    for start, end in all_busy:\n        if start > previous_end:\n            # Check if the slot is long enough and before Eric's constraint\n            if (start - previous_end) >= duration and (previous_end + duration) <= eric_constraint:\n                # Convert back to HH:MM format\n                start_hh = previous_end // 60\n                start_mm = previous_end % 60\n                end_hh = (previous_end + duration) // 60\n                end_mm = (previous_end + duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n        previous_end = max(previous_end, end)\n\n    # Check after the last busy slot\n    if (work_end - previous_end) >= duration and (previous_end + duration) <= eric_constraint:\n        start_hh = previous_end // 60\n        start_mm = previous_end % 60\n        end_hh = (previous_end + duration) // 60\n        end_mm = (previous_end + duration) % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_74"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:14:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration_hours):\n    # Convert all times to minutes since midnight for easier calculation\n    start_min = work_hours_start * 60\n    end_min = work_hours_end * 60\n    duration_min = duration_hours * 60\n\n    # Initialize a list to keep track of all busy intervals\n    busy_intervals = []\n\n    # Collect all busy intervals from each participant\n    for person in participants_busy_times.values():\n        for interval in person:\n            start = interval[0] * 60\n            end = interval[1] * 60\n            busy_intervals.append((start, end))\n\n    # Sort the busy intervals by start time\n    busy_intervals_sorted = sorted(busy_intervals, key=lambda x: x[0])\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for interval in busy_intervals_sorted:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append(interval)\n\n    # Find available slots by checking gaps between merged intervals\n    available_slots = []\n    previous_end = start_min\n\n    for interval in merged:\n        current_start, current_end = interval\n        if current_start > previous_end:\n            available_slots.append((previous_end, current_start))\n        previous_end = max(previous_end, current_end)\n\n    # Check the slot after the last busy interval\n    if previous_end < end_min:\n        available_slots.append((previous_end, end_min))\n\n    # Find the first available slot that can fit the meeting duration\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No available slot found\"\n\n# Define the participants' busy times\nparticipants_busy_times = {\n    \"Jacob\": [(9.0, 9.5), (12.5, 13.0), (14.5, 15.0), (16.5, 17.0)],\n    \"Amanda\": [(10.0, 10.5), (12.0, 12.5)],\n    \"Lisa\": [(11.0, 13.0), (14.5, 16.5)]\n}\n\n# Define work hours and meeting duration\nwork_hours_start = 9.0\nwork_hours_end = 17.0\nduration_hours = 1.0\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_75"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    \"\"\"\n    Find a meeting time that fits all participants' schedules within work hours.\n    \n    Args:\n        participants_schedules: List of lists of busy intervals for each participant.\n        work_hours: Tuple (start, end) of the working day in HH:MM format.\n        duration: Duration of the meeting in minutes.\n    \n    Returns:\n        A string representing the proposed meeting time in HH:MM:HH:MM format.\n    \"\"\"\n    # Convert work hours and busy intervals to minutes since midnight for easier calculation\n    work_start = convert_to_minutes(work_hours[0])\n    work_end = convert_to_minutes(work_hours[1])\n    \n    # Collect all busy intervals from all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start = convert_to_minutes(interval[0])\n            end = convert_to_minutes(interval[1])\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots between work hours and busy intervals\n    available = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting duration\n    for slot in available:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return (f\"{convert_to_hhmm(meeting_start)}:{convert_to_hhmm(meeting_end)}\")\n    \n    return \"No available time slot found\"\n\ndef convert_to_minutes(time_str):\n    \"\"\"Convert HH:MM time string to minutes since midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(':'))\n    return hours * 60 + minutes\n\ndef convert_to_hhmm(minutes):\n    \"\"\"Convert minutes since midnight to HH:MM format.\"\"\"\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Define the participants' schedules\njoyce_schedule = []\nbeverly_schedule = [\n    (\"09:30\", \"10:00\"),\n    (\"11:00\", \"11:30\"),\n    (\"12:30\", \"13:00\"),\n    (\"14:00\", \"14:30\"),\n    (\"15:30\", \"16:00\"),\n    (\"16:30\", \"17:00\")\n]\npeter_schedule = [\n    (\"09:30\", \"10:30\"),\n    (\"11:30\", \"13:00\"),\n    (\"14:30\", \"15:30\"),\n    (\"16:30\", \"17:00\")\n]\n\n# Combine all schedules\nparticipants_schedules = [joyce_schedule, beverly_schedule, peter_schedule]\n\n# Define work hours and meeting duration\nwork_hours = (\"09:00\", \"17:00\")\nduration = 60  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_76"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    duration = 30         # meeting duration in minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    donald_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (15 * 60 + 30, 16 * 60 + 30)\n    ]\n    # Donald doesn't want to meet after 12:00\n    donald_busy.append((12 * 60, work_end))\n\n    joyce_busy = [\n        (11 * 60, 13 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n\n    abigail_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60, 14 * 60),\n        (15 * 60, 17 * 60)\n    ]\n\n    # Combine all busy slots\n    all_busy = donald_busy + joyce_busy + abigail_busy\n\n    # Sort busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check after last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_77"
        },
        {
            "final_program_time": "{12:30:13:30}",
            "expected_time": "{12:30:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours\n    start_min = time_to_minutes(start_work)\n    end_min = time_to_minutes(end_work)\n    \n    # Initialize the free time slots as the entire work day\n    free_slots = [(start_min, end_min)]\n    \n    # Process each participant's busy slots to find common free time\n    for busy_slots in participants_busy:\n        new_free_slots = []\n        for busy_start, busy_end in busy_slots:\n            busy_start_min = time_to_minutes(busy_start)\n            busy_end_min = time_to_minutes(busy_end)\n            updated_slots = []\n            for slot_start, slot_end in free_slots:\n                if busy_end_min <= slot_start or busy_start_min >= slot_end:\n                    # No overlap, keep the slot as is\n                    updated_slots.append((slot_start, slot_end))\n                else:\n                    # Overlap, split the slot\n                    if slot_start < busy_start_min:\n                        updated_slots.append((slot_start, busy_start_min))\n                    if busy_end_min < slot_end:\n                        updated_slots.append((busy_end_min, slot_end))\n            free_slots = updated_slots\n        if not free_slots:\n            return None  # No common free time\n    \n    # Merge adjacent or overlapping slots (not necessary here but good practice)\n    merged_slots = []\n    for slot in sorted(free_slots):\n        if not merged_slots:\n            merged_slots.append(slot)\n        else:\n            last_start, last_end = merged_slots[-1]\n            current_start, current_end = slot\n            if current_start <= last_end:\n                # Merge slots\n                new_slot = (last_start, max(last_end, current_end))\n                merged_slots[-1] = new_slot\n            else:\n                merged_slots.append(slot)\n    \n    # Find the first slot that can accommodate the meeting duration\n    duration_min = duration * 60\n    for slot_start, slot_end in merged_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_end = slot_start + duration_min\n            return f\"{minutes_to_time(slot_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return None\n\n# Define the participants' busy times\nparticipants_busy = [\n    [(\"9:00\", \"10:00\"), (\"11:00\", \"12:00\")],  # Ronald\n    [(\"10:30\", \"11:00\"), (\"14:00\", \"14:30\")],  # Teresa\n    [(\"9:00\", \"12:30\"), (\"14:00\", \"15:30\"), (\"16:00\", \"17:00\")],  # Carol\n]\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration_hours = 1\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_78"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:10:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert all time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start, work_end = map(time_to_minutes, work_hours.split(':'))\n    \n    # Initialize all available slots as free\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's busy slots\n    for busy_slots in participants_busy:\n        new_free_slots = []\n        for busy_start, busy_end in busy_slots:\n            busy_start = time_to_minutes(busy_start)\n            busy_end = time_to_minutes(busy_end)\n            updated_free_slots = []\n            for slot_start, slot_end in free_slots:\n                if busy_start >= slot_end or busy_end <= slot_start:\n                    # No overlap, keep the slot as is\n                    updated_free_slots.append((slot_start, slot_end))\n                else:\n                    # Split the slot around the busy time\n                    if slot_start < busy_start:\n                        updated_free_slots.append((slot_start, busy_start))\n                    if slot_end > busy_end:\n                        updated_free_slots.append((busy_end, slot_end))\n            free_slots = updated_free_slots\n    \n    # Find the first slot that can fit the meeting duration\n    duration_minutes = duration * 60\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    return None\n\n# Define the participants' busy times\namy_busy = [(\"11:00\", \"11:30\"), (\"12:00\", \"12:30\")]\nemma_busy = []\njohn_busy = [(\"10:00\", \"10:30\"), (\"11:30\", \"12:00\"), (\"12:30\", \"16:00\"), (\"16:30\", \"17:00\")]\n\n# Combine all busy times\nparticipants_busy = [amy_busy, emma_busy, john_busy]\n\n# Define work hours and meeting duration\nwork_hours = \"9:00:17:00\"\nduration_hours = 1\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_79"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since midnight\n    michelle_busy = [\n        (9 * 60 + 30, 10 * 60 + 0),\n        (12 * 60 + 30, 13 * 60 + 0)\n    ]\n    billy_busy = [\n        (10 * 60 + 30, 11 * 60 + 0),\n        (11 * 60 + 30, 12 * 60 + 0),\n        (14 * 60 + 30, 15 * 60 + 0),\n        (16 * 60 + 0, 16 * 60 + 30)\n    ]\n    alexis_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (11 * 60 + 0, 12 * 60 + 0),\n        (12 * 60 + 30, 13 * 60 + 0),\n        (13 * 60 + 30, 14 * 60 + 30),\n        (16 * 60 + 0, 16 * 60 + 30)\n    ]\n    alexis_preference_end = 15 * 60  # 15:00 in minutes\n\n    # Generate all possible time slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 1  # Check every minute\n\n    # Check each slot against everyone's busy times and Alexis's preference\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        # Check if slot is before Alexis's preference end time\n        if slot_start >= alexis_preference_end:\n            continue\n        # Check Michelle's availability\n        michelle_available = True\n        for busy_start, busy_end in michelle_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                michelle_available = False\n                break\n        if not michelle_available:\n            continue\n        # Check Billy's availability\n        billy_available = True\n        for busy_start, busy_end in billy_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                billy_available = False\n                break\n        if not billy_available:\n            continue\n        # Check Alexis's availability\n        alexis_available = True\n        for busy_start, busy_end in alexis_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                alexis_available = False\n                break\n        if not alexis_available:\n            continue\n        # If all checks passed, return this slot\n        start_hh = slot_start // 60\n        start_mm = slot_start % 60\n        end_hh = slot_end // 60\n        end_mm = slot_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_80"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 9:00 (540 minutes)\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes  # Add back 540 minutes to start from 9:00\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    # Parse work hours\n    work_start, work_end = map(time_to_minutes, work_hours.split(' to '))\n    work_end -= duration  # No meeting can start after this time\n\n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules.values():\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            busy_intervals.append((start, end))\n    busy_intervals.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1] = (last_start, max(last_end, end))\n            else:\n                merged.append((start, end))\n\n    # Find the first available slot\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end and start - prev_end >= duration:\n            meeting_start = prev_end\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n        prev_end = max(prev_end, end)\n    \n    # Check after last busy interval\n    if prev_end <= work_end and work_end + duration - prev_end >= duration:\n        meeting_start = prev_end\n        meeting_end = meeting_start + duration\n        return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"Jeremy\": [\"14:30 to 15:30\"],\n    \"Lawrence\": [\"15:30 to 16:00\", \"16:30 to 17:00\"],\n    \"Helen\": [\n        \"9:30 to 10:00\",\n        \"10:30 to 11:00\",\n        \"11:30 to 12:00\",\n        \"13:00 to 14:00\",\n        \"15:00 to 15:30\",\n        \"16:00 to 17:00\"\n    ]\n}\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nmeeting_duration = 60  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, meeting_duration))\n```",
            "count": "calendar_scheduling_example_81"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes, work_start, work_end):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration = duration_minutes\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start = time_to_minutes(busy[0])\n            end = time_to_minutes(busy[1])\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start_min\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n    \n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nmichael_schedule = [\n    (\"09:30\", \"10:30\"),\n    (\"15:00\", \"15:30\"),\n    (\"16:00\", \"16:30\")\n]\n\neric_schedule = []\n\narthur_schedule = [\n    (\"09:00\", \"12:00\"),\n    (\"13:00\", \"15:00\"),\n    (\"15:30\", \"16:00\"),\n    (\"16:30\", \"17:00\")\n]\n\nparticipants_schedules = [michael_schedule, eric_schedule, arthur_schedule]\nmeeting_duration = 30\nwork_start = \"09:00\"\nwork_end = \"17:00\"\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, meeting_duration, work_start, work_end))\n```",
            "count": "calendar_scheduling_example_82"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{10:00:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    all_busy_intervals = []\n    for busy_intervals in participants_busy_times.values():\n        for interval in busy_intervals:\n            start, end = interval.split(' to ')\n            all_busy_intervals.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in all_busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability of all participants\n    for interval in free_intervals:\n        start, end = interval\n        duration = end - start\n        if duration >= meeting_duration * 60:\n            meeting_end = start + meeting_duration * 60\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' busy times\nparticipants_busy_times = {\n    \"Anthony\": [\"14:00 to 14:30\", \"15:00 to 15:30\"],\n    \"Ronald\": [\"9:00 to 10:00\", \"12:00 to 12:30\", \"13:30 to 14:00\"],\n    \"Jonathan\": [\"9:00 to 10:00\", \"11:00 to 11:30\", \"12:00 to 13:00\", \"14:00 to 14:30\", \"15:00 to 17:00\"]\n}\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 1  # in hours\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration))\n```",
            "count": "calendar_scheduling_example_83"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration):\n    # Convert all time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = map(time_to_minutes, work_hours)\n    duration_minutes = duration * 60\n    \n    # Generate all busy intervals for each participant in minutes\n    busy_intervals = []\n    for person in participants_busy_times:\n        person_intervals = []\n        for interval in participants_busy_times[person]:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            person_intervals.append((start, end))\n        busy_intervals.append(person_intervals)\n    \n    # Combine all busy intervals and sort them\n    all_busy = []\n    for intervals in busy_intervals:\n        all_busy.extend(intervals)\n    all_busy.sort()\n    \n    # Find the earliest available slot\n    current_start = work_start\n    for start, end in all_busy:\n        if start > current_start and start - current_start >= duration_minutes:\n            return f\"{minutes_to_time(current_start)}:{minutes_to_time(current_start + duration_minutes)}\"\n        current_start = max(current_start, end)\n    \n    # Check after the last busy interval\n    if work_end - current_start >= duration_minutes:\n        return f\"{minutes_to_time(current_start)}:{minutes_to_time(current_start + duration_minutes)}\"\n    \n    return \"No available slot found\"\n\n# Define the participants' busy times\nparticipants_busy_times = {\n    \"Kevin\": [\"9:30 to 10:00\", \"10:30 to 11:00\", \"15:00 to 16:00\"],\n    \"Ryan\": [\"10:30 to 11:30\", \"12:30 to 13:00\", \"13:30 to 14:00\"],\n    \"Eugene\": [\"9:00 to 9:30\", \"10:00 to 11:00\", \"12:30 to 17:00\"]\n}\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 1  # in hours\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_84"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define busy intervals in minutes since midnight\n    # Kelly is free all day, so no busy intervals\n    kelly_busy = []\n    \n    # Julia's busy intervals\n    julia_busy = [\n        (9 * 60 + 30, 10 * 60),      # 9:30-10:00\n        (14 * 60, 14 * 60 + 30),     # 14:00-14:30\n        (15 * 60, 15 * 60 + 30),     # 15:00-15:30\n        (16 * 60 + 30, 17 * 60)      # 16:30-17:00\n    ]\n    # Julia's preference: not after 13:30 (so before 13:30)\n    julia_preference_end = 13 * 60 + 30  # 13:30 in minutes\n    \n    # Martha's busy intervals\n    martha_busy = [\n        (9 * 60, 11 * 60),           # 9:00-11:00\n        (12 * 60, 15 * 60)           # 12:00-15:00\n    ]\n    \n    # Combine all busy intervals for all participants\n    # Since Kelly is free, we only need to consider Julia and Martha\n    all_busy = julia_busy + martha_busy\n    \n    # Generate potential slots\n    potential_slots = []\n    current_start = work_start\n    \n    while current_start + meeting_duration <= work_end:\n        current_end = current_start + meeting_duration\n        slot_valid = True\n        \n        # Check if the slot overlaps with any busy interval\n        for busy_start, busy_end in all_busy:\n            if not (current_end <= busy_start or current_start >= busy_end):\n                slot_valid = False\n                break\n        \n        # Also check Julia's preference (must start and end before 13:30)\n        if current_start >= julia_preference_end:\n            slot_valid = False\n        \n        if slot_valid:\n            potential_slots.append((current_start, current_end))\n        \n        current_start += 15  # Check every 15 minutes for efficiency\n    \n    # Select the first valid slot\n    if potential_slots:\n        meeting_start, meeting_end = potential_slots[0]\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No valid slot found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_85"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for person in schedules:\n        for interval in schedules[person]:\n            start, end = interval.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            busy_intervals.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find free intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Find the first free interval that can fit the meeting\n    for start, end in free_intervals:\n        if end - start >= duration * 60:\n            meeting_start = start\n            meeting_end = meeting_start + duration * 60\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define schedules and constraints\nschedules = {\n    \"Samuel\": [\n        \"9:00 to 9:30\",\n        \"10:00 to 10:30\",\n        \"12:00 to 12:30\",\n        \"14:00 to 15:00\",\n        \"16:00 to 16:30\"\n    ],\n    \"Emma\": [],\n    \"Brittany\": [\n        \"11:30 to 14:30\",\n        \"15:00 to 15:30\",\n        \"16:30 to 17:00\"\n    ]\n}\nwork_hours = \"9:00 to 17:00\"\nduration = 1  # in hours\n\n# Find and print the meeting time\nprint(find_meeting_time(schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_86"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, duration, work_hours):\n    # Convert all time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    all_busy = []\n    for person in participants_busy.values():\n        for interval in person:\n            start, end = interval.split(' to ')\n            all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Merge overlapping or adjacent free intervals (though sorting should prevent overlaps)\n    merged = []\n    for start, end in free_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1] = (last_start, end)\n            else:\n                merged.append((start, end))\n    \n    # Check each free interval for sufficient duration\n    duration_min = duration * 60\n    for start, end in merged:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' busy times\nparticipants_busy = {\n    \"Brittany\": [\"12:00 to 13:30\", \"14:30 to 15:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"],\n    \"Wayne\": [\"9:30 to 10:00\", \"13:00 to 15:00\", \"16:30 to 17:00\"],\n    \"Charles\": [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:30 to 13:30\", \"14:30 to 16:30\"]\n}\n\n# Meeting duration in hours (0.5 hours = 30 minutes)\nmeeting_duration = 0.5\n\n# Work hours\nwork_hours = \"9:00 to 17:00\"\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, meeting_duration, work_hours))\n```",
            "count": "calendar_scheduling_example_87"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:30}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Parse work hours\n    work_start, work_end = work_hours.split(' to ')\n    work_start = int(work_start.split(':')[0]) * 60 + int(work_start.split(':')[1])\n    work_end = int(work_end.split(':')[0]) * 60 + int(work_end.split(':')[1])\n    \n    # Initialize busy slots for all participants\n    busy_slots = []\n    \n    # Process each participant's schedule\n    for schedule in participents_schedules:\n        participant_busy = []\n        for busy in schedule.split('; '):\n            if 'to' in busy:\n                start, end = busy.split(' to ')\n                start_time = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n                end_time = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n                participant_busy.append((start_time, end_time))\n        busy_slots.append(participant_busy)\n    \n    # Find all available slots\n    available_slots = []\n    current_time = work_start\n    \n    while current_time + duration <= work_end:\n        slot_available = True\n        slot_end = current_time + duration\n        \n        # Check if the slot is available for all participants\n        for participant in busy_slots:\n            for busy_start, busy_end in participant:\n                if not (slot_end <= busy_start or current_time >= busy_end):\n                    slot_available = False\n                    break\n            if not slot_available:\n                break\n        \n        if slot_available:\n            available_slots.append((current_time, slot_end))\n        \n        current_time += 15  # Check in 15-minute increments\n    \n    if not available_slots:\n        return None\n    \n    # Return the first available slot\n    first_slot = available_slots[0]\n    start_hour = first_slot[0] // 60\n    start_min = first_slot[0] % 60\n    end_hour = first_slot[1] // 60\n    end_min = first_slot[1] % 60\n    \n    return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n\n# Define the problem\nparticipants_schedules = [\n    \"\",  # Dennis has no meetings\n    \"9:00 to 9:30; 12:30 to 13:00\",  # Joseph\n    \"9:00 to 10:30; 11:30 to 12:00; 13:30 to 14:00; 14:30 to 17:00\"  # Isabella\n]\nwork_hours = \"9:00 to 17:00\"\nduration = 60  # 1 hour in minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_88"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:00:16:00}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 (9:00)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Initialize the free slots for all participants\n    free_slots = []\n    for schedule in participents_schedules:\n        busy = []\n        for block in schedule:\n            start, end = block.split(' to ')\n            busy.append((time_to_minutes(start), time_to_minutes(end)))\n        # Sort busy intervals\n        busy.sort()\n        # Calculate free intervals\n        free = []\n        prev_end = work_start\n        for start, end in busy:\n            if start > prev_end:\n                free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            free.append((prev_end, work_end))\n        free_slots.append(free)\n    \n    # Find common free slots\n    common_free = free_slots[0]\n    for slots in free_slots[1:]:\n        new_common = []\n        i = j = 0\n        while i < len(common_free) and j < len(slots):\n            start1, end1 = common_free[i]\n            start2, end2 = slots[j]\n            # Find the overlap\n            start = max(start1, start2)\n            end = min(end1, end2)\n            if start < end:\n                new_common.append((start, end))\n            # Move the pointer which ends first\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free = new_common\n    \n    # Find the first slot that can fit the duration\n    for start, end in common_free:\n        if end - start >= duration:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define the schedules\nmichelle_schedule = [\"11:00 to 12:00\", \"14:00 to 15:00\"]\nandrea_schedule = [\"9:00 to 9:30\", \"11:30 to 12:30\", \"13:30 to 14:00\", \"14:30 to 15:00\", \"16:00 to 16:30\"]\ndouglas_schedule = [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:00 to 15:00\", \"16:00 to 17:00\"]\n\nparticipants_schedules = [michelle_schedule, andrea_schedule, douglas_schedule]\nwork_hours = \"9:00 to 17:00\"\nduration = 60  # 1 hour in minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_89"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    adam_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    willie_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    gloria_busy = [\n        (9 * 60 + 30, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    # Gloria's preference: avoid after 15:30 (i.e., 15 * 60 + 30)\n    gloria_preference_end = 15 * 60 + 30\n\n    # Generate all possible slots and check availability\n    for start in range(work_start, work_end - meeting_duration + 1, 15):  # Check every 15 minutes\n        end = start + meeting_duration\n        # Check if the slot is within Gloria's preference\n        if end > gloria_preference_end:\n            continue\n        # Check Adam's availability\n        adam_available = True\n        for busy_start, busy_end in adam_busy:\n            if not (end <= busy_start or start >= busy_end):\n                adam_available = False\n                break\n        if not adam_available:\n            continue\n        # Check Willie's availability\n        willie_available = True\n        for busy_start, busy_end in willie_busy:\n            if not (end <= busy_start or start >= busy_end):\n                willie_available = False\n                break\n        if not willie_available:\n            continue\n        # Check Gloria's availability\n        gloria_available = True\n        for busy_start, busy_end in gloria_busy:\n            if not (end <= busy_start or start >= busy_end):\n                gloria_available = False\n                break\n        if not gloria_available:\n            continue\n        # If all are available, return the slot\n        start_time = f\"{start // 60:02d}:{start % 60:02d}\"\n        end_time = f\"{end // 60:02d}:{end % 60:02d}\"\n        return f\"{start_time}:{end_time}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_90"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:14:00}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert work hours and meeting times to minutes for easier calculation\n    work_start, work_end = work_hours\n    work_start_min = work_start[0] * 60 + work_start[1]\n    work_end_min = work_end[0] * 60 + work_end[1]\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    busy_intervals = []\n    \n    for person in participents_schedules:\n        for meeting in participents_schedules[person]:\n            start, end = meeting\n            start_min = start[0] * 60 + start[1]\n            end_min = end[0] * 60 + end[1]\n            busy_intervals.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    previous_end = work_start_min\n    \n    for start, end in merged:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy interval\n    if previous_end < work_end_min:\n        available_slots.append((previous_end, work_end_min))\n    \n    # Find the first available slot that can fit the duration\n    duration_min = duration * 60\n    for start, end in available_slots:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return None\n\n# Define the participants' schedules\nparticipants_schedules = {\n    \"Danielle\": [\n        ((9, 0), (10, 0)),\n        ((10, 30), (11, 0)),\n        ((14, 30), (15, 0)),\n        ((15, 30), (16, 0)),\n        ((16, 30), (17, 0))\n    ],\n    \"Bruce\": [\n        ((11, 0), (11, 30)),\n        ((12, 30), (13, 0)),\n        ((14, 0), (14, 30)),\n        ((15, 30), (16, 0))\n    ],\n    \"Eric\": [\n        ((9, 0), (9, 30)),\n        ((10, 0), (11, 0)),\n        ((11, 30), (13, 0)),\n        ((14, 30), (15, 30))\n    ]\n}\n\n# Define work hours and meeting duration\nwork_hours = ((9, 0), (17, 0))\nduration = 1  # in hours\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_91"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can accommodate the meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define the participants' schedules\njacqueline_schedule = [\"9:30 to 10:00\", \"16:30 to 17:00\"]\nhenry_schedule = []  # Free all day\nwilliam_schedule = [\"9:30 to 10:30\", \"12:30 to 15:00\", \"15:30 to 17:00\"]\n\nparticipants_schedules = [jacqueline_schedule, henry_schedule, william_schedule]\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 60  # 1 hour\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes))\n```",
            "count": "calendar_scheduling_example_92"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert all time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for busy_slots in participants_busy.values():\n        for slot in busy_slots:\n            start, end = slot.split(' to ')\n            busy_intervals.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for a slot that can fit the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' busy times\nparticipants_busy = {\n    \"Austin\": [\"10:30 to 11:00\", \"13:30 to 14:00\"],\n    \"Danielle\": [\"9:00 to 10:00\", \"11:00 to 12:00\", \"13:00 to 13:30\", \"15:30 to 16:00\"],\n    \"Charles\": [\"9:00 to 11:30\", \"12:00 to 12:30\", \"13:00 to 17:00\"],\n}\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nmeeting_duration = 30  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, work_hours, meeting_duration))\n```",
            "count": "calendar_scheduling_example_93"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' schedules and constraints\n    # Nicholas is free all day\n    nicholas_free = [(work_start, work_end)]\n\n    # Elizabeth's meetings in minutes\n    elizabeth_meetings = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60 + 30, 14 * 60 + 30),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    elizabeth_free = []\n    prev_end = work_start\n    for start, end in sorted(elizabeth_meetings):\n        if start > prev_end:\n            elizabeth_free.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        elizabeth_free.append((prev_end, work_end))\n\n    # Sandra's meetings in minutes and constraint (not before 13:00)\n    sandra_meetings = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 13 * 60 + 30),\n        (15 * 60 + 30, 16 * 60 + 30)\n    ]\n    sandra_free = []\n    prev_end = max(work_start, 13 * 60)  # Sandra can't meet before 13:00\n    for start, end in sorted(sandra_meetings):\n        if start > prev_end:\n            sandra_free.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        sandra_free.append((prev_end, work_end))\n\n    # Find overlapping free times for all participants\n    common_free = []\n    i = j = k = 0\n    while i < len(nicholas_free) and j < len(elizabeth_free) and k < len(sandra_free):\n        n_start, n_end = nicholas_free[i]\n        e_start, e_end = elizabeth_free[j]\n        s_start, s_end = sandra_free[k]\n\n        # Find the overlapping start and end\n        overlap_start = max(n_start, e_start, s_start)\n        overlap_end = min(n_end, e_end, s_end)\n\n        if overlap_start < overlap_end:\n            common_free.append((overlap_start, overlap_end))\n        \n        # Move the pointer which has the earliest end time\n        if n_end <= e_end and n_end <= s_end:\n            i += 1\n        elif e_end <= n_end and e_end <= s_end:\n            j += 1\n        else:\n            k += 1\n\n    # Find the first slot that can accommodate a 30-minute meeting\n    meeting_duration = 30\n    for slot in common_free:\n        start, end = slot\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_94"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' schedules and constraints in minutes\n    jennifer_busy = [\n        (12 * 60, 12 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    jennifer_preference = 12 * 60 + 30  # Not before 12:30\n\n    gary_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n\n    frances_busy = [\n        (9 * 60, 11 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (13 * 60, 17 * 60)\n    ]\n\n    # Duration of the meeting in minutes\n    duration = 30\n\n    # Generate all possible time slots\n    possible_slots = []\n    current_time = work_start\n\n    while current_time + duration <= work_end:\n        slot_end = current_time + duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 30  # Check every 30 minutes\n\n    # Check each slot against all constraints\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n\n        # Check Jennifer's availability and preference\n        jennifer_available = True\n        for busy_start, busy_end in jennifer_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                jennifer_available = False\n                break\n        if slot_start < jennifer_preference:\n            jennifer_available = False\n\n        # Check Gary's availability\n        gary_available = True\n        for busy_start, busy_end in gary_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                gary_available = False\n                break\n\n        # Check Frances' availability\n        frances_available = True\n        for busy_start, busy_end in frances_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                frances_available = False\n                break\n\n        # If all are available, return the slot\n        if jennifer_available and gary_available and frances_available:\n            # Convert minutes back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_95"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:9:30}",
            "type_error": "TypeError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # 9:00 is 540 minutes\n    \n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes  # Convert back to absolute minutes\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    start_min = time_to_minutes(start_work)\n    end_min = time_to_minutes(end_work)\n    \n    # Initialize a list to mark busy times\n    busy = [False] * (end_min - start_min)\n    \n    # Mark busy times for each participant\n    for schedule in participants_schedules:\n        for busy_range in schedule:\n            start, end = busy_range.split(' to ')\n            start_busy = time_to_minutes(start)\n            end_busy = time_to_minutes(end)\n            # Mark the range in the busy list\n            for i in range(max(0, start_busy - start_min), min(len(busy), end_busy - start_min)):\n                busy[i] = True\n    \n    # Find a free slot of duration minutes\n    duration_min = duration * 60  # Convert hours to minutes\n    current_start = 0\n    while current_start < len(busy):\n        if not busy[current_start]:\n            # Check if the next 'duration_min' slots are free\n            slot_available = True\n            for i in range(current_start, min(current_start + duration_min, len(busy))):\n                if busy[i]:\n                    slot_available = False\n                    current_start = i + 1\n                    break\n            if slot_available and (current_start + duration_min) <= len(busy):\n                end_slot = current_start + duration_min\n                start_time = minutes_to_time(current_start + start_min)\n                end_time = minutes_to_time(end_slot + start_min)\n                return f\"{start_time}:{end_time}\"\n        else:\n            current_start += 1\n    return \"No available slot found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"9:30 to 10:00\", \"10:30 to 11:00\", \"11:30 to 13:00\", \"15:00 to 15:30\"],  # Christopher\n    [\"9:30 to 10:00\", \"11:00 to 11:30\", \"12:00 to 12:30\", \"13:30 to 14:30\", \"15:00 to 15:30\"],  # Robert\n    [\"10:00 to 17:00\"]  # Wayne\n]\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nduration = 0.5  # half an hour\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_96"
        },
        {
            "final_program_time": "{16:00:17:00}",
            "expected_time": "{16:00:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n    \n    # Convert each person's busy slots to minutes since midnight\n    joseph_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60 + 30, 15 * 60 + 30)\n    ]\n    kyle_busy = [\n        (12 * 60 + 30, 13 * 60 + 30)\n    ]\n    joan_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    \n    # Joseph's constraint: not before 14:30\n    joseph_constraint = 14 * 60 + 30\n    \n    # Combine all busy slots\n    all_busy = []\n    for busy in [joseph_busy, kyle_busy, joan_busy]:\n        all_busy.extend(busy)\n    \n    # Sort busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that fits the meeting duration and Joseph's constraint\n    for start, end in free_slots:\n        slot_start = max(start, joseph_constraint)\n        if end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_97"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define busy intervals in minutes for each participant\n    juan_busy = [(9 * 60, 10 * 60 + 30), (15 * 60 + 30, 16 * 60)]\n    marilyn_busy = [(11 * 60, 11 * 60 + 30), (12 * 60 + 30, 13 * 60)]\n    ronald_busy = [(9 * 60, 10 * 60 + 30), (12 * 60, 12 * 60 + 30), \n                   (13 * 60, 13 * 60 + 30), (14 * 60, 16 * 60 + 30)]\n    \n    # Juan cannot meet after 16:00\n    juan_limit = 16 * 60\n    \n    # Combine all busy intervals and sort them\n    all_busy = juan_busy + marilyn_busy + ronald_busy\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy intervals\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the time after the last busy interval\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Check each free slot for a 30-minute window that fits all constraints\n    meeting_duration = 30\n    for slot_start, slot_end in free_slots:\n        current_start = slot_start\n        while current_start + meeting_duration <= slot_end:\n            # Check if the meeting fits and respects Juan's limit\n            if current_start + meeting_duration <= juan_limit:\n                return (\n                    f\"{current_start // 60:02d}:{current_start % 60:02d}:\"\n                    f\"{(current_start + meeting_duration) // 60:02d}:{(current_start + meeting_duration) % 60:02d}\"\n                )\n            current_start += 1  # Move to the next minute\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_98"
        },
        {
            "final_program_time": "{15:00:16:00}",
            "expected_time": "{15:00:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Define each person's busy times in minutes since midnight\n    stephanie_busy = [(9 * 60, 9 * 60 + 30), (13 * 60 + 30, 14 * 60)]\n    scott_busy = [(9 * 60, 10 * 60), (11 * 60, 12 * 60 + 30), (14 * 60 + 30, 15 * 60), (16 * 60, 17 * 60)]\n    mark_preference = (15 * 60, work_end)  # Mark prefers after 15:00\n\n    # Combine all busy times and sort\n    all_busy = stephanie_busy + scott_busy\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy times and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Filter free slots that meet the duration and Mark's preference\n    valid_slots = []\n    for start, end in free_slots:\n        slot_start = max(start, mark_preference[0])\n        slot_end = min(end, mark_preference[1])\n        if slot_end - slot_start >= meeting_duration:\n            valid_slots.append((slot_start, slot_end))\n\n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Format the output as HH:MM:HH:MM\n        return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    else:\n        return \"No valid time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_99"
        },
        {
            "final_program_time": "{11:00:12:00}",
            "expected_time": "{11:00:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy times for all participants\n    all_busy_times = []\n    for busy_times in participants_busy_times:\n        for start, end in busy_times:\n            all_busy_times.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy times by start time\n    all_busy_times.sort()\n    \n    # Find free slots by checking gaps between busy times and work hours\n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy_times:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Check each free slot for availability of duration\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' busy times\ndenise_busy = []\njoseph_busy = []\nhenry_busy = [(\"09:00\", \"09:30\"), (\"10:00\", \"10:30\"), (\"12:00\", \"14:30\"), (\"15:00\", \"16:00\"), (\"16:30\", \"17:00\")]\nchristian_busy = [(\"09:00\", \"11:00\"), (\"14:30\", \"15:30\"), (\"16:00\", \"17:00\")]\n\nparticipants_busy_times = [denise_busy, joseph_busy, henry_busy, christian_busy]\n\n# Define work hours and meeting duration\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 60  # 1 hour\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_100"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    start, end = work_hours\n    # Convert time strings to minutes since 9:00 for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 9 * 60  # Offset by 9:00 (540 minutes)\n\n    def minutes_to_time(minutes):\n        total_minutes = 9 * 60 + minutes\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    # Initialize the free slots for all participants\n    free_slots = []\n    for schedule in participants_schedules:\n        busy = []\n        for block in schedule:\n            s, e = block.split(' to ')\n            busy.append((time_to_minutes(s), time_to_minutes(e)))\n        # Generate free slots by finding gaps between busy blocks\n        free = []\n        prev_end = 0\n        for s, e in sorted(busy):\n            if s > prev_end:\n                free.append((prev_end, s))\n            prev_end = max(prev_end, e)\n        if prev_end < time_to_minutes(end):\n            free.append((prev_end, time_to_minutes(end)))\n        free_slots.append(free)\n\n    # Find overlapping free slots across all participants\n    common_free = free_slots[0]\n    for slots in free_slots[1:]:\n        new_common = []\n        i = j = 0\n        while i < len(common_free) and j < len(slots):\n            s1, e1 = common_free[i]\n            s2, e2 = slots[j]\n            # Find the overlap\n            overlap_s = max(s1, s2)\n            overlap_e = min(e1, e2)\n            if overlap_s < overlap_e:\n                new_common.append((overlap_s, overlap_e))\n            # Move the pointer which ends first\n            if e1 < e2:\n                i += 1\n            else:\n                j += 1\n        common_free = new_common\n\n    # Find the first slot that can fit the duration\n    for slot in common_free:\n        s, e = slot\n        if e - s >= duration:\n            meeting_start = minutes_to_time(s)\n            meeting_end = minutes_to_time(s + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n\n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"10:00 to 10:30\", \"14:30 to 15:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"],  # Madison\n    [],  # Linda\n    [\"9:00 to 12:00\", \"12:30 to 16:00\", \"16:30 to 17:00\"],  # Logan\n    [\"9:30 to 11:00\", \"11:30 to 12:00\", \"13:00 to 14:30\", \"15:00 to 15:30\", \"16:00 to 17:00\"],  # Virginia\n]\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_hours = (\"9:00\", \"17:00\")\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, duration, work_hours))\n```",
            "count": "calendar_scheduling_example_101"
        },
        {
            "final_program_time": "{11:00:12:00}",
            "expected_time": "{11:00:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert all schedules to minutes for easier comparison\n    # Each person's busy times are represented as (start, end) in minutes\n    dylan_busy = [(14 * 60, 15 * 60)]\n    kathryn_busy = [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30)]\n    hannah_busy = [(9 * 60, 10 * 60 + 30), (12 * 60 + 30, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)]\n    anna_busy = [(9 * 60, 11 * 60), (12 * 60, 14 * 60), (14 * 60 + 30, 15 * 60), (16 * 60, 16 * 60 + 30)]\n    \n    # Combine all busy times and sort them\n    all_busy = dylan_busy + kathryn_busy + hannah_busy + anna_busy\n    all_busy.sort()\n    \n    # Find the earliest available slot of 60 minutes\n    current_time = work_start\n    meeting_duration = 60\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > current_time:\n            if busy_start - current_time >= meeting_duration:\n                # Found a slot\n                end_time = current_time + meeting_duration\n                return f\"{current_time // 60:02d}:{current_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n        # Update current_time to the end of the busy period if it's later\n        if busy_end > current_time:\n            current_time = busy_end\n    \n    # Check the remaining time after the last busy period\n    if work_end - current_time >= meeting_duration:\n        end_time = current_time + meeting_duration\n        return f\"{current_time // 60:02d}:{current_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n    \n    # If no slot found (though the problem states there is one)\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_102"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all blocked time slots\n    blocked_slots = []\n    for schedule in participants_schedules:\n        for slot in schedule:\n            start, end = map(time_to_minutes, slot.split(' to '))\n            blocked_slots.append((start, end))\n    \n    # Sort blocked slots by start time\n    blocked_slots.sort()\n    \n    # Find available slots by checking gaps between blocked slots and work hours\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in blocked_slots:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Check each available slot for duration\n    duration = duration_minutes\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\ndiane_schedule = [\"9:30 to 10:00\", \"14:30 to 15:00\"]\njack_schedule = [\"13:30 to 14:00\", \"14:30 to 15:00\"]\neugene_schedule = [\"9:00 to 10:00\", \"10:30 to 11:30\", \"12:00 to 14:30\", \"15:00 to 16:30\"]\npatricia_schedule = [\"9:30 to 10:30\", \"11:00 to 12:00\", \"12:30 to 14:00\", \"15:00 to 16:30\"]\n\nall_schedules = [diane_schedule, jack_schedule, eugene_schedule, patricia_schedule]\n\n# Find meeting time\nmeeting_time = find_meeting_time(all_schedules, \"9:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_103"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time strings to minutes since 9:00 (work_hours_start)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - work_hours_start) * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = work_hours_start + (minutes // 60)\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        person_busy = []\n        for block in schedule:\n            start, end = block.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            person_busy.append((start_min, end_min))\n        busy_intervals.append(person_busy)\n    \n    # Find the earliest and latest possible times in minutes\n    earliest_start = 0\n    latest_end = (work_hours_end - work_hours_start) * 60\n    \n    # Generate all possible time slots and check for availability\n    for start in range(earliest_start, latest_end - duration_minutes + 1):\n        end = start + duration_minutes\n        if end > latest_end:\n            continue\n        # Check if the slot is free for all participants\n        all_free = True\n        for person_busy in busy_intervals:\n            person_free = True\n            for (busy_start, busy_end) in person_busy:\n                if not (end <= busy_start or start >= busy_end):\n                    person_free = False\n                    break\n            if not person_free:\n                all_free = False\n                break\n        if all_free:\n            start_time = minutes_to_time(start)\n            end_time = minutes_to_time(end)\n            return f\"{start_time}:{end_time}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"9:00 to 10:30\", \"16:30 to 17:00\"],  # Karen\n    [\"9:30 to 10:00\", \"10:30 to 11:00\", \"11:30 to 12:30\", \"15:30 to 16:00\", \"16:30 to 17:00\"],  # Brandon\n    [\"9:00 to 10:30\", \"11:00 to 14:00\", \"14:30 to 17:00\"],  # Donald\n    [\"9:00 to 9:30\", \"10:30 to 11:00\", \"11:30 to 12:00\", \"13:30 to 14:00\", \"14:30 to 15:30\", \"16:00 to 17:00\"]  # Kelly\n]\n\n# Define work hours and meeting duration\nwork_hours_start = 9\nwork_hours_end = 17\nduration_minutes = 30\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_104"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between merged intervals and work hours\n    available = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n    \n    # Check each available slot for the first that can fit the duration\n    duration_min = duration * 60\n    for start, end in available:\n        if end - start >= duration_min:\n            meeting_end = start + duration_min\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules\njason_schedule = [\n    \"9:00 to 10:00\",\n    \"10:30 to 11:00\",\n    \"11:30 to 12:00\",\n    \"12:30 to 13:00\",\n    \"14:00 to 14:30\"\n]\n\nwilliam_schedule = [\n    \"9:00 to 9:30\",\n    \"11:30 to 12:00\",\n    \"14:00 to 14:30\",\n    \"16:30 to 17:00\"\n]\n\nfrances_schedule = [\n    \"9:00 to 9:30\",\n    \"10:00 to 10:30\",\n    \"11:00 to 12:30\",\n    \"13:30 to 16:00\"\n]\n\nrachel_schedule = [\n    \"9:00 to 9:30\",\n    \"10:00 to 10:30\",\n    \"11:00 to 14:00\",\n    \"14:30 to 16:00\",\n    \"16:30 to 17:00\"\n]\n\n# Combine all schedules\nparticipants_schedules = [jason_schedule, william_schedule, frances_schedule, rachel_schedule]\n\n# Find a meeting time\nmeeting_time = find_meeting_time(participants_schedules, 30, \"9:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_105"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{10:00:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n    \n    # Check each available slot for sufficient duration\n    for slot in available:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"12:30 to 13:30\", \"14:30 to 15:00\", \"16:30 to 17:00\"],  # Olivia\n    [],  # Anna\n    [\"09:00 to 10:00\", \"11:30 to 16:00\", \"16:30 to 17:00\"],  # Virginia\n    [\"09:00 to 09:30\", \"11:00 to 11:30\", \"13:00 to 14:00\", \"14:30 to 16:00\", \"16:30 to 17:00\"],  # Paul\n]\n\n# Define meeting parameters\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 60  # 1 hour\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_106"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert all time strings to minutes since 9:00 (work_hours_start)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - work_hours_start * 60\n\n    work_hours_start_min = time_to_minutes(f\"{work_hours_start}:00\")\n    work_hours_end_min = time_to_minutes(f\"{work_hours_end}:00\")\n\n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append([start, end])\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1][1] = max(end, last_end)\n            else:\n                merged.append([start, end])\n\n    # Check the available slots before first busy interval, between intervals, and after last busy interval\n    available_slots = []\n    prev_end = work_hours_start_min\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = end\n    if prev_end < work_hours_end_min:\n        available_slots.append((prev_end, work_hours_end_min))\n\n    # Find the first available slot that can fit the meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = (minutes + work_hours_start * 60) // 60\n                mm = (minutes + work_hours_start * 60) % 60\n                return f\"{hh:02d}:{mm:02d}\"\n\n            meeting_start = minutes_to_time(slot_start)\n            meeting_end = minutes_to_time(slot_start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n\n    return \"No available slot found\"\n\n# Define the participants' schedules\npeter_schedule = [\n    \"9:00 to 9:30\",\n    \"10:30 to 11:00\",\n    \"11:30 to 12:00\",\n    \"12:30 to 13:00\"\n]\njudith_schedule = []\nkeith_schedule = [\n    \"11:30 to 12:00\",\n    \"12:30 to 15:00\",\n    \"15:30 to 16:00\",\n    \"16:30 to 17:00\"\n]\nevelyn_schedule = [\n    \"9:00 to 12:30\",\n    \"13:30 to 15:30\",\n    \"16:30 to 17:00\"\n]\n\nparticipants_schedules = [peter_schedule, judith_schedule, keith_schedule, evelyn_schedule]\nmeeting_duration = 30  # minutes\nwork_hours_start = 9\nwork_hours_end = 17\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, meeting_duration, work_hours_start, work_hours_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_107"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each person's busy slots to minutes\n    # Lisa's busy slots: 9:00-9:30, 10:00-10:30, 13:00-14:00, 15:00-16:00\n    lisa_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (13 * 60, 14 * 60),\n        (15 * 60, 16 * 60)\n    ]\n    \n    # Dorothy's busy slots: 9:00-9:30, 10:30-11:30, 13:30-14:00, 14:30-15:30\n    dorothy_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 11 * 60 + 30),\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60 + 30)\n    ]\n    \n    # Anthony's busy slots: 9:00-10:00, 11:00-12:30, 13:00-14:00, 15:00-16:30\n    anthony_busy = [\n        (9 * 60, 10 * 60),\n        (11 * 60, 12 * 60 + 30),\n        (13 * 60, 14 * 60),\n        (15 * 60, 16 * 60 + 30)\n    ]\n    \n    # Ryan's busy slots: 9:00-12:30, 13:00-16:30\n    ryan_busy = [\n        (9 * 60, 12 * 60 + 30),\n        (13 * 60, 16 * 60 + 30)\n    ]\n    \n    # Lisa cannot meet before 14:30\n    lisa_constraint = 14 * 60 + 30\n    \n    # Meeting duration is 30 minutes\n    duration = 30\n    \n    # Generate all possible slots and check for availability\n    for start in range(work_start, work_end - duration + 1, 15):  # Check every 15 minutes\n        end = start + duration\n        # Check Lisa's constraints\n        if start < lisa_constraint:\n            continue\n        # Check if the slot is free for everyone\n        lisa_free = all(not (s < end and e > start) for s, e in lisa_busy)\n        dorothy_free = all(not (s < end and e > start) for s, e in dorothy_busy)\n        anthony_free = all(not (s < end and e > start) for s, e in anthony_busy)\n        ryan_free = all(not (s < end and e > start) for s, e in ryan_busy)\n        \n        if lisa_free and dorothy_free and anthony_free and ryan_free:\n            # Convert start and end back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = end // 60\n            end_mm = end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_108"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy blocks to minutes since 9:00\n    marie_busy = [(11*60, 11*60 + 30), (15*60, 16*60 + 30)]\n    janice_busy = [(12*60 + 30, 13*60), (13*60 + 30, 15*60)]\n    elijah_busy = [(10*60, 13*60), (14*60 + 30, 15*60), (16*60, 16*60 + 30)]\n    theresa_busy = [(9*60 + 30, 10*60 + 30), (12*60, 13*60), (13*60 + 30, 14*60),\n                    (14*60 + 30, 15*60), (15*60 + 30, 16*60), (16*60 + 30, 17*60)]\n    theresa_no_meet_after = 12 * 60  # No meetings after 12:00\n\n    # Generate all possible 30-minute slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 1  # Check every minute for availability\n\n    # Check each slot against everyone's constraints\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n\n        # Check Theresa's preference (no meetings after 12:00)\n        if slot_start >= theresa_no_meet_after:\n            continue\n\n        # Check Marie's availability\n        marie_available = True\n        for busy_start, busy_end in marie_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                marie_available = False\n                break\n        if not marie_available:\n            continue\n\n        # Check Janice's availability\n        janice_available = True\n        for busy_start, busy_end in janice_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                janice_available = False\n                break\n        if not janice_available:\n            continue\n\n        # Check Elijah's availability\n        elijah_available = True\n        for busy_start, busy_end in elijah_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                elijah_available = False\n                break\n        if not elijah_available:\n            continue\n\n        # Check Theresa's availability\n        theresa_available = True\n        for busy_start, busy_end in theresa_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                theresa_available = False\n                break\n        if not theresa_available:\n            continue\n\n        # If all checks passed, return this slot\n        start_h = slot_start // 60\n        start_m = slot_start % 60\n        end_h = slot_end // 60\n        end_m = slot_end % 60\n        return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n\n    return \"No suitable time found\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_109"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define each person's busy times in minutes (start, end)\n    helen_busy = [\n        (9 * 60, 12 * 60),\n        (12 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    ashley_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    grace_preference_end = 15 * 60  # Grace prefers no meetings after 15:00\n\n    # Combine all busy times for Helen and Ashley\n    combined_busy = helen_busy + ashley_busy\n    # Sort by start time\n    combined_busy.sort()\n\n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = work_start\n\n    for busy_start, busy_end in combined_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    # Check the time after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Filter free slots that are at least 30 minutes and before Grace's preference\n    possible_slots = []\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= 30 and slot_start < grace_preference_end:\n            possible_slots.append((slot_start, slot_end))\n\n    # Select the earliest possible slot\n    if possible_slots:\n        meeting_start = possible_slots[0][0]\n        meeting_end = meeting_start + 30\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_110"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:00:12:30}",
            "type_error": "SyntaxError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours=('09:00', '17:00')):\n    # Convert time strings to minutes since 00:00 for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start, work_end = map(time_to_minutes, work_hours)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    \n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            all_busy.append((time_to_minutes(busy_start), time_to_minutes(busy_end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append([start, end])\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = [new_start, new_end]\n            else:\n                merged_busy.append([start, end])\n    \n    # Find available slots by looking at gaps between busy intervals\n    available_slots = []\n    previous_end = work_start\n    \n    for start, end in merged_busy:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy interval\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [('09:00', '10:00'), ('10:30', '11:30'), ('12:30', '13:00'), ('13:30', '14:00')],  # Gregory\n    [],  # Natalie\n    [('09:00', '11:30'), ('13:30', '17:00')],  # Christine\n    [('09:00', '09:30'), ('10:30', '12:00'), ('12:30', '14:00'), ('14:30', '17:00')],  # Vincent\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_111"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration_minutes):\n    # Convert work hours and schedules to minutes since start of day\n    work_start, work_end = work_hours\n    work_start_min = work_start[0] * 60 + work_start[1]\n    work_end_min = work_end[0] * 60 + work_end[1]\n    \n    # Initialize the free slots for all participants\n    free_slots = []\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start_min = busy[0][0] * 60 + busy[0][1]\n            end_min = busy[1][0] * 60 + busy[1][1]\n            busy_slots.append((start_min, end_min))\n        \n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Calculate free slots for the participant\n        participant_free = []\n        prev_end = work_start_min\n        for busy_start, busy_end in busy_slots:\n            if busy_start > prev_end:\n                participant_free.append((prev_end, busy_start))\n            prev_end = max(prev_end, busy_end)\n        if prev_end < work_end_min:\n            participant_free.append((prev_end, work_end_min))\n        \n        free_slots.append(participant_free)\n    \n    # Find overlapping free slots across all participants\n    common_free = free_slots[0]\n    for participant_free in free_slots[1:]:\n        new_common_free = []\n        i = j = 0\n        while i < len(common_free) and j < len(participant_free):\n            start1, end1 = common_free[i]\n            start2, end2 = participant_free[j]\n            \n            # Find overlap\n            overlap_start = max(start1, start2)\n            overlap_end = min(end1, end2)\n            \n            if overlap_start < overlap_end:\n                new_common_free.append((overlap_start, overlap_end))\n            \n            # Move the pointer which ends first\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free = new_common_free\n    \n    # Find the first slot that can accommodate the meeting\n    for slot in common_free:\n        start, end = slot\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return None\n\n# Define work hours (9:00 to 17:00)\nwork_hours = ((9, 0), (17, 0))\n\n# Define participants' schedules in HH:MM format converted to tuples\nparticipants_schedules = [\n    # Jean's schedule\n    [\n        ((11, 0), (11, 30)),\n        ((12, 30), (13, 30)),\n        ((14, 0), (14, 30)),\n        ((15, 0), (15, 30)),\n        ((16, 30), (17, 0))\n    ],\n    # Jose's schedule (no meetings)\n    [],\n    # Samuel's schedule\n    [\n        ((9, 0), (12, 0)),\n        ((12, 30), (16, 0)),\n        ((16, 30), (17, 0))\n    ],\n    # Henry's schedule\n    [\n        ((9, 0), (10, 30)),\n        ((14, 0), (14, 30)),\n        ((15, 0), (17, 0))\n    ]\n]\n\n# Meeting duration is 30 minutes\nduration = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_112"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:00:10:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find available slots by merging busy intervals\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nbradley_schedule = [\"9:30:10:00\", \"12:30:13:00\", \"13:30:14:00\", \"15:30:16:00\"]\nteresa_schedule = [\"10:30:11:00\", \"12:00:12:30\", \"13:00:13:30\", \"14:30:15:00\"]\nelizabeth_schedule = [\"9:00:9:30\", \"10:30:11:30\", \"13:00:13:30\", \"14:30:15:00\", \"15:30:17:00\"]\nchristian_schedule = [\"9:00:9:30\", \"10:30:17:00\"]\n\n# Combine all schedules\nparticipants_schedules = [bradley_schedule, teresa_schedule, elizabeth_schedule, christian_schedule]\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, \"9:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_113"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    stephanie_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    cheryl_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    bradley_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 11 * 60 + 30),\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    steven_busy = [\n        (9 * 60, 12 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 17 * 60)\n    ]\n\n    # Combine all busy slots\n    all_busy = []\n    for slot in stephanie_busy:\n        all_busy.append(('Stephanie', slot))\n    for slot in cheryl_busy:\n        all_busy.append(('Cheryl', slot))\n    for slot in bradley_busy:\n        all_busy.append(('Bradley', slot))\n    for slot in steven_busy:\n        all_busy.append(('Steven', slot))\n\n    # Sort all busy slots by start time\n    all_busy.sort(key=lambda x: x[1][0])\n\n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n\n    for person, (start, end) in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check if there's a free slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate 60 minutes\n    meeting_duration = 60\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Check if all participants are free during this slot\n            valid = True\n            # Check Stephanie\n            for s_start, s_end in stephanie_busy:\n                if not (end <= s_start or start >= s_end):\n                    valid = False\n                    break\n            if not valid:\n                continue\n            # Check Cheryl\n            for c_start, c_end in cheryl_busy:\n                if not (end <= c_start or start >= c_end):\n                    valid = False\n                    break\n            if not valid:\n                continue\n            # Check Bradley\n            for b_start, b_end in bradley_busy:\n                if not (end <= b_start or start >= b_end):\n                    valid = False\n                    break\n            if not valid:\n                continue\n            # Check Steven\n            for st_start, st_end in steven_busy:\n                if not (end <= st_start or start >= st_end):\n                    valid = False\n                    break\n            if valid:\n                # Convert minutes back to HH:MM format\n                start_hh = start // 60\n                start_mm = start % 60\n                end_hh = (start + meeting_duration) // 60\n                end_mm = (start + meeting_duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_114"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy times in minutes since midnight\n    busy_times = {\n        'Jose': [],\n        'Catherine': [(12 * 60, 12 * 60 + 30), (15 * 60, 15 * 60 + 30)],\n        'Rachel': [\n            (9 * 60, 9 * 60 + 30),\n            (10 * 60, 11 * 60),\n            (11 * 60 + 30, 12 * 60),\n            (12 * 60 + 30, 13 * 60),\n            (14 * 60, 16 * 60),\n            (16 * 60 + 30, 17 * 60)\n        ],\n        'Lori': [\n            (9 * 60, 12 * 60),\n            (13 * 60, 13 * 60 + 30),\n            (14 * 60 + 30, 15 * 60 + 30),\n            (16 * 60 + 30, 17 * 60)\n        ]\n    }\n    \n    # Catherine's preference: not before 14:00\n    preference_start = 14 * 60\n    \n    # Meeting duration in minutes\n    duration = 30\n    \n    # Generate all possible slots and check availability\n    for start in range(preference_start, work_end - duration + 1, 15):  # Check in 15-minute increments\n        end = start + duration\n        if end > work_end:\n            continue\n        \n        # Check if the slot is free for all participants\n        all_free = True\n        for participant, busy_slots in busy_times.items():\n            for busy_start, busy_end in busy_slots:\n                if not (end <= busy_start or start >= busy_end):\n                    all_free = False\n                    break\n            if not all_free:\n                break\n        \n        if all_free:\n            # Format the time as HH:MM:HH:MM\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = end // 60\n            end_mm = end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_115"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define busy intervals in minutes for each participant\n    adam_busy = [(14 * 60, 15 * 60)]\n    john_busy = [(13 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30), \n                 (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)]\n    stephanie_busy = [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 11 * 60), \n                      (11 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)]\n    anna_busy = [(9 * 60 + 30, 10 * 60), (12 * 60, 12 * 60 + 30), \n                 (13 * 60, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)]\n    \n    # Anna's preference: not before 14:30\n    anna_preference_start = 14 * 60 + 30\n    \n    # Meeting duration in minutes\n    meeting_duration = 30\n    \n    # Generate all possible slots starting from 14:30 to end of work day\n    for start in range(anna_preference_start, work_end - meeting_duration + 1, 15):\n        end = start + meeting_duration\n        # Check if the slot is free for all participants\n        adam_free = all(not (start < busy_end and end > busy_start) for busy_start, busy_end in adam_busy)\n        john_free = all(not (start < busy_end and end > busy_start) for busy_start, busy_end in john_busy)\n        stephanie_free = all(not (start < busy_end and end > busy_start) for busy_start, busy_end in stephanie_busy)\n        anna_free = all(not (start < busy_end and end > busy_start) for busy_start, busy_end in anna_busy)\n        \n        if adam_free and john_free and stephanie_free and anna_free:\n            # Format the time as HH:MM:HH:MM\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = end // 60\n            end_mm = end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_116"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    brian_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (12 * 60, 13 * 60),\n        (14 * 60, 14 * 60 + 30)\n    ]\n    ronald_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    denise_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    jesse_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 13 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n\n    # Jesse's preference: avoid after 15:00\n    jesse_preference_end = 15 * 60\n\n    # Generate all possible slots\n    possible_slots = []\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        # Check if the slot is before Jesse's preference\n        if slot_end > jesse_preference_end:\n            current_time += 1\n            continue\n        # Check if all are free\n        brian_free = all(not (start <= current_time < end or start < slot_end <= end) for start, end in brian_busy)\n        ronald_free = all(not (start <= current_time < end or start < slot_end <= end) for start, end in ronald_busy)\n        denise_free = all(not (start <= current_time < end or start < slot_end <= end) for start, end in denise_busy)\n        jesse_free = all(not (start <= current_time < end or start < slot_end <= end) for start, end in jesse_busy)\n        if brian_free and ronald_free and denise_free and jesse_free:\n            possible_slots.append((current_time, slot_end))\n        current_time += 1\n\n    # Select the first available slot\n    if possible_slots:\n        start, end = possible_slots[0]\n        # Convert back to HH:MM format\n        start_hh = start // 60\n        start_mm = start % 60\n        end_hh = end // 60\n        end_mm = end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_117"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for person in participants_schedules:\n        busy_intervals = []\n        for interval in participants_schedules[person]:\n            start, end = interval.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            busy_intervals.append((start_min, end_min))\n        all_busy_intervals.append(busy_intervals)\n    \n    # Find all possible free intervals for all participants\n    possible_start_times = []\n    \n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        valid = True\n        for busy_intervals in all_busy_intervals:\n            for start, end in busy_intervals:\n                if current_time < end and current_time + meeting_duration > start:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            possible_start_times.append(current_time)\n        current_time += 15  # Check every 15 minutes for efficiency\n    \n    if possible_start_times:\n        first_available = possible_start_times[0]\n        end_time = first_available + meeting_duration\n        return f\"{minutes_to_time(first_available)}:{minutes_to_time(end_time)}\"\n    else:\n        return \"No available time found\"\n\n# Define the participants' schedules\nparticipants_schedules = {\n    'Ruth': ['9:30 to 10:00', '11:00 to 11:30', '12:00 to 12:30', '13:00 to 13:30', '14:30 to 15:00', '16:00 to 16:30'],\n    'Angela': ['9:00 to 9:30', '12:30 to 13:00', '13:30 to 15:00', '16:00 to 16:30'],\n    'Lisa': ['10:30 to 11:00', '11:30 to 14:00', '14:30 to 15:30', '16:00 to 17:00'],\n    'Cheryl': ['9:00 to 10:30', '11:00 to 11:30', '12:30 to 14:00', '16:00 to 16:30']\n}\n\n# Define work hours and meeting duration\nwork_hours_start = '9:00'\nwork_hours_end = '17:00'\nmeeting_duration = 30  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_118"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours=('09:00', '17:00')):\n    # Convert work hours to minutes since midnight\n    work_start = int(work_hours[0].split(':')[0]) * 60 + int(work_hours[0].split(':')[1])\n    work_end = int(work_hours[1].split(':')[0]) * 60 + int(work_hours[1].split(':')[1])\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for schedule in participants_schedules:\n        busy_intervals = []\n        for interval in schedule:\n            start, end = interval.split(' to ')\n            start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n            end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n            busy_intervals.append((start_min, end_min))\n        all_busy_intervals.append(busy_intervals)\n    \n    # Find all possible slots where all participants are free\n    for time in range(work_start, work_end - duration_minutes + 1):\n        slot_start = time\n        slot_end = time + duration_minutes\n        valid = True\n        \n        for busy_intervals in all_busy_intervals:\n            overlap = False\n            for (busy_start, busy_end) in busy_intervals:\n                if not (slot_end <= busy_start or slot_start >= busy_end):\n                    overlap = True\n                    break\n            if overlap:\n                valid = False\n                break\n        \n        if valid:\n            # Format the time as HH:MM:HH:MM\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"09:00 to 09:30\", \"10:30 to 11:30\", \"13:30 to 14:00\", \"14:30 to 15:30\"],  # Scott\n    [\"10:00 to 10:30\", \"14:30 to 15:00\"],  # Laura\n    [\"09:00 to 09:30\", \"10:00 to 15:00\", \"15:30 to 17:00\"],  # Marilyn\n    [\"09:00 to 09:30\", \"10:00 to 10:30\", \"11:00 to 12:00\", \"12:30 to 16:00\", \"16:30 to 17:00\"]  # Natalie\n]\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules))\n```",
            "count": "calendar_scheduling_example_119"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    # Debra's busy slots: 9:00-10:00, 12:00-12:30, 13:00-14:30\n    debra_busy = [\n        (9 * 60, 10 * 60),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 14 * 60 + 30)\n    ]\n    \n    # Christopher's busy slots: 9:30-10:00, 12:00-13:00, 13:30-14:00, 14:30-15:00, 16:30-17:00\n    # Also, Christopher prefers no meetings after 13:00, so we add a constraint\n    christopher_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (12 * 60, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    christopher_preference_end = 13 * 60  # Prefers no meetings after 13:00\n    \n    # Evelyn's busy slots: 9:30-10:30, 11:30-12:00, 12:30-14:30, 15:30-16:00\n    evelyn_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 14 * 60 + 30),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    \n    # Wayne's busy slots: 9:00-9:30, 10:00-10:30, 11:00-12:30, 13:00-13:30, 14:00-16:00\n    wayne_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 16 * 60)\n    ]\n    \n    # Combine all busy slots for each person\n    schedules = {\n        'Debra': debra_busy,\n        'Christopher': christopher_busy,\n        'Evelyn': evelyn_busy,\n        'Wayne': wayne_busy\n    }\n    \n    # Find all possible slots where everyone is free\n    for start in range(work_start, work_end - meeting_duration + 1):\n        end = start + meeting_duration\n        # Check if the slot is within Christopher's preference (before 13:00)\n        if end <= christopher_preference_end:\n            all_free = True\n            for person, busy_slots in schedules.items():\n                for busy_start, busy_end in busy_slots:\n                    if not (end <= busy_start or start >= busy_end):\n                        all_free = False\n                        break\n                if not all_free:\n                    break\n            if all_free:\n                return f\"{start // 60:02d}:{start % 60:02d}:{end // 60:02d}:{end % 60:02d}\"\n    \n    # If no slot found before 13:00, check after (though Christopher prefers not)\n    for start in range(work_start, work_end - meeting_duration + 1):\n        end = start + meeting_duration\n        all_free = True\n        for person, busy_slots in schedules.items():\n            for busy_start, busy_end in busy_slots:\n                if not (end <= busy_start or start >= busy_end):\n                    all_free = False\n                    break\n            if not all_free:\n                break\n        if all_free:\n            return f\"{start // 60:02d}:{end // 60:02d}:{start % 60:02d}:{end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_120"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert all time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = map(time_to_minutes, work_hours.split(':'))\n    duration_minutes = duration * 60\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules.values():\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find available slots by merging busy intervals\n    available_slots = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define the participants' schedules\nparticipants_schedules = {\n    \"Jerry\": [\"11:30:12:00\", \"16:00:16:30\"],\n    \"Benjamin\": [],\n    \"Andrew\": [\"09:30:10:30\", \"11:30:12:30\", \"13:00:13:30\", \"14:00:15:30\"],\n    \"Anna\": [\"09:00:11:30\", \"12:00:12:30\", \"13:00:17:00\"]\n}\n\n# Define meeting duration (in hours) and work hours\nmeeting_duration = 0.5  # half an hour\nwork_hours = \"9:00:17:00\"\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, meeting_duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_121"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:00:15:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, meeting_duration):\n    # Convert time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work hours start at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = 9 + minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    start_work = time_to_minutes(work_hours[0])\n    end_work = time_to_minutes(work_hours[1])\n    duration = meeting_duration * 60\n\n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules.values():\n        for interval in schedule:\n            start = time_to_minutes(interval[0])\n            end = time_to_minutes(interval[1])\n            busy_intervals.append((start, end))\n\n    # Sort all busy intervals\n    busy_intervals.sort()\n\n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find available slots\n    available_slots = []\n    prev_end = start_work\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < end_work:\n        available_slots.append((prev_end, end_work))\n\n    # Check each available slot for sufficient duration\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            meeting_start = minutes_to_time(slot_start)\n            meeting_end = minutes_to_time(slot_start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n\n    return \"No available slot found\"\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nmeeting_duration = 0.5  # half an hour\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"Diana\": [(\"12:00\", \"13:30\"), (\"14:00\", \"15:00\"), (\"16:30\", \"17:00\")],\n    \"Rebecca\": [(\"9:00\", \"9:30\"), (\"10:00\", \"11:30\"), (\"13:00\", \"13:30\"), (\"14:30\", \"15:00\")],\n    \"Madison\": [(\"9:30\", \"10:30\"), (\"11:00\", \"12:30\"), (\"13:30\", \"15:00\"), (\"15:30\", \"16:30\")],\n    \"Carol\": [(\"9:00\", \"9:30\"), (\"10:00\", \"10:30\"), (\"11:00\", \"11:30\"), (\"12:00\", \"14:00\"), (\"14:30\", \"15:00\"), (\"16:00\", \"17:00\")]\n}\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_122"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define each participant's busy times in minutes since midnight\n    # Format: list of (start, end) tuples\n    thomas_busy = []\n    catherine_busy = [(13 * 60, 13 * 60 + 30), (14 * 60, 15 * 60 + 30)]\n    ruth_busy = [(9 * 60 + 30, 14 * 60 + 30), (15 * 60 + 30, 16 * 60 + 30)]\n    andrew_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60 + 30, 16 * 60)\n    ]\n\n    # Combine all busy times and sort them\n    all_busy = thomas_busy + catherine_busy + ruth_busy + andrew_busy\n    all_busy.sort()\n\n    # Find the earliest available slot\n    previous_end = work_start\n    for start, end in all_busy:\n        if start > previous_end and start - previous_end >= meeting_duration:\n            # Found a slot\n            proposed_start = previous_end\n            proposed_end = proposed_start + meeting_duration\n            return f\"{proposed_start // 60:02d}:{proposed_start % 60:02d}:{proposed_end // 60:02d}:{proposed_end % 60:02d}\"\n        previous_end = max(previous_end, end)\n\n    # Check after the last busy slot\n    if work_end - previous_end >= meeting_duration:\n        proposed_start = previous_end\n        proposed_end = proposed_start + meeting_duration\n        return f\"{proposed_start // 60:02d}:{proposed_start % 60:02d}:{proposed_end // 60:02d}:{proposed_end % 60:02d}\"\n\n    # If no slot found (though the problem states one exists)\n    return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_123"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    michael_busy = [(16 * 60, 17 * 60)]\n    hannah_busy = [(9 * 60 + 30, 10 * 60 + 30),\n                   (12 * 60, 12 * 60 + 30),\n                   (13 * 60 + 30, 14 * 60),\n                   (15 * 60 + 30, 16 * 60),\n                   (16 * 60 + 30, 17 * 60)]\n    brenda_busy = [(9 * 60 + 30, 11 * 60 + 30),\n                   (12 * 60, 13 * 60),\n                   (13 * 60 + 30, 14 * 60 + 30),\n                   (15 * 60, 17 * 60)]\n    anthony_busy = [(9 * 60, 11 * 60),\n                    (12 * 60, 12 * 60 + 30),\n                    (13 * 60 + 30, 14 * 60),\n                    (15 * 60 + 30, 16 * 60 + 30)]\n    \n    # Hannah's preference: not before 14:30\n    hannah_preference_start = 14 * 60 + 30\n\n    # Combine all busy slots\n    all_busy = []\n    for person_busy in [michael_busy, hannah_busy, brenda_busy, anthony_busy]:\n        all_busy.extend(person_busy)\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Filter free slots that are >= meeting_duration and after Hannah's preference\n    possible_slots = []\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration and slot_start >= hannah_preference_start:\n            possible_slots.append((slot_start, slot_end))\n    \n    # Select the earliest possible slot\n    if possible_slots:\n        meeting_start = possible_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_124"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define participants' busy times in minutes since midnight\n    jesse_busy = [(12 * 60 + 30, 13 * 60), (15 * 60, 15 * 60 + 30)]\n    alan_busy = [(9 * 60, 9 * 60 + 30), (16 * 60, 16 * 60 + 30)]\n    elijah_busy = [(9 * 60, 12 * 60), (12 * 60 + 30, 13 * 60), (14 * 60, 15 * 60), (15 * 60 + 30, 17 * 60)]\n    amy_busy = [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 12 * 60), (13 * 60, 13 * 60 + 30), (14 * 60, 15 * 60), (16 * 60, 16 * 60 + 30)]\n    \n    # Jesse's constraint: not before 12:30\n    jesse_constraint = 12 * 60 + 30\n    \n    # Meeting duration\n    duration = 30\n    \n    # Combine all busy times\n    all_busy = jesse_busy + alan_busy + elijah_busy + amy_busy\n    \n    # Generate free slots by finding gaps between busy times\n    all_busy.sort()\n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Filter free slots that meet duration and Jesse's constraint\n    valid_slots = []\n    for start, end in free_slots:\n        if end - start >= duration and start >= jesse_constraint:\n            valid_slots.append((start, end))\n    \n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + duration\n        # Format the output as HH:MM:HH:MM\n        return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    else:\n        return \"No valid time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_125"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Define participants' busy times in minutes since midnight\n    lawrence_busy = [(14 * 60, 16 * 60)]\n    sharon_busy = [(10 * 60 + 30, 11 * 60), (12 * 60 + 30, 13 * 60 + 30), (15 * 60, 15 * 60 + 30)]\n    aaron_busy = [(9 * 60 + 30, 11 * 60 + 30), (12 * 60, 14 * 60), (14 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)]\n    amy_busy = [(9 * 60 + 30, 11 * 60), (12 * 60, 13 * 60), (14 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)]\n\n    # Lawrence's preference: not before 13:00\n    preference_start = 13 * 60\n\n    # Combine all busy times\n    all_busy = []\n    for busy in [lawrence_busy, sharon_busy, aaron_busy, amy_busy]:\n        all_busy.extend(busy)\n\n    # Sort busy times by start time\n    all_busy.sort()\n\n    # Find free slots\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check for a 30-minute slot that fits Lawrence's preference\n    meeting_duration = 30\n    for start, end in free_slots:\n        if start >= preference_start:\n            available_start = start\n            available_end = min(end, available_start + meeting_duration)\n            if available_end - available_start >= meeting_duration:\n                # Convert back to HH:MM format\n                start_hh = available_start // 60\n                start_mm = available_start % 60\n                end_hh = (available_start + meeting_duration) // 60\n                end_mm = (available_start + meeting_duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    # If no slot found after preference, check before (though Lawrence prefers not)\n    for start, end in free_slots:\n        available_start = start\n        available_end = min(end, available_start + meeting_duration)\n        if available_end - available_start >= meeting_duration:\n            start_hh = available_start // 60\n            start_mm = available_start % 60\n            end_hh = (available_start + meeting_duration) // 60\n            end_mm = (available_start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_126"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert each participant's busy slots to minutes\n    # Kathleen: 13:00-14:00, 15:00-15:30, 16:00-16:30\n    kathleen_busy = [\n        (13 * 60, 14 * 60),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    # Kathleen doesn't want to meet before 13:30\n    kathleen_min_start = 13 * 60 + 30\n\n    # Frank: no meetings\n    frank_busy = []\n\n    # Christopher: 9:00-9:30, 10:00-11:30, 13:30-14:00, 15:30-17:00\n    christopher_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 11 * 60 + 30),\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n\n    # Kathryn: 9:00-10:00, 10:30-11:30, 12:30-13:00, 13:30-14:00, 14:30-15:00, 15:30-17:00\n    kathryn_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n\n    # Combine all busy slots for all participants\n    all_busy = kathleen_busy + frank_busy + christopher_busy + kathryn_busy\n\n    # Generate free slots by inverting busy slots within work hours\n    free_slots = []\n    previous_end = work_start\n    for start, end in sorted(all_busy):\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that is at least 30 minutes and meets Kathleen's constraint\n    meeting_duration = 30\n    for start, end in free_slots:\n        slot_start = max(start, kathleen_min_start)\n        if slot_start + meeting_duration <= end:\n            # Convert back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = (slot_start + meeting_duration) // 60\n            end_mm = (slot_start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_127"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Define participants' schedules and constraints\n    # Each entry is a list of (start, end) in minutes\n    catherine = [\n        (9 * 60, 10 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    harold = [\n        (12 * 60 + 30, 13 * 60),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    ann = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60, 15 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    randy = [\n        (9 * 60, 12 * 60),\n        (13 * 60, 14 * 60),\n        (14 * 60 + 30, 15 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n\n    # Harold cannot meet before 14:00\n    harold_constraint = 14 * 60\n\n    # Meeting duration is 30 minutes\n    duration = 30\n\n    # Combine all busy times and sort them\n    all_busy = []\n    for person in [catherine, harold, ann, randy]:\n        all_busy.extend(person)\n    all_busy.sort()\n\n    # Find available slots by checking gaps between busy times\n    available_slots = []\n    prev_end = work_start\n\n    for start, end in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n\n    if work_end > prev_end:\n        available_slots.append((prev_end, work_end))\n\n    # Filter slots that are >= duration and after Harold's constraint\n    possible_slots = []\n    for start, end in available_slots:\n        if end - start >= duration and start >= harold_constraint:\n            possible_slots.append((start, end))\n\n    # The first suitable slot is the earliest possible\n    if possible_slots:\n        meeting_start = possible_slots[0][0]\n        meeting_end = meeting_start + duration\n        # Format the output as HH:MM:HH:MM\n        return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_128"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    start_hour, end_hour = work_hours\n    # Convert work hours to minutes for easier calculation\n    work_start = start_hour * 60\n    work_end = end_hour * 60\n    \n    # Initialize a list to keep track of busy times for all participants\n    busy_times = []\n    \n    for schedule in participants_schedules:\n        personal_busy = []\n        for meeting in schedule:\n            start, end = meeting\n            start_min = start[0] * 60 + start[1]\n            end_min = end[0] * 60 + end[1]\n            personal_busy.append((start_min, end_min))\n        busy_times.append(personal_busy)\n    \n    # Check all possible time slots within work hours\n    for time in range(work_start, work_end - duration + 1):\n        end_time = time + duration\n        # Check if the time slot is free for all participants\n        all_free = True\n        for personal_busy in busy_times:\n            free = True\n            for (busy_start, busy_end) in personal_busy:\n                if not (end_time <= busy_start or time >= busy_end):\n                    free = False\n                    break\n            if not free:\n                all_free = False\n                break\n        if all_free:\n            # Convert back to HH:MM format\n            start_hh = time // 60\n            start_mm = time % 60\n            end_hh = end_time // 60\n            end_mm = end_time % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No available time slot found\"\n\n# Define the participants' schedules\njacqueline = [\n    ((10, 0), (10, 30)),\n    ((11, 0), (11, 30)),\n    ((12, 30), (13, 0)),\n    ((14, 0), (15, 0)),\n    ((16, 0), (16, 30))\n]\nadam = []\ngerald = [\n    ((9, 0), (11, 0)),\n    ((11, 30), (12, 0)),\n    ((14, 0), (15, 0)),\n    ((15, 30), (17, 0))\n]\nwayne = [\n    ((9, 0), (10, 0)),\n    ((10, 30), (11, 30)),\n    ((13, 0), (15, 0)),\n    ((15, 30), (16, 0)),\n    ((16, 30), (17, 0))\n]\n\nparticipants_schedules = [jacqueline, adam, gerald, wayne]\nmeeting_duration = 30  # minutes\nwork_hours = (9, 17)   # 9:00 to 17:00\n\n# Find the earliest available time\nmeeting_time = find_meeting_time(participants_schedules, meeting_duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_129"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals\n    busy_intervals = []\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals_sorted = sorted(busy_intervals, key=lambda x: x[0])\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals_sorted:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\njohn_schedule = [\n    \"9:00 to 9:30\",\n    \"10:00 to 10:30\",\n    \"11:00 to 11:30\",\n    \"13:00 to 14:30\"\n]\n\nralph_schedule = [\n    \"13:30 to 14:00\",\n    \"14:30 to 15:00\",\n    \"15:30 to 16:30\"\n]\n\ndaniel_schedule = [\n    \"9:00 to 9:30\",\n    \"10:30 to 11:00\",\n    \"12:00 to 13:00\",\n    \"13:30 to 16:30\"\n]\n\nkeith_schedule = [\n    \"10:30 to 14:30\",\n    \"15:00 to 17:00\"\n]\n\nparticipants_schedules = [john_schedule, ralph_schedule, daniel_schedule, keith_schedule]\nmeeting_duration = 30  # minutes\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, meeting_duration, work_hours_start, work_hours_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_130"
        },
        {
            "final_program_time": "{15:30:16:30}",
            "expected_time": "{15:30:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert all time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work_hours start at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = 9 + minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    start_work = time_to_minutes(work_hours[0])\n    end_work = time_to_minutes(work_hours[1]) - duration  # Latest possible start time\n\n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy_intervals in participants_busy.values():\n        for interval in busy_intervals:\n            start, end = interval.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            all_busy.append((start_min, end_min))\n\n    # Sort all busy intervals by start time\n    all_busy.sort()\n\n    # Find the first available slot\n    current_time = start_work\n    for start, end in all_busy:\n        if start > current_time and start - current_time >= duration:\n            # Found a slot\n            meeting_end = current_time + duration\n            return f\"{minutes_to_time(current_time)}:{minutes_to_time(meeting_end)}\"\n        current_time = max(current_time, end)\n    \n    # Check after the last busy interval\n    if current_time <= end_work:\n        meeting_end = current_time + duration\n        return f\"{minutes_to_time(current_time)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' busy times\nparticipants_busy = {\n    \"Walter\": [\"9:30 to 10:00\", \"13:00 to 13:30\"],\n    \"Jacob\": [\"11:00 to 11:30\", \"13:00 to 13:30\"],\n    \"Jennifer\": [\"9:30 to 10:30\", \"11:30 to 12:00\", \"12:30 to 15:00\"],\n    \"Joan\": [\"9:30 to 10:00\", \"10:30 to 11:30\", \"12:00 to 12:30\", \"13:00 to 14:00\", \"14:30 to 15:30\"],\n}\n\n# Work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 60  # minutes\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_131"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:30:10:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, duration_minutes, work_start, work_end):\n    # Convert all times to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration = duration_minutes\n    \n    # Collect all busy time slots\n    all_busy_slots = []\n    for busy_slots in participants_busy_times.values():\n        for slot in busy_slots:\n            start, end = map(time_to_minutes, slot.split(':'))\n            all_busy_slots.append((start, end))\n    \n    # Sort the busy slots by start time\n    all_busy_slots_sorted = sorted(all_busy_slots, key=lambda x: x[0])\n    \n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    prev_end = work_start_min\n    \n    for start, end in all_busy_slots_sorted:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        free_slots.append((prev_end, work_end_min))\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' busy times\nparticipants_busy_times = {\n    \"Diana\": [\"10:30:11:00\", \"12:30:13:00\", \"14:30:15:00\", \"15:30:16:00\"],\n    \"Harold\": [\"10:00:11:00\", \"11:30:16:30\"],\n    \"Philip\": [\"09:00:09:30\", \"10:30:12:00\", \"12:30:13:30\", \"14:00:17:00\"],\n    \"Joe\": []  # Joe has no busy times\n}\n\n# Parameters\nduration_minutes = 30\nwork_start = \"09:00\"\nwork_end = \"17:00\"\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, duration_minutes, work_start, work_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_132"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours_start, work_hours_end, duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n\n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy_intervals in participants_busy.values():\n        for interval in busy_intervals:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n\n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n\n    # Check each free interval for availability of duration\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' busy times\nparticipants_busy = {\n    \"Janice\": [\"11:30 to 12:30\"],\n    \"Isabella\": [],\n    \"Linda\": [\"9:30 to 11:30\", \"12:00 to 13:00\", \"13:30 to 16:30\"],\n    \"Billy\": [\"9:00 to 9:30\", \"10:30 to 11:30\", \"13:30 to 14:00\", \"14:30 to 16:00\", \"16:30 to 17:00\"]\n}\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30  # half an hour\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_133"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:13:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = work_hours\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start_min, work_end_min)]\n    \n    # Subtract busy slots from free slots for each participant\n    for person, busy_slots in participants_busy.items():\n        new_free_slots = []\n        for free_start, free_end in free_slots:\n            current_start = free_start\n            for busy_start, busy_end in busy_slots:\n                busy_start_min = time_to_minutes(busy_start)\n                busy_end_min = time_to_minutes(busy_end)\n                if busy_start_min >= free_end:\n                    break\n                if busy_end_min <= free_start:\n                    continue\n                if current_start < busy_start_min:\n                    new_free_slots.append((current_start, busy_start_min))\n                current_start = max(current_start, busy_end_min)\n            if current_start < free_end:\n                new_free_slots.append((current_start, free_end))\n        free_slots = new_free_slots\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_end = slot_start + duration_min\n            return f\"{minutes_to_time(slot_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 0.5  # half an hour\n\n# Define busy slots for each participant\nparticipants_busy = {\n    \"Alice\": [\n        (\"10:00\", \"10:30\"),\n        (\"14:30\", \"15:00\"),\n        (\"15:30\", \"16:30\")\n    ],\n    \"Charlotte\": [],\n    \"Stephanie\": [\n        (\"9:00\", \"9:30\"),\n        (\"10:30\", \"11:00\"),\n        (\"11:30\", \"13:00\"),\n        (\"13:30\", \"14:30\"),\n        (\"15:00\", \"15:30\")\n    ],\n    \"Ethan\": [\n        (\"9:00\", \"12:00\"),\n        (\"12:30\", \"13:00\"),\n        (\"13:30\", \"14:30\"),\n        (\"15:00\", \"15:30\"),\n        (\"16:00\", \"17:00\")\n    ]\n}\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_134"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    # Eric is free all day\n    eric_busy = []\n    \n    # Ashley's busy slots: 10:00-10:30, 11:00-12:00, 12:30-13:00, 15:00-16:00\n    ashley_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (15 * 60, 16 * 60)\n    ]\n    \n    # Ronald's busy slots: 9:00-9:30, 10:00-11:30, 12:30-14:00, 14:30-17:00\n    ronald_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 17 * 60)\n    ]\n    \n    # Larry's busy slots: 9:00-12:00, 13:00-17:00\n    larry_busy = [\n        (9 * 60, 12 * 60),\n        (13 * 60, 17 * 60)\n    ]\n    \n    # Combine all busy slots\n    all_busy = []\n    for person_busy in [eric_busy, ashley_busy, ronald_busy, larry_busy]:\n        all_busy.extend(person_busy)\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can fit the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_135"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' schedules and constraints\n    diana_busy = [(10*60+30, 11*60), (11*60+30, 12*60), (13*60+30, 14*60), (14*60+30, 15*60), (16*60, 17*60)]\n    diana_constraint = 9 * 60 + 30  # Cannot meet before 9:30\n\n    gerald_busy = [(9*60+30, 10*60), (12*60+30, 13*60), (15*60, 15*60+30), (16*60, 16*60+30)]\n\n    timothy_busy = [(10*60, 12*60), (12*60+30, 14*60), (14*60+30, 15*60), (16*60, 17*60)]\n\n    julie_busy = [(9*60+30, 10*60), (10*60+30, 11*60), (11*60+30, 15*60+30), (16*60, 17*60)]\n\n    # Combine all busy times\n    all_busy = []\n    for busy in [diana_busy, gerald_busy, timothy_busy, julie_busy]:\n        all_busy.extend(busy)\n\n    # Sort all busy times by start time\n    all_busy.sort()\n\n    # Find available slots\n    available_slots = []\n    prev_end = max(work_start, diana_constraint)\n\n    for start, end in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Find the first available slot that is at least 30 minutes\n    meeting_duration = 30\n    for slot in available_slots:\n        start, end = slot\n        if end - start >= meeting_duration:\n            # Convert start time to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_time = start + meeting_duration\n            end_hh = end_time // 60\n            end_mm = end_time % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_136"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy times in minutes (start, end)\n    rebecca_busy = [(10*60 + 30, 11*60), (12*60 + 30, 13*60)]\n    donald_busy = [(12*60, 12*60 + 30), (15*60, 15*60 + 30)]\n    diana_busy = [(9*60 + 30, 11*60), (12*60 + 30, 13*60), (13*60 + 30, 14*60), (14*60 + 30, 17*60)]\n    jesse_busy = [(9*60 + 30, 12*60 + 30), (13*60, 13*60 + 30), (14*60 + 30, 15*60), (16*60, 17*60)]\n    \n    # Diana cannot meet before 14:00\n    diana_min_time = 14 * 60\n    \n    # Combine all busy times\n    all_busy = rebecca_busy + donald_busy + diana_busy + jesse_busy\n    \n    # Sort busy times by start time\n    all_busy.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = work_start\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > prev_end:\n            free_slots.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Filter free slots that are at least 30 minutes and after Diana's min time\n    possible_slots = []\n    for start, end in free_slots:\n        if end - start >= 30 and start >= diana_min_time:\n            possible_slots.append((start, end))\n    \n    # Select the earliest possible slot\n    if possible_slots:\n        meeting_start = possible_slots[0][0]\n        meeting_end = meeting_start + 30\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_137"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' busy times in minutes since midnight\n    # Juan is free all day\n    emma_busy = [(9 * 60 + 30, 10 * 60 + 30), (12 * 60 + 30, 13 * 60 + 30)]\n    gloria_busy = [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), \n                    (11 * 60, 11 * 60 + 30), (12 * 60 + 30, 14 * 60),\n                    (16 * 60, 17 * 60)]\n    joan_busy = [(9 * 60, 9 * 60 + 30), (10 * 60, 12 * 60), \n                 (13 * 60, 14 * 60), (14 * 60 + 30, 17 * 60)]\n    \n    # Emma cannot meet before 12:30\n    emma_constraint = 12 * 60 + 30\n\n    # Combine all busy times and sort them\n    all_busy = emma_busy + gloria_busy + joan_busy\n    all_busy.sort()\n\n    # Initialize candidate start time\n    candidate_start = max(work_start, emma_constraint)\n\n    # Check for available slots\n    for busy_start, busy_end in all_busy:\n        if busy_start > candidate_start:\n            # Check if there's enough time before the next busy period\n            if busy_start - candidate_start >= 30:\n                # Format the time as HH:MM:HH:MM\n                start_hh = candidate_start // 60\n                start_mm = candidate_start % 60\n                end_hh = (candidate_start + 30) // 60\n                end_mm = (candidate_start + 30) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n        # Update candidate_start to the end of the current busy period\n        candidate_start = max(candidate_start, busy_end)\n    \n    # Check after the last busy period\n    if work_end - candidate_start >= 30:\n        start_hh = candidate_start // 60\n        start_mm = candidate_start % 60\n        end_hh = (candidate_start + 30) // 60\n        end_mm = (candidate_start + 30) % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_138"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours_start='9:00', work_hours_end='17:00'):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            all_busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_intervals = []\n    for start, end in all_busy_intervals:\n        if not merged_intervals:\n            merged_intervals.append([start, end])\n        else:\n            last_start, last_end = merged_intervals[-1]\n            if start <= last_end:\n                merged_intervals[-1][1] = max(end, last_end)\n            else:\n                merged_intervals.append([start, end])\n    \n    # Find the earliest available slot\n    prev_end = work_start\n    for start, end in merged_intervals:\n        if start - prev_end >= duration_minutes:\n            # Found a slot\n            meeting_start = prev_end\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n        prev_end = max(prev_end, end)\n    \n    # Check after the last busy interval\n    if work_end - prev_end >= duration_minutes:\n        meeting_start = prev_end\n        meeting_end = meeting_start + duration_minutes\n        def minutes_to_time(minutes):\n            hh = minutes // 60\n            mm = minutes % 60\n            return f\"{hh:02d}:{mm:02d}\"\n        return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"9:00 to 9:30\", \"12:00 to 12:30\", \"13:00 to 14:00\"],  # Jose\n    [\"10:30 to 11:00\", \"12:30 to 13:30\", \"14:30 to 15:00\"],  # Sean\n    [\"9:00 to 9:30\", \"10:00 to 11:30\", \"13:00 to 13:30\", \"14:00 to 14:30\", \"15:00 to 17:00\"],  # Denise\n    [\"9:00 to 10:00\", \"10:30 to 11:30\", \"12:00 to 17:00\"]  # Amanda\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_139"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    start_hour, end_hour = work_hours\n    # Convert work hours to minutes\n    start_time = start_hour * 60\n    end_time = end_hour * 60\n    \n    # Initialize a list to keep track of busy times for all participants\n    busy_times = []\n    \n    for schedule in participants_schedules:\n        for block in schedule:\n            start_block = block[0] * 60 + block[1]\n            end_block = block[2] * 60 + block[3]\n            busy_times.append((start_block, end_block))\n    \n    # Sort all busy times by start time\n    busy_times.sort()\n    \n    # Find all free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = start_time\n    \n    for start, end in busy_times:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy time\n    if previous_end < end_time:\n        free_slots.append((previous_end, end_time))\n    \n    # Now, merge overlapping or adjacent busy times to find common free slots\n    # But since we have all busy times, we can directly look for gaps >= duration\n    # in the merged busy times\n    merged_busy = []\n    for start, end in busy_times:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Now find free slots between merged busy times\n    common_free_slots = []\n    previous_end = start_time\n    \n    for start, end in merged_busy:\n        if start > previous_end:\n            common_free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy time\n    if previous_end < end_time:\n        common_free_slots.append((previous_end, end_time))\n    \n    # Now find the first slot that can fit the duration\n    for slot in common_free_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration * 60:\n            # Found a suitable slot\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration * 60\n            # Convert back to hours and minutes\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules in terms of (HH, MM, HH, MM) blocks\nwillie_schedule = [\n    (12, 0, 12, 30),\n    (15, 30, 16, 0)\n]\n\ncharlotte_schedule = [\n    (9, 30, 10, 0),\n    (14, 0, 14, 30),\n    (15, 0, 16, 0)\n]\n\nnoah_schedule = [\n    (10, 0, 10, 30),\n    (11, 0, 12, 0),\n    (13, 0, 15, 0),\n    (15, 30, 17, 0)\n]\n\nevelyn_schedule = [\n    (9, 0, 10, 0),\n    (10, 30, 11, 30),\n    (13, 30, 16, 0),\n    (16, 30, 17, 0)\n]\n\n# Combine all schedules\nall_schedules = [\n    willie_schedule,\n    charlotte_schedule,\n    noah_schedule,\n    evelyn_schedule\n]\n\n# Meeting duration in hours\nduration = 0.5  # half an hour\n\n# Work hours from 9:00 to 17:00\nwork_hours = (9, 17)\n\n# Find the meeting time\nmeeting_time = find_meeting_time(all_schedules, duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_140"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:00:15:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m - 540  # 540 minutes = 9:00\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        h = (minutes + 540) // 60\n        m = (minutes + 540) % 60\n        return f\"{h:02d}:{m:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    start_min = time_to_minutes(start_work)\n    end_min = time_to_minutes(end_work)\n    \n    # Initialize a list to track busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = busy.split(' to ')\n            start_busy = time_to_minutes(start)\n            end_busy = time_to_minutes(end)\n            busy_intervals.append((start_busy, end_busy))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = start_min\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < end_min:\n        free_intervals.append((prev_end, end_min))\n    \n    # Check each free interval for a slot that fits the meeting duration\n    duration_min = duration * 60  # Convert hours to minutes\n    for start, end in free_intervals:\n        if end - start >= duration_min:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration_min)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nlinda_schedule = [\n    \"10:00 to 11:30\",\n    \"12:00 to 12:30\",\n    \"13:00 to 14:00\"\n]\n\nsamantha_schedule = [\n    \"10:30 to 11:00\",\n    \"16:00 to 16:30\"\n]\n\nralph_schedule = [\n    \"9:00 to 10:00\",\n    \"10:30 to 12:00\",\n    \"12:30 to 13:30\",\n    \"14:00 to 15:00\",\n    \"16:30 to 17:00\"\n]\n\nkatherine_schedule = [\n    \"10:00 to 12:30\",\n    \"13:30 to 14:00\",\n    \"14:30 to 15:00\",\n    \"15:30 to 16:00\"\n]\n\nparticipants_schedules = [\n    linda_schedule,\n    samantha_schedule,\n    ralph_schedule,\n    katherine_schedule\n]\n\n# Find a 30-minute meeting time between 9:00 to 17:00\nmeeting_time = find_meeting_time(participants_schedules, 0.5, \"9:00 to 17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_141"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define each person's blocked times in minutes (start, end)\n    richard_blocked = [(9 * 60, 10 * 60)]\n    sarah_blocked = [(11 * 60, 11 * 60 + 30), (14 * 60, 14 * 60 + 30)]\n    gloria_blocked = [(9 * 60, 12 * 60 + 30), (13 * 60 + 30, 14 * 60), \n                      (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60)]\n    kathleen_blocked = [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 11 * 60),\n                        (12 * 60, 12 * 60 + 30), (13 * 60 + 30, 15 * 60 + 30),\n                        (16 * 60, 16 * 60 + 30)]\n\n    # Gloria's preference: not before 14:30\n    gloria_preference_start = 14 * 60 + 30\n\n    # Combine all blocked times\n    all_blocked = []\n    all_blocked.extend([(start, end, \"Richard\") for start, end in richard_blocked])\n    all_blocked.extend([(start, end, \"Sarah\") for start, end in sarah_blocked])\n    all_blocked.extend([(start, end, \"Gloria\") for start, end in gloria_blocked])\n    all_blocked.extend([(start, end, \"Kathleen\") for start, end in kathleen_blocked])\n\n    # Sort blocked times by start time\n    all_blocked.sort()\n\n    # Find available slots\n    available_slots = []\n    current_time = max(work_start, gloria_preference_start)\n\n    while current_time + meeting_duration <= work_end:\n        slot_available = True\n        slot_end = current_time + meeting_duration\n\n        for blocked_start, blocked_end, person in all_blocked:\n            if not (slot_end <= blocked_start or current_time >= blocked_end):\n                slot_available = False\n                current_time = blocked_end\n                break\n\n        if slot_available:\n            available_slots.append((current_time, slot_end))\n            current_time = slot_end\n        else:\n            # Move to the next possible start time\n            pass\n\n    if not available_slots:\n        return \"No available time slot found.\"\n\n    # Select the first available slot\n    meeting_start, meeting_end = available_slots[0]\n\n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n\n    start_time = minutes_to_time(meeting_start)\n    end_time = minutes_to_time(meeting_end)\n\n    return f\"{start_time}:{end_time}\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_142"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define busy intervals in minutes for each participant\n    marilyn_busy = [(9 * 60, 10 * 60)]\n    timothy_busy = [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30)]\n    peter_busy = [(9 * 60 + 30, 12 * 60 + 30), (13 * 60, 14 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)]\n    patrick_busy = [(9 * 60, 10 * 60), (11 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60, 15 * 60)]\n    \n    # Peter's preference: avoid meetings before 14:30\n    peter_preference_start = 14 * 60 + 30\n    \n    # Combine all busy intervals\n    all_busy = marilyn_busy + timothy_busy + peter_busy + patrick_busy\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by checking gaps between busy intervals\n    free_intervals = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the interval after the last busy interval\n    if previous_end < work_end:\n        free_intervals.append((previous_end, work_end))\n    \n    # Filter free intervals that are at least 30 minutes and after Peter's preference\n    meeting_duration = 30\n    suitable_intervals = []\n    \n    for start, end in free_intervals:\n        if end - start >= meeting_duration and start >= peter_preference_start:\n            suitable_intervals.append((start, end))\n    \n    # Select the earliest suitable interval\n    if suitable_intervals:\n        meeting_start = suitable_intervals[0][0]\n        meeting_end = meeting_start + meeting_duration\n    else:\n        # If no interval after preference, check all free intervals (though problem states solution exists)\n        for start, end in free_intervals:\n            if end - start >= meeting_duration:\n                meeting_start = start\n                meeting_end = meeting_start + meeting_duration\n                break\n    \n    # Format the output\n    start_hh = meeting_start // 60\n    start_mm = meeting_start % 60\n    end_hh = meeting_end // 60\n    end_mm = meeting_end % 60\n    \n    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_143"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:00:12:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 9:00 (0 minutes)\n    \n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Initialize the free slots for all participants\n    free_slots = []\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = busy.split(' to ')\n            busy_start = time_to_minutes(start)\n            busy_end = time_to_minutes(end)\n            busy_slots.append((busy_start, busy_end))\n        \n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Calculate free slots\n        current_time = work_start\n        free = []\n        for start, end in busy_slots:\n            if start > current_time:\n                free.append((current_time, start))\n            current_time = max(current_time, end)\n        if current_time < work_end:\n            free.append((current_time, work_end))\n        \n        free_slots.append(free)\n    \n    # Find intersection of all free slots\n    common_free = free_slots[0]\n    for slots in free_slots[1:]:\n        new_common = []\n        i = j = 0\n        while i < len(common_free) and j < len(slots):\n            start1, end1 = common_free[i]\n            start2, end2 = slots[j]\n            \n            # Find overlap\n            start = max(start1, start2)\n            end = min(end1, end2)\n            if start < end:\n                new_common.append((start, end))\n            \n            # Move the pointer which ends first\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free = new_common\n    \n    # Find the first slot that can fit the duration\n    duration_min = duration * 60\n    for start, end in common_free:\n        if end - start >= duration_min:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration_min)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Diane is free all day\n    [\"10:30 to 11:00\", \"16:00 to 16:30\"],  # Olivia\n    [\"9:00 to 9:30\", \"10:30 to 12:00\", \"12:30 to 15:00\", \"15:30 to 17:00\"],  # Vincent\n    [\"9:00 to 10:30\", \"11:00 to 12:00\", \"12:30 to 17:00\"],  # Steven\n]\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nduration = 0.5  # half hour\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_144"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_work, end_work = work_hours\n    # Convert time to minutes for easier calculation\n    start_min = start_work[0] * 60 + start_work[1]\n    end_min = end_work[0] * 60 + end_work[1]\n    \n    # Initialize a list to track busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for meeting in schedule:\n            start_meet = meeting[0][0] * 60 + meeting[0][1]\n            end_meet = meeting[1][0] * 60 + meeting[1][1]\n            busy_intervals.append((start_meet, end_meet))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append(interval)\n    \n    # Find available slots by checking gaps between merged intervals and work hours\n    available_slots = []\n    prev_end = start_min\n    \n    for interval in merged:\n        current_start, current_end = interval\n        if current_start > prev_end:\n            available_slots.append((prev_end, current_start))\n        prev_end = max(prev_end, current_end)\n    \n    # Check the time after the last meeting until end of work day\n    if prev_end < end_min:\n        available_slots.append((prev_end, end_min))\n    \n    # Check each available slot for duration\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            # Convert back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = (slot_start + duration) // 60\n            end_mm = (slot_start + duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available slot found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours = ((9, 0), (17, 0))\n\n# Define participants' schedules in HH:MM format converted to tuples\nparticipants_schedules = [\n    [],  # Marilyn has no meetings\n    [((10, 30), (11, 0)), ((12, 0), (12, 30)), ((13, 0), (13, 30)), ((16, 0), (16, 30))],  # Carolyn\n    [((10, 30), (12, 0)), ((13, 0), (14, 30)), ((15, 30), (16, 30))],  # Charles\n    [((9, 30), (13, 0)), ((13, 30), (17, 0))]  # Lori\n]\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_145"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 9:00 (0 minutes)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = (minutes + 540) // 60\n        mm = (minutes + 540) % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = work_hours.split(' to ')\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Initialize a list to track busy intervals for all participants\n    all_busy = []\n    \n    for person, schedules in participants_schedules.items():\n        for interval in schedules:\n            start, end = interval.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            all_busy.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start_min\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n    \n    # Check each free interval for availability of duration\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_end = start + duration\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    'Anna': ['9:00 to 9:30', '10:30 to 11:00', '12:00 to 12:30', '14:30 to 15:00', '16:00 to 17:00'],\n    'Dennis': ['12:00 to 13:30', '15:00 to 15:30'],\n    'Zachary': ['9:00 to 10:30', '12:00 to 12:30', '13:00 to 17:00'],\n    'Bobby': ['9:30 to 11:00', '11:30 to 12:00', '12:30 to 14:30', '15:00 to 17:00']\n}\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_hours = '9:00 to 17:00'\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, duration, work_hours))\n```",
            "count": "calendar_scheduling_example_146"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define busy intervals in minutes for each participant\n    busy_intervals = {\n        'Janice': [(9 * 60, 9 * 60 + 30), (15 * 60, 16 * 60 + 30)],\n        'Alexander': [(9 * 60, 9 * 60 + 30), (10 * 60, 12 * 60 + 30), \n                     (13 * 60, 14 * 60), (14 * 60 + 30, 15 * 60 + 30), \n                     (16 * 60, 17 * 60)],\n        'Thomas': [(9 * 60, 11 * 60), (13 * 60, 13 * 60 + 30), \n                   (14 * 60 + 30, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n    }\n\n    # Alexander doesn't want to meet before 13:00\n    alexander_constraint = 13 * 60\n\n    # Meeting duration is 30 minutes\n    duration = 30\n\n    # Generate all busy intervals for all participants\n    all_busy = []\n    for person, intervals in busy_intervals.items():\n        for start, end in intervals:\n            all_busy.append((start, end))\n    # Add Alexander's constraint as a busy interval before 13:00\n    all_busy.append((work_start, alexander_constraint))\n\n    # Sort all busy intervals by start time\n    all_busy.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_end = max(end, last_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find available slots between work hours and busy intervals\n    available = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n\n    # Find the first available slot that can fit the meeting\n    for start, end in available:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No available time slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_147"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define each person's busy times in minutes since midnight\n    # Format: (start, end)\n    deborah_busy = [\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (16 * 60, 17 * 60)\n    ]\n    samuel_busy = [\n        (11 * 60 + 30, 12 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    betty_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 14 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n    stephen_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (13 * 60, 15 * 60),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    stephen_constraint = 14 * 60  # Cannot meet before 14:00\n\n    # Combine all busy times\n    all_busy = []\n    for busy in [deborah_busy, samuel_busy, betty_busy, stephen_busy]:\n        all_busy.extend(busy)\n\n    # Sort all busy times by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy times and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Now check each free slot for availability for all participants\n    # Also respect Stephen's constraint\n    potential_slots = []\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            actual_start = max(slot_start, stephen_constraint)\n            if actual_start + meeting_duration <= slot_end:\n                potential_slots.append((actual_start, actual_start + meeting_duration))\n\n    # Now check each potential slot against individual calendars\n    valid_slots = []\n    for slot_start, slot_end in potential_slots:\n        valid = True\n        # Check Deborah\n        for start, end in deborah_busy:\n            if not (slot_end <= start or slot_start >= end):\n                valid = False\n                break\n        if not valid:\n            continue\n        # Check Samuel\n        for start, end in samuel_busy:\n            if not (slot_end <= start or slot_start >= end):\n                valid = False\n                break\n        if not valid:\n            continue\n        # Check Betty\n        for start, end in betty_busy:\n            if not (slot_end <= start or slot_start >= end):\n                valid = False\n                break\n        if not valid:\n            continue\n        # Check Stephen\n        for start, end in stephen_busy:\n            if not (slot_end <= start or slot_start >= end):\n                valid = False\n                break\n        if valid and slot_start >= stephen_constraint:\n            valid_slots.append((slot_start, slot_end))\n\n    if valid_slots:\n        # Return the first valid slot\n        best_slot = valid_slots[0]\n        start_h = best_slot[0] // 60\n        start_m = best_slot[0] % 60\n        end_h = best_slot[1] // 60\n        end_m = best_slot[1] % 60\n        return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    else:\n        return \"No valid slot found\"\n\n# Execute and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_148"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Parse work hours\n    work_start, work_end = [int(time.replace(':', '')) for time in work_hours.split(' to ')]\n    \n    # Initialize available slots for each participant\n    available_slots = []\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = [int(time.replace(':', '')) for time in busy.split(' to ')]\n            busy_slots.append((start, end))\n        # Sort busy slots\n        busy_slots.sort()\n        # Generate free slots\n        free_slots = []\n        prev_end = work_start\n        for start, end in busy_slots:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        available_slots.append(free_slots)\n    \n    # Find overlapping free slots\n    common_slots = available_slots[0]\n    for slots in available_slots[1:]:\n        new_common_slots = []\n        i = j = 0\n        while i < len(common_slots) and j < len(slots):\n            slot_start = max(common_slots[i][0], slots[j][0])\n            slot_end = min(common_slots[i][1], slots[j][1])\n            if slot_start < slot_end:\n                new_common_slots.append((slot_start, slot_end))\n            if common_slots[i][1] < slots[j][1]:\n                i += 1\n            else:\n                j += 1\n        common_slots = new_common_slots\n    \n    # Find first slot that can accommodate the meeting duration\n    duration_mins = duration * 100  # Convert to HHMM format (e.g., 0.5 hours -> 30 mins -> 0030)\n    for slot in common_slots:\n        slot_duration = slot[1] - slot[0]\n        if slot_duration >= duration_mins:\n            start_time = f\"{slot[0] // 100:02d}:{slot[0] % 100:02d}\"\n            end_time = f\"{(slot[0] + duration_mins) // 100:02d}:{(slot[0] + duration_mins) % 100:02d}\"\n            return f\"{start_time}:{end_time}\"\n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Diane has no meetings\n    [],  # Russell has no meetings\n    [\"09:00 to 10:00\", \"10:30 to 11:30\", \"12:00 to 13:00\", \"13:30 to 14:00\", \"14:30 to 17:00\"],  # Kathryn\n    [\"09:00 to 09:30\", \"10:00 to 11:00\", \"11:30 to 12:30\", \"14:00 to 15:30\", \"16:00 to 17:00\"]   # Joshua\n]\n\n# Define meeting duration in hours\nduration = 0.5  # half an hour\n\n# Define work hours\nwork_hours = \"9:00 to 17:00\"\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, duration, work_hours))\n```",
            "count": "calendar_scheduling_example_149"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, duration, work_hours):\n    # Convert all time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours\n    start_min = time_to_minutes(start_work)\n    end_min = time_to_minutes(end_work)\n    \n    # Generate all possible slots within work hours\n    possible_slots = []\n    current_min = start_min\n    while current_min + duration <= end_min:\n        possible_slots.append((current_min, current_min + duration))\n        current_min += 1  # Check every minute\n    \n    # Check each slot against all participants' busy times\n    for slot_start, slot_end in possible_slots:\n        slot_valid = True\n        for busy_list in participants_busy:\n            for busy_start, busy_end in busy_list:\n                busy_start_min = time_to_minutes(busy_start)\n                busy_end_min = time_to_minutes(busy_end)\n                # Check if slot overlaps with any busy time\n                if not (slot_end <= busy_start_min or slot_start >= busy_end_min):\n                    slot_valid = False\n                    break\n            if not slot_valid:\n                break\n        if slot_valid:\n            return f\"{minutes_to_time(slot_start)}:{minutes_to_time(slot_end)}\"\n    return \"No suitable time found\"\n\n# Define participants' busy times\nparticipants_busy = [\n    [],  # Andrew has no meetings\n    [(\"09:30\", \"10:00\"), (\"12:00\", \"12:30\"), (\"14:00\", \"14:30\"), (\"15:30\", \"16:00\")],  # Dennis\n    [(\"09:30\", \"11:00\"), (\"11:30\", \"12:30\"), (\"14:00\", \"15:00\"), (\"16:00\", \"16:30\")],  # Nancy\n    [(\"09:00\", \"09:30\"), (\"10:30\", \"11:30\"), (\"12:00\", \"12:30\"), (\"14:00\", \"15:30\"), (\"16:30\", \"17:00\")],  # Alexander\n]\n\n# Meeting duration in minutes\nduration = 30  # half an hour\n\n# Work hours\nwork_hours = (\"09:00\", \"17:00\")\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, duration, work_hours))\n```",
            "count": "calendar_scheduling_example_150"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' busy times in minutes since midnight\n    peter_busy = []\n    patricia_busy = [(11 * 60, 11 * 60 + 30), (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60), (16 * 60, 16 * 60 + 30)]\n    megan_busy = [(9 * 60, 10 * 60 + 30), (11 * 60, 12 * 60), (12 * 60 + 30, 14 * 60 + 30), (15 * 60, 16 * 60 + 30)]\n    amber_busy = [(9 * 60 + 30, 10 * 60 + 30), (11 * 60, 13 * 60), (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60)]\n\n    # Megan cannot meet before 11:00\n    megan_constraint = 11 * 60\n\n    # Combine all busy times\n    all_busy = peter_busy + patricia_busy + megan_busy + amber_busy\n    all_busy.sort()\n\n    # Find available slots\n    available_slots = []\n    prev_end = max(work_start, megan_constraint)\n\n    for start, end in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Find the first available slot that can fit 30 minutes\n    meeting_duration = 30\n    for slot in available_slots:\n        start, end = slot\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_151"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30       # 30 minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    aaron_busy = [\n        (9*60, 9*60 + 30),\n        (11*60 + 30, 12*60),\n        (12*60 + 30, 14*60),\n        (15*60 + 30, 16*60)\n    ]\n    sarah_busy = [\n        (10*60 + 30, 11*60 + 30),\n        (12*60 + 30, 13*60),\n        (13*60 + 30, 14*60 + 30),\n        (16*60, 16*60 + 30)\n    ]\n    martha_busy = [\n        (9*60, 9*60 + 30),\n        (10*60 + 30, 12*60),\n        (12*60 + 30, 13*60 + 30),\n        (14*60, 14*60 + 30),\n        (15*60 + 30, 17*60)\n    ]\n    heather_busy = [\n        (9*60, 10*60),\n        (11*60 + 30, 12*60),\n        (13*60, 14*60 + 30),\n        (15*60, 15*60 + 30),\n        (16*60, 16*60 + 30)\n    ]\n\n    sarah_preference_start = 13 * 60 + 30  # 13:30 in minutes\n\n    # Generate all possible 30-minute slots in the work hours\n    possible_slots = []\n    current_time = work_hours_start\n    while current_time + meeting_duration <= work_hours_end:\n        slot_start = current_time\n        slot_end = current_time + meeting_duration\n        possible_slots.append((slot_start, slot_end))\n        current_time += 1  # Check every minute for availability\n\n    # Check each slot against everyone's busy times and Sarah's preference\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n\n        # Check Sarah's preference\n        if slot_start < sarah_preference_start:\n            continue\n\n        # Check Aaron's availability\n        aaron_available = True\n        for busy_start, busy_end in aaron_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                aaron_available = False\n                break\n        if not aaron_available:\n            continue\n\n        # Check Sarah's availability\n        sarah_available = True\n        for busy_start, busy_end in sarah_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                sarah_available = False\n                break\n        if not sarah_available:\n            continue\n\n        # Check Martha's availability\n        martha_available = True\n        for busy_start, busy_end in martha_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                martha_available = False\n                break\n        if not martha_available:\n            continue\n\n        # Check Heather's availability\n        heather_available = True\n        for busy_start, busy_end in heather_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                heather_available = False\n                break\n        if not heather_available:\n            continue\n\n        # If all checks passed, return this slot\n        start_hour = slot_start // 60\n        start_min = slot_start % 60\n        end_hour = slot_end // 60\n        end_min = slot_end % 60\n        return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_152"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_start, work_end):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for schedule in participants_schedules:\n        busy_intervals = []\n        for busy_block in schedule:\n            start, end = busy_block.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            busy_intervals.append((start_min, end_min))\n        all_busy_intervals.append(busy_intervals)\n    \n    # Find all possible free intervals for each participant\n    all_free_intervals = []\n    for busy_intervals in all_busy_intervals:\n        free_intervals = []\n        prev_end = work_start_min\n        for start, end in sorted(busy_intervals):\n            if start > prev_end:\n                free_intervals.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end_min:\n            free_intervals.append((prev_end, work_end_min))\n        all_free_intervals.append(free_intervals)\n    \n    # Find overlapping free intervals across all participants\n    common_free_intervals = all_free_intervals[0]\n    for free_intervals in all_free_intervals[1:]:\n        new_common = []\n        i = j = 0\n        while i < len(common_free_intervals) and j < len(free_intervals):\n            start1, end1 = common_free_intervals[i]\n            start2, end2 = free_intervals[j]\n            overlap_start = max(start1, start2)\n            overlap_end = min(end1, end2)\n            if overlap_start < overlap_end:\n                new_common.append((overlap_start, overlap_end))\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free_intervals = new_common\n    \n    # Find the first interval that can accommodate the meeting duration\n    for start, end in common_free_intervals:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    return None\n\n# Define participants' schedules\nlogan_schedule = [\"11:00 to 11:30\", \"16:30 to 17:00\"]\nbruce_schedule = [\"9:00 to 9:30\", \"10:00 to 10:30\", \"14:00 to 14:30\", \"15:00 to 15:30\"]\njoan_schedule = [\"9:00 to 9:30\", \"10:00 to 11:00\", \"12:30 to 14:00\", \"14:30 to 15:30\", \"16:00 to 17:00\"]\nkevin_schedule = [\"9:00 to 9:30\", \"11:30 to 13:30\", \"14:30 to 17:00\"]\n\nparticipants_schedules = [logan_schedule, bruce_schedule, joan_schedule, kevin_schedule]\nmeeting_duration = 30  # minutes\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, meeting_duration, work_hours_start, work_hours_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_153"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:30:15:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, duration, work_hours):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    start_work, end_work = work_hours.split('-')\n    start_min = time_to_minutes(start_work)\n    end_min = time_to_minutes(end_work)\n    \n    # Initialize a list to mark busy intervals\n    timeline = [0] * (end_min - start_min)\n    \n    # Mark busy intervals for each participant\n    for person in participants_busy.values():\n        for busy in person:\n            start, end = busy.split('-')\n            start_busy = time_to_minutes(start)\n            end_busy = time_to_minutes(end)\n            # Mark the busy slots\n            for i in range(start_busy, end_busy):\n                if i < len(timeline):\n                    timeline[i] += 1\n    \n    # Find the first interval where all are free\n    required_slots = duration * 2  # Assuming each slot is 30 minutes for half-hour\n    current_free = 0\n    for i in range(len(timeline)):\n        if timeline[i] == 0:\n            current_free += 1\n            if current_free >= required_slots:\n                start_time = i - current_free + 1\n                end_time = start_time + required_slots\n                return f\"{minutes_to_time(start_time)}:{minutes_to_time(end_time)}\"\n        else:\n            current_free = 0\n    return \"No suitable time found\"\n\n# Define participants' busy times\nparticipants_busy = {\n    'Ann': [],\n    'Kelly': ['12:30-13:00', '14:00-14:30', '15:00-15:30', '16:30-17:00'],\n    'Benjamin': ['9:00-10:30', '11:00-11:30', '12:30-14:00', '15:00-16:30'],\n    'Pamela': ['9:30-11:00', '11:30-12:30', '13:00-14:30', '15:00-17:00']\n}\n\n# Meeting duration in hours (0.5 for half an hour)\nduration = 0.5\nwork_hours = '9:00-17:00'\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, duration, work_hours))\n```",
            "count": "calendar_scheduling_example_154"
        },
        {
            "final_program_time": "{13:30:14:30}",
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_work, end_work = work_hours\n    # Convert all times to minutes since midnight for easier calculation\n    start_min = start_work[0] * 60 + start_work[1]\n    end_min = end_work[0] * 60 + end_work[1]\n    \n    # Initialize a list to represent the availability of each minute in the workday\n    availability = [True] * (end_min - start_min)\n    \n    # For each participant, mark their busy times as unavailable\n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            busy_start_min = busy_start[0] * 60 + busy_start[1]\n            busy_end_min = busy_end[0] * 60 + busy_end[1]\n            # Only consider busy times within work hours\n            overlap_start = max(busy_start_min, start_min)\n            overlap_end = min(busy_end_min, end_min)\n            for minute in range(overlap_start - start_min, overlap_end - start_min):\n                availability[minute] = False\n    \n    # Find the first available slot of the required duration\n    required_slots = duration * 60\n    current_slot_length = 0\n    for minute in range(len(availability)):\n        if availability[minute]:\n            current_slot_length += 1\n            if current_slot_length >= required_slots:\n                # Calculate the start time of the meeting\n                meeting_start_min = start_min + minute - current_slot_length + 1\n                meeting_start_hour = meeting_start_min // 60\n                meeting_start_minute = meeting_start_min % 60\n                # Calculate the end time of the meeting\n                meeting_end_min = meeting_start_min + required_slots\n                meeting_end_hour = meeting_end_min // 60\n                meeting_end_minute = meeting_end_min % 60\n                # Format the output as HH:MM:HH:MM\n                return f\"{meeting_start_hour:02d}:{meeting_start_minute:02d}:{meeting_end_hour:02d}:{meeting_end_minute:02d}\"\n        else:\n            current_slot_length = 0\n    return \"No available slot found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours = ((9, 0), (17, 0))\n\n# Define each participant's schedule as a list of busy time slots (each slot is a tuple of (start, end))\njean_schedule = []\ndennis_schedule = [\n    ((10, 30), (11, 0)),\n    ((12, 0), (12, 30)),\n    ((14, 30), (15, 0)),\n    ((16, 0), (16, 30))\n]\nruth_schedule = [\n    ((9, 30), (12, 0)),\n    ((12, 30), (13, 30)),\n    ((15, 0), (16, 30))\n]\neugene_schedule = [\n    ((9, 0), (9, 30)),\n    ((11, 0), (11, 30)),\n    ((12, 0), (12, 30)),\n    ((13, 0), (13, 30)),\n    ((14, 30), (15, 30)),\n    ((16, 0), (17, 0))\n]\n\n# Combine all participants' schedules\nparticipants_schedules = [jean_schedule, dennis_schedule, ruth_schedule, eugene_schedule]\n\n# Duration of the meeting in hours (1 hour)\nduration = 1\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_155"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for duration availability\n    for interval in free_intervals:\n        start, end = interval\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return (minutes_to_time(meeting_start), minutes_to_time(meeting_end))\n    \n    return None\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"9:00 to 9:30\", \"11:00 to 11:30\", \"15:30 to 16:00\", \"16:30 to 17:00\"],  # Alexander\n    [\"9:00 to 9:30\", \"12:30 to 13:00\"],  # Paul\n    [\"9:30 to 10:00\", \"11:00 to 11:30\", \"12:00 to 17:00\"],  # Elijah\n    [\"9:00 to 10:00\", \"10:30 to 11:30\", \"12:00 to 13:30\", \"14:00 to 14:30\", \"15:30 to 16:00\", \"16:30 to 17:00\"]  # Mark\n]\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\n\n# Find the earliest meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end)\nif meeting_time:\n    print(f\"{meeting_time[0]}:{meeting_time[1]}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_156"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    duration = 30         # meeting duration in minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    # Richard has no meetings\n    richard_busy = []\n    \n    # Debra's busy slots\n    debra_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    \n    # Matthew's busy slots\n    matthew_busy = [\n        (9 * 60, 13 * 60),\n        (14 * 60 + 30, 15 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n    \n    # Elizabeth's busy slots\n    elizabeth_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    \n    # Combine all busy slots for all participants\n    all_busy = []\n    for person in [richard_busy, debra_busy, matthew_busy, elizabeth_busy]:\n        all_busy.extend(person)\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            # Convert back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = (slot_start + duration) // 60\n            end_mm = (slot_start + duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_157"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    russell_busy = [\n        (9 * 60 + 30, 10 * 60 + 0),\n        (13 * 60 + 0, 13 * 60 + 30),\n        (15 * 60 + 30, 16 * 60 + 30)\n    ]\n    debra_busy = [\n        (11 * 60 + 0, 11 * 60 + 30),\n        (13 * 60 + 0, 13 * 60 + 30),\n        (14 * 60 + 0, 14 * 60 + 30),\n        (15 * 60 + 30, 16 * 60 + 0)\n    ]\n    philip_busy = [\n        (9 * 60 + 0, 9 * 60 + 30),\n        (10 * 60 + 30, 12 * 60 + 30),\n        (14 * 60 + 0, 15 * 60 + 0),\n        (15 * 60 + 30, 17 * 60 + 0)\n    ]\n    peter_busy = [\n        (9 * 60 + 0, 9 * 60 + 30),\n        (10 * 60 + 0, 11 * 60 + 30),\n        (12 * 60 + 0, 12 * 60 + 30),\n        (13 * 60 + 0, 15 * 60 + 0),\n        (15 * 60 + 30, 16 * 60 + 0)\n    ]\n\n    # Philip's preference: avoid before 13:30\n    philip_preference_start = 13 * 60 + 30\n\n    # Generate all possible slots (every minute) and check availability\n    for start in range(max(work_start, philip_preference_start), work_end - meeting_duration + 1):\n        end = start + meeting_duration\n        slot_ok = True\n\n        # Check Russell's availability\n        for busy_start, busy_end in russell_busy:\n            if not (end <= busy_start or start >= busy_end):\n                slot_ok = False\n                break\n        if not slot_ok:\n            continue\n\n        # Check Debra's availability\n        for busy_start, busy_end in debra_busy:\n            if not (end <= busy_start or start >= busy_end):\n                slot_ok = False\n                break\n        if not slot_ok:\n            continue\n\n        # Check Philip's availability\n        for busy_start, busy_end in philip_busy:\n            if not (end <= busy_start or start >= busy_end):\n                slot_ok = False\n                break\n        if not slot_ok:\n            continue\n\n        # Check Peter's availability\n        for busy_start, busy_end in peter_busy:\n            if not (end <= busy_start or start >= busy_end):\n                slot_ok = False\n                break\n        if not slot_ok:\n            continue\n\n        # If all checks passed, return this slot\n        start_hour = start // 60\n        start_min = start % 60\n        end_hour = end // 60\n        end_min = end % 60\n        return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_158"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define participants' busy times in minutes (start, end)\n    virginia_busy = [\n        (9 * 60, 11 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (14 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    paul_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 14 * 60),\n        (15 * 60 + 30, 16 * 60 + 30)\n    ]\n    \n    # Nathan's preference: avoid before 13:00\n    nathan_preference_start = 13 * 60\n    \n    # Meeting duration in minutes\n    meeting_duration = 30\n    \n    # Combine all busy times and sort\n    all_busy = virginia_busy + paul_busy\n    all_busy.sort()\n    \n    # Find free slots\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Filter slots that are >= meeting_duration and after Nathan's preference\n    possible_slots = []\n    for start, end in free_slots:\n        if end - start >= meeting_duration and start >= nathan_preference_start:\n            possible_slots.append((start, end))\n    \n    # Select the earliest possible slot\n    if possible_slots:\n        meeting_start = possible_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_159"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' schedules and constraints\n    schedules = {\n        \"Nathan\": [(10 * 60 + 30, 11 * 60), (13 * 60, 13 * 60 + 30)],\n        \"Jacob\": [(13 * 60, 13 * 60 + 30), (15 * 60 + 30, 16 * 60)],\n        \"Katherine\": [(9 * 60 + 30, 11 * 60), (11 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60 + 30)],\n        \"Samantha\": [(9 * 60, 11 * 60), (11 * 60 + 30, 13 * 60 + 30), (14 * 60, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n    }\n    # Jacob's constraint: not before 14:30\n    jacob_constraint = 14 * 60 + 30\n\n    # Meeting duration in minutes\n    duration = 30\n\n    # Generate all possible time slots within work hours, checking every 30 minutes\n    for start in range(work_start, work_end - duration + 1, 30):\n        end = start + duration\n        # Check Jacob's constraint\n        if start < jacob_constraint:\n            continue\n        # Check each participant's availability\n        all_available = True\n        for person, busy_slots in schedules.items():\n            for busy_start, busy_end in busy_slots:\n                if not (end <= busy_start or start >= busy_end):\n                    all_available = False\n                    break\n            if not all_available:\n                break\n        if all_available:\n            # Format the time as HH:MM:HH:MM\n            return f\"{start // 60:02d}:{start % 60:02d}:{end // 60:02d}:{end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_160"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy times in minutes since midnight\n    ryan_busy = [(12 * 60 + 30, 13 * 60), (15 * 60 + 30, 16 * 60)]\n    margaret_busy = [(11 * 60, 12 * 60), (13 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30)]\n    willie_busy = [(9 * 60 + 30, 11 * 60), (12 * 60, 13 * 60), (13 * 60 + 30, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)]\n    shirley_busy = [(10 * 60, 10 * 60 + 30), (11 * 60, 11 * 60 + 30), (12 * 60, 13 * 60), (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)]\n    \n    # Margaret's preference: not before 13:30\n    margaret_preference_start = 13 * 60 + 30\n    \n    # Combine all busy times\n    all_busy = []\n    for busy in [ryan_busy, margaret_busy, willie_busy, shirley_busy]:\n        all_busy.extend(busy)\n    \n    # Sort busy times by start time\n    all_busy.sort()\n    \n    # Find free slots\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Check each free slot for availability and Margaret's preference\n    meeting_duration = 30\n    for slot_start, slot_end in free_slots:\n        if slot_start >= margaret_preference_start:\n            available_start = slot_start\n            available_end = slot_end\n            if available_end - available_start >= meeting_duration:\n                # Convert back to HH:MM format\n                start_hh = available_start // 60\n                start_mm = available_start % 60\n                end_hh = (available_start + meeting_duration) // 60\n                end_mm = (available_start + meeting_duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_161"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert each participant's busy slots to minutes since midnight\n    angela_busy = [\n        (10 * 60, 11 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    judith_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    thomas_busy = [\n        (9 * 60, 10 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (13 * 60, 14 * 60),\n        (14 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    # David has no busy slots\n\n    # Combine all busy slots for all participants\n    all_busy = []\n    for busy in [angela_busy, judith_busy, thomas_busy]:\n        all_busy.extend(busy)\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the time after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = (start + meeting_duration) // 60\n            end_mm = (start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_162"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    duration = 30         # meeting duration in minutes\n\n    # Convert each participant's busy slots to minutes\n    jason_busy = [(10 * 60 + 30, 13 * 60), (14 * 60, 14 * 60 + 30)]\n    hannah_busy = []  # No meetings\n    gary_busy = [(9 * 60, 10 * 60), (10 * 60 + 30, 15 * 60), (16 * 60 + 30, 17 * 60)]\n    pamela_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60, 16 * 60 + 30)\n    ]\n\n    # Combine all busy slots\n    all_busy = jason_busy + hannah_busy + gary_busy + pamela_busy\n\n    # Sort busy slots by start time\n    all_busy_sorted = sorted(all_busy, key=lambda x: x[0])\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    prev_end = work_start\n\n    for busy_start, busy_end in all_busy_sorted:\n        if busy_start > prev_end:\n            free_slots.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_163"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    duration = 30        # meeting duration in minutes\n\n    # Convert each participant's busy slots to minutes\n    # Jennifer's busy slots\n    jennifer_busy = [\n        (12 * 60 + 30, 13 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n\n    # Jean's busy slots and preference to avoid after 15:30\n    jean_busy = [\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    jean_preference_end = 15 * 60 + 30  # 15:30\n\n    # Jerry's busy slots\n    jerry_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n\n    # Carl's busy slots\n    carl_busy = [\n        (9 * 60, 11 * 60),\n        (12 * 60, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n\n    # Combine all busy slots\n    all_busy = jennifer_busy + jean_busy + jerry_busy + carl_busy\n\n    # Generate free slots by finding gaps between busy slots\n    all_busy.sort()\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check each free slot for availability for all participants and Jean's preference\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Check Jean's preference (meeting should end by 15:30)\n            if meeting_end <= jean_preference_end:\n                # Check if all participants are free\n                all_free = True\n                # Jennifer\n                for bs in jennifer_busy:\n                    if not (meeting_end <= bs[0] or meeting_start >= bs[1]):\n                        all_free = False\n                        break\n                if not all_free:\n                    continue\n                # Jean\n                for bs in jean_busy:\n                    if not (meeting_end <= bs[0] or meeting_start >= bs[1]):\n                        all_free = False\n                        break\n                if not all_free:\n                    continue\n                # Jerry\n                for bs in jerry_busy:\n                    if not (meeting_end <= bs[0] or meeting_start >= bs[1]):\n                        all_free = False\n                        break\n                if not all_free:\n                    continue\n                # Carl\n                for bs in carl_busy:\n                    if not (meeting_end <= bs[0] or meeting_start >= bs[1]):\n                        all_free = False\n                        break\n                if all_free:\n                    # Convert to HH:MM format\n                    start_hh = meeting_start // 60\n                    start_mm = meeting_start % 60\n                    end_hh = meeting_end // 60\n                    end_mm = meeting_end % 60\n                    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Run the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_164"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_start=9 * 60, work_end=17 * 60):\n    # Convert all schedules to minutes since start of day\n    busy_slots = []\n    for schedule in participants_schedules:\n        for start, end in schedule:\n            busy_slots.append((start, end))\n    \n    # Sort all busy slots by start time\n    busy_slots.sort()\n    \n    # Merge overlapping or adjacent busy slots\n    merged = []\n    for start, end in busy_slots:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find the earliest available slot\n    prev_end = work_start\n    for start, end in merged:\n        if start - prev_end >= duration_minutes:\n            return (prev_end, prev_end + duration_minutes)\n        prev_end = max(prev_end, end)\n    \n    # Check after the last busy slot\n    if work_end - prev_end >= duration_minutes:\n        return (prev_end, prev_end + duration_minutes)\n    \n    return None\n\n# Define participants' schedules in minutes since 9:00 (work_start)\nparticipants_schedules = [\n    [],  # Anthony has no meetings\n    [(9.5 * 60, 10 * 60), (12.5 * 60, 13.5 * 60), (15.5 * 60, 17 * 60)],  # Stephanie\n    [(9 * 60, 10.5 * 60), (11.5 * 60, 12.5 * 60), (13 * 60, 13.5 * 60), (14 * 60, 16 * 60)],  # Emma\n    [(10 * 60, 11 * 60), (11.5 * 60, 12.5 * 60), (14 * 60, 14.5 * 60), (15.5 * 60, 17 * 60)],  # Kathleen\n]\n\nmeeting_slot = find_meeting_time(participants_schedules)\n\nif meeting_slot:\n    start, end = meeting_slot\n    # Convert minutes back to HH:MM format\n    start_hh = start // 60\n    start_mm = start % 60\n    end_hh = end // 60\n    end_mm = end % 60\n    print(f\"{int(start_hh):02d}:{int(start_mm):02d}:{int(end_hh):02d}:{int(end_mm):02d}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_165"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration_min = duration * 60\n\n    # Initialize the free slots for the day\n    free_slots = []\n    current_start = work_start\n\n    # Generate all possible slots during work hours\n    while current_start + duration_min <= work_end:\n        free_slots.append((current_start, current_start + duration_min))\n        current_start += 30  # Assuming 30-minute increments for simplicity\n\n    # Check each slot against all participants' schedules\n    for slot_start, slot_end in free_slots:\n        slot_ok = True\n        for person, meetings in participants_schedules.items():\n            for meeting in meetings:\n                meeting_start = time_to_minutes(meeting[0])\n                meeting_end = time_to_minutes(meeting[1])\n                # Check if slot overlaps with any meeting\n                if not (slot_end <= meeting_start or slot_start >= meeting_end):\n                    slot_ok = False\n                    break\n            if not slot_ok:\n                break\n        if slot_ok:\n            return f\"{minutes_to_time(slot_start)}:{minutes_to_time(slot_end)}\"\n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    'Sara': [('10:00', '10:30'), ('15:00', '15:30'), ('16:00', '17:00')],\n    'Lauren': [],\n    'Jose': [('9:00', '10:30'), ('11:00', '12:00'), ('13:00', '13:30'), ('14:00', '17:00')],\n    'Henry': [('10:00', '10:30'), ('11:00', '14:00'), ('14:30', '16:00')]\n}\n\n# Find a meeting time\nmeeting_time = find_meeting_time(participants_schedules, 30, '9:00', '17:00')\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_166"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time slots to minutes since start of the day for easier calculation\n    work_start = work_hours_start * 60\n    work_end = work_hours_end * 60\n    duration = duration_minutes\n\n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n\n    for participant, schedules in participants_schedules.items():\n        for start, end in schedules:\n            busy_intervals.append((start[0] * 60 + start[1], end[0] * 60 + end[1]))\n\n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n\n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find the available slots by looking at the gaps between busy intervals\n    available_slots = []\n    previous_end = work_start\n\n    for start, end in merged:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check the slot after the last busy interval\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n\n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No available time slot found\"\n\n# Define the participants' schedules in HH:MM format converted to tuples of (HH, MM)\nparticipants_schedules = {\n    \"Marilyn\": [((10, 30), (11, 30)), ((12, 0), (12, 30)), ((15, 30), (16, 00))],\n    \"George\": [],\n    \"Stephanie\": [((10, 30), (12, 30)), ((13, 30), (16, 30))],\n    \"Kimberly\": [((9, 00), (10, 30)), ((12, 30), (13, 00)), ((13, 30), (15, 00)), ((15, 30), (17, 00))],\n}\n\n# Define work hours and meeting duration\nwork_hours_start = 9\nwork_hours_end = 17\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_167"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize a list to keep track of all busy intervals\n    all_busy_intervals = []\n    \n    for person, busy_intervals in participants_busy_times.items():\n        for interval in busy_intervals:\n            start, end = interval.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            all_busy_intervals.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Find free intervals by inverting busy intervals\n    free_intervals = []\n    previous_end = work_start\n    \n    for start, end in all_busy_intervals:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_intervals.append((previous_end, work_end))\n    \n    # Check each free interval for availability of all participants\n    potential_slots = []\n    for start, end in free_intervals:\n        if end - start >= meeting_duration:\n            potential_slots.append((start, start + meeting_duration))\n    \n    # The first suitable slot is the earliest possible\n    if potential_slots:\n        slot_start, slot_end = potential_slots[0]\n        return f\"{minutes_to_time(slot_start)}:{minutes_to_time(slot_end)}\"\n    else:\n        return \"No available slot found\"\n\n# Define the participants' busy times\nparticipants_busy_times = {\n    \"Jean\": [\"13:00 to 13:30\", \"14:00 to 14:30\", \"16:00 to 17:00\"],\n    \"Lauren\": [\"9:30 to 10:00\", \"10:30 to 11:00\"],\n    \"Olivia\": [\"9:00 to 11:00\", \"12:30 to 16:00\", \"16:30 to 17:00\"],\n    \"Scott\": [\"9:00 to 11:30\", \"13:30 to 14:00\", \"14:30 to 15:30\"],\n}\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 60  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_168"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    start, end = work_hours\n    # Convert time strings to minutes for easier calculation\n    start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n    end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n    duration_min = duration * 60\n    \n    # Initialize the free slots for all participants\n    free_slots = []\n    for schedule in participants_schedules:\n        busy = []\n        for slot in schedule:\n            s, e = slot.split(' to ')\n            s_min = int(s.split(':')[0]) * 60 + int(s.split(':')[1])\n            e_min = int(e.split(':')[0]) * 60 + int(e.split(':')[1])\n            busy.append((s_min, e_min))\n        # Sort the busy slots\n        busy.sort()\n        # Calculate free slots\n        free = []\n        prev_end = start_min\n        for slot in busy:\n            s, e = slot\n            if s > prev_end:\n                free.append((prev_end, s))\n            prev_end = max(prev_end, e)\n        if prev_end < end_min:\n            free.append((prev_end, end_min))\n        free_slots.append(free)\n    \n    # Find overlapping free slots\n    common_free = free_slots[0]\n    for slots in free_slots[1:]:\n        new_common = []\n        i = j = 0\n        while i < len(common_free) and j < len(slots):\n            s1, e1 = common_free[i]\n            s2, e2 = slots[j]\n            # Find the overlap\n            overlap_start = max(s1, s2)\n            overlap_end = min(e1, e2)\n            if overlap_start < overlap_end:\n                new_common.append((overlap_start, overlap_end))\n            if e1 < e2:\n                i += 1\n            else:\n                j += 1\n        common_free = new_common\n    \n    # Find the first slot that can fit the meeting\n    for slot in common_free:\n        s, e = slot\n        if e - s >= duration_min:\n            meeting_start = s\n            meeting_end = s + duration_min\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Donna has no meetings\n    [],  # Lisa has no meetings\n    [   # Philip's schedule\n        \"9:00 to 10:30\",\n        \"11:00 to 12:00\",\n        \"12:30 to 14:00\",\n        \"14:30 to 15:00\",\n        \"15:30 to 17:00\"\n    ],\n    [   # Albert's schedule\n        \"9:30 to 10:00\",\n        \"11:00 to 12:30\",\n        \"13:30 to 14:30\",\n        \"15:00 to 15:30\",\n        \"16:00 to 16:30\"\n    ]\n]\n\n# Define meeting duration (0.5 hours = 30 minutes) and work hours (9:00 to 17:00)\nduration = 0.5\nwork_hours = (\"9:00\", \"17:00\")\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_169"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy times in minutes (start, end)\n    gary_busy = [(9.5 * 60, 10 * 60), (12 * 60, 12.5 * 60)]\n    douglas_busy = [(10.5 * 60, 11 * 60), (11.5 * 60, 12 * 60), (14 * 60, 14.5 * 60), (16.5 * 60, 17 * 60)]\n    elizabeth_busy = [(11.5 * 60, 13.5 * 60), (14 * 60, 15 * 60), (16 * 60, 17 * 60)]\n    daniel_busy = [(10.5 * 60, 12.5 * 60), (14 * 60, 17 * 60)]\n    \n    # Gary's preference: not after 10:00 (so before 10:00)\n    gary_pref_end = 10 * 60\n    \n    # Combine all busy times and sort\n    all_busy = gary_busy + douglas_busy + elizabeth_busy + daniel_busy\n    all_busy.sort()\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Check for a 30-minute slot that fits Gary's preference (before 10:00)\n    meeting_duration = 30\n    for slot_start, slot_end in available_slots:\n        if slot_start >= gary_pref_end:\n            continue  # Skip slots after Gary's preference\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{int(meeting_start // 60):02d}:{int(meeting_start % 60):02d}:{int(meeting_end // 60):02d}:{int(meeting_end % 60):02d}\"\n    \n    # If no slot found before 10:00, look for any other slot (though problem states a solution exists)\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            return f\"{int(meeting_start // 60):02d}:{int(meeting_start % 60):02d}:{int(meeting_end // 60):02d}:{int(meeting_end % 60):02d}\"\n    \n    return \"No time found\"  # Should not reach here per problem statement\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_170"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Convert each participant's busy slots to minutes\n    kevin_busy = [(10 * 60 + 30, 11 * 60), (14 * 60, 14 * 60 + 30)]\n    carolyn_busy = [(11 * 60 + 30, 12 * 60), (16 * 60, 16 * 60 + 30)]\n    stephanie_busy = [(9 * 60, 10 * 60 + 30), (11 * 60, 12 * 60 + 30), \n                      (13 * 60 + 30, 14 * 60 + 30), (15 * 60, 17 * 60)]\n    isabella_busy = [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 11 * 60), \n                     (11 * 60 + 30, 14 * 60 + 30), (15 * 60, 17 * 60)]\n\n    # Combine all busy slots\n    all_busy = kevin_busy + carolyn_busy + stephanie_busy + isabella_busy\n\n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_171"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:00:14:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours\n    start_min = time_to_minutes(start_work)\n    end_min = time_to_minutes(end_work)\n    duration_min = duration * 60\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(start_min, end_min)]\n    \n    # Process each participant's busy slots to find common free time\n    for person in participants_busy:\n        new_free_slots = []\n        for busy_start, busy_end in person:\n            busy_start_min = time_to_minutes(busy_start)\n            busy_end_min = time_to_minutes(busy_end)\n            temp_slots = []\n            for slot_start, slot_end in free_slots:\n                if busy_end_min <= slot_start or busy_start_min >= slot_end:\n                    # No overlap, keep the slot as is\n                    temp_slots.append((slot_start, slot_end))\n                else:\n                    # Overlap, split the slot\n                    if slot_start < busy_start_min:\n                        temp_slots.append((slot_start, busy_start_min))\n                    if slot_end > busy_end_min:\n                        temp_slots.append((busy_end_min, slot_end))\n            free_slots = temp_slots\n        if not free_slots:\n            return None  # No common free time\n    \n    # Find the first slot that can accommodate the meeting duration\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return None\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 0.5  # half an hour\n\n# Define each participant's busy times\nparticipants_busy = [\n    # Patrick's busy slots\n    [(\"9:00\", \"9:30\"), (\"10:00\", \"10:30\"), (\"13:30\", \"14:00\"), (\"16:00\", \"16:30\")],\n    # Kayla's busy slots\n    [(\"12:30\", \"13:30\"), (\"15:00\", \"15:30\"), (\"16:00\", \"16:30\")],\n    # Carl's busy slots\n    [(\"10:30\", \"11:00\"), (\"12:00\", \"12:30\"), (\"13:00\", \"13:30\"), (\"14:30\", \"17:00\")],\n    # Christian's busy slots\n    [(\"9:00\", \"12:30\"), (\"13:00\", \"14:00\"), (\"14:30\", \"17:00\")],\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_172"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert all schedules to minutes since midnight\n    # Each person's busy times are represented as a list of (start, end) tuples in minutes\n    jacqueline_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    \n    harold_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (15 * 60, 17 * 60)\n    ]\n    harold_no_meet_after = 13 * 60  # Harold doesn't want to meet after 13:00\n    \n    arthur_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 12 * 60 + 30),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    \n    kelly_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 11 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    \n    # Duration of the meeting in minutes\n    duration = 30\n    \n    # Collect all busy times for all participants\n    all_busy = jacqueline_busy + harold_busy + arthur_busy + kelly_busy\n    \n    # Generate all possible time slots within work hours, checking for availability\n    current_time = work_start\n    while current_time + duration <= work_end:\n        slot_end = current_time + duration\n        # Check if the slot is free for everyone\n        is_available = True\n        \n        # Check Jacqueline's schedule\n        for start, end in jacqueline_busy:\n            if not (slot_end <= start or current_time >= end):\n                is_available = False\n                break\n        if not is_available:\n            current_time += 5  # Move to next possible slot (5-minute increments)\n            continue\n        \n        # Check Harold's schedule and constraint\n        for start, end in harold_busy:\n            if not (slot_end <= start or current_time >= end):\n                is_available = False\n                break\n        if not is_available:\n            current_time += 5\n            continue\n        if current_time >= harold_no_meet_after:\n            is_available = False\n        if not is_available:\n            current_time += 5\n            continue\n        \n        # Check Arthur's schedule\n        for start, end in arthur_busy:\n            if not (slot_end <= start or current_time >= end):\n                is_available = False\n                break\n        if not is_available:\n            current_time += 5\n            continue\n        \n        # Check Kelly's schedule\n        for start, end in kelly_busy:\n            if not (slot_end <= start or current_time >= end):\n                is_available = False\n                break\n        if not is_available:\n            current_time += 5\n            continue\n        \n        # If all checks passed, return the slot\n        start_h = current_time // 60\n        start_m = current_time % 60\n        end_h = slot_end // 60\n        end_m = slot_end % 60\n        return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n        \n        current_time += 5\n    \n    return \"No available slot found\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_173"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:30:14:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between merged intervals and work hours\n    available_slots = []\n    previous_end = work_start\n    for start, end in merged:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Check each available slot for sufficient duration\n    meeting_duration_min = meeting_duration * 60\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"11:30:12:00\", \"14:30:16:00\"],  # Kevin\n    [\"10:00:11:00\"],                 # David\n    [\"9:00:11:30\", \"12:00:13:00\", \"14:00:15:30\", \"16:00:17:00\"],  # Stephen\n    [\"9:00:13:30\", \"14:30:17:00\"]    # Helen\n]\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 0.5  # in hours\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_174"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each participant's blocked times to minutes since midnight\n    roger_blocked = [\n        (12 * 60 + 30, 13 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    jesse_blocked = [\n        (10 * 60, 10 * 60 + 30),\n        (12 * 60 + 30, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30)\n    ]\n    daniel_blocked = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    maria_blocked = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60, 13 * 60),\n        (13 * 60 + 30, 14 * 60 + 30),\n        (15 * 60, 16 * 60 + 30)\n    ]\n    maria_min_time = 12 * 60 + 30  # Maria can't meet before 12:30\n\n    # Combine all blocked times for all participants\n    all_blocked = []\n    for start, end in roger_blocked:\n        all_blocked.append((start, end, \"Roger\"))\n    for start, end in jesse_blocked:\n        all_blocked.append((start, end, \"Jesse\"))\n    for start, end in daniel_blocked:\n        all_blocked.append((start, end, \"Daniel\"))\n    for start, end in maria_blocked:\n        all_blocked.append((start, end, \"Maria\"))\n\n    # Sort all blocked times by start time\n    all_blocked.sort()\n\n    # Find available slots\n    available_slots = []\n    current_time = max(work_start, maria_min_time)\n\n    for start, end, _ in all_blocked:\n        if start > current_time:\n            available_slots.append((current_time, start))\n        current_time = max(current_time, end)\n    if current_time < work_end:\n        available_slots.append((current_time, work_end))\n\n    # Check each available slot for a meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Check if all participants are free during this time\n            all_free = True\n            # Roger\n            for start, end, person in all_blocked:\n                if person == \"Roger\" and not (end <= meeting_start or start >= meeting_end):\n                    all_free = False\n                    break\n            if not all_free:\n                continue\n            # Jesse\n            for start, end, person in all_blocked:\n                if person == \"Jesse\" and not (end <= meeting_start or start >= meeting_end):\n                    all_free = False\n                    break\n            if not all_free:\n                continue\n            # Daniel\n            for start, end, person in all_blocked:\n                if person == \"Daniel\" and not (end <= meeting_start or start >= meeting_end):\n                    all_free = False\n                    break\n            if not all_free:\n                continue\n            # Maria\n            for start, end, person in all_blocked:\n                if person == \"Maria\" and not (end <= meeting_start or start >= meeting_end):\n                    all_free = False\n                    break\n            if all_free:\n                # Convert back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No available time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_175"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration_minutes):\n    # Convert all times to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    meeting_duration = meeting_duration_minutes\n\n    # Collect all busy times for all participants\n    all_busy_times = []\n    for busy_times in participants_busy_times.values():\n        for start, end in busy_times:\n            all_busy_times.append((time_to_minutes(start), time_to_minutes(end)))\n\n    # Sort busy times by start time\n    all_busy_times.sort()\n\n    # Find free slots by checking gaps between busy times and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy_times:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No suitable time found\"\n\n# Define the participants' busy times\nparticipants_busy_times = {\n    \"Gary\": [(\"9:00\", \"9:30\"), (\"14:00\", \"14:30\")],\n    \"Melissa\": [(\"12:00\", \"13:00\"), (\"14:30\", \"15:00\"), (\"16:00\", \"16:30\")],\n    \"Alan\": [(\"9:00\", \"10:00\"), (\"10:30\", \"11:30\"), (\"12:00\", \"17:00\")],\n    \"Kevin\": [(\"9:00\", \"9:30\"), (\"10:00\", \"10:30\"), (\"12:00\", \"16:00\")],\n}\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_176"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:00:12:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's busy times\n    for busy_slots in participants_busy_times:\n        new_free_slots = []\n        for busy_start, busy_end in busy_slots:\n            busy_start_min = time_to_minutes(busy_start)\n            busy_end_min = time_to_minutes(busy_end)\n            updated_free_slots = []\n            for slot_start, slot_end in free_slots:\n                if busy_end_min <= slot_start or busy_start_min >= slot_end:\n                    # No overlap, keep the slot as is\n                    updated_free_slots.append((slot_start, slot_end))\n                else:\n                    # There is an overlap, split the slot\n                    if slot_start < busy_start_min:\n                        updated_free_slots.append((slot_start, busy_start_min))\n                    if busy_end_min < slot_end:\n                        updated_free_slots.append((busy_end_min, slot_end))\n            free_slots = updated_free_slots\n        if not free_slots:\n            return None  # No possible slot\n    \n    # Find the first slot that can fit the meeting\n    meeting_duration_min = meeting_duration * 60\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration_min:\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            start_time = minutes_to_time(slot_start)\n            end_time = minutes_to_time(slot_start + meeting_duration_min)\n            return f\"{start_time}:{end_time}\"\n    return None\n\n# Define the participants' busy times\nparticipants_busy_times = [\n    # Richard's busy times\n    [(\"9:00\", \"9:30\"), (\"11:30\", \"12:00\"), (\"13:00\", \"13:30\"), (\"16:00\", \"16:30\")],\n    # Joseph's busy times\n    [(\"9:30\", \"10:30\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:30\"), (\"14:00\", \"14:30\")],\n    # Gabriel's busy times\n    [(\"9:00\", \"11:00\"), (\"11:30\", \"12:00\"), (\"12:30\", \"17:00\")],\n    # Brenda's busy times\n    [(\"9:00\", \"12:00\"), (\"12:30\", \"16:30\")]\n]\n\n# Find a meeting time\nmeeting_time = find_meeting_time(\n    participants_busy_times=participants_busy_times,\n    work_hours_start=\"9:00\",\n    work_hours_end=\"17:00\",\n    meeting_duration=0.5  # 0.5 hours = 30 minutes\n)\n\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_177"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start, end = work_hours\n    busy_times = []\n    \n    # Collect all busy intervals from all participants\n    for schedule in participants_schedules.values():\n        for busy_start, busy_end in schedule:\n            busy_times.append((busy_start, busy_end))\n    \n    # Sort all busy intervals by start time\n    busy_times.sort()\n    \n    # Find all free intervals by checking gaps between busy intervals\n    free_times = []\n    previous_end = start\n    \n    for busy_start, busy_end in busy_times:\n        if busy_start > previous_end:\n            free_times.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    # Check the time after the last busy interval until end of work hours\n    if previous_end < end:\n        free_times.append((previous_end, end))\n    \n    # Find the first free interval that can accommodate the meeting duration\n    for free_start, free_end in free_times:\n        if (free_end - free_start) >= duration:\n            meeting_start = free_start\n            meeting_end = meeting_start + duration\n            return f\"{meeting_start:02d}:00:{meeting_end:02d}:00\"\n    \n    return \"No suitable time found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (9, 17)\n\n# Define participants' schedules in 24-hour format as integers for simplicity\nparticipants_schedules = {\n    \"Aaron\": [(9, 9.5), (10.5, 11)],\n    \"Bryan\": [(9, 9.5), (14.5, 15)],\n    \"Philip\": [(9, 9.5), (10, 10.5), (13.5, 15), (15.5, 17)],\n    \"Ronald\": [(9, 9.5), (10, 10.5), (11.5, 12), (13, 15.5)],\n}\n\n# Meeting duration in hours\nduration = 1\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_178"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert all time slots to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots between work hours and busy intervals\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Check each available slot for duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"12:00 to 12:30\", \"15:00 to 15:30\"],  # Joseph\n    [\"09:30 to 10:00\", \"14:00 to 14:30\"],  # Laura\n    [\"09:00 to 09:30\", \"10:00 to 10:30\", \"11:00 to 11:30\", \"12:00 to 12:30\", \"13:30 to 14:00\", \"14:30 to 16:00\"],  # Jeffrey\n    [\"09:30 to 12:30\", \"13:00 to 17:00\"],  # Jeremy\n]\n\n# Define work hours and meeting duration\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_179"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Convert each participant's busy slots to minutes since 9:00\n    david_busy = [(14*60, 14*60 + 30), (16*60 + 30, 17*60)]\n    ethan_busy = [(13*60, 13*60 + 30), (14*60 + 30, 15*60)]\n    bradley_busy = [(9*60 + 30, 10*60 + 30), (11*60, 12*60), (13*60 + 30, 14*60), (15*60 + 30, 17*60)]\n    natalie_busy = [(9*60 + 30, 10*60), (10*60 + 30, 12*60), (12*60 + 30, 15*60 + 30), (16*60, 17*60)]\n    \n    # Natalie's preference: not after 10:30 (10*60 + 30)\n    preference_end = 10 * 60 + 30\n    \n    # Combine all busy slots\n    all_busy = david_busy + ethan_busy + bradley_busy + natalie_busy\n    \n    # Generate all possible 30-minute slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + 30 <= work_end:\n        slot_start = current_time\n        slot_end = current_time + 30\n        possible_slots.append((slot_start, slot_end))\n        current_time += 30  # Check every 30 minutes\n    \n    # Check each slot for availability and Natalie's preference\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        # Check if slot is within Natalie's preference\n        if slot_end > preference_end:\n            continue\n        # Check if slot overlaps with any busy time\n        overlap = False\n        for busy_start, busy_end in all_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                overlap = True\n                break\n        if not overlap:\n            # Convert back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_180"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define each person's busy times in minutes since midnight\n    # Samuel is free all day\n    samuel_busy = []\n    \n    # Evelyn's busy times\n    evelyn_busy = [\n        (9 * 60, 10 * 60),\n        (11 * 60, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    \n    # Ruth's busy times\n    ruth_busy = [\n        (9 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Amanda's busy times and constraint (not before 16:00)\n    amanda_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    amanda_constraint = 16 * 60  # Can't meet before 16:00\n    \n    # Combine all busy times\n    all_busy = []\n    all_busy.extend(evelyn_busy)\n    all_busy.extend(ruth_busy)\n    all_busy.extend(amanda_busy)\n    \n    # Sort all busy times by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    prev_end = work_start\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > prev_end:\n            free_slots.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n    \n    # Check the remaining time after the last busy slot\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Filter free slots that meet duration and Amanda's constraint\n    possible_slots = []\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Check if the slot is after Amanda's constraint\n            if slot_start >= amanda_constraint:\n                possible_slots.append((slot_start, slot_end))\n    \n    # Select the earliest possible slot\n    if possible_slots:\n        meeting_start = possible_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Format the output as HH:MM:HH:MM\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_181"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert each participant's busy slots to minutes\n    emma_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 11 * 60),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    doris_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (12 * 60 + 30, 13 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    randy_busy = [\n        (9 * 60 + 30, 11 * 60),\n        (12 * 60 + 30, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n    # Ann is free all day\n\n    # Combine all busy slots\n    all_busy = emma_busy + doris_busy + randy_busy\n\n    # Sort busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the time after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Filter free slots that are at least 30 minutes and meet Doris's preference (before or at 12:30)\n    meeting_duration = 30\n    valid_slots = []\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Check if the slot starts before or at 12:30 (Doris's preference)\n            if start <= 12 * 60 + 30:\n                valid_slots.append((start, end))\n\n    # If no slots before 12:30, consider all free slots\n    if not valid_slots:\n        valid_slots = [slot for slot in free_slots if slot[1] - slot[0] >= meeting_duration]\n\n    # Select the earliest possible slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n    else:\n        return \"No available slot found\"\n\n    # Convert back to HH:MM format\n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n\n    return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_182"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since midnight\n    benjamin_busy = [\n        (12 * 60 + 30, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60 + 30)\n    ]\n    philip_busy = [\n        (11 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    jessica_busy = [\n        (9 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60 + 30, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    ashley_busy = [\n        (10 * 60, 12 * 60),\n        (12 * 60 + 30, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60, 16 * 60 + 30)\n    ]\n\n    # Combine all busy slots\n    all_busy = benjamin_busy + philip_busy + jessica_busy + ashley_busy\n\n    # Generate free slots by finding gaps between busy slots\n    all_busy.sort()  # Sort by start time\n    free_slots = []\n    previous_end = work_start\n\n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the earliest free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_183"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:00:15:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy_slots in participants_busy.values():\n        for slot in busy_slots:\n            start, end = slot.split(' to ')\n            all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting duration\n    duration_min = duration * 60\n    for start, end in available:\n        if end - start >= duration_min:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration_min)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No available slot found\"\n\n# Define participants' busy times\nparticipants_busy = {\n    'Raymond': ['9:30 to 10:00', '12:30 to 14:30', '15:30 to 16:00'],\n    'Sophia': [],\n    'Lori': ['9:00 to 9:30', '10:30 to 13:00', '14:30 to 15:00', '15:30 to 17:00'],\n    'Dorothy': ['9:00 to 13:30', '14:00 to 15:00', '16:00 to 16:30'],\n}\n\n# Define work hours and meeting duration\nwork_hours = '9:00 to 17:00'\nduration = 0.5  # half an hour\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_184"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Convert each participant's busy slots to minutes\n    kimberly_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 12 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    marie_busy = [\n        (10 * 60, 11 * 60),\n        (11 * 60 + 30, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    diana_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 14 * 60 + 30),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    # Megan has no meetings but prefers to avoid before 10:00\n    megan_preferred_start = 10 * 60\n    \n    # Combine all busy slots\n    all_busy = kimberly_busy + marie_busy + diana_busy\n    # Add Megan's preference as a busy slot (before 10:00)\n    all_busy.append((work_start, megan_preferred_start))\n    \n    # Sort busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can fit 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_185"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:00:14:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy_times in participants_busy_times.values():\n        for start, end in busy_times:\n            all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append([start, end])\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                merged_busy[-1][1] = max(end, last_end)\n            else:\n                merged_busy.append([start, end])\n    \n    # Find free intervals between work hours and busy times\n    free_intervals = []\n    prev_end = work_start\n    for start, end in merged_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Find the first free interval that can accommodate the meeting\n    meeting_duration_min = meeting_duration * 60\n    for start, end in free_intervals:\n        if end - start >= meeting_duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' busy times\nparticipants_busy_times = {\n    'Richard': [],\n    'Frances': [],\n    'Andrea': [('9:30', '10:00'), ('10:30', '14:00'), ('14:30', '16:00'), ('16:30', '17:00')],\n    'Cheryl': [('9:00', '10:30'), ('11:00', '12:30'), ('13:00', '14:00'), ('14:30', '15:00'), ('16:00', '16:30')],\n}\n\n# Define work hours and meeting duration\nwork_hours_start = '9:00'\nwork_hours_end = '17:00'\nmeeting_duration = 0.5  # in hours\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration))\n```",
            "count": "calendar_scheduling_example_186"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Initialize busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        person_busy = []\n        for block in schedule:\n            start, end = block.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            person_busy.append((start_min, end_min))\n        busy_intervals.append(person_busy)\n    \n    # Find all possible meeting start times (every minute)\n    possible_starts = []\n    for start in range(work_start, work_end - duration + 1):\n        end = start + duration\n        valid = True\n        # Check against each participant's busy intervals\n        for person in busy_intervals:\n            for (busy_start, busy_end) in person:\n                if not (end <= busy_start or start >= busy_end):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            possible_starts.append(start)\n    \n    if not possible_starts:\n        return \"No available time slot found.\"\n    \n    # Return the first available time slot\n    meeting_start = possible_starts[0]\n    meeting_end = meeting_start + duration\n    return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n# Define participants' schedules\ndouglas = [\"10:00 to 10:30\", \"11:00 to 12:00\", \"12:30 to 13:00\", \"15:30 to 16:30\"]\ngloria = [\"10:30 to 11:00\", \"16:30 to 17:00\"]\npeter = [\"9:00 to 10:00\", \"11:00 to 11:30\", \"12:30 to 13:30\", \"14:30 to 15:00\", \"16:00 to 17:00\"]\nryan = [\"9:30 to 10:00\", \"10:30 to 11:30\", \"12:00 to 12:30\", \"13:00 to 14:00\", \"15:00 to 17:00\"]\n\nparticipants_schedules = [douglas, gloria, peter, ryan]\nduration = 30  # minutes\nwork_hours = \"9:00 to 17:00\"\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, duration, work_hours))\n```",
            "count": "calendar_scheduling_example_187"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define each participant's busy times in minutes (start, end)\n    beverly_busy = [(10*60, 11*60), (13*60, 13*60 + 30), (15*60, 15*60 + 30)]\n    brenda_busy = [(10*60 + 30, 11*60), (11*60 + 30, 12*60 + 30), (13*60, 13*60 + 30), (14*60 + 30, 15*60), (16*60 + 30, 17*60)]\n    lori_busy = [(9*60 + 30, 11*60), (12*60 + 30, 13*60), (14*60, 15*60 + 30), (16*60, 16*60 + 30)]\n    ronald_busy = [(9*60, 11*60), (11*60 + 30, 15*60 + 30), (16*60, 17*60)]\n    \n    # Beverly's preference: not before 15:00\n    preferred_start = 15 * 60\n    \n    # Meeting duration in minutes\n    duration = 30\n    \n    # Combine all busy times\n    all_busy = beverly_busy + brenda_busy + lori_busy + ronald_busy\n    \n    # Generate available slots by finding gaps between busy times\n    all_busy.sort()  # Sort by start time\n    available_slots = []\n    current_time = work_start\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > current_time:\n            available_slots.append((current_time, busy_start))\n        current_time = max(current_time, busy_end)\n    if current_time < work_end:\n        available_slots.append((current_time, work_end))\n    \n    # Filter slots that are at least 30 minutes and meet Beverly's preference\n    possible_slots = []\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration and slot_start >= preferred_start:\n            possible_slots.append((slot_start, slot_start + duration))\n    \n    # Select the earliest possible slot\n    if possible_slots:\n        meeting_start, meeting_end = possible_slots[0]\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        print(f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\")\n    else:\n        print(\"No available time slot found.\")\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_188"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:00:14:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, duration, work_start, work_end):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Initialize the free slots for the day (9:00-17:00)\n    free_slots = []\n    current_start = work_start_min\n    \n    # Collect all busy slots and sort them\n    all_busy = []\n    for busy_slots in participants_busy.values():\n        for start, end in busy_slots:\n            all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy slots\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Generate free slots between busy times\n    for start, end in merged_busy:\n        if current_start < start:\n            free_slots.append((current_start, start))\n        current_start = max(current_start, end)\n    if current_start < work_end_min:\n        free_slots.append((current_start, work_end_min))\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                h = minutes // 60\n                m = minutes % 60\n                return f\"{h:02d}:{m:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    return None\n\n# Define participants' busy times\nparticipants_busy = {\n    'Judy': [('9:30', '10:00'), ('15:00', '15:30')],\n    'Lori': [('14:30', '15:00'), ('16:00', '16:30')],\n    'Andrea': [('9:00', '9:30'), ('10:30', '11:30'), ('12:30', '13:00'), ('13:30', '14:00'), ('15:00', '16:00'), ('16:30', '17:00')],\n    'Mark': [('9:30', '14:00'), ('14:30', '15:00'), ('16:00', '17:00')],\n}\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_busy, 0.5, '9:00', '17:00')\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_189"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' busy times in minutes (start, end)\n    cheryl_busy = [\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60, 14 * 60),\n        (15 * 60, 16 * 60 + 30)\n    ]\n    raymond_busy = [\n        (11 * 60, 11 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60 + 30)\n    ]\n    karen_busy = [\n        (9 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 14 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    joan_busy = [\n        (9 * 60, 10 * 60 + 30),\n        (11 * 60, 12 * 60 + 30),\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n\n    # Raymond's preference: not after 11:30 (so before 11:30)\n    # But since all his busy times start at or after 11:00, we can ignore this preference\n    # because no slots are available before 11:30 that work for everyone.\n\n    # Combine all busy times and sort\n    all_busy = cheryl_busy + raymond_busy + karen_busy + joan_busy\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    prev_end = work_start\n\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n\n    if work_end > prev_end:\n        free_slots.append((prev_end, work_end))\n\n    # Check for a 30-minute slot\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Found a suitable slot\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_190"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:30:12:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, meeting_duration, work_hours_start, work_hours_end):\n    # Convert all time strings to minutes since start of the day\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals from all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for sufficient duration\n    meeting_duration_min = meeting_duration * 60\n    for start, end in free_intervals:\n        if end - start >= meeting_duration_min:\n            meeting_end = start + meeting_duration_min\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Beverly's calendar is wide open\n    [],  # Austin is free the entire day\n    [\"09:00:09:30\", \"10:30:11:00\", \"12:00:12:30\", \"13:30:15:00\", \"15:30:16:30\"],  # Rachel\n    [\"09:30:11:30\", \"12:00:13:30\", \"14:00:15:30\", \"16:00:17:00\"],  # Andrea\n]\n\n# Find a 30-minute meeting between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, 30, \"09:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_191"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each participant's busy slots to minutes\n    thomas_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    \n    amanda_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (13 * 60 + 30, 14 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    joe_busy = [\n        (9 * 60, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    # Joe cannot meet after 14:00, so add constraint\n    joe_busy.append((14 * 60, 17 * 60))\n    \n    christina_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (11 * 60, 13 * 60),\n        (14 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Combine all busy slots\n    all_busy = thomas_busy + amanda_busy + joe_busy + christina_busy\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check if there's a free slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Look for the first free slot that is at least 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert start time back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_time = start + meeting_duration\n            end_hh = end_time // 60\n            end_mm = end_time % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_192"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours\n    start_min = time_to_minutes(start_work)\n    end_min = time_to_minutes(end_work)\n    \n    # Initialize a list to track busy intervals for all participants\n    all_busy = []\n    for busy_slots in participants_busy:\n        participant_busy = []\n        for slot in busy_slots:\n            start, end = slot\n            participant_busy.append((time_to_minutes(start), time_to_minutes(end)))\n        all_busy.append(participant_busy)\n    \n    # Find all possible slots where no one is busy\n    possible_slots = []\n    current_time = start_min\n    \n    while current_time + duration <= end_min:\n        slot_valid = True\n        for participant in all_busy:\n            for busy_start, busy_end in participant:\n                if not (current_time + duration <= busy_start or current_time >= busy_end):\n                    slot_valid = False\n                    break\n            if not slot_valid:\n                break\n        \n        if slot_valid:\n            possible_slots.append((current_time, current_time + duration))\n            current_time += duration\n        else:\n            current_time += 1  # Check next minute\n    \n    if not possible_slots:\n        return None\n    \n    # Return the first valid slot\n    first_slot = possible_slots[0]\n    start_time = minutes_to_time(first_slot[0])\n    end_time = minutes_to_time(first_slot[1])\n    return f\"{start_time}:{end_time}\"\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 30  # minutes\n\n# Define busy slots for each participant\nparticipants_busy = [\n    [(\"9:30\", \"10:00\"), (\"10:30\", \"11:00\"), (\"11:30\", \"12:00\"), (\"13:30\", \"14:00\"), (\"15:00\", \"15:30\"), (\"16:00\", \"16:30\")],  # Lisa\n    [(\"9:00\", \"9:30\"), (\"11:30\", \"12:00\"), (\"14:00\", \"15:00\")],  # Joshua\n    [(\"9:00\", \"10:30\"), (\"11:00\", \"12:00\"), (\"12:30\", \"13:30\"), (\"14:00\", \"15:00\"), (\"16:30\", \"17:00\")],  # James\n    [(\"9:00\", \"14:00\"), (\"14:30\", \"15:30\"), (\"16:00\", \"17:00\")]  # Steven\n]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_193"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours=('09:00', '17:00')):\n    # Convert all time strings to minutes since 9:00 for easier comparison\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work_hours start at 9:00\n\n    work_start, work_end = work_hours\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n\n    # Collect all busy intervals for each participant\n    busy_intervals = []\n    for schedule in participants_schedules.values():\n        for busy in schedule:\n            start, end = busy.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            busy_intervals.append((start_min, end_min))\n\n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n\n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start_min\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n\n    # Now, find overlapping free intervals across all participants\n    # To simplify, we'll merge all busy intervals and find gaps\n    # But in reality, we should find common free times across all participants\n    # So a better approach is to find times when no one is busy\n    # Let's instead find all busy intervals for any participant and invert them\n\n    # Merge all busy intervals from all participants\n    merged_busy = []\n    for start, end in busy_intervals:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n\n    # Now find gaps between merged busy intervals\n    common_free = []\n    prev_end = work_start_min\n    for start, end in merged_busy:\n        if start > prev_end:\n            common_free.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        common_free.append((prev_end, work_end_min))\n\n    # Find the first free interval that can fit the meeting\n    for start, end in common_free:\n        if end - start >= duration_minutes:\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = 9 + minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration_minutes)\n            return f\"{meeting_start}:{meeting_end}\"\n\n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    'Dennis': [\n        '9:30 to 10:30',\n        '11:30 to 12:00',\n        '13:30 to 14:00',\n        '14:30 to 15:00',\n        '15:30 to 16:00'\n    ],\n    'Victoria': [\n        '9:00 to 9:30',\n        '10:30 to 11:00',\n        '11:30 to 12:00',\n        '12:30 to 13:00',\n        '14:30 to 15:30'\n    ],\n    'Samantha': [\n        '9:00 to 10:00',\n        '10:30 to 11:00',\n        '11:30 to 12:30',\n        '13:00 to 14:00',\n        '14:30 to 15:00',\n        '16:00 to 17:00'\n    ],\n    'Jeffrey': [\n        '9:00 to 9:30',\n        '10:30 to 11:00',\n        '11:30 to 13:00',\n        '13:30 to 15:00',\n        '15:30 to 16:00',\n        '16:30 to 17:00'\n    ]\n}\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_194"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define busy intervals for each participant in minutes since midnight\n    donna_busy = [(11 * 60 + 30, 12 * 60), (14 * 60 + 30, 15 * 60)]\n    andrea_busy = [(9 * 60, 9 * 60 + 30), (11 * 60 + 30, 14 * 60), (15 * 60 + 30, 16 * 60 + 30)]\n    dylan_busy = [(9 * 60, 9 * 60 + 30), (10 * 60, 11 * 60), (11 * 60 + 30, 17 * 60)]\n    \n    # Aaron's constraint: avoid after 10:30 (10:30 in minutes is 10*60 + 30 = 630)\n    aaron_constraint = 10 * 60 + 30\n    \n    # Meeting duration is 30 minutes\n    duration = 30\n    \n    # Generate all possible 30-minute slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + duration <= work_end:\n        slot_end = current_time + duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 1  # Check every minute\n    \n    # Check each slot against all constraints\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        \n        # Check Aaron's constraint (slot must start before or at 10:30)\n        if slot_start > aaron_constraint:\n            continue\n        \n        # Check Donna's availability\n        donna_available = True\n        for busy_start, busy_end in donna_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                donna_available = False\n                break\n        if not donna_available:\n            continue\n        \n        # Check Andrea's availability\n        andrea_available = True\n        for busy_start, busy_end in andrea_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                andrea_available = False\n                break\n        if not andrea_available:\n            continue\n        \n        # Check Dylan's availability\n        dylan_available = True\n        for busy_start, busy_end in dylan_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                dylan_available = False\n                break\n        if not dylan_available:\n            continue\n        \n        # If all checks passed, return this slot\n        return f\"{slot_start // 60:02d}:{slot_start % 60:02d}:{slot_end // 60:02d}:{slot_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_195"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy_intervals = []\n    for schedule in participants_schedules:\n        participant_busy = []\n        for busy in schedule:\n            start, end = busy.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            participant_busy.append((start_min, end_min))\n        all_busy_intervals.append(participant_busy)\n    \n    # Find all free intervals for each participant\n    all_free_intervals = []\n    for busy_intervals in all_busy_intervals:\n        free_intervals = []\n        # Sort busy intervals by start time\n        busy_intervals.sort()\n        # Check before first busy interval\n        if busy_intervals[0][0] > work_start:\n            free_intervals.append((work_start, busy_intervals[0][0]))\n        # Check between busy intervals\n        for i in range(1, len(busy_intervals)):\n            prev_end = busy_intervals[i-1][1]\n            curr_start = busy_intervals[i][0]\n            if curr_start > prev_end:\n                free_intervals.append((prev_end, curr_start))\n        # Check after last busy interval\n        if busy_intervals[-1][1] < work_end:\n            free_intervals.append((busy_intervals[-1][1], work_end))\n        all_free_intervals.append(free_intervals)\n    \n    # Find overlapping free intervals across all participants\n    common_free_intervals = all_free_intervals[0]\n    for free_intervals in all_free_intervals[1:]:\n        new_common_free = []\n        i = j = 0\n        while i < len(common_free_intervals) and j < len(free_intervals):\n            start1, end1 = common_free_intervals[i]\n            start2, end2 = free_intervals[j]\n            # Find the overlap\n            overlap_start = max(start1, start2)\n            overlap_end = min(end1, end2)\n            if overlap_start < overlap_end:\n                new_common_free.append((overlap_start, overlap_end))\n            # Move the pointer which ends first\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free_intervals = new_common_free\n    \n    # Find the first interval that can fit the duration\n    for interval in common_free_intervals:\n        start, end = interval\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = start + duration\n            return (f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\")\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"10:00 to 11:00\", \"15:00 to 15:30\", \"16:30 to 17:00\"],  # Jonathan\n    [\"10:30 to 11:00\", \"11:30 to 12:00\"],                   # Lisa\n    [\"9:00 to 13:00\", \"13:30 to 14:30\", \"15:00 to 17:00\"],  # Jerry\n    [\"9:30 to 14:30\", \"15:00 to 17:00\"]                     # Emma\n]\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30  # half an hour\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_196"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours_start=\"9:00\", work_hours_end=\"17:00\"):\n    # Convert work hours to minutes since midnight\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's schedule to find common free slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_slots.append((start, end))\n        # Sort the busy slots by start time\n        busy_slots.sort()\n        \n        # Subtract busy slots from current free slots\n        new_free_slots = []\n        for free_start, free_end in free_slots:\n            current_start = free_start\n            for busy_start, busy_end in busy_slots:\n                if busy_start > current_start:\n                    new_free_slots.append((current_start, busy_start))\n                current_start = max(current_start, busy_end)\n            if current_start < free_end:\n                new_free_slots.append((current_start, free_end))\n        free_slots = new_free_slots\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot in free_slots:\n        start, end = slot\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [],  # Hannah is free all day\n    [\"9:00 to 10:00\", \"12:00 to 12:30\", \"16:30 to 17:00\"],  # Austin\n    [\"9:00 to 10:00\", \"10:30 to 13:00\", \"13:30 to 14:00\"],  # Donna\n    [\"9:00 to 12:30\", \"13:00 to 15:00\", \"15:30 to 17:00\"],  # Bobby\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_197"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy blocks to minutes since 9:00\n    # Keith: 9:00-9:30, 10:30-12:00, 12:30-13:30\n    keith_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 13 * 60 + 30)\n    ]\n    # Wayne: 9:00-9:30, 10:30-11:00, 14:30-15:00, 16:00-16:30\n    wayne_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 11 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    # Harold: 9:00-10:00, 10:30-11:00, 11:30-12:30, 13:00-14:00, 15:00-15:30\n    harold_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (13 * 60, 14 * 60),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    # Ralph: 9:00-9:30, 10:30-15:30, 16:00-16:30\n    ralph_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 15 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n\n    # Wayne prefers after 16:00, so prioritize times after 16:00\n    preferred_start = 16 * 60\n\n    # Check if preferred time works (16:00-16:30 is blocked, so next is 16:30-17:00)\n    start_time = preferred_start + 30  # 16:30\n    end_time = start_time + meeting_duration\n    if end_time <= work_end:\n        # Check if all are free\n        all_free = True\n        # Check Keith\n        for start, end in keith_busy:\n            if not (end_time <= start or start_time >= end):\n                all_free = False\n                break\n        if all_free:\n            # Check Wayne\n            for start, end in wayne_busy:\n                if not (end_time <= start or start_time >= end):\n                    all_free = False\n                    break\n            if all_free:\n                # Check Harold\n                for start, end in harold_busy:\n                    if not (end_time <= start or start_time >= end):\n                        all_free = False\n                        break\n                if all_free:\n                    # Check Ralph\n                    for start, end in ralph_busy:\n                        if not (end_time <= start or start_time >= end):\n                            all_free = False\n                            break\n                    if all_free:\n                        return f\"{start_time // 60:02d}:{start_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n\n    # If preferred time doesn't work, check other times\n    for start_time in range(work_start, work_end - meeting_duration + 1, 15):  # check every 15 minutes\n        end_time = start_time + meeting_duration\n        if end_time > work_end:\n            continue\n        # Skip times before 16:00 due to Wayne's preference\n        if start_time < 16 * 60:\n            continue\n        # Check if all are free\n        all_free = True\n        # Check Keith\n        for start, end in keith_busy:\n            if not (end_time <= start or start_time >= end):\n                all_free = False\n                break\n        if not all_free:\n            continue\n        # Check Wayne\n        for start, end in wayne_busy:\n            if not (end_time <= start or start_time >= end):\n                all_free = False\n                break\n        if not all_free:\n            continue\n        # Check Harold\n        for start, end in harold_busy:\n            if not (end_time <= start or start_time >= end):\n                all_free = False\n                break\n        if not all_free:\n            continue\n        # Check Ralph\n        for start, end in ralph_busy:\n            if not (end_time <= start or start_time >= end):\n                all_free = False\n                break\n        if all_free:\n            return f\"{start_time // 60:02d}:{start_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n\n    # If no time after 16:00 works, check earlier (though Wayne prefers after 16:00)\n    for start_time in range(work_start, work_end - meeting_duration + 1, 15):\n        end_time = start_time + meeting_duration\n        if end_time > work_end:\n            continue\n        # Check if all are free\n        all_free = True\n        # Check Keith\n        for start, end in keith_busy:\n            if not (end_time <= start or start_time >= end):\n                all_free = False\n                break\n        if not all_free:\n            continue\n        # Check Wayne\n        for start, end in wayne_busy:\n            if not (end_time <= start or start_time >= end):\n                all_free = False\n                break\n        if not all_free:\n            continue\n        # Check Harold\n        for start, end in harold_busy:\n            if not (end_time <= start or start_time >= end):\n                all_free = False\n                break\n        if not all_free:\n            continue\n        # Check Ralph\n        for start, end in ralph_busy:\n            if not (end_time <= start or start_time >= end):\n                all_free = False\n                break\n        if all_free:\n            return f\"{start_time // 60:02d}:{start_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n\n    return \"No time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_198"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' schedules and constraints\n    schedules = {\n        'Elizabeth': [(11 * 60 + 30, 12 * 60), (13 * 60 + 30, 14 * 60), (15 * 60, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n        'Christian': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (11 * 60, 11 * 60 + 30), (12 * 60 + 30, 13 * 60 + 30), (15 * 60 + 30, 17 * 60)],\n        'Isabella': [(9 * 60 + 30, 11 * 60 + 30), (12 * 60 + 30, 13 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n    }\n    \n    # Carol's constraint: not before 12:30\n    carol_constraint = 12 * 60 + 30\n    \n    # Duration of the meeting in minutes\n    duration = 30\n    \n    # Generate all possible time slots\n    possible_slots = []\n    current_time = max(work_start, carol_constraint)\n    \n    while current_time + duration <= work_end:\n        possible_slots.append((current_time, current_time + duration))\n        current_time += 30  # Check every 30 minutes\n    \n    # Check each slot against all participants' schedules\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        valid = True\n        \n        # Check Elizabeth's schedule\n        for meeting in schedules['Elizabeth']:\n            if not (slot_end <= meeting[0] or slot_start >= meeting[1]):\n                valid = False\n                break\n        if not valid:\n            continue\n        \n        # Check Christian's schedule\n        for meeting in schedules['Christian']:\n            if not (slot_end <= meeting[0] or slot_start >= meeting[1]):\n                valid = False\n                break\n        if not valid:\n            continue\n        \n        # Check Isabella's schedule\n        for meeting in schedules['Isabella']:\n            if not (slot_end <= meeting[0] or slot_start >= meeting[1]):\n                valid = False\n                break\n        if not valid:\n            continue\n        \n        # If all checks passed, return this slot\n        start_h = slot_start // 60\n        start_m = slot_start % 60\n        end_h = slot_end // 60\n        end_m = slot_end % 60\n        return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    \n    return \"No suitable time found\"\n\n# Run the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_199"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes\n    # Format: (start_minute, end_minute)\n    stephen_busy = []\n    elijah_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    william_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    jeremy_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 12 * 60),\n        (13 * 60, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    timothy_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 14 * 60 + 30),\n        (15 * 60 + 30, 16 * 60)\n    ]\n\n    # Combine all busy slots\n    all_busy = elijah_busy + william_busy + jeremy_busy + timothy_busy\n\n    # Generate free slots by inverting busy slots\n    all_busy.sort()  # Sort by start time\n    free_slots = []\n    previous_end = work_start\n\n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_200"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each participant's blocked times to minutes since midnight\n    sarah_blocks = [(12 * 60, 12 * 60 + 30), (15 * 60, 15 * 60 + 30)]\n    shirley_blocks = [(13 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60)]\n    harold_blocks = [(9 * 60, 10 * 60), (10 * 60 + 30, 12 * 60 + 30), (13 * 60, 17 * 60)]\n    terry_blocks = [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60 + 30), (12 * 60, 17 * 60)]\n    \n    # Sara has no meetings, so no blocks\n    \n    # Combine all blocked times\n    all_blocks = sarah_blocks + shirley_blocks + harold_blocks + terry_blocks\n    \n    # Sort blocks by start time\n    all_blocks.sort()\n    \n    # Find free slots by checking gaps between blocks and work hours\n    free_slots = []\n    previous_end = work_start\n    \n    for block in all_blocks:\n        if block[0] > previous_end:\n            free_slots.append((previous_end, block[0]))\n        previous_end = max(previous_end, block[1])\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Check for a slot that is at least 30 minutes long\n    meeting_duration = 30\n    for slot in free_slots:\n        if slot[1] - slot[0] >= meeting_duration:\n            # Return the first suitable slot\n            start_hour = slot[0] // 60\n            start_min = slot[0] % 60\n            end_hour = (slot[0] + meeting_duration) // 60\n            end_min = (slot[0] + meeting_duration) % 60\n            return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_201"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n\n    # Collect all busy intervals for all participants\n    all_busy_intervals = []\n    for busy_times in participants_busy_times.values():\n        for interval in busy_times:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            all_busy_intervals.append((start, end))\n\n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n\n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in all_busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n\n    # Check each free interval for availability for all participants\n    for interval in free_intervals:\n        start, end = interval\n        duration = end - start\n        if duration >= meeting_duration:\n            # Check if this interval is free for all participants\n            valid = True\n            for participant, busy_times in participants_busy_times.items():\n                participant_free = True\n                # Check if the interval overlaps with any of the participant's busy times\n                for busy_interval in busy_times:\n                    busy_start, busy_end = map(time_to_minutes, busy_interval.split(' to '))\n                    if not (end <= busy_start or start >= busy_end):\n                        participant_free = False\n                        break\n                if not participant_free:\n                    valid = False\n                    break\n            if valid:\n                meeting_end = start + meeting_duration\n                return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No suitable time found\"\n\n# Define the participants' busy times\nparticipants_busy_times = {\n    \"Lawrence\": [],\n    \"Christine\": [\"9:00 to 9:30\", \"12:30 to 13:00\"],\n    \"Barbara\": [\"10:30 to 11:30\", \"12:00 to 12:30\", \"13:00 to 13:30\", \"14:00 to 14:30\", \"15:30 to 16:00\"],\n    \"Stephanie\": [\"10:00 to 11:00\", \"11:30 to 12:00\", \"12:30 to 13:30\", \"14:30 to 15:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"],\n    \"Hannah\": [\"9:00 to 10:00\", \"10:30 to 12:00\", \"12:30 to 13:00\", \"14:00 to 15:30\", \"16:00 to 16:30\"]\n}\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 30  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_202"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time slots to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n\n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n\n    # Function to subtract busy slots from free slots\n    def subtract_busy_slots(free_slots, busy_start, busy_end):\n        new_free_slots = []\n        for slot_start, slot_end in free_slots:\n            if busy_start >= slot_end or busy_end <= slot_start:\n                new_free_slots.append((slot_start, slot_end))\n            else:\n                if slot_start < busy_start:\n                    new_free_slots.append((slot_start, busy_start))\n                if slot_end > busy_end:\n                    new_free_slots.append((busy_end, slot_end))\n        return new_free_slots\n\n    # Process each participant's busy slots\n    for participant, busy_slots in participants_schedules.items():\n        for busy_start_str, busy_end_str in busy_slots:\n            busy_start = time_to_minutes(busy_start_str)\n            busy_end = time_to_minutes(busy_end_str)\n            free_slots = subtract_busy_slots(free_slots, busy_start, busy_end)\n\n    # Find the earliest slot that fits the duration\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = {\n    'Elijah': [('10:00', '11:00'), ('12:00', '12:30'), ('15:00', '15:30')],\n    'Janet': [('9:30', '10:30'), ('13:30', '15:30')],\n    'Brian': [],\n    'Carl': [('9:30', '16:30')],\n    'Timothy': [('10:30', '12:00'), ('13:30', '14:00'), ('14:30', '16:00'), ('16:30', '17:00')]\n}\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, '9:00', '17:00', 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_203"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability for all participants\n    # Since the problem states a solution exists, we return the first suitable interval\n    for interval in free_intervals:\n        start, end = interval\n        if end - start >= duration:\n            meeting_end = start + duration\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\n# Define each participant's busy times\nparticipants_schedules = [\n    [\"10:00 to 10:30\", \"11:30 to 12:00\", \"12:30 to 13:00\", \"13:30 to 14:00\", \"15:00 to 15:30\", \"16:00 to 16:30\"],  # Benjamin\n    [\"10:00 to 10:30\", \"11:00 to 11:30\", \"12:00 to 12:30\", \"14:30 to 16:00\"],  # Juan\n    [\"9:00 to 9:30\", \"10:00 to 10:30\", \"12:30 to 13:00\", \"14:00 to 14:30\"],  # Heather\n    [\"9:00 to 11:00\", \"11:30 to 12:30\", \"14:00 to 14:30\", \"15:00 to 16:00\", \"16:30 to 17:00\"],  # Nathan\n    [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:00 to 13:00\", \"13:30 to 15:00\", \"15:30 to 17:00\"],  # Jacob\n]\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes))\n```",
            "count": "calendar_scheduling_example_204"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:30:12:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n\n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(':'))\n            busy_intervals.append((start, end))\n\n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n\n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Find the first available slot that can fit the meeting\n    duration_minutes = duration * 60\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"10:30:11:30\", \"12:00:12:30\", \"13:00:13:30\", \"14:00:14:30\", \"15:00:15:30\"],  # Julia\n    [],                                                                           # Joshua\n    [\"09:00:09:30\", \"12:00:12:30\", \"15:30:16:30\"],                                # Nicholas\n    [\"09:00:11:00\", \"12:00:12:30\", \"13:00:13:30\", \"14:00:15:00\", \"16:00:17:00\"], # David\n    [\"09:00:09:30\", \"12:30:13:00\", \"13:30:15:00\", \"15:30:17:00\"],                # Melissa\n]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, 30, \"09:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_205"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Convert all schedules to minutes since midnight\n    # Each person's busy times are represented as a list of (start, end) tuples in minutes\n    schedules = {\n        'Shirley': [(10 * 60 + 30, 11 * 60), (12 * 60, 12 * 60 + 30)],\n        'Jacob': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (11 * 60, 11 * 60 + 30),\n                  (12 * 60 + 30, 13 * 60 + 30), (14 * 60 + 30, 15 * 60)],\n        'Stephen': [(11 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60)],\n        'Margaret': [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 12 * 60 + 30), (13 * 60, 13 * 60 + 30),\n                     (15 * 60, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n        'Mason': [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60), (11 * 60 + 30, 12 * 60 + 30),\n                  (13 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n    }\n    \n    # Margaret's preference: not before 14:30\n    margaret_preference_start = 14 * 60 + 30\n    \n    # Meeting duration in minutes\n    meeting_duration = 30\n    \n    # Collect all busy times from all participants\n    all_busy = []\n    for person in schedules:\n        for start, end in schedules[person]:\n            all_busy.append((start, end))\n    \n    # Sort all busy times by start time\n    all_busy.sort()\n    \n    # Find available slots by merging busy intervals\n    available_slots = []\n    current_start = work_start\n    \n    for start, end in all_busy:\n        if start > current_start:\n            available_slots.append((current_start, start))\n        current_start = max(current_start, end)\n    \n    if current_start < work_end:\n        available_slots.append((current_start, work_end))\n    \n    # Filter slots that are at least meeting_duration long and meet Margaret's preference\n    valid_slots = []\n    for start, end in available_slots:\n        slot_start = max(start, margaret_preference_start)\n        if end - slot_start >= meeting_duration:\n            valid_slots.append((slot_start, end))\n    \n    # The first valid slot is the earliest possible meeting time\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available time slot found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_206"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, duration, work_start, work_end):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n\n    # Initialize the free slots for each participant\n    free_slots = []\n    for participant in participants_busy:\n        busy_slots = participants_busy[participant]\n        # Convert busy slots to minutes\n        busy_min = []\n        for slot in busy_slots:\n            start, end = map(time_to_minutes, slot.split(':'))\n            busy_min.append((start, end))\n        # Sort busy slots by start time\n        busy_min.sort()\n        # Generate free slots\n        free = []\n        prev_end = work_start_min\n        for start, end in busy_min:\n            if start > prev_end:\n                free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end_min:\n            free.append((prev_end, work_end_min))\n        free_slots.append(free)\n\n    # Find common free slots\n    common_free = free_slots[0]\n    for free in free_slots[1:]:\n        new_common = []\n        i = j = 0\n        while i < len(common_free) and j < len(free):\n            start1, end1 = common_free[i]\n            start2, end2 = free[j]\n            # Find overlap\n            start = max(start1, start2)\n            end = min(end1, end2)\n            if start < end:\n                new_common.append((start, end))\n            # Move the pointer which ends first\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free = new_common\n\n    # Find the earliest slot that fits the duration\n    for start, end in common_free:\n        if end - start >= duration_min:\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration_min)\n            return f\"{meeting_start}:{meeting_end}\"\n    return None\n\n# Define participants' busy slots\nparticipants_busy = {\n    'Walter': [],\n    'Danielle': [],\n    'Julia': ['09:30:10:00', '10:30:11:00', '13:30:14:00', '16:00:16:30'],\n    'Samuel': ['09:00:11:00', '11:30:12:30', '13:00:14:30', '15:00:15:30', '16:00:17:00'],\n    'Lori': ['10:00:10:30', '11:00:11:30', '12:00:12:30', '13:00:14:30', '15:00:17:00'],\n}\n\n# Meeting duration in hours (0.5 hours = 30 minutes)\nduration = 0.5\nwork_start = '09:00'\nwork_end = '17:00'\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy, duration, work_start, work_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_207"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define each person's busy times in minutes (start, end)\n    busy_times = {\n        'Jesse': [(10 * 60, 10 * 60 + 30), (15 * 60, 15 * 60 + 30)],\n        'Nancy': [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 11 * 60), (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60)],\n        'Isabella': [(9 * 60, 10 * 60), (11 * 60 + 30, 12 * 60), (15 * 60 + 30, 16 * 60)],\n        'Harold': [(9 * 60, 10 * 60), (10 * 60 + 30, 16 * 60 + 30)],\n        'Linda': [(9 * 60, 10 * 60), (12 * 60, 12 * 60 + 30), (13 * 60 + 30, 16 * 60)],\n    }\n    \n    # Combine all busy times and sort\n    all_busy = []\n    for person in busy_times:\n        all_busy.extend(busy_times[person])\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Check each free slot for availability for all participants\n    meeting_duration = 30\n    valid_slots = []\n    \n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Check if all participants are free during this slot\n            all_free = True\n            for person in busy_times:\n                person_busy = busy_times[person]\n                for busy_start, busy_end in person_busy:\n                    if not (slot_start >= busy_end or slot_start + meeting_duration <= busy_start):\n                        # Overlap found, person is busy\n                        all_free = False\n                        break\n                if not all_free:\n                    break\n            if all_free:\n                valid_slots.append((slot_start, slot_start + meeting_duration))\n    \n    # Return the first valid slot found\n    if valid_slots:\n        start = valid_slots[0][0]\n        end = valid_slots[0][1]\n        # Convert minutes back to HH:MM format\n        start_hh = start // 60\n        start_mm = start % 60\n        end_hh = end // 60\n        end_mm = end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No valid slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_208"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Convert each participant's busy slots to minutes\n    michael_busy = [(10 * 60 + 30, 11 * 60), (14 * 60 + 30, 15 * 60)]\n    samuel_busy = [(10 * 60 + 30, 11 * 60), (12 * 60 + 30, 13 * 60), \n                    (13 * 60 + 30, 14 * 60 + 30), (15 * 60 + 30, 16 * 60), \n                    (16 * 60 + 30, 17 * 60)]\n    aaron_busy = [(11 * 60, 11 * 60 + 30), (12 * 60 + 30, 13 * 60), \n                   (13 * 60 + 30, 14 * 60), (15 * 60, 15 * 60 + 30), \n                   (16 * 60, 17 * 60)]\n    judith_busy = [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 11 * 60 + 30), \n                    (12 * 60, 12 * 60 + 30), (14 * 60, 15 * 60), \n                    (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)]\n    kevin_busy = [(9 * 60, 11 * 60), (11 * 60 + 30, 13 * 60), \n                   (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60), \n                   (15 * 60 + 30, 16 * 60)]\n    \n    # Combine all busy slots\n    all_busy = michael_busy + samuel_busy + aaron_busy + judith_busy + kevin_busy\n    \n    # Generate free slots by inverting busy slots\n    free_slots = []\n    current_time = work_start\n    \n    # Sort all busy slots by start time\n    all_busy_sorted = sorted(all_busy, key=lambda x: x[0])\n    \n    for busy_start, busy_end in all_busy_sorted:\n        if busy_start > current_time:\n            free_slots.append((current_time, busy_start))\n        current_time = max(current_time, busy_end)\n    \n    if current_time < work_end:\n        free_slots.append((current_time, work_end))\n    \n    # Find the first free slot that is at least 30 minutes long\n    meeting_duration = 30\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Convert back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = (slot_start + meeting_duration) // 60\n            end_mm = (slot_start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_209"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each person's busy slots to minutes\n    raymond_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60, 11 * 60 + 30),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    daniel_busy = [\n        (11 * 60, 11 * 60 + 30),\n        (14 * 60, 14 * 60 + 30)\n    ]\n    \n    julia_busy = [\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60)\n    ]\n    \n    laura_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 12 * 60 + 30),\n        (15 * 60 + 30, 16 * 60 + 30)\n    ]\n    \n    willie_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 12 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Combine all busy slots\n    all_busy = raymond_busy + daniel_busy + julia_busy + laura_busy + willie_busy\n    \n    # Generate free slots by inverting busy slots\n    free_slots = []\n    current_time = work_start\n    \n    # Sort all busy slots by start time\n    sorted_busy = sorted(all_busy, key=lambda x: x[0])\n    \n    for busy_start, busy_end in sorted_busy:\n        if busy_start > current_time:\n            free_slots.append((current_time, busy_start))\n        current_time = max(current_time, busy_end)\n    \n    if current_time < work_end:\n        free_slots.append((current_time, work_end))\n    \n    # Check each free slot to see if it's free for everyone\n    meeting_duration = 30\n    valid_slots = []\n    \n    for slot_start, slot_end in free_slots:\n        slot_duration = slot_end - slot_start\n        if slot_duration >= meeting_duration:\n            # Check if this slot is free for everyone\n            raymond_free = all(not (busy_end > slot_start and busy_start < slot_start + meeting_duration) for busy_start, busy_end in raymond_busy)\n            daniel_free = all(not (busy_end > slot_start and busy_start < slot_start + meeting_duration) for busy_start, busy_end in daniel_busy)\n            julia_free = all(not (busy_end > slot_start and busy_start < slot_start + meeting_duration) for busy_start, busy_end in julia_busy)\n            laura_free = all(not (busy_end > slot_start and busy_start < slot_start + meeting_duration) for busy_start, busy_end in laura_busy)\n            willie_free = all(not (busy_end > slot_start and busy_start < slot_start + meeting_duration) for busy_start, busy_end in willie_busy)\n            \n            if raymond_free and daniel_free and julia_free and laura_free and willie_free:\n                valid_slots.append((slot_start, slot_start + meeting_duration))\n    \n    if not valid_slots:\n        return None\n    \n    # Find the earliest valid slot\n    earliest_slot = min(valid_slots, key=lambda x: x[0])\n    \n    # Convert to HH:MM format\n    start_hh = earliest_slot[0] // 60\n    start_mm = earliest_slot[0] % 60\n    end_hh = earliest_slot[1] // 60\n    end_mm = earliest_slot[1] % 60\n    \n    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_210"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_start, work_end):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find the earliest available slot\n    prev_end = work_start_min\n    for start, end in merged:\n        if start - prev_end >= duration_min:\n            # Found a suitable slot\n            meeting_start = prev_end\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n        prev_end = max(prev_end, end)\n    \n    # Check after the last busy interval\n    if work_end_min - prev_end >= duration_min:\n        meeting_start = prev_end\n        meeting_end = meeting_start + duration_min\n        return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Douglas is free the entire day\n    [\"09:30 to 10:00\", \"11:00 to 11:30\"],  # Mary\n    [\"09:00 to 10:00\", \"10:30 to 11:30\", \"13:30 to 14:30\"],  # Billy\n    [\"09:30 to 10:00\", \"11:00 to 11:30\", \"13:30 to 16:00\", \"16:30 to 17:00\"],  # Russell\n    [\"09:00 to 10:00\", \"10:30 to 12:00\", \"12:30 to 17:00\"],  # Judy\n]\n\n# Find the earliest available 30-minute slot between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, 30, \"09:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_211"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define busy intervals for each participant in minutes\n    katherine_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60)\n    ]\n    \n    carl_busy = [\n        (10 * 60 + 30, 11 * 60 + 30)\n    ]\n    \n    charles_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60 + 30)\n    ]\n    \n    gerald_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60)\n    ]\n    \n    stephanie_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 12 * 60),\n        (13 * 60, 14 * 60),\n        (15 * 60, 16 * 60)\n    ]\n    \n    # Combine all busy intervals\n    all_busy = katherine_busy + carl_busy + charles_busy + gerald_busy + stephanie_busy\n    \n    # Sort busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by checking gaps between busy intervals\n    free_intervals = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the interval after the last busy interval\n    if previous_end < work_end:\n        free_intervals.append((previous_end, work_end))\n    \n    # Filter out intervals that are less than 30 minutes\n    free_intervals = [(start, end) for start, end in free_intervals if end - start >= 30]\n    \n    # Apply Charles' constraint: no meetings after 16:00\n    free_intervals = [(start, end) for start, end in free_intervals if start < 16 * 60]\n    \n    # Select the first available interval\n    if free_intervals:\n        meeting_start = free_intervals[0][0]\n        meeting_end = meeting_start + 30\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_212"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_work, end_work = work_hours\n    busy_slots = []\n    \n    # Collect all busy slots from all participants\n    for schedule in participants_schedules:\n        busy_slots.extend(schedule)\n    \n    # Sort all busy slots by start time\n    busy_slots.sort()\n    \n    # Merge overlapping or adjacent busy slots\n    merged_slots = []\n    for slot in busy_slots:\n        if not merged_slots:\n            merged_slots.append(slot)\n        else:\n            last_start, last_end = merged_slots[-1]\n            current_start, current_end = slot\n            if current_start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged_slots[-1] = (new_start, new_end)\n            else:\n                merged_slots.append(slot)\n    \n    # Find free slots between work hours considering merged busy slots\n    free_slots = []\n    previous_end = start_work\n    \n    for slot in merged_slots:\n        slot_start, slot_end = slot\n        if slot_start > previous_end:\n            free_slots.append((previous_end, slot_start))\n        previous_end = max(previous_end, slot_end)\n    \n    if previous_end < end_work:\n        free_slots.append((previous_end, end_work))\n    \n    # Find the first free slot that can accommodate the meeting duration\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        if (slot_end - slot_start) >= duration:\n            return f\"{slot_start}:{slot_start + duration}\"\n    \n    return \"No suitable time found\"\n\n# Define work hours (9:00 to 17:00 in 24-hour format)\nwork_hours = (9.0, 17.0)\nmeeting_duration = 1.0  # 1 hour\n\n# Define each participant's busy slots in 24-hour format as (start, end)\njeremy_schedule = [(9.0, 9.5), (11.0, 11.5), (13.5, 14.0), (15.0, 15.5)]\ndiana_schedule = []\nbeverly_schedule = []\ndiane_schedule = [(9.0, 9.5), (10.0, 10.5), (12.5, 13.5), (14.0, 14.5), (15.5, 17.0)]\nmegan_schedule = [(9.0, 10.0), (10.5, 11.5), (12.5, 13.0), (14.0, 16.5)]\n\nparticipants_schedules = [jeremy_schedule, diana_schedule, beverly_schedule, diane_schedule, megan_schedule]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, meeting_duration)\n\n# Format the output as HH:MM:HH:MM\nif meeting_time != \"No suitable time found\":\n    start, end = meeting_time.split(':')\n    start_h = int(float(start))\n    start_m = int((float(start) - start_h) * 60)\n    end_h = int(float(end))\n    end_m = int((float(end) - end_h) * 60)\n    print(f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\")\nelse:\n    print(meeting_time)\n```",
            "count": "calendar_scheduling_example_213"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours=('09:00', '17:00')):\n    # Convert time strings to minutes since 9:00 for easier calculation\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m - 9 * 60  # Offset by 9:00 (start of work day)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        h = (minutes // 60) + 9\n        m = minutes % 60\n        return f\"{h:02d}:{m:02d}\"\n    \n    start_work, end_work = work_hours\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find the earliest available slot\n    prev_end = work_start\n    for start, end in merged:\n        if start - prev_end >= duration_minutes:\n            return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + duration_minutes)}\"\n        prev_end = max(prev_end, end)\n    \n    # Check after the last busy interval\n    if work_end - prev_end >= duration_minutes:\n        return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + duration_minutes)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Donna is free\n    [],  # Susan is free\n    [\"09:00 to 09:30\", \"11:30 to 12:00\", \"13:00 to 13:30\", \"16:30 to 17:00\"],  # Ethan\n    [\"09:30 to 10:00\", \"10:30 to 11:00\", \"11:30 to 12:00\", \"13:00 to 14:00\", \"15:00 to 16:30\"],  # Adam\n    [\"09:00 to 10:30\", \"11:00 to 11:30\", \"12:00 to 12:30\", \"13:00 to 14:30\", \"15:00 to 15:30\", \"16:00 to 16:30\"],  # Jordan\n]\n\n# Find the earliest available meeting time\nmeeting_time = find_meeting_time(participants_schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_214"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, duration, work_hours):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start, work_end = map(time_to_minutes, work_hours.split('-'))\n    duration_min = duration * 60\n\n    # Generate all busy intervals for all participants\n    all_busy = []\n    for busy_times in participants_busy_times.values():\n        for start, end in busy_times:\n            all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort busy intervals by start time\n    all_busy.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find free slots between work hours and busy intervals\n    free_slots = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n\n    # Find the earliest free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define the participants' busy times\nparticipants_busy_times = {\n    \"Steven\": [],\n    \"Roy\": [],\n    \"Cynthia\": [\n        (\"09:30\", \"10:30\"),\n        (\"11:30\", \"12:00\"),\n        (\"13:00\", \"13:30\"),\n        (\"15:00\", \"16:00\")\n    ],\n    \"Lauren\": [\n        (\"09:00\", \"09:30\"),\n        (\"10:30\", \"11:00\"),\n        (\"11:30\", \"12:00\"),\n        (\"13:00\", \"13:30\"),\n        (\"14:00\", \"14:30\"),\n        (\"15:00\", \"15:30\"),\n        (\"16:00\", \"17:00\")\n    ],\n    \"Robert\": [\n        (\"10:30\", \"11:00\"),\n        (\"11:30\", \"12:00\"),\n        (\"12:30\", \"13:30\"),\n        (\"14:00\", \"16:00\")\n    ]\n}\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, 30, \"09:00-17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_215"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each participant's busy slots to minutes since 9:00\n    # Format: (start_minute, end_minute)\n    kathleen_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    ashley_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (15 * 60 + 30, 16 * 60 + 30)\n    ]\n    christian_busy = [\n        (9 * 60, 13 * 60),\n        (13 * 60 + 30, 15 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    matthew_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60 + 30),\n        (15 * 60, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n\n    # Combine all busy slots\n    all_busy = []\n    all_busy.extend(kathleen_busy)\n    all_busy.extend(ashley_busy)\n    all_busy.extend(christian_busy)\n    all_busy.extend(matthew_busy)\n\n    # Sort busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n\n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n\n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_216"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define each person's busy times in minutes since midnight\n    # Format: (start, end) in minutes\n    busy_times = {\n        'Lauren': [(9 * 60 + 30, 10 * 60), (14 * 60 + 30, 15 * 60)],\n        'Willie': [(9 * 60 + 30, 11 * 60 + 30), (12 * 60 + 30, 14 * 60), (15 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Lori': [(9 * 60 + 30, 10 * 60), (11 * 60, 11 * 60 + 30), (12 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30), (15 * 60, 16 * 60)],\n    }\n\n    # Lauren cannot meet after 14:30 (14*60 + 30)\n    lauren_cutoff = 14 * 60 + 30\n\n    # Combine all busy times and sort them\n    all_busy = []\n    for person, times in busy_times.items():\n        for start, end in times:\n            all_busy.append((start, end))\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy times and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Filter free slots that are at least meeting_duration long and before Lauren's cutoff\n    valid_slots = []\n    for start, end in free_slots:\n        if end - start >= meeting_duration and start + meeting_duration <= lauren_cutoff:\n            valid_slots.append((start, end))\n\n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_217"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each person's busy slots to minutes\n    sharon_busy = [\n        (12 * 60, 13 * 60),\n        (13 * 60 + 30, 14 * 60 + 30),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    elizabeth_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60)\n    ]\n    danielle_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 11 * 60),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60 + 30, 14 * 60)\n    ]\n    david_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60, 14 * 60 + 30),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    charles_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 11 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (15 * 60, 17 * 60)\n    ]\n    \n    # Combine all busy slots\n    all_busy = sharon_busy + elizabeth_busy + danielle_busy + david_busy + charles_busy\n    \n    # Generate free slots by inverting busy slots\n    free_slots = []\n    current_time = work_start\n    \n    # Sort all busy slots by start time\n    all_busy_sorted = sorted(all_busy, key=lambda x: x[0])\n    \n    for busy_start, busy_end in all_busy_sorted:\n        if busy_start > current_time:\n            free_slots.append((current_time, busy_start))\n        current_time = max(current_time, busy_end)\n    \n    if current_time < work_end:\n        free_slots.append((current_time, work_end))\n    \n    # Check each free slot to see if it's free for everyone\n    meeting_duration = 30\n    valid_slots = []\n    \n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Check if this slot is free for everyone\n            is_free_for_all = True\n            \n            # Check Sharon\n            for busy_start, busy_end in sharon_busy:\n                if not (slot_start >= busy_end or slot_start + meeting_duration <= busy_start):\n                    is_free_for_all = False\n                    break\n            if not is_free_for_all:\n                continue\n            \n            # Check Elizabeth\n            for busy_start, busy_end in elizabeth_busy:\n                if not (slot_start >= busy_end or slot_start + meeting_duration <= busy_start):\n                    is_free_for_all = False\n                    break\n            if not is_free_for_all:\n                continue\n            \n            # Check Danielle\n            for busy_start, busy_end in danielle_busy:\n                if not (slot_start >= busy_end or slot_start + meeting_duration <= busy_start):\n                    is_free_for_all = False\n                    break\n            if not is_free_for_all:\n                continue\n            \n            # Check David\n            for busy_start, busy_end in david_busy:\n                if not (slot_start >= busy_end or slot_start + meeting_duration <= busy_start):\n                    is_free_for_all = False\n                    break\n            if not is_free_for_all:\n                continue\n            \n            # Check Charles\n            for busy_start, busy_end in charles_busy:\n                if not (slot_start >= busy_end or slot_start + meeting_duration <= busy_start):\n                    is_free_for_all = False\n                    break\n            if not is_free_for_all:\n                continue\n            \n            valid_slots.append((slot_start, slot_start + meeting_duration))\n    \n    if valid_slots:\n        # Return the first valid slot\n        start = valid_slots[0][0]\n        end = valid_slots[0][1]\n        # Convert to HH:MM format\n        start_hh = start // 60\n        start_mm = start % 60\n        end_hh = end // 60\n        end_mm = end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_218"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = busy.split(' to ')\n            busy_start = time_to_minutes(start)\n            busy_end = time_to_minutes(end)\n            busy_intervals.append((busy_start, busy_end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Check each available slot for sufficient duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30  # meeting duration in minutes\n\n# Define each participant's busy intervals\nparticipants_schedules = [\n    [\"9:00 to 9:30\", \"10:00 to 11:00\", \"11:30 to 12:00\", \"14:30 to 15:30\"],  # Thomas\n    [\"12:00 to 12:30\", \"13:00 to 14:00\", \"15:00 to 15:30\"],  # Terry\n    [\"11:30 to 12:00\", \"12:30 to 13:30\", \"14:00 to 14:30\", \"16:00 to 17:00\"],  # Kenneth\n    [\"9:30 to 10:00\", \"10:30 to 11:30\", \"12:00 to 14:00\", \"15:00 to 15:30\", \"16:00 to 17:00\"],  # Andrew\n    [\"9:00 to 10:30\", \"11:30 to 13:00\", \"13:30 to 14:30\", \"15:00 to 15:30\", \"16:00 to 16:30\"],  # Sharon\n]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_219"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy times in minutes (start, end)\n    mason_busy = []\n    evelyn_busy = []\n    jose_busy = [(9 * 60 + 30, 10 * 60), (11 * 60 + 30, 12 * 60)]\n    helen_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (11 * 60, 12 * 60),\n        (13 * 60, 14 * 60 + 30),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    beverly_busy = [\n        (9 * 60, 12 * 60 + 30),\n        (13 * 60, 15 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Jose cannot meet after 15:30\n    jose_constraint = 15 * 60 + 30\n    \n    # Combine all busy times\n    all_busy = []\n    all_busy.extend([(start, end, 'Jose') for start, end in jose_busy])\n    all_busy.extend([(start, end, 'Helen') for start, end in helen_busy])\n    all_busy.extend([(start, end, 'Beverly') for start, end in beverly_busy])\n    \n    # Sort busy times by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = work_start\n    \n    for busy_start, busy_end, _ in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    # Check the end of the day\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Filter free slots that are at least 30 minutes and respect Jose's constraint\n    meeting_duration = 30\n    valid_slots = []\n    \n    for start, end in free_slots:\n        if end > jose_constraint:\n            end = min(end, jose_constraint)\n            if end <= start:\n                continue\n        if end - start >= meeting_duration:\n            valid_slots.append((start, end))\n    \n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n    else:\n        return None\n    \n    # Convert to HH:MM format\n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n    \n    start_time = minutes_to_time(meeting_start)\n    end_time = minutes_to_time(meeting_end)\n    \n    return f\"{start_time}:{end_time}\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_220"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define each participant's busy times in minutes since midnight\n    busy_times = {\n        'Megan': [(12 * 60, 12 * 60 + 30), (15 * 60 + 30, 16 * 60)],\n        'Jacob': [],\n        'Kathryn': [],\n        'Keith': [(9 * 60, 11 * 60), (11 * 60 + 30, 12 * 60 + 30), (13 * 60 + 30, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Matthew': [(9 * 60 + 30, 11 * 60 + 30), (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60 + 30)],\n    }\n\n    # Combine all busy times and sort them\n    all_busy = []\n    for person in busy_times:\n        for start, end in busy_times[person]:\n            all_busy.append((start, end))\n    all_busy.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n\n    # Find available slots by checking gaps between busy times\n    available_slots = []\n    previous_end = work_start\n    for start, end in merged_busy:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n\n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No available time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_221"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 (9:00)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = (minutes + 540) // 60\n        mm = (minutes + 540) % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Initialize the availability list (all times are available)\n    start_min = time_to_minutes(work_hours[0])\n    end_min = time_to_minutes(work_hours[1])\n    total_slots = end_min - start_min\n    availability = [True] * total_slots\n    \n    # Mark busy times for each participant\n    for person in participants_busy:\n        for busy_range in person:\n            start = time_to_minutes(busy_range[0])\n            end = time_to_minutes(busy_range[1])\n            for i in range(start, end):\n                if i < total_slots:\n                    availability[i] = False\n    \n    # Find the first available slot of the given duration\n    required_slots = duration // 30  # Assuming 30-minute slots for simplicity\n    current_slot = 0\n    while current_slot <= total_slots - required_slots:\n        if all(availability[current_slot + i] for i in range(required_slots)):\n            start_time = minutes_to_time(current_slot)\n            end_time = minutes_to_time(current_slot + required_slots * 30)\n            return f\"{start_time}:{end_time}\"\n        current_slot += 1\n    \n    return \"No available time slot found\"\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 30  # minutes\n\n# Define participants' busy times\nparticipants_busy = [\n    [(\"9:30\", \"10:00\"), (\"10:30\", \"11:00\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:00\")],  # Betty\n    [(\"11:30\", \"12:30\"), (\"14:00\", \"15:00\")],  # Evelyn\n    [(\"9:30\", \"10:00\"), (\"10:30\", \"11:00\"), (\"11:30\", \"12:00\"), (\"13:00\", \"13:30\"), (\"15:00\", \"16:00\")],  # John\n    [(\"10:30\", \"13:00\"), (\"13:30\", \"17:00\")],  # Andrea\n    [(\"10:00\", \"10:30\"), (\"11:00\", \"12:00\"), (\"13:00\", \"13:30\"), (\"14:00\", \"15:00\"), (\"15:30\", \"16:30\")]   # Eric\n]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_222"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:11:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Find the earliest free interval that can accommodate the meeting\n    duration_minutes = duration * 60\n    for start, end in free_intervals:\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Participants' schedules\nparticipants_schedules = [\n    [\"9:00 to 9:30\", \"12:00 to 12:30\", \"13:30 to 14:30\"],  # Frances\n    [\"15:00 to 15:30\", \"16:00 to 16:30\"],                  # Sarah\n    [\"10:00 to 10:30\", \"13:30 to 14:00\", \"14:30 to 15:30\"], # Christopher\n    [\"9:30 to 11:00\", \"12:00 to 12:30\", \"13:00 to 13:30\", \"15:00 to 16:30\"], # Bobby\n    [\"9:00 to 10:30\", \"12:00 to 12:30\", \"13:00 to 13:30\", \"14:00 to 14:30\", \"15:30 to 16:00\", \"16:30 to 17:00\"]  # Janice\n]\n\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 0.5  # half an hour\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_223"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours=('09:00', '17:00')):\n    # Convert work hours to minutes since midnight\n    start_work, end_work = work_hours\n    work_start = int(start_work.split(':')[0]) * 60 + int(start_work.split(':')[1])\n    work_end = int(end_work.split(':')[0]) * 60 + int(end_work.split(':')[1])\n    \n    # Initialize the free slots for all participants\n    free_slots = []\n    \n    for name, busy_slots in participants_schedules.items():\n        # Convert busy slots to minutes\n        busy_intervals = []\n        for slot in busy_slots:\n            start, end = slot.split(' to ')\n            start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n            end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n            busy_intervals.append((start_min, end_min))\n        \n        # Sort busy intervals\n        busy_intervals.sort()\n        \n        # Find free intervals for this participant\n        free_intervals = []\n        prev_end = work_start\n        \n        for start, end in busy_intervals:\n            if start > prev_end:\n                free_intervals.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_intervals.append((prev_end, work_end))\n        \n        free_slots.append(free_intervals)\n    \n    # Find overlapping free intervals across all participants\n    common_free_intervals = free_slots[0]\n    \n    for intervals in free_slots[1:]:\n        new_common = []\n        i = j = 0\n        while i < len(common_free_intervals) and j < len(intervals):\n            start1, end1 = common_free_intervals[i]\n            start2, end2 = intervals[j]\n            \n            # Find overlap\n            overlap_start = max(start1, start2)\n            overlap_end = min(end1, end2)\n            \n            if overlap_start < overlap_end:\n                new_common.append((overlap_start, overlap_end))\n            \n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free_intervals = new_common\n    \n    # Find the first interval that can fit the meeting\n    for start, end in common_free_intervals:\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return None\n\n# Define participants' schedules\nparticipants_schedules = {\n    'Marilyn': ['16:00 to 17:00'],\n    'Wayne': ['09:30 to 10:00', '10:30 to 11:30', '12:00 to 12:30', '13:00 to 14:00'],\n    'Julia': ['12:30 to 13:00', '14:00 to 14:30'],\n    'Deborah': ['09:00 to 11:00', '11:30 to 14:30', '15:00 to 15:30', '16:30 to 17:00'],\n    'Virginia': ['09:00 to 09:30', '10:00 to 11:30', '12:30 to 13:30', '15:00 to 17:00']\n}\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_224"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30       # 30 minutes\n    \n    # Convert each person's busy slots to minutes since midnight\n    jean_busy = [\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    doris_busy = [\n        (10 * 60, 11 * 60 + 30),\n        (12 * 60, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    \n    joan_busy = [\n        (9 * 60, 11 * 60 + 30),\n        (12 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 16 * 60 + 30)\n    ]\n    \n    # Doris cannot meet before 15:00\n    doris_constraint = 15 * 60\n    \n    # Combine all busy times and constraints\n    all_busy = jean_busy + doris_busy + joan_busy\n    \n    # Generate free slots by finding gaps in busy times\n    all_busy_sorted = sorted(all_busy, key=lambda x: x[0])\n    free_slots = []\n    previous_end = work_hours_start\n    \n    for start, end in all_busy_sorted:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_hours_end:\n        free_slots.append((previous_end, work_hours_end))\n    \n    # Check free slots for meeting duration and Doris's constraint\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        # Adjust slot start to respect Doris's constraint\n        effective_start = max(slot_start, doris_constraint)\n        if effective_start + meeting_duration <= slot_end:\n            # Convert back to HH:MM format\n            start_hh = effective_start // 60\n            start_mm = effective_start % 60\n            end_time = effective_start + meeting_duration\n            end_hh = end_time // 60\n            end_mm = end_time % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_225"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy slots in minutes\n    busy_slots = {\n        'Maria': [(9*60 + 30, 10*60), (11*60, 12*60), (15*60 + 30, 16*60)],\n        'Gary': [(10*60, 10*60 + 30), (13*60, 13*60 + 30), (14*60 + 30, 15*60), (16*60 + 30, 17*60)],\n        'Betty': [],\n        'Charlotte': [(9*60 + 30, 12*60), (13*60, 13*60 + 30), (14*60, 14*60 + 30), (15*60 + 30, 16*60)],\n        'Jerry': [(9*60 + 30, 10*60), (10*60 + 30, 12*60 + 30), (13*60, 16*60 + 30)],\n    }\n    \n    # Maria cannot meet before 9:30\n    maria_constraint = 9 * 60 + 30\n    \n    # Meeting duration in minutes\n    meeting_duration = 30\n    \n    # Combine all busy slots from all participants\n    all_busy = []\n    for person in busy_slots:\n        for slot in busy_slots[person]:\n            all_busy.append(slot)\n    \n    # Add Maria's constraint as a busy slot if needed\n    if maria_constraint > work_start:\n        all_busy.append((work_start, maria_constraint))\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_226"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Convert all schedules to minutes since midnight\n    # Each person's busy times are represented as a list of (start, end) tuples in minutes\n    natalie_busy = []\n    david_busy = [(11 * 60 + 30, 12 * 60), (14 * 60 + 30, 15 * 60)]\n    douglas_busy = [(9 * 60 + 30, 10 * 60), (11 * 60 + 30, 12 * 60), \n                    (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60)]\n    ralph_busy = [(9 * 60, 9 * 60 + 30), (10 * 60, 11 * 60), \n                  (11 * 60 + 30, 12 * 60 + 30), (13 * 60 + 30, 15 * 60), \n                  (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)]\n    jordan_busy = [(9 * 60, 10 * 60), (12 * 60, 12 * 60 + 30), \n                   (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60), \n                   (15 * 60 + 30, 17 * 60)]\n    \n    # Combine all busy times and sort them\n    all_busy = david_busy + douglas_busy + ralph_busy + jordan_busy\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = work_start\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    # Check the time after the last busy slot until work_end\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Filter free slots that are at least 30 minutes and meet David's preference (after 14:00)\n    meeting_duration = 30\n    valid_slots = []\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration and slot_start >= 14 * 60:\n            valid_slots.append((slot_start, slot_end))\n    \n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No valid slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_227"
        },
        {
            "final_program_time": "{15:00:15:01}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 9:00 (0 minutes)\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    # Parse work hours\n    work_start, work_end = map(time_to_minutes, work_hours.split(' to '))\n    \n    # Initialize a list to mark busy intervals\n    timeline = [False] * (work_end - work_start)\n    \n    # Mark busy times for each participant\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            for i in range(start, end):\n                if 0 <= i < len(timeline):\n                    timeline[i] = True\n    \n    # Find the first available slot of duration\n    required_slots = duration // 30  # assuming duration is in minutes, e.g., 30 for half hour\n    current_slots = 0\n    \n    for i in range(len(timeline)):\n        if not timeline[i]:\n            current_slots += 1\n            if current_slots >= required_slots:\n                start_time = i - required_slots + 1\n                end_time = start_time + required_slots\n                start_str = minutes_to_time(start_time)\n                end_str = minutes_to_time(end_time)\n                return f\"{start_str}:{end_str}\"\n        else:\n            current_slots = 0\n    \n    return \"No available slot found\"\n\n# Participants' schedules\nparticipants_schedules = [\n    [\"11:00 to 11:30\", \"16:00 to 16:30\"],  # Mason\n    [\"9:30 to 10:00\", \"11:30 to 12:00\"],  # Anthony\n    [\"9:30 to 10:00\", \"11:00 to 11:30\", \"13:00 to 14:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"],  # Teresa\n    [\"9:00 to 10:30\", \"11:00 to 12:30\", \"13:00 to 15:00\", \"16:00 to 17:00\"],  # Katherine\n    [\"9:30 to 12:00\", \"12:30 to 13:00\", \"14:00 to 14:30\", \"16:00 to 16:30\"],  # Brian\n]\n\n# Meeting duration in minutes\nduration = 30\n\n# Work hours\nwork_hours = \"9:00 to 17:00\"\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, duration, work_hours))\n```",
            "count": "calendar_scheduling_example_228"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Define participants' busy times in minutes since midnight\n    busy_times = {\n        'Brittany': [],\n        'Wayne': [],\n        'Betty': [(10.5 * 60, 11 * 60), (15 * 60, 15.5 * 60)],\n        'Diane': [(9 * 60, 9.5 * 60), (10 * 60, 11 * 60), (11.5 * 60, 13 * 60), (13.5 * 60, 16.5 * 60)],\n        'Larry': [(9 * 60, 11 * 60), (11.5 * 60, 13 * 60), (13.5 * 60, 17 * 60)],\n    }\n\n    # Betty's preference: avoid meetings after 11:30\n    betty_preference_end = 11.5 * 60\n\n    # Generate all possible 30-minute slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + 30 <= work_end:\n        slot_start = current_time\n        slot_end = slot_start + 30\n        possible_slots.append((slot_start, slot_end))\n        current_time += 1  # Check every minute\n\n    # Check each slot against all constraints\n    for slot_start, slot_end in possible_slots:\n        # Check Betty's preference\n        if slot_start >= betty_preference_end:\n            continue\n\n        # Check if slot is free for all participants\n        all_free = True\n        for person, busy in busy_times.items():\n            for busy_start, busy_end in busy:\n                if not (slot_end <= busy_start or slot_start >= busy_end):\n                    all_free = False\n                    break\n            if not all_free:\n                break\n\n        if all_free:\n            # Format the time as HH:MM:HH:MM\n            start_hh = int(slot_start // 60)\n            start_mm = int(slot_start % 60)\n            end_hh = int(slot_end // 60)\n            end_mm = int(slot_end % 60)\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_229"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:30:15:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_hour, end_hour = work_hours\n    # Convert work hours to minutes for easier calculation\n    start_time = start_hour * 60\n    end_time = end_hour * 60\n    \n    # Initialize a list to keep track of busy intervals in minutes\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start = busy[0] * 60\n            end = busy[1] * 60\n            busy_intervals.append((start, end))\n    \n    # Sort the busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append(interval)\n    \n    # Check the available slots before the first busy interval, between intervals, and after the last busy interval\n    available_slots = []\n    \n    # Before the first busy interval\n    if merged:\n        first_start, first_end = merged[0]\n        if first_start > start_time:\n            available_slots.append((start_time, first_start))\n    else:\n        # No busy intervals, the whole day is available\n        available_slots.append((start_time, end_time))\n    \n    # Between busy intervals\n    for i in range(1, len(merged)):\n        prev_end = merged[i-1][1]\n        current_start = merged[i][0]\n        if current_start > prev_end:\n            available_slots.append((prev_end, current_start))\n    \n    # After the last busy interval\n    if merged:\n        last_start, last_end = merged[-1]\n        if last_end < end_time:\n            available_slots.append((last_end, end_time))\n    \n    # Check each available slot for a duration that fits\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration * 60:\n            # Found a suitable slot, return the first possible one\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration * 60\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules in hours\nparticipants_schedules = [\n    [],  # Jessica is free all day\n    [(10.0, 10.5), (16.0, 16.5)],  # Joshua\n    [(12.0, 12.5), (16.0, 16.5)],  # Robert\n    [(10.0, 11.0), (11.5, 12.0), (13.0, 13.5), (14.0, 14.5), (15.0, 16.5)],  # Samuel\n    [(9.0, 12.0), (12.5, 14.5), (15.0, 17.0)],  # Jennifer\n]\n\n# Define work hours and meeting duration\nwork_hours = (9.0, 17.0)\nduration = 0.5  # half an hour\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_230"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_start, work_end):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start_min = time_to_minutes(busy[0])\n            end_min = time_to_minutes(busy[1])\n            all_busy.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots between work hours and busy intervals\n    available = []\n    prev_end = work_start_min\n    \n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        available.append((prev_end, work_end_min))\n    \n    # Find the first available slot that can fit the meeting\n    for slot in available:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [(\"10:00\", \"10:30\"), (\"12:30\", \"13:00\"), (\"16:00\", \"17:00\")],  # Betty\n    [],  # Olivia\n    [(\"11:30\", \"12:00\"), (\"14:00\", \"14:30\"), (\"15:00\", \"15:30\"), (\"16:00\", \"16:30\")],  # Brandon\n    [(\"09:30\", \"10:00\"), (\"11:00\", \"12:30\"), (\"13:00\", \"15:00\")],  # Lori\n    [(\"09:00\", \"10:30\"), (\"11:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"13:30\"), (\"15:00\", \"17:00\")]  # Rachel\n]\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, 30, \"09:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_231"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:00:12:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert time strings to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's schedule to find common free slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_slots.append((start, end))\n        \n        # Sort the busy slots by start time\n        busy_slots.sort()\n        \n        # Calculate free slots for the current participant\n        current_free = []\n        prev_end = work_start\n        for start, end in busy_slots:\n            if start > prev_end:\n                current_free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            current_free.append((prev_end, work_end))\n        \n        # Intersect current free slots with the common free slots\n        new_free_slots = []\n        i = j = 0\n        while i < len(free_slots) and j < len(current_free):\n            fs_start, fs_end = free_slots[i]\n            cf_start, cf_end = current_free[j]\n            \n            # Find the overlap\n            overlap_start = max(fs_start, cf_start)\n            overlap_end = min(fs_end, cf_end)\n            \n            if overlap_start < overlap_end:\n                new_free_slots.append((overlap_start, overlap_end))\n            \n            # Move the pointer which ends first\n            if fs_end < cf_end:\n                i += 1\n            else:\n                j += 1\n        \n        free_slots = new_free_slots\n    \n    # Find the first free slot that can accommodate the meeting duration\n    for start, end in free_slots:\n        if end - start >= duration:\n            meeting_end = start + duration\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [],  # Joyce is free the entire day\n    [\"09:00:09:30\", \"14:30:15:00\"],  # Judith\n    [\"10:00:10:30\", \"14:00:14:30\", \"15:00:16:00\"],  # Bradley\n    [\"09:00:12:00\", \"12:30:14:30\", \"15:00:17:00\"],  # Terry\n    [\"09:00:09:30\", \"10:00:10:30\", \"11:00:12:00\", \"12:30:13:00\", \"14:00:15:00\", \"16:00:16:30\"],  # Hannah\n]\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_232"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define meeting duration\n    meeting_duration = 30  # minutes\n    \n    # Define each person's busy times in minutes since midnight\n    # Format: (start, end)\n    samuel_busy = [\n        (12 * 60 + 30, 13 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    \n    jesse_busy = []  # No meetings\n    \n    willie_busy = []  # Wide open\n    \n    joyce_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60, 13 * 60),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    mark_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 16 * 60)\n    ]\n    \n    # Mark's preference: avoid after 13:00 (but still possible if no other slot)\n    mark_preferred_end = 13 * 60\n    \n    # Combine all busy times\n    all_busy = []\n    for person in [samuel_busy, jesse_busy, willie_busy, joyce_busy, mark_busy]:\n        all_busy.extend(person)\n    \n    # Sort busy times by start time\n    all_busy.sort()\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > prev_end:\n            available_slots.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n    \n    # Check after last busy slot\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Filter slots that are long enough and meet Mark's preference\n    valid_slots = []\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration:\n            valid_slots.append((slot_start, slot_end))\n    \n    # Prioritize slots before Mark's preferred end time (13:00)\n    preferred_slots = [slot for slot in valid_slots if slot[1] <= mark_preferred_end]\n    if preferred_slots:\n        best_slot = preferred_slots[0]\n    elif valid_slots:\n        best_slot = valid_slots[0]\n    else:\n        return None\n    \n    # Format the best slot as HH:MM:HH:MM\n    start_hh = best_slot[0] // 60\n    start_mm = best_slot[0] % 60\n    end_hh = (best_slot[0] + meeting_duration) // 60\n    end_mm = (best_slot[0] + meeting_duration) % 60\n    \n    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_233"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Convert each participant's busy slots to minutes\n    # Format: list of (start, end) in minutes\n    barbara_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60, 11 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    bruce_busy = [\n        (11 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    robert_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (11 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 16 * 60 + 30)\n    ]\n    \n    michelle_busy = [\n        (9 * 60, 10 * 60),\n        (11 * 60, 14 * 60 + 30),\n        (15 * 60, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Catherine is free all day, so no busy slots\n    \n    # Combine all busy slots\n    all_busy = barbara_busy + bruce_busy + robert_busy + michelle_busy\n    \n    # Sort busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    prev_end = work_start\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > prev_end:\n            free_slots.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Check each free slot for 30-minute availability\n    meeting_duration = 30\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Found a suitable slot\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_234"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:10:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_start, work_end):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start_min, work_end_min)]\n    \n    # Process each participant's schedule to find common free slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for slot in schedule:\n            start, end = map(time_to_minutes, slot.split(':'))\n            busy_slots.append((start, end))\n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Merge overlapping or adjacent busy slots\n        merged_busy = []\n        for start, end in busy_slots:\n            if not merged_busy:\n                merged_busy.append((start, end))\n            else:\n                last_start, last_end = merged_busy[-1]\n                if start <= last_end:\n                    merged_busy[-1] = (last_start, max(end, last_end))\n                else:\n                    merged_busy.append((start, end))\n        \n        # Calculate free slots for this participant\n        participant_free = []\n        prev_end = work_start_min\n        for start, end in merged_busy:\n            if start > prev_end:\n                participant_free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end_min:\n            participant_free.append((prev_end, work_end_min))\n        \n        # Intersect with common free slots\n        new_free_slots = []\n        i = j = 0\n        while i < len(free_slots) and j < len(participant_free):\n            fs_start, fs_end = free_slots[i]\n            pf_start, pf_end = participant_free[j]\n            \n            # Find overlap\n            overlap_start = max(fs_start, pf_start)\n            overlap_end = min(fs_end, pf_end)\n            if overlap_start < overlap_end:\n                new_free_slots.append((overlap_start, overlap_end))\n            \n            # Move the pointer which ends first\n            if fs_end < pf_end:\n                i += 1\n            else:\n                j += 1\n        \n        free_slots = new_free_slots\n    \n    # Find the first slot that can fit the meeting\n    for start, end in free_slots:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"12:30:13:00\", \"14:00:14:30\", \"15:00:15:30\", \"16:00:16:30\"],  # Amber\n    [\"11:00:11:30\", \"15:30:16:00\"],  # Alice\n    [],  # Brian\n    [\"11:00:11:30\", \"12:30:13:30\", \"14:30:17:00\"],  # Ryan\n    [\"10:30:11:00\", \"11:30:12:00\", \"12:30:14:30\", \"15:00:17:00\"],  # Jonathan\n]\n\n# Find a 1-hour meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, 1, \"9:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_235"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:00:10:30}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours\n    start_min = time_to_minutes(start_work)\n    end_min = time_to_minutes(end_work)\n    \n    # Initialize the list of busy intervals\n    busy_intervals = []\n    \n    # Process each participant's schedule\n    for schedule in participans_schedules:\n        for busy in schedule:\n            start, end = busy\n            busy_start = time_to_minutes(start)\n            busy_end = time_to_minutes(end)\n            busy_intervals.append((busy_start, busy_end))\n    \n    # Sort the busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append([start, end])\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1][1] = max(last_end, end)\n            else:\n                merged.append([start, end])\n    \n    # Find the first available slot\n    prev_end = start_min\n    for start, end in merged:\n        if start - prev_end >= duration:\n            return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + duration)}\"\n        prev_end = max(prev_end, end)\n    \n    # Check after the last busy interval\n    if end_min - prev_end >= duration:\n        return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + duration)}\"\n    \n    return \"No available slot found\"\n\n# Define the participants' schedules\ngregory_schedule = []\njoyce_schedule = []\nchristopher_schedule = [(\"09:00\", \"09:30\"), (\"15:00\", \"15:30\")]\ndorothy_schedule = [(\"09:30\", \"10:00\"), (\"11:00\", \"14:00\"), (\"14:30\", \"15:30\"), (\"16:30\", \"17:00\")]\ncynthia_schedule = [(\"09:30\", \"10:00\"), (\"10:30\", \"11:00\"), (\"13:00\", \"15:00\"), (\"15:30\", \"16:30\")]\n\nparticipants_schedules = [\n    gregory_schedule,\n    joyce_schedule,\n    christopher_schedule,\n    dorothy_schedule,\n    cynthia_schedule\n]\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_hours = (\"09:00\", \"17:00\")\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_236"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 (9:00)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Initialize the free time slots for all participants\n    free_slots = []\n    for person in participants_busy:\n        busy_slots = participants_busy[person]\n        person_free = []\n        prev_end = work_start\n        \n        for busy in busy_slots:\n            busy_start, busy_end = busy.split(' to ')\n            busy_start_min = time_to_minutes(busy_start)\n            busy_end_min = time_to_minutes(busy_end)\n            \n            if prev_end < busy_start_min:\n                person_free.append((prev_end, busy_start_min))\n            prev_end = max(prev_end, busy_end_min)\n        \n        if prev_end < work_end:\n            person_free.append((prev_end, work_end))\n        \n        free_slots.append(person_free)\n    \n    # Find intersection of all free slots\n    common_free = free_slots[0]\n    for person_slots in free_slots[1:]:\n        new_common = []\n        i = j = 0\n        while i < len(common_free) and j < len(person_slots):\n            start1, end1 = common_free[i]\n            start2, end2 = person_slots[j]\n            \n            start_max = max(start1, start2)\n            end_min = min(end1, end2)\n            \n            if start_max < end_min:\n                new_common.append((start_max, end_min))\n            \n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free = new_common\n    \n    # Find the first slot that can fit the duration\n    for slot in common_free:\n        start, end = slot\n        if end - start >= duration:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' busy times\nparticipants_busy = {\n    \"Carol\": [\"9:30 to 10:00\", \"10:30 to 11:00\", \"12:30 to 13:30\", \"15:30 to 16:00\", \"16:30 to 17:00\"],\n    \"Cynthia\": [\"9:00 to 10:00\", \"14:00 to 14:30\", \"16:30 to 17:00\"],\n    \"Judy\": [\"9:00 to 10:00\", \"11:00 to 12:00\", \"12:30 to 13:00\", \"14:00 to 14:30\"],\n    \"Alan\": [\"10:00 to 11:00\", \"13:00 to 15:30\", \"16:30 to 17:00\"],\n    \"Linda\": [\"9:30 to 12:30\", \"13:00 to 16:00\"]\n}\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nduration_minutes = 30  # Half an hour\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_237"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:9:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = map(time_to_minutes, work_hours.split(' to '))\n    duration_min = duration * 60\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        person_busy = []\n        for meeting in schedule:\n            start, end = map(time_to_minutes, meeting.split(' to '))\n            person_busy.append((start, end))\n        busy_intervals.append(person_busy)\n    \n    # Find all possible free intervals for each participant\n    free_intervals_per_person = []\n    \n    for person_busy in busy_intervals:\n        person_free = []\n        prev_end = work_start\n        \n        for start, end in sorted(person_busy, key=lambda x: x[0]):\n            if start > prev_end:\n                person_free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            person_free.append((prev_end, work_end))\n        \n        free_intervals_per_person.append(person_free)\n    \n    # Find overlapping free intervals across all participants\n    common_free = free_intervals_per_person[0]\n    \n    for person_free in free_intervals_per_person[1:]:\n        new_common_free = []\n        i = j = 0\n        \n        while i < len(common_free) and j < len(person_free):\n            start1, end1 = common_free[i]\n            start2, end2 = person_free[j]\n            \n            overlap_start = max(start1, start2)\n            overlap_end = min(end1, end2)\n            \n            if overlap_start < overlap_end:\n                new_common_free.append((overlap_start, overlap_end))\n            \n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        \n        common_free = new_common_free\n    \n    # Find the first common free interval that can fit the meeting\n    for start, end in common_free:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"10:00 to 10:30\", \"13:00 to 14:00\", \"14:30 to 15:00\", \"16:00 to 17:00\"],  # Alexander\n    [],                                                                         # Dylan\n    [],                                                                         # Elizabeth\n    [\"9:30 to 11:00\", \"11:30 to 17:00\"],                                       # Edward\n    [\"10:00 to 10:30\", \"11:00 to 12:00\", \"12:30 to 13:30\", \"14:00 to 15:30\", \"16:00 to 17:00\"]  # Douglas\n]\n\n# Define meeting duration (0.5 hours = 30 minutes) and work hours\nmeeting_duration = 0.5\nwork_hours = \"9:00 to 17:00\"\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, meeting_duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_238"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:11:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration_minutes):\n    # Convert work hours and busy times to minutes since start of day\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    duration = duration_minutes\n    \n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy_times in participants_busy_times.values():\n        for start, end in busy_times:\n            all_busy.append((start * 60, end * 60))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Check the available slots between work hours and merged busy intervals\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return None\n\n# Define participants' busy times in their local time (HH.HH format)\nparticipants_busy_times = {\n    \"Jennifer\": [],\n    \"Gabriel\": [(13.0, 13.5), (14.0, 14.5)],\n    \"Andrew\": [(12.0, 12.5), (16.5, 17.0)],\n    \"Carolyn\": [(9.0, 11.0), (12.0, 13.0), (13.5, 14.5), (15.0, 17.0)],\n    \"Alexis\": [(9.5, 11.0), (11.5, 17.0)],\n}\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (9.0, 17.0)\nmeeting_duration = 30  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_239"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours=('09:00', '17:00')):\n    # Convert all time strings to minutes since 00:00 for easier comparison\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start, work_end = map(time_to_minutes, work_hours)\n    \n    # Generate all busy intervals for each participant\n    busy_intervals = []\n    for schedule in participants_schedules.values():\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by examining the gaps between busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Merge overlapping or adjacent free intervals (not necessary here but good practice)\n    merged = []\n    for start, end in free_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1] = (last_start, end)\n            else:\n                merged.append((start, end))\n    \n    # Find the earliest free interval that can accommodate the meeting\n    duration = duration_minutes\n    for start, end in merged:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    return None\n\n# Define participants' schedules\nparticipants_schedules = {\n    'Edward': ['9:00 to 10:30', '12:30 to 13:00', '13:30 to 14:00', '15:00 to 15:30'],\n    'Daniel': ['11:00 to 11:30', '15:00 to 15:30'],\n    'Jonathan': ['9:00 to 10:30', '14:30 to 15:00', '15:30 to 16:00', '16:30 to 17:00'],\n    'Samuel': ['9:30 to 11:30', '12:00 to 12:30', '14:00 to 16:30'],\n    'Paul': ['10:00 to 11:00', '12:30 to 13:00', '13:30 to 14:00', '14:30 to 16:00', '16:30 to 17:00'],\n}\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_240"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy times in minutes\n    busy_times = {\n        'Terry': [(13 * 60 + 30, 14 * 60), (16 * 60 + 30, 17 * 60)],\n        'Janet': [(9 * 60 + 30, 10 * 60), (12 * 60 + 30, 13 * 60), \n                  (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60 + 30), \n                  (16 * 60 + 30, 17 * 60)],\n        'Lauren': [],\n        'Sharon': [(9 * 60 + 30, 10 * 60 + 30), (11 * 60 + 30, 12 * 60), \n                    (12 * 60 + 30, 17 * 60)],\n        'Adam': [(9 * 60 + 30, 10 * 60 + 30), (11 * 60, 17 * 60)]\n    }\n    \n    # Adam's preference: avoid before 10:30\n    preference_start = 10 * 60 + 30\n    \n    # Generate all busy slots combined\n    all_busy = []\n    for person in busy_times:\n        all_busy.extend(busy_times[person])\n    \n    # Sort busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the end of the day\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Filter free slots that are at least 30 minutes and after Adam's preference\n    meeting_duration = 30\n    valid_slots = []\n    \n    for start, end in free_slots:\n        if end - start >= meeting_duration and start >= preference_start:\n            valid_slots.append((start, end))\n    \n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No valid slot found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_241"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:00:16:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_hour, end_hour = work_hours\n    # Convert work hours to minutes for easier calculation\n    start_time = start_hour * 60\n    end_time = end_hour * 60\n    \n    # Initialize a list to keep track of busy times for all participants\n    busy_times = []\n    \n    # Collect all busy intervals from each participant\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start_busy = busy[0] * 60\n            end_busy = busy[1] * 60\n            busy_times.append((start_busy, end_busy))\n    \n    # Sort all busy intervals by start time\n    busy_times.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for busy in busy_times:\n        if not merged:\n            merged.append(busy)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = busy\n            if current_start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append(busy)\n    \n    # Find available slots by checking gaps between merged busy intervals\n    available_slots = []\n    previous_end = start_time\n    \n    for busy_start, busy_end in merged:\n        if busy_start > previous_end:\n            available_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    # Check the slot after the last busy interval\n    if previous_end < end_time:\n        available_slots.append((previous_end, end_time))\n    \n    # Find the first available slot that can fit the meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration * 60:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration * 60\n            # Convert back to hours and minutes\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules in hours\nparticipants_schedules = [\n    [(9, 11), (15, 16)],  # Anthony\n    [(12.5, 14), (14.5, 15.5), (16.5, 17)],  # Zachary\n    [(9, 10)],  # Russell\n    [(9, 14.5), (15, 16), (16.5, 17)],  # Gary\n    [(9, 11), (11.5, 12.5), (13, 15.5), (16.5, 17)]  # Helen\n]\n\n# Define work hours and meeting duration\nwork_hours = (9, 17)\nduration = 0.5  # half an hour\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_242"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each participant's busy slots to minutes since 9:00\n    # Douglas has no meetings\n    douglas_busy = []\n    \n    # Debra: 15:30 to 16:30 \u2192 390 to 450\n    debra_busy = [(15 * 60 + 30, 16 * 60 + 30)]\n    \n    # Frank: 10:00-11:00 (60-120), 12:00-12:30 (180-210), 13:30-14:00 (270-300), 15:00-16:00 (360-420)\n    frank_busy = [\n        (10 * 60, 11 * 60),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60, 16 * 60)\n    ]\n    \n    # Nicholas: 9:00-10:00 (0-60), 11:00-12:30 (120-150), 13:30-15:00 (270-360), 15:30-16:00 (390-420), 16:30-17:00 (450-480)\n    nicholas_busy = [\n        (9 * 60, 10 * 60),\n        (11 * 60, 12 * 60 + 30),\n        (13 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Mark: 10:00-11:30 (60-150), 12:00-12:30 (180-210), 13:30-14:30 (270-330), 15:00-17:00 (360-480)\n    mark_busy = [\n        (10 * 60, 11 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60 + 30, 14 * 60 + 30),\n        (15 * 60, 17 * 60)\n    ]\n    \n    # Combine all busy slots\n    all_busy = douglas_busy + debra_busy + frank_busy + nicholas_busy + mark_busy\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check if there's a free slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_243"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each participant's busy slots to minutes since 9:00\n    # Walter has no meetings\n    walter_busy = []\n    \n    # Cynthia's busy slots: 9:00-9:30, 10:00-10:30, 13:30-14:30, 15:00-16:00\n    cynthia_busy = [\n        (9*60, 9*60 + 30),\n        (10*60, 10*60 + 30),\n        (13*60 + 30, 14*60 + 30),\n        (15*60, 16*60)\n    ]\n    \n    # Ann's busy slots: 10:00-11:00, 13:00-13:30, 14:00-15:00, 16:00-16:30\n    ann_busy = [\n        (10*60, 11*60),\n        (13*60, 13*60 + 30),\n        (14*60, 15*60),\n        (16*60, 16*60 + 30)\n    ]\n    \n    # Catherine's busy slots: 9:00-11:30, 12:30-13:30, 14:30-17:00\n    catherine_busy = [\n        (9*60, 11*60 + 30),\n        (12*60 + 30, 13*60 + 30),\n        (14*60 + 30, 17*60)\n    ]\n    \n    # Kyle's busy slots: 9:00-9:30, 10:00-11:30, 12:00-12:30, 13:00-14:30, 15:00-16:00\n    kyle_busy = [\n        (9*60, 9*60 + 30),\n        (10*60, 11*60 + 30),\n        (12*60, 12*60 + 30),\n        (13*60, 14*60 + 30),\n        (15*60, 16*60)\n    ]\n    \n    # Combine all busy slots for all participants\n    all_busy = walter_busy + cynthia_busy + ann_busy + catherine_busy + kyle_busy\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_244"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:00:16:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time slots to minutes since start of the day for easier comparison\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n\n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_intervals.append((start, end))\n\n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find the first available slot\n    prev_end = work_start\n    for start, end in merged:\n        if start - prev_end >= duration:\n            # Found a slot\n            meeting_start = prev_end\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n        prev_end = max(prev_end, end)\n\n    # Check after the last busy interval\n    if work_end - prev_end >= duration:\n        meeting_start = prev_end\n        meeting_end = meeting_start + duration\n        def minutes_to_time(minutes):\n            hh = minutes // 60\n            mm = minutes % 60\n            return f\"{hh:02d}:{mm:02d}\"\n        return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"14:30:15:30\"],  # Amanda\n    [\"11:00:11:30\", \"14:00:14:30\"],  # Margaret\n    [\"09:00:09:30\", \"10:00:11:00\", \"12:00:13:00\", \"14:00:14:30\"],  # Walter\n    [\"09:00:11:00\", \"11:30:13:00\", \"14:00:16:00\", \"16:30:17:00\"],  # Larry\n    [\"09:00:11:00\", \"13:00:14:00\", \"15:00:15:30\", \"16:30:17:00\"],  # John\n]\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, \"09:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_245"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert work hours to minutes\n    start_time = work_hours_start[0] * 60 + work_hours_start[1]\n    end_time = work_hours_end[0] * 60 + work_hours_end[1]\n    \n    # Initialize a list to keep track of busy intervals in minutes\n    busy_intervals = []\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start_busy = busy[0] * 60 + busy[1]\n            end_busy = busy[2] * 60 + busy[3]\n            busy_intervals.append((start_busy, end_busy))\n    \n    # Sort busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append(interval)\n    \n    # Find available slots\n    available_slots = []\n    previous_end = start_time\n    \n    for interval in merged:\n        current_start, current_end = interval\n        if current_start > previous_end:\n            available_slots.append((previous_end, current_start))\n        previous_end = max(previous_end, current_end)\n    \n    if previous_end < end_time:\n        available_slots.append((previous_end, end_time))\n    \n    # Check each available slot for sufficient duration\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_minutes:\n            # Found a suitable slot\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return None\n\n# Define work hours (9:00 to 17:00)\nwork_hours_start = (9, 0)\nwork_hours_end = (17, 0)\n\n# Define participants' schedules in HH:MM format converted to tuples\nparticipants_schedules = [\n    [(13, 30, 14, 0), (14, 30, 15, 0)],  # Jacob\n    [(9, 30, 10, 0), (11, 30, 12, 0), (13, 0, 13, 30), (16, 0, 16, 30)],  # Diana\n    [(9, 30, 10, 30), (11, 0, 12, 30), (15, 30, 16, 0)],  # Adam\n    [(9, 30, 10, 0), (10, 30, 12, 0), (13, 0, 15, 30), (16, 0, 16, 30)],  # Angela\n    [(9, 0, 9, 30), (10, 30, 11, 30), (13, 0, 15, 0), (16, 30, 17, 0)],  # Dennis\n]\n\n# Meeting duration is 30 minutes\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_246"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:00:14:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 9:00 (0 minutes)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours\n    start_min = time_to_minutes(start_work)\n    end_min = time_to_minutes(end_work)\n    \n    # Initialize a list to track busy intervals for all participants\n    all_busy = []\n    for busy_slots in participants_busy.values():\n        for slot in busy_slots:\n            start, end = slot\n            all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append([start, end])\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1][1] = max(end, last_end)\n            else:\n                merged.append([start, end])\n    \n    # Find available slots between 9:00 and 17:00 (0 to 480 minutes)\n    available = []\n    prev_end = start_min\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < end_min:\n        available.append((prev_end, end_min))\n    \n    # Check for the first available slot that can fit the meeting duration\n    duration_min = duration * 60\n    for start, end in available:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' busy times\nparticipants_busy = {\n    'Charles': [('11:00', '12:30'), ('16:30', '17:00')],\n    'Bryan': [('13:30', '14:00'), ('15:30', '17:00')],\n    'Ruth': [],\n    'Keith': [('09:00', '09:30'), ('10:00', '10:30'), ('11:30', '12:00'), ('13:00', '14:00'), ('14:30', '17:00')],\n    'William': [('09:00', '11:30'), ('12:30', '13:00'), ('15:30', '16:30')]\n}\n\n# Define work hours and meeting duration\nwork_hours = ('09:00', '17:00')\nduration = 0.5  # half an hour\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_247"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_hour, end_hour = work_hours\n    # Convert work hours to minutes for easier calculation\n    start_time = start_hour * 60\n    end_time = end_hour * 60\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start = busy[0] * 60\n            end = busy[1] * 60\n            all_busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for busy in all_busy_intervals:\n        if not merged:\n            merged.append(busy)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = busy\n            if current_start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append(busy)\n    \n    # Find the earliest available slot\n    previous_end = start_time\n    for busy_start, busy_end in merged:\n        if busy_start > previous_end:\n            # Check if the gap is enough for the meeting\n            if busy_start - previous_end >= duration:\n                # Convert back to hours and minutes\n                start_meeting = previous_end\n                end_meeting = start_meeting + duration\n                return (start_meeting // 60, start_meeting % 60, end_meeting // 60, end_meeting % 60)\n        previous_end = max(previous_end, busy_end)\n    \n    # Check the time after the last busy interval\n    if end_time - previous_end >= duration:\n        start_meeting = previous_end\n        end_meeting = start_meeting + duration\n        return (start_meeting // 60, start_meeting % 60, end_meeting // 60, end_meeting % 60)\n    \n    return None\n\n# Define work hours and meeting duration\nwork_hours = (9, 17)  # 9:00 to 17:00\nduration = 30  # minutes\n\n# Define each participant's busy intervals in hours\nbilly = [(10, 10.5), (11.5, 12), (14.5, 16.5)]\njoe = [(9.5, 10), (11.5, 12)]\nbrittany = [(13.5, 14), (15.5, 16)]\ngrace = [(9.5, 10), (10.5, 11), (11.5, 12.5), (13.5, 16.5)]\ndennis = [(9.5, 10.5), (11, 12), (12.5, 13), (13.5, 14), (14.5, 15), (15.5, 17)]\n\nparticipants_schedules = [billy, joe, brittany, grace, dennis]\n\n# Find the earliest available meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\n\n# Format the output as HH:MM:HH:MM\nif meeting_time:\n    start_h, start_m, end_h, end_m = meeting_time\n    print(f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\")\nelse:\n    print(\"No available time slot found.\")\n```",
            "count": "calendar_scheduling_example_248"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    duration = 30         # meeting duration in minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    # Julie: 13:30-15:30 \u2192 270-330\n    julie_busy = [(13 * 60 + 30, 15 * 60 + 30)]\n    # Betty: 10:30-11:00, 13:00-13:30, 14:00-14:30, 15:30-16:00\n    betty_busy = [(10 * 60 + 30, 11 * 60), (13 * 60, 13 * 60 + 30),\n                  (14 * 60, 14 * 60 + 30), (15 * 60 + 30, 16 * 60)]\n    # Kayla: free all day\n    kayla_busy = []\n    # Heather: 9:00-9:30, 10:30-11:00, 11:30-13:00, 13:30-15:00\n    heather_busy = [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 11 * 60),\n                    (11 * 60 + 30, 13 * 60), (13 * 60 + 30, 15 * 60)]\n    # Keith: 9:30-11:00, 11:30-13:30, 14:30-15:00\n    keith_busy = [(9 * 60 + 30, 11 * 60), (11 * 60 + 30, 13 * 60 + 30),\n                  (14 * 60 + 30, 15 * 60)]\n\n    # Combine all busy times\n    all_busy = julie_busy + betty_busy + kayla_busy + heather_busy + keith_busy\n\n    # Betty prefers no meetings after 15:00, so we'll treat 15:00-17:00 as busy for her\n    betty_preferred_busy = (15 * 60, 17 * 60)\n    all_busy.append(betty_preferred_busy)\n\n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    prev_end = work_start\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_249"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Find the first free interval that can accommodate the meeting\n    meeting_duration_min = duration * 60\n    for start, end in free_intervals:\n        if end - start >= meeting_duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"10:00 to 10:30\", \"11:30 to 12:00\", \"12:30 to 13:00\", \"16:00 to 16:30\"],  # Dorothy\n    [\"11:30 to 12:00\", \"12:30 to 13:00\"],  # Kenneth\n    [\"09:30 to 10:00\", \"16:30 to 17:00\"],  # Madison\n    [\"09:00 to 09:30\", \"11:00 to 12:00\", \"12:30 to 15:30\", \"16:00 to 16:30\"],  # Brandon\n    [\"10:00 to 10:30\", \"11:00 to 11:30\", \"12:00 to 12:30\", \"13:30 to 15:00\", \"15:30 to 16:30\"],  # Judith\n]\n\n# Find a meeting time\nmeeting_time = find_meeting_time(participants_schedules, \"09:00\", \"17:00\", 0.5)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_250"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define participants' busy times in minutes (start, end)\n    willie_busy = [\n        (10 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60 + 30, 15 * 60 + 30)\n    ]\n    \n    diana_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    olivia_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (11 * 60, 11 * 60 + 30)\n    ]\n    \n    kyle_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    kathleen_busy = [\n        (9 * 60, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Diana's preference: avoid before 14:30\n    diana_preference_start = 14 * 60 + 30\n    \n    # Meeting duration in minutes\n    duration = 30\n    \n    # Collect all busy intervals\n    all_busy = []\n    for busy in [willie_busy, diana_busy, olivia_busy, kyle_busy, kathleen_busy]:\n        all_busy.extend(busy)\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Filter free intervals that are after Diana's preference and long enough\n    possible_slots = []\n    for start, end in free_intervals:\n        if start >= diana_preference_start and (end - start) >= duration:\n            possible_slots.append((start, end))\n    \n    # Select the earliest possible slot\n    if possible_slots:\n        meeting_start = possible_slots[0][0]\n        meeting_end = meeting_start + duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_251"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes\n    daniel_busy = [(9 * 60 + 30, 10 * 60), (12 * 60 + 30, 13 * 60)]\n    wayne_busy = [(13 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30)]\n    gloria_busy = [(10 * 60 + 30, 11 * 60), (11 * 60 + 30, 12 * 60)]\n    stephanie_busy = [(9 * 60 + 30, 15 * 60 + 30)]\n    megan_busy = [(9 * 60, 10 * 60 + 30), (11 * 60, 14 * 60), (15 * 60, 16 * 60 + 30)]\n\n    # Combine all busy slots\n    all_busy = daniel_busy + wayne_busy + gloria_busy + stephanie_busy + megan_busy\n\n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check each free slot for availability for all participants\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Check if the slot works for everyone\n            valid = True\n            # Daniel's availability\n            for start, end in daniel_busy:\n                if not (slot_start >= end or slot_start + meeting_duration <= start):\n                    valid = False\n                    break\n            if not valid:\n                continue\n            # Wayne's availability\n            for start, end in wayne_busy:\n                if not (slot_start >= end or slot_start + meeting_duration <= start):\n                    valid = False\n                    break\n            if not valid:\n                continue\n            # Gloria's availability\n            for start, end in gloria_busy:\n                if not (slot_start >= end or slot_start + meeting_duration <= start):\n                    valid = False\n                    break\n            if not valid:\n                continue\n            # Stephanie's availability\n            for start, end in stephanie_busy:\n                if not (slot_start >= end or slot_start + meeting_duration <= start):\n                    valid = False\n                    break\n            if not valid:\n                continue\n            # Megan's availability\n            for start, end in megan_busy:\n                if not (slot_start >= end or slot_start + meeting_duration <= start):\n                    valid = False\n                    break\n            if valid:\n                # Convert minutes back to HH:MM format\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_hh = (slot_start + meeting_duration) // 60\n                end_mm = (slot_start + meeting_duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_252"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:30:12:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes, work_start, work_end):\n    # Convert time strings to minutes since 9:00 (work_start)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - work_start * 60\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_hh = (minutes + work_start * 60) // 60\n        total_mm = (minutes + work_start * 60) % 60\n        return f\"{total_hh:02d}:{total_mm:02d}\"\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(0, (work_end - work_start) * 60)]\n    \n    # Process each participant's schedule to find common free slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_slots.append((start, end))\n        \n        # Merge overlapping or adjacent busy slots\n        busy_slots.sort()\n        merged_busy = []\n        for start, end in busy_slots:\n            if not merged_busy:\n                merged_busy.append((start, end))\n            else:\n                last_start, last_end = merged_busy[-1]\n                if start <= last_end:\n                    merged_busy[-1] = (last_start, max(end, last_end))\n                else:\n                    merged_busy.append((start, end))\n        \n        # Subtract busy slots from free slots\n        new_free_slots = []\n        for free_start, free_end in free_slots:\n            current_start = free_start\n            for busy_start, busy_end in merged_busy:\n                if busy_start > current_start:\n                    new_free_slots.append((current_start, busy_start))\n                current_start = max(current_start, busy_end)\n            if current_start < free_end:\n                new_free_slots.append((current_start, free_end))\n        free_slots = new_free_slots\n    \n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= duration_minutes:\n            meeting_end = start + duration_minutes\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Bryan is free all day\n    [],  # Lori is free all day\n    [\"9:30:11:00\", \"12:00:12:30\"],  # Kimberly\n    [\"9:00:9:30\", \"11:00:11:30\", \"12:30:13:30\", \"14:00:15:00\", \"15:30:16:30\"],  # Beverly\n    [\"9:30:11:30\", \"12:00:17:00\"],  # Dennis\n]\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, 30, 9, 17)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_253"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration):\n    # Convert all time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 (9:00)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = map(time_to_minutes, work_hours.split(':'))\n    duration_min = duration * 60\n    \n    # Collect all busy times for all participants\n    all_busy = []\n    for busy_times in participants_busy_times.values():\n        for start, end in busy_times:\n            all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy times by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy times and work hours\n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' busy times\nparticipants_busy_times = {\n    'Cheryl': [],\n    'Judith': [],\n    'Ann': [],\n    'Joseph': [\n        ('9:00', '10:30'),\n        ('11:00', '11:30'),\n        ('13:00', '14:00'),\n        ('14:30', '15:30'),\n        ('16:00', '17:00')\n    ],\n    'Douglas': [\n        ('9:00', '12:30'),\n        ('13:00', '14:30'),\n        ('15:00', '17:00')\n    ]\n}\n\n# Define work hours and meeting duration\nwork_hours = \"9:00:17:00\"  # Assuming this means 9:00 to 17:00\nduration = 0.5  # 0.5 hours = 30 minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy_times, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_254"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define each person's busy slots in minutes (start, end)\n    michael = [(9*60, 9*60+30), (10*60, 10*60+30), (13*60+30, 14*60), (16*60+30, 17*60)]\n    vincent = [(12*60+30, 13*60), (13*60+30, 14*60)]\n    laura = []\n    frank = [(9*60+30, 10*60+30), (11*60+30, 12*60+30), (14*60, 15*60), (16*60, 17*60)]\n    dylan = [(9*60+30, 15*60+30), (16*60, 17*60)]\n    \n    # Combine all busy slots\n    all_busy = michael + vincent + laura + frank + dylan\n    all_busy.sort()  # Sort by start time\n    \n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Check each free slot for 30-minute availability\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert start time back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = (start + meeting_duration) // 60\n            end_mm = (start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_255"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours=('09:00', '17:00')):\n    # Convert time strings to minutes since 9:00 for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work_hours start at 9:00\n\n    start_work, end_work = work_hours\n    start_min = time_to_minutes(start_work)\n    end_min = time_to_minutes(end_work)\n    \n    # Initialize the available slots as all time within work hours\n    available_slots = [(start_min, end_min)]\n    \n    # Process each participant's schedule to find common available slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = busy\n            busy_slots.append((time_to_minutes(start), time_to_minutes(end)))\n        # Sort the busy slots by start time\n        busy_slots.sort()\n        \n        # Merge overlapping or adjacent busy slots\n        merged_busy = []\n        for start, end in busy_slots:\n            if not merged_busy:\n                merged_busy.append((start, end))\n            else:\n                last_start, last_end = merged_busy[-1]\n                if start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged_busy[-1] = (new_start, new_end)\n                else:\n                    merged_busy.append((start, end))\n        \n        # Subtract the busy slots from available_slots\n        new_available_slots = []\n        for avail_start, avail_end in available_slots:\n            current_start = avail_start\n            for busy_start, busy_end in merged_busy:\n                if busy_end <= current_start:\n                    continue  # Busy slot is before current available\n                if busy_start >= avail_end:\n                    break     # Busy slot is after current available\n                if busy_start > current_start:\n                    new_available_slots.append((current_start, busy_start))\n                current_start = max(current_start, busy_end)\n            if current_start < avail_end:\n                new_available_slots.append((current_start, avail_end))\n        available_slots = new_available_slots\n    \n    # Find the first available slot that can fit the meeting\n    for slot in available_slots:\n        start, end = slot\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = 9 + minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    return None\n\n# Define the participants' schedules based on the task\nparticipants_schedules = [\n    [],  # Carol has no meetings\n    [(\"09:00\", \"09:30\"), (\"10:00\", \"10:30\"), (\"14:00\", \"15:00\")],  # Lori\n    [(\"09:30\", \"10:00\"), (\"12:30\", \"13:30\"), (\"14:00\", \"14:30\")],  # Patricia\n    [(\"09:00\", \"12:00\"), (\"12:30\", \"14:30\"), (\"15:00\", \"17:00\")],  # Alexis\n    [(\"09:00\", \"11:30\"), (\"12:30\", \"15:30\"), (\"16:00\", \"16:30\")],  # Tyler\n]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_256"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert all time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # 9:00 is 0 minutes\n\n    # Convert work hours to minutes\n    work_start = time_to_minutes(work_hours[0])\n    work_end = time_to_minutes(work_hours[1])\n\n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy in participants_busy:\n        for interval in busy:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n\n    # Find free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    prev_end = work_start\n\n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n\n    # Check each free interval for a slot that fits the meeting duration\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = 9 + minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' busy times\nparticipants_busy = [\n    [\"12:00 to 13:00\", \"13:30 to 14:00\", \"14:30 to 15:30\", \"16:30 to 17:00\"],  # Jennifer\n    [],  # Gregory\n    [],  # Stephanie\n    [\"9:00 to 9:30\", \"11:00 to 11:30\", \"12:00 to 12:30\", \"13:00 to 13:30\", \"14:00 to 15:30\", \"16:30 to 17:00\"],  # Lori\n    [\"9:00 to 11:30\", \"12:00 to 13:00\", \"13:30 to 14:30\", \"15:00 to 16:30\"],  # Jessica\n]\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 30  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_257"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert each participant's busy slots to minutes\n    juan_busy = [\n        (10 * 60 + 30, 11 * 60),\n        (12 * 60, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    marilyn_busy = [\n        (11 * 60, 11 * 60 + 30),\n        (13 * 60 + 30, 14 * 60)\n    ]\n    brian_busy = [\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n    ruth_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (13 * 60, 17 * 60)\n    ]\n    diana_busy = [\n        (9 * 60 + 30, 11 * 60 + 30),\n        (12 * 60, 16 * 60)\n    ]\n\n    # Combine all busy slots\n    all_busy = juan_busy + marilyn_busy + brian_busy + ruth_busy + diana_busy\n\n    # Sort busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check each free slot for a 30-minute window\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert start time back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = (start + meeting_duration) // 60\n            end_mm = (start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_258"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each participant's busy times to minutes since 9:00\n    # Randy's busy times (and constraint: not after 15:30)\n    randy_busy = [\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (16 * 60, 17 * 60)\n    ]\n    randy_constraint = 15 * 60 + 30  # 15:30\n    \n    # Carolyn's busy times\n    carolyn_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60, 11 * 60 + 30),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    # Christina's busy times\n    christina_busy = [\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60 + 30, 14 * 60)\n    ]\n    \n    # Amy's busy times\n    amy_busy = [\n        (9 * 60, 11 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60 + 30, 15 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n    \n    # Christine's busy times\n    christine_busy = [\n        (9 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60, 13 * 60),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    # Combine all busy times into a single list of intervals\n    all_busy = []\n    for busy in [randy_busy, carolyn_busy, christina_busy, amy_busy, christine_busy]:\n        all_busy.extend(busy)\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Filter free intervals to those that are at least 30 minutes and meet Randy's constraint\n    meeting_duration = 30\n    valid_slots = []\n    \n    for start, end in free_intervals:\n        if end - start >= meeting_duration:\n            # Check if the slot starts before Randy's constraint (15:30)\n            if start + meeting_duration <= randy_constraint:\n                valid_slots.append((start, start + meeting_duration))\n    \n    # The first valid slot is the earliest possible meeting time\n    if valid_slots:\n        meeting_start, meeting_end = valid_slots[0]\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No valid time slot found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_259"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:00:12:30}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert all time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work_hours start at 9:00\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = 9 + minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    work_start, work_end = work_hours.split(' to ')\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participans_schedules.values():\n        for busy in schedule:\n            start, end = busy.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            busy_intervals.append((start_min, end_min))\n    \n    # Sort busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots\n    available = []\n    prev_end = work_start_min\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        available.append((prev_end, work_end_min))\n    \n    # Check each available slot for duration\n    for slot_start, slot_end in available:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"Sharon\": [],\n    \"Ryan\": [\"10:00 to 11:00\", \"12:30 to 13:00\", \"14:00 to 14:30\"],\n    \"Isabella\": [\"11:00 to 11:30\", \"14:00 to 14:30\"],\n    \"Anna\": [\"9:00 to 10:00\", \"11:00 to 11:30\", \"13:00 to 14:30\", \"15:00 to 17:00\"],\n    \"Vincent\": [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:30 to 12:00\", \"13:30 to 16:00\"],\n}\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_hours = \"9:00 to 17:00\"\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_260"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{10:00:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability across all participants\n    # Since Alan is free all day, we only need to ensure the interval is free for others\n    # But to generalize, we can consider the merged busy intervals\n    \n    # Now, find the first free interval that can accommodate the meeting duration\n    meeting_duration_min = meeting_duration * 60\n    \n    for start, end in free_intervals:\n        if end - start >= meeting_duration_min:\n            meeting_end = start + meeting_duration_min\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"9:00 to 9:30\", \"11:30 to 12:00\", \"13:00 to 13:30\", \"15:30 to 16:00\"],  # Lisa\n    [\"13:00 to 13:30\", \"14:00 to 14:30\"],  # Frances\n    [],  # Alan\n    [\"9:30 to 10:00\", \"11:00 to 11:30\", \"13:00 to 14:00\", \"14:30 to 16:30\"],  # Linda\n    [\"9:00 to 9:30\", \"11:00 to 11:30\", \"12:00 to 12:30\", \"13:30 to 17:00\"],  # Shirley\n]\n\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 1  # in hours\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_261"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert all time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work_hours start at 9:00\n    \n    start_work, end_work = work_hours\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules.values():\n        for interval in schedule:\n            start, end = interval\n            busy_start = time_to_minutes(start)\n            busy_end = time_to_minutes(end)\n            busy_intervals.append((busy_start, busy_end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = 9 + minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            start_time = minutes_to_time(meeting_start)\n            end_time = minutes_to_time(meeting_end)\n            return f\"{start_time}:{end_time}\"\n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"Doris\": [(\"10:30\", \"11:00\"), (\"16:30\", \"17:00\")],\n    \"Dennis\": [(\"9:30\", \"10:00\"), (\"10:30\", \"11:00\"), (\"14:00\", \"14:30\"), (\"15:30\", \"16:00\")],\n    \"Matthew\": [(\"9:30\", \"10:30\"), (\"13:00\", \"13:30\"), (\"15:00\", \"15:30\")],\n    \"Andrea\": [(\"9:00\", \"10:00\"), (\"10:30\", \"11:30\"), (\"12:00\", \"13:00\"), (\"14:00\", \"14:30\"), (\"15:30\", \"17:00\")],\n    \"Brandon\": [(\"9:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"17:00\")]\n}\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\n# Work hours (9:00 to 17:00)\nwork_hours = (\"9:00\", \"17:00\")\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, duration, work_hours))\n```",
            "count": "calendar_scheduling_example_262"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each participant's busy slots to minutes since 9:00\n    # Nicholas has no meetings\n    nicholas_busy = []\n    \n    # Robert's busy slots\n    robert_busy = [\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60)\n    ]\n    \n    # Gary's busy slots\n    gary_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (13 * 60, 13 * 60 + 30)\n    ]\n    \n    # Doris's busy slots\n    doris_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 11 * 60),\n        (11 * 60 + 30, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    # Beverly's busy slots and preference (avoid before 11:30)\n    beverly_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 16 * 60 + 30)\n    ]\n    beverly_preference_start = 11 * 60 + 30  # 11:30\n    \n    # Combine all busy slots\n    all_busy = robert_busy + gary_busy + doris_busy + beverly_busy\n    \n    # Generate free slots by finding gaps in the combined busy slots\n    all_busy.sort()  # Sort by start time\n    free_slots = []\n    previous_end = work_start\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Filter free slots that are at least 30 minutes and meet Beverly's preference\n    valid_slots = []\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration and slot_start >= beverly_preference_start:\n            valid_slots.append((slot_start, slot_end))\n    \n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No valid slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_263"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time slots to minutes since start of the day for easier comparison\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n\n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n\n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n\n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:00 to 12:00\", \"13:00 to 13:30\", \"16:00 to 16:30\"],  # Amber\n    [\"11:00 to 11:30\", \"14:00 to 14:30\"],  # Christian\n    [\"11:00 to 11:30\", \"12:00 to 13:30\", \"14:00 to 14:30\", \"15:30 to 16:00\"],  # Natalie\n    [\"9:30 to 12:30\", \"14:00 to 14:30\", \"15:00 to 15:30\", \"16:00 to 17:00\"],  # Douglas\n    [\"9:00 to 9:30\", \"10:00 to 10:30\", \"12:00 to 13:00\", \"14:00 to 17:00\"],  # Larry\n]\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, \"9:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_264"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:30:15:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find the earliest time when everyone is free\n    current_start = work_start\n    \n    for start, end in busy_intervals:\n        if start > current_start:\n            # Check if there's enough time before the next busy interval\n            if start - current_start >= duration:\n                meeting_end = current_start + duration\n                if meeting_end <= work_end:\n                    return f\"{minutes_to_time(current_start)}:{minutes_to_time(meeting_end)}\"\n        # Update current_start to the end of the current busy interval if it's later\n        if end > current_start:\n            current_start = end\n    \n    # Check the remaining time after the last busy interval\n    if work_end - current_start >= duration:\n        meeting_end = current_start + duration\n        return f\"{minutes_to_time(current_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [],  # Cheryl is free\n    [\"09:30:10:00\", \"12:00:13:00\", \"14:00:14:30\", \"16:00:17:00\"],  # Juan\n    [],  # Alan is free\n    [\"09:00:10:30\", \"12:00:14:30\", \"15:00:16:00\"],  # Christina\n    [\"09:00:14:00\", \"15:00:17:00\"],  # Grace\n]\n\n# Define work hours and meeting duration\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes))\n```",
            "count": "calendar_scheduling_example_265"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:11:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since 9:00 (work_hours_start)\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m - work_hours_start * 60\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        h = (minutes + work_hours_start * 60) // 60\n        m = (minutes + work_hours_start * 60) % 60\n        return f\"{h:02d}:{m:02d}\"\n\n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots between work hours\n    available = []\n    prev_end = 0\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < (work_hours_end - work_hours_start) * 60:\n        available.append((prev_end, (work_hours_end - work_hours_start) * 60))\n    \n    # Find the first available slot that fits the duration\n    duration = duration_minutes\n    for start, end in available:\n        if end - start >= duration:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"09:30:10:00\", \"10:30:11:00\"],  # Joe\n    [\"11:30:12:00\", \"15:00:15:30\"],  # Keith\n    [\"09:00:09:30\", \"13:00:13:30\"],  # Patricia\n    [\"09:00:11:00\", \"11:30:16:30\"],  # Nancy\n    [\"09:00:10:00\", \"10:30:11:00\", \"11:30:12:30\", \"13:00:14:00\", \"14:30:15:00\", \"15:30:16:00\", \"16:30:17:00\"]  # Pamela\n]\n\n# Define work hours and meeting duration\nwork_hours_start = 9\nwork_hours_end = 17\nduration_minutes = 30\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes))\n```",
            "count": "calendar_scheduling_example_266"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy times in minutes (start, end)\n    deborah_busy = [(9*60, 9*60 + 30), (14*60, 14*60 + 30)]\n    gary_busy = [(12*60 + 30, 13*60), (14*60 + 30, 15*60)]\n    emma_busy = []\n    carolyn_busy = [(9*60 + 30, 12*60), (12*60 + 30, 15*60 + 30), (16*60, 16*60 + 30)]\n    karen_busy = [\n        (9*60 + 30, 10*60),\n        (10*60 + 30, 11*60),\n        (11*60 + 30, 12*60),\n        (12*60 + 30, 13*60),\n        (13*60 + 30, 14*60),\n        (15*60, 16*60 + 30)\n    ]\n    \n    # Emma's preference: not before 13:30\n    emma_preference_start = 13*60 + 30\n    \n    # Combine all busy times\n    all_busy = deborah_busy + gary_busy + carolyn_busy + karen_busy\n    \n    # Generate available slots (inverted busy times)\n    all_busy.sort()\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Filter slots that are at least 30 minutes and meet Emma's preference\n    meeting_duration = 30\n    valid_slots = []\n    \n    for start, end in available_slots:\n        if end - start >= meeting_duration:\n            slot_start = max(start, emma_preference_start)\n            if slot_start + meeting_duration <= end:\n                valid_slots.append((slot_start, slot_start + meeting_duration))\n    \n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start, meeting_end = valid_slots[0]\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        print(f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\")\n    else:\n        print(\"No valid slot found\")\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_267"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each person's busy slots to minutes since 9:00\n    # Jesse: 10:30-11:00, 11:30-12:00, 13:30-15:30\n    jesse_busy = [\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60 + 30, 15 * 60 + 30)\n    ]\n    \n    # Cheryl: 9:30-10:00, 12:30-13:00, 14:30-16:00, 16:30-17:00\n    cheryl_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Elizabeth: free all day\n    elizabeth_busy = []\n    \n    # Diana: 9:00-12:00, 12:30-13:30, 14:00-17:00\n    diana_busy = [\n        (9 * 60, 12 * 60),\n        (12 * 60 + 30, 13 * 60 + 30),\n        (14 * 60, 17 * 60)\n    ]\n    \n    # Barbara: 9:00-11:00, 11:30-12:00, 12:30-14:30, 15:00-16:30\n    barbara_busy = [\n        (9 * 60, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 14 * 60 + 30),\n        (15 * 60, 16 * 60 + 30)\n    ]\n    \n    # Combine all busy slots\n    all_busy = jesse_busy + cheryl_busy + elizabeth_busy + diana_busy + barbara_busy\n    \n    # Sort busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Check each free slot for a 30-minute window\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert back to HH:MM format\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_268"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since midnight\n    busy_slots = {\n        'Virginia': [(9*60 + 30, 10*60 + 30), (11*60, 11*60 + 30), (12*60, 12*60 + 30), (16*60, 17*60)],\n        'Melissa': [(11*60 + 30, 12*60 + 30), (14*60 + 30, 15*60), (16*60 + 30, 17*60)],\n        'Emma': [(10*60, 13*60 + 30), (14*60, 14*60 + 30), (15*60, 17*60)],\n        'Jacqueline': [(10*60, 11*60), (11*60 + 30, 12*60), (13*60, 14*60 + 30), (15*60 + 30, 16*60), (16*60 + 30, 17*60)],\n    }\n\n    # Collect all busy slots from all participants except Jacob (free all day)\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n\n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check the slot after the last busy slot until work_end\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_269"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    duration = 30         # meeting duration in minutes\n\n    # Define busy intervals for each participant in minutes since midnight\n    frances_busy = [(9*60, 10*60 + 30), (12*60 + 30, 13*60)]\n    kimberly_busy = [(9*60, 9*60 + 30), (12*60, 13*60 + 30), (14*60, 14*60 + 30), (15*60, 15*60 + 30), (16*60, 17*60)]\n    christopher_busy = [(9*60 + 30, 10*60 + 30), (11*60, 14*60 + 30), (15*60 + 30, 17*60)]\n    \n    # Kimberly's preference: avoid meetings after 12:30 (12*60 + 30)\n    kimberly_preference_cutoff = 12 * 60 + 30\n\n    # Combine all busy intervals\n    all_busy = frances_busy + kimberly_busy + christopher_busy\n    # Sort by start time\n    all_busy.sort()\n\n    # Find free slots\n    free_slots = []\n    prev_end = work_start\n\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n\n    # Filter free slots that are at least 'duration' long and meet Kimberly's preference\n    possible_slots = []\n    for start, end in free_slots:\n        if end - start >= duration:\n            # Check if the slot is entirely before Kimberly's preference cutoff\n            if end <= kimberly_preference_cutoff:\n                possible_slots.append((start, end))\n    \n    # If no slots before cutoff, consider all free slots\n    if not possible_slots:\n        for start, end in free_slots:\n            if end - start >= duration:\n                possible_slots.append((start, end))\n\n    # Select the earliest possible slot\n    if possible_slots:\n        start, end = possible_slots[0]\n        # Convert minutes back to HH:MM format\n        start_hh = start // 60\n        start_mm = start % 60\n        end_hh = (start + duration) // 60\n        end_mm = (start + duration) % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_270"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:30:16:00}",
            "type_error": "SyntaxError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start, end = work_hours\n    # Convert time strings to minutes for easier calculation\n    start_min = time_to_minutes(start)\n    end_min = time_to_minutes(end)\n    duration_min = duration * 60\n    \n    # Initialize a list to track busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            busy_start = time_to_minutes(busy[0])\n            busy_end = time_to_minutes(busy[1])\n            busy_intervals.append((busy_start, busy_end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find the earliest available slot\n    previous_end = start_min\n    for interval in busy_intervals:\n        current_start, current_end = interval\n        if current_start > previous_end:\n            available_start = previous_end\n            available_end = current_start\n            if available_end - available_start >= duration_min:\n                return (minutes_to_time(available_start), minutes_to_time(available_start + duration_min)\n        previous_end = max(previous_end, current_end)\n    \n    # Check the slot after the last busy interval\n    if end_min - previous_end >= duration_min:\n        return (minutes_to_time(previous_end), minutes_to_time(previous_end + duration_min))\n    \n    return None\n\ndef time_to_minutes(time_str):\n    hours, minutes = map(int, time_str.split(':'))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Define work hours and meeting duration\nwork_hours = ('9:00', '17:00')\nduration = 0.5  # 0.5 hours = 30 minutes\n\n# Define participants' schedules\nparticipants_schedules = [\n    [('9:30', '10:00'), ('12:00', '14:00'), ('16:30', '17:00')],  # Teresa\n    [('11:30', '12:00'), ('14:00', '14:30')],  # Amanda\n    [],  # Frances\n    [('9:00', '12:00'), ('12:30', '14:00'), ('14:30', '15:30'), ('16:30', '17:00')],  # Evelyn\n    [('9:00', '10:00'), ('10:30', '11:30'), ('12:00', '13:00'), ('13:30', '15:30'), ('16:00', '17:00')]  # Betty\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nif meeting_time:\n    print(f\"{meeting_time[0]}:{meeting_time[1]}\")\nelse:\n    print(\"No available time slot found.\")\n```",
            "count": "calendar_scheduling_example_271"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Convert all blocked times to minutes since midnight\n    blocked_slots = {\n        'Teresa': [(9*60 + 30, 10*60), (12*60, 13*60), (14*60, 14*60 + 30)],\n        'Scott': [(9*60, 9*60 + 30), (10*60, 11*60), (11*60 + 30, 12*60), (15*60, 16*60)],\n        'Eric': [(12*60, 12*60 + 30), (13*60, 13*60 + 30), (14*60 + 30, 15*60 + 30)],\n        'Maria': [(9*60, 10*60), (10*60 + 30, 12*60), (12*60 + 30, 13*60 + 30), (14*60, 15*60 + 30)],\n        'Emily': [(9*60, 11*60 + 30), (12*60 + 30, 14*60), (14*60 + 30, 15*60), (16*60 + 30, 17*60)],\n    }\n    \n    # Collect all blocked slots\n    all_blocked = []\n    for person in blocked_slots:\n        all_blocked.extend(blocked_slots[person])\n    \n    # Sort blocked slots by start time\n    all_blocked.sort()\n    \n    # Find free slots by checking gaps between blocked slots and work hours\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_blocked:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the time after the last blocked slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can accommodate 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_272"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 9:00 (0 minutes)\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    # Initialize the work hours in minutes\n    start_work = time_to_minutes(work_hours[0])\n    end_work = time_to_minutes(work_hours[1])\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules.values():\n        for interval in schedule:\n            start, end = interval\n            busy_start = time_to_minutes(start)\n            busy_end = time_to_minutes(end)\n            busy_intervals.append((busy_start, busy_end))\n    \n    # Sort the busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    prev_end = start_work\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < end_work:\n        free_intervals.append((prev_end, end_work))\n    \n    # Check each free interval for availability of duration\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"John\": [\"11:30-12:00\", \"13:30-14:00\", \"15:00-15:30\", \"16:00-16:30\"],\n    \"Frank\": [\"12:00-13:30\", \"15:00-15:30\"],\n    \"Randy\": [],\n    \"Larry\": [\"9:00-11:00\", \"11:30-12:00\", \"13:30-14:00\", \"14:30-15:00\", \"16:30-17:00\"],\n    \"Beverly\": [\"9:00-11:00\", \"12:00-12:30\", \"13:30-17:00\"],\n}\n\n# Convert each participant's schedule to list of intervals\nfor name in participants_schedules:\n    intervals = []\n    for interval in participants_schedules[name]:\n        start, end = interval.split('-')\n        intervals.append((start, end))\n    participants_schedules[name] = intervals\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 30  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_273"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define each person's busy slots in minutes\n    busy_slots = {\n        'Kevin': [(11 * 60 + 30, 12 * 60), (14 * 60, 14 * 60 + 30), (16 * 60, 17 * 60)],\n        'Joyce': [],\n        'Kathryn': [(9 * 60, 9 * 60 + 30), (11 * 60 + 30, 12 * 60)],\n        'Bruce': [(9 * 60, 10 * 60 + 30), (11 * 60, 13 * 60 + 30), (14 * 60, 17 * 60)],\n        'Ronald': [(9 * 60 + 30, 11 * 60), (11 * 60 + 30, 13 * 60 + 30), \n                    (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)]\n    }\n\n    # Duration of the meeting in minutes\n    duration = 30\n\n    # Iterate through each minute in the work hours\n    for start_time in range(work_start, work_end - duration + 1):\n        end_time = start_time + duration\n        all_available = True\n\n        # Check each person's availability\n        for person, slots in busy_slots.items():\n            for (busy_start, busy_end) in slots:\n                # Check if the proposed slot overlaps with any busy slot\n                if not (end_time <= busy_start or start_time >= busy_end):\n                    all_available = False\n                    break\n            if not all_available:\n                break\n\n        if all_available:\n            # Convert minutes back to HH:MM format\n            start_hh = start_time // 60\n            start_mm = start_time % 60\n            end_hh = end_time // 60\n            end_mm = end_time % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No available time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_274"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since midnight\n    busy_slots = {\n        'Jose': [(11 * 60, 11 * 60 + 30), (12 * 60 + 30, 13 * 60)],\n        'Albert': [(10 * 60, 10 * 60 + 30), (11 * 60, 11 * 60 + 30), (13 * 60, 14 * 60 + 30), (15 * 60, 15 * 60 + 30)],\n        'Brenda': [(10 * 60, 10 * 60 + 30), (11 * 60, 11 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60 + 30)],\n        'Bruce': [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 13 * 60), (13 * 60 + 30, 16 * 60 + 30)],\n        'Jacob': [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 11 * 60 + 30), (12 * 60, 14 * 60), (15 * 60, 15 * 60 + 30)]\n    }\n\n    # Collect all busy slots\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n\n    # Sort busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check the time after the last busy slot until work_end\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_275"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert each participant's busy slots to minutes\n    christine_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30)\n    ]\n    \n    natalie_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    # Willie is free all day but can't meet after 12:00\n    willie_busy = [(12 * 60, work_end)]\n    \n    anna_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    \n    evelyn_busy = [\n        (11 * 60, 12 * 60),\n        (12 * 60 + 30, 13 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (16 * 60, 17 * 60)\n    ]\n    \n    # Combine all busy slots\n    all_busy = christine_busy + natalie_busy + willie_busy + anna_busy + evelyn_busy\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    # Check after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that is at least 30 minutes long\n    meeting_duration = 30\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Convert back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = (slot_start + meeting_duration) // 60\n            end_mm = (slot_start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_276"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each person's busy slots to minutes\n    # Virginia's busy slots\n    virginia_busy = [\n        (9 * 60, 10 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    \n    # Lawrence's busy slots\n    lawrence_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 17 * 60)\n    ]\n    \n    # Angela's busy slots\n    angela_busy = [\n        (9 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Marilyn and Diana have no meetings, so their busy slots are empty\n    \n    # Combine all busy slots\n    all_busy = virginia_busy + lawrence_busy + angela_busy\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Check each free slot for a 30-minute window\n    meeting_duration = 30\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Found a suitable slot\n            start_hour = slot_start // 60\n            start_min = slot_start % 60\n            end_hour = (slot_start + meeting_duration) // 60\n            end_min = (slot_start + meeting_duration) % 60\n            return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_277"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m - 540  # Subtract 540 to start from 0 (9:00)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        h = (minutes + 540) // 60\n        m = (minutes + 540) % 60\n        return f\"{h:02d}:{m:02d}\"\n    \n    # Initialize the availability list (0 to 480 minutes, 9:00-17:00 is 8 hours)\n    availability = [True] * (work_hours[1] - work_hours[0])\n    \n    # Mark busy times for each participant\n    for person, busy_slots in participants_busy.items():\n        for slot in busy_slots:\n            start = time_to_minutes(slot[0])\n            end = time_to_minutes(slot[1])\n            for i in range(start, end):\n                if i >= 0 and i < len(availability):\n                    availability[i] = False\n    \n    # Find the first available slot of duration\n    duration_min = duration\n    start_time = None\n    for i in range(len(availability) - duration_min + 1):\n        if all(availability[i:i+duration_min]):\n            start_time = i\n            break\n    \n    if start_time is not None:\n        end_time = start_time + duration_min\n        return f\"{minutes_to_time(start_time)}:{minutes_to_time(end_time)}\"\n    else:\n        return \"No available slot found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (9 * 60, 17 * 60)  # 9:00 and 17:00 in minutes since midnight\n\n# Define participants' busy times\nparticipants_busy = {\n    'Donald': [('10:00', '10:30'), ('11:30', '13:00'), ('15:30', '16:00'), ('16:30', '17:00')],\n    'Gregory': [('9:30', '10:00'), ('12:00', '12:30'), ('13:00', '13:30'), ('14:30', '15:00')],\n    'Roy': [('10:00', '10:30'), ('12:30', '13:00')],\n    'Jack': [('9:00', '9:30'), ('10:00', '13:30'), ('14:00', '16:00')],\n    'Paul': [('9:00', '11:30'), ('12:00', '12:30'), ('13:00', '13:30'), ('15:00', '16:30')]\n}\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_278"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define busy slots for each participant in minutes\n    busy_slots = {\n        'Thomas': [(9 * 60, 9 * 60 + 30), (14 * 60, 14 * 60 + 30)],\n        'Albert': [(9 * 60 + 30, 11 * 60), (12 * 60, 13 * 60), (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Margaret': [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 11 * 60 + 30), (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 15 * 60 + 30), (16 * 60, 17 * 60)],\n    }\n\n    # Betty's preference: not after 13:00\n    betty_preference_end = 13 * 60\n\n    # Collect all busy slots\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n\n    # Add Betty's preference as a busy slot after 13:00\n    all_busy.append((betty_preference_end, work_end))\n\n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check for a free slot that is at least 30 minutes long\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Return the first suitable slot\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_279"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:9:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert all time strings to minutes since 9:00 (work_hours_start)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # 9:00 is 0 minutes\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = 9 + minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration_min = duration * 60\n\n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules.values():\n        for busy in schedule:\n            start = time_to_minutes(busy[0])\n            end = time_to_minutes(busy[1])\n            all_busy.append((start, end))\n\n    # Sort all busy intervals by start time\n    all_busy.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find available slots by checking gaps between merged intervals\n    available = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n\n    # Find the first available slot that fits the duration\n    for slot in available:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No available time slot found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"Charles\": [(\"13:00\", \"14:30\"), (\"15:00\", \"16:30\")],\n    \"Adam\": [(\"12:00\", \"12:30\"), (\"16:00\", \"16:30\")],\n    \"Jason\": [(\"9:30\", \"10:00\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"15:00\", \"15:30\")],\n    \"Daniel\": [(\"9:30\", \"10:30\"), (\"11:00\", \"11:30\"), (\"12:30\", \"13:00\"), (\"14:00\", \"15:30\"), (\"16:00\", \"16:30\")],\n    \"Ethan\": [(\"10:00\", \"12:00\"), (\"12:30\", \"14:30\"), (\"16:00\", \"17:00\")]\n}\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, \"9:00\", \"17:00\", 0.5)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_280"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration_minutes):\n    # Convert work hours to minutes since midnight\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's busy times\n    for busy_times in participants_busy_times:\n        new_free_slots = []\n        for slot in free_slots:\n            current_start = slot[0]\n            for busy in busy_times:\n                busy_start = busy[0] * 60\n                busy_end = busy[1] * 60\n                if busy_start > current_start:\n                    new_free_slots.append((current_start, busy_start))\n                current_start = max(current_start, busy_end)\n            if current_start < slot[1]:\n                new_free_slots.append((current_start, slot[1]))\n        free_slots = new_free_slots\n    \n    # Find the first slot that can accommodate the meeting duration\n    for slot in free_slots:\n        slot_duration = slot[1] - slot[0]\n        if slot_duration >= duration_minutes:\n            meeting_start = slot[0]\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No suitable time found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (9, 17)\n\n# Define each participant's busy times in HH.MM format\nparticipants_busy_times = [\n    [],  # Rebecca\n    [],  # Alexander\n    [(11.5, 12), (12.5, 13), (13.5, 14.5), (15, 15.5), (16, 16.5)],  # Angela\n    [(9.5, 10), (10.5, 15), (15.5, 16.5)],  # Beverly\n    [(9.5, 11), (11.5, 12), (13, 13.5), (14, 15), (16.5, 17)]  # Peter\n]\n\n# Meeting duration in minutes (30 minutes)\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_281"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_hour, end_hour = work_hours\n    # Convert work hours to minutes\n    start_time = start_hour * 60\n    end_time = end_hour * 60\n    \n    # Initialize a list to track busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules.values():\n        all_busy.extend(schedule)\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for busy in all_busy:\n        if not merged:\n            merged.append(busy)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = busy\n            if current_start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append(busy)\n    \n    # Find available slots between work hours and busy intervals\n    available = []\n    prev_end = start_time\n    for busy_start, busy_end in merged:\n        if busy_start > prev_end:\n            available.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n    if prev_end < end_time:\n        available.append((prev_end, end_time))\n    \n    # Check each available slot for sufficient duration\n    for slot_start, slot_end in available:\n        if slot_end - slot_start >= duration:\n            # Convert back to hours and minutes\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = (slot_start + duration) // 60\n            end_mm = (slot_start + duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules in minutes since midnight\nparticipants_schedules = {\n    \"Larry\": [(10*60 + 30, 11*60), (11*60 + 30, 12*60)],\n    \"Juan\": [],\n    \"Emily\": [],\n    \"Joan\": [(9*60 + 30, 11*60), (11*60 + 30, 12*60), (12*60 + 30, 14*60), (15*60, 15*60 + 30)],\n    \"Julie\": [(9*60, 11*60 + 30), (12*60 + 30, 17*60)],\n}\n\n# Define work hours and meeting duration\nwork_hours = (9*60, 17*60)  # 9:00 to 17:00 in minutes\nduration = 30  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_282"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start, work_end = map(time_to_minutes, work_hours)\n    duration_min = duration * 60\n\n    # Collect all busy times for all participants\n    all_busy_times = []\n    for busy_times in participants_busy_times.values():\n        for start, end in busy_times:\n            all_busy_times.append((time_to_minutes(start), time_to_minutes(end)))\n\n    # Sort all busy times by start time\n    all_busy_times.sort()\n\n    # Generate available slots by finding gaps between busy times and work hours\n    available_slots = []\n    prev_end = work_start\n\n    for start, end in all_busy_times:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No available time slot found\"\n\n# Define participants' busy times\nparticipants_busy_times = {\n    \"Rachel\": [(\"12:00\", \"12:30\"), (\"15:00\", \"15:30\")],\n    \"Alexander\": [(\"14:00\", \"14:30\"), (\"15:00\", \"15:30\")],\n    \"Aaron\": [(\"09:00\", \"10:30\"), (\"11:30\", \"17:00\")],\n    \"Hannah\": [(\"09:00\", \"09:30\"), (\"11:00\", \"11:30\"), (\"12:30\", \"14:30\"), (\"15:00\", \"15:30\"), (\"16:00\", \"16:30\")],\n    \"Juan\": []\n}\n\n# Define work hours and meeting duration\nwork_hours = (\"09:00\", \"17:00\")\nduration = 0.5  # half an hour\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_283"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_start=9 * 60, work_end=17 * 60):\n    # Convert all schedules to minutes since midnight for easier comparison\n    busy_slots = []\n    for schedule in participants_schedules:\n        for start, end in schedule:\n            busy_slots.append((start, end))\n    \n    # Sort all busy slots by start time\n    busy_slots.sort()\n    \n    # Merge overlapping or adjacent busy slots\n    merged_slots = []\n    for start, end in busy_slots:\n        if not merged_slots:\n            merged_slots.append((start, end))\n        else:\n            last_start, last_end = merged_slots[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged_slots[-1] = (new_start, new_end)\n            else:\n                merged_slots.append((start, end))\n    \n    # Find available slots between work hours, outside merged busy slots\n    available_slots = []\n    previous_end = work_start\n    for start, end in merged_slots:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for start, end in available_slots:\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return None\n\n# Define participants' schedules in minutes since midnight\nparticipants_schedules = [\n    [],  # Frances has no meetings\n    [(10 * 60 + 30, 11 * 60 + 0), (14 * 60 + 0, 14 * 60 + 30), (16 * 60 + 0, 17 * 60 + 0)],  # Jack\n    [(12 * 60 + 30, 13 * 60 + 0), (14 * 60 + 0, 14 * 60 + 30)],  # Susan\n    [(9 * 60 + 0, 10 * 60 + 0), (10 * 60 + 30, 11 * 60 + 30), (12 * 60 + 0, 12 * 60 + 30), \n     (15 * 60 + 0, 16 * 60 + 0), (16 * 60 + 30, 17 * 60 + 0)],  # Scott\n    [(9 * 60 + 0, 10 * 60 + 0), (11 * 60 + 0, 14 * 60 + 0), (14 * 60 + 30, 16 * 60 + 0), \n     (16 * 60 + 30, 17 * 60 + 0)],  # Joan\n]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_284"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    duration = 30         # meeting duration in minutes\n\n    # Define each person's busy times in minutes since midnight\n    logan_busy = [(10 * 60, 10 * 60 + 30), (14 * 60, 14 * 60 + 30)]\n    kathryn_busy = []\n    jennifer_busy = []\n    alexis_busy = [(9 * 60, 11 * 60), (12 * 60, 14 * 60), (15 * 60, 16 * 60)]\n    roy_busy = [(9 * 60, 10 * 60 + 30), (12 * 60, 12 * 60 + 30), \n                (13 * 60, 13 * 60 + 30), (14 * 60, 15 * 60), (16 * 60, 16 * 60 + 30)]\n\n    # Alexis's preference: not before 16:30\n    alexis_preference_start = 16 * 60 + 30\n\n    # Combine all busy times\n    all_busy = logan_busy + kathryn_busy + jennifer_busy + alexis_busy + roy_busy\n\n    # Generate available slots by finding gaps in busy times\n    all_busy.sort()\n    available_slots = []\n    prev_end = work_start\n\n    for start, end in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Filter slots that meet duration and Alexis's preference\n    valid_slots = []\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration and slot_start >= alexis_preference_start:\n            valid_slots.append(slot)\n\n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No valid slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_285"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Check each available slot for sufficient duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"9:00 to 10:30\", \"15:00 to 15:30\"],  # Ralph\n    [],                                   # John\n    [],                                   # Sharon\n    [\"9:30 to 13:30\", \"14:00 to 17:00\"], # Sophia\n    [\"9:00 to 10:30\", \"12:00 to 13:30\", \"15:00 to 15:30\", \"16:30 to 17:00\"]  # Samantha\n]\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 30  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration))\n```",
            "count": "calendar_scheduling_example_286"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:30:10:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes, work_start, work_end):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start_min, work_end_min)]\n    \n    # Process each participant's busy slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_slots.append((start, end))\n        \n        # Sort the busy slots\n        busy_slots.sort()\n        \n        # Update free_slots by subtracting busy slots\n        new_free_slots = []\n        for free_start, free_end in free_slots:\n            current_start = free_start\n            for busy_start, busy_end in busy_slots:\n                if busy_start >= free_end:\n                    break\n                if busy_end <= current_start:\n                    continue\n                if busy_start > current_start:\n                    new_free_slots.append((current_start, busy_start))\n                current_start = max(current_start, busy_end)\n            if current_start < free_end:\n                new_free_slots.append((current_start, free_end))\n        free_slots = new_free_slots\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' busy schedules\nparticipants_schedules = [\n    [\"10:00:10:30\", \"11:30:12:30\", \"14:30:15:30\", \"16:00:16:30\"],  # Aaron\n    [],  # Lori\n    [],  # Jordan\n    [\"9:00:9:30\", \"10:00:13:00\", \"14:00:14:30\", \"15:00:16:00\"],  # Noah\n    [\"9:00:9:30\", \"10:00:16:00\", \"16:30:17:00\"],  # Susan\n]\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_start = \"9:00\"\nwork_end = \"17:00\"\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_start, work_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_287"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:00:10:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    meeting_duration_min = meeting_duration * 60\n\n    # Initialize the list of busy intervals for all participants\n    all_busy_intervals = []\n    for busy_times in participants_busy_times:\n        for interval in busy_times:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            all_busy_intervals.append((start, end))\n\n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged_intervals = []\n    for start, end in all_busy_intervals:\n        if not merged_intervals:\n            merged_intervals.append([start, end])\n        else:\n            last_start, last_end = merged_intervals[-1]\n            if start <= last_end:\n                merged_intervals[-1][1] = max(end, last_end)\n            else:\n                merged_intervals.append([start, end])\n\n    # Find available slots by checking gaps between merged intervals and work hours\n    available_slots = []\n    prev_end = work_start\n    for start, end in merged_intervals:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Find the first available slot that can accommodate the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No available time slot found\"\n\n# Define the participants' busy times\nparticipants_busy_times = [\n    [\"9:30 to 10:00\", \"14:30 to 15:00\"],  # Dennis\n    [\"10:30 to 11:00\", \"11:30 to 12:30\", \"13:00 to 13:30\"],  # Ralph\n    [\"11:00 to 11:30\", \"12:00 to 13:00\", \"14:00 to 15:00\", \"15:30 to 16:00\"],  # Jesse\n    [\"9:00 to 10:00\", \"10:30 to 12:00\", \"13:00 to 15:00\", \"15:30 to 17:00\"],  # Deborah\n    [\"9:00 to 9:30\", \"10:30 to 11:30\", \"12:00 to 13:30\", \"14:00 to 17:00\"],  # Karen\n]\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 0.5  # in hours\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_288"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert all schedules to minutes for easier comparison\n    # Each person's busy times are represented as (start, end) in minutes\n    janet_busy = [\n        (10 * 60 + 30, 11 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    \n    alexander_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    alan_busy = [\n        (9 * 60, 11 * 60),\n        (13 * 60, 14 * 60),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    henry_busy = [\n        (9 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 17 * 60)\n    ]\n    \n    # Combine all busy times\n    all_busy = janet_busy + alexander_busy + alan_busy + henry_busy\n    \n    # Sort all busy times by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    prev_end = work_start\n    \n    for busy in all_busy:\n        start, end = busy\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    # Check the time after the last busy slot until work_end\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Find the first free slot that can accommodate 30 minutes\n    meeting_duration = 30\n    for slot in free_slots:\n        start, end = slot\n        if end - start >= meeting_duration:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = (start + meeting_duration) // 60\n            end_mm = (start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_289"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define each person's busy times in minutes since midnight\n    busy_times = {\n        'Ryan': [],\n        'Susan': [],\n        'Joyce': [(10 * 60, 10 * 60 + 30), (15 * 60 + 30, 16 * 60)],\n        'Jacob': [(9 * 60, 11 * 60), (12 * 60 + 30, 13 * 60), (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Lauren': [(9 * 60, 10 * 60), (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 17 * 60)],\n    }\n\n    # Lauren's preference: avoid after 13:00 (but already blocked in schedule)\n    # Combine all busy times\n    all_busy = []\n    for person in busy_times:\n        all_busy.extend(busy_times[person])\n    \n    # Sort busy times by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy times and work hours\n    free_slots = []\n    prev_end = work_start\n\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    # Check after last busy time\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n\n    # Find the first free slot that can fit the meeting\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= meeting_duration:\n            # Convert back to HH:MM format\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_290"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration_minutes):\n    # Convert all time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work_hours start at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = 9 + minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    start_work = time_to_minutes(work_hours[0])\n    end_work = time_to_minutes(work_hours[1])\n    \n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy_times in participants_busy_times.values():\n        for busy in busy_times:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals\n    all_busy.sort()\n    \n    # Find free intervals by merging busy intervals\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Find the gaps between busy intervals that are within work hours\n    free_intervals = []\n    prev_end = start_work\n    for start, end in merged_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < end_work:\n        free_intervals.append((prev_end, end_work))\n    \n    # Check each free interval for a slot that fits the meeting duration\n    for start, end in free_intervals:\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            return (minutes_to_time(meeting_start), minutes_to_time(meeting_end))\n    \n    return None\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration_minutes = 30\n\n# Define participants' busy times\nparticipants_busy_times = {\n    \"Pamela\": [],\n    \"Randy\": [\"10:30 to 12:00\", \"14:30 to 15:30\", \"16:30 to 17:00\"],\n    \"Elijah\": [\"13:00 to 13:30\", \"15:00 to 15:30\"],\n    \"Jerry\": [\"9:00 to 10:00\", \"10:30 to 15:30\", \"16:00 to 17:00\"],\n    \"Kevin\": [\"9:00 to 9:30\", \"10:00 to 11:00\", \"12:30 to 13:30\", \"14:00 to 14:30\", \"16:00 to 17:00\"],\n}\n\n# Find a meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours, duration_minutes)\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{start}:{end}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_291"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert each person's busy slots to minutes\n    larry_busy = [\n        (9 * 60, 10 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    harold_busy = [\n        (11 * 60 + 30, 12 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    elijah_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60)\n    ]\n    willie_busy = [\n        (9 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 13 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    patrick_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n\n    # Combine all busy slots\n    all_busy = larry_busy + harold_busy + elijah_busy + willie_busy + patrick_busy\n\n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by merging busy intervals\n    free_slots = []\n    prev_end = work_start\n\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n\n    # Check each free slot for the earliest 30-minute window\n    meeting_duration = 30\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_292"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    duration = 30         # meeting duration in minutes\n\n    # Define each person's busy times in minutes since 9:00\n    # Format: (start, end) in minutes\n    scott_busy = []\n    nicholas_busy = [(11*60, 11*60+30), (15*60+30, 16*60)]\n    donna_busy = [(9*60+30, 10*60), (12*60, 12*60+30), (14*60, 14*60+30), (16*60, 16*60+30)]\n    vincent_busy = [(9*60+30, 11*60), (11*60+30, 12*60), (13*60+30, 14*60+30), (15*60+30, 16*60+30)]\n    ann_busy = [(9*60+30, 11*60), (12*60, 13*60), (14*60, 15*60), (16*60+30, 17*60)]\n\n    # Vincent's constraint: no meetings after 14:30 (14*60 + 30)\n    vincent_max_time = 14 * 60 + 30\n\n    # Combine all busy times\n    all_busy = scott_busy + nicholas_busy + donna_busy + vincent_busy + ann_busy\n\n    # Generate free slots by finding gaps between busy times\n    # Sort all busy times by start time\n    all_busy.sort()\n    \n    # Initialize free slots\n    free_slots = []\n    prev_end = work_start\n\n    for busy_start, busy_end in all_busy:\n        if busy_start > prev_end:\n            free_slots.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n    \n    # Check the slot after the last busy time\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n\n    # Now find the first free slot that fits the duration and Vincent's constraint\n    for slot_start, slot_end in free_slots:\n        # Calculate the latest possible start time in this slot\n        latest_start = min(slot_end - duration, vincent_max_time - duration)\n        if latest_start >= slot_start:\n            # Found a valid slot\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_293"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = map(time_to_minutes, work_hours.split('-'))\n    \n    # Generate all possible busy intervals for all participants\n    all_busy_intervals = []\n    for busy_times in participants_busy_times.values():\n        for interval in busy_times:\n            start, end = map(time_to_minutes, interval.split('-'))\n            all_busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_intervals = []\n    for start, end in all_busy_intervals:\n        if not merged_intervals:\n            merged_intervals.append([start, end])\n        else:\n            last_start, last_end = merged_intervals[-1]\n            if start <= last_end:\n                merged_intervals[-1][1] = max(end, last_end)\n            else:\n                merged_intervals.append([start, end])\n    \n    # Find available slots between work hours and busy intervals\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged_intervals:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Check each available slot for a duration that fits\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}-{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define the participants' busy times\nparticipants_busy_times = {\n    \"Willie\": [],\n    \"Marilyn\": [\"14:00-14:30\", \"15:00-15:30\"],\n    \"Charlotte\": [\"9:00-9:30\", \"10:00-10:30\", \"11:00-11:30\", \"16:00-16:30\"],\n    \"Zachary\": [\"9:00-9:30\", \"10:00-11:00\", \"11:30-12:00\", \"12:30-13:30\", \"14:30-15:30\", \"16:00-17:00\"],\n    \"Noah\": [\"10:30-11:30\", \"12:00-14:00\", \"14:30-15:00\", \"15:30-17:00\"],\n}\n\n# Define work hours and meeting duration\nwork_hours = \"9:00-17:00\"\nmeeting_duration = 30  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_294"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:30:16:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours=('09:00', '17:00')):\n    # Convert all time strings to minutes since midnight for easier comparison\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start, work_end = map(time_to_minutes, work_hours)\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's schedule to find common free slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_slots.append((start, end))\n        # Sort the busy slots by start time\n        busy_slots.sort()\n        \n        # Merge overlapping or adjacent busy slots\n        merged_busy = []\n        for start, end in busy_slots:\n            if not merged_busy:\n                merged_busy.append((start, end))\n            else:\n                last_start, last_end = merged_busy[-1]\n                if start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged_busy[-1] = (new_start, new_end)\n                else:\n                    merged_busy.append((start, end))\n        \n        # Calculate free slots for this participant\n        participant_free = []\n        prev_end = work_start\n        for start, end in merged_busy:\n            if start > prev_end:\n                participant_free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            participant_free.append((prev_end, work_end))\n        \n        # Intersect with the current common free slots\n        new_free_slots = []\n        i = j = 0\n        while i < len(free_slots) and j < len(participant_free):\n            slot_start, slot_end = free_slots[i]\n            part_start, part_end = participant_free[j]\n            \n            # Find the overlap\n            overlap_start = max(slot_start, part_start)\n            overlap_end = min(slot_end, part_end)\n            \n            if overlap_start < overlap_end:\n                new_free_slots.append((overlap_start, overlap_end))\n            \n            # Move the pointer which ends first\n            if slot_end < part_end:\n                i += 1\n            else:\n                j += 1\n        \n        free_slots = new_free_slots\n    \n    # Find the first free slot that can fit the meeting duration\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration_minutes:\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            \n            meeting_start = minutes_to_time(slot_start)\n            meeting_end = minutes_to_time(slot_start + duration_minutes)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [],  # Joan is free all day\n    [\"09:00:10:00\", \"11:30:12:00\", \"16:30:17:00\"],  # Gloria\n    [\"09:30:10:00\", \"10:30:11:00\", \"12:00:13:00\", \"16:00:17:00\"],  # Ann\n    [\"09:00:10:00\", \"10:30:11:30\", \"13:00:13:30\", \"14:00:15:30\", \"16:00:17:00\"],  # Dorothy\n    [\"09:00:09:30\", \"10:00:15:30\", \"16:00:17:00\"],  # David\n]\n\n# Find the meeting time\nprint(find_meeting_time(participants_schedules))\n```",
            "count": "calendar_scheduling_example_295"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    albert_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    jessica_busy = [\n        (10 * 60, 11 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    lisa_busy = []  # Wide open\n    \n    danielle_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (11 * 60, 12 * 60),\n        (13 * 60 + 30, 16 * 60 + 30)\n    ]\n    \n    deborah_busy = [\n        (9 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (13 * 60, 14 * 60),\n        (15 * 60, 16 * 60)\n    ]\n    \n    # Combine all busy slots\n    all_busy = albert_busy + jessica_busy + danielle_busy + deborah_busy\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_296"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy times to minutes since midnight\n    # Carolyn: 10:00-10:30, 12:00-13:00, 13:30-14:00, 15:00-16:00\n    carolyn_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (12 * 60, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60, 16 * 60)\n    ]\n    \n    # Mark: 12:30-13:00, 15:00-15:30\n    mark_busy = [\n        (12 * 60 + 30, 13 * 60),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    \n    # Thomas: free all day, but prefers after 10:30\n    thomas_busy = [\n        (work_start, 10 * 60 + 30)\n    ]\n    \n    # Hannah: 9:30-11:00, 12:00-15:30, 16:00-17:00\n    hannah_busy = [\n        (9 * 60 + 30, 11 * 60),\n        (12 * 60, 15 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n    \n    # Abigail: 9:30-10:30, 12:00-12:30, 13:00-15:00, 16:00-16:30\n    abigail_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    # Combine all busy times for each participant\n    schedules = {\n        'Carolyn': carolyn_busy,\n        'Mark': mark_busy,\n        'Thomas': thomas_busy,\n        'Hannah': hannah_busy,\n        'Abigail': abigail_busy\n    }\n    \n    # Check for a valid time slot\n    for start in range(work_start, work_end - meeting_duration + 1, 15):  # Check every 15 minutes\n        end = start + meeting_duration\n        valid = True\n        \n        # Check against each person's schedule\n        for person, busy_times in schedules.items():\n            for busy_start, busy_end in busy_times:\n                if not (end <= busy_start or start >= busy_end):\n                    valid = False\n                    break\n            if not valid:\n                break\n        \n        if valid:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = end // 60\n            end_mm = end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No valid time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_297"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes, work_start, work_end):\n    # Convert time strings to minutes since start of day\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            all_busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between merged intervals and work hours\n    available_slots = []\n    previous_end = work_start_min\n    \n    for start, end in merged:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end_min:\n        available_slots.append((previous_end, work_end_min))\n    \n    # Check each available slot for sufficient duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_minutes:\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            \n            meeting_start = minutes_to_time(slot_start)\n            meeting_end = minutes_to_time(slot_start + duration_minutes)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"13:00 to 13:30\", \"14:00 to 14:30\"],  # Ryan\n    [],                                    # Randy\n    [],                                    # Diana\n    [\"9:00 to 10:30\", \"11:00 to 14:00\", \"14:30 to 15:00\", \"15:30 to 16:30\"],  # Stephanie\n    [\"9:00 to 9:30\", \"10:00 to 11:30\", \"13:00 to 14:00\", \"14:30 to 16:30\"],   # Doris\n]\n\n# Find a 30-minute meeting between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, 30, \"9:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_298"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_start, work_end):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start_min\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n    \n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"9:00 to 9:30\", \"10:30 to 11:30\", \"12:00 to 12:30\", \"13:00 to 13:30\", \"16:30 to 17:00\"],  # Jacqueline\n    [\"10:00 to 11:00\", \"11:30 to 12:30\", \"13:30 to 14:00\", \"15:30 to 16:00\"],  # Lauren\n    [],  # Billy\n    [\"9:30 to 10:30\", \"11:30 to 14:30\", \"15:00 to 16:00\"],  # Mark\n    [\"9:00 to 9:30\", \"10:30 to 11:30\", \"12:00 to 14:00\", \"14:30 to 15:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"],  # Teresa\n]\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, 30, \"9:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_299"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m - 540  # Subtract 540 to start from 0 (9:00)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        h = (minutes + 540) // 60\n        m = (minutes + 540) % 60\n        return f\"{h:02d}:{m:02d}\"\n    \n    start_min = time_to_minutes(work_hours[0])\n    end_min = time_to_minutes(work_hours[1])\n    \n    # Create a list of all busy intervals in minutes\n    all_busy = []\n    for busy_list in participants_busy.values():\n        for interval in busy_list:\n            start = time_to_minutes(interval[0])\n            end = time_to_minutes(interval[1])\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots\n    available = []\n    prev_end = start_min\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < end_min:\n        available.append((prev_end, end_min))\n    \n    # Find the first available slot that can fit the duration\n    for slot in available:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            meeting_start = minutes_to_time(slot_start)\n            meeting_end = minutes_to_time(slot_start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No available slot found\"\n\n# Define work hours and duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 30  # minutes\n\n# Define participants' busy times\nparticipants_busy = {\n    \"Eric\": [(\"10:00\", \"10:30\"), (\"12:30\", \"13:00\")],\n    \"Jeremy\": [(\"11:00\", \"12:00\"), (\"12:30\", \"13:00\"), (\"15:00\", \"15:30\")],\n    \"Joe\": [],\n    \"Brian\": [(\"9:00\", \"10:30\"), (\"11:00\", \"13:00\"), (\"13:30\", \"14:00\"), (\"14:30\", \"16:00\"), (\"16:30\", \"17:00\")],\n    \"Brittany\": [(\"9:00\", \"9:30\"), (\"10:30\", \"12:00\"), (\"13:30\", \"14:30\"), (\"15:00\", \"15:30\"), (\"16:30\", \"17:00\")],\n    \"Julia\": [(\"9:00\", \"11:00\"), (\"12:30\", \"13:00\"), (\"13:30\", \"15:00\"), (\"16:00\", \"17:00\")],\n}\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_300"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:11:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # 9:00 is 540 minutes\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    start_work, end_work = work_hours\n    start_min = time_to_minutes(start_work)\n    end_min = time_to_minutes(end_work)\n    duration_min = duration * 60\n\n    # Create a list of all busy intervals for all participants\n    all_busy = []\n    for busy_list in participants_busy.values():\n        for busy in busy_list:\n            start, end = busy\n            all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n\n    # Find available slots by merging all busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1] = (last_start, max(end, last_end))\n            else:\n                merged.append((start, end))\n\n    # Check the available slots before the first busy interval, between them, and after the last\n    available = []\n    prev_end = start_min\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < end_min:\n        available.append((prev_end, end_min))\n\n    # Find the first available slot that can fit the meeting\n    for slot in available:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No available slot found\"\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 0.5  # half an hour\n\n# Define each participant's busy times\nparticipants_busy = {\n    \"Amy\": [(\"13:00\", \"13:30\"), (\"15:30\", \"16:00\")],\n    \"Jonathan\": [(\"9:00\", \"9:30\"), (\"10:00\", \"10:30\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:00\")],\n    \"Brittany\": [(\"9:30\", \"10:00\"), (\"16:30\", \"17:00\")],\n    \"Matthew\": [(\"9:00\", \"10:00\"), (\"12:30\", \"14:30\"), (\"15:00\", \"15:30\"), (\"16:00\", \"16:30\")],\n    \"Catherine\": [(\"9:00\", \"10:30\"), (\"12:00\", \"14:00\"), (\"16:30\", \"17:00\")],\n    \"Carl\": [(\"10:00\", \"11:00\"), (\"11:30\", \"12:30\"), (\"13:00\", \"14:00\"), (\"14:30\", \"16:30\")],\n}\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_301"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Convert all schedules to minutes for easier comparison\n    # Each person's busy times in minutes (start, end)\n    schedules = {\n        'Nicole': [(10 * 60, 10 * 60 + 30), (14 * 60 + 30, 15 * 60)],\n        'Christine': [(11 * 60, 11 * 60 + 30), (12 * 60 + 30, 13 * 60)],\n        'Anna': [(9 * 60 + 30, 10 * 60 + 30), (11 * 60, 11 * 60 + 30), \n                 (12 * 60 + 30, 13 * 60), (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Terry': [(9 * 60 + 30, 11 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60, 15 * 60 + 30)],\n        'Julie': [(10 * 60, 12 * 60), (12 * 60 + 30, 13 * 60 + 30), (14 * 60, 15 * 60)],\n        'Abigail': [(9 * 60, 10 * 60), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 14 * 60), \n                    (14 * 60 + 30, 15 * 60), (16 * 60 + 30, 17 * 60)]\n    }\n    \n    # Anna's preference: not before 14:00\n    anna_preference_start = 14 * 60\n    \n    # Find all possible slots that are free for everyone\n    possible_slots = []\n    current_time = max(work_start, anna_preference_start)\n    meeting_duration = 30\n    \n    while current_time + meeting_duration <= work_end:\n        slot_valid = True\n        slot_start = current_time\n        slot_end = current_time + meeting_duration\n        \n        # Check for each person if the slot is free\n        for person, busy_slots in schedules.items():\n            for busy_start, busy_end in busy_slots:\n                if not (slot_end <= busy_start or slot_start >= busy_end):\n                    slot_valid = False\n                    break\n            if not slot_valid:\n                break\n        \n        if slot_valid:\n            possible_slots.append((slot_start, slot_end))\n        \n        current_time += 15  # Check in 15-minute increments\n    \n    if not possible_slots:\n        return \"No available slot found\"\n    \n    # Select the earliest possible slot\n    chosen_slot = possible_slots[0]\n    start_h = chosen_slot[0] // 60\n    start_m = chosen_slot[0] % 60\n    end_h = chosen_slot[1] // 60\n    end_m = chosen_slot[1] % 60\n    \n    return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_302"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each participant's busy slots to minutes\n    theresa_busy = [(9*60 + 30, 10*60 + 30), (15*60, 16*60)]\n    alexander_busy = [(12*60, 12*60 + 30), (13*60 + 30, 14*60)]\n    lisa_busy = [(10*60 + 30, 12*60 + 30), (13*60 + 30, 14*60 + 30), (16*60, 17*60)]\n    natalie_busy = [(9*60, 9*60 + 30), (11*60, 12*60 + 30), (13*60 + 30, 15*60 + 30), (16*60, 17*60)]\n    victoria_busy = [(9*60 + 30, 10*60 + 30), (11*60, 12*60 + 30), (13*60 + 30, 14*60 + 30), (15*60, 16*60 + 30)]\n    \n    # Virginia is free all day, so no busy slots\n    \n    # Combine all busy slots\n    all_busy = theresa_busy + alexander_busy + lisa_busy + natalie_busy + victoria_busy\n    \n    # Sort busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Check each free slot for a 30-minute window\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_303"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    # Christine: 9:30-10:30, 12:00-12:30, 13:00-13:30, 14:30-15:00, 16:00-16:30\n    christine_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    # Janice: wide open (no busy slots)\n    janice_busy = []\n    \n    # Bobby: 12:00-12:30, 14:30-15:00\n    bobby_busy = [\n        (12 * 60, 12 * 60 + 30),\n        (14 * 60 + 30, 15 * 60)\n    ]\n    \n    # Elizabeth: 9:00-9:30, 11:30-13:00, 13:30-14:00, 15:00-15:30, 16:00-17:00\n    elizabeth_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (11 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n    \n    # Tyler: 9:00-11:00, 12:00-12:30, 13:00-13:30, 15:30-16:00, 16:30-17:00\n    tyler_busy = [\n        (9 * 60, 11 * 60),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Edward: 9:00-9:30, 10:00-11:00, 11:30-14:00, 14:30-15:30, 16:00-17:00\n    edward_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 11 * 60),\n        (11 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n    \n    # Janice prefers not to meet after 13:00\n    janice_preference_end = 13 * 60\n    \n    # Combine all busy slots for all participants\n    all_busy = christine_busy + janice_busy + bobby_busy + elizabeth_busy + tyler_busy + edward_busy\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    # Check the time after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that fits the meeting duration and Janice's preference\n    for slot_start, slot_end in free_slots:\n        if slot_end > slot_start + meeting_duration:\n            actual_start = slot_start\n            actual_end = actual_start + meeting_duration\n            # Check if the slot is before Janice's preference end time\n            if actual_end <= janice_preference_end:\n                # Format the time as HH:MM:HH:MM\n                start_hh = actual_start // 60\n                start_mm = actual_start % 60\n                end_hh = actual_end // 60\n                end_mm = actual_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    # If no slot before Janice's preference, look for any slot (though problem states solution exists)\n    for slot_start, slot_end in free_slots:\n        if slot_end > slot_start + meeting_duration:\n            actual_start = slot_start\n            actual_end = actual_start + meeting_duration\n            start_hh = actual_start // 60\n            start_mm = actual_start % 60\n            end_hh = actual_end // 60\n            end_mm = actual_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_304"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Convert each participant's busy slots to minutes\n    ethan_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 12 * 60 + 30),\n        (13 * 60 + 30, 15 * 60)\n    ]\n    \n    beverly_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (13 * 60 + 30, 15 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    deborah_busy = [\n        (9 * 60, 11 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60 + 30),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n    \n    # Diane, Helen, and Arthur have no meetings, but Diane prefers before 15:30\n    diane_preference = 15 * 60 + 30\n    \n    # Combine all busy times and sort them\n    all_busy = ethan_busy + beverly_busy + deborah_busy\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Check each free slot for availability and duration (30 minutes)\n    meeting_duration = 30\n    valid_slots = []\n    \n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            slot_start = start\n            slot_end = start + meeting_duration\n            # Check if it fits within the slot and Diane's preference\n            while slot_end <= end:\n                if slot_end <= diane_preference:\n                    valid_slots.append((slot_start, slot_end))\n                slot_start += 1\n                slot_end += 1\n                # Early exit if slot is too small\n                if slot_end > end:\n                    break\n    \n    # Select the earliest valid slot\n    if valid_slots:\n        valid_slots.sort()\n        best_start, best_end = valid_slots[0]\n    else:\n        return None\n    \n    # Convert back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_time = minutes_to_time(best_start)\n    end_time = minutes_to_time(best_end)\n    \n    return f\"{start_time}:{end_time}\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_305"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time strings to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        person_busy = []\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            person_busy.append((start, end))\n        busy_intervals.append(person_busy)\n    \n    # Find all possible meeting start times in the work hours, checking every minute\n    for start in range(work_start, work_end - duration + 1):\n        end = start + duration\n        valid = True\n        # Check if this slot is free for all participants\n        for person_busy in busy_intervals:\n            person_free = True\n            for busy_start, busy_end in person_busy:\n                if not (end <= busy_start or start >= busy_end):\n                    person_free = False\n                    break\n            if not person_free:\n                valid = False\n                break\n        if valid:\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            start_time = minutes_to_time(start)\n            end_time = minutes_to_time(end)\n            return f\"{start_time}:{end_time}\"\n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"09:30:10:00\", \"11:00:12:30\", \"14:30:15:00\", \"16:30:17:00\"],  # Donald\n    [\"09:00:09:30\", \"10:30:11:30\", \"12:00:12:30\", \"13:00:14:00\"],  # Zachary\n    [],  # Kathryn\n    [\"09:00:09:30\", \"10:00:10:30\", \"11:30:12:00\", \"13:00:13:30\", \"14:00:17:00\"],  # Deborah\n    [\"09:00:09:30\", \"10:00:11:00\", \"11:30:12:30\", \"14:00:14:30\", \"15:00:16:00\"],  # Teresa\n    [\"09:30:10:30\", \"11:00:12:30\", \"13:00:14:00\", \"14:30:17:00\"],  # James\n]\n\n# Find a 30-minute meeting between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules=participants_schedules,\n                                 work_hours_start=\"09:00\",\n                                 work_hours_end=\"17:00\",\n                                 duration_minutes=30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_306"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time slots to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n\n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_intervals.append((start, end))\n\n    # Sort the busy intervals by start time\n    busy_intervals.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find available slots by looking at gaps between merged busy intervals\n    available_slots = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Find the first available slot that can fit the meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No available slot found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [],  # Ronald's calendar is wide open\n    [\"10:00:10:30\", \"12:00:12:30\"],  # Stephen\n    [\"11:00:11:30\", \"13:30:14:00\", \"15:30:16:00\", \"16:30:17:00\"],  # Brittany\n    [\"9:00:9:30\", \"10:00:10:30\", \"11:00:12:30\", \"13:00:15:00\", \"15:30:17:00\"],  # Dorothy\n    [\"9:30:10:30\", \"11:00:11:30\", \"12:00:12:30\", \"13:00:17:00\"],  # Rebecca\n    [\"9:00:9:30\", \"10:00:11:00\", \"11:30:12:00\", \"13:00:15:00\", \"15:30:16:30\"],  # Jordan\n]\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, \"9:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_307"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find all free intervals by merging busy intervals\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Find free intervals by checking gaps between merged busy intervals and work hours\n    free_intervals = []\n    previous_end = work_start\n    for start, end in merged_busy:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_intervals.append((previous_end, work_end))\n    \n    # Check each free interval for availability of all participants\n    for free_start, free_end in free_intervals:\n        if free_end - free_start >= meeting_duration:\n            # Check if this interval is free for all participants\n            valid = True\n            for schedule in participants_schedules:\n                participant_free = True\n                for busy in schedule:\n                    busy_start, busy_end = map(time_to_minutes, busy.split(' to '))\n                    # Check if free interval overlaps with any busy interval\n                    if not (free_end <= busy_start or free_start >= busy_end):\n                        participant_free = False\n                        break\n                if not participant_free:\n                    valid = False\n                    break\n            if valid:\n                meeting_start = minutes_to_time(free_start)\n                meeting_end = minutes_to_time(free_start + meeting_duration)\n                return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"10:00 to 10:30\", \"12:30 to 13:00\"],  # Adam\n    [\"12:30 to 13:00\", \"14:00 to 14:30\"],  # Frances\n    [\"10:30 to 11:00\", \"12:30 to 13:30\", \"16:00 to 16:30\"],  # Natalie\n    [\"10:30 to 11:00\", \"12:00 to 14:00\", \"14:30 to 16:00\"],  # Patrick\n    [\"9:00 to 10:00\", \"10:30 to 11:30\", \"12:00 to 13:00\", \"14:00 to 15:30\", \"16:00 to 16:30\"],  # Willie\n    [\"9:00 to 10:30\", \"11:00 to 16:30\"],  # Diana\n]\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 30  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration))\n```",
            "count": "calendar_scheduling_example_308"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Each participant's busy slots in minutes (start, end)\n    busy_slots = {\n        'Nicholas': [],\n        'Emma': [],\n        'Catherine': [(9*60, 9*60+30), (11*60+30, 12*60), (13*60+30, 14*60), (15*60+30, 16*60)],\n        'Steven': [(9*60, 9*60+30), (10*60, 16*60+30)],\n        'Adam': [(9*60, 10*60), (10*60+30, 13*60), (13*60+30, 14*60), (14*60+30, 16*60+30)],\n        'Lori': [(9*60, 11*60+30), (12*60+30, 13*60+30), (16*60, 16*60+30)],\n    }\n\n    # Collect all busy slots\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n\n    # Sort busy slots by start time\n    all_busy.sort()\n\n    # Merge overlapping or adjacent busy slots\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n    for start, end in merged_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_309"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Convert each participant's busy slots to minutes\n    helen_busy = [(12*60, 12*60+30), (15*60+30, 16*60)]\n    sophia_busy = [(11*60+30, 12*60), (13*60, 13*60+30), (15*60, 16*60)]\n    anthony_busy = [(9*60, 9*60+30), (10*60+30, 11*60+30), (12*60, 12*60+30), (15*60+30, 16*60+30)]\n    hannah_busy = [(9*60, 11*60), (12*60, 13*60+30), (14*60, 14*60+30), (15*60, 17*60)]\n    donna_busy = [(9*60, 9*60+30), (10*60, 10*60+30), (11*60, 13*60), (15*60, 17*60)]\n    brittany_busy = [(9*60+30, 10*60), (10*60+30, 12*60+30), (13*60, 14*60), (15*60+30, 16*60)]\n    \n    # Combine all busy slots\n    all_busy = helen_busy + sophia_busy + anthony_busy + hannah_busy + donna_busy + brittany_busy\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can accommodate 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert start time back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_time = start + meeting_duration\n            end_hh = end_time // 60\n            end_mm = end_time % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_310"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:30:12:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration_minutes):\n    # Convert work hours and schedules to minutes for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Initialize the list of busy intervals\n    busy_intervals = []\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        for start, end in schedule:\n            busy_intervals.append((start * 60, end * 60))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append(interval)\n    \n    # Find available slots by checking gaps between merged intervals and work hours\n    available_slots = []\n    previous_end = work_start\n    \n    for start, end in merged:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the time after the last busy interval until work_end\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Find the first available slot that can fit the meeting duration\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to hours and minutes\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time slot found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (9, 17)\n\n# Define meeting duration (30 minutes)\nduration_minutes = 30\n\n# Define participants' schedules in their local time (converted to 24-hour format)\nparticipants_schedules = [\n    [],  # Zachary - open\n    [],  # Douglas - open\n    [],  # Adam - open\n    [(9, 9.5), (10.5, 11.5), (12, 14), (14.5, 15), (15.5, 16.5)],  # Mark\n    [(9, 9.5), (10, 11.5), (12, 17)],  # Ashley\n    [(9.5, 10.5), (12, 12.5), (13.5, 14.5), (15, 15.5), (16, 17)]   # Jennifer\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_311"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time slots to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the busy slots for all participants\n    busy_slots = []\n    for schedule in participants_schedules:\n        person_busy = []\n        for slot in schedule:\n            start, end = map(time_to_minutes, slot.split(' to '))\n            person_busy.append((start, end))\n        busy_slots.append(person_busy)\n    \n    # Find all possible free slots for each participant\n    free_slots_per_person = []\n    for person_busy in busy_slots:\n        person_free = []\n        prev_end = work_start\n        for start, end in sorted(person_busy, key=lambda x: x[0]):\n            if start > prev_end:\n                person_free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            person_free.append((prev_end, work_end))\n        free_slots_per_person.append(person_free)\n    \n    # Find intersection of all free slots\n    common_free_slots = free_slots_per_person[0]\n    for person_free in free_slots_per_person[1:]:\n        new_common = []\n        i = j = 0\n        while i < len(common_free_slots) and j < len(person_free):\n            slot1_start, slot1_end = common_free_slots[i]\n            slot2_start, slot2_end = person_free[j]\n            \n            overlap_start = max(slot1_start, slot2_start)\n            overlap_end = min(slot1_end, slot2_end)\n            \n            if overlap_start < overlap_end:\n                new_common.append((overlap_start, overlap_end))\n            \n            if slot1_end < slot2_end:\n                i += 1\n            else:\n                j += 1\n        common_free_slots = new_common\n    \n    # Find the first slot that can fit the meeting duration\n    duration = duration_minutes\n    for slot_start, slot_end in common_free_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"10:30 to 11:30\", \"12:00 to 12:30\", \"15:30 to 16:00\"],  # Samantha\n    [\"14:00 to 14:30\", \"15:30 to 16:00\"],                   # Jerry\n    [],                                                      # Walter\n    [\"9:30 to 11:30\", \"12:00 to 12:30\", \"13:00 to 13:30\", \"14:30 to 15:00\", \"16:30 to 17:00\"],  # Sara\n    [\"9:00 to 13:00\", \"14:00 to 15:00\", \"16:00 to 17:00\"],  # Kenneth\n    [\"9:30 to 10:00\", \"10:30 to 11:30\", \"12:00 to 12:30\", \"13:00 to 13:30\", \"14:00 to 16:00\", \"16:30 to 17:00\"],  # Danielle\n]\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, \"9:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_312"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for schedule in participants_schedules:\n        busy_intervals = []\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n        all_busy_intervals.append(busy_intervals)\n    \n    # Find all possible meeting start times in the work hours\n    possible_starts = []\n    current_time = work_start\n    \n    while current_time + duration <= work_end:\n        valid = True\n        for busy_intervals in all_busy_intervals:\n            for start, end in busy_intervals:\n                if not (current_time + duration <= start or current_time >= end):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            possible_starts.append(current_time)\n        current_time += 15  # Check every 15 minutes for efficiency\n    \n    if not possible_starts:\n        return None\n    \n    # Select the earliest possible start time\n    meeting_start = possible_starts[0]\n    meeting_end = meeting_start + duration\n    \n    return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"10:00 to 10:30\", \"15:30 to 16:00\"],  # Carl\n    [\"09:30 to 10:30\", \"12:00 to 12:30\", \"14:00 to 15:30\"],  # Shirley\n    [\"09:00 to 10:30\", \"11:30 to 12:00\"],  # Timothy\n    [\"09:00 to 11:30\", \"12:00 to 13:00\", \"13:30 to 14:00\", \"14:30 to 16:30\"],  # Marilyn\n    [\"09:00 to 10:30\", \"13:00 to 15:00\", \"15:30 to 16:00\"],  # Martha\n    [\"09:00 to 11:00\", \"12:00 to 15:00\", \"15:30 to 16:30\"],  # Samantha\n]\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, \"09:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_313"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes, work_start, work_end):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start_min = time_to_minutes(busy[0])\n            end_min = time_to_minutes(busy[1])\n            all_busy.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    previous_end = work_start_min\n    \n    for start, end in merged_busy:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the time after the last busy interval until work end\n    if previous_end < work_end_min:\n        available_slots.append((previous_end, work_end_min))\n    \n    # Find the first available slot that can fit the meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules in HH:MM format\nparticipants_schedules = [\n    [],  # Lori\n    [],  # Kelly\n    [(\"10:00\", \"10:30\"), (\"11:30\", \"12:00\"), (\"15:30\", \"16:00\"), (\"16:30\", \"17:00\")],  # Tyler\n    [(\"09:00\", \"12:00\"), (\"12:30\", \"13:00\"), (\"13:30\", \"14:30\"), (\"15:00\", \"15:30\"), (\"16:00\", \"17:00\")],  # Julie\n    [(\"09:00\", \"13:00\"), (\"13:30\", \"15:30\"), (\"16:00\", \"17:00\")],  # Andrea\n    [(\"09:00\", \"12:30\"), (\"13:30\", \"17:00\")],  # Gabriel\n]\n\n# Meeting duration in minutes\nduration_minutes = 30\n\n# Work hours\nwork_start = \"09:00\"\nwork_end = \"17:00\"\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, duration_minutes, work_start, work_end))\n```",
            "count": "calendar_scheduling_example_314"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_start=\"09:00\", work_end=\"17:00\"):\n    # Convert time strings to minutes since 9:00 for easier calculation\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m - 9 * 60  # Subtract 9:00 to start from 0\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Initialize a list to mark busy intervals\n    busy_intervals = []\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_end = max(end, last_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find the first available slot of at least duration_minutes\n    prev_end = work_start_min\n    for start, end in merged:\n        if start - prev_end >= duration_minutes:\n            # Found a slot\n            meeting_start = prev_end\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                total_h = 9 + minutes // 60\n                total_m = minutes % 60\n                return f\"{total_h:02d}:{total_m:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n        prev_end = max(prev_end, end)\n    \n    # Check after the last busy interval\n    if work_end_min - prev_end >= duration_minutes:\n        meeting_start = prev_end\n        meeting_end = meeting_start + duration_minutes\n        def minutes_to_time(minutes):\n            total_h = 9 + minutes // 60\n            total_m = minutes % 60\n            return f\"{total_h:02d}:{total_m:02d}\"\n        return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Gloria is free\n    [\"09:00 to 10:00\"],  # Roy\n    [\"09:00 to 09:30\", \"11:00 to 12:00\", \"16:30 to 17:00\"],  # Kimberly\n    [\"09:00 to 09:30\", \"10:00 to 11:00\", \"13:00 to 13:30\", \"14:00 to 15:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"],  # Robert\n    [\"09:00 to 09:30\", \"10:00 to 11:00\", \"11:30 to 12:30\", \"13:00 to 14:00\", \"14:30 to 15:00\"],  # Jesse\n    [\"09:00 to 12:00\", \"13:00 to 17:00\"],  # Sophia\n]\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules))\n```",
            "count": "calendar_scheduling_example_315"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_start=\"09:00\", work_end=\"17:00\"):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Initialize the available slots as the entire work day\n    available_slots = [(work_start_min, work_end_min)]\n    \n    # Process each participant's busy slots\n    for person, busy_slots in participants_schedules.items():\n        new_available_slots = []\n        for slot_start, slot_end in available_slots:\n            current_start = slot_start\n            # Sort busy slots by start time for this person\n            sorted_busy = sorted(busy_slots, key=lambda x: x[0])\n            for busy_start, busy_end in sorted_busy:\n                if busy_start >= slot_end:\n                    break\n                if busy_end <= current_start:\n                    continue\n                if busy_start > current_start:\n                    new_available_slots.append((current_start, busy_start))\n                current_start = max(current_start, busy_end)\n            if current_start < slot_end:\n                new_available_slots.append((current_start, slot_end))\n        available_slots = new_available_slots\n        if not available_slots:\n            return None  # No available slot\n    \n    # Find the first available slot that fits the duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    return None\n\n# Define the participants' busy slots in minutes since midnight\nparticipants_schedules = {\n    \"Brittany\": [(570, 600), (630, 660), (690, 720), (780, 810), (960, 1020)],\n    \"Gloria\": [(540, 570), (600, 630), (780, 810), (900, 930)],\n    \"Lisa\": [(750, 780), (810, 840)],\n    \"Paul\": [(540, 570), (660, 780), (810, 840), (900, 930), (990, 1020)],\n    \"Justin\": [(570, 780), (810, 840), (900, 1020)],\n    \"Diana\": [(540, 630), (660, 690), (720, 810), (840, 870), (900, 930), (990, 1020)],\n}\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_316"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    start, end = work_hours\n    # Convert time strings to minutes for easier calculation\n    start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n    end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n    \n    # Initialize the free slots for all participants\n    free_slots = []\n    for participant in participants_schedules:\n        busy_slots = participants_schedules[participant]\n        participant_free = []\n        prev_end = start_min\n        \n        for slot in sorted(busy_slots, key=lambda x: x[0]):\n            slot_start = slot[0][0] * 60 + slot[0][1]\n            slot_end = slot[1][0] * 60 + slot[1][1]\n            if prev_end < slot_start:\n                participant_free.append((prev_end, slot_start))\n            prev_end = max(prev_end, slot_end)\n        \n        if prev_end < end_min:\n            participant_free.append((prev_end, end_min))\n        free_slots.append(participant_free)\n    \n    # Find common free slots\n    common_free = free_slots[0]\n    for participant in free_slots[1:]:\n        temp_common = []\n        i = j = 0\n        while i < len(common_free) and j < len(participant):\n            start1, end1 = common_free[i]\n            start2, end2 = participant[j]\n            \n            overlap_start = max(start1, start2)\n            overlap_end = min(end1, end2)\n            \n            if overlap_start < overlap_end:\n                temp_common.append((overlap_start, overlap_end))\n            \n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free = temp_common\n    \n    # Find the first slot that can fit the duration\n    for slot in common_free:\n        if slot[1] - slot[0] >= duration:\n            meeting_start = slot[0]\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return None\n\n# Define the participants' schedules\nparticipants = {\n    \"Virginia\": [],\n    \"Kevin\": [\n        ((14, 30), (15, 00)),\n        ((15, 30), (16, 00))\n    ],\n    \"Kimberly\": [\n        ((9, 30), (10, 30)),\n        ((11, 30), (12, 00)),\n        ((12, 30), (13, 00)),\n        ((13, 30), (14, 00)),\n        ((15, 00), (15, 30))\n    ],\n    \"Lawrence\": [\n        ((10, 00), (10, 30)),\n        ((11, 00), (11, 30)),\n        ((12, 00), (12, 30)),\n        ((13, 00), (14, 00)),\n        ((14, 30), (15, 30)),\n        ((16, 00), (16, 30))\n    ],\n    \"Donna\": [\n        ((10, 00), (11, 00)),\n        ((12, 00), (15, 00)),\n        ((15, 30), (16, 00)),\n        ((16, 30), (17, 00))\n    ],\n    \"Joe\": [\n        ((9, 30), (10, 00)),\n        ((11, 30), (12, 30)),\n        ((13, 00), (13, 30)),\n        ((14, 30), (16, 00)),\n        ((16, 30), (17, 00))\n    ]\n}\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_hours = (\"9:00\", \"17:00\")\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants, duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_317"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    busy_slots = {\n        'Shirley': [(11 * 60, 12 * 60)],\n        'Carl': [],\n        'Bradley': [],\n        'Kevin': [(9 * 60, 12 * 60 + 30), (13 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Walter': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (11 * 60, 12 * 60),\n                   (12 * 60 + 30, 13 * 60), (14 * 60 + 30, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n        'Anna': [(9 * 60, 10 * 60), (11 * 60, 13 * 60), (14 * 60, 15 * 60)]\n    }\n\n    # Combine all busy slots from all participants\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n\n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for slot in free_slots:\n        start, end = slot\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_318"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:30:12:00}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_start, work_end):\n    # Convert time strings to minutes since 9:00 (work_start)\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m - work_start_min\n\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    total_duration = work_end_min - work_start_min\n    timeline = [0] * total_duration  # 0 means free, increment for each busy participant\n\n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            start = max(time_to_minutes(busy_start), 0)\n            end = min(time_to_minutes(busy_end), total_duration)\n            for i in range(start, end):\n                timeline[i] += 1\n\n    required_free = len(participants_schedules)\n    duration_slots = duration * 2  # assuming 30-minute slots for half-hour\n\n    current_free = 0\n    for i in range(total_duration):\n        if timeline[i] == 0:\n            current_free += 1\n        else:\n            current_free = 0\n        if current_free >= duration_slots:\n            start_time = i - duration_slots + 1\n            end_time = i + 1\n            # Convert back to HH:MM format\n            start_h = (work_start_min + start_time) // 60\n            start_m = (work_start_min + start_time) % 60\n            end_h = (work_start_min + end_time) // 60\n            end_m = (work_start_min + end_time) % 60\n            return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    return \"No suitable time found\"\n\n# Define participants' schedules in HH:MM format\nparticipants_schedules = [\n    [(\"14:30\", \"15:00\"), (\"16:00\", \"16:30\")],  # Natalie\n    [],                                         # Evelyn\n    [],                                         # Andrea\n    [(\"09:00\", \"10:00\"), (\"10:30\", \"11:30\"), (\"12:30\", \"13:30\"), (\"14:30\", \"15:30\")],  # Kimberly\n    [(\"09:00\", \"10:00\"), (\"11:00\", \"11:30\"), (\"12:00\", \"14:00\"), (\"14:30\", \"16:00\")],  # Dennis\n    [(\"09:00\", \"11:00\"), (\"12:00\", \"17:00\")]   # Larry\n]\n\nduration = 30  # minutes\nwork_start = \"09:00\"\nwork_end = \"17:00\"\n\nprint(find_meeting_time(participants_schedules, duration, work_start, work_end))\n```",
            "count": "calendar_scheduling_example_319"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each participant's busy slots to minutes\n    diane_busy = [(9*60, 9*60 + 30), (12*60 + 30, 13*60)]\n    christian_busy = [(11*60 + 30, 12*60), (12*60 + 30, 13*60)]\n    jeffrey_busy = []\n    vincent_busy = [(9*60 + 30, 10*60 + 30), (11*60 + 30, 13*60 + 30), (14*60 + 30, 15*60), (16*60 + 30, 17*60)]\n    ethan_busy = [(9*60, 11*60), (11*60 + 30, 12*60), (12*60 + 30, 13*60), (13*60 + 30, 14*60 + 30), (15*60, 17*60)]\n    christine_busy = [(9*60, 11*60), (11*60 + 30, 16*60 + 30)]\n    \n    # Combine all busy slots\n    all_busy = diane_busy + christian_busy + jeffrey_busy + vincent_busy + ethan_busy + christine_busy\n    \n    # Generate free slots by inverting busy slots\n    free_slots = []\n    previous_end = work_start\n    for start, end in sorted(all_busy):\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can accommodate 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_320"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define each participant's busy times in minutes (start, end)\n    grace_busy = [(10*60 + 30, 11*60 + 30), (12*60, 12*60 + 30), (15*60, 15*60 + 30)]\n    ralph_busy = [(11*60, 11*60 + 30), (16*60, 16*60 + 30)]\n    harold_busy = []\n    kayla_busy = [(10*60, 10*60 + 30), (11*60, 11*60 + 30), (12*60, 12*60 + 30), (13*60 + 30, 17*60)]\n    andrea_busy = [(9*60, 10*60 + 30), (11*60, 13*60), (13*60 + 30, 17*60)]\n    maria_busy = [(9*60, 10*60 + 30), (11*60, 13*60), (15*60, 16*60 + 30)]\n    \n    # Combine all busy times\n    all_busy = grace_busy + ralph_busy + harold_busy + kayla_busy + andrea_busy + maria_busy\n    \n    # Sort busy times by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = work_start\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    # Check the slot after the last busy time\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can accommodate 30 minutes\n    meeting_duration = 30\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Convert minutes back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = (slot_start + meeting_duration) // 60\n            end_mm = (slot_start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_321"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Convert each participant's busy slots to minutes\n    busy_slots = {\n        'Kathryn': [(9.5 * 60, 10 * 60), (12.5 * 60, 14 * 60)],\n        'Jessica': [],\n        'Ruth': [(12.5 * 60, 13 * 60), (14.5 * 60, 15 * 60)],\n        'Matthew': [(9 * 60, 10 * 60), (11.5 * 60, 13 * 60), (13.5 * 60, 15 * 60), (15.5 * 60, 16 * 60), (16.5 * 60, 17 * 60)],\n        'Jennifer': [(9 * 60, 9.5 * 60), (10 * 60, 10.5 * 60), (11.5 * 60, 12 * 60), (12.5 * 60, 13 * 60), (15 * 60, 17 * 60)],\n        'Alice': [(9 * 60, 10.5 * 60), (12 * 60, 12.5 * 60), (15 * 60, 17 * 60)],\n    }\n\n    # Combine all busy slots\n    all_busy = []\n    for person in busy_slots:\n        for start, end in busy_slots[person]:\n            all_busy.append((start, end))\n    \n    # Sort busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check each free slot for availability for all participants\n    meeting_duration = 60  # 1 hour\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Check if all participants are free during this slot\n            valid = True\n            for person in busy_slots:\n                person_busy = False\n                for busy_start, busy_end in busy_slots[person]:\n                    if not (slot_start >= busy_end or slot_start + meeting_duration <= busy_start):\n                        person_busy = True\n                        break\n                if person_busy:\n                    valid = False\n                    break\n            if valid:\n                # Convert minutes back to HH:MM format\n                start_hh = int(slot_start // 60)\n                start_mm = int(slot_start % 60)\n                end_hh = int((slot_start + meeting_duration) // 60)\n                end_mm = int((slot_start + meeting_duration) % 60)\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_322"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:00:16:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration_min = duration * 60\n\n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(':'))\n            busy_intervals.append((start, end))\n\n    # Sort intervals by start time\n    busy_intervals.sort()\n\n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Find the first slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No available time slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"14:00:14:30\", \"15:30:16:00\"],  # Ralph\n    [],                              # Kenneth\n    [\"09:00:10:30\", \"13:00:13:30\", \"15:00:15:30\", \"16:30:17:00\"],  # Diane\n    [\"10:00:11:00\", \"12:00:15:00\", \"15:30:16:00\", \"16:30:17:00\"],  # Kayla\n    [\"09:30:10:00\", \"10:30:11:30\", \"12:30:14:30\", \"16:30:17:00\"],  # Bruce\n    [\"10:00:11:00\", \"11:30:12:00\", \"12:30:13:30\", \"14:30:15:00\", \"15:30:16:00\", \"16:30:17:00\"]  # Jesse\n]\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, 30, \"09:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_323"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since midnight\n    busy_slots = {\n        'Jacob': [(9*60, 9*60+30), (10*60, 11*60), (12*60, 12*60+30), (13*60+30, 14*60), (16*60, 16*60+30)],\n        'Nancy': [(11*60, 11*60+30), (14*60+30, 16*60)],\n        'Lori': [(9*60, 9*60+30), (11*60, 11*60+30), (12*60, 12*60+30), (13*60+30, 14*60)],\n        'Ann': [(10*60, 13*60), (14*60+30, 16*60+30)],\n        'Pamela': [(9*60, 9*60+30), (10*60+30, 11*60+30), (12*60, 12*60+30), (13*60+30, 15*60), (15*60+30, 16*60)],\n        'Anna': [(9*60+30, 11*60+30), (12*60, 13*60), (13*60+30, 14*60+30), (15*60, 17*60)],\n    }\n\n    # Collect all busy slots\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n\n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check the slot after the last busy slot until work_end\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Now, find the earliest free slot that fits the meeting duration and is free for everyone\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Check if this slot is free for everyone\n            valid = True\n            for person in busy_slots:\n                person_busy = busy_slots[person]\n                for busy_start, busy_end in person_busy:\n                    if not (slot_start >= busy_end or slot_start + meeting_duration <= busy_start):\n                        # Overlap found, slot is not free for this person\n                        valid = False\n                        break\n                if not valid:\n                    break\n            if valid:\n                # Convert start time back to HH:MM format\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_time = slot_start + meeting_duration\n                end_hh = end_time // 60\n                end_mm = end_time % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_324"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy times in minutes (start, end)\n    busy_times = {\n        'Jose': [(11 * 60, 11 * 60 + 30), (12 * 60 + 30, 13 * 60)],\n        'Keith': [(14 * 60, 14 * 60 + 30), (15 * 60, 15 * 60 + 30)],\n        'Logan': [(9 * 60, 10 * 60), (12 * 60, 12 * 60 + 30), (15 * 60, 15 * 60 + 30)],\n        'Megan': [(9 * 60, 10 * 60 + 30), (11 * 60, 12 * 60), (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 16 * 60 + 30)],\n        'Gary': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (11 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 16 * 60 + 30)],\n        'Bobby': [(11 * 60, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (13 * 60, 16 * 60)],\n    }\n    \n    # Jose's constraint: not after 15:30\n    jose_constraint = 15 * 60 + 30\n    \n    # Collect all busy intervals\n    all_busy = []\n    for person in busy_times:\n        for start, end in busy_times[person]:\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals\n    all_busy.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Filter free intervals that are at least 30 minutes and meet Jose's constraint\n    possible_slots = []\n    for start, end in free_intervals:\n        if end - start >= 30 and end <= jose_constraint:\n            possible_slots.append((start, end))\n    \n    # Find the earliest possible slot\n    if possible_slots:\n        earliest_slot = possible_slots[0]\n        meeting_start = earliest_slot[0]\n        meeting_end = meeting_start + 30\n        # Format the output\n        start_hour = meeting_start // 60\n        start_min = meeting_start % 60\n        end_hour = meeting_end // 60\n        end_min = meeting_end % 60\n        return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n    else:\n        return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_325"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_start=9*60, work_end=17*60):\n    # Convert all schedules to minutes since midnight for easier comparison\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start_h, start_m = map(int, interval[0].split(':'))\n            end_h, end_m = map(int, interval[1].split(':'))\n            start = start_h * 60 + start_m\n            end = end_h * 60 + end_m\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between merged intervals\n    available_slots = []\n    previous_end = work_start\n    for start, end in merged:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            start_h = meeting_start // 60\n            start_m = meeting_start % 60\n            end_h = meeting_end // 60\n            end_m = meeting_end % 60\n            return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [(\"09:30\", \"10:00\"), (\"10:30\", \"11:30\"), (\"12:30\", \"13:00\"), (\"14:00\", \"14:30\"), (\"16:00\", \"16:30\")],  # Jason\n    [(\"09:00\", \"09:30\"), (\"10:00\", \"11:00\"), (\"15:30\", \"17:00\")],  # Anthony\n    [(\"11:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"15:00\", \"15:30\"), (\"16:00\", \"16:30\")],  # Joan\n    [(\"09:00\", \"11:00\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"13:30\", \"15:30\"), (\"16:00\", \"17:00\")],  # Elizabeth\n    [(\"09:00\", \"10:00\"), (\"11:00\", \"11:30\"), (\"12:30\", \"13:00\"), (\"13:30\", \"16:30\")],  # Ryan\n    [(\"09:30\", \"10:30\"), (\"11:00\", \"11:30\"), (\"12:00\", \"13:00\"), (\"13:30\", \"14:00\"), (\"14:30\", \"16:00\"), (\"16:30\", \"17:00\")]  # Jeffrey\n]\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules))\n```",
            "count": "calendar_scheduling_example_326"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours=('09:00', '17:00')):\n    # Convert work hours to minutes since midnight\n    start_work, end_work = work_hours\n    work_start = int(start_work.split(':')[0]) * 60 + int(start_work.split(':')[1])\n    work_end = int(end_work.split(':')[0]) * 60 + int(end_work.split(':')[1])\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    busy_intervals = []\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        for block in schedule:\n            start, end = block.split(' to ')\n            start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n            end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n            busy_intervals.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for a slot that can fit the meeting\n    for start, end in free_intervals:\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            # Format the time as HH:MM:HH:MM\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"11:00 to 11:30\", \"12:00 to 12:30\", \"14:00 to 16:00\"],  # Cynthia\n    [\"10:00 to 11:30\", \"12:30 to 13:00\", \"14:00 to 14:30\", \"15:30 to 16:00\"],  # Megan\n    [],  # Christopher\n    [\"09:00 to 11:30\", \"12:00 to 13:00\", \"13:30 to 17:00\"],  # Philip\n    [\"09:00 to 10:30\", \"11:00 to 11:30\", \"12:30 to 15:30\", \"16:00 to 17:00\"],  # Ryan\n    [\"09:30 to 10:30\", \"11:00 to 11:30\", \"12:00 to 13:00\", \"14:00 to 14:30\", \"15:00 to 17:00\"],  # Lauren\n]\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules))\n```",
            "count": "calendar_scheduling_example_327"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define each participant's busy times in minutes (start, end)\n    busy_times = {\n        'Diana': [(13 * 60 + 30, 14 * 60), (16 * 60 + 30, 17 * 60)],\n        'Timothy': [(9 * 60, 9 * 60 + 30), (12 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30)],\n        'Patrick': [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 11 * 60), (11 * 60 + 30, 12 * 60 + 30), (14 * 60 + 30, 15 * 60), (16 * 60, 16 * 60 + 30)],\n        'Janet': [(9 * 60 + 30, 10 * 60 + 30), (11 * 60, 12 * 60), (13 * 60, 13 * 60 + 30), (14 * 60, 16 * 60 + 30)],\n        'Megan': [(9 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60, 17 * 60)],\n        'Evelyn': [(9 * 60, 10 * 60 + 30), (11 * 60, 12 * 60 + 30), (13 * 60, 17 * 60)],\n    }\n\n    # Combine all busy times and sort them\n    all_busy = []\n    for person in busy_times:\n        all_busy.extend(busy_times[person])\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check the slot after the last busy time\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that is at least 30 minutes long\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = (start + meeting_duration) // 60\n            end_mm = (start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_328"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_work, end_work = work_hours\n    # Convert work hours to minutes\n    start_min = start_work[0] * 60 + start_work[1]\n    end_min = end_work[0] * 60 + end_work[1]\n    \n    # Initialize a list to track busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for block in schedule:\n            start_block = block[0][0] * 60 + block[0][1]\n            end_block = block[1][0] * 60 + block[1][1]\n            busy_intervals.append((start_block, end_block))\n    \n    # Sort all busy intervals\n    busy_intervals.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = start_min\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < end_min:\n        free_intervals.append((prev_end, end_min))\n    \n    # Check for a free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = (start + duration) // 60\n            end_mm = (start + duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules in HH:MM format converted to tuples of (HH, MM)\nparticipants_schedules = [\n    [((11, 0), (11, 30)), ((16, 0), (16, 30))],  # Anna\n    [((9, 0), (9, 30)), ((15, 30), (16, 0))],     # Samuel\n    [],                                            # Joshua\n    [((9, 0), (10, 30)), ((12, 30), (14, 0)), ((16, 0), (17, 0))],  # Eugene\n    [((9, 0), (12, 0)), ((12, 30), (15, 0)), ((15, 30), (17, 0))],  # Debra\n    [((9, 30), (10, 0)), ((10, 30), (11, 30)), ((12, 30), (13, 30)), ((14, 30), (17, 0))]  # Carolyn\n]\n\nwork_hours = ((9, 0), (17, 0))  # 9:00 to 17:00\nduration = 30  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_329"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, duration_minutes=30, work_start=9 * 60, work_end=17 * 60):\n    # Convert all busy times to minutes since start of day and flatten\n    busy_slots = []\n    for person in participants_busy:\n        for slot in person:\n            start_h, start_m = map(int, slot.split(' to ')[0].split(':'))\n            end_h, end_m = map(int, slot.split(' to ')[1].split(':'))\n            busy_slots.append((start_h * 60 + start_m, end_h * 60 + end_m))\n    \n    # Sort all busy slots by start time\n    busy_slots.sort()\n    \n    # Merge overlapping or adjacent busy slots\n    merged = []\n    for start, end in busy_slots:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find free slots between work hours and busy slots\n    free_slots = []\n    previous_end = work_start\n    for start, end in merged:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            start_h = meeting_start // 60\n            start_m = meeting_start % 60\n            end_h = meeting_end // 60\n            end_m = meeting_end % 60\n            return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    return \"No suitable time found\"\n\n# Define participants' busy times\nparticipants_busy = [\n    [\"10:30 to 11:00\", \"12:00 to 12:30\", \"14:00 to 15:00\"],  # Terry\n    [\"9:30 to 10:30\", \"11:30 to 12:00\", \"14:00 to 14:30\"],    # Gloria\n    [],                                                       # Julie\n    [\"9:00 to 12:00\", \"12:30 to 13:00\", \"14:00 to 14:30\"],    # Albert\n    [\"9:00 to 10:00\", \"10:30 to 12:00\", \"12:30 to 13:00\", \"13:30 to 16:00\", \"16:30 to 17:00\"],  # Logan\n    [\"9:30 to 11:00\", \"11:30 to 13:00\", \"14:30 to 15:30\"],    # Alexander\n]\n\n# Find the earliest meeting time\nprint(find_meeting_time(participants_busy))\n```",
            "count": "calendar_scheduling_example_330"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    # Parse work hours\n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n\n    # Initialize a list to track busy intervals for all participants\n    all_busy = []\n\n    # Process each participant's schedule\n    for schedule in participants_schedules.values():\n        for busy in schedule:\n            start, end = busy.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            all_busy.append((start_min, end_min))\n\n    # Sort all busy intervals by start time\n    all_busy.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find available slots\n    available = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n\n    # Find the first available slot that can fit the meeting\n    for slot in available:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No available slot found\"\n\n# Define participants and their schedules\nparticipants_schedules = {\n    \"Evelyn\": [],\n    \"Patrick\": [\"12:00 to 13:00\", \"15:00 to 15:30\", \"16:30 to 17:00\"],\n    \"Anthony\": [\"9:30 to 10:30\", \"12:00 to 13:00\", \"13:30 to 14:00\", \"16:30 to 17:00\"],\n    \"Aaron\": [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:30 to 12:00\", \"12:30 to 13:30\", \"14:30 to 15:30\", \"16:30 to 17:00\"],\n    \"Abigail\": [\"9:00 to 11:00\", \"11:30 to 12:00\", \"12:30 to 14:00\", \"14:30 to 16:00\", \"16:30 to 17:00\"],\n    \"Vincent\": [\"9:00 to 10:30\", \"11:30 to 12:00\", \"14:00 to 17:00\"],\n}\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_hours = \"9:00 to 17:00\"\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, duration, work_hours))\n```",
            "count": "calendar_scheduling_example_331"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:00:14:30}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 (9:00)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    start_work_min = time_to_minutes(start_work)\n    end_work_min = time_to_minutes(end_work)\n    \n    # Initialize a list to track busy intervals for all participants\n    all_busy = []\n    for busy_slots in participents_busy.values():\n        for slot in busy_slots:\n            start, end = slot.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            all_busy.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = start_work_min\n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < end_work_min:\n        free_intervals.append((prev_end, end_work_min))\n    \n    # Check each free interval for availability of duration\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' busy slots\nparticipants_busy = {\n    \"Pamela\": [\"9:30 to 10:00\", \"15:00 to 15:30\", \"16:00 to 17:00\"],\n    \"Sandra\": [],\n    \"Helen\": [],\n    \"Zachary\": [\"9:00 to 11:00\", \"11:30 to 12:00\", \"12:30 to 13:30\", \"15:30 to 17:00\"],\n    \"Janice\": [\"9:30 to 14:00\", \"14:30 to 17:00\"],\n    \"Paul\": [\"9:30 to 11:30\", \"12:00 to 12:30\", \"13:00 to 13:30\", \"15:00 to 17:00\"]\n}\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nmeeting_duration = 30  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, work_hours, meeting_duration))\n```",
            "count": "calendar_scheduling_example_332"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:00:16:30}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time slots to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's busy slots to find common free time\n    for person, busy_slots in participents_schedules.items():\n        person_busy = []\n        for slot in busy_slots:\n            start, end = map(time_to_minutes, slot.split(':'))\n            person_busy.append((start, end))\n        # Sort the busy slots by start time\n        person_busy.sort()\n        \n        # Merge overlapping or adjacent busy slots\n        merged_busy = []\n        for start, end in person_busy:\n            if not merged_busy:\n                merged_busy.append((start, end))\n            else:\n                last_start, last_end = merged_busy[-1]\n                if start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = last_start\n                    new_end = max(last_end, end)\n                    merged_busy[-1] = (new_start, new_end)\n                else:\n                    merged_busy.append((start, end))\n        \n        # Calculate the person's free slots within work hours\n        person_free = []\n        prev_end = work_start\n        for start, end in merged_busy:\n            if start > prev_end:\n                person_free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            person_free.append((prev_end, work_end))\n        \n        # Intersect the person's free slots with the current common free slots\n        new_free_slots = []\n        i = j = 0\n        while i < len(free_slots) and j < len(person_free):\n            slot_start, slot_end = free_slots[i]\n            person_start, person_end = person_free[j]\n            \n            # Find the overlap between the current common slot and person's slot\n            overlap_start = max(slot_start, person_start)\n            overlap_end = min(slot_end, person_end)\n            \n            if overlap_start < overlap_end:\n                new_free_slots.append((overlap_start, overlap_end))\n            \n            # Move the pointer which ends first\n            if slot_end < person_end:\n                i += 1\n            else:\n                j += 1\n        \n        free_slots = new_free_slots\n        if not free_slots:\n            return None  # No common free time\n    \n    # Check if any remaining free slot can fit the meeting\n    for start, end in free_slots:\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = start + duration_minutes\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return None\n\n# Define the participants' schedules\nparticipants_schedules = {\n    \"Debra\": [\"15:00:16:00\"],\n    \"Sean\": [\"9:00:9:30\", \"12:00:12:30\", \"13:00:14:00\", \"14:30:15:00\", \"16:30:17:00\"],\n    \"Randy\": [\"11:00:12:00\", \"13:00:14:00\", \"15:00:15:30\", \"16:30:17:00\"],\n    \"Gary\": [\"9:30:11:00\", \"11:30:13:00\", \"14:00:15:30\", \"16:30:17:00\"],\n    \"Joseph\": [\"9:00:9:30\", \"10:30:11:00\", \"11:30:12:00\", \"12:30:13:00\", \"13:30:14:00\", \"15:00:16:00\", \"16:30:17:00\"],\n    \"Christina\": [\"9:00:10:00\", \"10:30:12:30\", \"14:00:16:00\"],\n}\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, \"9:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_333"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:30:10:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the free slots for the day (work hours)\n    free_slots = [{'start': work_start, 'end': work_end}]\n    \n    # Process each participant's schedule to find common free slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_slots.append({'start': start, 'end': end})\n        \n        # Merge overlapping or adjacent busy slots\n        busy_slots.sort(key=lambda x: x['start'])\n        merged_busy = []\n        for slot in busy_slots:\n            if not merged_busy:\n                merged_busy.append(slot)\n            else:\n                last = merged_busy[-1]\n                if slot['start'] <= last['end']:\n                    last['end'] = max(last['end'], slot['end'])\n                else:\n                    merged_busy.append(slot)\n        \n        # Subtract busy slots from current free slots\n        new_free_slots = []\n        for free in free_slots:\n            current_start = free['start']\n            for busy in merged_busy:\n                if busy['start'] > current_start:\n                    new_free_slots.append({'start': current_start, 'end': busy['start']})\n                current_start = max(current_start, busy['end'])\n            if current_start < free['end']:\n                new_free_slots.append({'start': current_start, 'end': free['end']})\n        free_slots = new_free_slots\n    \n    # Find the earliest slot that fits the duration\n    for slot in free_slots:\n        if slot['end'] - slot['start'] >= duration:\n            return slot['start'], slot['start'] + duration\n    \n    return None\n\n# Participants' schedules in HH:MM format\nparticipants_schedules = [\n    [],  # Albert is free all day\n    [\"9:00:9:30\", \"10:00:11:00\", \"15:30:16:00\"],  # Laura\n    [\"10:00:11:00\", \"13:00:13:30\", \"16:00:16:30\"],  # Elijah\n    [\"9:00:9:30\", \"10:00:11:30\", \"12:30:13:00\", \"13:30:14:00\", \"16:00:17:00\"],  # Kenneth\n    [\"9:00:9:30\", \"10:00:11:00\", \"12:30:14:30\", \"15:00:16:00\", \"16:30:17:00\"],  # Adam\n    [\"10:00:11:30\", \"13:30:15:00\", \"16:00:17:00\"],  # Heather\n]\n\n# Meeting duration in minutes\nduration = 30\n\n# Work hours\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end)\n\n# Convert minutes back to HH:MM format\ndef minutes_to_time(minutes):\n    hh = minutes // 60\n    mm = minutes % 60\n    return f\"{hh:02d}:{mm:02d}\"\n\nif meeting_time:\n    start_time = minutes_to_time(meeting_time[0])\n    end_time = minutes_to_time(meeting_time[1])\n    print(f\"{start_time}:{end_time}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_334"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Now, find a free interval that is common to all participants\n    # To do this, we need to find the intersection of all participants' free times\n    # But since we've combined all busy times, the free_intervals already represent when at least one person is free\n    # So we need to find when all are free, i.e., when no one is busy\n    \n    # Instead, a better approach is to find the times when no one is busy\n    # We can collect all busy intervals and merge them, then find the gaps\n    \n    # Merge all busy intervals\n    merged_busy = []\n    for start, end in busy_intervals:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Now find the free intervals between merged busy times and work hours\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in merged_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"9:00 to 9:30\", \"10:30 to 11:00\", \"11:30 to 12:30\"],  # Stephanie\n    [\"11:00 to 12:30\", \"14:00 to 14:30\"],  # Henry\n    [\"9:30 to 10:30\", \"14:30 to 15:00\", \"15:30 to 16:00\"],  # Janice\n    [\"9:00 to 10:00\", \"10:30 to 12:00\", \"13:00 to 13:30\", \"14:00 to 15:00\"],  # Judy\n    [\"10:00 to 10:30\", \"12:00 to 13:30\", \"14:00 to 15:30\", \"16:00 to 16:30\"],  # Victoria\n    [\"9:00 to 10:30\", \"11:00 to 12:00\", \"12:30 to 15:30\", \"16:00 to 16:30\"],  # Joe\n]\n\n# Work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_335"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert each participant's busy slots to minutes\n    busy_slots = {\n        'Cheryl': [(12 * 60 + 30, 13 * 60), (16 * 60 + 30, 17 * 60)],\n        'Bryan': [(11 * 60 + 30, 12 * 60 + 30), (16 * 60, 17 * 60)],\n        'Joseph': [],\n        'Maria': [(9 * 60, 9 * 60 + 30), (10 * 60, 11 * 60 + 30),\n                  (12 * 60, 12 * 60 + 30), (14 * 60, 14 * 60 + 30),\n                  (15 * 60, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Elizabeth': [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60),\n                     (12 * 60 + 30, 13 * 60 + 30), (15 * 60, 16 * 60),\n                     (16 * 60 + 30, 17 * 60)],\n        'Kimberly': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30),\n                     (11 * 60, 12 * 60), (12 * 60 + 30, 13 * 60),\n                     (13 * 60 + 30, 14 * 60), (16 * 60, 17 * 60)]\n    }\n\n    # Collect all busy slots\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n\n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check each free slot for availability for all participants\n    for slot_start, slot_end in free_slots:\n        duration_needed = 30  # minutes\n        if slot_end - slot_start >= duration_needed:\n            # Check if all participants are free during this slot\n            valid = True\n            for person in busy_slots:\n                person_busy = busy_slots[person]\n                for busy_start, busy_end in person_busy:\n                    if not (slot_start >= busy_end or slot_start + duration_needed <= busy_start):\n                        # Overlap found, not free\n                        valid = False\n                        break\n                if not valid:\n                    break\n            if valid:\n                # Convert minutes back to HH:MM format\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_hh = (slot_start + duration_needed) // 60\n                end_mm = (slot_start + duration_needed) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_336"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:30:10:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert time strings to minutes since start of the day\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append(interval)\n    \n    # Find available slots\n    available_slots = []\n    previous_end = work_start\n    \n    for interval in merged:\n        start, end = interval\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot in available_slots:\n        start, end = slot\n        if end - start >= duration:\n            meeting_end = start + duration\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"11:30:12:00\", \"14:00:14:30\"],  # John\n    [\"12:00:12:30\", \"14:00:15:00\", \"15:30:16:00\"],  # Megan\n    [],  # Brandon\n    [\"9:00:9:30\", \"10:00:10:30\", \"11:00:14:30\", \"15:00:16:00\", \"16:30:17:00\"],  # Kimberly\n    [\"10:00:11:00\", \"11:30:14:00\", \"15:00:15:30\"],  # Sean\n    [\"9:00:9:30\", \"10:30:12:00\", \"13:00:14:30\", \"16:00:16:30\"],  # Lori\n]\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_337"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each person's busy slots to minutes\n    alexander_busy = [(12*60, 12*60+30), (14*60+30, 16*60)]\n    amy_busy = [(10*60, 10*60+30), (12*60, 12*60+30), (15*60+30, 16*60), (16*60+30, 17*60)]\n    christopher_busy = [(10*60+30, 11*60+30)]\n    kyle_busy = [(9*60+30, 10*60), (11*60+30, 12*60+30), (13*60, 14*60), (14*60+30, 15*60+30), (16*60, 16*60+30)]\n    jerry_busy = [(9*60+30, 11*60+30), (12*60, 12*60+30), (13*60+30, 14*60), (15*60, 16*60)]\n    raymond_busy = [(9*60, 9*60+30), (10*60, 10*60+30), (11*60, 12*60+30), (13*60, 15*60+30), (16*60, 17*60)]\n    \n    # Combine all busy slots\n    all_busy = alexander_busy + amy_busy + christopher_busy + kyle_busy + jerry_busy + raymond_busy\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check if there's a free slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can accommodate 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_338"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:11:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration):\n    # Convert all time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work_hours start at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = 9 + minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    start_work = time_to_minutes(work_hours[0])\n    end_work = time_to_minutes(work_hours[1])\n    duration_min = duration * 60\n\n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy_times in participants_busy_times:\n        for start, end in busy_times:\n            all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals\n    all_busy.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find available slots\n    available = []\n    prev_end = start_work\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < end_work:\n        available.append((prev_end, end_work))\n\n    # Find the first available slot that can fit the meeting\n    for start, end in available:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    return \"No available time slot found\"\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 0.5  # 0.5 hours = 30 minutes\n\n# Define each participant's busy times\nparticipants_busy_times = [\n    [],  # Zachary is free all day\n    [(\"9:00\", \"10:00\"), (\"11:30\", \"12:00\"), (\"14:30\", \"15:30\"), (\"16:00\", \"16:30\")],  # Kenneth\n    [(\"9:30\", \"10:00\"), (\"16:00\", \"16:30\")],  # Judy\n    [(\"9:00\", \"10:00\"), (\"10:30\", \"11:00\"), (\"11:30\", \"12:30\"), (\"13:30\", \"14:00\"), (\"14:30\", \"16:00\"), (\"16:30\", \"17:00\")],  # Jean\n    [(\"9:30\", \"10:30\"), (\"11:30\", \"14:30\"), (\"15:00\", \"16:00\")],  # Sean\n    [(\"9:00\", \"9:30\"), (\"10:30\", \"11:00\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:30\"), (\"14:00\", \"16:00\"), (\"16:30\", \"17:00\")],  # Alice\n]\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy_times, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_339"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_start=9*60, work_end=17*60):\n    # Convert work hours to minutes since midnight for easier calculation\n    work_start_min = work_start\n    work_end_min = work_end\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    all_busy_intervals = []\n    \n    # Collect all busy intervals from each participant\n    for schedule in participants_schedules:\n        all_busy_intervals.extend(schedule)\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_intervals = []\n    for interval in all_busy_intervals:\n        if not merged_intervals:\n            merged_intervals.append(interval)\n        else:\n            last_start, last_end = merged_intervals[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged_intervals[-1] = (new_start, new_end)\n            else:\n                merged_intervals.append(interval)\n    \n    # Find free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    previous_end = work_start_min\n    \n    for interval in merged_intervals:\n        start, end = interval\n        if start > previous_end:\n            # There's a free interval before this busy interval\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check if there's a free interval after the last busy interval\n    if previous_end < work_end_min:\n        free_intervals.append((previous_end, work_end_min))\n    \n    # Find the first free interval that can accommodate the meeting duration\n    for interval in free_intervals:\n        start, end = interval\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules in minutes since midnight\nparticipants_schedules = [\n    # Aaron's schedule\n    [(10*60 + 30, 12*60), (13*60, 13*60 + 30), (14*60 + 30, 15*60), (16*60 + 30, 17*60)],\n    # Frank's schedule\n    [(9*60, 9*60 + 30), (11*60, 11*60 + 30), (12*60, 12*60 + 30), (14*60 + 30, 15*60 + 30), (16*60 + 30, 17*60)],\n    # Diane's schedule\n    [(9*60, 10*60)],\n    # Dylan's schedule\n    [(9*60 + 30, 10*60 + 30), (12*60, 15*60), (15*60 + 30, 16*60), (16*60 + 30, 17*60)],\n    # Alexis's schedule\n    [(9*60, 9*60 + 30), (10*60 + 30, 11*60), (12*60 + 30, 13*60), (13*60 + 30, 15*60), (15*60 + 30, 16*60), (16*60 + 30, 17*60)],\n    # Mason's schedule\n    [(9*60, 10*60), (10*60 + 30, 11*60 + 30), (12*60 + 30, 14*60 + 30), (15*60, 15*60 + 30), (16*60 + 30, 17*60)],\n]\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules))\n```",
            "count": "calendar_scheduling_example_340"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:30:17:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all times to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between merged intervals and work hours\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Check each available slot for sufficient duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_minutes:\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            \n            meeting_start = minutes_to_time(slot_start)\n            meeting_end = minutes_to_time(slot_start + duration_minutes)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"09:30:11:00\", \"13:00:14:00\", \"15:00:15:30\"],  # Ruth\n    [\"10:00:10:30\", \"11:00:12:00\", \"12:30:13:30\", \"15:00:15:30\"],  # Aaron\n    [\"13:00:13:30\", \"14:30:15:00\"],  # Brittany\n    [\"09:00:10:30\", \"11:00:12:00\", \"13:00:16:30\"],  # Jeffrey\n    [\"09:00:16:00\"],  # Virginia\n    [\"09:00:12:30\", \"13:00:14:00\", \"14:30:15:00\", \"15:30:16:30\"],  # Peter\n]\n\n# Find a 30-minute meeting slot between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, \"09:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_341"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time slots to minutes since start of the day for easier calculation\n    work_start = work_hours_start * 60\n    work_end = work_hours_end * 60\n    duration = duration_minutes\n\n    # Initialize a list to keep track of busy intervals for all participants\n    busy_intervals = []\n\n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start_h, start_m, end_h, end_m = interval\n            start = start_h * 60 + start_m\n            end = end_h * 60 + end_m\n            busy_intervals.append((start, end))\n\n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find available slots by checking gaps between merged intervals and work hours\n    available_slots = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Find the first available slot that can fit the meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_h = meeting_start // 60\n            start_m = meeting_start % 60\n            end_h = meeting_end // 60\n            end_m = meeting_end % 60\n            return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n\n    return \"No available slot found\"\n\n# Define participants' schedules in HH:MM:HH:MM format (converted to tuples for processing)\nparticipants_schedules = [\n    [(10, 0, 10, 30), (16, 0, 16, 30)],  # Ryan\n    [],                                   # Brandon\n    [(11, 0, 11, 30), (15, 30, 16, 0)],  # Sandra\n    [(9, 0, 12, 0), (12, 30, 13, 0), (14, 0, 16, 30)],  # Jonathan\n    [(9, 30, 11, 0), (12, 0, 13, 0), (14, 0, 16, 30)],  # Elijah\n    [(9, 0, 10, 30), (11, 30, 13, 0), (14, 30, 16, 30)] # Justin\n]\n\n# Work hours and meeting duration\nwork_hours_start = 9\nwork_hours_end = 17\nmeeting_duration = 60\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_342"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:00:16:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_hour, end_hour = work_hours\n    start_time = start_hour * 60\n    end_time = end_hour * 60\n    duration_minutes = duration * 60\n    \n    # Initialize a list to represent each minute in the workday\n    time_slots = [True] * (end_time - start_time)\n    \n    # Mark busy times for each participant\n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            busy_start_min = busy_start[0] * 60 + busy_start[1]\n            busy_end_min = busy_end[0] * 60 + busy_end[1]\n            # Adjust to work hours\n            busy_start_min = max(busy_start_min, start_time)\n            busy_end_min = min(busy_end_min, end_time)\n            # Mark the busy slots as False\n            for i in range(busy_start_min - start_time, busy_end_min - start_time):\n                if i < len(time_slots):\n                    time_slots[i] = False\n    \n    # Find the first available slot of duration_minutes\n    current_slot_start = None\n    consecutive_free = 0\n    for i in range(len(time_slots)):\n        if time_slots[i]:\n            if current_slot_start is None:\n                current_slot_start = i\n            consecutive_free += 1\n            if consecutive_free >= duration_minutes:\n                meeting_start = current_slot_start + start_time\n                meeting_start_hour = meeting_start // 60\n                meeting_start_min = meeting_start % 60\n                meeting_end = meeting_start + duration_minutes\n                meeting_end_hour = meeting_end // 60\n                meeting_end_min = meeting_end % 60\n                return f\"{meeting_start_hour:02d}:{meeting_start_min:02d}:{meeting_end_hour:02d}:{meeting_end_min:02d}\"\n        else:\n            current_slot_start = None\n            consecutive_free = 0\n    return \"No available slot found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (9, 17)\n\n# Define meeting duration (0.5 hours)\nduration = 0.5\n\n# Define each participant's busy times in (HH, MM) format\nparticipants_schedules = [\n    # Benjamin\n    [\n        ((9, 0), (9, 30)),\n        ((10, 30), (11, 0)),\n        ((13, 0), (15, 0))\n    ],\n    # Beverly\n    [\n        ((10, 0), (10, 30)),\n        ((12, 30), (13, 0))\n    ],\n    # Willie - no busy times\n    [],\n    # Ethan\n    [\n        ((10, 0), (10, 30)),\n        ((11, 30), (15, 0)),\n        ((15, 30), (16, 0)),\n        ((16, 30), (17, 0))\n    ],\n    # Marie\n    [\n        ((9, 0), (10, 30)),\n        ((11, 30), (13, 0)),\n        ((13, 30), (14, 0)),\n        ((16, 30), (17, 0))\n    ],\n    # Sandra\n    [\n        ((9, 0), (9, 30)),\n        ((10, 0), (11, 30)),\n        ((12, 0), (12, 30)),\n        ((13, 0), (16, 0)),\n        ((16, 30), (17, 0))\n    ]\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_343"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:9:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = meeting_duration * 60\n    \n    # Collect all busy intervals for all participants\n    all_busy_intervals = []\n    for busy_times in participants_busy_times.values():\n        for interval in busy_times:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            all_busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_intervals = []\n    for start, end in all_busy_intervals:\n        if not merged_intervals:\n            merged_intervals.append([start, end])\n        else:\n            last_start, last_end = merged_intervals[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_intervals[-1] = [new_start, new_end]\n            else:\n                merged_intervals.append([start, end])\n    \n    # Check for available slots between work hours and busy intervals\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged_intervals:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' busy times\nparticipants_busy_times = {\n    \"Noah\": [\"11:00 to 12:00\", \"12:30 to 13:00\", \"14:30 to 15:30\", \"16:30 to 17:00\"],\n    \"Ralph\": [\"10:30 to 11:00\", \"12:00 to 12:30\", \"13:00 to 14:00\", \"14:30 to 15:00\", \"16:30 to 17:00\"],\n    \"Sean\": [\"13:00 to 13:30\", \"14:30 to 15:30\", \"16:30 to 17:00\"],\n    \"John\": [\"9:30 to 10:30\", \"11:00 to 11:30\", \"13:00 to 16:00\", \"16:30 to 17:00\"],\n    \"Harold\": [\"9:30 to 10:00\", \"11:30 to 12:30\", \"13:00 to 13:30\", \"14:00 to 15:30\", \"16:30 to 17:00\"],\n    \"Austin\": [\"10:00 to 11:00\", \"11:30 to 14:00\", \"14:30 to 17:00\"]\n}\n\n# Work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 0.5  # half an hour\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_344"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy times in minutes since midnight\n    dennis_busy = [\n        (9 * 60 + 30, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    \n    elijah_busy = [\n        (10 * 60 + 30, 12 * 60 + 30),\n        (14 * 60, 15 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    christian_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (13 * 60, 15 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Willie's constraint: not before 10:00\n    willie_constraint = 10 * 60\n    \n    # Combine all busy times\n    all_busy = dennis_busy + elijah_busy + christian_busy\n    all_busy.sort()  # Sort by start time\n    \n    # Find free slots by merging busy intervals\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Generate potential free slots\n    free_slots = []\n    previous_end = max(work_start, willie_constraint)\n    \n    for start, end in merged_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy interval\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that is at least 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Return the first suitable slot\n            start_time = start\n            end_time = start_time + meeting_duration\n            # Format as HH:MM:HH:MM\n            return f\"{start_time // 60:02d}:{start_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_345"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:30:17:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_start, work_end):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            all_busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_intervals = []\n    for start, end in all_busy_intervals:\n        if not merged_intervals:\n            merged_intervals.append([start, end])\n        else:\n            last_start, last_end = merged_intervals[-1]\n            if start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                merged_intervals[-1][1] = max(end, last_end)\n            else:\n                merged_intervals.append([start, end])\n    \n    # Find the earliest available slot\n    previous_end = work_start_min\n    for start, end in merged_intervals:\n        if start - previous_end >= duration_min:\n            # Found a suitable slot\n            meeting_start = previous_end\n            meeting_end = meeting_start + duration_min\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy interval\n    if work_end_min - previous_end >= duration_min:\n        meeting_start = previous_end\n        meeting_end = meeting_start + duration_min\n        def minutes_to_time(minutes):\n            hh = minutes // 60\n            mm = minutes % 60\n            return f\"{hh:02d}:{mm:02d}\"\n        return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return None\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"9:00:9:30\", \"10:30:11:00\", \"13:00:14:00\"],  # Walter\n    [\"13:30:14:00\", \"14:30:15:00\"],  # Jessica\n    [\"11:00:11:30\", \"14:00:15:00\", \"16:00:16:30\"],  # Robert\n    [\"9:00:9:30\", \"10:30:11:00\", \"11:30:13:00\", \"13:30:14:30\", \"16:00:16:30\"],  # Nicole\n    [\"9:30:11:30\", \"12:00:12:30\", \"15:00:16:30\"],  # Dorothy\n    [\"9:00:10:30\", \"11:00:12:30\", \"13:30:15:30\"],  # Gabriel\n]\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, 0.5, \"9:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_346"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:30:14:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals\n    busy_intervals = []\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules.values():\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort the busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    # Check the slot after the last busy interval\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    meeting_duration_min = meeting_duration * 60\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    'Albert': ['12:30 to 13:00', '14:00 to 14:30'],\n    'Jean': [],\n    'William': ['10:00 to 11:00', '12:30 to 13:00', '14:30 to 16:00'],\n    'Alan': ['9:30 to 10:00', '10:30 to 11:30', '12:00 to 13:30', '14:30 to 15:30', '16:00 to 17:00'],\n    'Donna': ['9:00 to 10:00', '12:00 to 13:30', '14:00 to 15:00', '16:30 to 17:00'],\n    'Christina': ['9:00 to 11:00', '11:30 to 12:00', '12:30 to 13:00', '16:00 to 17:00'],\n}\n\n# Define work hours and meeting duration\nwork_hours_start = '9:00'\nwork_hours_end = '17:00'\nmeeting_duration = 0.5  # in hours\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_347"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    anna_busy = [(10*60 + 30, 11*60), (12*60 + 30, 13*60), (15*60, 16*60)]\n    benjamin_busy = [(10*60, 10*60 + 30), (11*60, 11*60 + 30), (12*60 + 30, 13*60), (14*60, 14*60 + 30)]\n    noah_busy = [(9*60 + 30, 13*60 + 30), (14*60, 14*60 + 30), (15*60, 15*60 + 30), (16*60, 17*60)]\n    bruce_busy = [(9*60 + 30, 10*60 + 30), (11*60, 13*60), (13*60 + 30, 14*60), (14*60 + 30, 17*60)]\n    matthew_busy = [(9*60 + 30, 16*60 + 30)]\n\n    # Combine all busy slots\n    all_busy = []\n    all_busy.extend(anna_busy)\n    all_busy.extend(benjamin_busy)\n    all_busy.extend(noah_busy)\n    all_busy.extend(bruce_busy)\n    all_busy.extend(matthew_busy)\n\n    # Sort busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_348"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert work hours to minutes since midnight for easier calculation\n    start_time = work_hours_start * 60\n    end_time = work_hours_end * 60\n    duration = duration_minutes\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            all_busy_intervals.append((busy_start * 60, busy_end * 60))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_intervals = []\n    for interval in all_busy_intervals:\n        if not merged_intervals:\n            merged_intervals.append(interval)\n        else:\n            last_start, last_end = merged_intervals[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged_intervals[-1] = (new_start, new_end)\n            else:\n                merged_intervals.append(interval)\n    \n    # Find the earliest available slot\n    previous_end = start_time\n    for busy_start, busy_end in merged_intervals:\n        if busy_start - previous_end >= duration:\n            # Found a suitable slot\n            meeting_start = previous_end\n            meeting_end = meeting_start + duration\n            return (meeting_start // 60, meeting_start % 60, meeting_end // 60, meeting_end % 60)\n        previous_end = max(previous_end, busy_end)\n    \n    # Check the time after the last busy interval\n    if end_time - previous_end >= duration:\n        meeting_start = previous_end\n        meeting_end = meeting_start + duration\n        return (meeting_start // 60, meeting_start % 60, meeting_end // 60, meeting_end % 60)\n    \n    # No suitable slot found (though the problem states one exists)\n    return None\n\n# Define participants' schedules in minutes since midnight (converted from HH:MM)\nparticipants_schedules = [\n    [(10 * 60, 11 * 60 + 30), (15 * 60, 15 * 60 + 30)],  # Carl\n    [],  # Patricia\n    [(11 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60)],  # Madison\n    [(10 * 60, 12 * 60), (13 * 60, 13 * 60 + 30), (14 * 60, 15 * 60), (16 * 60, 16 * 60 + 30)],  # Gloria\n    [(9 * 60, 10 * 60), (11 * 60 + 30, 12 * 60), (13 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],  # Kenneth\n    [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (13 * 60, 14 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],  # Betty\n]\n\n# Work hours and meeting duration\nwork_hours_start = 9\nwork_hours_end = 17\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\n\n# Format the output as HH:MM:HH:MM\nif meeting_time:\n    start_hour, start_minute, end_hour, end_minute = meeting_time\n    print(f\"{start_hour:02d}:{start_minute:02d}:{end_hour:02d}:{end_minute:02d}\")\nelse:\n    print(\"No suitable time found\")\n```",
            "count": "calendar_scheduling_example_349"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:00:15:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time slots to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's schedule to find common free slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_slots.append((start, end))\n        # Sort the busy slots by start time\n        busy_slots.sort()\n        \n        # Merge overlapping or adjacent busy slots\n        merged_busy = []\n        for start, end in busy_slots:\n            if not merged_busy:\n                merged_busy.append((start, end))\n            else:\n                last_start, last_end = merged_busy[-1]\n                if start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged_busy[-1] = (new_start, new_end)\n                else:\n                    merged_busy.append((start, end))\n        \n        # Subtract busy slots from current free slots\n        new_free_slots = []\n        for free_start, free_end in free_slots:\n            current_start = free_start\n            for busy_start, busy_end in merged_busy:\n                if busy_end <= current_start:\n                    continue  # busy slot is before current free slot\n                if busy_start >= free_end:\n                    break    # busy slot is after current free slot\n                if busy_start > current_start:\n                    new_free_slots.append((current_start, busy_start))\n                current_start = max(current_start, busy_end)\n            if current_start < free_end:\n                new_free_slots.append((current_start, free_end))\n        free_slots = new_free_slots\n    \n    # Find the first free slot that can accommodate the meeting duration\n    duration = duration_minutes\n    for start, end in free_slots:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return (f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\")\n    \n    return None\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"9:00:9:30\", \"14:00:15:00\", \"15:30:16:00\"],  # Madison\n    [],                                            # Cheryl\n    [],                                            # Walter\n    [\"9:30:11:00\", \"11:30:15:00\", \"16:00:17:00\"], # Donna\n    [\"9:00:9:30\", \"10:00:10:30\", \"11:00:15:00\", \"15:30:16:00\", \"16:30:17:00\"],  # Kathleen\n    [\"9:30:12:30\", \"13:00:13:30\", \"15:30:17:00\"], # Samuel\n]\n\n# Find a meeting time\nmeeting_time = find_meeting_time(participants_schedules, \"9:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_350"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy_intervals = []\n    for schedule in participants_schedules:\n        participant_busy = []\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            participant_busy.append((start, end))\n        all_busy_intervals.append(participant_busy)\n    \n    # Find all free intervals for each participant\n    all_free_intervals = []\n    for participant in all_busy_intervals:\n        free = []\n        # Check before first busy interval\n        if participant and participant[0][0] > work_start:\n            free.append((work_start, participant[0][0]))\n        # Check between busy intervals\n        for i in range(1, len(participant)):\n            prev_end = participant[i-1][1]\n            curr_start = participant[i][0]\n            if curr_start > prev_end:\n                free.append((prev_end, curr_start))\n        # Check after last busy interval\n        if participant and participant[-1][1] < work_end:\n            free.append((participant[-1][1], work_end))\n        # If no busy intervals, the whole day is free\n        if not participant:\n            free.append((work_start, work_end))\n        all_free_intervals.append(free)\n    \n    # Find overlapping free intervals across all participants\n    # Start with the first participant's free intervals\n    overlapping_free = all_free_intervals[0]\n    for participant_free in all_free_intervals[1:]:\n        new_overlapping = []\n        for slot1 in overlapping_free:\n            for slot2 in participant_free:\n                # Find the overlap between slot1 and slot2\n                overlap_start = max(slot1[0], slot2[0])\n                overlap_end = min(slot1[1], slot2[1])\n                if overlap_start < overlap_end:\n                    new_overlapping.append((overlap_start, overlap_end))\n        overlapping_free = new_overlapping\n        if not overlapping_free:\n            break  # No possible slots\n    \n    # Find the first overlapping free slot that can fit the meeting\n    duration = duration_minutes\n    for slot in overlapping_free:\n        slot_duration = slot[1] - slot[0]\n        if slot_duration >= duration:\n            meeting_start = slot[0]\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\n# Define each participant's busy intervals\nparticipants_schedules = [\n    [\"9:00 to 10:30\", \"11:00 to 11:30\", \"12:30 to 13:00\", \"16:30 to 17:00\"],  # Andrew\n    [\"10:30 to 11:00\", \"15:30 to 16:00\"],  # Rebecca\n    [\"9:00 to 9:30\", \"15:30 to 16:00\"],  # Harold\n    [\"9:00 to 11:00\", \"11:30 to 13:00\", \"14:00 to 15:00\", \"15:30 to 17:00\"],  # Douglas\n    [\"9:00 to 11:30\", \"13:30 to 16:00\"],  # Jean\n    [\"9:30 to 10:30\", \"11:00 to 13:00\", \"13:30 to 16:30\"],  # Larry\n]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_351"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_hour, end_hour = work_hours\n    # Convert work hours to minutes for easier calculation\n    start_time = start_hour * 60\n    end_time = end_hour * 60\n    \n    # Initialize a list to keep track of busy times for all participants\n    busy_times = []\n    \n    for schedule in participants_schedules:\n        personal_busy = []\n        for block in schedule:\n            start_block = block[0] * 60\n            end_block = block[1] * 60\n            personal_busy.append((start_block, end_block))\n        busy_times.append(personal_busy)\n    \n    # Check every possible time slot within work hours\n    for current_time in range(start_time, end_time - duration + 1):\n        end_slot = current_time + duration\n        # Check if the time slot is free for all participants\n        all_free = True\n        for personal_busy in busy_times:\n            free = True\n            for (busy_start, busy_end) in personal_busy:\n                if not (end_slot <= busy_start or current_time >= busy_end):\n                    free = False\n                    break\n            if not free:\n                all_free = False\n                break\n        if all_free:\n            # Convert back to HH:MM format\n            start_hh = current_time // 60\n            start_mm = current_time % 60\n            end_hh = end_slot // 60\n            end_mm = end_slot % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No available time slot found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (9, 17)\n\n# Define meeting duration (30 minutes)\nduration = 30\n\n# Define participants' schedules in 24-hour format (HH:MM to HH:MM)\nparticipants_schedules = [\n    [],  # Aaron has no meetings\n    [(10, 10.5), (11.5, 12), (12.5, 13), (14.5, 15), (15.5, 16), (16.5, 17)],  # Betty\n    [],  # Linda\n    [(9, 9.5), (10, 11), (12, 12.5), (13, 14.5), (16, 16.5)],  # Joan\n    [(9, 9.5), (10.5, 11), (11.5, 12), (12.5, 13), (13.5, 14.5), (15, 17)],  # Walter\n    [(9, 9.5), (10.5, 11), (11.5, 12), (12.5, 13.5), (14.5, 15.5), (16, 16.5)]  # Martha\n]\n\n# Find the earliest meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_352"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:30:10:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    meeting_duration_min = meeting_duration * 60\n    \n    # Initialize the free slots for the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's busy times\n    for busy_times in participants_busy_times:\n        new_free_slots = []\n        for busy_start, busy_end in busy_times:\n            busy_start_min = time_to_minutes(busy_start)\n            busy_end_min = time_to_minutes(busy_end)\n            temp_slots = []\n            for slot_start, slot_end in free_slots:\n                if busy_end_min <= slot_start or busy_start_min >= slot_end:\n                    # No overlap, keep the slot as is\n                    temp_slots.append((slot_start, slot_end))\n                else:\n                    # Overlap, split the slot\n                    if slot_start < busy_start_min:\n                        temp_slots.append((slot_start, busy_start_min))\n                    if slot_end > busy_end_min:\n                        temp_slots.append((busy_end_min, slot_end))\n            free_slots = temp_slots\n        if not free_slots:\n            return None  # No possible slot\n    \n    # Merge overlapping or adjacent slots\n    free_slots.sort()\n    merged_slots = []\n    for slot in free_slots:\n        if not merged_slots:\n            merged_slots.append(slot)\n        else:\n            last_start, last_end = merged_slots[-1]\n            current_start, current_end = slot\n            if current_start <= last_end:\n                # Merge the slots\n                new_slot = (last_start, max(last_end, current_end))\n                merged_slots[-1] = new_slot\n            else:\n                merged_slots.append(slot)\n    \n    # Find the first slot that can accommodate the meeting\n    for slot_start, slot_end in merged_slots:\n        if slot_end - slot_start >= meeting_duration_min:\n            meeting_end = slot_start + meeting_duration_min\n            return f\"{minutes_to_time(slot_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return None\n\n# Define the participants' busy times\nparticipants_busy_times = [\n    [(\"10:00\", \"10:30\"), (\"11:30\", \"12:30\"), (\"14:30\", \"15:00\")],  # Andrea\n    [(\"10:00\", \"11:00\"), (\"14:00\", \"14:30\"), (\"16:00\", \"16:30\")],  # Gloria\n    [],  # Philip\n    [(\"10:00\", \"10:30\"), (\"11:00\", \"12:00\"), (\"12:30\", \"13:00\"), (\"13:30\", \"15:30\"), (\"16:00\", \"17:00\")],  # Christian\n    [(\"10:00\", \"10:30\"), (\"11:30\", \"12:00\"), (\"12:30\", \"14:30\"), (\"15:00\", \"16:00\")],  # Denise\n    [(\"09:00\", \"09:30\"), (\"10:00\", \"13:30\"), (\"14:00\", \"17:00\")],  # Julie\n]\n\n# Find a meeting time\nmeeting_time = find_meeting_time(participants_busy_times, \"09:00\", \"17:00\", 0.5)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_353"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:30:17:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 (9:00)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Initialize a list to mark busy intervals\n    timeline = [0] * (work_end - work_start)\n    \n    # Mark busy intervals for each participant\n    for busy_slots in participants_busy.values():\n        for slot in busy_slots:\n            start, end = slot.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            for i in range(start_min, end_min):\n                if i < len(timeline):\n                    timeline[i] += 1\n    \n    # Find the first interval where all are free (timeline[i] == 0) for duration\n    required_slots = duration * 2  # Assuming half-hour slots (30 mins)\n    current_free = 0\n    \n    for i in range(len(timeline)):\n        if timeline[i] == 0:\n            current_free += 1\n            if current_free >= required_slots:\n                start_time = i - current_free + 1\n                end_time = start_time + required_slots\n                start_str = minutes_to_time(start_time)\n                end_str = minutes_to_time(end_time)\n                return f\"{start_str}:{end_str}\"\n        else:\n            current_free = 0\n    \n    return \"No suitable time found\"\n\n# Define participants' busy slots\nparticipants_busy = {\n    'Wayne': ['9:30 to 10:00', '11:30 to 12:00', '12:30 to 13:00', '15:00 to 15:30'],\n    'Larry': [],\n    'Richard': ['9:30 to 10:30', '11:30 to 12:00', '13:00 to 13:30'],\n    'Sophia': ['9:00 to 9:30', '11:00 to 15:30'],\n    'Jennifer': ['9:00 to 9:30', '10:30 to 13:00', '13:30 to 14:30', '15:00 to 16:00'],\n    'Theresa': ['9:30 to 10:00', '11:00 to 12:00', '12:30 to 13:30', '14:30 to 15:30', '16:00 to 16:30'],\n}\n\nwork_hours = '9:00 to 17:00'\nmeeting_duration = 0.5  # half an hour\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_354"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy times in minutes (start, end)\n    busy_times = {\n        'Vincent': [(12 * 60 + 30, 13 * 60), (14 * 60, 15 * 60), (16 * 60 + 30, 17 * 60)],\n        'Diane': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (12 * 60, 13 * 60 + 30),\n                  (14 * 60, 14 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n        'Juan': [(9 * 60, 9 * 60 + 30), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 14 * 60 + 30),\n                 (16 * 60, 17 * 60)],\n        'Joseph': [(9 * 60, 11 * 60), (12 * 60, 15 * 60)],\n    }\n    \n    # Austin's preference: not after 15:30\n    austin_preference_end = 15 * 60 + 30\n    \n    # Combine all busy times\n    all_busy = []\n    for person in busy_times:\n        all_busy.extend(busy_times[person])\n    \n    # Add Austin's preference as a \"busy\" time after 15:30\n    all_busy.append((austin_preference_end, work_end))\n    \n    # Sort busy times by start time\n    all_busy.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Find the first free slot that is at least 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Return the first 30-minute slot\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_355"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each person's busy slots to minutes since midnight\n    # Katherine: 12:00-12:30, 13:00-14:30\n    katherine_busy = [(12*60, 12*60 + 30), (13*60, 14*60 + 30)]\n    \n    # Rebecca: free all day\n    rebecca_busy = []\n    \n    # Julie: 9:00-9:30, 10:30-11:00, 13:30-14:00, 15:00-15:30\n    julie_busy = [(9*60, 9*60 + 30), (10*60 + 30, 11*60),\n                  (13*60 + 30, 14*60), (15*60, 15*60 + 30)]\n    \n    # Angela: 9:00-10:00, 10:30-11:00, 11:30-14:00, 14:30-15:00, 16:30-17:00\n    # Preference: avoid before 15:00\n    angela_busy = [(9*60, 10*60), (10*60 + 30, 11*60),\n                   (11*60 + 30, 14*60), (14*60 + 30, 15*60),\n                   (16*60 + 30, 17*60)]\n    angela_preference_start = 15 * 60  # 15:00\n    \n    # Nicholas: 9:30-11:00, 11:30-13:30, 14:00-16:00, 16:30-17:00\n    nicholas_busy = [(9*60 + 30, 11*60), (11*60 + 30, 13*60 + 30),\n                     (14*60, 16*60), (16*60 + 30, 17*60)]\n    \n    # Carl: 9:00-11:00, 11:30-12:30, 13:00-14:30, 15:00-16:00, 16:30-17:00\n    carl_busy = [(9*60, 11*60), (11*60 + 30, 12*60 + 30),\n                 (13*60, 14*60 + 30), (15*60, 16*60),\n                 (16*60 + 30, 17*60)]\n    \n    # Combine all busy slots\n    all_busy = katherine_busy + rebecca_busy + julie_busy + angela_busy + nicholas_busy + carl_busy\n    \n    # Generate free slots by inverting busy slots\n    all_busy.sort()  # Sort by start time\n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Filter free slots to find those that are at least 30 minutes and meet Angela's preference\n    meeting_duration = 30\n    valid_slots = []\n    \n    for start, end in free_slots:\n        if end - start >= meeting_duration and start >= angela_preference_start:\n            valid_slots.append((start, end))\n    \n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No valid time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_356"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each participant's busy slots to minutes since 9:00\n    # Format: list of (start, end) in minutes\n    eric_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    carol_busy = []\n    nicholas_busy = [\n        (11 * 60 + 30, 12 * 60),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    randy_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 11 * 60 + 30),\n        (13 * 60, 14 * 60),\n        (15 * 60, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    kevin_busy = [\n        (9 * 60, 10 * 60),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60, 13 * 60),\n        (13 * 60 + 30, 15 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    henry_busy = [\n        (9 * 60, 10 * 60),\n        (11 * 60, 12 * 60),\n        (13 * 60, 14 * 60),\n        (15 * 60 + 30, 16 * 60 + 30)\n    ]\n\n    # Combine all busy slots\n    all_busy = eric_busy + carol_busy + nicholas_busy + randy_busy + kevin_busy + henry_busy\n\n    # Generate available slots by finding gaps between busy times\n    all_busy.sort()  # Sort by start time\n    available_slots = []\n    prev_end = work_start\n\n    for busy_start, busy_end in all_busy:\n        if busy_start > prev_end:\n            available_slots.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_357"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define each participant's busy times in minutes (start, end)\n    busy_times = {\n        'Jennifer': [(10 * 60 + 30, 11 * 60), (13 * 60, 14 * 60), (16 * 60 + 30, 17 * 60)],\n        'Douglas': [(9 * 60, 9 * 60 + 30), (12 * 60 + 30, 13 * 60)],\n        'Lauren': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (13 * 60, 15 * 60)],\n        'Daniel': [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60), (11 * 60 + 30, 12 * 60 + 30), (13 * 60, 14 * 60 + 30), (15 * 60 + 30, 16 * 60 + 30)],\n        'Abigail': [(9 * 60 + 30, 10 * 60 + 30), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 14 * 60 + 30), (15 * 60 + 30, 16 * 60)],\n        'Catherine': [(9 * 60, 11 * 60), (11 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)]\n    }\n\n    # Collect all busy intervals\n    all_busy = []\n    for person in busy_times:\n        all_busy.extend(busy_times[person])\n\n    # Sort all busy intervals by start time\n    all_busy.sort()\n\n    # Find free intervals by checking gaps between busy intervals\n    free_intervals = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check the interval after the last busy time\n    if previous_end < work_end:\n        free_intervals.append((previous_end, work_end))\n\n    # Find the first free interval that is at least 30 minutes long\n    for start, end in free_intervals:\n        if end - start >= 30:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = (start + 30) // 60\n            end_mm = (start + 30) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_358"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:00:14:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    start, end = work_hours\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        h = minutes // 60\n        m = minutes % 60\n        return f\"{h:02d}:{m:02d}\"\n    \n    work_start = time_to_minutes(start)\n    work_end = time_to_minutes(end)\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    busy_intervals = []\n    \n    for person, schedules in participants_schedules.items():\n        for interval in schedules:\n            start_time, end_time = interval.split(' to ')\n            start_min = time_to_minutes(start_time)\n            end_min = time_to_minutes(end_time)\n            busy_intervals.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    prev_end = work_start\n    \n    for start_busy, end_busy in busy_intervals:\n        if start_busy > prev_end:\n            free_intervals.append((prev_end, start_busy))\n        prev_end = max(prev_end, end_busy)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Now check each free interval to see if it's long enough and doesn't overlap with any participant's busy time\n    # But since we've combined all busy times, any free interval is a potential candidate\n    # So we just need to find the first free interval that's >= duration\n    duration_min = duration * 60\n    for start_free, end_free in free_intervals:\n        if end_free - start_free >= duration_min:\n            # Check if this interval is free for all participants\n            all_free = True\n            for person, schedules in participants_schedules.items():\n                person_busy = False\n                for interval in schedules:\n                    s, e = interval.split(' to ')\n                    s_min = time_to_minutes(s)\n                    e_min = time_to_minutes(e)\n                    # Check if the proposed interval overlaps with any of the person's busy intervals\n                    if not (end_free <= s_min or start_free >= e_min):\n                        person_busy = True\n                        break\n                if person_busy:\n                    all_free = False\n                    break\n            if all_free:\n                return f\"{minutes_to_time(start_free)}:{minutes_to_time(start_free + duration_min)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    'Bryan': ['9:00 to 9:30', '10:00 to 10:30', '12:30 to 13:00', '16:00 to 16:30'],\n    'Sophia': ['13:00 to 13:30', '16:00 to 16:30'],\n    'Jeremy': [],\n    'Marie': ['9:00 to 9:30', '10:00 to 12:00', '13:00 to 14:00', '15:30 to 16:00'],\n    'Tyler': ['9:00 to 10:00', '11:00 to 11:30', '13:00 to 14:00', '14:30 to 17:00'],\n    'Emily': ['9:00 to 10:00', '11:00 to 12:30', '13:30 to 14:00', '14:30 to 15:30']\n}\n\n# Meeting duration in hours (0.5 hours = 30 minutes)\nduration = 0.5\nwork_hours = ('9:00', '17:00')\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, duration, work_hours))\n```",
            "count": "calendar_scheduling_example_359"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:9:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            all_busy.append((time_to_minutes(busy_start), time_to_minutes(busy_end)))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find the merged busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(start, last_start)\n                new_end = max(end, last_end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Check the available slots between work hours and merged busy intervals\n    available_slots = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    meeting_duration_min = meeting_duration * 60\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration_min:\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            meeting_start = minutes_to_time(slot_start)\n            meeting_end = minutes_to_time(slot_start + meeting_duration_min)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [(\"10:00\", \"10:30\"), (\"16:00\", \"16:30\")],  # Emily\n    [],                                         # Mason\n    [(\"10:30\", \"11:00\"), (\"14:00\", \"14:30\")],  # Maria\n    [(\"09:30\", \"10:00\"), (\"10:30\", \"12:30\"), (\"13:30\", \"14:00\"), (\"14:30\", \"15:30\"), (\"16:00\", \"17:00\")],  # Carl\n    [(\"09:30\", \"11:00\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:30\"), (\"14:00\", \"15:00\"), (\"16:00\", \"17:00\")],  # David\n    [(\"09:30\", \"10:30\"), (\"11:00\", \"11:30\"), (\"12:30\", \"13:30\"), (\"14:30\", \"17:00\")]  # Frank\n]\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, \"09:00\", \"17:00\", 0.5)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_360"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30       # 30 minutes\n    \n    # Convert each participant's busy slots to minutes\n    # Format: (start_minute, end_minute)\n    kenneth_busy = []\n    melissa_busy = []\n    joan_busy = [(10*60, 11*60), (12*60 + 30, 13*60 + 30), (15*60, 15*60 + 30), (16*60 + 30, 17*60)]\n    emily_busy = [(10*60, 11*60), (12*60 + 30, 14*60), (15*60, 15*60 + 30), (16*60, 17*60)]\n    brandon_busy = [(9*60 + 30, 10*60 + 30), (11*60, 11*60 + 30), (12*60 + 30, 14*60), (14*60 + 30, 15*60), (15*60 + 30, 17*60)]\n    christopher_busy = [(11*60 + 30, 14*60), (14*60 + 30, 15*60), (15*60 + 30, 16*60), (16*60 + 30, 17*60)]\n    \n    # Emily cannot meet before 9:30\n    emily_constraint = 9 * 60 + 30\n    \n    # Combine all busy slots\n    all_busy = kenneth_busy + melissa_busy + joan_busy + emily_busy + brandon_busy + christopher_busy\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find potential meeting slots\n    potential_slots = []\n    previous_end = max(work_hours_start, emily_constraint)\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            potential_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    # Check the slot after the last busy slot\n    if previous_end + meeting_duration <= work_hours_end:\n        potential_slots.append((previous_end, work_hours_end))\n    \n    # Find the first slot that fits the meeting duration\n    for slot_start, slot_end in potential_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_361"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy blocks to minutes since midnight\n    busy_blocks = {\n        'Megan': [(13 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60)],\n        'Jeremy': [(14 * 60, 15 * 60)],\n        'Sean': [(11 * 60, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (13 * 60 + 30, 14 * 60), (16 * 60, 16 * 60 + 30)],\n        'Dorothy': [(9 * 60, 10 * 60), (11 * 60, 11 * 60 + 30), (12 * 60, 13 * 60), (14 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Michael': [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 11 * 60 + 30), (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Jesse': [(10 * 60, 12 * 60 + 30), (14 * 60, 14 * 60 + 30), (16 * 60, 17 * 60)],\n    }\n\n    # Dorothy's preference: avoid after 15:00\n    dorothy_preference_end = 15 * 60\n\n    # Combine all busy blocks\n    all_busy = []\n    for person, blocks in busy_blocks.items():\n        all_busy.extend(blocks)\n    \n    # Sort all busy blocks by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy blocks and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the time after the last busy block\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Filter free slots that are at least meeting_duration long and meet Dorothy's preference\n    possible_slots = []\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            if end <= dorothy_preference_end:\n                possible_slots.append((start, end))\n    \n    # Also check slots that end after Dorothy's preference but start before\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            if start < dorothy_preference_end and end > dorothy_preference_end:\n                if dorothy_preference_end - start >= meeting_duration:\n                    possible_slots.append((start, dorothy_preference_end))\n    \n    # Find the earliest possible slot\n    if possible_slots:\n        possible_slots.sort()\n        best_start, best_end = possible_slots[0]\n        meeting_end = best_start + meeting_duration\n        # Format the output as HH:MM:HH:MM\n        return f\"{best_start // 60:02d}:{best_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    else:\n        return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_362"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    # Russell: 14:30-15:00, 15:30-17:00\n    russell_busy = [(14*60 + 30, 15*60), (15*60 + 30, 17*60)]\n    # Paul: 9:00-10:00, 10:30-12:30, 13:00-15:00, 15:30-16:00, 16:30-17:00\n    paul_busy = [(9*60, 10*60), (10*60 + 30, 12*60 + 30), (13*60, 15*60), (15*60 + 30, 16*60), (16*60 + 30, 17*60)]\n    # Donna: 9:00-9:30, 10:00-11:00, 11:30-12:30, 14:00-14:30, 15:00-15:30, 16:00-16:30\n    donna_busy = [(9*60, 9*60 + 30), (10*60, 11*60), (11*60 + 30, 12*60 + 30), (14*60, 14*60 + 30), (15*60, 15*60 + 30), (16*60, 16*60 + 30)]\n    # Isabella: 9:30-10:00, 11:00-11:30, 12:00-12:30, 13:00-13:30, 14:00-14:30, 15:00-15:30, 16:00-17:00\n    isabella_busy = [(9*60 + 30, 10*60), (11*60, 11*60 + 30), (12*60, 12*60 + 30), (13*60, 13*60 + 30), (14*60, 14*60 + 30), (15*60, 15*60 + 30), (16*60, 17*60)]\n\n    # Combine all busy times and sort\n    all_busy = russell_busy + paul_busy + donna_busy + isabella_busy\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = work_start\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can fit the meeting\n    for slot in free_slots:\n        start, end = slot\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_363"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy blocks to minutes since midnight\n    busy_blocks = {\n        'Virginia': [],\n        'Janet': [(9*60 + 30, 10*60), (12*60 + 30, 13*60), (13*60 + 30, 15*60 + 30)],\n        'Joyce': [(12*60 + 30, 13*60), (15*60 + 30, 17*60)],\n        'Catherine': [(9*60, 10*60), (10*60 + 30, 16*60 + 30)],\n        'Donna': [(9*60, 9*60 + 30), (11*60, 11*60 + 30), (13*60, 13*60 + 30), (14*60 + 30, 17*60)],\n        'Evelyn': [(10*60 + 30, 11*60), (12*60, 15*60 + 30), (16*60, 17*60)]\n    }\n\n    # Combine all busy blocks\n    all_busy = []\n    for person in busy_blocks:\n        all_busy.extend(busy_blocks[person])\n\n    # Sort busy blocks by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy blocks and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_364"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Convert each participant's busy slots to minutes\n    sarah_busy = [(11 * 60 + 30, 12 * 60), (15 * 60, 15 * 60 + 30)]\n    russell_busy = []\n    michael_busy = [(10 * 60 + 30, 11 * 60 + 30)]\n    charles_busy = [(10 * 60, 12 * 60), (13 * 60, 14 * 60), (14 * 60 + 30, 15 * 60), (16 * 60 + 30, 17 * 60)]\n    heather_busy = [(9 * 60, 10 * 60 + 30), (11 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60), (16 * 60, 16 * 60 + 30)]\n    sharon_busy = [(9 * 60, 9 * 60 + 30), (10 * 60, 12 * 60), (12 * 60 + 30, 13 * 60 + 30), (14 * 60, 14 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)]\n    \n    # Combine all busy slots\n    all_busy = sarah_busy + russell_busy + michael_busy + charles_busy + heather_busy + sharon_busy\n    \n    # Sort busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can accommodate 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_365"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:30:15:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours_start, work_hours_end, duration):\n    # Convert work hours to minutes\n    start_min = work_hours_start * 60\n    end_min = work_hours_end * 60\n    \n    # Initialize a list to keep track of busy times for all participants\n    all_busy = []\n    \n    # Collect all busy intervals from each participant\n    for busy in participants_busy:\n        for interval in busy:\n            start = interval[0] * 60\n            end = interval[1] * 60\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find free intervals between merged busy times\n    free_intervals = []\n    prev_end = start_min\n    \n    for start, end in merged:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    # Check the interval after the last busy time\n    if prev_end < end_min:\n        free_intervals.append((prev_end, end_min))\n    \n    # Find the first free interval that can accommodate the meeting duration\n    duration_min = duration * 60\n    for start, end in free_intervals:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            # Convert back to hours and minutes\n            start_h = meeting_start // 60\n            start_m = meeting_start % 60\n            end_h = meeting_end // 60\n            end_m = meeting_end % 60\n            return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    \n    return \"No suitable time found\"\n\n# Define work hours and meeting duration\nwork_hours_start = 9\nwork_hours_end = 17\nduration = 0.5  # half an hour\n\n# Define each participant's busy times in hours\nparticipants_busy = [\n    [(14, 14.5), (15, 15.5), (16, 17)],  # Jeffrey\n    [(9, 9.5), (10, 10.5)],              # Benjamin\n    [(9.5, 10), (15, 15.5)],             # Denise\n    [(9, 11.5), (12.5, 14.5), (16, 16.5)],  # Alexis\n    [(9, 10.5), (11, 12), (12.5, 14), (15, 17)],  # Shirley\n    [(9, 9.5), (10.5, 11), (12, 12.5), (13, 13.5), (14, 14.5), (15, 15.5), (16, 17)]  # Philip\n]\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, work_hours_start, work_hours_end, duration))\n```",
            "count": "calendar_scheduling_example_366"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define each person's busy times in minutes (start, end)\n    busy_times = {\n        'Carolyn': [(9.5 * 60, 10.5 * 60), (13.5 * 60, 14 * 60), (15 * 60, 15.5 * 60), (16 * 60, 17 * 60)],\n        'Jordan': [(9.5 * 60, 10 * 60), (10.5 * 60, 11 * 60), (13 * 60, 14.5 * 60), (16 * 60, 16.5 * 60)],\n        'Wayne': [(9 * 60, 9.5 * 60), (10.5 * 60, 11.5 * 60), (12.5 * 60, 13 * 60)],\n        'Megan': [(9 * 60, 9.5 * 60), (10 * 60, 11.5 * 60), (12 * 60, 13.5 * 60), (14 * 60, 14.5 * 60), (15 * 60, 15.5 * 60), (16 * 60, 16.5 * 60)],\n        'Billy': [(9 * 60, 11 * 60), (11.5 * 60, 15.5 * 60), (16 * 60, 17 * 60)],\n        'Peter': [(9 * 60, 10.5 * 60), (11 * 60, 13 * 60), (14 * 60, 15.5 * 60), (16 * 60, 17 * 60)]\n    }\n    \n    # Collect all busy intervals\n    all_busy = []\n    for person in busy_times:\n        all_busy.extend(busy_times[person])\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for a 30-minute slot\n    meeting_duration = 30\n    for interval in free_intervals:\n        start, end = interval\n        if end - start >= meeting_duration:\n            # Check if all participants are free during this interval\n            valid = True\n            meeting_start = start\n            meeting_end = start + meeting_duration\n            \n            for person in busy_times:\n                person_busy = busy_times[person]\n                for busy_start, busy_end in person_busy:\n                    if not (meeting_end <= busy_start or meeting_start >= busy_end):\n                        valid = False\n                        break\n                if not valid:\n                    break\n            \n            if valid:\n                # Convert minutes back to HH:MM format\n                def format_time(minutes):\n                    hours = int(minutes // 60)\n                    mins = int(minutes % 60)\n                    return f\"{hours:02d}:{mins:02d}\"\n                \n                return f\"{format_time(meeting_start)}:{format_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_367"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert each participant's busy slots to minutes\n    patrick_busy = [(11*60 + 30, 12*60), (15*60, 15*60 + 30)]\n    john_busy = [(11*60 + 30, 12*60 + 30), (13*60, 14*60), (14*60 + 30, 15*60), (15*60 + 30, 16*60)]\n    samantha_busy = [(12*60, 12*60 + 30), (16*60 + 30, 17*60)]\n    billy_busy = [(9*60, 9*60 + 30), (10*60, 11*60), (12*60 + 30, 14*60), (15*60 + 30, 16*60), (16*60 + 30, 17*60)]\n    christine_busy = [(9*60, 10*60), (10*60 + 30, 14*60), (15*60, 15*60 + 30)]\n    ruth_busy = [(9*60, 10*60), (10*60 + 30, 11*60), (11*60 + 30, 12*60), (12*60 + 30, 16*60), (16*60 + 30, 17*60)]\n\n    # Combine all busy slots\n    all_busy = patrick_busy + john_busy + samantha_busy + billy_busy + christine_busy + ruth_busy\n\n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert start time back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_time = start + meeting_duration\n            end_hh = end_time // 60\n            end_mm = end_time % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_368"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' busy slots in minutes\n    busy_slots = {\n        'Charles': [],\n        'Kayla': [(12 * 60, 13 * 60)],\n        'Cynthia': [],\n        'Rebecca': [(10 * 60, 10 * 60 + 30), (12 * 60, 14 * 60), (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Randy': [(10 * 60, 11 * 60 + 30), (12 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Hannah': [(9 * 60, 9 * 60 + 30), (10 * 60, 12 * 60), (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)]\n    }\n\n    # Kayla's constraint: not before 10:30\n    kayla_constraint = 10 * 60 + 30\n\n    # Meeting duration in minutes\n    meeting_duration = 30\n\n    # Combine all busy slots\n    all_busy = []\n    for person in busy_slots:\n        for start, end in busy_slots[person]:\n            all_busy.append((start, end))\n    all_busy.sort()\n\n    # Find free slots\n    free_slots = []\n    prev_end = work_start\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n\n    # Filter free slots that meet duration and Kayla's constraint\n    valid_slots = []\n    for start, end in free_slots:\n        if end - start >= meeting_duration and start >= kayla_constraint:\n            valid_slots.append((start, end))\n\n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Format the output as HH:MM:HH:MM\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No valid slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_369"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define each person's busy times in minutes (start, end)\n    schedules = {\n        'Peter': [(10*60 + 30, 11*60), (11*60 + 30, 12*60), (13*60, 13*60 + 30), (15*60 + 30, 16*60)],\n        'Grace': [(11*60 + 30, 13*60), (15*60, 15*60 + 30)],\n        'Julie': [(9*60 + 30, 10*60), (10*60 + 30, 11*60), (14*60, 15*60), (15*60 + 30, 16*60 + 30)],\n        'Kayla': [(11*60 + 30, 12*60), (12*60 + 30, 14*60 + 30), (15*60, 16*60), (16*60 + 30, 17*60)],\n        'Emma': [(9*60, 9*60 + 30), (10*60 + 30, 11*60), (11*60 + 30, 12*60), (13*60, 15*60 + 30)],\n        'Scott': [(9*60, 10*60), (12*60, 12*60 + 30), (13*60, 14*60), (14*60 + 30, 15*60 + 30), (16*60, 16*60 + 30)],\n    }\n    \n    # Kayla's preference: not before 11:00\n    kayla_preference_start = 11 * 60\n    \n    # Collect all busy intervals\n    all_busy = []\n    for person in schedules:\n        for start, end in schedules[person]:\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Filter free intervals that are at least 30 minutes and after Kayla's preference\n    possible_slots = []\n    for start, end in free_intervals:\n        if end - start >= 30 and start >= kayla_preference_start:\n            possible_slots.append((start, end))\n    \n    # Find the first possible slot that fits everyone\n    for slot_start, slot_end in possible_slots:\n        # Check if the slot is free for everyone\n        all_free = True\n        for person in schedules:\n            person_busy = schedules[person]\n            for busy_start, busy_end in person_busy:\n                if not (slot_start >= busy_end or slot_start + 30 <= busy_start):\n                    all_free = False\n                    break\n            if not all_free:\n                break\n        if all_free:\n            # Format the time as HH:MM:HH:MM\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = (slot_start + 30) // 60\n            end_mm = (slot_start + 30) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_370"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' schedules as lists of busy intervals in minutes\n    schedules = {\n        'Mark': [(11 * 60, 11 * 60 + 30), (12 * 60 + 30, 13 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Logan': [(11 * 60 + 30, 12 * 60), (13 * 60, 13 * 60 + 30)],\n        'Isabella': [(9 * 60, 9 * 60 + 30), (11 * 60, 11 * 60 + 30)],\n        'Nathan': [(9 * 60, 9 * 60 + 30), (10 * 60, 13 * 60), (13 * 60 + 30, 14 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Anna': [(9 * 60, 10 * 60), (11 * 60, 13 * 60), (13 * 60 + 30, 14 * 60), (16 * 60 + 30, 17 * 60)],\n        'Dylan': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (11 * 60, 12 * 60 + 30), (13 * 60, 14 * 60 + 30), (15 * 60, 16 * 60)],\n    }\n\n    # Collect all busy intervals from all participants\n    all_busy = []\n    for person in schedules:\n        all_busy.extend(schedules[person])\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n\n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append([start, end])\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1][1] = max(last_end, end)\n            else:\n                merged.append([start, end])\n\n    # Find available slots between work hours and busy intervals\n    available = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n\n    # Check each available slot for a 30-minute window\n    meeting_duration = 30\n    for start, end in available:\n        if end - start >= meeting_duration:\n            # Convert start time back to HH:MM format\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No available time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_371"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            all_busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Find the earliest time when everyone is free for the duration\n    current_time = work_start\n    for start, end in all_busy_intervals:\n        if start > current_time:\n            # Check if there's enough time before the next busy interval starts\n            if start - current_time >= duration_minutes:\n                # Found a suitable slot\n                meeting_end = current_time + duration_minutes\n                # Convert back to HH:MM format\n                def minutes_to_time(minutes):\n                    hh = minutes // 60\n                    mm = minutes % 60\n                    return f\"{hh:02d}:{mm:02d}\"\n                return f\"{minutes_to_time(current_time)}:{minutes_to_time(meeting_end)}\"\n        # Update current_time to the end of this busy interval if it's later\n        if end > current_time:\n            current_time = end\n        # If we've gone past work hours, break\n        if current_time >= work_end:\n            break\n    \n    # Check the time after the last busy interval\n    if work_end - current_time >= duration_minutes:\n        meeting_end = current_time + duration_minutes\n        def minutes_to_time(minutes):\n            hh = minutes // 60\n            mm = minutes % 60\n            return f\"{hh:02d}:{mm:02d}\"\n        return f\"{minutes_to_time(current_time)}:{minutes_to_time(meeting_end)}\"\n    \n    return None\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"10:30 to 11:30\", \"14:00 to 14:30\", \"16:00 to 16:30\"],  # Barbara\n    [\"11:30 to 13:00\", \"13:30 to 14:00\"],  # Arthur\n    [\"09:30 to 10:00\", \"10:30 to 11:00\", \"12:00 to 12:30\", \"14:00 to 15:30\"],  # Elijah\n    [\"09:00 to 13:00\", \"13:30 to 14:30\", \"15:00 to 17:00\"],  # Natalie\n    [\"09:30 to 10:00\", \"11:00 to 12:00\", \"13:30 to 15:30\", \"16:30 to 17:00\"],  # Philip\n    [\"09:00 to 13:00\", \"13:30 to 15:30\", \"16:00 to 17:00\"],  # Jordan\n]\n\n# Define work hours and meeting duration\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_372"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time strings to minutes since 9:00 (work_hours_start)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - work_hours_start) * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = work_hours_start + (minutes // 60)\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy_intervals = []\n    for schedule in participants_schedules:\n        busy_intervals = []\n        for busy in schedule:\n            start, end = busy.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            busy_intervals.append((start_min, end_min))\n        all_busy_intervals.append(busy_intervals)\n    \n    # Merge all busy intervals into a single list\n    merged_busy = []\n    for intervals in all_busy_intervals:\n        merged_busy.extend(intervals)\n    \n    # Sort the merged intervals by start time\n    merged_busy.sort()\n    \n    # Find the free intervals by checking gaps between busy intervals\n    free_intervals = []\n    previous_end = 0\n    for start, end in merged_busy:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the end of the day\n    total_work_minutes = (work_hours_end - work_hours_start) * 60\n    if previous_end < total_work_minutes:\n        free_intervals.append((previous_end, total_work_minutes))\n    \n    # Now, find the earliest free interval that can accommodate the meeting\n    for interval in free_intervals:\n        start, end = interval\n        if end - start >= duration_minutes:\n            # Check if this interval is free for all participants\n            all_free = True\n            for participant_intervals in all_busy_intervals:\n                participant_free = True\n                for busy_start, busy_end in participant_intervals:\n                    if not (end <= busy_start or start >= busy_end):\n                        participant_free = False\n                        break\n                if not participant_free:\n                    all_free = False\n                    break\n            if all_free:\n                return f\"{minutes_to_time(start)}:{minutes_to_time(start + duration_minutes)}\"\n    \n    return \"No suitable time found\"\n\n# Define work hours and meeting duration\nwork_hours_start = 9\nwork_hours_end = 17\nduration_minutes = 30\n\n# Define each participant's busy intervals\nparticipants_schedules = [\n    [],  # Julia\n    [\"9:00 to 9:30\", \"10:00 to 11:00\", \"12:00 to 12:30\"],  # Joseph\n    [\"9:30 to 10:00\", \"12:30 to 13:00\", \"14:00 to 16:00\"],  # Donna\n    [\"9:30 to 11:00\", \"11:30 to 12:00\", \"12:30 to 14:00\", \"15:00 to 16:30\"],  # Bruce\n    [\"9:00 to 9:30\", \"10:30 to 11:30\", \"12:30 to 13:00\", \"14:00 to 15:30\", \"16:00 to 16:30\"],  # Bobby\n    [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:30 to 12:00\", \"13:00 to 13:30\", \"14:00 to 14:30\", \"15:00 to 16:30\"],  # Arthur\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_373"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(schedules, duration, start_hour, end_hour):\n    # Convert all busy times to minutes since start_hour\n    start_min = start_hour * 60\n    end_min = end_hour * 60\n    busy_intervals = []\n    \n    for person in schedules:\n        for busy in schedules[person]:\n            start = busy[0].split(':')\n            end = busy[1].split(':')\n            start_busy = int(start[0]) * 60 + int(start[1])\n            end_busy = int(end[0]) * 60 + int(end[1])\n            busy_intervals.append((start_busy, end_busy))\n    \n    # Sort all busy intervals\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                new_end = max(last_end, current_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append(interval)\n    \n    # Find the earliest available slot\n    prev_end = start_min\n    for interval in merged:\n        current_start, current_end = interval\n        if current_start - prev_end >= duration:\n            return (prev_end, prev_end + duration)\n        prev_end = max(prev_end, current_end)\n    \n    # Check after the last busy interval\n    if end_min - prev_end >= duration:\n        return (prev_end, prev_end + duration)\n    \n    return None\n\n# Define the schedules\nschedules = {\n    'Lori': [('9:30', '10:00'), ('11:00', '11:30'), ('12:00', '12:30'), ('13:30', '14:30'), ('16:30', '17:00')],\n    'Victoria': [],\n    'Natalie': [],\n    'Pamela': [('9:30', '10:30'), ('11:00', '12:00'), ('13:00', '13:30'), ('14:00', '15:00'), ('16:30', '17:00')],\n    'Justin': [('9:00', '10:00'), ('10:30', '11:30'), ('12:00', '13:00'), ('13:30', '15:00'), ('15:30', '17:00')],\n    'Martha': [('9:00', '11:30'), ('12:30', '13:00'), ('13:30', '15:00'), ('15:30', '16:00')]\n}\n\nduration = 30  # minutes\nstart_hour = 9\nend_hour = 17\n\nmeeting_time = find_meeting_time(schedules, duration, start_hour, end_hour)\n\nif meeting_time:\n    start = meeting_time[0]\n    end = meeting_time[1]\n    start_hh = start // 60\n    start_mm = start % 60\n    end_hh = end // 60\n    end_mm = end % 60\n    print(f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_374"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time slots to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Function to subtract busy slots from free slots\n    def subtract_busy_slots(free_slots, busy_start, busy_end):\n        new_free_slots = []\n        for slot_start, slot_end in free_slots:\n            if busy_end <= slot_start or busy_start >= slot_end:\n                # No overlap, keep the slot as is\n                new_free_slots.append((slot_start, slot_end))\n            else:\n                # There is an overlap, split the free slot\n                if slot_start < busy_start:\n                    new_free_slots.append((slot_start, busy_start))\n                if slot_end > busy_end:\n                    new_free_slots.append((busy_end, slot_end))\n        return new_free_slots\n    \n    # Process each participant's busy slots\n    for participant, busy_slots in participants_schedules.items():\n        for busy_start_str, busy_end_str in busy_slots:\n            busy_start = time_to_minutes(busy_start_str)\n            busy_end = time_to_minutes(busy_end_str)\n            free_slots = subtract_busy_slots(free_slots, busy_start, busy_end)\n    \n    # Find the first free slot that can accommodate the meeting duration\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = {\n    \"Julie\": [(\"12:00\", \"12:30\"), (\"13:30\", \"14:00\"), (\"15:00\", \"16:00\")],\n    \"Sara\": [(\"11:00\", \"11:30\"), (\"15:00\", \"15:30\")],\n    \"Donna\": [(\"10:30\", \"11:00\"), (\"12:30\", \"13:30\"), (\"14:30\", \"15:00\")],\n    \"Keith\": [(\"09:00\", \"16:00\")],\n    \"Dylan\": [(\"09:00\", \"09:30\"), (\"10:00\", \"10:30\"), (\"11:00\", \"12:30\"), (\"13:30\", \"16:00\")],\n    \"Jose\": [(\"09:00\", \"10:30\"), (\"12:00\", \"14:30\"), (\"15:30\", \"16:30\")]\n}\n\n# Define work hours and meeting duration\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_375"
        },
        {
            "final_program_time": "{11:30:11:31}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = (minutes + 540) // 60\n        mm = (minutes + 540) % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    # Initialize the free slots for the day (9:00-17:00 is 480 minutes)\n    free_slots = [True] * 480  # 9:00-17:00 (8 hours = 480 minutes)\n\n    # Mark busy times for each participant\n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            start = time_to_minutes(busy_start)\n            end = time_to_minutes(busy_end)\n            # Clamp to work hours\n            start = max(0, start)\n            end = min(480, end)\n            for i in range(start, end):\n                if i < 480:\n                    free_slots[i] = False\n\n    # Find the first available slot of duration\n    required_slots = duration // 30  # Assuming 30-minute intervals\n    current_streak = 0\n    for i in range(480):\n        if free_slots[i]:\n            current_streak += 1\n            if current_streak >= required_slots:\n                start_time = i - current_streak + 1\n                end_time = i + 1\n                start_str = minutes_to_time(start_time)\n                end_str = minutes_to_time(end_time)\n                return f\"{start_str}:{end_str}\"\n        else:\n            current_streak = 0\n\n    return \"No available slot\"\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 30  # minutes\n\n# Define participants' schedules\nparticipants_schedules = [\n    [(\"12:00\", \"13:00\"), (\"14:30\", \"15:30\")],  # Larry\n    [(\"10:30\", \"11:00\"), (\"14:30\", \"15:00\")],  # Angela\n    [],                                         # Christina\n    [(\"9:30\", \"10:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"14:30\"), (\"15:00\", \"16:00\")],  # Scott\n    [(\"9:30\", \"11:30\"), (\"12:00\", \"15:00\"), (\"16:00\", \"17:00\")],  # Matthew\n    [(\"9:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"13:30\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:30\")]  # Charlotte\n]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_376"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert all schedules to minutes for easier comparison\n    # Each person's busy times are represented as (start, end) in minutes\n    busy_times = {\n        'Rebecca': [(13 * 60, 13 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n        'Peter': [\n            (9 * 60, 9 * 60 + 30),\n            (10 * 60 + 30, 11 * 60 + 30),\n            (12 * 60 + 30, 13 * 60),\n            (14 * 60, 14 * 60 + 30),\n            (15 * 60, 16 * 60),\n            (16 * 60 + 30, 17 * 60)\n        ],\n        'Lawrence': [\n            (9 * 60, 9 * 60 + 30),\n            (10 * 60, 11 * 60),\n            (12 * 60, 13 * 60),\n            (13 * 60 + 30, 14 * 60),\n            (14 * 60 + 30, 15 * 60),\n            (16 * 60 + 30, 17 * 60)\n        ],\n        'Randy': [\n            (9 * 60, 9 * 60 + 30),\n            (10 * 60, 11 * 60 + 30),\n            (12 * 60, 13 * 60),\n            (13 * 60 + 30, 15 * 60 + 30),\n            (16 * 60, 17 * 60)\n        ]\n    }\n    \n    # Randy's preference: not after 10:30 (10:30 = 10*60 + 30)\n    randy_preference_end = 10 * 60 + 30\n    \n    # Generate all possible 30-minute slots within work hours\n    for start in range(work_start, work_end - 30 + 1):\n        end = start + 30\n        # Check if the slot is within Randy's preference\n        if end > randy_preference_end:\n            continue\n        # Check if the slot is free for everyone\n        all_free = True\n        for person, busy_slots in busy_times.items():\n            for busy_start, busy_end in busy_slots:\n                if not (end <= busy_start or start >= busy_end):\n                    all_free = False\n                    break\n            if not all_free:\n                break\n        if all_free:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = end // 60\n            end_mm = end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_377"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy slots in minutes\n    busy_slots = {\n        'Marie': [(11 * 60, 11 * 60 + 30), (12 * 60 + 30, 15 * 60)],\n        'Mark': [(11 * 60 + 30, 12 * 60 + 30), (15 * 60 + 30, 16 * 60 + 30)],\n        'Patrick': [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 11 * 60), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60), (16 * 60, 17 * 60)],\n        'Julie': [(9 * 60, 10 * 60), (11 * 60, 11 * 60 + 30), (12 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 17 * 60)],\n        'Emma': [(9 * 60, 10 * 60), (10 * 60 + 30, 12 * 60 + 30), (13 * 60 + 30, 15 * 60), (15 * 60 + 30, 17 * 60)],\n        'Daniel': [(9 * 60, 10 * 60), (11 * 60, 12 * 60), (13 * 60 + 30, 15 * 60), (16 * 60 + 30, 17 * 60)],\n    }\n    \n    # Patrick's constraint: no meetings after 12:00\n    patrick_constraint = 12 * 60\n    \n    # Combine all busy slots\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n    \n    # Add Patrick's constraint as a busy slot for everyone\n    all_busy.append((patrick_constraint, work_end))\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by merging busy intervals\n    free_slots = []\n    prev_end = work_start\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Check each free slot for 30-minute availability\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert start time back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_time = start + meeting_duration\n            end_hh = end_time // 60\n            end_mm = end_time % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_378"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:9:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_start, work_end, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 (9:00)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    all_busy = []\n    for busy_list in participants_busy:\n        for busy in busy_list:\n            start, end = busy.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            all_busy.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots between merged busy intervals\n    available = []\n    prev_end = work_start_min\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        available.append((prev_end, work_end_min))\n    \n    # Check each available slot for sufficient duration\n    for slot in available:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' busy times\nparticipants_busy = [\n    [\"10:30 to 11:30\", \"13:00 to 13:30\", \"14:30 to 15:00\"],  # Carolyn\n    [\"14:30 to 15:00\", \"16:30 to 17:00\"],  # Russell\n    [\"10:00 to 10:30\", \"16:30 to 17:00\"],  # Emma\n    [\"9:30 to 10:30\", \"11:00 to 11:30\", \"12:30 to 14:30\", \"15:30 to 17:00\"],  # Maria\n    [\"9:30 to 10:30\", \"11:00 to 11:30\", \"12:00 to 14:00\", \"15:00 to 15:30\"],  # Mason\n    [\"10:00 to 12:30\", \"13:00 to 13:30\", \"15:00 to 16:00\"],  # Hannah\n]\n\nwork_start = \"9:00\"\nwork_end = \"17:00\"\nduration = 0.5  # half an hour\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, work_start, work_end, duration))\n```",
            "count": "calendar_scheduling_example_379"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes, work_start, work_end):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration = duration_minutes\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start_min = time_to_minutes(busy[0])\n            end_min = time_to_minutes(busy[1])\n            all_busy.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start_min\n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n    \n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Adam has no meetings\n    [(\"10:00\", \"11:00\"), (\"12:00\", \"13:00\"), (\"15:30\", \"16:30\")],  # Jacqueline\n    [(\"09:30\", \"10:30\"), (\"11:00\", \"11:30\"), (\"13:30\", \"14:00\"), (\"15:00\", \"15:30\"), (\"16:00\", \"16:30\")],  # Denise\n    [(\"09:30\", \"10:30\"), (\"11:00\", \"13:00\"), (\"14:00\", \"15:00\"), (\"15:30\", \"16:30\")],  # Kimberly\n    [(\"09:30\", \"10:30\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:30\"), (\"14:00\", \"16:00\"), (\"16:30\", \"17:00\")],  # Ann\n    [(\"09:30\", \"10:30\"), (\"11:30\", \"12:30\"), (\"13:00\", \"14:30\"), (\"16:00\", \"16:30\")],  # Steven\n]\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, 30, \"09:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_380"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the free slots for the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Function to subtract busy slots from free slots\n    def subtract_busy_slots(free_slots, busy_start, busy_end):\n        new_free_slots = []\n        for slot_start, slot_end in free_slots:\n            if busy_end <= slot_start or busy_start >= slot_end:\n                new_free_slots.append((slot_start, slot_end))\n            else:\n                if slot_start < busy_start:\n                    new_free_slots.append((slot_start, busy_start))\n                if slot_end > busy_end:\n                    new_free_slots.append((busy_end, slot_end))\n        return new_free_slots\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        for busy_start_str, busy_end_str in schedule:\n            busy_start = time_to_minutes(busy_start_str)\n            busy_end = time_to_minutes(busy_end_str)\n            free_slots = subtract_busy_slots(free_slots, busy_start, busy_end)\n    \n    # Find the first free slot that can accommodate the meeting duration\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    return None\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\n# Define participants' schedules\nparticipants_schedules = [\n    [(\"9:30\", \"10:30\"), (\"12:30\", \"13:00\"), (\"15:30\", \"16:00\")],  # Larry\n    [(\"11:00\", \"11:30\"), (\"16:00\", \"16:30\")],  # Julie\n    [(\"9:00\", \"9:30\"), (\"16:00\", \"16:30\")],  # Jason\n    [(\"10:00\", \"10:30\"), (\"11:00\", \"11:30\"), (\"12:00\", \"13:30\"), (\"15:00\", \"16:30\")],  # Mason\n    [(\"9:00\", \"11:30\"), (\"12:00\", \"14:00\"), (\"14:30\", \"17:00\")],  # Alan\n    [(\"9:30\", \"10:00\"), (\"11:30\", \"13:00\"), (\"13:30\", \"14:00\"), (\"14:30\", \"15:30\"), (\"16:00\", \"16:30\")]  # Bruce\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_381"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_hour, end_hour = work_hours\n    # Convert work hours to minutes for easier calculation\n    start_time = start_hour * 60\n    end_time = end_hour * 60\n    \n    # Initialize a list to keep track of busy times for all participants\n    busy_times = []\n    \n    for schedule in participants_schedules:\n        person_busy = []\n        for block in schedule:\n            start_block = block[0] * 60\n            end_block = block[1] * 60\n            person_busy.append((start_block, end_block))\n        busy_times.append(person_busy)\n    \n    # Check every possible time slot within work hours\n    for time in range(start_time, end_time - duration + 1):\n        end_slot = time + duration\n        valid = True\n        # Check against each participant's schedule\n        for person in busy_times:\n            person_valid = True\n            for block_start, block_end in person:\n                if not (end_slot <= block_start or time >= block_end):\n                    person_valid = False\n                    break\n            if not person_valid:\n                valid = False\n                break\n        if valid:\n            # Convert back to HH:MM format\n            start_hh = time // 60\n            start_mm = time % 60\n            end_hh = end_slot // 60\n            end_mm = end_slot % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No valid time found\"\n\n# Define participants' schedules in 24-hour format (HH.HH)\nparticipants_schedules = [\n    [(13.0, 14.5), (16.5, 17.0)],  # Debra\n    [],                             # Ryan\n    [(12.0, 12.5), (14.0, 15.0), (15.5, 16.0)],  # Maria\n    [(9.5, 10.0), (11.0, 13.0), (13.5, 15.0), (15.5, 16.5)],  # Timothy\n    [(10.0, 11.0), (12.5, 13.0), (14.0, 15.0), (15.5, 17.0)],  # Pamela\n    [(9.5, 11.0), (11.5, 14.0), (14.5, 15.5), (16.0, 17.0)],   # Ethan\n]\n\nwork_hours = (9, 17)  # 9:00 to 17:00\nduration = 30  # minutes\n\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_382"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each person's busy slots to minutes\n    busy_slots = {\n        'Diane': [(10 * 60, 10 * 60 + 30), (14 * 60 + 30, 15 * 60)],\n        'Rachel': [(11 * 60 + 30, 12 * 60), (13 * 60, 13 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Amber': [(9 * 60, 9 * 60 + 30), (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60), (15 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Shirley': [(10 * 60, 11 * 60), (11 * 60 + 30, 12 * 60), (13 * 60 + 30, 14 * 60), (15 * 60, 17 * 60)],\n        'Joshua': [(9 * 60, 10 * 60 + 30), (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 15 * 60), (16 * 60, 16 * 60 + 30)],\n        'Lisa': [(9 * 60 + 30, 10 * 60), (12 * 60 + 30, 14 * 60), (15 * 60, 17 * 60)]\n    }\n    \n    # Collect all busy slots\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the earliest free slot that is at least 30 minutes long\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = (start + meeting_duration) // 60\n            end_mm = (start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_383"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each person's busy slots to minutes\n    busy_slots = {\n        'Stephen': [(11 * 60, 12 * 60)],\n        'Diane': [(9 * 60 + 30, 10 * 60), (11 * 60 + 30, 12 * 60), (13 * 60, 14 * 60), (15 * 60 + 30, 16 * 60 + 30)],\n        'Joe': [(12 * 60 + 30, 13 * 60), (14 * 60 + 30, 15 * 60)],\n        'Diana': [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 11 * 60 + 30), (12 * 60 + 30, 16 * 60)],\n        'Julia': [(9 * 60 + 30, 12 * 60), (12 * 60 + 30, 17 * 60)],\n        'Stephanie': [(9 * 60, 11 * 60), (11 * 60 + 30, 12 * 60), (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)],\n    }\n    \n    # Combine all busy slots\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n    \n    # Sort busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the time after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that is at least 30 minutes long\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = (start + meeting_duration) // 60\n            end_mm = (start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_384"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_start, work_end):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find the earliest available slot\n    prev_end = work_start_min\n    for start, end in all_busy:\n        if start > prev_end:\n            available_start = prev_end\n            available_end = start\n            if available_end - available_start >= duration_min:\n                return (minutes_to_time(available_start), \n                        minutes_to_time(available_start + duration_min))\n        prev_end = max(prev_end, end)\n    \n    # Check the slot after the last busy interval\n    if work_end_min - prev_end >= duration_min:\n        return (minutes_to_time(prev_end), \n                minutes_to_time(prev_end + duration_min))\n    \n    return None\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"12:00 to 12:30\", \"13:00 to 14:00\", \"14:30 to 15:00\"],  # Noah\n    [\"10:30 to 11:30\", \"12:30 to 13:00\", \"14:00 to 15:00\", \"16:00 to 16:30\"],  # Jesse\n    [\"10:00 to 10:30\", \"11:30 to 12:00\"],  # Amy\n    [\"9:30 to 10:30\", \"11:00 to 12:00\", \"12:30 to 13:30\", \"14:00 to 15:00\", \"15:30 to 16:30\"],  # Timothy\n    [\"9:00 to 11:00\", \"13:00 to 14:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"],  # Eugene\n    [\"9:00 to 10:00\", \"10:30 to 13:00\", \"13:30 to 15:00\", \"16:00 to 17:00\"],  # Theresa\n]\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, 30, \"9:00\", \"17:00\")\nif meeting_time:\n    print(f\"{meeting_time[0]}:{meeting_time[1]}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_385"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Define participants' schedules and constraints\n    schedules = {\n        'Bryan': [(9.5 * 60, 10 * 60), (13.5 * 60, 14.5 * 60), (15 * 60, 16.5 * 60)],\n        'Matthew': [(9 * 60, 9.5 * 60), (10.5 * 60, 12 * 60), (14 * 60, 14.5 * 60), (15.5 * 60, 16 * 60)],\n        'Margaret': [(9 * 60, 9.5 * 60), (10.5 * 60, 12 * 60), (12.5 * 60, 13 * 60), (13.5 * 60, 14.5 * 60), (15 * 60, 15.5 * 60)],\n        'Donald': [(9 * 60, 10 * 60), (10.5 * 60, 13.5 * 60), (14 * 60, 14.5 * 60), (15.5 * 60, 17 * 60)],\n        'Jason': [(9 * 60, 10 * 60), (12 * 60, 12.5 * 60), (13 * 60, 13.5 * 60), (15 * 60, 17 * 60)],\n    }\n    \n    # Jason's constraint: not before 10:30\n    jason_constraint = 10.5 * 60\n    \n    # Meeting duration in minutes\n    duration = 30\n    \n    # Collect all busy intervals\n    busy_intervals = []\n    for person, intervals in schedules.items():\n        for start, end in intervals:\n            busy_intervals.append((start, end))\n    \n    # Add Jason's constraint as a busy interval if needed\n    if jason_constraint > work_start:\n        busy_intervals.append((work_start, jason_constraint))\n    \n    # Sort intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find free slots\n    free_slots = []\n    previous_end = work_start\n    for start, end in merged:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Format the output as HH:MM:HH:MM\n            start_hh = int(meeting_start // 60)\n            start_mm = int(meeting_start % 60)\n            end_hh = int(meeting_end // 60)\n            end_mm = int(meeting_end % 60)\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_386"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(schedules, duration, start_hour, end_hour):\n    # Convert work hours to minutes\n    work_start = start_hour * 60\n    work_end = end_hour * 60\n    \n    # Initialize a list to track busy times for all participants\n    all_busy = []\n    \n    # Collect all busy intervals for each participant\n    for person in schedules:\n        for interval in schedules[person]:\n            start, end = interval\n            all_busy.append((start[0] * 60 + start[1], end[0] * 60 + end[1]))\n    \n    # Sort all busy intervals\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots between work hours and busy times\n    available = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n    \n    # Check each available slot for sufficient duration\n    for start, end in available:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time slot found\"\n\n# Define the schedules for each participant\nschedules = {\n    \"Bruce\": [\n        ((9, 0), (9, 30)),\n        ((10, 0), (11, 0)),\n        ((12, 30), (13, 0)),\n        ((14, 0), (14, 30)),\n        ((16, 0), (16, 30))\n    ],\n    \"Dorothy\": [],\n    \"Joyce\": [],\n    \"Jessica\": [\n        ((11, 30), (13, 0)),\n        ((13, 30), (14, 0)),\n        ((14, 30), (16, 30))\n    ],\n    \"Aaron\": [\n        ((9, 0), (10, 30)),\n        ((11, 30), (12, 0)),\n        ((13, 0), (13, 30)),\n        ((14, 30), (15, 30)),\n        ((16, 0), (16, 30))\n    ],\n    \"Kathryn\": [\n        ((9, 0), (9, 30)),\n        ((10, 0), (10, 30)),\n        ((12, 30), (14, 0)),\n        ((14, 30), (17, 0))\n    ]\n}\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\n# Work hours (9:00 to 17:00)\nstart_hour = 9\nend_hour = 17\n\n# Find the meeting time\nmeeting_time = find_meeting_time(schedules, duration, start_hour, end_hour)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_387"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours=('09:00', '17:00')):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    work_start, work_end = map(time_to_minutes, work_hours)\n    busy_slots = []\n\n    # Collect all busy slots from each participant\n    for schedule in participants_schedules.values():\n        for busy_start, busy_end in schedule:\n            start = time_to_minutes(busy_start)\n            end = time_to_minutes(busy_end)\n            busy_slots.append((start, end))\n\n    # Sort all busy slots by start time\n    busy_slots.sort()\n\n    # Merge overlapping or adjacent busy slots\n    merged_slots = []\n    for start, end in busy_slots:\n        if not merged_slots:\n            merged_slots.append([start, end])\n        else:\n            last_start, last_end = merged_slots[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                merged_slots[-1][1] = max(end, last_end)\n            else:\n                merged_slots.append([start, end])\n\n    # Find available slots between work hours and busy slots\n    available_slots = []\n    previous_end = work_start\n\n    for start, end in merged_slots:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n\n    # Find the first available slot that can fit the meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    'Amy': [],\n    'Karen': [('09:30', '10:00'), ('12:30', '13:00')],\n    'Mark': [('10:30', '11:30'), ('13:00', '13:30'), ('15:30', '16:00')],\n    'Madison': [('09:00', '12:00'), ('12:30', '13:30'), ('15:30', '16:00'), ('16:30', '17:00')],\n    'Michelle': [('09:00', '09:30'), ('10:00', '10:30'), ('11:00', '11:30'), ('12:00', '14:00'), ('14:30', '15:00'), ('15:30', '16:30')],\n    'Brandon': [('09:30', '15:00'), ('15:30', '17:00')],\n}\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_388"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    duration = 30        # meeting duration in minutes\n\n    # Convert each participant's busy slots to minutes since 9:00\n    busy_slots = {\n        'Debra': [(11*60, 11*60 + 30), (13*60 + 30, 14*60)],\n        'Sara': [],\n        'Theresa': [(13*60 + 30, 14*60), (15*60 + 30, 16*60)],\n        'Carol': [(9*60, 10*60), (11*60, 11*60 + 30), (12*60, 13*60 + 30), (15*60, 15*60 + 30), (16*60, 16*60 + 30)],\n        'Justin': [(9*60, 9*60 + 30), (10*60, 14*60), (14*60 + 30, 15*60 + 30), (16*60 + 30, 17*60)],\n        'Edward': [(9*60 + 30, 10*60 + 30), (11*60 + 30, 13*60), (13*60 + 30, 14*60), (16*60, 17*60)],\n    }\n\n    # Combine all busy slots and sort them\n    all_busy = []\n    for person in busy_slots.values():\n        all_busy.extend(person)\n    all_busy.sort()\n\n    # Find the earliest available slot\n    current_time = work_start\n    for start, end in all_busy:\n        if current_time + duration <= start:\n            # Found a slot\n            break\n        if end > current_time:\n            current_time = end\n    else:\n        # Check if there's time at the end of the day\n        if current_time + duration <= work_end:\n            pass\n        else:\n            return None  # No slot found (though the problem states there is one)\n\n    # Ensure the slot is within work hours and doesn't conflict with any busy times\n    # Double-check against all individual schedules\n    proposed_start = current_time\n    proposed_end = proposed_start + duration\n\n    for person in busy_slots.values():\n        for start, end in person:\n            if not (proposed_end <= start or proposed_start >= end):\n                # Conflict found, need to move to the next possible slot\n                return find_next_available_slot(all_busy, work_start, work_end, duration)\n\n    # Format the time as HH:MM:HH:MM\n    start_hh = proposed_start // 60\n    start_mm = proposed_start % 60\n    end_hh = proposed_end // 60\n    end_mm = proposed_end % 60\n\n    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\ndef find_next_available_slot(all_busy, work_start, work_end, duration):\n    current_time = work_start\n    for start, end in all_busy:\n        if current_time + duration <= start:\n            return current_time\n        if end > current_time:\n            current_time = end\n    if current_time + duration <= work_end:\n        return current_time\n    return None\n\nmeeting_time = find_meeting_time()\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_389"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration):\n    # Convert all time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 9:00 (0 minutes)\n    \n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Collect all busy times for all participants\n    all_busy_times = []\n    for busy_times in participants_busy_times.values():\n        for busy in busy_times:\n            start, end = busy.split(' to ')\n            all_busy_times.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort busy times by start time\n    all_busy_times.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = work_start\n    for start, end in all_busy_times:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' busy times\nparticipants_busy_times = {\n    \"Katherine\": [\"10:00 to 10:30\", \"11:00 to 11:30\", \"12:30 to 13:30\", \"15:00 to 15:30\", \"16:30 to 17:00\"],\n    \"Justin\": [\"9:00 to 10:30\", \"11:00 to 12:00\", \"12:30 to 13:30\", \"14:30 to 15:00\", \"15:30 to 16:30\"],\n    \"Abigail\": [\"10:30 to 11:00\", \"12:30 to 15:00\", \"15:30 to 16:30\"],\n    \"Kayla\": [\"9:30 to 10:00\", \"11:30 to 12:00\", \"12:30 to 14:00\", \"14:30 to 15:00\", \"15:30 to 16:30\"],\n}\n\n# Jason and Christopher have no meetings, so their busy times are empty\nparticipants_busy_times = {\n    \"Jason\": [],\n    \"Christopher\": [],\n    **participants_busy_times\n}\n\n# Work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nduration = 30  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy_times, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_390"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:30:16:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration_min = duration * 60\n    \n    # Generate all busy intervals for each participant\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration = 0.5  # in hours\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"10:00 to 10:30\", \"12:30 to 13:00\"],  # Bryan\n    [],                                    # Billy\n    [],                                    # Alexander\n    [\"9:00 to 13:00\", \"13:30 to 14:30\", \"15:00 to 15:30\", \"16:00 to 16:30\"],  # Sophia\n    [\"9:00 to 9:30\", \"10:30 to 11:30\", \"12:30 to 13:00\", \"13:30 to 14:00\", \"14:30 to 15:30\", \"16:30 to 17:00\"],  # Larry\n    [\"9:30 to 14:00\", \"14:30 to 15:00\"],  # Nicole\n]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_391"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - work_hours_start * 60\n\n    work_start_min = time_to_minutes(f\"{work_hours_start}:00\")\n    work_end_min = time_to_minutes(f\"{work_hours_end}:00\")\n    \n    # Initialize a list to track busy intervals for all participants\n    all_busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = busy.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            all_busy_intervals.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Find free intervals by inverting busy intervals\n    free_intervals = []\n    prev_end = work_start_min\n    for start, end in all_busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n    \n    # Merge overlapping or adjacent free intervals (not necessary here but good practice)\n    merged_free = []\n    for start, end in free_intervals:\n        if not merged_free:\n            merged_free.append([start, end])\n        else:\n            last_start, last_end = merged_free[-1]\n            if start <= last_end:\n                merged_free[-1] = [last_start, max(last_end, end)]\n            else:\n                merged_free.append([start, end])\n    \n    # Find the first free interval that can accommodate the meeting\n    for start, end in merged_free:\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                total_hh = (minutes + work_hours_start * 60) // 60\n                total_mm = (minutes + work_hours_start * 60) % 60\n                return f\"{total_hh:02d}:{total_mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    return \"No suitable time found\"\n\n# Define work hours and meeting duration\nwork_hours_start = 9\nwork_hours_end = 17\nduration_minutes = 30\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"11:30 to 12:30\", \"14:00 to 14:30\", \"15:30 to 16:00\"],  # Donald\n    [\"10:30 to 11:00\", \"13:00 to 14:00\", \"15:00 to 16:00\", \"16:30 to 17:00\"],  # Alice\n    [\"10:30 to 11:00\", \"12:00 to 12:30\", \"13:00 to 14:00\", \"16:00 to 17:00\"],  # Doris\n    [\"9:00 to 9:30\", \"10:00 to 11:00\", \"12:00 to 12:30\", \"13:00 to 14:00\", \"15:00 to 15:30\", \"16:30 to 17:00\"],  # Jesse\n    [\"9:00 to 11:00\", \"11:30 to 13:00\", \"13:30 to 17:00\"],  # Noah\n    [\"9:00 to 9:30\", \"10:00 to 11:00\", \"12:00 to 12:30\", \"14:30 to 15:00\", \"15:30 to 17:00\"],  # Jerry\n]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_392"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:00:12:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval to see if it can accommodate the meeting\n    meeting_duration_min = meeting_duration * 60\n    for start, end in free_intervals:\n        if end - start >= meeting_duration_min:\n            # Check if all participants are free during this interval\n            all_free = True\n            meeting_start = start\n            meeting_end = start + meeting_duration_min\n            \n            for schedule in participants_schedules:\n                participant_free = True\n                for busy in schedule:\n                    busy_start, busy_end = map(time_to_minutes, busy.split(':'))\n                    if not (meeting_end <= busy_start or meeting_start >= busy_end):\n                        participant_free = False\n                        break\n                if not participant_free:\n                    all_free = False\n                    break\n            \n            if all_free:\n                return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Samantha is free\n    [\"9:00:9:30\", \"11:00:11:30\"],  # Nancy\n    [],  # Steven is free\n    [\"11:00:12:00\", \"13:00:13:30\", \"14:00:16:30\"],  # William\n    [\"9:00:12:00\", \"12:30:13:00\", \"13:30:17:00\"],  # Karen\n    [\"9:00:11:00\", \"11:30:12:00\", \"12:30:13:00\", \"13:30:15:00\", \"15:30:17:00\"],  # Tyler\n]\n\n# Find a meeting time\nmeeting_time = find_meeting_time(participants_schedules, \"9:00\", \"17:00\", 0.5)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_393"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours=('09:00', '17:00')):\n    # Convert work hours to minutes\n    start_work = int(work_hours[0].split(':')[0]) * 60 + int(work_hours[0].split(':')[1])\n    end_work = int(work_hours[1].split(':')[0]) * 60 + int(work_hours[1].split(':')[1])\n    \n    # Initialize busy slots for all participants\n    busy_slots = []\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        participant_busy = []\n        for meeting in schedule:\n            start, end = meeting.split(' to ')\n            start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n            end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n            participant_busy.append((start_min, end_min))\n        busy_slots.append(participant_busy)\n    \n    # Find common free slots\n    for time in range(start_work, end_work - duration_minutes + 1):\n        end_time = time + duration_minutes\n        all_free = True\n        for participant in busy_slots:\n            is_free = True\n            for start, end in participant:\n                if not (end_time <= start or time >= end):\n                    is_free = False\n                    break\n            if not is_free:\n                all_free = False\n                break\n        if all_free:\n            # Format the time as HH:MM\n            start_hh = time // 60\n            start_mm = time % 60\n            end_hh = end_time // 60\n            end_mm = end_time % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Nicole\n    [],  # Randy\n    [\"10:00 to 11:00\"],  # Michelle\n    [\"09:00 to 10:30\", \"11:00 to 11:30\", \"12:00 to 13:30\", \"14:00 to 15:30\"],  # Matthew\n    [\"10:00 to 11:00\", \"11:30 to 12:00\", \"13:00 to 13:30\", \"14:30 to 16:00\", \"16:30 to 17:00\"],  # Andrea\n    [\"09:00 to 09:30\", \"10:30 to 13:30\", \"14:00 to 14:30\", \"15:00 to 17:00\"]  # Douglas\n]\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules))\n```",
            "count": "calendar_scheduling_example_394"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration_minutes):\n    # Convert work hours and busy times to minutes for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Generate all possible time slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + duration_minutes <= work_end:\n        possible_slots.append((current_time, current_time + duration_minutes))\n        current_time += 1  # Check every minute\n    \n    # Check each slot against all participants' busy times\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        valid = True\n        for busy_times in participants_busy_times:\n            for busy_start, busy_end in busy_times:\n                busy_start_min = busy_start[0] * 60 + busy_start[1]\n                busy_end_min = busy_end[0] * 60 + busy_end[1]\n                # Check if slot overlaps with any busy time\n                if not (slot_end <= busy_start_min or slot_start >= busy_end_min):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            # Convert the slot back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No available slot found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (9, 17)\n\n# Define each participant's busy times in HH:MM format\nparticipants_busy_times = [\n    # Jonathan's busy times\n    [\n        ((9, 0), (9, 30)),\n        ((10, 30), (11, 0)),\n        ((13, 0), (13, 30)),\n        ((15, 30), (16, 0))\n    ],\n    # George's busy times\n    [\n        ((9, 0), (9, 30)),\n        ((10, 0), (10, 30)),\n        ((11, 30), (12, 30)),\n        ((15, 0), (15, 30)),\n        ((16, 30), (17, 0))\n    ],\n    # Stephen's busy times\n    [\n        ((9, 0), (9, 30)),\n        ((10, 0), (11, 0)),\n        ((11, 30), (12, 0)),\n        ((12, 30), (13, 0)),\n        ((13, 30), (14, 0)),\n        ((15, 0), (17, 0))\n    ],\n    # Betty's busy times\n    [\n        ((9, 0), (10, 0)),\n        ((10, 30), (11, 0)),\n        ((11, 30), (12, 30)),\n        ((13, 30), (14, 0)),\n        ((15, 0), (16, 0))\n    ],\n    # Frank's busy times\n    [\n        ((9, 0), (11, 30)),\n        ((12, 0), (14, 30)),\n        ((15, 0), (17, 0))\n    ]\n]\n\n# Meeting duration in minutes\nduration = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_395"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to make 9:00 as 0\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Initialize the busy slots for all participants\n    busy_slots = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = busy.split(' to ')\n            busy_start = time_to_minutes(start)\n            busy_end = time_to_minutes(end)\n            busy_slots.append((busy_start, busy_end))\n    \n    # Sort all busy slots by start time\n    busy_slots.sort()\n    \n    # Merge overlapping or adjacent busy slots\n    merged = []\n    for start, end in busy_slots:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy slots and work hours\n    available_slots = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Check each available slot for sufficient duration\n    for slot in available_slots:\n        start, end = slot\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Andrea\n    [\"9:00 to 9:30\", \"14:00 to 14:30\"],  # Jack\n    [\"9:30 to 10:30\", \"13:00 to 14:00\", \"15:00 to 15:30\", \"16:30 to 17:00\"],  # Madison\n    [\"9:30 to 10:30\", \"11:00 to 11:30\", \"12:00 to 13:30\", \"14:30 to 15:30\", \"16:00 to 17:00\"],  # Rachel\n    [\"9:00 to 11:30\", \"12:00 to 16:30\"],  # Douglas\n    [\"9:00 to 9:30\", \"13:00 to 14:00\", \"14:30 to 17:00\"],  # Ryan\n]\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nmeeting_duration = 30  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, meeting_duration))\n```",
            "count": "calendar_scheduling_example_396"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert work hours and schedules to minutes for easier calculation\n    work_start, work_end = work_hours\n    work_start_min = work_start[0] * 60 + work_start[1]\n    work_end_min = work_end[0] * 60 + work_end[1]\n    \n    # Initialize the free slots for all participants\n    free_slots = []\n    for participant in participants_schedules:\n        busy_slots = participants_schedules[participant]\n        participant_free = []\n        prev_end = work_start_min\n        \n        for slot in busy_slots:\n            slot_start = slot[0][0] * 60 + slot[0][1]\n            slot_end = slot[1][0] * 60 + slot[1][1]\n            \n            if prev_end < slot_start:\n                participant_free.append((prev_end, slot_start))\n            prev_end = max(prev_end, slot_end)\n        \n        if prev_end < work_end_min:\n            participant_free.append((prev_end, work_end_min))\n        \n        free_slots.append(participant_free)\n    \n    # Find common free slots across all participants\n    common_free = free_slots[0]\n    for participant_free in free_slots[1:]:\n        new_common_free = []\n        i = j = 0\n        while i < len(common_free) and j < len(participant_free):\n            start = max(common_free[i][0], participant_free[j][0])\n            end = min(common_free[i][1], participant_free[j][1])\n            if start < end:\n                new_common_free.append((start, end))\n            if common_free[i][1] < participant_free[j][1]:\n                i += 1\n            else:\n                j += 1\n        common_free = new_common_free\n    \n    # Find the first slot that can fit the meeting duration\n    for slot in common_free:\n        if slot[1] - slot[0] >= duration:\n            start_hour = slot[0] // 60\n            start_min = slot[0] % 60\n            end_hour = (slot[0] + duration) // 60\n            end_min = (slot[0] + duration) % 60\n            return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n    return \"No suitable time found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours = ((9, 0), (17, 0))\n\n# Define participants' schedules in minutes\nparticipants = {\n    \"Jonathan\": [],\n    \"Matthew\": [((10, 0), (10, 30)), ((14, 0), (14, 30)), ((15, 0), (15, 30)), ((16, 0), (16, 30))],\n    \"Carl\": [((9, 30), (10, 0)), ((13, 30), (14, 0))],\n    \"Ryan\": [((9, 30), (11, 0)), ((11, 30), (12, 30)), ((13, 0), (13, 30)), ((15, 0), (16, 0))],\n    \"Albert\": [((9, 0), (9, 30)), ((10, 0), (12, 30)), ((13, 0), (15, 30)), ((16, 0), (16, 30))],\n    \"Danielle\": [((9, 0), (9, 30)), ((10, 30), (11, 30)), ((12, 30), (14, 30)), ((15, 0), (15, 30))],\n}\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\n\n# Find and print the meeting time\nprint(find_meeting_time(participants, duration, work_hours))\n```",
            "count": "calendar_scheduling_example_397"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:13:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between merged intervals and work hours\n    available_slots = []\n    previous_end = work_start\n    \n    for start, end in merged:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy interval\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    duration = duration_minutes\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"9:00:11:00\", \"13:30:14:00\", \"16:00:16:30\"],  # Doris\n    [\"10:00:12:00\"],                                # Theresa\n    [],                                             # Christian\n    [\"9:30:10:00\", \"11:30:12:00\", \"12:30:13:00\", \"13:30:14:00\", \"14:30:15:00\", \"15:30:17:00\"],  # Terry\n    [\"9:00:10:30\", \"11:00:11:30\", \"12:00:13:00\", \"13:30:14:30\", \"15:00:17:00\"],  # Carolyn\n    [\"9:00:9:30\", \"11:30:12:00\", \"12:30:13:00\", \"14:30:17:00\"]  # Kyle\n]\n\n# Find a 30-minute meeting slot between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, \"9:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_398"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy times to minutes since midnight\n    busy_slots = {\n        'Andrew': [(11 * 60, 11 * 60 + 30), (15 * 60 + 30, 16 * 60)],\n        'Lawrence': [(9 * 60 + 30, 10 * 60), (11 * 60 + 30, 12 * 60)],\n        'Olivia': [(9 * 60, 10 * 60), (11 * 60, 12 * 60), (12 * 60 + 30, 13 * 60 + 30), (14 * 60 + 30, 15 * 60), (16 * 60, 16 * 60 + 30)],\n        'Bruce': [(9 * 60, 11 * 60 + 30), (12 * 60, 13 * 60), (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 16 * 60 + 30)],\n        'Joyce': [(9 * 60 + 30, 12 * 60 + 30), (13 * 60 + 30, 14 * 60 + 30), (15 * 60 + 30, 16 * 60 + 30)],\n    }\n\n    # Combine all busy slots\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n    all_busy.sort()\n\n    # Merge overlapping or adjacent busy slots\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n\n    # Find free slots between work hours and busy times\n    free_slots = []\n    previous_end = work_start\n    for start, end in merged_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can fit the meeting\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_399"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert work hours and busy times to minutes\n    start_work, end_work = work_hours\n    work_start_min = start_work[0] * 60 + start_work[1]\n    work_end_min = end_work[0] * 60 + end_work[1]\n    \n    # Initialize the free slots for the day\n    free_slots = []\n    current_start = work_start_min\n    \n    # Generate all possible busy times across all participants\n    all_busy = []\n    for busy in participants_busy:\n        for slot in busy:\n            start = slot[0][0] * 60 + slot[0][1]\n            end = slot[1][0] * 60 + slot[1][1]\n            all_busy.append((start, end))\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy slots\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Find free slots between merged busy times\n    free_slots = []\n    prev_end = work_start_min\n    for start, end in merged_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        free_slots.append((prev_end, work_end_min))\n    \n    # Check each free slot for duration availability\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            # Convert back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = (slot_start + duration) // 60\n            end_mm = (slot_start + duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return None\n\n# Define work hours (9:00 to 17:00)\nwork_hours = ((9, 0), (17, 0))\n\n# Define busy slots for each participant in HH:MM format\nparticipants_busy = [\n    # Rachel is free\n    [],\n    # Katherine: 10:00-11:00, 12:30-13:00, 14:00-15:00, 16:00-16:30\n    [((10, 0), (11, 0)), ((12, 30), (13, 0)), ((14, 0), (15, 0)), ((16, 0), (16, 30))],\n    # Kelly: 11:30-12:30, 13:00-14:30, 16:00-16:30\n    [((11, 30), (12, 30)), ((13, 0), (14, 30)), ((16, 0), (16, 30))],\n    # Cynthia: 13:30-14:00, 14:30-15:30, 16:00-16:30\n    [((13, 30), (14, 0)), ((14, 30), (15, 30)), ((16, 0), (16, 30))],\n    # Anthony: 9:00-11:00, 12:00-17:00\n    [((9, 0), (11, 0)), ((12, 0), (17, 0))],\n    # Ryan: 9:00-11:00, 12:30-13:30, 14:00-14:30, 15:00-16:30\n    [((9, 0), (11, 0)), ((12, 30), (13, 30)), ((14, 0), (14, 30)), ((15, 0), (16, 30))],\n    # Richard: 9:30-10:30, 12:00-13:30, 15:30-17:00\n    [((9, 30), (10, 30)), ((12, 0), (13, 30)), ((15, 30), (17, 0))]\n]\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_400"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Define busy intervals for each participant in minutes since midnight\n    busy_times = {\n        'Evelyn': [(9 * 60 + 30, 10 * 60), (11 * 60 + 30, 12 * 60)],\n        'Gregory': [(10 * 60, 10 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Vincent': [(10 * 60, 10 * 60 + 30), (11 * 60, 12 * 60), (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60), (15 * 60, 16 * 60 + 30)],\n        'Philip': [(9 * 60, 10 * 60 + 30), (11 * 60, 11 * 60 + 30), (12 * 60, 13 * 60), (15 * 60, 17 * 60)],\n        'William': [(9 * 60, 10 * 60), (11 * 60, 13 * 60), (13 * 60 + 30, 14 * 60 + 30), (15 * 60, 17 * 60)],\n    }\n\n    # William's preference: not after 13:30 (13 * 60 + 30)\n    william_preference_end = 13 * 60 + 30\n\n    # Generate all busy intervals\n    all_busy = []\n    for person in busy_times:\n        for start, end in busy_times[person]:\n            all_busy.append((start, end))\n\n    # Add William's preference as a constraint\n    all_busy.append((william_preference_end, work_end))\n\n    # Sort all busy intervals\n    all_busy.sort()\n\n    # Find free slots\n    free_slots = []\n    prev_end = work_start\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n\n    # Check for a 30-minute slot\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Found a suitable slot\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_401"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:30:15:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        person_busy = []\n        for block in schedule:\n            start, end = map(time_to_minutes, block.split(':'))\n            person_busy.append((start, end))\n        busy_intervals.append(person_busy)\n    \n    # Find all possible meeting start times (every minute in work hours)\n    possible_starts = []\n    for start in range(work_start, work_end - duration + 1):\n        end = start + duration\n        valid = True\n        # Check against each participant's busy intervals\n        for person_busy in busy_intervals:\n            for busy_start, busy_end in person_busy:\n                if not (end <= busy_start or start >= busy_end):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            possible_starts.append(start)\n    \n    if not possible_starts:\n        return \"No available time slot found.\"\n    \n    # Select the earliest possible start time\n    meeting_start = possible_starts[0]\n    meeting_end = meeting_start + duration\n    \n    return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"11:00:11:30\", \"13:00:13:30\", \"15:30:16:00\", \"16:30:17:00\"],  # Samantha\n    [],  # Brian\n    [\"13:30:14:00\", \"16:00:16:30\"],  # Arthur\n    [],  # Matthew\n    [\"09:00:10:00\", \"10:30:11:30\", \"12:00:13:00\", \"14:00:14:30\", \"16:00:16:30\"],  # Marilyn\n    [\"09:30:11:00\", \"11:30:13:30\", \"14:00:14:30\", \"15:00:16:00\"],  # Mark\n    [\"09:30:11:00\", \"11:30:14:30\", \"15:00:15:30\"],  # Andrea\n]\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, \"09:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_402"
        },
        {
            "final_program_time": "{13:00:13:01}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, meeting_duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 9:00 (0 minutes)\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes  # Add back 540 to get actual time\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    # Parse work hours\n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n\n    # Initialize a list to mark busy times\n    time_slots = [False] * (work_end - work_start)\n    \n    # Mark busy times for each participant\n    for participant, schedules in participants_schedules.items():\n        for meeting in schedules:\n            start, end = meeting.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            # Mark all slots in this meeting as busy\n            for i in range(start_min, end_min):\n                if i < len(time_slots):\n                    time_slots[i] = True\n\n    # Find a free slot of meeting_duration (30 minutes)\n    required_slots = meeting_duration // 30\n    current_free = 0\n    for i in range(len(time_slots)):\n        if not time_slots[i]:\n            current_free += 1\n            if current_free >= required_slots:\n                start_slot = i - required_slots + 1\n                start_time = minutes_to_time(start_slot)\n                end_time = minutes_to_time(start_slot + required_slots)\n                return f\"{start_time}:{end_time}\"\n        else:\n            current_free = 0\n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    'Wayne': ['14:30 to 15:00', '15:30 to 16:00'],\n    'Edward': [],\n    'Lauren': [],\n    'Helen': [],\n    'Michael': ['9:00 to 10:00', '10:30 to 11:30', '12:00 to 13:00', '13:30 to 14:30', '16:00 to 17:00'],\n    'Joseph': ['9:00 to 12:00', '14:00 to 14:30', '15:30 to 16:00'],\n    'Vincent': ['9:00 to 10:30', '11:30 to 13:00', '13:30 to 14:00', '14:30 to 17:00'],\n}\n\nwork_hours = '9:00 to 17:00'\nmeeting_duration = 30  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, meeting_duration))\n```",
            "count": "calendar_scheduling_example_403"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:14:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration_min = duration * 60\n\n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n\n    # Process each participant's schedule to find common free slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_slots.append((start, end))\n        # Sort busy slots by start time\n        busy_slots.sort()\n\n        # Merge overlapping or adjacent busy slots\n        merged_busy = []\n        for start, end in busy_slots:\n            if not merged_busy:\n                merged_busy.append((start, end))\n            else:\n                last_start, last_end = merged_busy[-1]\n                if start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged_busy[-1] = (new_start, new_end)\n                else:\n                    merged_busy.append((start, end))\n\n        # Calculate free slots for this participant\n        participant_free = []\n        prev_end = work_start\n        for start, end in merged_busy:\n            if start > prev_end:\n                participant_free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            participant_free.append((prev_end, work_end))\n\n        # Intersect with current free slots\n        new_free_slots = []\n        i = j = 0\n        while i < len(free_slots) and j < len(participant_free):\n            fs_start, fs_end = free_slots[i]\n            pf_start, pf_end = participant_free[j]\n\n            # Find the overlap\n            overlap_start = max(fs_start, pf_start)\n            overlap_end = min(fs_end, pf_end)\n            if overlap_start < overlap_end:\n                new_free_slots.append((overlap_start, overlap_end))\n\n            # Move the pointer which ends first\n            if fs_end < pf_end:\n                i += 1\n            else:\n                j += 1\n\n        free_slots = new_free_slots\n        if not free_slots:\n            return None  # No possible slot\n\n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= duration_min:\n            meeting_end = start + duration_min\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n\n    return None  # No suitable slot found\n\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"09:00:10:00\", \"14:30:15:00\", \"15:30:16:00\"],  # Kayla\n    [\"12:00:12:30\", \"14:00:15:00\", \"16:30:17:00\"],  # Sandra\n    [\"09:30:10:30\", \"11:00:11:30\", \"12:30:13:00\"],  # Ryan\n    [],  # Kathleen\n    [\"09:30:12:00\", \"14:00:14:30\", \"15:00:17:00\"],  # Walter\n    [\"09:00:11:00\", \"11:30:12:00\", \"12:30:13:00\", \"14:00:15:00\"],  # Arthur\n    [\"10:00:11:30\", \"12:00:13:00\", \"14:30:15:30\", \"16:30:17:00\"],  # Heather\n]\n\n# Find a meeting time\nmeeting_time = find_meeting_time(participants_schedules, \"09:00\", \"17:00\", 1)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_404"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:30:16:00}",
            "type_error": "TypeError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_hour, end_hour = work_hours\n    # Convert work hours to minutes for easier calculation\n    start_time = start_hour * 60\n    end_time = end_hour * 60\n    duration_min = duration * 60\n    \n    # Initialize a list to keep track of busy times for all participants\n    busy_times = []\n    \n    for schedule in participants_schedules:\n        personal_busy = []\n        for block in schedule:\n            start_block = block[0] * 60 + block[1]\n            end_block = block[2] * 60 + block[3]\n            personal_busy.append((start_block, end_block))\n        busy_times.append(personal_busy)\n    \n    # Check all possible time slots within work hours\n    for time in range(start_time, end_time - duration_min + 1, 15):  # Check in 15-minute increments\n        end_slot = time + duration_min\n        slot_ok = True\n        for personal_busy in busy_times:\n            for (busy_start, busy_end) in personal_busy:\n                if not (end_slot <= busy_start or time >= busy_end):\n                    slot_ok = False\n                    break\n            if not slot_ok:\n                break\n        if slot_ok:\n            # Convert back to HH:MM format\n            start_hh = time // 60\n            start_mm = time % 60\n            end_hh = end_slot // 60\n            end_mm = end_slot % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No suitable time found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (9, 17)\n\n# Define meeting duration (0.5 hours)\nduration = 0.5\n\n# Define participants' schedules in HH, MM, HH, MM format\nparticipants_schedules = [\n    # Emily\n    [(9, 0, 9, 30), (11, 0, 11, 30), (14, 0, 14, 30), (16, 30, 17, 0)],\n    # Brian\n    [(9, 30, 10, 0), (14, 30, 15, 30), (16, 30, 17, 0)],\n    # Gerald (free)\n    [],\n    # Julia (free)\n    [],\n    # Logan\n    [(9, 0, 10, 0), (11, 0, 14, 0), (16, 0, 17, 0)],\n    # Judith\n    [(9, 0, 11, 0), (11, 30, 13, 0), (15, 0, 15, 30), (16, 0, 17, 0)],\n    # Michael\n    [(9, 0, 9, 30), (10, 0, 11, 0), (11, 30, 12, 30), (13, 0, 15, 30), (16, 0, 17, 0)],\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_405"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 (9:00)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    work_start, work_end = map(time_to_minutes, work_hours.split(' to '))\n    \n    # Collect all busy intervals\n    busy_intervals = []\n    for schedule in participants_schedules.values():\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_end = max(end, last_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find the first available slot\n    prev_end = work_start\n    for start, end in merged:\n        if start - prev_end >= duration:\n            meeting_start = prev_end\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n        prev_end = max(prev_end, end)\n    \n    # Check after last busy interval\n    if work_end - prev_end >= duration:\n        meeting_start = prev_end\n        meeting_end = meeting_start + duration\n        return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"Alan\": [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:00 to 12:30\", \"14:00 to 14:30\"],\n    \"Michael\": [],\n    \"Michelle\": [],\n    \"Roy\": [\"9:30 to 10:00\", \"12:30 to 13:00\", \"13:30 to 14:30\"],\n    \"Judy\": [\"9:00 to 10:30\", \"11:00 to 15:30\", \"16:00 to 17:00\"],\n    \"Natalie\": [\"9:00 to 9:30\", \"11:00 to 12:30\", \"13:00 to 17:00\"],\n    \"Brian\": [\"9:30 to 10:30\", \"11:00 to 12:00\", \"13:30 to 14:00\", \"14:30 to 15:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"]\n}\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_hours = \"9:00 to 17:00\"\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_406"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define busy intervals for each participant in minutes\n    busy_times = {\n        'Alice': [],\n        'Daniel': [(10 * 60, 10 * 60 + 30), (15 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Scott': [(9 * 60, 10 * 60), (12 * 60, 13 * 60), (14 * 60, 14 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Lori': [(12 * 60 + 30, 13 * 60), (16 * 60, 16 * 60 + 30)],\n        'Cynthia': [(9 * 60, 9 * 60 + 30), (11 * 60, 11 * 60 + 30), (12 * 60, 13 * 60), \n                    (13 * 60 + 30, 14 * 60 + 30), (15 * 60 + 30, 16 * 60 + 30)],\n        'Jeffrey': [(9 * 60, 11 * 60 + 30), (12 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Hannah': [(9 * 60, 11 * 60), (12 * 60, 12 * 60 + 30), (13 * 60, 15 * 60), (16 * 60 + 30, 17 * 60)],\n    }\n    \n    # Collect all busy intervals from all participants\n    all_busy = []\n    for person in busy_times:\n        all_busy.extend(busy_times[person])\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by checking gaps between busy intervals\n    free_intervals = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the interval after the last busy interval\n    if previous_end < work_end:\n        free_intervals.append((previous_end, work_end))\n    \n    # Find the first free interval that can accommodate a 30-minute meeting\n    meeting_duration = 30\n    for start, end in free_intervals:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_407"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:13:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_start, work_end, duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Collect all busy intervals for all participants\n    all_busy_intervals = []\n    for busy_times in participants_busy_times.values():\n        for interval in busy_times:\n            start, end = interval.split(' to ')\n            all_busy_intervals.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start_min\n    \n    for start, end in all_busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n    \n    # Find the first free interval that can accommodate the meeting\n    for interval in free_intervals:\n        start, end = interval\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return None\n\n# Define the participants' busy times\nparticipants_busy_times = {\n    \"Noah\": [],\n    \"Teresa\": [\"11:00 to 12:00\", \"14:00 to 15:00\", \"16:00 to 17:00\"],\n    \"Bradley\": [\"9:00 to 9:30\", \"10:00 to 10:30\", \"15:00 to 15:30\", \"16:00 to 16:30\"],\n    \"Philip\": [\"9:00 to 9:30\", \"11:30 to 12:00\", \"12:30 to 13:00\", \"16:30 to 17:00\"],\n    \"Joyce\": [\"9:30 to 10:00\", \"11:30 to 12:30\", \"13:30 to 14:30\", \"15:30 to 17:00\"],\n    \"Ryan\": [\"9:00 to 10:30\", \"11:00 to 11:30\", \"14:00 to 17:00\"],\n    \"Aaron\": [\"10:00 to 12:00\", \"14:00 to 14:30\", \"15:00 to 16:30\"],\n}\n\n# Define work hours and meeting duration\nwork_start = \"9:00\"\nwork_end = \"17:00\"\nduration = 0.5  # half an hour\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_start, work_end, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_408"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each person's busy slots to minutes\n    alan_busy = [(9*60, 9*60+30), (10*60, 11*60), (11*60+30, 12*60)]\n    mason_busy = [(13*60+30, 14*60), (16*60+30, 17*60)]\n    dennis_busy = [(9*60, 9*60+30), (14*60+30, 15*60)]\n    brenda_busy = [(10*60+30, 11*60), (12*60, 13*60+30), (14*60+30, 15*60+30), (16*60, 17*60)]\n    juan_busy = [(9*60+30, 10*60), (10*60+30, 11*60), (11*60+30, 13*60), (14*60+30, 15*60), (16*60, 17*60)]\n    angela_busy = [(9*60, 10*60), (10*60+30, 11*60), (11*60+30, 12*60), (13*60, 14*60), (15*60, 15*60+30), (16*60+30, 17*60)]\n    \n    # Theresa is free all day\n    \n    # Combine all busy slots\n    all_busy = alan_busy + mason_busy + dennis_busy + brenda_busy + juan_busy + angela_busy\n    \n    # Generate free slots by finding gaps between busy slots\n    all_busy_sorted = sorted(all_busy, key=lambda x: x[0])\n    \n    # Initialize free slots\n    free_slots = []\n    prev_end = work_start\n    \n    for busy_start, busy_end in all_busy_sorted:\n        if busy_start > prev_end:\n            free_slots.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n    \n    # Check the end of the day\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Find the first free slot that is at least 30 minutes and meets Mason's preference (before 14:00)\n    meeting_duration = 30\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Check Mason's preference (meeting should end by 14:00)\n            if slot_start + meeting_duration <= 14 * 60:\n                # Format the time as HH:MM:HH:MM\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_hh = (slot_start + meeting_duration) // 60\n                end_mm = (slot_start + meeting_duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    # If no slot before 14:00, find any slot (though problem states solution exists)\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = (slot_start + meeting_duration) // 60\n            end_mm = (slot_start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_409"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Participants' busy times in minutes (start, end)\n    busy_times = {\n        'David': [(9 * 60, 9 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Robert': [(9 * 60 + 30, 10 * 60), (13 * 60, 13 * 60 + 30)],\n        'Christine': [(9 * 60, 10 * 60), (13 * 60, 13 * 60 + 30), (14 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Kelly': [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60), (12 * 60, 12 * 60 + 30), (13 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60)],\n        'Paul': [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 11 * 60), (11 * 60 + 30, 12 * 60), (13 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30), (15 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n    }\n    \n    # Paul's preference: avoid after 11:00 (11 * 60)\n    paul_preference_cutoff = 11 * 60\n    \n    # Collect all busy slots\n    all_busy = []\n    for person in busy_times:\n        for start, end in busy_times[person]:\n            all_busy.append((start, end))\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by merging busy intervals\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Filter free slots that are at least 30 minutes and before Paul's cutoff\n    meeting_duration = 30\n    valid_slots = []\n    \n    for start, end in free_slots:\n        if end - start >= meeting_duration and start < paul_preference_cutoff:\n            valid_slots.append((start, end))\n    \n    # If no slots before Paul's cutoff, look after (though not preferred)\n    if not valid_slots:\n        for start, end in free_slots:\n            if end - start >= meeting_duration:\n                valid_slots.append((start, end))\n    \n    # Select the earliest possible slot\n    if valid_slots:\n        best_start = valid_slots[0][0]\n        best_end = best_start + meeting_duration\n    else:\n        return None\n    \n    # Convert to HH:MM format\n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n    \n    start_time = minutes_to_time(best_start)\n    end_time = minutes_to_time(best_end)\n    \n    return f\"{start_time}:{end_time}\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_410"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each participant's busy slots to minutes\n    busy_slots = {\n        'Edward': [(11*60 + 30, 12*60), (16*60, 16*60 + 30)],\n        'Samantha': [(14*60, 14*60 + 30), (15*60, 15*60 + 30), (16*60, 17*60)],\n        'Jacob': [(11*60 + 30, 13*60 + 30), (16*60, 17*60)],\n        'Vincent': [(9*60 + 30, 10*60), (11*60, 11*60 + 30), (12*60, 12*60 + 30), \n                    (13*60, 13*60 + 30), (15*60, 15*60 + 30), (16*60 + 30, 17*60)],\n        'William': [(9*60, 14*60), (14*60 + 30, 15*60 + 30), (16*60, 17*60)],\n        'Alexander': [(9*60, 10*60 + 30), (11*60, 13*60 + 30), (14*60 + 30, 15*60 + 30), \n                      (16*60, 17*60)],\n        'Dylan': [(9*60 + 30, 12*60), (12*60 + 30, 14*60 + 30), (15*60, 15*60 + 30), \n                  (16*60, 17*60)],\n    }\n    \n    # Combine all busy slots\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n    all_busy.sort()\n    \n    # Find free slots by inverting busy slots\n    free_slots = []\n    prev_end = work_start\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Find the first free slot that can fit 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = (start + meeting_duration) // 60\n            end_mm = (start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_411"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration_min = duration * 60\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration_min:\n            meeting_end = start + duration_min\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"11:30 to 12:00\", \"13:30 to 14:00\", \"15:00 to 15:30\", \"16:00 to 16:30\"],  # Douglas\n    [],                                                                         # Susan\n    [],                                                                         # Donna\n    [\"09:00 to 09:30\", \"12:30 to 13:00\", \"13:30 to 14:00\", \"15:00 to 15:30\"],  # Elizabeth\n    [\"09:00 to 09:30\", \"10:00 to 11:00\", \"11:30 to 12:00\", \"13:00 to 13:30\", \"14:30 to 15:00\", \"15:30 to 16:30\"],  # Ralph\n    [\"09:00 to 10:00\", \"11:30 to 12:30\", \"13:00 to 14:00\", \"14:30 to 15:00\", \"16:00 to 16:30\"],  # Paul\n    [\"09:00 to 09:30\", \"10:00 to 10:30\", \"12:30 to 14:30\", \"15:00 to 15:30\", \"16:30 to 17:00\"],  # Ryan\n]\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, \"09:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_412"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert all time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work_hours start at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = 9 + minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    start_work = time_to_minutes(work_hours[0])\n    end_work = time_to_minutes(work_hours[1])\n    \n    # Initialize a list to track busy intervals for all participants\n    all_busy = []\n    for busy_slots in participants_busy.values():\n        for slot in busy_slots:\n            start = time_to_minutes(slot[0])\n            end = time_to_minutes(slot[1])\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Check for available slots before the first busy interval\n    if merged and merged[0][0] > start_work:\n        available_start = start_work\n        available_end = merged[0][0]\n        if available_end - available_start >= duration:\n            return f\"{minutes_to_time(available_start)}:{minutes_to_time(available_start + duration)}\"\n    \n    # Check for available slots between busy intervals\n    for i in range(1, len(merged)):\n        prev_end = merged[i-1][1]\n        curr_start = merged[i][0]\n        if curr_start - prev_end >= duration:\n            return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + duration)}\"\n    \n    # Check for available slots after the last busy interval\n    if merged and merged[-1][1] < end_work:\n        available_start = merged[-1][1]\n        available_end = end_work\n        if available_end - available_start >= duration:\n            return f\"{minutes_to_time(available_start)}:{minutes_to_time(available_start + duration)}\"\n    \n    # If no busy intervals, the whole day is available\n    if not merged:\n        return f\"{work_hours[0]}:{minutes_to_time(time_to_minutes(work_hours[0]) + duration)}\"\n    \n    return \"No available slot found\"\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 30  # minutes\n\n# Define each participant's busy times\nparticipants_busy = {\n    \"Carl\": [],\n    \"Patrick\": [(\"9:00\", \"9:30\"), (\"11:30\", \"12:00\")],\n    \"Thomas\": [],\n    \"Bryan\": [(\"9:30\", \"10:00\"), (\"12:30\", \"13:00\"), (\"15:00\", \"15:30\"), (\"16:00\", \"16:30\")],\n    \"Matthew\": [(\"9:30\", \"11:00\"), (\"11:30\", \"13:30\"), (\"14:00\", \"14:30\"), (\"15:00\", \"16:00\")],\n    \"Bruce\": [(\"9:00\", \"10:00\"), (\"10:30\", \"11:30\"), (\"12:30\", \"16:30\")],\n    \"William\": [(\"10:00\", \"12:00\"), (\"12:30\", \"13:00\"), (\"14:00\", \"14:30\"), (\"15:30\", \"16:30\")],\n}\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_413"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define each participant's busy times in minutes (start, end)\n    evelyn_busy = [(9*60, 9*60+30), (12*60, 12*60+30), (14*60+30, 15*60), (15*60+30, 16*60)]\n    kelly_busy = [(10*60, 10*60+30), (15*60+30, 17*60)]\n    margaret_busy = [(9*60, 9*60+30), (10*60, 11*60+30), (12*60, 13*60+30), (14*60, 15*60), (16*60+30, 17*60)]\n    lauren_busy = [(9*60+30, 10*60+30), (11*60, 12*60), (12*60+30, 13*60), (14*60+30, 15*60), (16*60, 17*60)]\n    henry_busy = [(9*60+30, 10*60+30), (11*60, 11*60+30), (12*60, 13*60), (15*60, 15*60+30), (16*60, 17*60)]\n    \n    # Combine all busy times\n    all_busy = evelyn_busy + kelly_busy + margaret_busy + lauren_busy + henry_busy\n    \n    # Sort all busy times by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy time\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can accommodate 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_414"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find the earliest available slot\n    current_time = work_start\n    for start, end in all_busy:\n        if start > current_time:\n            # Check if the gap is enough for the meeting\n            if start - current_time >= duration_minutes:\n                meeting_end = current_time + duration_minutes\n                return f\"{minutes_to_time(current_time)}:{minutes_to_time(meeting_end)}\"\n        # Update current_time to the end of this busy interval if it's later\n        if end > current_time:\n            current_time = end\n        # If current_time exceeds work hours, break\n        if current_time >= work_end:\n            break\n    \n    # Check the slot after the last busy interval\n    if work_end - current_time >= duration_minutes:\n        meeting_end = current_time + duration_minutes\n        return f\"{minutes_to_time(current_time)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"10:30 to 11:00\", \"15:00 to 15:30\"],  # Paul\n    [\"10:30 to 11:00\", \"15:30 to 16:00\"],  # Kyle\n    [\"09:00 to 10:00\", \"13:00 to 13:30\", \"14:00 to 14:30\", \"15:30 to 16:00\", \"16:30 to 17:00\"],  # Christian\n    [\"09:00 to 09:30\", \"12:00 to 12:30\", \"14:00 to 15:00\", \"15:30 to 16:30\"],  # Alice\n    [\"10:30 to 15:00\", \"15:30 to 16:00\"],  # Kelly\n    [\"09:00 to 09:30\", \"10:30 to 11:30\", \"12:30 to 14:30\", \"15:00 to 16:00\", \"16:30 to 17:00\"],  # Brian\n    [\"10:30 to 11:30\", \"12:00 to 13:30\", \"14:00 to 15:00\", \"15:30 to 17:00\"],  # James\n]\n\n# Find a 30-minute meeting slot between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, \"09:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_415"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    duration = 30        # meeting duration in minutes\n\n    # Convert each person's busy times to minutes since midnight\n    busy_times = {\n        'Jack': [(9*60 + 30, 10*60), (13*60, 13*60 + 30), (14*60, 15*60), (15*60 + 30, 16*60), (16*60 + 30, 17*60)],\n        'Frank': [(12*60 + 30, 13*60), (13*60 + 30, 14*60)],\n        'Theresa': [],\n        'Ronald': [],\n        'Alexander': [(9*60 + 30, 10*60), (10*60 + 30, 11*60), (11*60 + 30, 12*60 + 30), (13*60, 13*60 + 30), (15*60, 15*60 + 30), (16*60, 17*60)],\n        'Peter': [(9*60 + 30, 10*60), (12*60, 13*60), (13*60 + 30, 15*60), (16*60, 17*60)],\n        'Anthony': [(9*60 + 30, 10*60), (11*60 + 30, 13*60), (13*60 + 30, 15*60), (16*60, 16*60 + 30)],\n    }\n\n    # Ronald's preference: avoid after 11:00 (11*60)\n    ronald_preference_end = 11 * 60\n\n    # Combine all busy times into a single list\n    all_busy = []\n    for person, times in busy_times.items():\n        all_busy.extend(times)\n\n    # Add Ronald's preference as a busy time if needed\n    all_busy.append((ronald_preference_end, work_end))\n\n    # Sort all busy times by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check the time after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_416"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_start=9 * 60, work_end=17 * 60):\n    # Convert all schedules to minutes since midnight for easier comparison\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start_h, start_m = map(int, interval[0].split(':'))\n            end_h, end_m = map(int, interval[1].split(':'))\n            start = start_h * 60 + start_m\n            end = end_h * 60 + end_m\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                new_end = max(last_end, current_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append(interval)\n    \n    # Find the first available slot\n    previous_end = work_start\n    for interval in merged:\n        start, end = interval\n        if start > previous_end:\n            if start - previous_end >= duration_minutes:\n                # Found a slot\n                meeting_start = previous_end\n                meeting_end = meeting_start + duration_minutes\n                return (\n                    f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:\"\n                    f\"{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n                )\n        previous_end = max(previous_end, end)\n    \n    # Check after the last busy interval\n    if work_end - previous_end >= duration_minutes:\n        meeting_start = previous_end\n        meeting_end = meeting_start + duration_minutes\n        return (\n            f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:\"\n            f\"{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n        )\n    \n    return \"No available slot found\"\n\n# Define participants' schedules in HH:MM format\nparticipants_schedules = [\n    [],  # Anthony has no meetings\n    [],  # Teresa is free\n    [(\"10:00\", \"10:30\"), (\"11:30\", \"12:30\"), (\"13:30\", \"14:00\"), (\"16:00\", \"17:00\")],  # Vincent\n    [(\"09:00\", \"09:30\"), (\"10:30\", \"11:00\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:30\"), (\"16:00\", \"16:30\")],  # Kevin\n    [(\"09:00\", \"09:30\"), (\"10:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"14:00\"), (\"15:00\", \"16:30\")],  # Julie\n    [(\"09:30\", \"10:00\"), (\"10:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"13:30\", \"14:00\"), (\"14:30\", \"15:00\"), (\"16:00\", \"16:30\")],  # Tyler\n    [(\"09:00\", \"12:30\"), (\"13:00\", \"14:00\"), (\"14:30\", \"17:00\")],  # Bryan\n]\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules))\n```",
            "count": "calendar_scheduling_example_417"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    duration = 30        # meeting duration in minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    busy_slots = {\n        'Jack': [],\n        'Dylan': [(9*60, 9*60 + 30), (16*60 + 30, 17*60)],\n        'Janice': [(9*60 + 30, 10*60), (12*60, 12*60 + 30), (14*60, 14*60 + 30), (16*60 + 30, 17*60)],\n        'Willie': [(9*60 + 30, 10*60), (11*60 + 30, 12*60), (14*60, 15*60)],\n        'Donna': [(9*60 + 30, 11*60), (11*60 + 30, 13*60), (13*60 + 30, 14*60), (14*60 + 30, 15*60), (16*60, 17*60)],\n        'Peter': [(10*60 + 30, 11*60 + 30), (12*60 + 30, 13*60), (13*60 + 30, 14*60 + 30), (15*60 + 30, 17*60)],\n        'Raymond': [(9*60, 9*60 + 30), (10*60 + 30, 11*60), (12*60 + 30, 13*60 + 30), (14*60 + 30, 15*60), (15*60 + 30, 17*60)],\n    }\n\n    # Collect all busy slots\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n\n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= duration:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = (start + duration) // 60\n            end_mm = (start + duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_418"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define each participant's busy intervals in minutes since 9:00\n    busy_times = {\n        'Shirley': [],\n        'Mary': [(16 * 60, 17 * 60)],\n        'Doris': [(10 * 60 + 30, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (15 * 60, 16 * 60 + 30)],\n        'Daniel': [(9 * 60, 9 * 60 + 30), (10 * 60, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Madison': [(9 * 60, 9 * 60 + 30), (10 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Albert': [(10 * 60, 11 * 60), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60), (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 17 * 60)],\n        'Stephanie': [(9 * 60 + 30, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60, 15 * 60)],\n    }\n    \n    # Combine all busy intervals\n    all_busy = []\n    for person in busy_times:\n        all_busy.extend(busy_times[person])\n    \n    # Sort the busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by inverting the busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Find the first free interval that can accommodate 30 minutes\n    meeting_duration = 30\n    for start, end in free_intervals:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_419"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 (9:00)\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes  # Add 540 to start from 9:00\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    # Initialize the work hours in minutes\n    start_work = time_to_minutes(work_hours[0])\n    end_work = time_to_minutes(work_hours[1])\n    \n    # Initialize a list to keep track of busy intervals\n    busy_intervals = []\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort the busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append([start, end])\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1][1] = max(last_end, end)\n            else:\n                merged.append([start, end])\n    \n    # Find available slots\n    available = []\n    prev_end = start_work\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < end_work:\n        available.append((prev_end, end_work))\n    \n    # Check for a slot that can fit the duration\n    for start, end in available:\n        if end - start >= duration:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No available slot found\"\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 30  # minutes\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"16:00 to 17:00\"],  # Larry\n    [\"9:30 to 10:30\", \"11:30 to 12:30\", \"13:30 to 14:00\", \"16:30 to 17:00\"],  # Elijah\n    [],  # Jean\n    [],  # Jesse\n    [\"9:30 to 10:30\", \"11:30 to 12:00\", \"13:00 to 14:00\", \"15:00 to 16:30\"],  # Walter\n    [\"9:00 to 9:30\", \"10:30 to 11:00\", \"11:30 to 12:30\", \"14:00 to 15:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"],  # Keith\n    [\"9:30 to 11:00\", \"11:30 to 17:00\"],  # Ethan\n]\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_420"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define busy intervals for each participant in minutes\n    busy_schedule = {\n        'Julia': [(10 * 60, 10 * 60 + 30), (12 * 60, 12 * 60 + 30), (13 * 60, 14 * 60), (15 * 60 + 30, 16 * 60 + 30)],\n        'Philip': [(10 * 60, 11 * 60), (12 * 60 + 30, 13 * 60 + 30), (15 * 60, 17 * 60)],\n        'Ashley': [(9 * 60, 11 * 60 + 30), (12 * 60, 14 * 60), (14 * 60 + 30, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Mark': [(9 * 60 + 30, 11 * 60 + 30), (12 * 60 + 30, 14 * 60 + 30), (15 * 60, 16 * 60)],\n    }\n    \n    # Collect all busy intervals\n    all_busy = []\n    for person in busy_schedule:\n        all_busy.extend(busy_schedule[person])\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Find free intervals between work hours and busy intervals\n    free_intervals = []\n    previous_end = work_start\n    \n    for start, end in merged_busy:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_intervals.append((previous_end, work_end))\n    \n    # Check for a free interval of at least 30 minutes\n    meeting_duration = 30\n    for start, end in free_intervals:\n        if end - start >= meeting_duration:\n            # Found a suitable time\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_421"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:30:16:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes, work_start, work_end):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    previous_end = work_start_min\n    \n    for start, end in merged:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy interval and before work end\n    if previous_end < work_end_min:\n        available_slots.append((previous_end, work_end_min))\n    \n    # Find the first available slot that can fit the meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"09:00:10:00\", \"12:00:12:30\", \"13:00:13:30\", \"14:00:15:00\"],  # Julie\n    [\"10:30:11:00\", \"14:30:15:00\"],                                # Ann\n    [],                                                             # Kenneth\n    [],                                                             # Austin\n    [\"09:00:09:30\", \"10:00:12:30\", \"13:00:13:30\", \"15:00:15:30\", \"16:00:17:00\"],  # Edward\n    [\"09:00:15:30\", \"16:30:17:00\"],                                # Christine\n    [\"09:00:10:00\", \"10:30:13:00\", \"13:30:15:30\", \"16:00:16:30\"],  # Carol\n]\n\n# Meeting duration in minutes\nduration_minutes = 30\n\n# Work hours\nwork_start = \"09:00\"\nwork_end = \"17:00\"\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, duration_minutes, work_start, work_end))\n```",
            "count": "calendar_scheduling_example_422"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration_minutes):\n    # Convert work hours and schedules to minutes since start of day\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            all_busy_intervals.append((busy_start * 60, busy_end * 60))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Find free intervals by merging and inverting busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for busy_start, busy_end in all_busy_intervals:\n        if busy_start > prev_end:\n            free_intervals.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability of all participants\n    for interval in free_intervals:\n        start, end = interval\n        if end - start >= duration_minutes:\n            # Check if this interval is free for all participants\n            all_free = True\n            for schedule in participants_schedules:\n                participant_free = True\n                for busy_start, busy_end in schedule:\n                    busy_start_min = busy_start * 60\n                    busy_end_min = busy_end * 60\n                    # Check if the interval overlaps with any busy time\n                    if not (end <= busy_start_min or start >= busy_end_min):\n                        participant_free = False\n                        break\n                if not participant_free:\n                    all_free = False\n                    break\n            if all_free:\n                # Convert start time back to hours and minutes\n                start_hour = start // 60\n                start_min = start % 60\n                end_hour = (start + duration_minutes) // 60\n                end_min = (start + duration_minutes) % 60\n                return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n    \n    return \"No suitable time found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (9, 17)\n\n# Define each participant's busy times in their local timezone\nparticipants_schedules = [\n    [(11, 12), (12.5, 13), (14, 14.5)],  # Frank\n    [(9.5, 10), (11, 11.5), (12.5, 13), (16.5, 17)],  # Julie\n    [],  # Donna\n    [],  # Ronald\n    [(9.5, 10.5), (11, 11.5), (12, 13), (13.5, 14), (14.5, 15), (16, 16.5)],  # Peter\n    [(10, 11), (11.5, 12), (12.5, 13), (14, 16)],  # Nancy\n    [(9.5, 11.5), (12.5, 13.5), (15, 16)],  # Scott\n]\n\n# Meeting duration is 30 minutes\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_423"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:00:16:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n\n    # Initialize the free time slots for all participants\n    free_slots = []\n    for busy_times in participants_busy_times:\n        # Convert busy times to minutes and sort them\n        busy_minutes = []\n        for start, end in busy_times:\n            busy_minutes.append((time_to_minutes(start), time_to_minutes(end)))\n        busy_minutes.sort()\n\n        # Calculate free slots for the participant\n        participant_free_slots = []\n        prev_end = work_start\n        for start, end in busy_minutes:\n            if start > prev_end:\n                participant_free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            participant_free_slots.append((prev_end, work_end))\n        free_slots.append(participant_free_slots)\n\n    # Find common free slots across all participants\n    common_free_slots = free_slots[0]\n    for participant_slots in free_slots[1:]:\n        new_common_slots = []\n        i = j = 0\n        while i < len(common_free_slots) and j < len(participant_slots):\n            slot1_start, slot1_end = common_free_slots[i]\n            slot2_start, slot2_end = participant_slots[j]\n            overlap_start = max(slot1_start, slot2_start)\n            overlap_end = min(slot1_end, slot2_end)\n            if overlap_start < overlap_end:\n                new_common_slots.append((overlap_start, overlap_end))\n            if slot1_end < slot2_end:\n                i += 1\n            else:\n                j += 1\n        common_free_slots = new_common_slots\n\n    # Find the first slot that can accommodate the meeting duration\n    meeting_duration_minutes = meeting_duration * 60\n    for start, end in common_free_slots:\n        if end - start >= meeting_duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration_minutes\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    return None\n\n# Define the participants' busy times\nparticipants_busy_times = [\n    [],  # Julie - free all day\n    [(\"09:30\", \"10:00\"), (\"15:00\", \"15:30\")],  # Marilyn\n    [],  # Olivia - free all day\n    [(\"12:30\", \"13:30\")],  # Emily\n    [(\"09:00\", \"12:00\"), (\"12:30\", \"13:00\"), (\"14:00\", \"16:00\"), (\"16:30\", \"17:00\")],  # Bruce\n    [(\"09:00\", \"14:30\"), (\"15:00\", \"16:00\"), (\"16:30\", \"17:00\")],  # Jeffrey\n    [(\"09:00\", \"10:00\"), (\"11:00\", \"12:30\"), (\"13:30\", \"15:00\"), (\"15:30\", \"16:00\"), (\"16:30\", \"17:00\")],  # Kyle\n]\n\n# Find a meeting time\nmeeting_time = find_meeting_time(participants_busy_times, \"09:00\", \"17:00\", 0.5)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_424"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for schedule in participants_schedules:\n        busy_intervals = []\n        for busy in schedule:\n            start, end = busy.split(' to ')\n            busy_start = time_to_minutes(start)\n            busy_end = time_to_minutes(end)\n            busy_intervals.append((busy_start, busy_end))\n        all_busy_intervals.append(busy_intervals)\n    \n    # Find all possible free intervals common to all participants\n    common_free_intervals = []\n    \n    # Check every minute in the work hours\n    current_time = work_start\n    while current_time + duration_minutes <= work_end:\n        is_free_for_all = True\n        for busy_intervals in all_busy_intervals:\n            is_free = True\n            for (busy_start, busy_end) in busy_intervals:\n                if not (current_time + duration_minutes <= busy_start or current_time >= busy_end):\n                    is_free = False\n                    break\n            if not is_free:\n                is_free_for_all = False\n                break\n        if is_free_for_all:\n            common_free_intervals.append((current_time, current_time + duration_minutes))\n            # Move to the end of this interval to avoid overlapping\n            current_time += duration_minutes\n        else:\n            current_time += 1  # Check next minute\n    \n    if not common_free_intervals:\n        return None\n    \n    # Return the first available interval\n    start, end = common_free_intervals[0]\n    return f\"{minutes_to_time(start)}:{minutes_to_time(end)}\"\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\n# Define each participant's busy intervals\nparticipants_schedules = [\n    [\"9:00 to 9:30\", \"11:00 to 11:30\", \"12:00 to 13:00\", \"15:00 to 16:00\"],  # Judy\n    [\"11:00 to 11:30\", \"14:00 to 14:30\"],  # Alice\n    [\"9:30 to 10:00\", \"13:00 to 14:00\", \"14:30 to 16:00\"],  # Christina\n    [\"13:30 to 14:30\", \"15:30 to 16:30\"],  # Barbara\n    [\"10:00 to 10:30\", \"11:00 to 11:30\", \"12:00 to 13:30\", \"14:00 to 14:30\", \"15:30 to 16:00\", \"16:30 to 17:00\"],  # Sharon\n    [\"9:00 to 10:00\", \"11:00 to 13:30\", \"14:00 to 15:30\"],  # Edward\n    [\"9:00 to 10:30\", \"11:00 to 13:00\", \"13:30 to 17:00\"],  # Sarah\n]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_425"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define each person's busy times in minutes since midnight\n    busy_times = {\n        'Donna': [(10*60, 10*60+30), (11*60, 12*60+30), (13*60, 13*60+30), (14*60+30, 15*60)],\n        'Albert': [(10*60, 10*60+30), (11*60, 11*60+30), (13*60+30, 15*60), (16*60, 16*60+30)],\n        'Jeremy': [],\n        'Grace': [(13*60, 13*60+30), (16*60+30, 17*60)],\n        'Matthew': [(10*60, 10*60+30), (11*60, 11*60+30), (12*60, 15*60), (15*60+30, 16*60+30)],\n        'Jean': [(11*60, 13*60+30), (14*60+30, 15*60+30), (16*60+30, 17*60)],\n        'Dylan': [(9*60, 9*60+30), (10*60, 10*60+30), (11*60+30, 12*60), (12*60+30, 13*60), \n                  (13*60+30, 14*60), (15*60, 15*60+30), (16*60, 17*60)],\n    }\n    \n    # Donna's preference: avoid before 10:00\n    preference_start = 10 * 60\n    \n    # Collect all busy intervals\n    all_busy = []\n    for person in busy_times:\n        all_busy.extend(busy_times[person])\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Filter free intervals based on Donna's preference\n    free_intervals = [(s, e) for s, e in free_intervals if s >= preference_start]\n    \n    # Check each free interval for a 30-minute slot\n    meeting_duration = 30\n    for start, end in free_intervals:\n        if end - start >= meeting_duration:\n            # Found a suitable time\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_426"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:30:10:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 (9:00)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes  # Add back 540 to start from 9:00\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Initialize the busy slots for all participants\n    busy_slots = []\n    for schedule in participants_schedules:\n        person_busy = []\n        for meeting in schedule:\n            start, end = meeting.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            person_busy.append((start_min, end_min))\n        busy_slots.append(person_busy)\n    \n    # Find all possible free slots for each participant\n    free_slots_per_person = []\n    for person_busy in busy_slots:\n        person_free = []\n        prev_end = work_start\n        for start, end in sorted(person_busy):\n            if start > prev_end:\n                person_free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            person_free.append((prev_end, work_end))\n        free_slots_per_person.append(person_free)\n    \n    # Find common free slots across all participants\n    common_free_slots = free_slots_per_person[0]\n    for person_free in free_slots_per_person[1:]:\n        new_common = []\n        i = j = 0\n        while i < len(common_free_slots) and j < len(person_free):\n            slot1_start, slot1_end = common_free_slots[i]\n            slot2_start, slot2_end = person_free[j]\n            start = max(slot1_start, slot2_start)\n            end = min(slot1_end, slot2_end)\n            if start < end:\n                new_common.append((start, end))\n            if slot1_end < slot2_end:\n                i += 1\n            else:\n                j += 1\n        common_free_slots = new_common\n    \n    # Find the first slot that can fit the duration\n    duration_min = duration * 60\n    for start, end in common_free_slots:\n        if end - start >= duration_min:\n            meeting_end = start + duration_min\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"11:30 to 12:00\", \"16:30 to 17:00\"],  # Nancy\n    [],  # Gloria\n    [\"9:00 to 9:30\", \"10:30 to 11:00\", \"11:30 to 12:00\", \"12:30 to 13:00\", \"15:00 to 15:30\", \"16:30 to 17:00\"],  # Harold\n    [],  # Katherine\n    [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:00 to 12:30\", \"13:30 to 15:00\", \"15:30 to 16:30\"],  # Tyler\n    [\"10:00 to 11:00\", \"11:30 to 13:00\", \"13:30 to 14:30\", \"15:00 to 16:00\", \"16:30 to 17:00\"],  # Larry\n    [\"9:00 to 9:30\", \"10:00 to 14:30\", \"15:00 to 17:00\"],  # Mark\n]\n\n# Parameters\nmeeting_duration = 0.5  # half an hour\nwork_hours = \"9:00 to 17:00\"\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, meeting_duration, work_hours))\n```",
            "count": "calendar_scheduling_example_427"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each participant's busy slots to minutes\n    busy_slots = {\n        'Denise': [],\n        'Amber': [(10 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60), (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Charles': [(9 * 60 + 30, 10 * 60), (11 * 60 + 30, 12 * 60 + 30), (13 * 60 + 30, 15 * 60)],\n        'Edward': [(11 * 60 + 30, 12 * 60 + 30), (14 * 60 + 30, 15 * 60), (16 * 60, 16 * 60 + 30)],\n        'Richard': [(9 * 60, 9 * 60 + 30), (11 * 60, 12 * 60 + 30), (14 * 60, 14 * 60 + 30), (15 * 60, 16 * 60 + 30)],\n        'Katherine': [(9 * 60, 11 * 60), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60), (16 * 60, 16 * 60 + 30)],\n        'Russell': [(9 * 60, 12 * 60), (12 * 60 + 30, 13 * 60), (14 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n    }\n    \n    # Collect all busy slots\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check if there's a free slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that is at least 30 minutes long\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = (start + meeting_duration) // 60\n            end_mm = (start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_428"
        },
        {
            "final_program_time": "{13:30:13:32}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - work_hours_start * 60\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = work_hours_start * 60 + minutes\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    # Initialize the availability list (all times initially free)\n    work_hours_total = (work_hours_end - work_hours_start) * 60\n    availability = [True] * work_hours_total\n\n    # Mark busy times for each participant\n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            start_min = time_to_minutes(busy_start)\n            end_min = time_to_minutes(busy_end)\n            for minute in range(start_min, end_min):\n                if minute < len(availability):\n                    availability[minute] = False\n\n    # Find the first available slot of 'duration' minutes\n    required_slots = duration * 2  # assuming 30-minute slots for half-hour\n    current_slot_length = 0\n\n    for minute, is_free in enumerate(availability):\n        if is_free:\n            current_slot_length += 1\n            if current_slot_length >= required_slots:\n                start_minute = minute - current_slot_length + 1\n                end_minute = start_minute + required_slots\n                start_time = minutes_to_time(start_minute)\n                end_time = minutes_to_time(end_minute)\n                return f\"{start_time}:{end_time}\"\n        else:\n            current_slot_length = 0\n\n    return \"No available slot found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours_start = 9\nwork_hours_end = 17\n\n# Define participants' schedules in HH:MM format\nparticipants_schedules = [\n    [(\"13:00\", \"13:30\"), (\"16:00\", \"16:30\")],  # Judy\n    [(\"10:00\", \"10:30\"), (\"12:00\", \"13:00\"), (\"14:00\", \"14:30\")],  # Olivia\n    [],  # Eric (free)\n    [(\"10:00\", \"10:30\"), (\"15:00\", \"15:30\")],  # Jacqueline\n    [(\"9:00\", \"10:00\"), (\"10:30\", \"12:00\"), (\"13:00\", \"13:30\"), (\"14:30\", \"15:00\"), (\"15:30\", \"17:00\")],  # Laura\n    [(\"9:00\", \"10:00\"), (\"11:00\", \"11:30\"), (\"12:30\", \"13:00\"), (\"14:00\", \"14:30\"), (\"15:30\", \"17:00\")],  # Tyler\n    [(\"9:30\", \"10:30\"), (\"11:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"13:30\"), (\"14:00\", \"14:30\"), (\"16:00\", \"17:00\")],  # Lisa\n]\n\n# Duration in half-hour units (1 = 30 minutes)\nduration = 1\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules=participants_schedules, \n                                 duration=duration, \n                                 work_hours_start=work_hours_start, \n                                 work_hours_end=work_hours_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_429"
        },
        {
            "final_program_time": "{12:30:13:30}",
            "expected_time": "{12:30:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert all time slots to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration_min = duration * 60\n\n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n\n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start\n\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Find the first available slot that can accommodate the meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"9:30 to 10:00\", \"16:30 to 17:00\"],  # Jessica\n    [\"9:30 to 10:00\", \"14:00 to 14:30\", \"15:00 to 16:00\"],  # Elijah\n    [\"11:00 to 11:30\", \"16:30 to 17:00\"],  # Ann\n    [],  # Marie\n    [\"9:00 to 10:00\", \"10:30 to 11:00\", \"11:30 to 12:30\", \"14:00 to 15:30\"],  # Kathryn\n    [\"9:00 to 11:00\", \"11:30 to 12:30\", \"16:00 to 17:00\"],  # Albert\n    [\"10:00 to 11:00\", \"12:00 to 12:30\", \"14:00 to 15:00\", \"15:30 to 17:00\"],  # Nicole\n]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, \"9:00\", \"17:00\", 1)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_430"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Participants' schedules and constraints\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30       # 30 minutes\n    \n    # Emma's busy times in minutes (9:30-10:30, 11:00-12:00, 12:30-13:00, 14:00-16:00, 16:30-17:00)\n    emma_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (11 * 60, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Alan's busy times (9:30-10:30, 11:00-17:00)\n    alan_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (11 * 60, 17 * 60)\n    ]\n    \n    # Philip's busy times (9:30-10:30, 11:00-12:30, 13:00-13:30, 14:30-15:00, 16:00-16:30)\n    philip_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (11 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    # William's preference: not before 9:30\n    william_pref_start = 9 * 60 + 30\n    \n    # Combine all busy times and sort them\n    all_busy = emma_busy + alan_busy + philip_busy\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = max(work_hours_start, william_pref_start)\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy time\n    if previous_end < work_hours_end:\n        free_slots.append((previous_end, work_hours_end))\n    \n    # Find the first free slot that can fit the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_431"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start = time_to_minutes(busy[0])\n            end = time_to_minutes(busy[1])\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find the earliest available slot\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available_duration = start - prev_end\n            if available_duration >= duration_minutes:\n                return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + duration_minutes)}\"\n        prev_end = max(prev_end, end)\n    \n    # Check after the last busy interval\n    if work_end - prev_end >= duration_minutes:\n        return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + duration_minutes)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules in HH:MM format\nparticipants_schedules = [\n    [(\"10:00\", \"10:30\"), (\"11:00\", \"11:30\"), (\"12:30\", \"13:30\"), (\"15:00\", \"15:30\"), (\"16:30\", \"17:00\")],  # Grace\n    [(\"10:00\", \"11:00\"), (\"12:30\", \"13:00\"), (\"13:30\", \"14:00\"), (\"14:30\", \"15:00\"), (\"16:00\", \"16:30\")],  # Nicholas\n    [(\"09:00\", \"10:00\"), (\"10:30\", \"12:00\"), (\"16:00\", \"16:30\")],  # Ann\n    [],  # Jacob\n    [(\"09:30\", \"14:00\"), (\"14:30\", \"16:00\")],  # Joe\n    [(\"09:30\", \"11:30\"), (\"12:00\", \"14:00\"), (\"14:30\", \"15:00\"), (\"16:30\", \"17:00\")],  # Stephanie\n    [(\"09:00\", \"14:00\"), (\"14:30\", \"16:30\")],  # Tyler\n]\n\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_432"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    start, end = work_hours\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(start)\n    work_end = time_to_minutes(end)\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's schedule to find common free slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            busy_start = time_to_minutes(busy[0])\n            busy_end = time_to_minutes(busy[1])\n            busy_slots.append((busy_start, busy_end))\n        # Sort the busy slots\n        busy_slots.sort()\n        # Merge overlapping or adjacent busy slots\n        merged_busy = []\n        for slot in busy_slots:\n            if not merged_busy:\n                merged_busy.append(slot)\n            else:\n                last_start, last_end = merged_busy[-1]\n                current_start, current_end = slot\n                if current_start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = last_start\n                    new_end = max(last_end, current_end)\n                    merged_busy[-1] = (new_start, new_end)\n                else:\n                    merged_busy.append(slot)\n        # Now find the free slots by subtracting busy from work hours\n        participant_free = []\n        prev_end = work_start\n        for busy_start, busy_end in merged_busy:\n            if busy_start > prev_end:\n                participant_free.append((prev_end, busy_start))\n            prev_end = max(prev_end, busy_end)\n        if prev_end < work_end:\n            participant_free.append((prev_end, work_end))\n        # Intersect the participant's free slots with the current common free slots\n        new_free_slots = []\n        i = j = 0\n        while i < len(free_slots) and j < len(participant_free):\n            slot_start, slot_end = free_slots[i]\n            part_start, part_end = participant_free[j]\n            # Find the overlap\n            overlap_start = max(slot_start, part_start)\n            overlap_end = min(slot_end, part_end)\n            if overlap_start < overlap_end:\n                new_free_slots.append((overlap_start, overlap_end))\n            # Move the pointer which ends first\n            if slot_end < part_end:\n                i += 1\n            else:\n                j += 1\n        free_slots = new_free_slots\n    \n    # Now find the first slot in free_slots that can fit the duration\n    duration_min = duration * 60\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [],  # Diane\n    [(\"09:30\", \"10:00\"), (\"11:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"13:30\"), (\"15:30\", \"16:00\"), (\"16:30\", \"17:00\")],  # Terry\n    [(\"09:30\", \"11:00\"), (\"15:00\", \"16:30\")],  # Jessica\n    [],  # Peter\n    [(\"09:00\", \"11:30\"), (\"12:00\", \"16:00\"), (\"16:30\", \"17:00\")],  # Gary\n    [(\"10:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"14:00\"), (\"14:30\", \"15:30\")],  # Gabriel\n    [(\"09:00\", \"09:30\"), (\"10:00\", \"11:30\"), (\"12:00\", \"13:00\"), (\"13:30\", \"14:00\"), (\"14:30\", \"17:00\")],  # Amanda\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, 30, (\"09:00\", \"17:00\"))\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_433"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    start, end = work_hours\n    # Convert time strings to minutes for easier calculation\n    start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n    end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules.values():\n        for busy in schedule:\n            busy_start, busy_end = busy\n            busy_start_min = int(busy_start.split(':')[0]) * 60 + int(busy_start.split(':')[1])\n            busy_end_min = int(busy_end.split(':')[0]) * 60 + int(busy_end.split(':')[1])\n            busy_intervals.append((busy_start_min, busy_end_min))\n    \n    # Sort the busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals\n    free_intervals = []\n    previous_end = start_min\n    \n    for start_busy, end_busy in busy_intervals:\n        if start_busy > previous_end:\n            free_intervals.append((previous_end, start_busy))\n        previous_end = max(previous_end, end_busy)\n    \n    if end_min > previous_end:\n        free_intervals.append((previous_end, end_min))\n    \n    # Check each free interval for availability for all participants\n    for free_start, free_end in free_intervals:\n        if free_end - free_start >= duration:\n            # Check if this interval is free for all participants\n            all_free = True\n            for schedule in participants_schedules.values():\n                participant_free = True\n                for busy_start, busy_end in schedule:\n                    busy_start_min = int(busy_start.split(':')[0]) * 60 + int(busy_start.split(':')[1])\n                    busy_end_min = int(busy_end.split(':')[0]) * 60 + int(busy_end.split(':')[1])\n                    if not (free_end <= busy_start_min or free_start >= busy_end_min):\n                        participant_free = False\n                        break\n                if not participant_free:\n                    all_free = False\n                    break\n            if all_free:\n                # Convert back to HH:MM format\n                meeting_start = f\"{free_start // 60:02d}:{free_start % 60:02d}\"\n                meeting_end = f\"{(free_start + duration) // 60:02d}:{(free_start + duration) % 60:02d}\"\n                return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    'Kayla': [('9:00', '9:30'), ('15:00', '15:30')],\n    'Karen': [],\n    'Henry': [('10:00', '10:30'), ('12:00', '12:30'), ('14:00', '14:30'), ('15:30', '16:00')],\n    'Randy': [('10:30', '11:30'), ('12:00', '12:30'), ('16:30', '17:00')],\n    'Stephanie': [('10:00', '11:30'), ('12:00', '13:30'), ('14:30', '16:30')],\n    'Tyler': [('10:00', '11:30'), ('12:00', '13:30'), ('15:00', '15:30'), ('16:30', '17:00')],\n    'Joe': [('9:00', '10:30'), ('11:00', '11:30'), ('12:00', '12:30'), ('13:00', '14:30'), ('15:00', '17:00')]\n}\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_hours = ('9:00', '17:00')\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_434"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time slots to minutes since start of day for easier calculation\n    work_start = work_hours_start[0] * 60 + work_hours_start[1]\n    work_end = work_hours_end[0] * 60 + work_hours_end[1]\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's busy slots\n    for schedule in participants_schedules:\n        new_free_slots = []\n        for busy_start, busy_end in schedule:\n            busy_start_min = busy_start[0] * 60 + busy_start[1]\n            busy_end_min = busy_end[0] * 60 + busy_end[1]\n            for slot_start, slot_end in free_slots:\n                if busy_end_min <= slot_start or busy_start_min >= slot_end:\n                    # No overlap, keep the slot as is\n                    new_free_slots.append((slot_start, slot_end))\n                else:\n                    # There is an overlap, split the slot\n                    if slot_start < busy_start_min:\n                        new_free_slots.append((slot_start, busy_start_min))\n                    if slot_end > busy_end_min:\n                        new_free_slots.append((busy_end_min, slot_end))\n        # Update free_slots to the intersection of current free_slots and new_free_slots\n        free_slots = new_free_slots\n    \n    # Merge overlapping or adjacent slots\n    free_slots.sort()\n    merged_slots = []\n    for slot in free_slots:\n        if not merged_slots:\n            merged_slots.append(slot)\n        else:\n            last_start, last_end = merged_slots[-1]\n            current_start, current_end = slot\n            if current_start <= last_end:\n                # Merge the slots\n                new_slot = (last_start, max(last_end, current_end))\n                merged_slots[-1] = new_slot\n            else:\n                merged_slots.append(slot)\n    \n    # Find the first slot that can fit the meeting\n    duration = duration_minutes\n    for slot_start, slot_end in merged_slots:\n        if slot_end - slot_start >= duration:\n            # Found a suitable slot\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' busy schedules in HH:MM format\nparticipants_schedules = [\n    # Lawrence\n    [( (10, 0), (10, 30) ), ( (13, 30), (14, 0) )],\n    # Shirley - no meetings\n    [],\n    # Alexander\n    [( (9, 30), (10, 0) ), ( (10, 30), (11, 30) ), ( (12, 30), (13, 0) )],\n    # Brian\n    [( (9, 0), (9, 30) ), ( (13, 30), (14, 0) )],\n    # Kathryn\n    [( (9, 0), (15, 0) ), ( (16, 0), (17, 0) )],\n    # Aaron\n    [( (9, 0), (11, 0) ), ( (11, 30), (12, 30) ), ( (13, 0), (13, 30) ), ( (14, 0), (15, 0) ), ( (16, 0), (16, 30) )],\n    # Janice\n    [( (9, 0), (11, 30) ), ( (12, 0), (12, 30) ), ( (13, 0), (15, 0) ), ( (15, 30), (16, 0) ), ( (16, 30), (17, 0) )]\n]\n\n# Define work hours and meeting duration\nwork_hours_start = (9, 0)  # 9:00\nwork_hours_end = (17, 0)    # 17:00\nduration = 30                # 30 minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration))\n```",
            "count": "calendar_scheduling_example_435"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:30:10:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by merging busy intervals\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = min(start, last_start)\n                new_end = max(end, last_end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Find the first available slot\n    previous_end = work_start\n    for start, end in merged_busy:\n        if start - previous_end >= duration_minutes:\n            # Found a slot\n            meeting_start = previous_end\n            meeting_end = meeting_start + duration_minutes\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n        previous_end = max(previous_end, end)\n    \n    # Check after the last busy interval\n    if work_end - previous_end >= duration_minutes:\n        meeting_start = previous_end\n        meeting_end = meeting_start + duration_minutes\n        return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"13:30:14:00\", \"14:30:15:00\"],  # Patrick\n    [\"09:00:09:30\", \"11:00:11:30\", \"12:00:12:30\", \"14:30:15:00\", \"16:00:17:00\"],  # Shirley\n    [\"09:00:09:30\", \"10:30:11:00\", \"11:30:12:00\", \"13:00:13:30\", \"16:00:17:00\"],  # Jeffrey\n    [\"11:30:12:00\", \"15:00:15:30\"],  # Gloria\n    [\"09:00:09:30\", \"10:30:12:00\", \"14:00:17:00\"],  # Nathan\n    [\"09:00:09:30\", \"10:00:11:00\", \"12:30:15:00\", \"15:30:16:30\"],  # Angela\n    [\"09:00:09:30\", \"10:00:10:30\", \"11:00:14:00\", \"14:30:16:30\"],  # David\n]\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, \"09:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_436"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy_times in participants_busy_times.values():\n        for busy in busy_times:\n            start, end = map(time_to_minutes, busy.split(':'))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals\n    all_busy.sort()\n    \n    # Find free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    prev_end = work_start\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > prev_end:\n            free_intervals.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' busy times\nparticipants_busy_times = {\n    \"Gerald\": [\"14:30:15:00\", \"15:30:16:00\"],\n    \"Paul\": [\"10:00:10:30\", \"11:30:12:30\", \"14:00:14:30\", \"15:30:16:00\", \"16:30:17:00\"],\n    \"Donald\": [\"9:00:10:30\", \"12:30:14:00\", \"14:30:15:00\", \"15:30:16:00\"],\n    \"Richard\": [\"9:00:10:30\", \"11:00:12:30\", \"13:00:15:30\", \"16:30:17:00\"],\n    \"Patrick\": [\"9:30:10:30\", \"11:30:12:00\", \"13:00:13:30\", \"15:00:17:00\"],\n    # Joshua and Alice have no busy times\n}\n\n# Work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_437"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each person's busy slots to minutes\n    george_busy = [(11*60 + 30, 12*60), (15*60, 15*60 + 30), (16*60, 17*60)]\n    emma_busy = [(9*60 + 30, 10*60), (11*60, 11*60 + 30), (12*60, 12*60 + 30), (15*60, 15*60 + 30), (16*60, 17*60)]\n    ashley_busy = [(9*60, 9*60 + 30), (10*60, 12*60 + 30), (14*60 + 30, 15*60 + 30)]\n    jose_busy = [(9*60, 11*60), (11*60 + 30, 13*60 + 30), (14*60 + 30, 16*60 + 30)]\n    charles_busy = [(9*60, 10*60), (10*60 + 30, 11*60), (12*60, 14*60), (14*60 + 30, 15*60 + 30), (16*60 + 30, 17*60)]\n    \n    # Combine all busy slots\n    all_busy = george_busy + emma_busy + ashley_busy + jose_busy + charles_busy\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Check each free slot for 30-minute availability\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert start time back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_time = start + meeting_duration\n            end_hh = end_time // 60\n            end_mm = end_time % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_438"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Each participant's busy blocks in minutes since midnight\n    busy_blocks = {\n        'Jeffrey': [(10 * 60 + 30, 11 * 60), (13 * 60 + 30, 14 * 60)],\n        'Nancy': [(11 * 60, 11 * 60 + 30), (14 * 60, 14 * 60 + 30), (15 * 60, 16 * 60)],\n        'Jordan': [(9 * 60, 9 * 60 + 30), (11 * 60 + 30, 12 * 60), (13 * 60 + 30, 14 * 60 + 30)],\n        'Samantha': [(11 * 60 + 30, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Jason': [(9 * 60, 10 * 60 + 30), (11 * 60, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (13 * 60 + 30, 14 * 60), (15 * 60 + 30, 16 * 60 + 30)],\n        'Shirley': [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60), (12 * 60, 13 * 60), (13 * 60 + 30, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Jessica': [(9 * 60 + 30, 10 * 60 + 30), (11 * 60, 11 * 60 + 30), (12 * 60, 15 * 60 + 30)],\n    }\n\n    # Combine all busy blocks and sort them\n    all_busy = []\n    for blocks in busy_blocks.values():\n        all_busy.extend(blocks)\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy blocks\n    free_slots = []\n    previous_end = work_start\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_439"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = meeting_duration\n\n    # Initialize the list of busy intervals for all participants\n    all_busy_intervals = []\n    for busy_times in participants_busy_times:\n        for start, end in busy_times:\n            all_busy_intervals.append((time_to_minutes(start), time_to_minutes(end)))\n\n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n\n    # Merge overlapping or adjacent intervals\n    merged_intervals = []\n    for start, end in all_busy_intervals:\n        if not merged_intervals:\n            merged_intervals.append((start, end))\n        else:\n            last_start, last_end = merged_intervals[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_intervals[-1] = (new_start, new_end)\n            else:\n                merged_intervals.append((start, end))\n\n    # Find available slots by checking gaps between merged intervals and work hours\n    available_slots = []\n    previous_end = work_start\n    for start, end in merged_intervals:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n\n    # Check each available slot for sufficient duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            # Found a suitable slot\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n\n            meeting_start = minutes_to_time(slot_start)\n            meeting_end = minutes_to_time(slot_start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n\n    return \"No suitable time found\"\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 30  # minutes\n\n# Define each participant's busy times in HH:MM format\nparticipants_busy_times = [\n    [(\"11:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"14:30\", \"15:00\"), (\"16:00\", \"16:30\")],  # Alan\n    [],  # Kyle\n    [],  # Zachary\n    [],  # Heather\n    [(\"10:00\", \"12:30\"), (\"13:00\", \"13:30\"), (\"14:00\", \"14:30\"), (\"15:00\", \"16:30\")],  # Joan\n    [(\"10:00\", \"11:00\"), (\"12:00\", \"16:00\")],  # Diane\n    [(\"09:30\", \"11:00\"), (\"12:30\", \"14:00\"), (\"14:30\", \"15:00\"), (\"15:30\", \"17:00\")],  # Julie\n]\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration))\n```",
            "count": "calendar_scheduling_example_440"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for meeting in schedule:\n            start, end = map(time_to_minutes, meeting.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by checking gaps between busy intervals\n    free_intervals = []\n    previous_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the time after the last busy interval until work_end\n    if previous_end < work_end:\n        free_intervals.append((previous_end, work_end))\n    \n    # Now merge free intervals from all participants by finding common free times\n    # Since we need a time when everyone is free, we look for intervals that are free for all\n    # But in this approach, we've combined all busy intervals first, so the free intervals are when no one is busy\n    \n    # Find the first free interval that can fit the meeting duration\n    duration = duration_minutes\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"11:30 to 12:00\", \"14:30 to 15:00\"],  # Joan\n    [\"9:00 to 10:00\", \"14:00 to 14:30\", \"16:00 to 16:30\"],  # Megan\n    [],  # Austin\n    [\"9:30 to 10:00\", \"11:30 to 12:00\", \"13:30 to 14:00\", \"16:00 to 16:30\"],  # Betty\n    [\"9:00 to 11:00\", \"12:00 to 13:00\", \"14:00 to 15:00\"],  # Judith\n    [\"9:30 to 10:00\", \"11:30 to 12:30\", \"13:00 to 14:00\", \"15:00 to 15:30\", \"16:00 to 17:00\"],  # Terry\n    [\"9:30 to 10:00\", \"10:30 to 11:00\", \"11:30 to 13:00\", \"14:00 to 16:00\", \"16:30 to 17:00\"],  # Kathryn\n]\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 30  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_441"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours\n    start_min = time_to_minutes(start_work)\n    end_min = time_to_minutes(end_work)\n    \n    # Initialize a list to mark busy intervals\n    timeline = [0] * (end_min - start_min)\n    \n    # Mark busy times for each participant\n    for schedule in participants_schedules:\n        for busy in schedule:\n            busy_start = time_to_minutes(busy[0])\n            busy_end = time_to_minutes(busy[1])\n            # Clamp to work hours\n            busy_start = max(busy_start, start_min)\n            busy_end = min(busy_end, end_min)\n            for i in range(busy_start - start_min, busy_end - start_min):\n                if i >= 0 and i < len(timeline):\n                    timeline[i] += 1\n    \n    # Find the first interval where all are free (timeline[i] == 0)\n    required_slots = duration\n    current_free = 0\n    for i in range(len(timeline)):\n        if timeline[i] == 0:\n            current_free += 1\n            if current_free >= required_slots:\n                start_time = i - required_slots + 1\n                end_time = i + 1\n                meeting_start = minutes_to_time(start_time + start_min)\n                meeting_end = minutes_to_time(end_time + start_min)\n                return f\"{meeting_start}:{meeting_end}\"\n        else:\n            current_free = 0\n    return \"No available slot found\"\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 30  # minutes\n\n# Define each participant's busy times\nparticipants_schedules = [\n    [(\"9:00\", \"9:30\"), (\"11:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"13:30\"), (\"14:00\", \"14:30\"), (\"15:30\", \"16:00\")],  # Christopher\n    [(\"9:00\", \"9:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"13:30\"), (\"14:00\", \"14:30\")],  # Karen\n    [(\"9:00\", \"9:30\"), (\"10:30\", \"11:00\"), (\"11:30\", \"12:00\"), (\"15:00\", \"15:30\")],  # Patricia\n    [(\"10:00\", \"10:30\"), (\"11:00\", \"11:30\"), (\"14:00\", \"14:30\"), (\"16:30\", \"17:00\")],  # Charlotte\n    [(\"9:00\", \"9:30\"), (\"12:00\", \"13:30\"), (\"14:00\", \"15:00\"), (\"15:30\", \"16:30\")],  # Roger\n    [(\"9:00\", \"9:30\"), (\"10:00\", \"11:30\"), (\"12:00\", \"17:00\")],  # Anna\n    [(\"10:30\", \"11:00\"), (\"12:00\", \"13:00\"), (\"13:30\", \"15:30\"), (\"16:30\", \"17:00\")],  # Dylan\n]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_442"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert work hours and busy times to minutes\n    start_hour, start_min = map(int, work_hours[0].split(':'))\n    end_hour, end_min = map(int, work_hours[1].split(':'))\n    work_start = start_hour * 60 + start_min\n    work_end = end_hour * 60 + end_min\n    \n    # Initialize a list to track busy intervals in minutes\n    busy_intervals = []\n    for person in participants_busy:\n        for interval in person:\n            start, end = interval.split(' to ')\n            start_h, start_m = map(int, start.split(':'))\n            end_h, end_m = map(int, end.split(':'))\n            busy_start = start_h * 60 + start_m\n            busy_end = end_h * 60 + end_m\n            busy_intervals.append((busy_start, busy_end))\n    \n    # Sort all busy intervals\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Check for available slots before the first busy interval\n    if merged:\n        first_start, first_end = merged[0]\n        if work_start + duration <= first_start:\n            return f\"{format_time(work_start)}:{format_time(work_start + duration)}\"\n    \n    # Check between busy intervals\n    for i in range(len(merged) - 1):\n        current_end = merged[i][1]\n        next_start = merged[i + 1][0]\n        if current_end + duration <= next_start:\n            return f\"{format_time(current_end)}:{format_time(current_end + duration)}\"\n    \n    # Check after last busy interval\n    last_end = merged[-1][1] if merged else work_start\n    if last_end + duration <= work_end:\n        return f\"{format_time(last_end)}:{format_time(last_end + duration)}\"\n    \n    return \"No available slot found\"\n\ndef format_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Define participants' busy times\nparticipants_busy = [\n    [\"14:00 to 14:30\", \"15:00 to 15:30\"],  # Jacob\n    [\"13:30 to 14:00\", \"16:00 to 16:30\"],  # Frances\n    [\"12:30 to 13:00\", \"14:00 to 14:30\"],  # Emily\n    [],                                    # Mark\n    [\"10:00 to 12:00\", \"13:00 to 14:30\", \"15:30 to 16:00\"],  # Linda\n    [\"9:30 to 10:00\", \"11:00 to 13:30\", \"14:00 to 14:30\", \"16:00 to 16:30\"],  # Robert\n    [\"9:30 to 11:30\", \"12:30 to 16:00\", \"16:30 to 17:00\"],  # Raymond\n]\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 30  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_443"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:00:16:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the free slots for the day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's schedule to find common free slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_slots.append((start, end))\n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Merge overlapping or adjacent busy slots\n        merged_busy = []\n        for start, end in busy_slots:\n            if not merged_busy:\n                merged_busy.append((start, end))\n            else:\n                last_start, last_end = merged_busy[-1]\n                if start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged_busy[-1] = (new_start, new_end)\n                else:\n                    merged_busy.append((start, end))\n        \n        # Calculate free slots for this participant\n        participant_free = []\n        prev_end = work_start\n        for start, end in merged_busy:\n            if start > prev_end:\n                participant_free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            participant_free.append((prev_end, work_end))\n        \n        # Intersect with current free slots\n        new_free_slots = []\n        i = j = 0\n        while i < len(free_slots) and j < len(participant_free):\n            slot_start, slot_end = free_slots[i]\n            part_start, part_end = participant_free[j]\n            \n            # Find overlap\n            overlap_start = max(slot_start, part_start)\n            overlap_end = min(slot_end, part_end)\n            \n            if overlap_start < overlap_end:\n                new_free_slots.append((overlap_start, overlap_end))\n            \n            # Move the pointer which ends first\n            if slot_end < part_end:\n                i += 1\n            else:\n                j += 1\n        \n        free_slots = new_free_slots\n    \n    # Find the first free slot that can accommodate the meeting\n    meeting_duration_min = meeting_duration * 60\n    for start, end in free_slots:\n        if end - start >= meeting_duration_min:\n            meeting_end = start + meeting_duration_min\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"12:00:12:30\", \"14:30:15:00\"],  # Abigail\n    [\"09:30:10:30\", \"13:30:14:00\", \"16:30:17:00\"],  # Roy\n    [],  # Brian\n    [\"12:00:13:00\", \"14:00:14:30\", \"15:30:16:00\"],  # Deborah\n    [\"09:30:10:00\", \"11:30:12:00\", \"12:30:13:00\", \"14:00:16:00\", \"16:30:17:00\"],  # Eric\n    [\"09:00:10:00\", \"10:30:12:00\", \"12:30:14:30\", \"15:00:16:00\", \"16:30:17:00\"],  # Susan\n    [\"09:30:10:00\", \"10:30:12:30\", \"14:00:15:00\", \"16:30:17:00\"],  # Joyce\n]\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, \"09:00\", \"17:00\", 0.5)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_444"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Now, find a free interval that is common to all participants\n    # To do this, we need to find overlapping free intervals across all participants\n    # But since it's complex, we'll instead look for a time slot where no one is busy\n    # We'll generate all possible slots and check availability\n    \n    # Generate all possible 30-minute slots within work hours\n    possible_slots = []\n    current_time = work_start\n    \n    while current_time + duration <= work_end:\n        slot_start = current_time\n        slot_end = slot_start + duration\n        possible_slots.append((slot_start, slot_end))\n        current_time += 15  # Check every 15 minutes for efficiency\n    \n    # Check each slot against all busy intervals\n    for slot_start, slot_end in possible_slots:\n        conflict = False\n        for busy_start, busy_end in busy_intervals:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                conflict = True\n                break\n        if not conflict:\n            return f\"{minutes_to_time(slot_start)}:{minutes_to_time(slot_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"11:00:11:30\", \"12:00:12:30\"],  # Sophia\n    [\"09:00:09:30\", \"14:30:15:00\"],  # Judith\n    [\"15:30:16:00\", \"16:30:17:00\"],  # Linda\n    [],                               # Ethan\n    [\"09:00:09:30\", \"10:00:11:00\", \"11:30:12:30\", \"13:30:17:00\"],  # Anna\n    [\"09:30:10:00\", \"10:30:11:30\", \"12:00:12:30\", \"13:00:13:30\", \"14:00:14:30\", \"15:00:16:00\"],  # Marie\n    [\"09:00:11:00\", \"11:30:12:30\", \"13:00:13:30\", \"14:00:16:00\", \"16:30:17:00\"],  # Olivia\n]\n\n# Meeting duration in minutes\nduration = 30\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_445"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    busy_slots = {\n        'Megan': [(9*60, 9*60+30), (10*60, 11*60), (12*60, 12*60+30)],\n        'Christine': [(9*60, 9*60+30), (11*60+30, 12*60), (13*60, 14*60), (15*60+30, 16*60+30)],\n        'Gabriel': [],\n        'Sara': [(11*60+30, 12*60), (14*60+30, 15*60)],\n        'Bruce': [(9*60+30, 10*60), (10*60+30, 12*60), (12*60+30, 14*60), (14*60+30, 15*60), (15*60+30, 16*60+30)],\n        'Kathryn': [(10*60, 15*60+30), (16*60, 16*60+30)],\n        'Billy': [(9*60, 9*60+30), (11*60, 11*60+30), (12*60, 14*60), (14*60+30, 15*60+30)],\n    }\n\n    # Combine all busy slots and sort them\n    all_busy = []\n    for person in busy_slots:\n        for slot in busy_slots[person]:\n            all_busy.append(slot)\n    all_busy.sort()\n\n    # Merge overlapping or adjacent busy slots\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n\n    # Find the earliest available slot\n    prev_end = work_start\n    for start, end in merged_busy:\n        if start - prev_end >= meeting_duration:\n            # Found a slot\n            meeting_start = prev_end\n            meeting_end = meeting_start + meeting_duration\n            return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n        prev_end = max(prev_end, end)\n\n    # Check after the last busy slot\n    if work_end - prev_end >= meeting_duration:\n        meeting_start = prev_end\n        meeting_end = meeting_start + meeting_duration\n        return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n\n    return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_446"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n\n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules.values():\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort intervals by start time\n    busy_intervals.sort()\n\n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find available slots between work hours and busy intervals\n    available_slots = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Check each available slot for sufficient duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"Joan\": [\"10:00 to 11:00\", \"14:00 to 14:30\", \"16:30 to 17:00\"],\n    \"Sean\": [\"12:30 to 13:30\"],\n    \"Christian\": [\"10:00 to 10:30\", \"11:00 to 11:30\", \"12:00 to 12:30\", \"13:00 to 13:30\", \"14:00 to 15:00\"],\n    \"Jerry\": [],\n    \"Jessica\": [\"10:00 to 11:00\", \"11:30 to 13:00\", \"13:30 to 14:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"],\n    \"Virginia\": [\"9:00 to 9:30\", \"10:30 to 12:00\", \"13:30 to 15:00\", \"16:30 to 17:00\"],\n    \"Harold\": [\"9:30 to 10:00\", \"10:30 to 13:00\", \"13:30 to 16:00\", \"16:30 to 17:00\"],\n}\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, \"9:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_447"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    # Format: list of (start, end) in minutes\n    busy_slots = {\n        'Thomas': [(9*60, 9*60 + 30), (11*60 + 30, 12*60 + 30), (16*60 + 30, 17*60)],\n        'Kyle': [(9*60, 9*60 + 30), (12*60, 12*60 + 30), (13*60, 13*60 + 30), (14*60 + 30, 15*60 + 30), (16*60, 16*60 + 30)],\n        'Helen': [],\n        'Anna': [(12*60, 12*60 + 30), (14*60 + 30, 15*60)],\n        'Lauren': [(9*60, 10*60), (10*60 + 30, 11*60), (11*60 + 30, 12*60), (13*60, 13*60 + 30), (14*60, 16*60), (16*60 + 30, 17*60)],\n        'Frances': [(11*60, 17*60)],\n        'Maria': [(9*60, 10*60), (12*60, 12*60 + 30), (13*60, 14*60), (15*60, 16*60), (16*60 + 30, 17*60)],\n    }\n\n    # Collect all busy slots from all participants\n    all_busy = []\n    for person in busy_slots:\n        for start, end in busy_slots[person]:\n            all_busy.append((start, end))\n\n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_448"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:11:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert time strings to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for schedule in participants_schedules:\n        busy_intervals = []\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n        all_busy_intervals.append(busy_intervals)\n    \n    # Find all possible free intervals for each participant\n    all_free_intervals = []\n    for busy_intervals in all_busy_intervals:\n        free_intervals = []\n        # Start with the beginning of the work day\n        previous_end = work_start\n        for start, end in sorted(busy_intervals):\n            if start > previous_end:\n                free_intervals.append((previous_end, start))\n            previous_end = max(previous_end, end)\n        # Add the interval from the last meeting end to work end\n        if previous_end < work_end:\n            free_intervals.append((previous_end, work_end))\n        all_free_intervals.append(free_intervals)\n    \n    # Find overlapping free intervals across all participants\n    common_free_intervals = all_free_intervals[0]\n    for free_intervals in all_free_intervals[1:]:\n        new_common_free = []\n        i = j = 0\n        while i < len(common_free_intervals) and j < len(free_intervals):\n            start1, end1 = common_free_intervals[i]\n            start2, end2 = free_intervals[j]\n            # Find the overlap\n            overlap_start = max(start1, start2)\n            overlap_end = min(end1, end2)\n            if overlap_start < overlap_end:\n                new_common_free.append((overlap_start, overlap_end))\n            # Move the pointer which ends first\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free_intervals = new_common_free\n    \n    # Find the first interval that can fit the meeting duration\n    duration_minutes = duration * 60\n    for start, end in common_free_intervals:\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Walter is free\n    [],  # Frances is free\n    [\"9:00 to 9:30\", \"10:30 to 11:00\", \"12:30 to 13:00\", \"13:30 to 14:00\"],  # Martha\n    [],  # Lori is free\n    [\"9:00 to 10:00\", \"10:30 to 11:00\", \"12:30 to 15:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"],  # Beverly\n    [\"9:00 to 11:00\", \"11:30 to 12:30\", \"13:00 to 14:00\", \"14:30 to 16:00\", \"16:30 to 17:00\"],  # Christine\n    [\"9:00 to 10:30\", \"11:30 to 12:00\", \"13:00 to 14:00\", \"15:00 to 17:00\"],  # Catherine\n]\n\n# Find a 30-minute meeting between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, 0.5, \"9:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_449"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours=('09:00', '17:00')):\n    # Convert work hours to minutes since midnight\n    start_work, end_work = work_hours\n    work_start = int(start_work.split(':')[0]) * 60 + int(start_work.split(':')[1])\n    work_end = int(end_work.split(':')[0]) * 60 + int(end_work.split(':')[1])\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for person, schedules in participants_schedules.items():\n        for interval in schedules:\n            start, end = interval.split(' to ')\n            start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n            end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n            all_busy_intervals.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Find all free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in all_busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Now, find a free interval that is common to all participants (i.e., not blocked by anyone)\n    # To do this, we need to find intervals where no one is busy\n    # We can represent the free time as the complement of the union of all busy intervals\n    # The free time is the time not covered by any busy interval\n    \n    # Merge all busy intervals to find the total blocked time\n    merged_busy = []\n    for start, end in sorted(all_busy_intervals):\n        if not merged_busy:\n            merged_busy.append([start, end])\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                merged_busy[-1][1] = max(last_end, end)\n            else:\n                merged_busy.append([start, end])\n    \n    # Now, find the free intervals as the gaps between merged busy intervals and work hours\n    free_for_all = []\n    prev_end_free = work_start\n    \n    for start, end in merged_busy:\n        if start > prev_end_free:\n            free_for_all.append((prev_end_free, start))\n        prev_end_free = max(prev_end_free, end)\n    \n    if prev_end_free < work_end:\n        free_for_all.append((prev_end_free, work_end))\n    \n    # Now, find the first free interval that can accommodate the meeting duration\n    for start, end in free_for_all:\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            # Format the time as HH:MM:HH:MM\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = {\n    'Jonathan': ['9:30 to 10:00', '12:30 to 13:30', '14:30 to 15:00'],\n    'Janice': ['9:00 to 9:30', '11:30 to 12:00', '12:30 to 13:30', '14:30 to 15:00', '16:00 to 16:30'],\n    'Walter': ['9:30 to 10:00', '11:30 to 12:00'],\n    'Mary': ['12:00 to 12:30', '13:30 to 14:00'],\n    'Roger': ['9:30 to 10:30', '11:00 to 12:30', '13:00 to 13:30', '14:00 to 15:30', '16:00 to 16:30'],\n    'Tyler': ['9:30 to 11:00', '11:30 to 12:30', '13:30 to 14:00', '15:00 to 16:00'],\n    'Arthur': ['10:00 to 11:30', '12:30 to 13:00', '13:30 to 14:00', '14:30 to 16:00']\n}\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules))\n```",
            "count": "calendar_scheduling_example_450"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each participant's busy slots to minutes\n    # Judy: 10:30-11:30, 12:00-13:00, 15:00-16:00\n    judy_busy = [(10*60 + 30, 11*60 + 30), (12*60, 13*60), (15*60, 16*60)]\n    \n    # Jack: 10:30-11:30, 12:30-13:00, 14:00-14:30, 15:00-15:30, 16:30-17:00\n    jack_busy = [(10*60 + 30, 11*60 + 30), (12*60 + 30, 13*60),\n                 (14*60, 14*60 + 30), (15*60, 15*60 + 30), (16*60 + 30, 17*60)]\n    \n    # Ronald: 10:30-11:00, 11:30-12:00, 12:30-13:00, 16:30-17:00\n    ronald_busy = [(10*60 + 30, 11*60), (11*60 + 30, 12*60),\n                   (12*60 + 30, 13*60), (16*60 + 30, 17*60)]\n    \n    # Sandra: no meetings, but doesn't want to meet before 13:30\n    sandra_busy = [(0, 13*60 + 30)]  # Treat as busy before 13:30\n    \n    # Ashley: 10:00-10:30, 11:00-13:00, 13:30-16:00\n    ashley_busy = [(10*60, 10*60 + 30), (11*60, 13*60), (13*60 + 30, 16*60)]\n    \n    # Heather: 9:00-9:30, 10:00-11:30, 12:00-12:30, 13:30-15:30, 16:30-17:00\n    heather_busy = [(9*60, 9*60 + 30), (10*60, 11*60 + 30), (12*60, 12*60 + 30),\n                    (13*60 + 30, 15*60 + 30), (16*60 + 30, 17*60)]\n    \n    # Terry: 9:00-10:00, 10:30-11:00, 12:00-13:00, 13:30-16:00\n    terry_busy = [(9*60, 10*60), (10*60 + 30, 11*60), (12*60, 13*60), (13*60 + 30, 16*60)]\n    \n    # Combine all busy slots\n    all_busy = (judy_busy + jack_busy + ronald_busy + sandra_busy +\n                ashley_busy + heather_busy + terry_busy)\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the end of the day\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that is at least 30 minutes long\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert start time back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_time = start + meeting_duration\n            end_hh = end_time // 60\n            end_mm = end_time % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_451"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_start, work_end):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between merged intervals and work hours\n    available_slots = []\n    prev_end = work_start_min\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        available_slots.append((prev_end, work_end_min))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Austin\n    [\"9:00:9:30\", \"10:00:10:30\", \"11:00:11:30\", \"13:30:14:00\", \"14:30:15:00\", \"16:00:16:30\"],  # Andrew\n    [\"11:00:11:30\", \"16:30:17:00\"],  # Raymond\n    [\"9:00:9:30\", \"10:00:10:30\", \"11:30:12:30\", \"15:30:16:00\", \"16:30:17:00\"],  # Mary\n    [\"9:30:10:00\", \"11:00:11:30\", \"12:00:12:30\", \"13:00:15:30\", \"16:00:17:00\"],  # Bobby\n    [\"9:00:10:30\", \"11:30:13:00\", \"13:30:16:30\"],  # Shirley\n    [\"9:30:10:30\", \"11:30:12:00\", \"13:00:14:30\", \"15:30:16:30\"],  # Jordan\n]\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules=participants_schedules, duration=30, work_start=\"9:00\", work_end=\"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_452"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:30:10:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_hour, end_hour = work_hours\n    # Convert work hours to minutes\n    start_time = start_hour * 60\n    end_time = end_hour * 60\n    \n    # Initialize a list to keep track of busy times for all participants\n    busy_times = []\n    \n    # Collect all busy intervals for each participant\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start = interval[0] * 60\n            end = interval[1] * 60\n            busy_times.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_times.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_times:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between merged intervals\n    available_slots = []\n    previous_end = start_time\n    \n    for start, end in merged:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy interval\n    if previous_end < end_time:\n        available_slots.append((previous_end, end_time))\n    \n    # Check each available slot for the required duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration * 60:\n            # Found a suitable slot\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration * 60\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available slot found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (9, 17)\n\n# Define meeting duration in hours (0.5 hours = 30 minutes)\nduration = 0.5\n\n# Define each participant's schedule as a list of busy intervals in HH:MM format\nparticipants_schedules = [\n    [(10.0, 10.5), (11.0, 11.5)],  # Natalie\n    [(9.0, 9.5), (13.0, 13.5)],     # Dylan\n    [(11.5, 12.0), (13.5, 14.0), (15.0, 15.5), (16.0, 16.5)],  # Pamela\n    [],                              # Charlotte\n    [(10.0, 11.0), (11.5, 12.5), (13.0, 13.5), (14.5, 17.0)],  # Ann\n    [(9.0, 9.5), (10.0, 13.5), (14.0, 14.5), (15.5, 17.0)],     # Jason\n    [(10.0, 11.0), (12.5, 14.5), (15.0, 16.0)],                 # Benjamin\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_453"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours=('09:00', '17:00')):\n    # Convert work hours to minutes since midnight\n    start_work, end_work = work_hours\n    work_start = int(start_work.split(':')[0]) * 60 + int(start_work.split(':')[1])\n    work_end = int(end_work.split(':')[0]) * 60 + int(end_work.split(':')[1])\n    \n    # Initialize the free slots for all participants\n    free_slots = []\n    \n    for participant, busy_slots in participants_schedules.items():\n        participant_free = []\n        # Start with the entire work day as free\n        current_start = work_start\n        \n        # Process each busy slot\n        for busy in busy_slots:\n            busy_start = int(busy[0].split(':')[0]) * 60 + int(busy[0].split(':')[1])\n            busy_end = int(busy[1].split(':')[0]) * 60 + int(busy[1].split(':')[1])\n            \n            if current_start < busy_start:\n                participant_free.append((current_start, busy_start))\n            current_start = max(current_start, busy_end)\n        \n        # Add the remaining time after the last busy slot\n        if current_start < work_end:\n            participant_free.append((current_start, work_end))\n        \n        free_slots.append(participant_free)\n    \n    # Find the intersection of all free slots\n    common_free = free_slots[0]\n    for participant in free_slots[1:]:\n        new_common = []\n        i = j = 0\n        while i < len(common_free) and j < len(participant):\n            start = max(common_free[i][0], participant[j][0])\n            end = min(common_free[i][1], participant[j][1])\n            if start < end:\n                new_common.append((start, end))\n            if common_free[i][1] < participant[j][1]:\n                i += 1\n            else:\n                j += 1\n        common_free = new_common\n    \n    # Find the first slot that can accommodate the meeting\n    for slot in common_free:\n        if slot[1] - slot[0] >= duration_minutes:\n            meeting_start = slot[0]\n            meeting_end = meeting_start + duration_minutes\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = {\n    'Sara': [('09:30', '10:30')],\n    'Ethan': [('11:00', '11:30'), ('12:00', '12:30'), ('13:30', '15:00'), ('15:30', '16:00')],\n    'Stephanie': [],\n    'Hannah': [('12:30', '13:30'), ('15:30', '16:00'), ('16:30', '17:00')],\n    'Kevin': [('09:00', '15:00'), ('15:30', '16:00'), ('16:30', '17:00')],\n    'Susan': [('10:00', '10:30'), ('11:00', '13:30'), ('14:30', '16:00'), ('16:30', '17:00')],\n    'Bryan': [('09:00', '09:30'), ('10:00', '10:30'), ('11:30', '12:00'), ('13:30', '15:30'), ('16:30', '17:00')]\n}\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules))\n```",
            "count": "calendar_scheduling_example_454"
        },
        {
            "final_program_time": "{16:00:16:01}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_start, work_end):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes  # Add back 540 to start from 9:00\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Initialize the availability list\n    availability = [True] * (work_end_min - work_start_min)\n    \n    for person in participants_schedules:\n        person_availability = [True] * (work_end_min - work_start_min)\n        for busy in person:\n            start_min = max(time_to_minutes(busy[0]), work_start_min)\n            end_min = min(time_to_minutes(busy[1]), work_end_min)\n            for i in range(start_min, end_min):\n                if i - work_start_min >= 0 and i - work_start_min < len(person_availability):\n                    person_availability[i - work_start_min] = False\n        # Merge with overall availability\n        for i in range(len(availability)):\n            availability[i] = availability[i] and person_availability[i]\n    \n    # Find the first available slot of duration\n    required_slots = duration // 30  # Assuming slots are 30 minutes\n    current_slots = 0\n    for i in range(len(availability)):\n        if availability[i]:\n            current_slots += 1\n            if current_slots >= required_slots:\n                start = i - required_slots + 1\n                end = i + 1\n                start_time = minutes_to_time(start + work_start_min)\n                end_time = minutes_to_time(end + work_start_min)\n                return f\"{start_time}:{end_time}\"\n        else:\n            current_slots = 0\n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [(\"9:30\", \"10:00\"), (\"12:00\", \"12:30\"), (\"14:00\", \"14:30\"), (\"15:30\", \"16:00\")],  # Ryan\n    [],  # Jerry\n    [(\"9:00\", \"9:30\"), (\"14:30\", \"15:00\")],  # Raymond\n    [(\"9:00\", \"10:00\"), (\"10:30\", \"11:00\"), (\"12:00\", \"12:30\"), (\"15:00\", \"15:30\"), (\"16:30\", \"17:00\")],  # Eugene\n    [(\"9:30\", \"12:30\"), (\"13:00\", \"15:30\"), (\"16:30\", \"17:00\")],  # Justin\n    [(\"9:00\", \"9:30\"), (\"10:00\", \"12:00\"), (\"12:30\", \"13:00\"), (\"15:00\", \"16:00\")],  # Gerald\n    [(\"9:00\", \"10:00\"), (\"11:30\", \"13:00\"), (\"13:30\", \"14:00\"), (\"15:00\", \"15:30\"), (\"16:30\", \"17:00\")],  # Eric\n]\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, 30, \"9:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_455"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    start, end = work_hours\n    # Convert time strings to minutes for easier calculation\n    start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n    end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n    \n    # Initialize a list to mark busy times\n    timeline = [False] * (end_min - start_min)\n    \n    # Mark busy times for each participant\n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            busy_start_min = int(busy_start.split(':')[0]) * 60 + int(busy_start.split(':')[1])\n            busy_end_min = int(busy_end.split(':')[0]) * 60 + int(busy_end.split(':')[1])\n            # Only consider times within work hours\n            busy_start_min = max(busy_start_min, start_min)\n            busy_end_min = min(busy_end_min, end_min)\n            for i in range(busy_start_min - start_min, busy_end_min - start_min):\n                if i < len(timeline):\n                    timeline[i] = True\n    \n    # Find a free slot of the required duration\n    required_slots = duration\n    current_free = 0\n    for i in range(len(timeline)):\n        if not timeline[i]:\n            current_free += 1\n            if current_free >= required_slots:\n                slot_start = i - current_free + 1 + start_min\n                slot_end = slot_start + required_slots\n                # Convert back to HH:MM format\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_hh = slot_end // 60\n                end_mm = slot_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n        else:\n            current_free = 0\n    return \"No available slot found\"\n\n# Define participants' schedules in HH:MM format\nparticipants_schedules = [\n    [(\"09:30\", \"10:30\"), (\"12:00\", \"12:30\"), (\"14:00\", \"14:30\")],  # Margaret\n    [(\"09:30\", \"10:00\"), (\"13:30\", \"14:00\")],  # Justin\n    [(\"10:00\", \"10:30\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"14:00\", \"14:30\")],  # Noah\n    [(\"09:30\", \"10:30\"), (\"11:00\", \"11:30\"), (\"13:00\", \"13:30\"), (\"14:00\", \"15:00\")],  # Madison\n    [(\"09:30\", \"10:00\"), (\"11:00\", \"12:00\"), (\"12:30\", \"13:30\"), (\"14:00\", \"14:30\"), (\"15:00\", \"15:30\"), (\"16:00\", \"16:30\")],  # Carl\n    [(\"09:00\", \"10:30\"), (\"11:30\", \"14:30\"), (\"15:00\", \"16:30\")],  # Denise\n    [(\"09:30\", \"10:00\"), (\"10:30\", \"11:00\"), (\"11:30\", \"14:00\"), (\"14:30\", \"15:30\"), (\"16:00\", \"16:30\")],  # Mason\n]\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\n# Work hours (9:00 to 17:00)\nwork_hours = (\"09:00\", \"17:00\")\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, duration, work_hours))\n```",
            "count": "calendar_scheduling_example_456"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert each participant's busy slots to minutes\n    andrea_busy = [(9*60 + 30, 10*60 + 30), (13*60 + 30, 14*60 + 30)]\n    ruth_busy = [(12*60 + 30, 13*60 + 0), (15*60 + 0, 15*60 + 30)]\n    steven_busy = [(10*60 + 0, 10*60 + 30), (11*60 + 0, 11*60 + 30), \n                   (12*60 + 0, 12*60 + 30), (13*60 + 30, 14*60 + 0), \n                   (15*60 + 0, 16*60 + 0)]\n    grace_busy = []\n    kyle_busy = [(9*60 + 0, 9*60 + 30), (10*60 + 30, 12*60 + 0), \n                 (12*60 + 30, 13*60 + 0), (13*60 + 30, 15*60 + 0), \n                 (15*60 + 30, 16*60 + 0), (16*60 + 30, 17*60 + 0)]\n    elijah_busy = [(9*60 + 0, 11*60 + 0), (11*60 + 30, 13*60 + 0), \n                   (13*60 + 30, 14*60 + 0), (15*60 + 30, 16*60 + 0), \n                   (16*60 + 30, 17*60 + 0)]\n    lori_busy = [(9*60 + 0, 9*60 + 30), (10*60 + 0, 11*60 + 30), \n                 (12*60 + 0, 13*60 + 30), (14*60 + 0, 16*60 + 0), \n                 (16*60 + 30, 17*60 + 0)]\n\n    # Combine all busy slots\n    all_busy = andrea_busy + ruth_busy + steven_busy + grace_busy + kyle_busy + elijah_busy + lori_busy\n\n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check each free slot for a 30-minute window\n    meeting_duration = 30\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Found a suitable slot\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_457"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Define each participant's busy times in minutes (start, end)\n    busy_times = {\n        'Wayne': [],\n        'Melissa': [(10 * 60, 11 * 60), (12 * 60 + 30, 14 * 60), (15 * 60, 15 * 60 + 30)],\n        'Catherine': [],\n        'Gregory': [(12 * 60 + 30, 13 * 60), (15 * 60 + 30, 16 * 60)],\n        'Victoria': [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 11 * 60 + 30), (13 * 60, 14 * 60), \n                     (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60 + 30)],\n        'Thomas': [(10 * 60, 12 * 60), (12 * 60 + 30, 13 * 60), (14 * 60 + 30, 16 * 60)],\n        'Jennifer': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (11 * 60, 13 * 60), \n                     (13 * 60 + 30, 14 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n    }\n\n    # Wayne's preference: avoid before 14:00\n    wayne_preference_start = 14 * 60\n\n    # Generate all busy intervals\n    all_busy = []\n    for person, intervals in busy_times.items():\n        for interval in intervals:\n            all_busy.append(interval)\n\n    # Add Wayne's preference as a busy interval if before 14:00\n    all_busy.append((work_start, wayne_preference_start))\n\n    # Sort all busy intervals by start time\n    all_busy.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append([start, end])\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1][1] = max(last_end, end)\n            else:\n                merged.append([start, end])\n\n    # Find free slots between merged busy intervals and work hours\n    free_slots = []\n    previous_end = work_start\n    for start, end in merged:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check each free slot for 30-minute availability\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Found a suitable slot\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            def to_time_str(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{to_time_str(meeting_start)}:{to_time_str(meeting_end)}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_458"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:9:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - work_hours_start_min\n    \n    work_hours_start_min = work_hours_start * 60\n    work_hours_end_min = work_hours_end * 60\n    duration = duration_minutes\n    \n    # Initialize a list to track busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by checking gaps between busy intervals\n    free_intervals = []\n    prev_end = 0\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    # Check the interval after the last busy interval until end of work hours\n    if prev_end < (work_hours_end_min - work_hours_start_min):\n        free_intervals.append((prev_end, work_hours_end_min - work_hours_start_min))\n    \n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start + work_hours_start_min\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Define work hours and meeting duration\nwork_hours_start = 9 * 60  # 9:00 in minutes\nwork_hours_end = 17 * 60    # 17:00 in minutes\nduration = 30               # 30 minutes\n\n# Define participants' schedules in HH:MM:HH:MM format\nparticipants_schedules = [\n    [\"10:30:11:00\", \"12:00:12:30\", \"14:00:14:30\", \"15:00:15:30\", \"16:00:17:00\"],  # Marie\n    [\"11:00:11:30\", \"14:00:15:30\"],  # Roger\n    [\"10:00:10:30\", \"15:30:16:00\"],  # John\n    [\"13:30:14:00\", \"16:30:17:00\"],  # Peter\n    [\"09:30:15:30\", \"16:00:17:00\"],  # Ruth\n    [\"10:30:11:00\", \"12:00:13:00\", \"14:30:17:00\"],  # James\n    [\"09:30:11:00\", \"11:30:12:00\", \"12:30:15:00\", \"15:30:17:00\"],  # Victoria\n]\n\n# Find a meeting time\nmeeting_time = find_meeting_time(participants_schedules, 9, 17, 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_459"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all times to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the available slots as the entire work day\n    available_slots = [(work_start, work_end)]\n    \n    # Process each participant's busy times\n    for busy_times in participants_busy_times:\n        new_available_slots = []\n        for slot in available_slots:\n            slot_start, slot_end = slot\n            # Subtract each busy time from the current slot\n            for busy_start, busy_end in busy_times:\n                busy_start_min = time_to_minutes(busy_start)\n                busy_end_min = time_to_minutes(busy_end)\n                # If the busy time overlaps with the slot, split the slot\n                if busy_start_min < slot_end and busy_end_min > slot_start:\n                    if busy_start_min > slot_start:\n                        new_available_slots.append((slot_start, busy_start_min))\n                    if busy_end_min < slot_end:\n                        new_available_slots.append((busy_end_min, slot_end))\n                    break\n            else:\n                new_available_slots.append((slot_start, slot_end))\n        available_slots = new_available_slots\n    \n    # Find the first available slot that can fit the meeting\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_minutes:\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            meeting_start = minutes_to_time(slot_start)\n            meeting_end = minutes_to_time(slot_start + duration_minutes)\n            return f\"{meeting_start}:{meeting_end}\"\n    return \"No suitable time found\"\n\n# Define the participants' busy times\nparticipants_busy_times = [\n    # Katherine\n    [(\"12:00\", \"12:30\"), (\"13:00\", \"14:00\"), (\"14:30\", \"15:00\")],\n    # Douglas\n    [(\"09:00\", \"09:30\"), (\"13:00\", \"13:30\")],\n    # Ann\n    [(\"14:30\", \"15:30\")],\n    # Pamela\n    [(\"10:00\", \"11:00\")],\n    # Gloria\n    [(\"09:00\", \"12:30\"), (\"13:00\", \"15:30\"), (\"16:00\", \"17:00\")],\n    # Donna\n    [(\"09:00\", \"09:30\"), (\"10:30\", \"11:00\"), (\"12:30\", \"13:00\"), (\"13:30\", \"15:00\"), (\"16:00\", \"17:00\")],\n    # Christopher\n    [(\"09:30\", \"11:00\"), (\"11:30\", \"15:30\"), (\"16:30\", \"17:00\")]\n]\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_busy_times, \"09:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_460"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:9:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability of all participants\n    for start, end in free_intervals:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"09:30:10:30\", \"14:30:15:00\", \"16:30:17:00\"],  # Justin\n    [],                                              # Nancy\n    [\"09:30:10:00\", \"12:00:12:30\", \"14:00:14:30\", \"15:30:16:00\"],  # Willie\n    [\"09:30:10:00\", \"12:30:13:00\", \"13:30:14:00\", \"16:30:17:00\"],  # Alan\n    [\"10:00:10:30\", \"11:00:12:30\", \"13:00:14:00\", \"14:30:15:30\", \"16:00:17:00\"],  # Brian\n    [\"09:30:11:00\", \"11:30:12:00\", \"13:30:16:30\"],  # Lori\n    [\"10:30:11:30\", \"12:00:12:30\", \"13:30:14:00\", \"14:30:16:00\", \"16:30:17:00\"],  # Isabella\n]\n\n# Define work hours and meeting duration\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 30  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_461"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    meeting_duration_min = meeting_duration\n\n    # Collect all busy intervals for all participants\n    all_busy_intervals = []\n    for busy_times in participants_busy_times.values():\n        for busy in busy_times:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            all_busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged_busy = []\n    for start, end in all_busy_intervals:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n\n    # Find free intervals by inverting the busy intervals\n    free_intervals = []\n    previous_end = work_start\n    for start, end in merged_busy:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_intervals.append((previous_end, work_end))\n\n    # Find the earliest free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= meeting_duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return None\n\n# Define participants' busy times\nparticipants_busy_times = {\n    \"Justin\": [\"11:30 to 12:00\", \"13:00 to 13:30\"],\n    \"Diane\": [\"9:30 to 10:30\", \"11:30 to 12:00\", \"12:30 to 13:30\", \"14:30 to 15:30\", \"16:00 to 16:30\"],\n    \"Bryan\": [\"9:00 to 10:30\", \"12:00 to 12:30\", \"13:00 to 14:30\", \"15:00 to 15:30\", \"16:00 to 17:00\"],\n    \"Beverly\": [\"9:30 to 10:30\", \"11:30 to 12:30\", \"13:00 to 13:30\", \"14:00 to 14:30\", \"16:00 to 17:00\"]\n}\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 30  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_462"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:30:15:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert work hours to minutes since midnight for easier calculation\n    start_time = work_hours_start * 60\n    end_time = work_hours_end * 60\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    all_busy_intervals = []\n    \n    # Collect all busy intervals from each participant\n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            all_busy_intervals.append((busy_start * 60, busy_end * 60))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_intervals = []\n    for start, end in all_busy_intervals:\n        if not merged_intervals:\n            merged_intervals.append((start, end))\n        else:\n            last_start, last_end = merged_intervals[-1]\n            if start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_intervals[-1] = (new_start, new_end)\n            else:\n                merged_intervals.append((start, end))\n    \n    # Find free intervals between work hours and merged busy intervals\n    free_intervals = []\n    previous_end = start_time\n    \n    for start, end in merged_intervals:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the interval after the last busy interval\n    if previous_end < end_time:\n        free_intervals.append((previous_end, end_time))\n    \n    # Find the first free interval that can accommodate the meeting duration\n    duration = duration_minutes\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Convert back to hours and minutes\n            start_hour = meeting_start // 60\n            start_minute = meeting_start % 60\n            end_hour = meeting_end // 60\n            end_minute = meeting_end % 60\n            return f\"{start_hour:02d}:{start_minute:02d}:{end_hour:02d}:{end_minute:02d}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules in hours (converted to float for simplicity)\nparticipants_schedules = [\n    [(10.5, 11.5), (12.5, 14.0), (15.0, 15.5)],  # Joyce\n    [(9.0, 9.5), (16.0, 16.5)],  # Diana\n    [(9.0, 9.5), (12.0, 12.5), (13.0, 13.5), (14.0, 14.5)],  # Emma\n    [(10.0, 10.5), (16.5, 17.0)],  # Gregory\n    [(9.0, 9.5), (10.0, 10.5), (11.0, 14.0)],  # Tyler\n    [(9.0, 11.0), (11.5, 12.0), (12.5, 14.0), (15.5, 16.5)],  # Jacob\n    [(9.0, 9.5), (10.0, 11.5), (12.0, 14.5), (15.0, 16.0), (16.5, 17.0)]  # Bruce\n]\n\n# Work hours from 9:00 to 17:00 (5:00 PM)\nwork_hours_start = 9.0\nwork_hours_end = 17.0\nmeeting_duration = 30  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_463"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration_minutes):\n    # Convert work hours to minutes since midnight\n    work_start = int(work_hours[0].split(':')[0]) * 60 + int(work_hours[0].split(':')[1])\n    work_end = int(work_hours[1].split(':')[0]) * 60 + int(work_hours[1].split(':')[1])\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for interval in schedule:\n            start_time = interval[0]\n            end_time = interval[1]\n            start_min = int(start_time.split(':')[0]) * 60 + int(start_time.split(':')[1])\n            end_min = int(end_time.split(':')[0]) * 60 + int(end_time.split(':')[1])\n            all_busy_intervals.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in all_busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability of duration_minutes\n    for interval in free_intervals:\n        start, end = interval\n        if end - start >= duration_minutes:\n            # Convert start time back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_time = start + duration_minutes\n            end_hh = end_time // 60\n            end_mm = end_time % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [(\"10:30\", \"11:30\")],  # Rachel\n    [(\"10:30\", \"11:00\"), (\"12:00\", \"12:30\")],  # Henry\n    [(\"11:30\", \"12:00\"), (\"12:30\", \"14:30\"), (\"15:30\", \"16:00\")],  # Jesse\n    [(\"10:30\", \"12:00\"), (\"16:00\", \"16:30\")],  # Albert\n    [(\"09:00\", \"09:30\"), (\"10:30\", \"12:30\"), (\"13:30\", \"14:00\"), (\"15:00\", \"16:00\")],  # Ashley\n    [(\"09:00\", \"10:00\"), (\"10:30\", \"11:30\"), (\"12:30\", \"15:00\"), (\"15:30\", \"17:00\")],  # Jonathan\n    [(\"09:00\", \"09:30\"), (\"10:30\", \"17:00\")]  # Walter\n]\n\n# Define work hours and meeting duration\nwork_hours = (\"09:00\", \"17:00\")\nduration_minutes = 30\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration_minutes))\n```",
            "count": "calendar_scheduling_example_464"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define each participant's busy times in minutes (start, end)\n    busy_times = {\n        'Gregory': [(14 * 60, 17 * 60)],\n        'John': [],\n        'Roger': [],\n        'Roy': [(10 * 60 + 30, 11 * 60), (14 * 60 + 30, 15 * 60)],\n        'Adam': [(9 * 60, 12 * 60 + 30), (13 * 60 + 30, 17 * 60)],\n        'Judith': [(9 * 60, 10 * 60 + 30), (12 * 60, 13 * 60), (13 * 60 + 30, 14 * 60 + 30), (15 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Robert': [(9 * 60, 13 * 60), (13 * 60 + 30, 15 * 60), (15 * 60 + 30, 17 * 60)],\n    }\n\n    # Combine all busy times and sort them\n    all_busy = []\n    for person in busy_times:\n        for start, end in busy_times[person]:\n            all_busy.append((start, end))\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    prev_end = work_start\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_465"
        },
        {
            "final_program_time": "{16:00:16:01}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_start, work_end):\n    # Convert time strings to minutes since 9:00 (work_start)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work_start is 9:00\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Initialize a list to mark busy times\n    timeline = [0] * (work_end_min - work_start_min)\n    \n    # Mark busy intervals for each participant\n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            start = max(time_to_minutes(busy_start) - work_start_min, 0)\n            end = min(time_to_minutes(busy_end) - work_start_min, len(timeline))\n            for i in range(start, end):\n                timeline[i] += 1\n    \n    # Find the first interval where all are free (timeline[i] == 0) for duration\n    required_slots = duration // 30  # Assuming slots are 30 minutes each\n    current_free = 0\n    \n    for i in range(len(timeline)):\n        if timeline[i] == 0:\n            current_free += 1\n            if current_free >= required_slots:\n                start_time = i - required_slots + 1\n                start_hh = work_start_min + start_time\n                end_hh = start_hh + required_slots\n                # Convert back to HH:MM format\n                start_str = f\"{start_hh // 60 + 9}:{start_hh % 60:02d}\"\n                end_str = f\"{end_hh // 60 + 9}:{end_hh % 60:02d}\"\n                return f\"{start_str}:{end_str}\"\n        else:\n            current_free = 0\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules in HH:MM format\nparticipants_schedules = [\n    [(\"9:30\", \"10:00\"), (\"12:30\", \"13:00\"), (\"14:00\", \"15:00\")],  # Kyle\n    [],  # Danielle\n    [(\"10:00\", \"10:30\"), (\"12:00\", \"12:30\")],  # Kelly\n    [],  # Carol\n    [(\"9:00\", \"10:00\"), (\"10:30\", \"11:30\"), (\"12:00\", \"13:00\"), \n     (\"13:30\", \"14:00\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:00\"), \n     (\"16:30\", \"17:00\")],  # Angela\n    [(\"9:30\", \"10:00\"), (\"11:30\", \"13:00\"), (\"13:30\", \"15:30\")],  # Carolyn\n    [(\"9:00\", \"15:30\"), (\"16:30\", \"17:00\")],  # Gary\n]\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_start = \"9:00\"\nwork_end = \"17:00\"\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_start, work_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_466"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:30:16:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert time strings to minutes since start of day for easier handling\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start, work_end = map(time_to_minutes, work_hours.split(' to '))\n    duration_min = duration * 60\n\n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n\n    # For each participant, subtract their busy times from the free slots\n    for participant in participants_schedules.values():\n        for busy_start, busy_end in participant:\n            busy_start_min = time_to_minutes(busy_start)\n            busy_end_min = time_to_minutes(busy_end)\n            new_free_slots = []\n            for slot_start, slot_end in free_slots:\n                if busy_end_min <= slot_start or busy_start_min >= slot_end:\n                    # No overlap, keep the slot as is\n                    new_free_slots.append((slot_start, slot_end))\n                else:\n                    # Overlap, split the slot\n                    if slot_start < busy_start_min:\n                        new_free_slots.append((slot_start, busy_start_min))\n                    if busy_end_min < slot_end:\n                        new_free_slots.append((busy_end_min, slot_end))\n            free_slots = new_free_slots\n\n    # Find the first slot that can fit the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_end = slot_start + duration_min\n            return f\"{minutes_to_time(slot_start)}:{minutes_to_time(meeting_end)}\"\n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"Nicole\": [(\"9:00\", \"9:30\"), (\"11:00\", \"11:30\"), (\"12:30\", \"13:00\"), (\"14:30\", \"15:00\")],\n    \"Wayne\": [(\"10:30\", \"11:00\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"14:30\", \"15:30\"), (\"16:00\", \"16:30\")],\n    \"Gerald\": [(\"9:30\", \"10:00\"), (\"10:30\", \"11:00\")],\n    \"Christian\": [],\n    \"Harold\": [(\"9:00\", \"10:00\"), (\"10:30\", \"14:00\"), (\"14:30\", \"15:30\"), (\"16:30\", \"17:00\")],\n    \"Larry\": [(\"9:00\", \"12:00\"), (\"12:30\", \"13:00\"), (\"13:30\", \"14:00\"), (\"14:30\", \"15:30\"), (\"16:00\", \"17:00\")],\n    \"Jason\": [(\"9:30\", \"10:00\"), (\"10:30\", \"11:00\"), (\"12:00\", \"12:30\"), (\"13:30\", \"15:30\"), (\"16:30\", \"17:00\")]\n}\n\n# Find a 30-minute meeting time between 9:00 to 17:00\nmeeting_time = find_meeting_time(participants_schedules, 0.5, \"9:00 to 17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_467"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:30:16:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    meeting_duration_min = meeting_duration * 60\n    \n    # Collect all busy intervals for all participants\n    all_busy_intervals = []\n    for busy_times in participants_busy_times:\n        for interval in busy_times:\n            start, end = map(time_to_minutes, interval.split(':'))\n            all_busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_intervals = []\n    for start, end in all_busy_intervals:\n        if not merged_intervals:\n            merged_intervals.append([start, end])\n        else:\n            last_start, last_end = merged_intervals[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                merged_intervals[-1][1] = max(end, last_end)\n            else:\n                merged_intervals.append([start, end])\n    \n    # Find available slots by checking gaps between merged intervals and work hours\n    available_slots = []\n    previous_end = work_start\n    \n    for start, end in merged_intervals:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy interval until work_end\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define work hours and meeting duration\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 30  # minutes\n\n# Define each participant's busy times\nparticipants_busy_times = [\n    [\"09:30:10:00\", \"10:30:11:00\", \"16:00:17:00\"],  # Stephen\n    [],                                              # Jacqueline\n    [],                                              # Logan\n    [\"09:30:10:00\", \"15:00:15:30\"],                 # Larry\n    [\"09:30:12:00\", \"13:00:13:30\", \"14:00:14:30\", \"15:00:15:30\"],  # Jean\n    [\"09:00:12:30\", \"13:30:15:00\"],                 # Adam\n    [\"09:00:12:00\", \"12:30:15:30\", \"16:00:17:00\"],  # Eugene\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_468"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals\n    busy_intervals = []\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability\n    duration = duration_minutes\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Jack\n    [\"09:30:10:00\", \"13:30:14:00\"],  # Jacob\n    [\"09:00:09:30\", \"10:00:10:30\", \"11:30:12:00\", \"14:00:14:30\", \"15:00:15:30\", \"16:00:16:30\"],  # Edward\n    [],  # Sean\n    [\"10:00:10:30\", \"11:00:11:30\", \"12:00:12:30\", \"13:00:14:30\", \"15:30:16:30\"],  # Lori\n    [\"09:00:11:00\", \"12:00:12:30\", \"14:00:14:30\", \"15:00:15:30\", \"16:30:17:00\"],  # Billy\n    [\"10:00:12:30\", \"13:30:14:00\", \"14:30:16:30\"],  # Willie\n]\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, \"09:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_469"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define each participant's busy times in minutes (start, end)\n    busy_times = {\n        'Jordan': [(9*60, 9*60+30), (11*60, 11*60+30), (12*60+30, 13*60), (13*60+30, 14*60)],\n        'Madison': [(10*60, 11*60), (11*60+30, 12*60), (14*60+30, 15*60+30), (16*60+30, 17*60)],\n        'Kimberly': [(11*60+30, 12*60), (16*60+30, 17*60)],\n        'Carol': [(9*60, 9*60+30), (10*60+30, 12*60), (13*60+30, 14*60), (16*60, 16*60+30)],\n        'Nathan': [(10*60, 14*60), (14*60+30, 15*60+30), (16*60, 17*60)],\n        'Walter': [(9*60, 9*60+30), (10*60, 10*60+30), (11*60, 11*60+30), (12*60, 12*60+30), (13*60+30, 14*60), (14*60+30, 16*60)],\n        'Aaron': [(9*60, 9*60+30), (10*60, 10*60+30), (11*60, 12*60), (13*60+30, 14*60), (15*60+30, 17*60)],\n    }\n    \n    # Carol's preference: not after 10:00, so before 10:00\n    carol_preference_end = 10 * 60\n    \n    # Collect all busy times\n    all_busy = []\n    for person in busy_times:\n        all_busy.extend(busy_times[person])\n    \n    # Add Carol's preference as a \"busy\" time after 10:00\n    all_busy.append((carol_preference_end, work_end))\n    \n    # Sort busy times by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check if there's any time left after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Filter free slots that are at least 30 minutes and before Carol's preference\n    meeting_duration = 30\n    valid_slots = []\n    for start, end in free_slots:\n        if end <= carol_preference_end and (end - start) >= meeting_duration:\n            valid_slots.append((start, end))\n    \n    # If there's a valid slot before 10:00, return the first one\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n    else:\n        return \"No valid time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_470"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each person's busy slots to minutes\n    busy_slots = {\n        'Willie': [],\n        'Scott': [(9*60, 9*60+30), (10*60, 10*60+30), (15*60+30, 16*60), (16*60+30, 17*60)],\n        'Jordan': [(9*60, 9*60+30), (10*60, 10*60+30), (12*60, 12*60+30), (16*60+30, 17*60)],\n        'Austin': [(11*60+30, 13*60), (13*60+30, 14*60), (14*60+30, 15*60), (15*60+30, 16*60)],\n        'Kimberly': [(9*60, 9*60+30), (10*60+30, 11*60), (12*60+30, 14*60+30), (15*60, 16*60)],\n        'Teresa': [(9*60, 9*60+30), (10*60, 11*60+30), (12*60, 13*60), (15*60, 15*60+30), (16*60+30, 17*60)],\n        'Dylan': [(9*60+30, 10*60), (10*60+30, 12*60), (13*60, 15*60), (15*60+30, 16*60), (16*60+30, 17*60)],\n    }\n    \n    # Collect all busy slots\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by merging busy slots\n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Check for a free slot of at least 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = (start + meeting_duration) // 60\n            end_mm = (start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_471"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define each person's busy times in minutes (start, end)\n    busy_times = {\n        'Roy': [(16 * 60, 17 * 60)],\n        'Thomas': [(11 * 60 + 30, 12 * 60), (14 * 60 + 30, 15 * 60)],\n        'John': [(10 * 60 + 30, 11 * 60), (12 * 60, 12 * 60 + 30), \n                 (13 * 60 + 30, 14 * 60 + 30), (15 * 60, 15 * 60 + 30), \n                 (16 * 60 + 30, 17 * 60)],\n        'Amy': [(9 * 60, 9 * 60 + 30), (13 * 60 + 30, 14 * 60), \n                (14 * 60 + 30, 15 * 60), (16 * 60 + 30, 17 * 60)],\n        'Mason': [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 11 * 60), \n                  (11 * 60 + 30, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), \n                  (14 * 60, 14 * 60 + 30), (15 * 60 + 30, 16 * 60), \n                  (16 * 60 + 30, 17 * 60)],\n        'Zachary': [(10 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60), \n                    (12 * 60 + 30, 14 * 60), (15 * 60, 16 * 60), \n                    (16 * 60 + 30, 17 * 60)],\n        'Jacqueline': [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 11 * 60), \n                       (11 * 60 + 30, 12 * 60 + 30), (13 * 60 + 30, 16 * 60 + 30)]\n    }\n    \n    # Collect all busy intervals\n    all_busy = []\n    for person in busy_times:\n        all_busy.extend(busy_times[person])\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check for a 30-minute slot in free intervals\n    meeting_duration = 30\n    for start, end in free_intervals:\n        if end - start >= meeting_duration:\n            # Convert start time back to HH:MM format\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_472"
        },
        {
            "final_program_time": "{69:00:69:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours\n    start_min = time_to_minutes(start_work)\n    end_min = time_to_minutes(end_work)\n    \n    # Initialize the availability list\n    availability = [True] * (end_min - start_min)\n    \n    # Mark busy times for each participant\n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            busy_start_min = time_to_minutes(busy_start) - start_min\n            busy_end_min = time_to_minutes(busy_end) - start_min\n            for i in range(busy_start_min, busy_end_min):\n                if 0 <= i < len(availability):\n                    availability[i] = False\n    \n    # Find the first available slot of duration\n    required_slots = duration // 30  # assuming 30-minute slots for simplicity\n    current_slots = 0\n    for i in range(len(availability)):\n        if availability[i]:\n            current_slots += 1\n            if current_slots >= required_slots:\n                start_time = i - required_slots + 1\n                meeting_start = start_min + start_time * 30\n                meeting_end = meeting_start + duration\n                return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n        else:\n            current_slots = 0\n    \n    return \"No available time slot found\"\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 30  # minutes\n\n# Define each participant's busy times\nparticipants_schedules = [\n    [(\"9:00\", \"9:30\"), (\"11:30\", \"12:00\")],  # Gregory\n    [(\"9:00\", \"9:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"13:30\"), (\"15:00\", \"16:00\"), (\"16:30\", \"17:00\")],  # Jonathan\n    [(\"10:00\", \"10:30\"), (\"13:30\", \"14:00\")],  # Barbara\n    [(\"10:00\", \"11:00\"), (\"12:30\", \"14:30\")],  # Jesse\n    [(\"9:30\", \"11:00\"), (\"11:30\", \"12:30\"), (\"13:00\", \"15:30\"), (\"16:00\", \"17:00\")],  # Alan\n    [(\"9:00\", \"10:30\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:30\"), (\"14:00\", \"17:00\")],  # Nicole\n    [(\"9:00\", \"10:30\"), (\"12:00\", \"13:30\"), (\"15:00\", \"15:30\"), (\"16:00\", \"16:30\")],  # Catherine\n]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_473"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert work hours to minutes since midnight for easier calculation\n    work_start = work_hours_start * 60\n    work_end = work_hours_end * 60\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    # Collect all busy intervals from each participant's schedule\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start_h, start_m = busy[0], busy[1]\n            end_h, end_m = busy[2], busy[3]\n            start = start_h * 60 + start_m\n            end = end_h * 60 + end_m\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append(interval)\n    \n    # Find available slots by checking gaps between merged busy intervals\n    available_slots = []\n    previous_end = work_start\n    for interval in merged:\n        current_start, current_end = interval\n        if current_start > previous_end:\n            available_slots.append((previous_end, current_start))\n        previous_end = max(previous_end, current_end)\n    # Check the slot after the last busy interval\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Find the first available slot that can accommodate the meeting duration\n    for slot in available_slots:\n        start, end = slot\n        if end - start >= duration_minutes:\n            # Convert start time back to HH:MM format\n            meeting_start = start // 60\n            meeting_start_min = start % 60\n            meeting_end = (start + duration_minutes) // 60\n            meeting_end_min = (start + duration_minutes) % 60\n            return f\"{meeting_start:02d}:{meeting_start_min:02d}:{meeting_end:02d}:{meeting_end_min:02d}\"\n    return None\n\n# Define work hours and meeting duration\nwork_hours_start = 9  # 9:00\nwork_hours_end = 17    # 17:00\nduration_minutes = 30   # 30 minutes\n\n# Define each participant's busy times in HH:MM format (converted to tuples)\nparticipants_schedules = [\n    [],  # Russell is free\n    [(12, 0, 12, 30), (16, 0, 16, 30)],  # Christina\n    [(9, 0, 9, 30), (12, 30, 13, 0)],     # Ethan\n    [],                                   # Brian is free\n    [(9, 0, 12, 0), (12, 30, 14, 0), (15, 0, 15, 30)],  # Peter\n    [(9, 0, 10, 0), (10, 30, 14, 30), (16, 0, 17, 0)],  # Isabella\n    [(9, 30, 11, 30), (12, 0, 12, 30), (13, 30, 14, 0), (15, 0, 17, 0)],  # Dylan\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_474"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy times to minutes since midnight\n    busy_slots = {\n        'Brittany': [(10 * 60, 10 * 60 + 30), (12 * 60, 12 * 60 + 30), (14 * 60 + 30, 15 * 60 + 30)],\n        'Debra': [(9 * 60 + 30, 10 * 60), (11 * 60 + 30, 12 * 60)],\n        'Amber': [(11 * 60, 11 * 60 + 30), (13 * 60, 13 * 60 + 30)],\n        'Theresa': [(14 * 60, 14 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n        'Gloria': [(10 * 60, 13 * 60), (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 16 * 60)],\n        'Amanda': [(9 * 60, 10 * 60 + 30), (11 * 60, 14 * 60), (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Stephanie': [(9 * 60, 9 * 60 + 30), (10 * 60, 11 * 60 + 30), (12 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30), (15 * 60, 16 * 60)],\n    }\n\n    # Combine all busy slots into one list\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n\n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check the time after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can fit the meeting\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_475"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy times in minutes since midnight\n    busy_times = {\n        'Kathleen': [(14 * 60 + 30, 15 * 60 + 30)],\n        'Carolyn': [(12 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30)],\n        'Cheryl': [(9 * 60, 9 * 60 + 30), (10 * 60, 11 * 60 + 30), (12 * 60 + 30, 13 * 60 + 30), (14 * 60, 17 * 60)],\n        'Virginia': [(9 * 60 + 30, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Angela': [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60, 16 * 60 + 30)],\n    }\n    \n    # Roger's preference: not before 12:30\n    roger_preference_start = 12 * 60 + 30\n    \n    # Combine all busy times and sort them\n    all_busy = []\n    for person in busy_times:\n        for start, end in busy_times[person]:\n            all_busy.append((start, end))\n    \n    # Add Roger's preference as a busy time before 12:30\n    all_busy.append((work_start, roger_preference_start))\n    \n    # Sort all busy intervals\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Find the first available 30-minute slot\n    meeting_duration = 30\n    previous_end = work_start\n    \n    for start, end in merged_busy:\n        if start - previous_end >= meeting_duration:\n            # Found a slot\n            meeting_start = previous_end\n            meeting_end = meeting_start + meeting_duration\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n        previous_end = max(previous_end, end)\n    \n    # Check after the last busy interval\n    if work_end - previous_end >= meeting_duration:\n        meeting_start = previous_end\n        meeting_end = meeting_start + meeting_duration\n        return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No available time slot found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_476"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start, end = work_hours\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        h = minutes // 60\n        m = minutes % 60\n        return f\"{h:02d}:{m:02d}\"\n    \n    start_min = time_to_minutes(start)\n    end_min = time_to_minutes(end)\n    \n    # Initialize a list to mark busy intervals\n    timeline = []\n    for person, schedules in participants_schedules.items():\n        for interval in schedules:\n            s, e = map(time_to_minutes, interval.split(' to '))\n            timeline.append((s, e))\n    \n    # Sort all busy intervals\n    timeline.sort()\n    \n    # Find the earliest available slot\n    current_time = start_min\n    for s, e in timeline:\n        if s > current_time:\n            if s - current_time >= duration:\n                return f\"{minutes_to_time(current_time)}:{minutes_to_time(current_time + duration)}\"\n            current_time = e\n        else:\n            if e > current_time:\n                current_time = e\n    # Check after the last busy interval\n    if end_min - current_time >= duration:\n        return f\"{minutes_to_time(current_time)}:{minutes_to_time(current_time + duration)}\"\n    return \"No available slot\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    'Julia': [],\n    'Bryan': ['10:00 to 10:30', '11:00 to 12:00', '13:30 to 14:00', '14:30 to 15:00', '15:30 to 16:00'],\n    'Betty': [],\n    'Arthur': ['9:30 to 10:00', '12:00 to 12:30'],\n    'Megan': ['9:30 to 12:00', '12:30 to 13:00', '14:00 to 15:00', '15:30 to 16:30'],\n    'Kevin': ['9:00 to 9:30', '10:00 to 11:30', '13:00 to 13:30', '14:00 to 15:30'],\n    'Alice': ['9:00 to 15:30', '16:00 to 16:30']\n}\n\n# Work hours and meeting duration\nwork_hours = ('9:00', '17:00')\nduration = 30  # minutes\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_477"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_start=9 * 60, work_end=17 * 60):\n    # Convert work hours to minutes since midnight\n    work_start_min = work_start\n    work_end_min = work_end\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for schedule in participants_schedules:\n        all_busy_intervals.extend(schedule)\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_intervals = []\n    for interval in all_busy_intervals:\n        if not merged_intervals:\n            merged_intervals.append(interval)\n        else:\n            last_start, last_end = merged_intervals[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged_intervals[-1] = (new_start, new_end)\n            else:\n                merged_intervals.append(interval)\n    \n    # Find free intervals by looking at gaps between busy intervals\n    free_intervals = []\n    previous_end = work_start_min\n    \n    for interval in merged_intervals:\n        current_start, current_end = interval\n        if current_start > previous_end:\n            free_intervals.append((previous_end, current_start))\n        previous_end = max(previous_end, current_end)\n    \n    # Check the time after the last busy interval until work_end\n    if previous_end < work_end_min:\n        free_intervals.append((previous_end, work_end_min))\n    \n    # Find the first free interval that can accommodate the meeting duration\n    for interval in free_intervals:\n        start, end = interval\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules in minutes since midnight\nparticipants_schedules = [\n    # Kimberly is free the entire day\n    [],\n    # Deborah: 12:00-13:00, 14:30-15:30\n    [(12 * 60, 13 * 60), (14 * 60 + 30, 15 * 60 + 30)],\n    # Samuel: 9:00-9:30, 10:00-10:30, 11:30-12:30, 15:30-16:30\n    [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60 + 30), (15 * 60 + 30, 16 * 60 + 30)],\n    # Lisa: 9:30-10:00, 11:30-12:00, 12:30-13:30, 15:30-16:30\n    [(9 * 60 + 30, 10 * 60), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60 + 30), (15 * 60 + 30, 16 * 60 + 30)],\n    # Vincent: 9:30-10:30, 11:00-12:00, 12:30-13:00, 14:00-15:30, 16:00-17:00\n    [(9 * 60 + 30, 10 * 60 + 30), (11 * 60, 12 * 60), (12 * 60 + 30, 13 * 60), (14 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n    # Julia: 9:00-9:30, 11:00-14:00, 15:00-15:30\n    [(9 * 60, 9 * 60 + 30), (11 * 60, 14 * 60), (15 * 60, 15 * 60 + 30)],\n    # Judith: 9:00-9:30, 10:00-10:30, 11:00-12:00, 12:30-14:00, 14:30-17:00\n    [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (11 * 60, 12 * 60), (12 * 60 + 30, 14 * 60), (14 * 60 + 30, 17 * 60)],\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_478"
        },
        {
            "final_program_time": "{9:30:10:30}",
            "expected_time": "{9:30:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = work_hours\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Collect all busy times for all participants\n    all_busy_times = []\n    for busy_times in participants_busy_times.values():\n        for busy_start, busy_end in busy_times:\n            all_busy_times.append((time_to_minutes(busy_start), time_to_minutes(busy_end)))\n    \n    # Sort all busy times by start time\n    all_busy_times.sort()\n    \n    # Merge overlapping or adjacent busy times\n    merged_busy = []\n    for start, end in all_busy_times:\n        if not merged_busy:\n            merged_busy.append([start, end])\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                merged_busy[-1][1] = max(end, last_end)\n            else:\n                merged_busy.append([start, end])\n    \n    # Find available slots by checking gaps between busy times and work hours\n    available_slots = []\n    prev_end = work_start_min\n    for start, end in merged_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        available_slots.append((prev_end, work_end_min))\n    \n    # Check each available slot for duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration_hours = 1\n\n# Define each participant's busy times\nparticipants_busy_times = {\n    \"Evelyn\": [],\n    \"Joshua\": [(\"11:00\", \"12:30\"), (\"13:30\", \"14:30\"), (\"16:30\", \"17:00\")],\n    \"Kevin\": [],\n    \"Gerald\": [],\n    \"Jerry\": [(\"9:00\", \"9:30\"), (\"10:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"13:30\", \"14:00\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:00\")],\n    \"Jesse\": [(\"9:00\", \"9:30\"), (\"10:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:30\")],\n    \"Kenneth\": [(\"10:30\", \"12:30\"), (\"13:30\", \"14:00\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:00\"), (\"16:30\", \"17:00\")],\n}\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy_times, work_hours, duration_hours))\n```",
            "count": "calendar_scheduling_example_479"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals during work hours\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability across all participants\n    possible_slots = []\n    for interval in free_intervals:\n        start, end = interval\n        duration = end - start\n        if duration >= meeting_duration:\n            possible_slots.append((start, start + meeting_duration))\n    \n    # The first suitable slot is chosen\n    if possible_slots:\n        start, end = possible_slots[0]\n        return f\"{minutes_to_time(start)}:{minutes_to_time(end)}\"\n    else:\n        return \"No suitable time found\"\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 30  # minutes\n\n# Define each participant's busy times\nparticipants_schedules = [\n    [\"11:00 to 12:00\", \"14:00 to 14:30\", \"16:30 to 17:00\"],  # Betty\n    [],  # Roy\n    [\"9:30 to 10:00\", \"11:00 to 12:00\", \"14:00 to 14:30\", \"15:30 to 16:30\"],  # Douglas\n    [\"12:00 to 12:30\", \"13:00 to 14:00\", \"16:00 to 16:30\"],  # Kimberly\n    [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:00 to 12:30\", \"13:00 to 13:30\", \"14:00 to 14:30\", \"15:30 to 17:00\"],  # Ashley\n    [\"9:00 to 11:00\", \"11:30 to 12:30\", \"13:30 to 14:30\", \"16:00 to 17:00\"],  # Isabella\n    [\"9:00 to 9:30\", \"10:00 to 10:30\", \"12:30 to 14:30\", \"15:00 to 17:00\"],  # Carl\n]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_480"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since 9:00 (work_hours_start)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - work_hours_start) * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = work_hours_start + (minutes // 60)\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        person_busy = []\n        for busy_block in schedule:\n            start, end = busy_block.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            person_busy.append((start_min, end_min))\n        busy_intervals.append(person_busy)\n    \n    # Find the earliest and latest possible times in minutes\n    earliest = 0\n    latest = (work_hours_end - work_hours_start) * 60\n    \n    # Generate all possible busy intervals combined\n    all_busy = []\n    for person in busy_intervals:\n        for interval in person:\n            all_busy.append(interval)\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots\n    available = []\n    prev_end = earliest\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < latest:\n        available.append((prev_end, latest))\n    \n    # Check each available slot for duration\n    for slot in available:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            return (minutes_to_time(meeting_start), minutes_to_time(meeting_end))\n    \n    return None\n\n# Define work hours and duration\nwork_hours_start = 9\nwork_hours_end = 17\nduration_minutes = 30\n\n# Define each participant's busy times\nparticipants_schedules = [\n    [\"11:30 to 13:00\", \"13:30 to 14:00\"],  # Andrew\n    [\"12:00 to 12:30\", \"13:30 to 14:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"],  # Keith\n    [\"9:30 to 10:00\", \"12:30 to 13:00\", \"13:30 to 14:00\", \"14:30 to 15:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"],  # Pamela\n    [\"9:00 to 9:30\", \"11:00 to 12:30\", \"14:30 to 15:30\"],  # Carol\n    [\"9:00 to 13:00\", \"14:00 to 14:30\", \"15:00 to 16:00\", \"16:30 to 17:00\"],  # Barbara\n    [\"9:00 to 9:30\", \"10:00 to 10:30\", \"12:30 to 16:00\", \"16:30 to 17:00\"],  # Ronald\n    [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:00 to 11:30\", \"12:00 to 12:30\", \"13:00 to 16:00\"],  # Diana\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nif meeting_time:\n    print(f\"{meeting_time[0]}:{meeting_time[1]}\")\nelse:\n    print(\"No available time slot found.\")\n```",
            "count": "calendar_scheduling_example_481"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy times in minutes (start, end)\n    busy_times = {\n        'Frank': [(12 * 60, 12 * 60 + 30), (14 * 60, 14 * 60 + 30)],\n        'Michael': [],\n        'Jeremy': [(10 * 60 + 30, 11 * 60), (13 * 60, 13 * 60 + 30), \n                   (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60)],\n        'Charles': [(10 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60)],\n        'Scott': [(9 * 60, 13 * 60), (13 * 60 + 30, 16 * 60 + 30)],\n        'Kelly': [(9 * 60, 9 * 60 + 30), (10 * 60, 14 * 60 + 30), \n                  (15 * 60, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Julie': [(9 * 60 + 30, 10 * 60), (11 * 60, 13 * 60 + 30), \n                  (14 * 60, 14 * 60 + 30), (15 * 60, 16 * 60 + 30)]\n    }\n    \n    # Collect all busy intervals\n    all_busy = []\n    for person in busy_times:\n        all_busy.extend(busy_times[person])\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for a 30-minute slot\n    meeting_duration = 30\n    for start, end in free_intervals:\n        if end - start >= meeting_duration:\n            # Convert minutes back to HH:MM format\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_482"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all times to minutes since start of day for easier calculation\n    start_min = work_hours_start * 60\n    end_min = work_hours_end * 60\n    duration = duration_minutes\n\n    # Initialize a list to keep track of busy intervals for all participants\n    all_busy = []\n\n    # Collect all busy intervals\n    for busy_intervals in participants_busy.values():\n        for start, end in busy_intervals:\n            all_busy.append((start * 60, end * 60))\n\n    # Sort all busy intervals by start time\n    all_busy.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n\n    # Find the earliest available slot\n    prev_end = start_min\n    for start, end in merged_busy:\n        if start - prev_end >= duration:\n            # Found a suitable slot\n            meeting_start = prev_end\n            meeting_end = meeting_start + duration\n            return (meeting_start, meeting_end)\n        prev_end = max(prev_end, end)\n\n    # Check the slot after the last busy interval\n    if end_min - prev_end >= duration:\n        meeting_start = prev_end\n        meeting_end = meeting_start + duration\n        return (meeting_start, meeting_end)\n\n    # No slot found (though the problem states there is one)\n    return None\n\n# Define work hours and meeting duration\nwork_hours_start = 9  # 9:00\nwork_hours_end = 17    # 17:00\nduration_minutes = 30  # 30 minutes\n\n# Define each participant's busy times in their local time\nparticipants_busy = {\n    'Nicholas': [(9, 9.5), (11, 11.5), (12.5, 13), (15.5, 16)],\n    'Sara': [(10, 10.5), (11, 11.5)],\n    'Helen': [],\n    'Brian': [],\n    'Nancy': [(9, 10), (11, 14), (15, 17)],\n    'Kelly': [(10, 11.5), (12, 12.5), (13.5, 14), (14.5, 15.5), (16.5, 17)],\n    'Judy': [(9, 11.5), (12, 12.5), (13, 13.5), (14.5, 17)],\n}\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours_start, work_hours_end, duration_minutes)\n\n# Format the output as HH:MM:HH:MM\nif meeting_time:\n    start_min, end_min = meeting_time\n    start_hh = int(start_min // 60)\n    start_mm = int(start_min % 60)\n    end_hh = int(end_min // 60)\n    end_mm = int(end_min % 60)\n    print(f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_483"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"12:00 to 12:30\", \"14:00 to 14:30\", \"15:30 to 16:30\"],  # Jean\n    [],  # Susan\n    [],  # Beverly\n    [\"9:30 to 11:00\", \"12:30 to 13:00\", \"15:00 to 15:30\", \"16:30 to 17:00\"],  # Denise\n    [\"9:00 to 12:00\", \"14:30 to 16:30\"],  # Jeffrey\n    [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:00 to 13:00\", \"13:30 to 14:30\"],  # Mary\n    [\"9:00 to 10:00\", \"10:30 to 13:00\", \"13:30 to 15:00\", \"15:30 to 16:30\"],  # Joseph\n]\n\n# Find a meeting time\nmeeting_time = find_meeting_time(participants_schedules, \"9:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_484"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:13:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    start_hour, end_hour = work_hours\n    # Convert work hours to minutes for easier calculation\n    start_time = start_hour * 60\n    end_time = end_hour * 60\n    duration_min = duration * 60\n    \n    # Initialize a list to keep track of busy times for all participants\n    all_busy_times = []\n    \n    for person, schedules in participants_schedules.items():\n        for busy_start, busy_end in schedules:\n            # Convert each busy time to minutes\n            busy_start_min = busy_start[0] * 60 + busy_start[1]\n            busy_end_min = busy_end[0] * 60 + busy_end[1]\n            all_busy_times.append((busy_start_min, busy_end_min))\n    \n    # Sort all busy times by start time\n    all_busy_times.sort()\n    \n    # Find the earliest available slot\n    previous_end = start_time\n    for busy_start, busy_end in all_busy_times:\n        if busy_start > previous_end:\n            # Check if the gap is enough for the meeting\n            if busy_start - previous_end >= duration_min:\n                # Convert back to HH:MM format\n                start_slot = divmod(previous_end, 60)\n                end_slot = divmod(previous_end + duration_min, 60)\n                return f\"{start_slot[0]:02d}:{start_slot[1]:02d}:{end_slot[0]:02d}:{end_slot[1]:02d}\"\n        previous_end = max(previous_end, busy_end)\n    \n    # Check the time after the last busy slot until end of work hours\n    if end_time - previous_end >= duration_min:\n        start_slot = divmod(previous_end, 60)\n        end_slot = divmod(previous_end + duration_min, 60)\n        return f\"{start_slot[0]:02d}:{start_slot[1]:02d}:{end_slot[0]:02d}:{end_slot[1]:02d}\"\n    \n    return \"No available slot found\"\n\n# Define the participants' schedules in HH:MM format converted to tuples of (hour, minute)\nparticipants_schedules = {\n    \"Roy\": [((11, 0), (11, 30)), ((15, 30), (16, 0))],\n    \"Kayla\": [((10, 30), (11, 0)), ((12, 0), (13, 0)), ((13, 30), (14, 0)), ((14, 30), (15, 0)), ((15, 30), (16, 0))],\n    \"Alexis\": [],\n    \"Eugene\": [((11, 30), (12, 0)), ((12, 30), (13, 0))],\n    \"Matthew\": [((9, 0), (10, 0)), ((11, 0), (12, 30)), ((14, 0), (14, 30)), ((15, 0), (16, 0))],\n    \"Alice\": [((9, 0), (10, 30)), ((11, 0), (13, 0)), ((13, 30), (14, 30)), ((15, 0), (16, 30))],\n    \"Frank\": [((9, 0), (10, 0)), ((11, 30), (12, 0)), ((13, 30), (15, 0)), ((15, 30), (16, 0)), ((16, 30), (17, 0))],\n}\n\n# Meeting duration in hours\nduration = 0.5\n# Work hours in 24-hour format\nwork_hours = (9, 17)\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_485"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:30:15:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_start, work_end, duration):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Collect all busy intervals\n    all_busy_intervals = []\n    for busy_times in participants_busy_times.values():\n        for interval in busy_times:\n            start, end = interval.split(' to ')\n            all_busy_intervals.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort intervals by start time\n    all_busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged_intervals = []\n    for start, end in all_busy_intervals:\n        if not merged_intervals:\n            merged_intervals.append([start, end])\n        else:\n            last_start, last_end = merged_intervals[-1]\n            if start <= last_end:\n                merged_intervals[-1][1] = max(end, last_end)\n            else:\n                merged_intervals.append([start, end])\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start_min\n    for start, end in merged_intervals:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        available_slots.append((prev_end, work_end_min))\n    \n    # Find the first available slot that fits the duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' busy times\nparticipants_busy_times = {\n    \"Logan\": [\"9:30 to 10:00\", \"11:30 to 12:00\"],\n    \"Kimberly\": [\"14:00 to 14:30\", \"16:00 to 16:30\"],\n    \"Angela\": [\"10:00 to 10:30\", \"13:00 to 13:30\", \"14:00 to 14:30\", \"15:30 to 16:00\"],\n    \"Matthew\": [],\n    \"Dylan\": [\"9:30 to 12:00\", \"13:00 to 14:00\", \"15:30 to 16:00\"],\n    \"Marilyn\": [\"9:00 to 11:00\", \"11:30 to 14:30\", \"15:00 to 17:00\"],\n    \"Grace\": [\"9:00 to 9:30\", \"10:00 to 11:00\", \"11:30 to 12:30\", \"13:00 to 14:00\", \"15:30 to 17:00\"]\n}\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_busy_times, \"9:00\", \"17:00\", 0.5)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_486"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    busy_slots = {\n        'Albert': [],\n        'Rebecca': [(13 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30)],\n        'Ronald': [(10 * 60 + 30, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (15 * 60, 15 * 60 + 30)],\n        'Pamela': [(13 * 60 + 30, 14 * 60), (16 * 60, 16 * 60 + 30)],\n        'Noah': [(9 * 60 + 30, 11 * 60), (11 * 60 + 30, 12 * 60 + 30), (13 * 60, 13 * 60 + 30),\n                 (14 * 60, 14 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Diana': [(9 * 60, 13 * 60), (13 * 60 + 30, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Jacqueline': [(9 * 60 + 30, 12 * 60), (13 * 60, 15 * 60), (16 * 60, 16 * 60 + 30)],\n    }\n\n    # Collect all busy slots\n    all_busy = []\n    for person_slots in busy_slots.values():\n        all_busy.extend(person_slots)\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the time after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_487"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_start=\"09:00\", work_end=\"17:00\"):\n    # Convert time string to minutes since midnight\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start_min, work_end_min)]\n    \n    # Process each participant's schedule to find common free slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_slots.append((start, end))\n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Merge overlapping or adjacent busy slots\n        merged_busy = []\n        for start, end in busy_slots:\n            if not merged_busy:\n                merged_busy.append((start, end))\n            else:\n                last_start, last_end = merged_busy[-1]\n                if start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = last_start\n                    new_end = max(last_end, end)\n                    merged_busy[-1] = (new_start, new_end)\n                else:\n                    merged_busy.append((start, end))\n        \n        # Subtract busy slots from current free slots\n        new_free_slots = []\n        for free_start, free_end in free_slots:\n            current_start = free_start\n            for busy_start, busy_end in merged_busy:\n                if busy_start > current_start:\n                    # Add the free slot before the busy slot\n                    new_free_slots.append((current_start, busy_start))\n                current_start = max(current_start, busy_end)\n            if current_start < free_end:\n                new_free_slots.append((current_start, free_end))\n        free_slots = new_free_slots\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [],  # Samuel is free the entire day\n    [\"09:00:10:00\", \"13:30:14:00\", \"16:30:17:00\"],  # Maria\n    [\"09:00:09:30\", \"16:00:16:30\"],  # Bryan\n    [\"10:00:10:30\", \"11:00:12:00\", \"14:00:14:30\", \"15:00:15:30\", \"16:30:17:00\"],  # Kyle\n    [\"09:00:10:30\", \"11:00:11:30\", \"12:00:15:00\", \"15:30:16:00\", \"16:30:17:00\"],  # Christina\n    [\"09:00:09:30\", \"10:00:10:30\", \"11:00:11:30\", \"12:00:15:00\", \"15:30:17:00\"],  # Virginia\n    [\"09:00:10:30\", \"11:30:17:00\"],  # Ann\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_488"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert each participant's busy slots to minutes\n    busy_slots = {\n        'Cynthia': [(11*60 + 30, 12*60), (12*60 + 30, 13*60), (14*60, 14*60 + 30), (15*60, 15*60 + 30)],\n        'Carol': [(9*60, 10*60)],\n        'Billy': [(9*60, 9*60 + 30), (10*60, 10*60 + 30)],\n        'Albert': [(9*60 + 30, 10*60), (11*60 + 30, 13*60), (14*60, 15*60 + 30), (16*60 + 30, 17*60)],\n        'Doris': [(9*60, 11*60 + 30), (12*60, 13*60), (13*60 + 30, 14*60), (14*60 + 30, 15*60), (16*60, 16*60 + 30)],\n        'Keith': [(10*60, 10*60 + 30), (11*60, 12*60), (12*60 + 30, 14*60), (15*60, 15*60 + 30), (16*60, 16*60 + 30)],\n    }\n\n    # Jean is free all day, so no busy slots\n\n    # Collect all busy slots from all participants except Jean\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n\n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the time after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_489"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:00:15:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert time strings to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    \n    # Collect all busy intervals\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find the earliest available slot\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available_start = prev_end\n            available_end = start\n            if available_end - available_start >= duration:\n                return f\"{minutes_to_time(available_start)}:{minutes_to_time(available_start + duration)}\"\n        prev_end = max(prev_end, end)\n    \n    # Check after the last busy interval\n    if work_end - prev_end >= duration:\n        return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + duration)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"09:00:09:30\", \"12:00:12:30\", \"13:30:14:00\", \"14:30:15:00\"],  # Nancy\n    [],  # Julie\n    [\"11:30:12:00\", \"13:00:13:30\"],  # Randy\n    [\"12:00:12:30\", \"16:30:17:00\"],  # Anthony\n    [\"09:00:09:30\", \"10:00:11:00\", \"12:00:13:00\", \"13:30:14:00\", \"15:30:16:30\"],  # Alan\n    [\"09:00:09:30\", \"10:00:11:00\", \"11:30:14:30\", \"15:30:17:00\"],  # Denise\n    [\"09:00:10:00\", \"11:00:12:30\", \"13:30:14:30\", \"16:30:17:00\"],  # Jacob\n]\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_490"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_start=9*60, work_end=17*60):\n    # Convert all schedules to minutes since midnight for easier comparison\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start_h, start_m = map(int, interval.split(':')[:2])\n            end_h, end_m = map(int, interval.split(':')[2:4])\n            start = start_h * 60 + start_m\n            end = end_h * 60 + end_m\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                new_end = max(last_end, current_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append(interval)\n    \n    # Find available slots between work hours and busy intervals\n    available_slots = []\n    prev_end = work_start\n    for interval in merged:\n        start, end = interval\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            start_h = meeting_start // 60\n            start_m = meeting_start % 60\n            end_h = meeting_end // 60\n            end_m = meeting_end % 60\n            return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    return \"No available time slot found\"\n\n# Define participants' schedules in HH:MM:HH:MM format\nparticipants_schedules = [\n    [\"12:00:13:00\", \"14:00:14:30\", \"15:00:15:30\"],  # Patricia\n    [\"11:30:12:00\", \"14:00:15:00\", \"16:00:16:30\"],  # Nathan\n    [\"12:30:13:00\", \"14:30:15:00\", \"16:00:17:00\"],  # James\n    [\"09:00:09:30\", \"10:00:10:30\", \"12:30:13:00\", \"14:00:14:30\", \"16:00:17:00\"],  # Pamela\n    [\"09:00:13:00\", \"13:30:16:00\", \"16:30:17:00\"],  # Raymond\n    [\"09:00:09:30\", \"10:00:12:30\", \"14:30:15:00\", \"15:30:16:00\"],  # Cheryl\n    [\"09:00:11:00\", \"11:30:12:00\", \"12:30:13:00\", \"14:30:15:00\", \"15:30:17:00\"],  # Michelle\n]\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules))\n```",
            "count": "calendar_scheduling_example_491"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:11:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    start_work, end_work = work_hours\n    start_work_min = time_to_minutes(start_work)\n    end_work_min = time_to_minutes(end_work)\n    duration_min = duration * 60\n\n    # Collect all busy intervals for all participants\n    all_busy_intervals = []\n    for busy_times in participants_busy_times.values():\n        for interval in busy_times:\n            start, end = interval\n            all_busy_intervals.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged_intervals = []\n    for start, end in all_busy_intervals:\n        if not merged_intervals:\n            merged_intervals.append([start, end])\n        else:\n            last_start, last_end = merged_intervals[-1]\n            if start <= last_end:\n                merged_intervals[-1][1] = max(end, last_end)\n            else:\n                merged_intervals.append([start, end])\n\n    # Find available slots by checking gaps between merged intervals and work hours\n    available_slots = []\n    prev_end = start_work_min\n    for start, end in merged_intervals:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < end_work_min:\n        available_slots.append((prev_end, end_work_min))\n\n    # Find the first available slot that can fit the meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No available time slot found\"\n\n# Define the participants' busy times\nparticipants_busy_times = {\n    \"David\": [],\n    \"Julie\": [(\"11:30\", \"12:00\"), (\"14:30\", \"15:00\")],\n    \"Natalie\": [(\"13:30\", \"14:30\")],\n    \"Michelle\": [],\n    \"Brittany\": [(\"9:00\", \"10:30\"), (\"11:30\", \"12:30\"), (\"13:00\", \"13:30\"), (\"14:00\", \"17:00\")],\n    \"Richard\": [(\"9:00\", \"11:00\"), (\"11:30\", \"13:00\"), (\"13:30\", \"17:00\")],\n    \"Christine\": [(\"9:00\", \"10:30\"), (\"12:00\", \"14:30\"), (\"15:00\", \"15:30\"), (\"16:30\", \"17:00\")],\n}\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nmeeting_duration = 0.5  # in hours\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_492"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours=('09:00', '17:00')):\n    # Convert work hours to minutes since midnight\n    start_work, end_work = work_hours\n    work_start = int(start_work.split(':')[0]) * 60 + int(start_work.split(':')[1])\n    work_end = int(end_work.split(':')[0]) * 60 + int(end_work.split(':')[1])\n    \n    # Initialize the free slots for the day\n    free_slots = []\n    current_start = work_start\n    \n    # Generate all possible busy slots from all participants\n    busy_slots = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = busy\n            start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n            end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n            busy_slots.append((start_min, end_min))\n    \n    # Sort busy slots by start time\n    busy_slots.sort()\n    \n    # Merge overlapping or adjacent busy slots\n    merged_busy = []\n    for start, end in busy_slots:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Generate free slots by finding gaps between busy slots and work hours\n    free_slots = []\n    prev_end = work_start\n    for start, end in merged_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Find the first free slot that can accommodate the meeting duration\n    for start, end in free_slots:\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Tyler\n    [],  # Kelly\n    [(\"11:00\", \"11:30\"), (\"14:30\", \"15:00\")],  # Stephanie\n    [],  # Hannah\n    [(\"09:00\", \"09:30\"), (\"10:00\", \"12:00\"), (\"12:30\", \"13:00\"), (\"14:00\", \"17:00\")],  # Joe\n    [(\"09:00\", \"10:30\"), (\"11:30\", \"12:00\"), (\"13:00\", \"14:00\"), (\"14:30\", \"15:30\"), (\"16:00\", \"17:00\")],  # Diana\n    [(\"09:00\", \"10:00\"), (\"10:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"13:30\", \"14:00\"), (\"14:30\", \"15:30\"), (\"16:00\", \"16:30\")],  # Deborah\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_493"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert work hours to minutes for easier calculation\n    start_time = work_hours_start * 60\n    end_time = work_hours_end * 60\n    \n    # Initialize a list to keep track of busy intervals in minutes\n    busy_intervals = []\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            busy_start_min = busy_start[0] * 60 + busy_start[1]\n            busy_end_min = busy_end[0] * 60 + busy_end[1]\n            busy_intervals.append((busy_start_min, busy_end_min))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append(interval)\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    previous_end = start_time\n    \n    for interval in merged:\n        current_start, current_end = interval\n        if current_start > previous_end:\n            available_slots.append((previous_end, current_start))\n        previous_end = max(previous_end, current_end)\n    \n    # Check the time after the last busy interval until end of work hours\n    if previous_end < end_time:\n        available_slots.append((previous_end, end_time))\n    \n    # Find the first available slot that can fit the meeting duration\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules in HH:MM converted to tuples of (HH, MM)\nparticipants_schedules = [\n    [((10, 30), (11, 00)), ((11, 30), (12, 00))],  # Denise\n    [((14, 00), (14, 30)), ((16, 30), (17, 00))],  # Roy\n    [],                                             # Roger\n    [((10, 00), (11, 00)), ((14, 00), (14, 30)), ((16, 00), (16, 30))],  # Debra\n    [((9, 00), (9, 30)), ((10, 00), (11, 30)), ((12, 00), (12, 30)), \n     ((13, 00), (13, 30)), ((14, 30), (15, 00)), ((16, 30), (17, 00))],  # David\n    [((9, 00), (9, 30)), ((10, 00), (10, 30)), ((11, 00), (11, 30)), \n     ((12, 30), (13, 30)), ((14, 00), (15, 00)), ((15, 30), (17, 00))],  # Danielle\n    [((9, 00), (11, 00)), ((11, 30), (14, 30)), ((16, 00), (17, 00))],   # Brian\n]\n\n# Work hours and meeting duration\nwork_hours_start = 9\nwork_hours_end = 17\nduration_minutes = 30\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes))\n```",
            "count": "calendar_scheduling_example_494"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:30:10:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    start_work, end_work = work_hours.split(' to ')\n    start_work_min = time_to_minutes(start_work)\n    end_work_min = time_to_minutes(end_work)\n\n    # Initialize a list to mark busy intervals\n    timeline = [False] * (end_work_min - start_work_min)\n\n    # Mark busy intervals for each participant\n    for person, schedules in participants_schedules.items():\n        for schedule in schedules:\n            start, end = schedule.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            # Clamp to work hours\n            start_min = max(start_min, start_work_min)\n            end_min = min(end_min, end_work_min)\n            for i in range(start_min - start_work_min, end_min - start_work_min):\n                if i >= 0 and i < len(timeline):\n                    timeline[i] = True\n\n    # Find a free slot of duration\n    duration_min = duration * 60  # Convert hours to minutes\n    current_start = None\n    consecutive_free = 0\n\n    for i, busy in enumerate(timeline):\n        if not busy:\n            if current_start is None:\n                current_start = i\n            consecutive_free += 1\n            if consecutive_free >= duration_min:\n                start_time = minutes_to_time(current_start + start_work_min)\n                end_time = minutes_to_time(current_start + start_work_min + duration_min)\n                return f\"{start_time}:{end_time}\"\n        else:\n            current_start = None\n            consecutive_free = 0\n\n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"Jordan\": [\"10:00 to 11:00\", \"11:30 to 12:00\", \"13:00 to 13:30\", \"14:30 to 15:00\", \"16:00 to 16:30\"],\n    \"Ralph\": [\"12:30 to 13:00\", \"14:00 to 14:30\"],\n    \"Kathryn\": [],\n    \"Isabella\": [\"12:30 to 13:00\", \"14:00 to 14:30\", \"15:30 to 16:30\"],\n    \"Roger\": [\"9:00 to 9:30\", \"10:00 to 11:00\", \"12:30 to 17:00\"],\n    \"Henry\": [\"9:00 to 9:30\", \"10:00 to 13:00\", \"13:30 to 15:00\", \"15:30 to 16:30\"],\n    \"Anthony\": [\"9:00 to 9:30\", \"10:30 to 13:00\", \"13:30 to 14:00\", \"15:00 to 16:30\"]\n}\n\nwork_hours = \"9:00 to 17:00\"\nduration = 0.5  # half an hour\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_495"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time slots to minutes since start of the day for easier calculation\n    start_min = work_hours_start * 60\n    end_min = work_hours_end * 60\n    duration = duration_minutes\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for block in schedule:\n            start_h, start_m, end_h, end_m = block\n            start = start_h * 60 + start_m\n            end = end_h * 60 + end_m\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by checking gaps between busy intervals\n    free_intervals = []\n    prev_end = start_min\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    # Check the time after the last busy interval\n    if prev_end < end_min:\n        free_intervals.append((prev_end, end_min))\n    \n    # Now find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_h = meeting_start // 60\n            start_m = meeting_start % 60\n            end_h = meeting_end // 60\n            end_m = meeting_end % 60\n            return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules in HH:MM:HH:MM format converted to tuples\nparticipants_schedules = [\n    [(12, 30, 13, 00), (15, 00, 15, 30)],  # Zachary\n    [(9, 00, 10, 00), (12, 00, 12, 30), (13, 30, 14, 00)],  # Amanda\n    [],  # Keith\n    [(9, 30, 10, 30), (12, 30, 13, 00), (16, 00, 16, 30)],  # Ruth\n    [(10, 00, 11, 00), (11, 30, 12, 00), (13, 30, 14, 00), (15, 00, 17, 00)],  # Noah\n    [(9, 00, 14, 30), (15, 30, 17, 00)],  # Sean\n    [(9, 00, 11, 00), (13, 00, 14, 30), (16, 30, 17, 00)],  # Sara\n]\n\n# Work hours and meeting duration\nwork_hours_start = 9\nwork_hours_end = 17\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_496"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert each participant's busy slots to minutes\n    busy_slots = {\n        'Robert': [],\n        'Kyle': [(9*60 + 30, 10*60), (11*60 + 30, 12*60), (14*60, 15*60)],\n        'Russell': [(9*60, 9*60 + 30), (10*60 + 30, 11*60), (12*60, 12*60 + 30), (16*60, 16*60 + 30)],\n        'Juan': [(11*60 + 30, 12*60), (13*60, 14*60), (14*60 + 30, 15*60)],\n        'Beverly': [(9*60, 10*60), (10*60 + 30, 11*60 + 30), (13*60, 14*60 + 30), (15*60, 15*60 + 30)],\n        'Bryan': [(9*60, 9*60 + 30), (10*60 + 30, 11*60 + 30), (12*60, 12*60 + 30), (13*60, 17*60)],\n        'Margaret': [(9*60, 10*60), (10*60 + 30, 12*60), (12*60 + 30, 17*60)]\n    }\n\n    # Collect all busy slots\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n\n    # Merge overlapping or adjacent busy slots\n    all_busy.sort()\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find free slots between work hours, considering merged busy slots\n    free_slots = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n\n    # Check each free slot for the first 30-minute availability\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert start time back to HH:MM format\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_497"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration):\n    # Convert all time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start, work_end = map(time_to_minutes, work_hours.split(' to '))\n    \n    # Initialize the free slots for the day (work hours)\n    free_slots = [work_start, work_end]\n    \n    # Collect all busy times and convert to minutes\n    busy_periods = []\n    for busy_times in participants_busy_times.values():\n        for busy in busy_times:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_periods.append((start, end))\n    \n    # Sort busy periods by start time\n    busy_periods.sort()\n    \n    # Merge overlapping or adjacent busy periods\n    merged_busy = []\n    for start, end in busy_periods:\n        if not merged_busy:\n            merged_busy.append([start, end])\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                merged_busy[-1][1] = max(end, last_end)\n            else:\n                merged_busy.append([start, end])\n    \n    # Find free slots between busy periods and work hours\n    free_slots = []\n    prev_end = work_start\n    for start, end in merged_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Check each free slot for availability of duration\n    for start, end in free_slots:\n        if end - start >= duration:\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            \n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' busy times\nparticipants_busy_times = {\n    \"Diana\": [],\n    \"Richard\": [\"11:00 to 11:30\", \"14:30 to 15:00\"],\n    \"Judith\": [\"9:00 to 9:30\", \"15:00 to 15:30\"],\n    \"Ryan\": [\"13:00 to 13:30\", \"16:30 to 17:00\"],\n    \"Alexis\": [\"9:00 to 10:00\", \"10:30 to 11:00\", \"12:00 to 13:00\", \"13:30 to 15:00\", \"16:00 to 17:00\"],\n    \"Donna\": [\"9:00 to 9:30\", \"11:30 to 13:30\", \"14:30 to 15:00\", \"16:00 to 17:00\"],\n    \"Jason\": [\"9:00 to 12:30\", \"13:00 to 14:00\", \"14:30 to 15:00\"],\n}\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nduration_minutes = 30  # meeting duration in minutes\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_498"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define all participants' busy times in minutes (start, end)\n    busy_times = {\n        'Patrick': [(12 * 60 + 30, 13 * 60), (14 * 60 + 30, 15 * 60)],\n        'Joyce': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60), (15 * 60, 15 * 60 + 30)],\n        'Peter': [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 11 * 60 + 30), (12 * 60, 13 * 60 + 30), (16 * 60, 17 * 60)],\n        'Hannah': [(9 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Joseph': [(9 * 60 + 30, 10 * 60), (12 * 60, 13 * 60), (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60 + 30), (16 * 60, 17 * 60)],\n    }\n\n    # Samuel's preference: avoid after 15:00\n    samuel_preference_end = 15 * 60\n\n    # Collect all busy intervals\n    all_busy = []\n    for person in busy_times:\n        all_busy.extend(busy_times[person])\n\n    # Add Samuel's preference as a busy time after 15:00\n    all_busy.append((samuel_preference_end, work_end))\n\n    # Sort all busy intervals by start time\n    all_busy.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find available slots (gaps between busy intervals)\n    available = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n\n    # Check for a 30-minute slot\n    meeting_duration = 30\n    for start, end in available:\n        if end - start >= meeting_duration:\n            # Convert start time to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_time = start + meeting_duration\n            end_hh = end_time // 60\n            end_mm = end_time % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No available slot found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_499"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define busy slots in minutes since midnight\n    rachel_busy = [\n        (12 * 60, 12 * 60 + 30),    # 12:00-12:30\n        (14 * 60, 14 * 60 + 30),    # 14:00-14:30\n        (15 * 60 + 30, 16 * 60),    # 15:30-16:00\n        (16 * 60 + 30, 17 * 60)     # 16:30-17:00\n    ]\n    wayne_busy = [\n        (9 * 60, 9 * 60 + 30),      # 9:00-9:30\n        (10 * 60, 10 * 60 + 30),     # 10:00-10:30\n        (11 * 60, 14 * 60 + 30),     # 11:00-14:30\n        (15 * 60, 15 * 60 + 30),     # 15:00-15:30\n        (16 * 60, 17 * 60)           # 16:00-17:00\n    ]\n\n    # Rachel's preference: not before 13:00\n    preference_start = 13 * 60\n\n    # Meeting duration in minutes\n    duration = 30\n\n    # Generate available slots for Rachel and Wayne\n    def get_available_slots(busy_slots, start, end):\n        slots = []\n        prev_end = start\n        for busy_start, busy_end in sorted(busy_slots):\n            if busy_start > prev_end:\n                slots.append((prev_end, busy_start))\n            prev_end = max(prev_end, busy_end)\n        if prev_end < end:\n            slots.append((prev_end, end))\n        return slots\n\n    rachel_available = get_available_slots(rachel_busy, work_start, work_end)\n    wayne_available = get_available_slots(wayne_busy, work_start, work_end)\n\n    # Find overlapping slots that meet Rachel's preference\n    for r_start, r_end in rachel_available:\n        for w_start, w_end in wayne_available:\n            start = max(r_start, w_start, preference_start)\n            end = min(r_end, w_end)\n            if end - start >= duration:\n                # Convert minutes back to HH:MM format\n                start_hh = start // 60\n                start_mm = start % 60\n                end_hh = (start + duration) // 60\n                end_mm = (start + duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_500"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(carol_busy, mark_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # 9:00 is 540 minutes\n    \n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes  # Convert back to absolute minutes\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    work_start, work_end = work_hours.split(' to ')\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Parse busy slots\n    def parse_busy_slots(busy_slots):\n        slots = []\n        for slot in busy_slots:\n            start, end = slot.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            slots.append((start_min, end_min))\n        return slots\n    \n    carol_slots = parse_busy_slots(carol_busy)\n    mark_slots = parse_busy_slots(mark_busy)\n    \n    # Generate available slots for Carol and Mark\n    def get_available_slots(busy_slots, work_start_min, work_end_min):\n        available = []\n        prev_end = work_start_min\n        for start, end in sorted(busy_slots):\n            if start > prev_end:\n                available.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end_min:\n            available.append((prev_end, work_end_min))\n        return available\n    \n    carol_available = get_available_slots(carol_slots, work_start_min, work_end_min)\n    mark_available = get_available_slots(mark_slots, work_start_min, work_end_min)\n    \n    # Find overlapping available slots\n    for carol_start, carol_end in carol_available:\n        for mark_start, mark_end in mark_available:\n            start = max(carol_start, mark_start)\n            end = min(carol_end, mark_end)\n            if end - start >= duration:\n                meeting_end = start + duration\n                return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Input data\ncarol_busy = [\"10:00 to 11:00\", \"14:30 to 15:00\", \"15:30 to 17:00\"]\nmark_busy = [\"9:30 to 10:00\", \"10:30 to 17:00\"]\nwork_hours = \"9:00 to 17:00\"\nduration = 30  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(carol_busy, mark_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_501"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define busy slots in minutes\n    jack_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    charlotte_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 13 * 60 + 30),\n        (14 * 60, 16 * 60)\n    ]\n\n    # Combine and sort all busy slots for both participants\n    all_busy = jack_busy + charlotte_busy\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Filter free slots that are at least 30 minutes and meet Jack's preference (before 12:30)\n    meeting_duration = 30\n    valid_slots = []\n    for start, end in free_slots:\n        if end - start >= meeting_duration and start < 12 * 60 + 30:\n            valid_slots.append((start, end))\n\n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Format the output as HH:MM:HH:MM\n        return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    else:\n        return \"No valid slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_502"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for a slot that fits the duration\n    for start, end in free_intervals:\n        if end - start >= duration * 60:\n            meeting_start = start\n            meeting_end = meeting_start + duration * 60\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define the participants' schedules\nann_schedule = [\n    \"9:30 to 10:00\",\n    \"13:00 to 14:00\",\n    \"15:00 to 16:00\",\n    \"16:30 to 17:00\"\n]\n\nkathleen_schedule = [\n    \"10:00 to 10:30\",\n    \"11:00 to 11:30\",\n    \"13:00 to 14:30\",\n    \"15:00 to 16:00\",\n    \"16:30 to 17:00\"\n]\n\nparticipants_schedules = [ann_schedule, kathleen_schedule]\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration = 1  # in hours\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration))\n```",
            "count": "calendar_scheduling_example_503"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define busy intervals in minutes since midnight\n    alexis_busy = [\n        (11 * 60, 11 * 60 + 30),   # 11:00-11:30\n        (12 * 60, 12 * 60 + 30),   # 12:00-12:30\n        (14 * 60 + 30, 15 * 60),   # 14:30-15:00\n        (16 * 60 + 30, 17 * 60)    # 16:30-17:00\n    ]\n    \n    logan_busy = [\n        (9 * 60, 9 * 60 + 30),     # 9:00-9:30\n        (11 * 60 + 30, 12 * 60 + 30),  # 11:30-12:30\n        (13 * 60, 14 * 60 + 30),   # 13:00-14:30\n        (15 * 60, 17 * 60)          # 15:00-17:00\n    ]\n    \n    # Alexis prefers no meetings before 11:30\n    preferred_start = 11 * 60 + 30  # 11:30 in minutes\n    \n    # Meeting duration in minutes\n    duration = 30\n    \n    # Combine all busy times and sort\n    all_busy = alexis_busy + logan_busy\n    all_busy.sort()\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Filter slots that are after preferred start and have enough duration\n    valid_slots = []\n    for slot_start, slot_end in available_slots:\n        if slot_start >= preferred_start and (slot_end - slot_start) >= duration:\n            valid_slots.append((slot_start, slot_end))\n    \n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_504"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Vincent's busy times in minutes (9:00-10:30, 12:00-15:00, 15:30-17:00)\n    vincent_busy = [(9 * 60, 10 * 60 + 30), (12 * 60, 15 * 60), (15 * 60 + 30, 17 * 60)]\n    \n    # Vincent prefers no meetings after 12:30 (12:30 in minutes)\n    preference_cutoff = 12 * 60 + 30\n    \n    # Meeting duration in minutes\n    meeting_duration = 30\n    \n    # Find all free slots for Vincent before preference cutoff\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in vincent_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the remaining time after last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Filter slots that are before preference cutoff and can fit the meeting\n    possible_slots = []\n    for start, end in free_slots:\n        if start >= preference_cutoff:\n            continue\n        if end - start >= meeting_duration:\n            possible_slots.append((start, end))\n    \n    # Select the earliest possible slot\n    if possible_slots:\n        meeting_start = possible_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Format the output as HH:MM:HH:MM\n        return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    else:\n        return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_505"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(evelyn_schedule, jason_schedule, work_hours, duration):\n    # Parse work hours\n    work_start, work_end = work_hours.split(\" to \")\n    work_start = int(work_start.split(':')[0])\n    work_end = int(work_end.split(':')[0])\n    \n    # Initialize available time slots\n    available_slots = []\n    \n    # Generate all possible slots within work hours\n    for hour in range(work_start, work_end):\n        for minute in [0, 30]:\n            start_time = f\"{hour:02d}:{minute:02d}\"\n            end_hour = hour + (minute + duration) // 60\n            end_minute = (minute + duration) % 60\n            end_time = f\"{end_hour:02d}:{end_minute:02d}\"\n            \n            # Check if the slot is within work hours\n            if end_hour < work_end or (end_hour == work_end and end_minute == 0):\n                available_slots.append((start_time, end_time))\n    \n    # Check each slot against participants' schedules\n    for slot in available_slots:\n        start, end = slot\n        start_h, start_m = map(int, start.split(':'))\n        end_h, end_m = map(int, end.split(':'))\n        \n        # Check Jason's schedule\n        jason_conflict = False\n        for busy_start, busy_end in jason_schedule:\n            busy_start_h, busy_start_m = map(int, busy_start.split(':'))\n            busy_end_h, busy_end_m = map(int, busy_end.split(':'))\n            \n            # Check if slot overlaps with Jason's busy time\n            if not (end_h < busy_start_h or (end_h == busy_start_h and end_m <= busy_start_m) or\n                    start_h > busy_end_h or (start_h == busy_end_h and start_m >= busy_end_m)):\n                jason_conflict = True\n                break\n        \n        # If no conflicts, return the slot\n        if not jason_conflict:\n            return f\"{start}:{end}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules and constraints\nevelyn_schedule = []  # Evelyn has no meetings\njason_schedule = [\n    (\"09:00\", \"09:30\"),\n    (\"10:00\", \"11:30\"),\n    (\"12:30\", \"14:30\"),\n    (\"15:00\", \"17:00\")\n]\nwork_hours = \"9:00 to 17:00\"\nduration = 60  # minutes\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(evelyn_schedule, jason_schedule, work_hours, duration)\nprint(meeting_time.replace(':', ''))\n```",
            "count": "calendar_scheduling_example_506"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert schedules to minutes since midnight\n    patricia_busy = [\n        (11 * 60 + 30, 12 * 60),    # 11:30-12:00\n        (12 * 60 + 30, 13 * 60)     # 12:30-13:00\n    ]\n    \n    harold_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),  # 9:30-10:30\n        (11 * 60 + 30, 12 * 60),       # 11:30-12:00\n        (12 * 60 + 30, 13 * 60),       # 12:30-13:00\n        (13 * 60 + 30, 15 * 60 + 30),  # 13:30-15:30\n        (16 * 60, 17 * 60)             # 16:00-17:00\n    ]\n    \n    # Harold's preference: not after 14:00 (so latest end time is 14:00)\n    preference_end = 14 * 60\n    \n    # Combine and sort all busy intervals\n    all_busy = patricia_busy + harold_busy\n    all_busy.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Check for a 30-minute slot that ends by 14:00 (Harold's preference)\n    meeting_duration = 30\n    for slot_start, slot_end in free_slots:\n        latest_start = min(slot_end - meeting_duration, preference_end - meeting_duration)\n        if latest_start >= slot_start:\n            actual_start = max(slot_start, latest_start)\n            return f\"{actual_start // 60:02d}:{actual_start % 60:02d}:{actual_start // 60:02d}:{(actual_start + meeting_duration) % 60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_507"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(peter_schedule, randy_schedule, work_hours, duration):\n    # Parse work hours\n    work_start, work_end = work_hours.split(\" to \")\n    work_start = int(work_start.split(':')[0]) + int(work_start.split(':')[1]) / 60\n    work_end = int(work_end.split(':')[0]) + int(work_end.split(':')[1]) / 60\n\n    # Parse Randy's busy slots\n    randy_busy = []\n    for slot in randy_schedule.split('; '):\n        if not slot:\n            continue\n        start, end = slot.split(' to ')\n        start_time = int(start.split(':')[0]) + int(start.split(':')[1]) / 60\n        end_time = int(end.split(':')[0]) + int(end.split(':')[1]) / 60\n        randy_busy.append((start_time, end_time))\n\n    # Find available slots for Randy\n    randy_available = []\n    prev_end = work_start\n    for start, end in sorted(randy_busy):\n        if start > prev_end:\n            randy_available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        randy_available.append((prev_end, work_end))\n\n    # Find first available slot that fits the duration\n    for start, end in randy_available:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Format the time as HH:MM\n            start_hour = int(meeting_start)\n            start_minute = int((meeting_start - start_hour) * 60)\n            end_hour = int(meeting_end)\n            end_minute = int((meeting_end - end_hour) * 60)\n            return f\"{start_hour:02d}:{start_minute:02d}:{end_hour:02d}:{end_minute:02d}\"\n    return \"No available time slot found\"\n\n# Given data\npeter_schedule = \"wide open the entire day\"\nrandy_schedule = \"9:00 to 12:30, 13:30 to 17:00\"\nwork_hours = \"9:00 to 17:00\"\nduration = 1.0  # 1 hour\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(peter_schedule, randy_schedule, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_508"
        },
        {
            "final_program_time": "{9:30:10:30}",
            "expected_time": "{9:30:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(wayne_busy, laura_busy, work_start, work_end, duration):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Parse busy intervals for Wayne and Laura\n    def parse_busy_intervals(busy_list):\n        intervals = []\n        for interval in busy_list:\n            start, end = interval.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            intervals.append((start_min, end_min))\n        return intervals\n    \n    wayne_intervals = parse_busy_intervals(wayne_busy)\n    laura_intervals = parse_busy_intervals(laura_busy)\n    \n    # Combine and sort all busy intervals\n    all_busy = wayne_intervals + laura_intervals\n    all_busy.sort()\n    \n    # Find free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    prev_end = work_start_min\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n    \n    # Check each free interval for sufficient duration\n    duration_min = duration * 60\n    for start, end in free_intervals:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define inputs\nwayne_busy = [\"11:00 to 12:00\", \"13:00 to 13:30\", \"15:00 to 15:30\"]\nlaura_busy = [\"9:00 to 9:30\", \"10:30 to 17:00\"]\nwork_start = \"9:00\"\nwork_end = \"17:00\"\nduration = 1  # in hours\n\n# Find and print the meeting time\nprint(find_meeting_time(wayne_busy, laura_busy, work_start, work_end, duration))\n```",
            "count": "calendar_scheduling_example_509"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' schedules and constraints in minutes\n    nicole_busy = [\n        (11 * 60, 11 * 60 + 30),  # 11:00-11:30\n        (12 * 60, 13 * 60),        # 12:00-13:00\n        (15 * 60 + 30, 16 * 60)    # 15:30-16:00\n    ]\n    arthur_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),  # 9:30-10:30\n        (11 * 60, 12 * 60),           # 11:00-12:00\n        (13 * 60 + 30, 15 * 60),      # 13:30-15:00\n        (16 * 60 + 30, 17 * 60)       # 16:30-17:00\n    ]\n    \n    # Nicole's preference: not before 16:00\n    nicole_preference_start = 16 * 60\n    \n    # Meeting duration in minutes\n    meeting_duration = 30\n    \n    # Generate all possible slots within work hours, checking constraints\n    for start in range(work_start, work_end - meeting_duration + 1):\n        end = start + meeting_duration\n        # Check if slot is after Nicole's preference\n        if start < nicole_preference_start:\n            continue\n        # Check if slot is free for Nicole\n        nicole_free = True\n        for busy_start, busy_end in nicole_busy:\n            if not (end <= busy_start or start >= busy_end):\n                nicole_free = False\n                break\n        if not nicole_free:\n            continue\n        # Check if slot is free for Arthur\n        arthur_free = True\n        for busy_start, busy_end in arthur_busy:\n            if not (end <= busy_start or start >= busy_end):\n                arthur_free = False\n                break\n        if not arthur_free:\n            continue\n        # If all checks passed, return the slot\n        return f\"{start // 60:02d}:{start % 60:02d}:{end // 60:02d}:{end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_510"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert blocked times to minutes since midnight\n    barbara_blocked = [\n        (13 * 60 + 30, 14 * 60 + 30),  # 13:30-14:30\n        (15 * 60, 15 * 60 + 30),        # 15:00-15:30\n        (16 * 60, 16 * 60 + 30)         # 16:00-16:30\n    ]\n    \n    scott_blocked = [\n        (9 * 60, 9 * 60 + 30),          # 9:00-9:30\n        (11 * 60 + 30, 12 * 60),        # 11:30-12:00\n        (12 * 60 + 30, 14 * 60 + 30),   # 12:30-14:30\n        (15 * 60, 16 * 60)              # 15:00-16:00\n    ]\n    \n    # Scott cannot meet after 11:30, so adjust work_end for Scott\n    scott_work_end = 11 * 60 + 30\n    \n    # The actual end time is the minimum of work_end and scott_work_end\n    effective_end = min(work_end, scott_work_end)\n    \n    # Merge and sort all blocked times for both participants\n    all_blocked = barbara_blocked + scott_blocked\n    all_blocked.sort()\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in all_blocked:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    # Check after the last blocked time\n    if prev_end < effective_end:\n        available_slots.append((prev_end, effective_end))\n    \n    # Find the first available slot that can fit 30 minutes\n    meeting_duration = 30\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_511"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:00:16:30}",
            "type_error": "IndexError",
            "full_response": "```python\ndef find_meeting_time(paul_busy, nicholas_busy, work_hours, duration, nicholas_constraint):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 9:00 (0 minutes)\n    \n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes  # Add 540 to convert back to HH:MM\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    work_start, work_end = map(time_to_minutes, work_hours.split(' to '))\n    \n    # Parse Paul's busy intervals\n    paul_intervals = []\n    for interval in paul_busy:\n        start, end = map(time_to_minutes, interval.split(' to '))\n        paul_intervals.append((start, end))\n    \n    # Parse Nicholas's busy intervals\n    nicholas_intervals = []\n    for interval in nicholas_busy:\n        start, end = map(time_to_minutes, interval.split(' to '))\n        nicholas_intervals.append((start, end))\n    \n    # Parse Nicholas's constraint\n    constraint_start = time_to_minutes(nicholas_constraint.split(' before ')[1].replace('.', ''))\n    \n    # Combine and sort all busy intervals for both participants\n    all_busy = paul_intervals + nicholas_intervals\n    all_busy.sort()\n    \n    # Find free intervals by merging busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1] = (last_start, max(end, last_end))\n            else:\n                merged.append((start, end))\n    \n    # Check the time before first busy interval\n    if merged and work_start < merged[0][0]:\n        candidate_start = max(work_start, constraint_start)\n        candidate_end = candidate_start + duration\n        if candidate_end <= merged[0][0]:\n            return f\"{minutes_to_time(candidate_start)}:{minutes_to_time(candidate_end)}\"\n    \n    # Check the time between busy intervals\n    for i in range(len(merged) - 1):\n        current_end = merged[i][1]\n        next_start = merged[i+1][0]\n        candidate_start = max(current_end, constraint_start)\n        candidate_end = candidate_start + duration\n        if candidate_end <= next_start:\n            return f\"{minutes_to_time(candidate_start)}:{minutes_to_time(candidate_end)}\"\n    \n    # Check the time after last busy interval\n    if merged and merged[-1][1] < work_end:\n        candidate_start = max(merged[-1][1], constraint_start)\n        candidate_end = candidate_start + duration\n        if candidate_end <= work_end:\n            return f\"{minutes_to_time(candidate_start)}:{minutes_to_time(candidate_end)}\"\n    \n    # If no slot found (though problem states there is one)\n    return \"No suitable time found\"\n\n# Input data\npaul_busy = [\n    \"9:00 to 10:30\",\n    \"11:00 to 11:30\",\n    \"13:30 to 14:00\",\n    \"15:00 to 15:30\"\n]\n\nnicholas_busy = [\n    \"9:30 to 11:00\",\n    \"11:30 to 14:00\",\n    \"14:30 to 15:00\",\n    \"15:30 to 16:00\"\n]\n\nwork_hours = \"9:00 to 17:00\"\nduration = 30  # minutes\nnicholas_constraint = \"before 15:00\"\n\n# Find meeting time\nmeeting_time = find_meeting_time(paul_busy, nicholas_busy, work_hours, duration, nicholas_constraint)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_512"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(pamela_free, mark_busy, mark_constraint_start, duration_minutes=30):\n    # Parse the constraint: Mark cannot meet before 15:30\n    constraint_hour, constraint_minute = map(int, mark_constraint_start.split(':'))\n    constraint_start = constraint_hour * 60 + constraint_minute\n    \n    # Convert Mark's busy times to minutes since 9:00 (work start)\n    mark_busy_minutes = []\n    for slot in mark_busy:\n        start, end = slot.split(' to ')\n        start_h, start_m = map(int, start.split(':'))\n        end_h, end_m = map(int, end.split(':'))\n        start_total = start_h * 60 + start_m - 540  # 9:00 is 540 minutes\n        end_total = end_h * 60 + end_m - 540\n        mark_busy_minutes.append((start_total, end_total))\n    \n    # Generate all possible 30-minute slots in the workday (9:00-17:00 is 480 minutes)\n    possible_slots = []\n    for start in range(0, 480 - duration_minutes + 1, 15):  # check every 15 minutes\n        end = start + duration_minutes\n        # Check if the slot is after Mark's constraint\n        slot_start_time = 540 + start  # in absolute minutes\n        if slot_start_time < constraint_start:\n            continue\n        # Check if the slot overlaps with any of Mark's busy times\n        overlap = False\n        for busy_start, busy_end in mark_busy_minutes:\n            if not (end <= busy_start or start >= busy_end):\n                overlap = True\n                break\n        if not overlap:\n            possible_slots.append((start, end))\n    \n    if not possible_slots:\n        return None\n    \n    # Select the earliest possible slot\n    chosen_slot = possible_slots[0]\n    start_min, end_min = chosen_slot\n    \n    # Convert back to HH:MM format\n    start_h = 9 + (start_min // 60)\n    start_m = start_min % 60\n    end_h = 9 + (end_min // 60)\n    end_m = end_min % 60\n    \n    return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n\n# Define inputs\npamela_free = True  # Pamela has no meetings all day\nmark_busy = [\n    \"9:00 to 9:30\",\n    \"10:00 to 10:30\",\n    \"11:00 to 11:30\",\n    \"12:00 to 12:30\",\n    \"14:00 to 14:30\",\n    \"15:00 to 15:30\",\n    \"16:00 to 17:00\"\n]\nmark_constraint_start = \"15:30\"  # Mark cannot meet before 15:30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(pamela_free, mark_busy, mark_constraint_start)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_513"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert busy slots to minutes\n    martha_busy = [\n        (12 * 60, 12 * 60 + 30),   # 12:00-12:30\n        (14 * 60 + 30, 15 * 60)     # 14:30-15:00\n    ]\n    \n    nathan_busy = [\n        (9 * 60, 10 * 60 + 30),     # 9:00-10:30\n        (11 * 60, 11 * 60 + 30),    # 11:00-11:30\n        (12 * 60, 13 * 60),         # 12:00-13:00\n        (13 * 60 + 30, 14 * 60),    # 13:30-14:00\n        (15 * 60 + 30, 16 * 60)     # 15:30-16:00\n    ]\n    \n    # Nathan's preference: avoid after 11:00 (but we'll still check before 11:00 first)\n    preferred_end = 11 * 60\n    \n    # Check slots before 11:00 first\n    for start in range(work_start, preferred_end - 30, 5):  # Check in 5-minute increments\n        end = start + 30\n        if (not any(s <= start < e or s < end <= e for s, e in martha_busy) and\n            not any(s <= start < e or s < end <= e for s, e in nathan_busy)):\n            # Format the time as HH:MM:HH:MM\n            return f\"{start // 60:02d}:{start % 60:02d}:{end // 60:02d}:{end % 60:02d}\"\n    \n    # If no slot before 11:00, check the rest of the day\n    for start in range(work_start, work_end - 30, 5):\n        end = start + 30\n        if (not any(s <= start < e or s < end <= e for s, e in martha_busy) and\n            not any(s <= start < e or s < end <= e for s, e in nathan_busy)):\n            # Format the time as HH:MM:HH:MM\n            return f\"{start // 60:02d}:{start % 60:02d}:{end // 60:02d}:{end % 60:02d}\"\n    \n    return \"No time found\"  # Should not happen as per the problem statement\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_514"
        },
        {
            "final_program_time": "{16:00:17:00}",
            "expected_time": "{16:00:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert busy slots to minutes\n    randy_busy = [\n        (10 * 60, 10 * 60 + 30),  # 10:00-10:30\n        (15 * 60, 15 * 60 + 30)    # 15:00-15:30\n    ]\n    \n    dylan_busy = [\n        (9 * 60, 10 * 60 + 30),    # 9:00-10:30\n        (11 * 60, 11 * 60 + 30),   # 11:00-11:30\n        (12 * 60 + 30, 13 * 60),   # 12:30-13:00\n        (14 * 60 + 30, 16 * 60)    # 14:30-16:00\n    ]\n    \n    # Dylan prefers no meetings before 16:00, so we start checking from 16:00\n    start_time = 16 * 60\n    meeting_duration = 60\n    \n    # Check if the preferred time (16:00-17:00) works for both\n    if start_time + meeting_duration <= work_end:\n        # Check Randy's availability\n        randy_available = True\n        for busy_start, busy_end in randy_busy:\n            if not (start_time >= busy_end or start_time + meeting_duration <= busy_start):\n                randy_available = False\n                break\n        # Check Dylan's availability\n        dylan_available = True\n        for busy_start, busy_end in dylan_busy:\n            if not (start_time >= busy_end or start_time + meeting_duration <= busy_start):\n                dylan_available = False\n                break\n        if randy_available and dylan_available:\n            return f\"{start_time // 60:02d}:{start_time % 60:02d}:{(start_time + meeting_duration) // 60:02d}:{(start_time + meeting_duration) % 60:02d}\"\n    \n    # If preferred time doesn't work, check other slots (though in this case it should)\n    # This is a fallback (not needed here as the task states a solution exists)\n    for time in range(work_start, work_end - meeting_duration + 1, 15):\n        # Check Randy's availability\n        randy_available = True\n        for busy_start, busy_end in randy_busy:\n            if not (time >= busy_end or time + meeting_duration <= busy_start):\n                randy_available = False\n                break\n        if not randy_available:\n            continue\n        # Check Dylan's availability\n        dylan_available = True\n        for busy_start, busy_end in dylan_busy:\n            if not (time >= busy_end or time + meeting_duration <= busy_start):\n                dylan_available = False\n                break\n        if dylan_available and time >= 16 * 60:  # Respect Dylan's preference\n            return f\"{time // 60:02d}:{time % 60:02d}:{(time + meeting_duration) // 60:02d}:{(time + meeting_duration) % 60:02d}\"\n    \n    return \"No time found\"  # Should not happen as per the task\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_515"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(schedules, work_hours, duration):\n    # Parse work hours\n    work_start, work_end = work_hours.split(\" to \")\n    work_start_min = convert_time_to_minutes(work_start)\n    work_end_min = convert_time_to_minutes(work_end)\n    \n    # Parse and merge all busy intervals\n    busy_intervals = []\n    for person, calendar in schedules.items():\n        for meeting in calendar:\n            start, end = meeting.split(\" to \")\n            start_min = convert_time_to_minutes(start)\n            end_min = convert_time_to_minutes(end)\n            busy_intervals.append((start_min, end_min))\n    \n    # Sort busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals during work hours\n    free_intervals = []\n    prev_end = work_start_min\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n    \n    # Find the first free interval that can accommodate the meeting\n    duration_min = duration * 60\n    for start, end in free_intervals:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return (meeting_start, meeting_end)\n    \n    return None\n\ndef convert_time_to_minutes(time_str):\n    hours, minutes = map(int, time_str.split(':'))\n    return hours * 60 + minutes\n\ndef format_minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Define the schedules and constraints\nschedules = {\n    \"Sophia\": [],\n    \"Jesse\": [\"9:00 to 11:30\", \"12:00 to 14:30\", \"15:30 to 16:00\", \"16:30 to 17:00\"]\n}\nwork_hours = \"9:00 to 17:00\"\nduration = 1  # in hours\n\n# Find the meeting time\nmeeting_time = find_meeting_time(schedules, work_hours, duration)\n\n# Format the output\nif meeting_time:\n    start, end = meeting_time\n    start_time = format_minutes_to_time(start)\n    end_time = format_minutes_to_time(end)\n    print(f\"{start_time}:{end_time}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_516"
        },
        {
            "final_program_time": "{16:00:17:00}",
            "expected_time": "{16:00:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Define Carol's constraints (no meetings but can't meet before 14:30)\n    carol_free = [(14 * 60 + 30, work_end)]  # 14:30 to 17:00\n\n    # Define Frank's meetings in minutes\n    frank_meetings = [\n        (9 * 60, 10 * 60),    # 9:00-10:00\n        (11 * 60 + 30, 12 * 60),  # 11:30-12:00\n        (12 * 60 + 30, 13 * 60),  # 12:30-13:00\n        (13 * 60 + 30, 14 * 60),  # 13:30-14:00\n        (14 * 60 + 30, 16 * 60)   # 14:30-16:00\n    ]\n    # Calculate Frank's free time\n    frank_free = []\n    prev_end = work_start\n    for start, end in sorted(frank_meetings):\n        if start > prev_end:\n            frank_free.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        frank_free.append((prev_end, work_end))\n\n    # Find overlapping free time between Carol and Frank (1 hour)\n    meeting_duration = 60\n    for c_start, c_end in carol_free:\n        for f_start, f_end in frank_free:\n            overlap_start = max(c_start, f_start)\n            overlap_end = min(c_end, f_end)\n            if overlap_end - overlap_start >= meeting_duration:\n                # Return the first available slot\n                return f\"{minutes_to_time(overlap_start)}:{minutes_to_time(overlap_start + meeting_duration)}\"\n    return \"No meeting time found\"\n\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Run the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_517"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(schedule1, schedule2, work_hours, duration):\n    # Combine and sort all busy intervals from both schedules\n    busy_intervals = schedule1 + schedule2\n    busy_intervals.sort()\n    \n    # Initialize the start of the available time to the start of work hours\n    available_start = work_hours[0]\n    \n    # Iterate through each busy interval to find gaps\n    for start, end in busy_intervals:\n        if start > available_start:\n            # Check if the gap is long enough for the meeting\n            if (start - available_start) >= duration:\n                return (available_start, available_start + duration)\n        # Update the available_start to the end of the current busy interval\n        if end > available_start:\n            available_start = end\n    \n    # Check the gap between the last busy interval and the end of work hours\n    if (work_hours[1] - available_start) >= duration:\n        return (available_start, available_start + duration)\n    \n    return None\n\n# Define the work hours and meeting duration\nwork_hours = (9.0, 17.0)\nduration = 0.5  # half an hour\n\n# Define Susan's and Diane's schedules\nsusan_schedule = []  # Susan's calendar is wide open\ndiane_schedule = [\n    (9.0, 10.0),\n    (12.0, 14.0),\n    (15.0, 15.5),\n    (16.5, 17.0)\n]\n\n# Find the earliest available meeting time\nmeeting_time = find_meeting_time(susan_schedule, diane_schedule, work_hours, duration)\n\n# Format the output as HH:MM:HH:MM\ndef float_to_time(time_float):\n    hours = int(time_float)\n    minutes = int((time_float - hours) * 60)\n    return f\"{hours:02d}:{minutes:02d}\"\n\nif meeting_time:\n    start_time = float_to_time(meeting_time[0])\n    end_time = float_to_time(meeting_time[1])\n    print(f\"{start_time}:{end_time}\")\nelse:\n    print(\"No available time found.\")\n```",
            "count": "calendar_scheduling_example_518"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(logan_busy, alice_busy, work_start, work_end, duration):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Generate busy slots in minutes for Logan and Alice\n    def parse_busy_slots(busy_slots):\n        slots = []\n        for slot in busy_slots:\n            start, end = slot.split(' to ')\n            slots.append((time_to_minutes(start), time_to_minutes(end)))\n        return slots\n    \n    logan_slots = parse_busy_slots(logan_busy)\n    alice_slots = parse_busy_slots(alice_busy)\n    \n    # Combine and sort all busy slots\n    all_busy = logan_slots + alice_slots\n    all_busy.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = work_start_min\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        free_slots.append((prev_end, work_end_min))\n    \n    # Find the first suitable free slot\n    for start, end in free_slots:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define constraints\nlogan_busy = [\"9:30 to 10:30\"]\nalice_busy = [\"10:00 to 10:30\", \"11:00 to 11:30\", \"12:00 to 12:30\", \"13:00 to 14:00\", \"15:00 to 16:30\"]\nwork_start = \"9:00\"\nwork_end = \"17:00\"\nduration = 1  # in hours\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(logan_busy, alice_busy, work_start, work_end, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_519"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_work, end_work = work_hours\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work_min = time_to_minutes(start_work)\n    end_work_min = time_to_minutes(end_work)\n    duration_min = duration * 60\n    \n    # Collect all busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = busy\n            all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by merging all busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find the first available slot before the first busy interval\n    prev_end = start_work_min\n    for start, end in merged:\n        if start - prev_end >= duration_min:\n            return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + duration_min)}\"\n        prev_end = max(prev_end, end)\n    \n    # Check after the last busy interval\n    if end_work_min - prev_end >= duration_min:\n        return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + duration_min)}\"\n    \n    return None\n\n# Define the participants' schedules and constraints\npatricia_schedule = [\n    (\"09:00\", \"09:30\"),\n    (\"10:00\", \"10:30\"),\n    (\"13:00\", \"14:00\"),\n    (\"14:30\", \"15:00\"),\n    (\"15:30\", \"16:00\")\n]\n\naustin_schedule = [\n    (\"09:30\", \"10:00\"),\n    (\"10:30\", \"12:00\"),\n    (\"13:00\", \"14:00\"),\n    (\"14:30\", \"15:30\"),\n    (\"16:00\", \"17:00\")\n]\n\nparticipants_schedules = [patricia_schedule, austin_schedule]\nwork_hours = (\"09:00\", \"17:00\")\nduration = 1  # hour\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_520"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n    \n    # Elijah's busy times in minutes since midnight\n    elijah_busy = [\n        (12 * 60, 14 * 60),    # 12:00 to 14:00\n        (14 * 60 + 30, 15 * 60 + 30),  # 14:30 to 15:30\n        (16 * 60, 17 * 60)     # 16:00 to 17:00\n    ]\n    \n    # Elijah cannot meet after 14:30 (14:30 in minutes)\n    elijah_cutoff = 14 * 60 + 30\n    \n    # Find available slots for Elijah before the cutoff\n    available_slots = []\n    previous_end = work_start\n    \n    for start, end in sorted(elijah_busy):\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the time after the last busy slot\n    if previous_end < elijah_cutoff:\n        available_slots.append((previous_end, elijah_cutoff))\n    \n    # Find the first available slot that fits the meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No available time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_521"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert schedules to minutes\n    jeremy_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 12 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    denise_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 16 * 60)\n    ]\n    \n    # Denise's preference: not before 12:30\n    preference_start = 12 * 60 + 30  # 12:30 in minutes\n    \n    # Find all possible 30-minute slots\n    possible_slots = []\n    \n    for start in range(preference_start, work_end - 30):\n        end = start + 30\n        conflict = False\n        \n        # Check Jeremy's schedule\n        for busy_start, busy_end in jeremy_busy:\n            if not (end <= busy_start or start >= busy_end):\n                conflict = True\n                break\n        if conflict:\n            continue\n        \n        # Check Denise's schedule\n        for busy_start, busy_end in denise_busy:\n            if not (end <= busy_start or start >= busy_end):\n                conflict = True\n                break\n        if conflict:\n            continue\n        \n        possible_slots.append((start, end))\n    \n    if not possible_slots:\n        return None\n    \n    # Select the first available slot\n    meeting_start, meeting_end = possible_slots[0]\n    \n    # Convert back to HH:MM format\n    def format_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n    \n    return f\"{format_time(meeting_start)}:{format_time(meeting_end)}\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_522"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours_start, work_hours_end, duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy_slots in participants_busy.values():\n        for slot in busy_slots:\n            start, end = map(time_to_minutes, slot.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Find the first free interval that can accommodate the meeting\n    for interval in free_intervals:\n        start, end = interval\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return (minutes_to_time(meeting_start), minutes_to_time(meeting_end))\n    \n    return None\n\n# Define the participants' busy schedules\nparticipants_busy = {\n    'Ryan': [\n        '9:00 to 9:30',\n        '11:30 to 12:00',\n        '14:30 to 15:00',\n        '16:00 to 16:30'\n    ],\n    'Kenneth': [\n        '9:30 to 10:30',\n        '11:00 to 12:00',\n        '12:30 to 13:00',\n        '13:30 to 14:00',\n        '14:30 to 16:30'\n    ]\n}\n\n# Define work hours and meeting duration\nwork_hours_start = '9:00'\nwork_hours_end = '17:00'\nduration_minutes = 30  # half an hour\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours_start, work_hours_end, duration_minutes)\n\n# Output the result in the required format\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{start}:{end}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_523"
        },
        {
            "final_program_time": "{11:00:12:00}",
            "expected_time": "{11:00:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Katherine's schedule: free all day\n    katherine_free = [(work_start, work_end)]\n\n    # Logan's schedule and constraints\n    logan_busy = [\n        (9 * 60, 9 * 60 + 30),   # 9:00-9:30\n        (10 * 60 + 30, 11 * 60), # 10:30-11:00\n        (13 * 60 + 30, 14 * 60), # 13:30-14:00\n        (14 * 60 + 30, 17 * 60)  # 14:30-17:00\n    ]\n    logan_constraint_start = 10 * 60 + 30  # Not before 10:30\n\n    # Find Logan's free slots within work hours and constraints\n    logan_free = []\n    previous_end = work_start\n    for start, end in sorted(logan_busy):\n        if start > previous_end and previous_end >= logan_constraint_start:\n            logan_free.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if work_end > previous_end and previous_end >= logan_constraint_start:\n        logan_free.append((previous_end, work_end))\n\n    # Find overlapping free slots of 60 minutes\n    meeting_duration = 60\n    for k_start, k_end in katherine_free:\n        for l_start, l_end in logan_free:\n            start = max(k_start, l_start)\n            end = min(k_end, l_end)\n            if end - start >= meeting_duration:\n                # Return the first suitable slot found\n                return f\"{start//60:02d}:{start%60:02d}:{(start+meeting_duration)//60:02d}:{(start+meeting_duration)%60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_524"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define blocked times in minutes\n    james_blocked = [\n        (9 * 60 + 30, 10 * 60),   # 9:30-10:00\n        (10 * 60 + 30, 11 * 60)    # 10:30-11:00\n    ]\n    lawrence_blocked = [\n        (10 * 60, 11 * 60),        # 10:00-11:00\n        (12 * 60, 13 * 60),        # 12:00-13:00\n        (14 * 60, 15 * 60),        # 14:00-15:00\n        (16 * 60, 17 * 60)         # 16:00-17:00\n    ]\n    \n    # James cannot meet after 14:30\n    james_limit = 14 * 60 + 30\n    \n    # Meeting duration in minutes\n    meeting_duration = 30\n    \n    # Generate all possible slots\n    possible_slots = []\n    current_time = work_start\n    \n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        # Check if the slot is within James' limit\n        if slot_end > james_limit:\n            current_time += 1\n            continue\n        # Check if the slot is free for both\n        james_free = True\n        for start, end in james_blocked:\n            if not (slot_end <= start or current_time >= end):\n                james_free = False\n                break\n        lawrence_free = True\n        for start, end in lawrence_blocked:\n            if not (slot_end <= start or current_time >= end):\n                lawrence_free = False\n                break\n        if james_free and lawrence_free:\n            possible_slots.append((current_time, slot_end))\n        current_time += 1\n    \n    # Select the first available slot\n    if possible_slots:\n        start, end = possible_slots[0]\n        # Convert minutes back to HH:MM format\n        start_hh = start // 60\n        start_mm = start % 60\n        end_hh = end // 60\n        end_mm = end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_525"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define busy intervals in minutes since midnight\n    harold_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    \n    nicholas_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60, 17 * 60)\n    ]\n    \n    nicholas_preference_end = 14 * 60 + 30  # 14:30\n    \n    # Combine and sort all busy intervals\n    all_busy = harold_busy + nicholas_busy\n    all_busy.sort()\n    \n    # Find free intervals by checking gaps between busy intervals\n    free_intervals = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_intervals.append((previous_end, work_end))\n    \n    # Check each free interval for a 30-minute slot that fits Nicholas's preference\n    meeting_duration = 30\n    proposed_time = None\n    \n    for start, end in free_intervals:\n        if end > nicholas_preference_end:\n            end = min(end, nicholas_preference_end)\n        if end - start >= meeting_duration:\n            proposed_time = (start, start + meeting_duration)\n            break\n    \n    # Format the proposed time\n    if proposed_time:\n        start_h = proposed_time[0] // 60\n        start_m = proposed_time[0] % 60\n        end_h = proposed_time[1] // 60\n        end_m = proposed_time[1] % 60\n        return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    else:\n        return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_526"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define Megan's meetings and preferences\n    megan_meetings = [\n        (9 * 60, 9 * 60 + 30),   # 9:00-9:30\n        (10 * 60, 14 * 60),      # 10:00-14:00\n        (14 * 60 + 30, 17 * 60)  # 14:30-17:00\n    ]\n    megan_no_meet_after = 11 * 60  # 11:00\n    \n    # Wayne is free all day\n    wayne_meetings = []\n    \n    # Find all possible 30-minute slots\n    possible_slots = []\n    current_time = work_start\n    \n    while current_time + 30 <= work_end:\n        slot_start = current_time\n        slot_end = current_time + 30\n        \n        # Check if the slot is free for both\n        wayne_free = True\n        for meeting in wayne_meetings:\n            if not (slot_end <= meeting[0] or slot_start >= meeting[1]):\n                wayne_free = False\n                break\n        \n        megan_free = True\n        for meeting in megan_meetings:\n            if not (slot_end <= meeting[0] or slot_start >= meeting[1]):\n                megan_free = False\n                break\n        \n        # Check Megan's preference (not after 11:00)\n        if slot_start >= megan_no_meet_after:\n            megan_free = False\n        \n        if wayne_free and megan_free:\n            possible_slots.append((slot_start, slot_end))\n        \n        current_time += 30  # Check next slot\n    \n    if possible_slots:\n        # Select the first available slot\n        best_slot = possible_slots[0]\n        start_h = best_slot[0] // 60\n        start_m = best_slot[0] % 60\n        end_h = best_slot[1] // 60\n        end_m = best_slot[1] % 60\n        \n        return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    else:\n        return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_527"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Harold's meetings in minutes\n    harold_meetings = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    \n    # Edward's meetings in minutes (including blocked times and preference to avoid after 14:30)\n    edward_meetings = [\n        (9 * 60, 11 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 14 * 60 + 30),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n    edward_preference_end = 14 * 60 + 30  # Prefers no meetings after 14:30\n    \n    # Combine all busy times for both participants\n    busy_times = harold_meetings + edward_meetings\n    busy_times.sort()  # Sort by start time\n    \n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in busy_times:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last meeting until work_end\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Filter free slots that are at least 30 minutes and meet Edward's preference\n    meeting_duration = 30\n    valid_slots = []\n    \n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Check if the slot starts before Edward's preference end time\n            if start < edward_preference_end:\n                valid_slots.append((start, end))\n    \n    # Select the earliest valid slot\n    if valid_slots:\n        start, end = valid_slots[0]\n        # Format the time as HH:MM:HH:MM\n        start_hh = start // 60\n        start_mm = start % 60\n        end_hh = (start + meeting_duration) // 60\n        end_mm = (start + meeting_duration) % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No valid slot found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_528"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participant_schedules, work_hours, duration, constraints):\n    # Parse work hours\n    work_start, work_end = work_hours.split(\" to \")\n    work_start = int(work_start.split(':')[0]) * 60 + int(work_start.split(':')[1])\n    work_end = int(work_end.split(':')[0]) * 60 + int(work_end.split(':')[1])\n    \n    # Initialize busy intervals for all participants\n    busy_intervals = []\n    for schedule in participant_schedules:\n        intervals = []\n        for meeting in schedule['meetings']:\n            start, end = meeting.split(\" to \")\n            start_time = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n            end_time = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n            intervals.append((start_time, end_time))\n        busy_intervals.append(intervals)\n    \n    # Merge and sort busy intervals for each participant\n    merged_intervals = []\n    for intervals in busy_intervals:\n        if not intervals:\n            merged_intervals.append([])\n            continue\n        intervals.sort()\n        merged = [intervals[0]]\n        for current in intervals[1:]:\n            last = merged[-1]\n            if current[0] <= last[1]:\n                merged[-1] = (last[0], max(last[1], current[1]))\n            else:\n                merged.append(current)\n        merged_intervals.append(merged)\n    \n    # Find common free slots\n    all_free_slots = []\n    for i, intervals in enumerate(merged_intervals):\n        free_slots = []\n        prev_end = work_start\n        for start, end in intervals:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        all_free_slots.append(free_slots)\n    \n    # Find overlapping free slots\n    common_free_slots = []\n    for slot in all_free_slots[0]:\n        for other_slots in all_free_slots[1:]:\n            for other_slot in other_slots:\n                overlap_start = max(slot[0], other_slot[0])\n                overlap_end = min(slot[1], other_slot[1])\n                if overlap_start < overlap_end:\n                    common_free_slots.append((overlap_start, overlap_end))\n    \n    # Apply constraints\n    filtered_slots = []\n    for start, end in common_free_slots:\n        valid = True\n        for constraint in constraints:\n            if constraint['participant'] == 'Anthony' and 'after' in constraint:\n                constraint_time = int(constraint['after'].split(':')[0]) * 60 + int(constraint['after'].split(':')[1])\n                if start >= constraint_time:\n                    valid = False\n                    break\n        if valid and (end - start) >= duration:\n            filtered_slots.append((start, end))\n    \n    # Find the earliest possible slot\n    if filtered_slots:\n        filtered_slots.sort()\n        for start, end in filtered_slots:\n            if (end - start) >= duration:\n                meeting_end = start + duration\n                return f\"{start//60:02d}:{start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n    return \"No available slot found\"\n\n# Define the problem\nparticipant_schedules = [\n    {\n        'name': 'Anthony',\n        'meetings': [\n            '9:00 to 10:00',\n            '12:30 to 13:00',\n            '13:30 to 14:00',\n            '15:30 to 16:30'\n        ]\n    },\n    {\n        'name': 'Joshua',\n        'meetings': [\n            '9:00 to 9:30',\n            '11:00 to 12:30',\n            '13:00 to 14:00',\n            '15:30 to 16:30'\n        ]\n    }\n]\n\nwork_hours = \"9:00 to 17:00\"\nduration = 30  # minutes\nconstraints = [\n    {'participant': 'Anthony', 'after': '15:30'}\n]\n\n# Find and print the meeting time\nprint(find_meeting_time(participant_schedules, work_hours, duration, constraints))\n```",
            "count": "calendar_scheduling_example_529"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{10:00:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participant_busy_times, work_start, work_end, duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Combine all busy times and sort them\n    all_busy = []\n    for busy_times in participant_busy_times.values():\n        for start, end in busy_times:\n            all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    all_busy.sort()\n    \n    # Find the earliest available slot\n    prev_end = work_start_min\n    for start, end in all_busy:\n        if start > prev_end and start - prev_end >= duration_min:\n            return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + duration_min)}\"\n        prev_end = max(prev_end, end)\n    \n    # Check after the last busy time\n    if work_end_min - prev_end >= duration_min:\n        return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + duration_min)}\"\n    \n    return \"No available time slot found\"\n\n# Define the participants' busy times\nparticipant_busy_times = {\n    \"Ann\": [],\n    \"Christopher\": [\n        (\"09:00\", \"10:00\"),\n        (\"11:00\", \"11:30\"),\n        (\"12:00\", \"12:30\"),\n        (\"13:00\", \"13:30\"),\n        (\"14:00\", \"14:30\"),\n        (\"15:00\", \"15:30\"),\n        (\"16:30\", \"17:00\")\n    ]\n}\n\n# Define work hours and meeting duration\nwork_start = \"09:00\"\nwork_end = \"17:00\"\nduration = 1  # in hours\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participant_busy_times, work_start, work_end, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_530"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(ruth_schedule, kayla_schedule, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Combine and sort all busy intervals for Kayla (Ruth is free all day)\n    busy_intervals = []\n    for interval in kayla_schedule:\n        start, end = interval.split(' to ')\n        busy_intervals.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort intervals by start time\n    busy_intervals.sort()\n    \n    # Find free intervals for Kayla\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval to see if it can fit the meeting\n    duration_min = duration * 60\n    for start, end in free_intervals:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define schedules and constraints\nruth_schedule = []  # Ruth has no meetings\nkayla_schedule = [\"9:00 to 9:30\", \"10:00 to 11:30\", \"13:00 to 17:00\"]\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 1  # in hours\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(ruth_schedule, kayla_schedule, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_531"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Helen's busy times in minutes (start, end)\n    helen_busy = [\n        (9 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    \n    # Helen's preference: not after 13:30\n    preference_cutoff = 13 * 60 + 30\n    \n    # Theresa is free all day, so we only need to consider Helen's schedule\n    # Find all possible 30-minute slots in Helen's free time\n    free_slots = []\n    previous_end = work_start\n    \n    for busy_start, busy_end in helen_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = busy_end\n    \n    # Check after last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Filter slots that are at least 30 minutes and meet Helen's preference\n    possible_slots = []\n    for slot_start, slot_end in free_slots:\n        slot_duration = slot_end - slot_start\n        if slot_duration >= 30 and slot_start + 30 <= preference_cutoff:\n            possible_slots.append((slot_start, slot_start + 30))\n    \n    # Select the earliest possible slot\n    if possible_slots:\n        meeting_start, meeting_end = possible_slots[0]\n    else:\n        # If no preferred slots, check all free slots (though problem states a solution exists)\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= 30:\n                meeting_start, meeting_end = slot_start, slot_start + 30\n                break\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n    \n    start_time = minutes_to_time(meeting_start)\n    end_time = minutes_to_time(meeting_end)\n    \n    return f\"{start_time}:{end_time}\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_532"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert blocked times to minutes since midnight\n    alexis_blocked = [\n        (10 * 60 + 30, 11 * 60),    # 10:30-11:00\n        (13 * 60 + 30, 14 * 60)     # 13:30-14:00\n    ]\n    dorothy_blocked = [\n        (9 * 60 + 30, 10 * 60),     # 9:30-10:00\n        (10 * 60 + 30, 11 * 60 + 30),  # 10:30-11:30\n        (12 * 60 + 30, 13 * 60 + 30),  # 12:30-13:30\n        (14 * 60, 15 * 60 + 30),    # 14:00-15:30\n        (16 * 60, 17 * 60)          # 16:00-17:00\n    ]\n\n    # Combine all blocked times for both participants\n    all_blocked = alexis_blocked + dorothy_blocked\n    # Sort blocked times by start time\n    all_blocked.sort()\n\n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n\n    for start, end in all_blocked:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n\n    # Check after last blocked time\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Find first available slot that can fit 1 hour (60 minutes)\n    for slot in available_slots:\n        start, end = slot\n        if end - start >= 60:\n            meeting_start = start\n            meeting_end = meeting_start + 60\n            # Convert back to HH:MM format\n            start_h = meeting_start // 60\n            start_m = meeting_start % 60\n            end_h = meeting_end // 60\n            end_m = meeting_end % 60\n            return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n\n    return \"No available time found\"\n\n# Execute and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_533"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(busy_slots, work_hours, duration):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = map(time_to_minutes, work_hours)\n    busy_slots_min = []\n    for slot in busy_slots:\n        start, end = map(time_to_minutes, slot)\n        busy_slots_min.append((start, end))\n    \n    # Sort busy slots by start time\n    busy_slots_min.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = work_start\n    for start, end in busy_slots_min:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Find the earliest free slot that can fit the meeting\n    for slot in free_slots:\n        start, end = slot\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return (minutes_to_time(meeting_start), minutes_to_time(meeting_end))\n    \n    return None\n\n# Define the constraints\nwork_hours = (\"9:00\", \"17:00\")\nrobert_busy = [(\"9:00\", \"11:30\"), (\"12:00\", \"14:00\"), (\"14:30\", \"15:30\"), (\"16:00\", \"16:30\")]\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(robert_busy, work_hours, duration_minutes)\n\n# Output the result\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{start}:{end}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_534"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:9:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(daniel_schedule, donna_schedule, work_hours_start, work_hours_end, duration):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration_min = duration * 60\n    \n    # Combine and sort all busy intervals for Daniel and Donna\n    all_busy = []\n    for start, end in daniel_schedule:\n        all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    for start, end in donna_schedule:\n        all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort the busy intervals by start time\n    all_busy.sort()\n    \n    # Find the earliest available slot\n    prev_end = work_start\n    for start, end in all_busy:\n        if start > prev_end and start - prev_end >= duration_min:\n            return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + duration_min)}\"\n        prev_end = max(prev_end, end)\n    \n    # Check after the last busy interval\n    if work_end - prev_end >= duration_min:\n        return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + duration_min)}\"\n    \n    return None\n\n# Define the schedules and constraints\ndaniel_schedule = [\n    (\"10:00\", \"10:30\"),\n    (\"11:00\", \"11:30\")\n]\n\ndonna_schedule = [\n    (\"10:30\", \"11:00\"),\n    (\"11:30\", \"12:00\"),\n    (\"12:30\", \"13:30\"),\n    (\"14:00\", \"14:30\"),\n    (\"15:00\", \"16:00\"),\n    (\"16:30\", \"17:00\")\n]\n\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nduration = 0.5  # half an hour\n\n# Find the meeting time\nmeeting_time = find_meeting_time(daniel_schedule, donna_schedule, work_hours_start, work_hours_end, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_535"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' schedules and constraints in minutes\n    logan_busy = [\n        (10 * 60 + 30, 11 * 60),      # 10:30-11:00\n        (11 * 60 + 30, 12 * 60),      # 11:30-12:00\n        (12 * 60 + 30, 13 * 60),      # 12:30-13:00\n        (13 * 60 + 30, 14 * 60),      # 13:30-14:00\n        (14 * 60 + 30, 15 * 60),      # 14:30-15:00\n        (15 * 60 + 30, 16 * 60)       # 15:30-16:00\n    ]\n    \n    paul_busy = [\n        (9 * 60, 10 * 60 + 30),      # 9:00-10:30\n        (11 * 60, 11 * 60 + 30),      # 11:00-11:30\n        (12 * 60, 13 * 60 + 30),      # 12:00-13:30\n        (15 * 60 + 30, 17 * 60)       # 15:30-17:00\n    ]\n    \n    # Paul cannot meet before 15:00\n    paul_constraint = 15 * 60\n    \n    # Meeting duration in minutes\n    meeting_duration = 30\n    \n    # Combine and sort all busy intervals\n    all_busy = logan_busy + paul_busy\n    all_busy.sort()\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Filter slots that meet duration and Paul's constraint\n    valid_slots = []\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration:\n            actual_start = max(slot_start, paul_constraint)\n            if actual_start + meeting_duration <= slot_end:\n                valid_slots.append((actual_start, actual_start + meeting_duration))\n    \n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start, meeting_end = valid_slots[0]\n        # Convert minutes back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available time slot found.\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_536"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:30:10:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(judith_busy, terry_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n    \n    def minutes_to_time(minutes):\n        hh = (minutes + 540) // 60\n        mm = (minutes + 540) % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    start_work, end_work = map(time_to_minutes, work_hours.split(':'))\n    total_slots = end_work - start_work\n    \n    # Parse busy slots\n    def parse_busy_slots(busy_list):\n        slots = []\n        for slot in busy_list:\n            start, end = map(time_to_minutes, slot.split(' to '))\n            slots.append((start, end))\n        return slots\n    \n    judith_slots = parse_busy_slots(judith_busy)\n    terry_slots = parse_busy_slots(terry_busy)\n    \n    # Merge and sort all busy slots\n    all_busy = judith_slots + terry_slots\n    all_busy.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = start_work\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < end_work:\n        free_slots.append((prev_end, end_work))\n    \n    # Find the earliest slot that fits the duration\n    for start, end in free_slots:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define inputs\njudith_busy = [\"11:30 to 12:00\", \"14:00 to 14:30\"]\nterry_busy = [\"9:00 to 9:30\", \"11:00 to 12:30\", \"13:00 to 13:30\", \"14:30 to 16:00\"]\nwork_hours = \"9:00:17:00\"\nduration = 60  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(judith_busy, terry_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_537"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Kenneth's busy times in minutes (11:00-11:30, 12:00-12:30)\n    kenneth_busy = [(11 * 60, 11 * 60 + 30), (12 * 60, 12 * 60 + 30)]\n    \n    # Barbara's busy times in minutes (9:00-11:30, 12:30-17:00)\n    barbara_busy = [(9 * 60, 11 * 60 + 30), (12 * 60 + 30, 17 * 60)]\n    \n    # Combine and sort all busy times for both participants\n    all_busy = kenneth_busy + barbara_busy\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy times\n    previous_end = work_start\n    free_slots = []\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the time after the last busy slot until work_end\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can accommodate 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_538"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define busy intervals in minutes\n    andrea_busy = [\n        (10 * 60, 10 * 60 + 30),  # 10:00-10:30\n        (11 * 60 + 30, 12 * 60)    # 11:30-12:00\n    ]\n    abigail_busy = [\n        (9 * 60, 12 * 60),         # 9:00-12:00\n        (12 * 60 + 30, 14 * 60),    # 12:30-14:00\n        (14 * 60 + 30, 15 * 60 + 30),  # 14:30-15:30\n        (16 * 60 + 30, 17 * 60)     # 16:30-17:00\n    ]\n\n    # Andrea's preference: not after 12:30 (12*60 + 30)\n    preference_end = 12 * 60 + 30\n\n    # Meeting duration in minutes\n    duration = 30\n\n    # Find all possible slots in work hours\n    possible_slots = []\n    current_time = work_start\n\n    while current_time + duration <= work_end:\n        slot_end = current_time + duration\n        # Check if the slot is within Andrea's preference\n        if slot_end <= preference_end:\n            # Check if the slot is free for both\n            andrea_free = True\n            for start, end in andrea_busy:\n                if not (slot_end <= start or current_time >= end):\n                    andrea_free = False\n                    break\n            abigail_free = True\n            for start, end in abigail_busy:\n                if not (slot_end <= start or current_time >= end):\n                    abigail_free = False\n                    break\n            if andrea_free and abigail_free:\n                possible_slots.append((current_time, slot_end))\n        current_time += 15  # Check every 15 minutes for a slot\n\n    if possible_slots:\n        # Select the first available slot\n        start, end = possible_slots[0]\n        # Convert minutes back to HH:MM format\n        start_hh = start // 60\n        start_mm = start % 60\n        end_hh = end // 60\n        end_mm = end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_539"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(daniel_busy, christopher_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 (9:00)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes  # Add back 540 to get actual time\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    work_start, work_end = work_hours.split(' to ')\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Parse busy intervals for Daniel\n    daniel_busy_min = []\n    for interval in daniel_busy:\n        start, end = interval.split(' to ')\n        daniel_busy_min.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Parse busy intervals for Christopher\n    christopher_busy_min = []\n    for interval in christopher_busy:\n        start, end = interval.split(' to ')\n        christopher_busy_min.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Merge and sort busy intervals for both participants\n    all_busy = daniel_busy_min + christopher_busy_min\n    all_busy.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = work_start_min\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        free_slots.append((prev_end, work_end_min))\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot in free_slots:\n        start, end = slot\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define inputs\ndaniel_busy = [\n    \"9:30 to 10:00\",\n    \"11:00 to 11:30\",\n    \"13:00 to 14:00\",\n    \"15:00 to 15:30\",\n    \"16:30 to 17:00\"\n]\n\nchristopher_busy = [\n    \"9:30 to 11:00\",\n    \"11:30 to 12:30\",\n    \"13:30 to 14:00\",\n    \"15:00 to 15:30\",\n    \"16:00 to 16:30\"\n]\n\nwork_hours = \"9:00 to 17:00\"\nduration = 60  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(daniel_busy, christopher_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_540"
        },
        {
            "final_program_time": "{16:00:17:00}",
            "expected_time": "{16:00:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Find the first free interval that can accommodate the meeting\n    duration_minutes = duration * 60\n    for start, end in free_intervals:\n        if end - start >= duration_minutes:\n            meeting_end = start + duration_minutes\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nkayla_schedule = [\"10:00 to 10:30\", \"14:30 to 16:00\"]\nrebecca_schedule = [\"9:00 to 13:00\", \"13:30 to 15:00\", \"15:30 to 16:00\"]\nparticipants_schedules = [kayla_schedule, rebecca_schedule]\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration = 1  # hours\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration))\n```",
            "count": "calendar_scheduling_example_541"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Generate all busy intervals for each participant\n    all_busy_intervals = []\n    for busy_times in participants_busy_times:\n        for interval in busy_times:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            all_busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_intervals = []\n    for start, end in all_busy_intervals:\n        if not merged_intervals:\n            merged_intervals.append([start, end])\n        else:\n            last_start, last_end = merged_intervals[-1]\n            if start <= last_end:\n                merged_intervals[-1][1] = max(end, last_end)\n            else:\n                merged_intervals.append([start, end])\n    \n    # Find available slots by checking gaps between merged intervals and work hours\n    available_slots = []\n    previous_end = work_start\n    for start, end in merged_intervals:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Check each available slot for sufficient duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define the participants' busy times\njean_busy = [\n    \"09:30 to 10:00\",\n    \"10:30 to 11:00\",\n    \"12:30 to 13:30\"\n]\n\namanda_busy = [\n    \"09:00 to 10:30\",\n    \"11:30 to 12:30\",\n    \"13:00 to 14:00\",\n    \"15:30 to 17:00\"\n]\n\n# Parameters\nparticipants_busy_times = [jean_busy, amanda_busy]\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 60  # 1 hour\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration_minutes))\n```",
            "count": "calendar_scheduling_example_542"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:30:14:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(work_start, work_end, duration, schedules):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Combine all busy intervals and sort them\n    all_busy = []\n    for person_schedule in schedules:\n        for busy in person_schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            all_busy.append((start, end))\n    \n    # Sort busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots\n    available = []\n    prev_end = work_start_min\n    \n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        available.append((prev_end, work_end_min))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define work hours, duration, and schedules\nwork_start = \"09:00\"\nwork_end = \"17:00\"\nduration = 1  # in hours\n\njames_schedule = [\n    \"11:30:12:00\",\n    \"14:30:15:00\"\n]\n\njohn_schedule = [\n    \"09:30:11:00\",\n    \"11:30:12:00\",\n    \"12:30:13:30\",\n    \"14:30:16:30\"\n]\n\nschedules = [james_schedule, john_schedule]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(work_start, work_end, duration, schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_543"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Albert's busy times in minutes (start, end)\n    albert_busy = [\n        (9 * 60, 10 * 60),    # 9:00-10:00\n        (10 * 60 + 30, 12 * 60),  # 10:30-12:00\n        (15 * 60, 16 * 60 + 30),  # 15:00-16:30\n    ]\n    # Albert cannot meet after 11:00\n    albert_cutoff = 11 * 60\n\n    # Deborah is free all day, so only Albert's schedule matters\n    potential_slots = []\n\n    # Check before first busy slot\n    if albert_busy[0][0] > work_start:\n        potential_slots.append((work_start, albert_busy[0][0]))\n\n    # Check between busy slots\n    for i in range(1, len(albert_busy)):\n        prev_end = albert_busy[i-1][1]\n        curr_start = albert_busy[i][0]\n        if curr_start > prev_end:\n            potential_slots.append((prev_end, curr_start))\n\n    # Check after last busy slot but before work_end and Albert's cutoff\n    last_busy_end = albert_busy[-1][1]\n    latest_possible = min(work_end, albert_cutoff)\n    if latest_possible > last_busy_end:\n        potential_slots.append((last_busy_end, latest_possible))\n\n    # Find the first slot that can fit 30 minutes\n    meeting_duration = 30\n    for slot in potential_slots:\n        start, end = slot\n        if end - start >= meeting_duration:\n            # Return the first 30-minute window in this slot\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_544"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert busy slots to minutes\n    christine_busy = [\n        (12 * 60, 12 * 60 + 30),  # 12:00-12:30\n        (13 * 60, 13 * 60 + 30)    # 13:00-13:30\n    ]\n    richard_busy = [\n        (9 * 60, 12 * 60),          # 9:00-12:00\n        (13 * 60, 13 * 60 + 30),    # 13:00-13:30\n        (14 * 60, 14 * 60 + 30),    # 14:00-14:30\n        (15 * 60 + 30, 16 * 60),    # 15:30-16:00\n        (16 * 60 + 30, 17 * 60)     # 16:30-17:00\n    ]\n\n    # Combine and sort all busy slots\n    all_busy = christine_busy + richard_busy\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate 1 hour (60 minutes)\n    for start, end in free_slots:\n        if end - start >= 60:\n            meeting_start = start\n            meeting_end = meeting_start + 60\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_545"
        },
        {
            "final_program_time": "{9:30:10:30}",
            "expected_time": "{9:30:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Ruth's meetings in minutes since start of day\n    ruth_meetings = [\n        (9 * 60, 9 * 60 + 30),    # 9:00-9:30\n        (10 * 60 + 30, 12 * 60 + 30),  # 10:30-12:30\n        (13 * 60, 14 * 60 + 30),  # 13:00-14:30\n        (15 * 60 + 30, 16 * 60),   # 15:30-16:00\n        (16 * 60 + 30, 17 * 60)    # 16:30-17:00\n    ]\n\n    # Lauren's constraints: no meetings after 11:30 (11:30 in minutes)\n    lauren_max_time = 11 * 60 + 30\n\n    # Find available slots for Ruth (outside her meetings)\n    ruth_busy = sorted(ruth_meetings)\n    available_slots = []\n    previous_end = work_start\n\n    for start, end in ruth_busy:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n\n    # Check each available slot against Lauren's constraints and meeting duration (60 minutes)\n    meeting_duration = 60\n    for slot_start, slot_end in available_slots:\n        # Adjust slot_start to ensure the meeting fits and respects Lauren's constraint\n        latest_possible_start = min(slot_end - meeting_duration, lauren_max_time - meeting_duration)\n        if latest_possible_start >= slot_start:\n            actual_start = max(slot_start, latest_possible_start)\n            actual_end = actual_start + meeting_duration\n            if actual_end <= lauren_max_time and actual_end <= slot_end:\n                # Format the time as HH:MM:HH:MM\n                start_hh = actual_start // 60\n                start_mm = actual_start % 60\n                end_hh = actual_end // 60\n                end_mm = actual_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_546"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(duration, work_start, work_end, schedules):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Generate busy slots in minutes\n    busy_slots = []\n    for slot in schedules:\n        start, end = map(time_to_minutes, slot.split(' to '))\n        busy_slots.append((start, end))\n    \n    # Sort busy slots by start time\n    busy_slots.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = work_start_min\n    \n    for start, end in busy_slots:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        free_slots.append((prev_end, work_end_min))\n    \n    # Check for a free slot that can fit the duration\n    duration_min = duration * 60\n    for start, end in free_slots:\n        if end - start >= duration_min:\n            meeting_end = start + duration_min\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                h = minutes // 60\n                m = minutes % 60\n                return f\"{h:02d}:{m:02d}\"\n            \n            start_time = minutes_to_time(start)\n            end_time = minutes_to_time(meeting_end)\n            return f\"{start_time}:{end_time}\"\n    \n    return \"No suitable time found\"\n\n# Define the constraints\nduration = 1  # 1 hour\nwork_start = \"9:00\"\nwork_end = \"17:00\"\n# Jacob's busy slots\nschedules = [\n    \"9:00 to 10:30\",\n    \"11:30 to 12:00\",\n    \"12:30 to 13:00\",\n    \"13:30 to 15:00\",\n    \"15:30 to 16:00\",\n    \"16:30 to 17:00\"\n]\n\n# Find and print the meeting time\nprint(find_meeting_time(duration, work_start, work_end, schedules))\n```",
            "count": "calendar_scheduling_example_547"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define Judy's free time (entire day)\n    judy_free = [(work_start, work_end)]\n    \n    # Define Nicole's busy times (in minutes)\n    nicole_busy = [\n        (9 * 60, 10 * 60),    # 9:00-10:00\n        (10 * 60 + 30, 16 * 60 + 30)  # 10:30-16:30\n    ]\n    \n    # Nicole's preference: not before 16:00\n    preference_start = 16 * 60\n    \n    # Find Nicole's free times (inverse of busy times within work hours)\n    nicole_free = []\n    previous_end = work_start\n    \n    for start, end in sorted(nicole_busy):\n        if start > previous_end:\n            nicole_free.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        nicole_free.append((previous_end, work_end))\n    \n    # Filter Nicole's free times based on preference (not before 16:00)\n    nicole_free_preferred = []\n    for start, end in nicole_free:\n        if start >= preference_start:\n            nicole_free_preferred.append((start, end))\n        elif end > preference_start:\n            nicole_free_preferred.append((preference_start, end))\n    \n    # Find overlapping free times between Judy and Nicole (preferred)\n    meeting_duration = 30  # minutes\n    \n    for nicole_start, nicole_end in nicole_free_preferred:\n        # Judy is free all day, so overlap is Nicole's free time\n        start = nicole_start\n        end = nicole_end\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    # If no preferred time found, check all free times (though problem states solution exists)\n    for nicole_start, nicole_end in nicole_free:\n        start = nicole_start\n        end = nicole_end\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No time found\"  # Should not reach here per problem statement\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_548"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert busy slots to minutes\n    carl_busy = [\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    russell_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n\n    # Carl's preference: not after 10:30\n    carl_preference_end = 10 * 60 + 30\n\n    # Find all possible 30-minute slots\n    possible_slots = []\n    current_time = work_start\n    meeting_duration = 30\n\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        # Check if the slot is free for both and meets Carl's preference\n        carl_free = all(not (start <= current_time < end or start < slot_end <= end) for start, end in carl_busy)\n        russell_free = all(not (start <= current_time < end or start < slot_end <= end) for start, end in russell_busy)\n        if carl_free and russell_free and slot_end <= carl_preference_end:\n            possible_slots.append((current_time, slot_end))\n        current_time += 1  # Check every minute\n\n    if possible_slots:\n        # Return the first valid slot in HH:MM format\n        start, end = possible_slots[0]\n        return f\"{start // 60:02d}:{start % 60:02d}:{end // 60:02d}:{end % 60:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_549"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:11:30}",
            "type_error": "NoCodeGenerated",
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Deborah's busy times in minutes since midnight\n    deborah_busy = [\n        (9 * 60, 11 * 60),\n        (11 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n\n    # Deborah's preference to avoid meetings after 14:00\n    preference_cutoff = 14 * 60\n\n    # Generate available slots for Deborah\n    available_slots = []\n    prev_end = work_start\n\n    for start, end in deborah_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = end\n\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Filter slots based on Deborah's preference (before 14:00)\n    preferred_slots = []\n    for start, end in available_slots:\n        if end <= preference_cutoff:\n            preferred_slots.append((start, end))\n        elif start < preference_cutoff:\n            preferred_slots.append((start, preference_cutoff))\n\n    # Find the first available slot that fits 30 minutes\n    meeting_duration = 30\n    for start, end in preferred_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    # If no preferred slot found, check other available slots (though problem states a solution exists)\n    for start, end in available_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No available time found\"\n\nprint(find_meeting_time())\n'''\n```",
            "count": "calendar_scheduling_example_550"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define busy slots in minutes since midnight\n    daniel_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60 + 30, 16 * 60)\n    ]\n    anna_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 12 * 60),\n        (12 * 60 + 30, 17 * 60)\n    ]\n\n    # Daniel's preference: not after 10:00\n    daniel_preference_end = 10 * 60\n\n    # Find all possible 30-minute slots\n    possible_slots = []\n    current_time = work_start\n\n    while current_time + 30 <= work_end:\n        slot_end = current_time + 30\n        # Check if the slot is before Daniel's preference\n        if slot_end <= daniel_preference_end:\n            # Check if both are free\n            daniel_free = True\n            for start, end in daniel_busy:\n                if not (slot_end <= start or current_time >= end):\n                    daniel_free = False\n                    break\n            anna_free = True\n            for start, end in anna_busy:\n                if not (slot_end <= start or current_time >= end):\n                    anna_free = False\n                    break\n            if daniel_free and anna_free:\n                possible_slots.append((current_time, slot_end))\n        current_time += 30\n\n    # Select the earliest possible slot\n    if possible_slots:\n        meeting_start, meeting_end = possible_slots[0]\n        # Convert minutes back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_551"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 14 * 60   # 14:00 in minutes (Margaret can't meet after 14:00)\n    \n    # Margaret's busy slots in minutes\n    margaret_busy = [\n        (9 * 60, 9 * 60 + 30),   # 9:00-9:30\n        (10 * 60, 10 * 60 + 30), # 10:00-10:30\n        (12 * 60, 14 * 60 + 30), # 12:00-14:30 (but truncated to 14:00 due to constraint)\n    ]\n    \n    # Brian is free all day, so only Margaret's schedule matters\n    \n    # Generate available slots by finding gaps in Margaret's schedule\n    available_slots = []\n    previous_end = work_start\n    \n    for start, end in sorted(margaret_busy):\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the time after the last busy slot\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Find the first available 30-minute slot\n    meeting_duration = 30\n    for start, end in available_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No available time slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_552"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:9:30}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(eric_busy, henry_busy, henry_preference, duration, work_hours):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m - 540  # Subtract 540 to start from 9:00 (0 minutes)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        h = total_minutes // 60\n        m = total_minutes % 60\n        return f\"{h:02d}:{m:02d}\"\n    \n    # Parse work hours\n    work_start, work_end = map(time_to_minutes, work_hours.split(':'))\n    \n    # Generate Eric's free slots\n    eric_free = []\n    prev_end = work_start\n    for start, end in sorted(eric_busy):\n        eric_free.append((prev_end, start))\n        prev_end = end\n    eric_free.append((prev_end, work_end))\n    \n    # Generate Henry's free slots\n    henry_free = []\n    prev_end = work_start\n    for start, end in sorted(henry_busy):\n        henry_free.append((prev_end, start))\n        prev_end = end\n    henry_free.append((prev_end, work_end))\n    \n    # Find overlapping slots that meet duration and Henry's preference\n    for e_start, e_end in eric_free:\n        for h_start, h_end in henry_free:\n            start = max(e_start, h_start)\n            end = min(e_end, h_end)\n            if end - start >= duration:\n                # Check Henry's preference (before 10:00 is 60 minutes)\n                meeting_end = start + duration\n                if meeting_end <= 60:  # 10:00 is 60 minutes from 9:00\n                    return (start, meeting_end)\n    \n    # If no preferred slot found, find any slot\n    for e_start, e_end in eric_free:\n        for h_start, h_end in henry_free:\n            start = max(e_start, h_start)\n            end = min(e_end, h_end)\n            if end - start >= duration:\n                return (start, start + duration)\n    \n    return None\n\n# Input data\neric_busy = [(time_to_minutes('12:00'), time_to_minutes('13:00')), \n             (time_to_minutes('14:00'), time_to_minutes('15:00'))]\nhenry_busy = [(time_to_minutes('9:30'), time_to_minutes('10:00')), \n              (time_to_minutes('10:30'), time_to_minutes('11:00')), \n              (time_to_minutes('11:30'), time_to_minutes('12:30')), \n              (time_to_minutes('13:00'), time_to_minutes('13:30')), \n              (time_to_minutes('14:30'), time_to_minutes('15:00')), \n              (time_to_minutes('16:00'), time_to_minutes('17:00'))]\nhenry_preference = True  # Prefers before 10:00\nduration = 30  # minutes\nwork_hours = \"9:00:17:00\"\n\n# Find meeting time\nmeeting_slot = find_meeting_time(eric_busy, henry_busy, henry_preference, duration, work_hours)\n\nif meeting_slot:\n    start, end = meeting_slot\n    start_time = minutes_to_time(start)\n    end_time = minutes_to_time(end)\n    print(f\"{start_time}:{end_time}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_553"
        },
        {
            "final_program_time": "{9:30:10:30}",
            "expected_time": "{9:30:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(theresa_busy, frances_busy, work_start, work_end, duration):\n    # Convert all time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Generate all busy slots for Theresa and Frances\n    theresa_slots = [(time_to_minutes(start), time_to_minutes(end)) for start, end in theresa_busy]\n    frances_slots = [(time_to_minutes(start), time_to_minutes(end)) for start, end in frances_busy]\n    \n    # Combine and sort all busy slots\n    all_busy = theresa_slots + frances_slots\n    all_busy.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = work_start_min\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        free_slots.append((prev_end, work_end_min))\n    \n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define the busy slots\ntheresa_busy = [(\"10:30\", \"11:00\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:30\"), (\"15:00\", \"15:30\"), (\"16:30\", \"17:00\")]\nfrances_busy = [(\"09:00\", \"09:30\"), (\"10:30\", \"15:00\"), (\"15:30\", \"16:30\")]\n\n# Define work hours and duration\nwork_start = \"09:00\"\nwork_end = \"17:00\"\nduration = 1  # in hours\n\n# Find and print the meeting time\nprint(find_meeting_time(theresa_busy, frances_busy, work_start, work_end, duration))\n```",
            "count": "calendar_scheduling_example_554"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Evelyn's constraints: available all day but doesn't want to meet after 13:00\n    evelyn_start = work_start\n    evelyn_end = 13 * 60  # 13:00 in minutes\n    \n    # Randy's blocked times in minutes\n    randy_blocked = [\n        (9 * 60, 10 * 60 + 30),  # 9:00-10:30\n        (11 * 60, 15 * 60 + 30),  # 11:00-15:30\n        (16 * 60, 17 * 60)        # 16:00-17:00\n    ]\n    \n    # Meeting duration in minutes\n    duration = 30\n    \n    # Find available slots for Randy (inverse of blocked times)\n    randy_available = []\n    prev_end = work_start\n    \n    for start, end in sorted(randy_blocked):\n        if start > prev_end:\n            randy_available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        randy_available.append((prev_end, work_end))\n    \n    # Find overlapping slots between Evelyn and Randy\n    for r_start, r_end in randy_available:\n        # The slot must start and end within Evelyn's availability\n        slot_start = max(r_start, evelyn_start)\n        slot_end = min(r_end, evelyn_end)\n        \n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_555"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(eric_busy, deborah_busy, deborah_preference, duration, work_hours):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 9:00 (0 minutes)\n    \n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    work_start, work_end = map(time_to_minutes, work_hours.split(' to '))\n    work_end -= duration  # No meeting can start after this time\n    \n    # Parse Deborah's preference\n    pref_start, pref_end = map(time_to_minutes, deborah_preference.split(' to '))\n    \n    # Combine and sort all busy intervals for Eric and Deborah\n    all_busy = []\n    for start, end in eric_busy:\n        all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    for start, end in deborah_busy:\n        all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    all_busy.sort()\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    for start, end in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Filter slots that fit the duration and are within Deborah's preference\n    valid_slots = []\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            # Check if the slot is entirely before Deborah's preference cutoff\n            if slot_start < pref_start:\n                valid_slots.append((slot_start, slot_end))\n    \n    # If no slots before preference, look at all slots\n    if not valid_slots:\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= duration:\n                valid_slots.append((slot_start, slot_end))\n    \n    # Select the earliest possible slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + duration\n        return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    else:\n        return \"No available time slot found.\"\n\n# Input data\neric_busy = [\n    (\"9:00\", \"10:00\"),\n    (\"11:30\", \"12:00\"),\n    (\"12:30\", \"14:00\")\n]\ndeborah_busy = [\n    (\"9:00\", \"10:30\"),\n    (\"11:00\", \"11:30\"),\n    (\"12:00\", \"12:30\"),\n    (\"13:30\", \"14:30\"),\n    (\"15:00\", \"15:30\")\n]\ndeborah_preference = \"9:00 to 15:00\"  # Avoid after 15:00\nduration = 30  # minutes\nwork_hours = \"9:00 to 17:00\"\n\n# Find and print the meeting time\nprint(find_meeting_time(eric_busy, deborah_busy, deborah_preference, duration, work_hours))\n```",
            "count": "calendar_scheduling_example_556"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(william_busy, natalie_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work_hours start at 9:00\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = 9 + minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work = time_to_minutes(work_hours[0])\n    end_work = time_to_minutes(work_hours[1])\n    duration_min = duration * 60\n    \n    # Generate all busy slots in minutes for both participants\n    william_busy_min = [(time_to_minutes(start), time_to_minutes(end)) for start, end in william_busy]\n    natalie_busy_min = [(time_to_minutes(start), time_to_minutes(end)) for start, end in natalie_busy]\n    \n    # Combine and sort all busy slots\n    all_busy = william_busy_min + natalie_busy_min\n    all_busy.sort()\n    \n    # Find available slots\n    available_slots = []\n    prev_end = start_work\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < end_work:\n        available_slots.append((prev_end, end_work))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define busy slots and parameters\nwilliam_busy = [(\"10:00\", \"10:30\"), (\"12:00\", \"13:00\"), (\"16:00\", \"16:30\")]\nnatalie_busy = [(\"09:00\", \"09:30\"), (\"10:00\", \"10:30\"), (\"12:00\", \"13:30\"), (\"14:00\", \"14:30\"), (\"15:00\", \"17:00\")]\nwork_hours = (\"09:00\", \"17:00\")\nduration = 1  # in hours\n\n# Find and print the meeting time\nprint(find_meeting_time(william_busy, natalie_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_557"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define Douglas's busy times in minutes (start, end)\n    douglas_busy = [\n        (9 * 60, 12 * 60),\n        (12 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    \n    # Anthony's constraint: not before 14:00\n    anthony_constraint = 14 * 60\n    \n    # Meeting duration in minutes\n    duration = 30\n    \n    # Find Douglas's free slots within work hours\n    douglas_free = []\n    prev_end = work_start\n    \n    for start, end in sorted(douglas_busy):\n        if start > prev_end:\n            douglas_free.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        douglas_free.append((prev_end, work_end))\n    \n    # Find slots that fit the meeting duration and Anthony's constraint\n    possible_slots = []\n    for start, end in douglas_free:\n        slot_start = max(start, anthony_constraint)\n        if slot_start + duration <= end:\n            possible_slots.append((slot_start, slot_start + duration))\n    \n    # Select the earliest possible slot\n    if possible_slots:\n        meeting_start, meeting_end = possible_slots[0]\n        # Convert minutes back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No suitable time found.\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_558"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(larry_busy, james_busy, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m - 540  # Subtract 540 to make 9:00 as 0\n    \n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes  # Add back 540 to convert to 24-hour format\n        h = total_minutes // 60\n        m = total_minutes % 60\n        return f\"{h:02d}:{m:02d}\"\n    \n    # Parse busy slots for Larry and James\n    def parse_busy_slots(busy_slots):\n        slots = []\n        for slot in busy_slots:\n            start, end = slot.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            slots.append((start_min, end_min))\n        return slots\n    \n    larry_slots = parse_busy_slots(larry_busy)\n    james_slots = parse_busy_slots(james_busy)\n    \n    # Combine and sort all busy slots\n    all_busy = larry_slots + james_slots\n    all_busy.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = 0\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    # Check after last busy slot\n    work_end_min = time_to_minutes(work_hours_end)\n    if prev_end < work_end_min:\n        free_slots.append((prev_end, work_end_min))\n    \n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= duration:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Input data\nlarry_busy = [\"11:00 to 12:30\", \"13:00 to 13:30\", \"14:30 to 15:30\"]\njames_busy = [\"10:00 to 10:30\", \"11:30 to 12:30\", \"13:30 to 14:00\", \"14:30 to 15:30\", \"16:00 to 17:00\"]\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration = 60  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(larry_busy, james_busy, work_hours_start, work_hours_end, duration))\n```",
            "count": "calendar_scheduling_example_559"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:00:13:00}",
            "type_error": "NoCodeGenerated",
            "full_response": "```python\ndef find_meeting_time(participant_busy_times, work_hours, duration):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = work_hours\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Generate all busy intervals in minutes\n    busy_intervals = []\n    for busy_slots in participant_busy_times.values():\n        for slot in busy_slots:\n            start, end = map(time_to_minutes, slot.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = work_start_min\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        free_slots.append((prev_end, work_end_min))\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return (minutes_to_time(meeting_start), minutes_to_time(meeting_end))\n    \n    return None\n\n# Define the problem parameters\nwork_hours = (\"9:00\", \"17:00\")\nparticipant_busy_times = {\n    \"Marilyn\": [],\n    \"Benjamin\": [\"9:00:10:00\", \"10:30:12:00\", \"13:30:14:30\", \"15:00:16:00\", \"16:30:17:00\"],\n}\nmeeting_duration = 1  # in hours\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participant_busy_times, work_hours, meeting_duration)\n\n# Output the result in the required format\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{start}:{end}\")\nelse:\n    print(\"No suitable time found.\")\n'''\n```",
            "count": "calendar_scheduling_example_560"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Define busy intervals in minutes since midnight\n    scott_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    jack_busy = [\n        (9 * 60, 15 * 60),\n        (15 * 60 + 30, 16 * 60 + 30)\n    ]\n    jack_constraint = 16 * 60  # Can't meet before 16:00\n\n    # Combine and sort all busy intervals\n    all_busy = scott_busy + jack_busy\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy intervals\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check after last busy interval\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Filter slots that meet duration (30 minutes) and Jack's constraint\n    meeting_duration = 30\n    valid_slots = []\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration and slot_start >= jack_constraint:\n            valid_slots.append((slot_start, slot_end))\n\n    # Select the earliest valid slot\n    if valid_slots:\n        chosen_start = valid_slots[0][0]\n        chosen_end = chosen_start + meeting_duration\n        # Format as HH:MM:HH:MM\n        return f\"{chosen_start // 60:02d}:{chosen_start % 60:02d}:{chosen_end // 60:02d}:{chosen_end % 60:02d}\"\n    else:\n        return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_561"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:00:10:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participant_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration_min = duration * 60\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participant_schedules.values():\n        for interval in schedule:\n            start = time_to_minutes(interval[0])\n            end = time_to_minutes(interval[1])\n            busy_intervals.append((start, end))\n    \n    # Sort the busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find available slots by merging busy intervals\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found.\"\n\n# Define the participants' schedules\nparticipant_schedules = {\n    \"Robert\": [(\"9:00\", \"9:30\"), (\"10:30\", \"12:00\")],\n    \"Bruce\": [(\"9:00\", \"10:00\"), (\"11:00\", \"17:00\")],\n}\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration = 0.5  # half an hour\n\n# Find and print the meeting time\nprint(find_meeting_time(participant_schedules, work_hours_start, work_hours_end, duration))\n```",
            "count": "calendar_scheduling_example_562"
        },
        {
            "final_program_time": "{16:00:17:00}",
            "expected_time": "{16:00:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert schedules to minutes since midnight\n    andrew_busy = [\n        (12 * 60 + 30, 13 * 60),      # 12:30-13:00\n        (13 * 60 + 30, 15 * 60)       # 13:30-15:00\n    ]\n    \n    alexis_busy = [\n        (10 * 60 + 30, 11 * 60),      # 10:30-11:00\n        (12 * 60, 14 * 60),           # 12:00-14:00\n        (14 * 60 + 30, 16 * 60)       # 14:30-16:00\n    ]\n    \n    # Alexis's preference: not before 13:30\n    alexis_preference_start = 13 * 60 + 30\n    \n    # Meeting duration in minutes\n    duration = 60\n    \n    # Generate all possible slots within work hours, considering Alexis's preference\n    possible_slots = []\n    current_start = max(work_start, alexis_preference_start)\n    \n    while current_start + duration <= work_end:\n        # Check if the slot is free for both\n        andrew_free = all(not (start <= current_start < end or start < current_start + duration <= end) \n                          for start, end in andrew_busy)\n        alexis_free = all(not (start <= current_start < end or start < current_start + duration <= end) \n                          for start, end in alexis_busy)\n        \n        if andrew_free and alexis_free:\n            possible_slots.append((current_start, current_start + duration))\n        \n        current_start += 30  # Check in 30-minute increments\n    \n    if not possible_slots:\n        return None\n    \n    # Select the earliest possible slot\n    meeting_start, meeting_end = possible_slots[0]\n    \n    # Convert back to HH:MM format\n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n    \n    return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_563"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' schedules and preferences\n    abigail_blocked = [\n        (10 * 60, 10 * 60 + 30),  # 10:00-10:30\n        (16 * 60 + 30, 17 * 60)    # 16:30-17:00\n    ]\n    matthew_blocked = [\n        (9 * 60, 10 * 60),         # 9:00-10:00\n        (10 * 60 + 30, 11 * 60 + 30),  # 10:30-11:30\n        (13 * 60, 14 * 60),        # 13:00-14:00\n        (15 * 60 + 30, 16 * 60 + 30)   # 15:30-16:30\n    ]\n    abigail_preference_end = 13 * 60 + 30  # 13:30\n    \n    # Combine all blocked times and sort\n    all_blocked = []\n    for start, end in abigail_blocked:\n        all_blocked.append((start, end, 'Abigail'))\n    for start, end in matthew_blocked:\n        all_blocked.append((start, end, 'Matthew'))\n    all_blocked.sort()\n    \n    # Find available slots\n    available_slots = []\n    previous_end = work_start\n    \n    for start, end, _ in all_blocked:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Filter slots based on duration (30 minutes) and Abigail's preference\n    meeting_duration = 30\n    valid_slots = []\n    for start, end in available_slots:\n        if end - start >= meeting_duration:\n            # Check if the slot starts before Abigail's preference end time\n            if start + meeting_duration <= abigail_preference_end:\n                valid_slots.append((start, end))\n    \n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Format the output as HH:MM:HH:MM\n        return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    else:\n        return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_564"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Convert busy intervals to minutes\n    joe_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60 + 30)\n    ]\n    elijah_busy = [\n        (9 * 60, 13 * 60),\n        (13 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Joe's preference: not after 13:30 (13 * 60 + 30)\n    max_preferred_time = 13 * 60 + 30\n    \n    # Find all busy intervals combined for both participants\n    all_busy = joe_busy + elijah_busy\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Check the available slots before the max preferred time\n    available_slots = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Filter slots that are at least 30 minutes and before max preferred time\n    possible_slots = []\n    for slot in available_slots:\n        start, end = slot\n        if end <= max_preferred_time and (end - start) >= 30:\n            possible_slots.append(slot)\n    \n    # Select the earliest possible slot\n    if possible_slots:\n        meeting_start = possible_slots[0][0]\n        meeting_end = meeting_start + 30\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_565"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participant_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for schedule in participant_schedules:\n        for busy_start, busy_end in schedule:\n            all_busy_intervals.append((time_to_minutes(busy_start), time_to_minutes(busy_end)))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots outside merged busy intervals and within work hours\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define the schedules and constraints\nroy_schedule = [\n    (\"09:00\", \"10:30\"),\n    (\"11:30\", \"12:30\"),\n    (\"16:00\", \"16:30\")\n]\n\ndebra_schedule = [\n    (\"09:00\", \"09:30\"),\n    (\"10:00\", \"15:30\"),\n    (\"16:00\", \"17:00\")\n]\n\nparticipant_schedules = [roy_schedule, debra_schedule]\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\n# Find and print the meeting time\nprint(find_meeting_time(participant_schedules, work_hours_start, work_hours_end, duration_minutes))\n```",
            "count": "calendar_scheduling_example_566"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert busy slots to minutes\n    brandon_busy = [\n        (10 * 60, 11 * 60),      # 10:00-11:00\n        (12 * 60 + 30, 13 * 60),  # 12:30-13:00\n        (13 * 60 + 30, 14 * 60 + 30),  # 13:30-14:30\n        (15 * 60, 15 * 60 + 30)   # 15:00-15:30\n    ]\n    virginia_busy = [\n        (9 * 60, 10 * 60 + 30),   # 9:00-10:30\n        (11 * 60, 11 * 60 + 30),  # 11:00-11:30\n        (12 * 60 + 30, 13 * 60),   # 12:30-13:00\n        (13 * 60 + 30, 14 * 60),  # 13:30-14:00\n        (14 * 60 + 30, 16 * 60 + 30)  # 14:30-16:30\n    ]\n\n    # Virginia prefers no meetings after 13:00, so prioritize before 13:00\n    preferred_end = 13 * 60\n\n    # Find all possible 30-minute slots in work hours\n    possible_slots = []\n    for start in range(work_start, work_end - 30 + 1):\n        end = start + 30\n        # Check if the slot is free for both\n        brandon_free = all(not (start < busy_end and end > busy_start) for busy_start, busy_end in brandon_busy)\n        virginia_free = all(not (start < busy_end and end > busy_start) for busy_start, busy_end in virginia_busy)\n        if brandon_free and virginia_free:\n            possible_slots.append((start, end))\n\n    # Prioritize slots before 13:00\n    for slot in possible_slots:\n        if slot[1] <= preferred_end:\n            return f\"{slot[0]//60:02d}:{slot[0]%60:02d}:{slot[1]//60:02d}:{slot[1]%60:02d}\"\n\n    # If no preferred slot, return the first available\n    if possible_slots:\n        slot = possible_slots[0]\n        return f\"{slot[0]//60:02d}:{slot[0]%60:02d}:{slot[1]//60:02d}:{slot[1]%60:02d}\"\n\n    return \"No available slot\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_567"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define busy intervals in minutes since midnight\n    julia_busy = [\n        (15 * 60, 15 * 60 + 30),  # 15:00-15:30\n        (16 * 60, 16 * 60 + 30)   # 16:00-16:30\n    ]\n    pamela_busy = [\n        (11 * 60, 13 * 60 + 30),  # 11:00-13:30\n        (14 * 60 + 30, 15 * 60 + 30),  # 14:30-15:30\n        (16 * 60, 16 * 60 + 30)   # 16:00-16:30\n    ]\n\n    # Julia's preference: not after 12:30\n    julia_preference_end = 12 * 60 + 30  # 12:30 in minutes\n\n    # Combine all busy times and sort\n    all_busy = julia_busy + pamela_busy\n    all_busy.sort()\n\n    # Find free slots\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check each free slot for 30-minute availability and Julia's preference\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= 30:\n            # Check if the slot starts before Julia's preference end time\n            if slot_start + 30 <= julia_preference_end:\n                # Convert back to HH:MM format\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_hh = (slot_start + 30) // 60\n                end_mm = (slot_start + 30) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_568"
        },
        {
            "final_program_time": "{16:00:17:00}",
            "expected_time": "{16:00:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define busy intervals in minutes\n    julie_busy = [\n        (9 * 60, 9 * 60 + 30),    # 9:00-9:30\n        (12 * 60, 12 * 60 + 30),  # 12:00-12:30\n        (13 * 60 + 30, 14 * 60),  # 13:30-14:00\n        (15 * 60, 15 * 60 + 30)   # 15:00-15:30\n    ]\n    catherine_busy = [\n        (9 * 60, 10 * 60 + 30),  # 9:00-10:30\n        (13 * 60 + 30, 16 * 60)   # 13:30-16:00\n    ]\n    \n    # Julie's preference: not before 13:30\n    preferred_start = 13 * 60 + 30  # 13:30 in minutes\n    \n    # Combine and sort all busy intervals\n    all_busy = julie_busy + catherine_busy\n    all_busy.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Check for a slot that is at least 60 minutes and meets Julie's preference\n    for slot_start, slot_end in free_slots:\n        slot_start = max(slot_start, preferred_start)\n        if slot_end - slot_start >= 60:\n            meeting_start = slot_start\n            meeting_end = meeting_start + 60\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_569"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define Sophia's busy times in minutes since midnight\n    sophia_busy = [\n        (9 * 60 + 30, 12 * 60),      # 9:30 to 12:00\n        (12 * 60 + 30, 13 * 60),     # 12:30 to 13:00\n        (14 * 60 + 30, 16 * 60 + 30) # 14:30 to 16:30\n    ]\n\n    # Donna's constraint: avoid after 10:30\n    donna_constraint = 10 * 60 + 30  # 10:30 in minutes\n\n    # Meeting duration in minutes\n    duration = 30\n\n    # Find all possible slots for Sophia\n    sophia_free = []\n    prev_end = work_start\n    for start, end in sorted(sophia_busy):\n        if start > prev_end:\n            sophia_free.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        sophia_free.append((prev_end, work_end))\n\n    # Filter slots that fit duration and Donna's constraint\n    valid_slots = []\n    for start, end in sophia_free:\n        if end - start >= duration:\n            slot_start = max(start, work_start)\n            slot_end = min(end, work_end)\n            if slot_end - slot_start >= duration:\n                # Check Donna's constraint (must start before 10:30)\n                if slot_start + duration <= donna_constraint:\n                    valid_slots.append((slot_start, slot_start + duration))\n\n    if valid_slots:\n        # Select the earliest possible slot\n        best_slot = valid_slots[0]\n        # Convert minutes back to HH:MM format\n        start_h = best_slot[0] // 60\n        start_m = best_slot[0] % 60\n        end_h = (best_slot[0] + duration) // 60\n        end_m = (best_slot[0] + duration) % 60\n        return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    else:\n        return \"No valid slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_570"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert busy times to minutes since midnight\n    joseph_busy = [\n        (9 * 60, 9 * 60 + 30),   # 9:00-9:30\n        (12 * 60, 12 * 60 + 30)  # 12:00-12:30\n    ]\n    lori_busy = [\n        (9 * 60, 11 * 60),      # 9:00-11:00\n        (11 * 60 + 30, 12 * 60 + 30),  # 11:30-12:30\n        (13 * 60, 17 * 60)       # 13:00-17:00\n    ]\n    lori_max_time = 12 * 60 + 30  # Lori doesn't want to meet after 12:30\n\n    # Generate all possible slots for Joseph and Lori\n    def get_available_slots(busy_slots, max_time=None):\n        slots = []\n        prev_end = work_start\n        for start, end in sorted(busy_slots):\n            if start > prev_end:\n                slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if max_time is not None and prev_end < max_time:\n            slots.append((prev_end, max_time))\n        elif max_time is None and prev_end < work_end:\n            slots.append((prev_end, work_end))\n        return slots\n\n    joseph_slots = get_available_slots(joseph_busy)\n    lori_slots = get_available_slots(lori_busy, lori_max_time)\n\n    # Find overlapping slots\n    for js_start, js_end in joseph_slots:\n        for ls_start, ls_end in lori_slots:\n            start = max(js_start, ls_start)\n            end = min(js_end, ls_end)\n            if end - start >= meeting_duration:\n                # Convert back to HH:MM format\n                start_hh = start // 60\n                start_mm = start % 60\n                end_hh = (start + meeting_duration) // 60\n                end_mm = (start + meeting_duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_571"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define busy intervals in minutes since midnight\n    robert_busy = [\n        (10 * 60 + 30, 11 * 60),      # 10:30-11:00\n        (15 * 60, 15 * 60 + 30)        # 15:00-15:30\n    ]\n    frances_busy = [\n        (9 * 60, 9 * 60 + 30),         # 9:00-9:30\n        (11 * 60, 11 * 60 + 30),       # 11:00-11:30\n        (13 * 60, 14 * 60 + 30),       # 13:00-14:30\n        (15 * 60 + 30, 17 * 60)        # 15:30-17:00\n    ]\n    frances_preference_start = 11 * 60  # Frances doesn't want to meet before 11:00\n\n    # Combine and sort all busy intervals\n    all_busy = robert_busy + frances_busy\n    all_busy.sort()\n\n    # Find available slots\n    available_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    if work_end > previous_end:\n        available_slots.append((previous_end, work_end))\n\n    # Filter slots based on Frances' preference and duration (60 minutes)\n    meeting_duration = 60\n    valid_slots = []\n    for slot_start, slot_end in available_slots:\n        adjusted_start = max(slot_start, frances_preference_start)\n        if adjusted_start + meeting_duration <= slot_end:\n            valid_slots.append((adjusted_start, adjusted_start + meeting_duration))\n\n    # Select the first valid slot\n    if valid_slots:\n        meeting_start, meeting_end = valid_slots[0]\n        # Convert minutes back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_572"
        },
        {
            "final_program_time": "{11:00:12:00}",
            "expected_time": "{11:00:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(diana_schedule, alexis_schedule, work_hours, duration):\n    # Parse work hours\n    work_start, work_end = [int(time.split(':')[0]) for time in work_hours.split(' to ')]\n    \n    # Generate all possible slots within work hours\n    slots = []\n    for hour in range(work_start, work_end):\n        for minute in [0, 30]:\n            if hour == work_end - 1 and minute == 30:\n                continue  # Skip slots that exceed work hours\n            slots.append((hour, minute))\n    \n    # Check each slot for availability\n    for hour, minute in slots:\n        start_time = f\"{hour:02d}:{minute:02d}\"\n        end_hour = hour + duration // 60\n        end_minute = minute + duration % 60\n        if end_minute >= 60:\n            end_hour += 1\n            end_minute -= 60\n        end_time = f\"{end_hour:02d}:{end_minute:02d}\"\n        \n        # Check if the slot is free for both\n        diana_free = True  # Diana has no meetings\n        alexis_free = True\n        \n        # Check Alexis's schedule\n        for meeting in alexis_schedule:\n            m_start, m_end = meeting.split(' to ')\n            m_start_h, m_start_m = map(int, m_start.split(':'))\n            m_end_h, m_end_m = map(int, m_end.split(':'))\n            \n            # Convert times to minutes for easier comparison\n            slot_start = hour * 60 + minute\n            slot_end = end_hour * 60 + end_minute\n            meeting_start = m_start_h * 60 + m_start_m\n            meeting_end = m_end_h * 60 + m_end_m\n            \n            if not (slot_end <= meeting_start or slot_start >= meeting_end):\n                alexis_free = False\n                break\n        \n        if diana_free and alexis_free:\n            return f\"{start_time}:{end_time}\"\n    \n    return \"No available slot found\"\n\n# Given data\ndiana_schedule = []\nalexis_schedule = [\"9:00 to 11:00\", \"12:00 to 14:30\", \"15:00 to 16:30\"]\nwork_hours = \"9:00 to 17:00\"\nduration = 60  # minutes\n\n# Find meeting time\nmeeting_time = find_meeting_time(diana_schedule, alexis_schedule, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_573"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Martha's busy slots in minutes\n    martha_busy = [\n        (9 * 60 + 30, 11 * 60),    # 9:30-11:00\n        (11 * 60 + 30, 13 * 60 + 30),  # 11:30-13:30\n        (15 * 60, 15 * 60 + 30),    # 15:00-15:30\n        (16 * 60, 17 * 60)          # 16:00-17:00\n    ]\n\n    # Martha cannot meet after 11:00, so adjust work_end to 11:00\n    work_end = min(work_end, 11 * 60)\n\n    # Find all free slots for Martha within work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in sorted(martha_busy):\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_574"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define Stephanie's busy times in minutes since 9:00\n    stephanie_busy = [\n        (11 * 60, 11 * 60 + 30),  # 11:00-11:30\n        (16 * 60 + 30, 17 * 60)   # 16:30-17:00\n    ]\n    \n    # Define Samuel's busy times in minutes since 9:00\n    samuel_busy = [\n        (9 * 60, 10 * 60),        # 9:00-10:00\n        (10 * 60 + 30, 11 * 60),  # 10:30-11:00\n        (11 * 60 + 30, 12 * 60 + 30),  # 11:30-12:30\n        (13 * 60, 13 * 60 + 30),  # 13:00-13:30\n        (14 * 60, 15 * 60 + 30),  # 14:00-15:30\n        (16 * 60 + 30, 17 * 60)   # 16:30-17:00\n    ]\n    \n    # Stephanie's preference: not after 13:00\n    preference_end = 13 * 60\n    \n    # Combine and sort all busy times for both participants\n    all_busy = stephanie_busy + samuel_busy\n    all_busy.sort()\n    \n    # Find available slots before preference_end\n    current_time = work_start\n    available_slots = []\n    \n    for start, end in all_busy:\n        if start > current_time:\n            available_slots.append((current_time, start))\n        current_time = max(current_time, end)\n    \n    if current_time < preference_end:\n        available_slots.append((current_time, preference_end))\n    \n    # Check for a 30-minute slot in the available slots\n    meeting_duration = 30\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    # If no slot found (though the problem states there is one)\n    return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_575"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert schedules to minutes since start of day\n    dennis_busy = [\n        (10 * 60 + 30, 11 * 60),    # 10:30-11:00\n        (12 * 60, 12 * 60 + 30),     # 12:00-12:30\n        (14 * 60 + 30, 15 * 60 + 30) # 14:30-15:30\n    ]\n    \n    roy_busy = [\n        (9 * 60, 9 * 60 + 30),       # 9:00-9:30\n        (10 * 60, 11 * 60),          # 10:00-11:00\n        (11 * 60 + 30, 12 * 60 + 30),# 11:30-12:30\n        (13 * 60, 15 * 60),          # 13:00-15:00\n        (15 * 60 + 30, 17 * 60)      # 15:30-17:00\n    ]\n    \n    roy_no_meet_after = 12 * 60  # Roy doesn't want to meet after 12:00\n    \n    meeting_duration = 30  # minutes\n    \n    # Generate all possible slots within work hours\n    possible_slots = []\n    current_time = work_start\n    \n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 15  # Check every 15 minutes for efficiency\n    \n    # Check each slot against constraints\n    for slot in possible_slots:\n        start, end = slot\n        \n        # Check Roy's \"no meet after 12:00\" constraint\n        if start >= roy_no_meet_after:\n            continue\n        \n        # Check Dennis's availability\n        dennis_available = True\n        for busy_start, busy_end in dennis_busy:\n            if not (end <= busy_start or start >= busy_end):\n                dennis_available = False\n                break\n        \n        if not dennis_available:\n            continue\n        \n        # Check Roy's availability\n        roy_available = True\n        for busy_start, busy_end in roy_busy:\n            if not (end <= busy_start or start >= busy_end):\n                roy_available = False\n                break\n        \n        if roy_available:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = end // 60\n            end_mm = end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Execute and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_576"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert busy intervals to minutes\n    virginia_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60 + 30, 16 * 60 + 30)\n    ]\n    billy_busy = [\n        (9 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 13 * 60),\n        (15 * 60, 16 * 60)\n    ]\n\n    # Combine and sort all busy intervals\n    all_busy = virginia_busy + billy_busy\n    all_busy.sort()\n\n    # Find free intervals\n    free_intervals = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    if work_end > previous_end:\n        free_intervals.append((previous_end, work_end))\n\n    # Find the first free interval that can accommodate the meeting (60 minutes)\n    meeting_duration = 60\n    for start, end in free_intervals:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_577"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:30:14:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(bobby_schedule, doris_schedule, work_hours, duration, preference):\n    # Parse work hours\n    work_start, work_end = map(lambda x: int(x.replace(':', '')), work_hours.split(' to '))\n    \n    # Generate all possible 30-minute slots in work hours\n    slots = []\n    current = work_start\n    while current + duration * 100 <= work_end:\n        slot_end = current + duration * 100\n        slots.append((current, slot_end))\n        # Increment by 30 minutes (50 in 24-hour time format)\n        current += 30 if (current % 100) == 0 else 70\n    \n    # Filter slots based on Bobby's preference (not before 13:00)\n    preferred_slots = [slot for slot in slots if slot[0] >= 1300]\n    \n    # Check each preferred slot against both schedules\n    for slot in preferred_slots:\n        slot_start, slot_end = slot\n        bobby_free = True\n        for meeting in bobby_schedule:\n            m_start, m_end = map(lambda x: int(x.replace(':', '')), meeting.split(' to '))\n            if not (slot_end <= m_start or slot_start >= m_end):\n                bobby_free = False\n                break\n        if not bobby_free:\n            continue\n        \n        doris_free = True\n        for meeting in doris_schedule:\n            m_start, m_end = map(lambda x: int(x.replace(':', '')), meeting.split(' to '))\n            if not (slot_end <= m_start or slot_start >= m_end):\n                doris_free = False\n                break\n        if doris_free:\n            # Format the time as HH:MM:HH:MM\n            return f\"{slot_start // 100:02d}:{slot_start % 100:02d}:{slot_end // 100:02d}:{slot_end % 100:02d}\"\n    \n    # If no preferred slot found, check all slots (though problem states a solution exists)\n    for slot in slots:\n        slot_start, slot_end = slot\n        bobby_free = True\n        for meeting in bobby_schedule:\n            m_start, m_end = map(lambda x: int(x.replace(':', '')), meeting.split(' to '))\n            if not (slot_end <= m_start or slot_start >= m_end):\n                bobby_free = False\n                break\n        if not bobby_free:\n            continue\n        \n        doris_free = True\n        for meeting in doris_schedule:\n            m_start, m_end = map(lambda x: int(x.replace(':', '')), meeting.split(' to '))\n            if not (slot_end <= m_start or slot_start >= m_end):\n                doris_free = False\n                break\n        if doris_free:\n            return f\"{slot_start // 100:02d}:{slot_start % 100:02d}:{slot_end // 100:02d}:{slot_end % 100:02d}\"\n    \n    return \"No suitable time found\"\n\n# Given data\nbobby_schedule = [\"9:00 to 10:00\", \"10:30 to 12:00\", \"14:30 to 15:00\"]\ndoris_schedule = [\"10:30 to 11:00\", \"11:30 to 12:30\", \"13:00 to 13:30\", \"15:00 to 17:00\"]\nwork_hours = \"9:00 to 17:00\"\nduration = 0.5  # half an hour\npreference = \"after 13:00\"\n\n# Find and print the meeting time\nprint(find_meeting_time(bobby_schedule, doris_schedule, work_hours, duration, preference))\n```",
            "count": "calendar_scheduling_example_578"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' schedules and constraints\n    christine_busy = [\n        (11 * 60, 11 * 60 + 30),  # 11:00-11:30\n        (15 * 60, 15 * 60 + 30)    # 15:00-15:30\n    ]\n    helen_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),  # 9:30-10:30\n        (11 * 60, 11 * 60 + 30),      # 11:00-11:30\n        (12 * 60, 12 * 60 + 30),       # 12:00-12:30\n        (13 * 60 + 30, 16 * 60),       # 13:30-16:00\n        (16 * 60 + 30, 17 * 60)        # 16:30-17:00\n    ]\n    helen_no_meet_after = 15 * 60  # 15:00\n\n    # Combine and sort all busy intervals\n    all_busy = christine_busy + helen_busy\n    all_busy.sort()\n\n    # Find free slots\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check for a 30-minute slot that fits all constraints\n    meeting_duration = 30\n    for start, end in free_slots:\n        # Adjust end time based on Helen's constraint\n        adjusted_end = min(end, helen_no_meet_after)\n        if adjusted_end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_579"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Jose's busy times in minutes (10:00-11:00, 12:00-14:00, 15:00-16:00)\n    jose_busy = [\n        (10 * 60, 11 * 60),\n        (12 * 60, 14 * 60),\n        (15 * 60, 16 * 60)\n    ]\n    \n    # Jose cannot meet after 10:30 (which is 10:30 = 10*60 + 30)\n    jose_cutoff = 10 * 60 + 30\n    \n    # Adam is free all day, so only need to consider Jose's schedule\n    # Find all free slots for Jose within work hours and before 10:30\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in jose_busy:\n        if previous_end < start:\n            free_slots.append((previous_end, start))\n        previous_end = end\n    \n    # Check the time after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Filter slots that are before 10:30 and have at least 60 minutes\n    meeting_duration = 60\n    valid_slots = []\n    for start, end in free_slots:\n        # Adjust end time if it exceeds the cutoff\n        effective_end = min(end, jose_cutoff)\n        if effective_end - start >= meeting_duration:\n            valid_slots.append((start, effective_end))\n    \n    # Select the earliest possible slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Format the output as HH:MM:HH:MM\n        return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    else:\n        return \"No valid time slot found.\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_580"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_start, work_end, duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Collect all busy intervals for all participants\n    all_busy_intervals = []\n    for busy_times in participants_busy_times.values():\n        for interval in busy_times:\n            start, end = interval.split(' to ')\n            all_busy_intervals.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals_sorted = sorted(all_busy_intervals, key=lambda x: x[0])\n    \n    # Find free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    previous_end = work_start_min\n    \n    for start, end in all_busy_intervals_sorted:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end_min:\n        free_intervals.append((previous_end, work_end_min))\n    \n    # Find the first free interval that can accommodate the meeting duration\n    for start, end in free_intervals:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' busy times\nparticipants_busy_times = {\n    \"Ronald\": [\"9:30 to 10:30\", \"13:00 to 13:30\", \"15:30 to 16:00\"],\n    \"Ann\": [\"9:30 to 10:00\", \"11:00 to 12:30\", \"13:30 to 14:30\", \"15:30 to 16:30\"]\n}\n\n# Define work hours and meeting duration\nwork_start = \"9:00\"\nwork_end = \"17:00\"\nduration = 1  # in hours\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_start, work_end, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_581"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:30:17:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration, constraints):\n    # Parse work hours\n    work_start, work_end = work_hours.split(\" to \")\n    work_start = int(work_start.split(\":\")[0]) * 60 + int(work_start.split(\":\")[1])\n    work_end = int(work_end.split(\":\")[0]) * 60 + int(work_end.split(\":\")[1])\n    \n    # Initialize available slots as the entire work day\n    available_slots = [(work_start, work_end)]\n    \n    # Apply constraints\n    for constraint in constraints:\n        if constraint[\"participant\"] == \"Ann\" and constraint[\"condition\"] == \"before\":\n            constraint_time = int(constraint[\"time\"].split(\":\")[0]) * 60 + int(constraint[\"time\"].split(\":\")[1])\n            available_slots = [(max(slot[0], constraint_time), slot[1]) for slot in available_slots]\n    \n    # Process each participant's schedule to find common free times\n    for participant, schedules in participants_schedules.items():\n        busy_slots = []\n        for schedule in schedules:\n            start, end = schedule.split(\" to \")\n            start_time = int(start.split(\":\")[0]) * 60 + int(start.split(\":\")[1])\n            end_time = int(end.split(\":\")[0]) * 60 + int(end.split(\":\")[1])\n            busy_slots.append((start_time, end_time))\n        \n        # Sort busy slots\n        busy_slots.sort()\n        \n        # Subtract busy slots from available slots\n        new_available_slots = []\n        for slot in available_slots:\n            current_start = slot[0]\n            for busy_start, busy_end in busy_slots:\n                if busy_start > current_start and busy_start < slot[1]:\n                    new_available_slots.append((current_start, busy_start))\n                    current_start = busy_end\n                elif busy_start <= current_start and busy_end > current_start:\n                    current_start = busy_end\n            if current_start < slot[1]:\n                new_available_slots.append((current_start, slot[1]))\n        available_slots = new_available_slots\n    \n    # Find the first available slot that can fit the duration\n    duration_minutes = int(duration.split(\" \")[0]) * 30 if \"half\" in duration else int(duration.split(\" \")[0]) * 60\n    for slot in available_slots:\n        if slot[1] - slot[0] >= duration_minutes:\n            # Format the time as HH:MM:HH:MM\n            start_hh = slot[0] // 60\n            start_mm = slot[0] % 60\n            end_hh = (slot[0] + duration_minutes) // 60\n            end_mm = (slot[0] + duration_minutes) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No available slot found\"\n\n# Define the problem\nparticipants_schedules = {\n    \"Olivia\": [\"9:30 to 10:00\", \"10:30 to 11:00\", \"13:00 to 14:00\", \"15:30 to 16:30\"],\n    \"Ann\": [\"9:00 to 9:30\", \"11:00 to 13:00\", \"13:30 to 14:30\", \"15:00 to 15:30\"]\n}\nwork_hours = \"9:00 to 17:00\"\nduration = \"half an hour\"\nconstraints = [\n    {\"participant\": \"Ann\", \"condition\": \"before\", \"time\": \"15:00\"}\n]\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration, constraints))\n```",
            "count": "calendar_scheduling_example_582"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(lisa_busy, anthony_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n    \n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Parse busy slots\n    def parse_busy_slots(busy_slots):\n        slots = []\n        for slot in busy_slots:\n            start, end = slot.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            slots.append((start_min, end_min))\n        return slots\n    \n    lisa_slots = parse_busy_slots(lisa_busy)\n    anthony_slots = parse_busy_slots(anthony_busy)\n    \n    # Combine and sort all busy slots\n    all_busy = lisa_slots + anthony_slots\n    all_busy.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Find the earliest slot that fits the duration\n    for start, end in free_slots:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Input data\nlisa_busy = [\"9:00 to 9:30\", \"10:30 to 11:00\", \"14:00 to 16:00\"]\nanthony_busy = [\"9:00 to 9:30\", \"11:00 to 11:30\", \"12:30 to 13:30\", \"14:00 to 15:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"]\nwork_hours = \"9:00 to 17:00\"\nduration = 30  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(lisa_busy, anthony_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_583"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:13:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participant_schedules, duration, work_start, work_end):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participant_schedules:\n        for busy_start, busy_end in schedule:\n            busy_start_min = time_to_minutes(busy_start)\n            busy_end_min = time_to_minutes(busy_end)\n            busy_intervals.append((busy_start_min, busy_end_min))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start_min\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n    \n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define the participants' schedules\nemma_schedule = []  # Emma's calendar is wide open\nhenry_schedule = [(\"9:00\", \"13:00\"), (\"14:00\", \"17:00\")]\n\nparticipant_schedules = [emma_schedule, henry_schedule]\nduration = 0.5  # half an hour\nwork_start = \"9:00\"\nwork_end = \"17:00\"\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participant_schedules, duration, work_start, work_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_584"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participant_schedules, work_hours, duration):\n    # Parse work hours\n    work_start, work_end = work_hours.split(\" to \")\n    work_start = int(work_start.split(\":\")[0]) * 60 + int(work_start.split(\":\")[1])\n    work_end = int(work_end.split(\":\")[0]) * 60 + int(work_end.split(\":\")[1])\n\n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participant_schedules.values():\n        for meeting in schedule:\n            start, end = meeting.split(\" to \")\n            start_min = int(start.split(\":\")[0]) * 60 + int(start.split(\":\")[1])\n            end_min = int(end.split(\":\")[0]) * 60 + int(end.split(\":\")[1])\n            busy_intervals.append((start_min, end_min))\n\n    # Sort busy intervals by start time\n    busy_intervals.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                new_interval = (last_start, max(last_end, current_end))\n                merged[-1] = new_interval\n            else:\n                merged.append(interval)\n\n    # Find available slots\n    available_slots = []\n    previous_end = work_start\n    for interval in merged:\n        current_start, current_end = interval\n        if current_start > previous_end:\n            available_slots.append((previous_end, current_start))\n        previous_end = max(previous_end, current_end)\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n\n    # Find first available slot that can fit the meeting\n    duration_min = duration * 60\n    for slot in available_slots:\n        start, end = slot\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = start + duration_min\n            # Format the time as HH:MM\n            start_hour = meeting_start // 60\n            start_min = meeting_start % 60\n            end_hour = meeting_end // 60\n            end_min = meeting_end % 60\n            return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n    return None\n\n# Define participant schedules\nparticipant_schedules = {\n    \"Adam\": [\"9:00 to 10:30\", \"16:00 to 16:30\"],\n    \"Frank\": [\"9:30 to 10:00\", \"10:30 to 11:30\", \"12:00 to 13:30\", \"14:00 to 14:30\", \"15:30 to 16:00\"],\n}\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nduration = 1  # in hours\n\n# Find meeting time\nmeeting_time = find_meeting_time(participant_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_585"
        },
        {
            "final_program_time": "{15:00:16:00}",
            "expected_time": "{15:00:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Ralph's busy times in minutes (start, end)\n    ralph_busy = [\n        (9 * 60, 9 * 60 + 30),    # 9:00-9:30\n        (10 * 60, 11 * 60 + 30),   # 10:00-11:30\n        (12 * 60 + 30, 15 * 60),   # 12:30-15:00\n        (16 * 60, 16 * 60 + 30)    # 16:00-16:30\n    ]\n\n    # Brandon cannot meet before 15:00\n    brandon_constraint = 15 * 60  # 15:00 in minutes\n\n    # Combine all constraints (Ralph's busy times + Brandon's constraint)\n    constraints = ralph_busy + [(0, brandon_constraint)]\n\n    # Sort constraints by start time\n    constraints.sort()\n\n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n\n    for start, end in constraints:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Check for a slot that can fit the 1-hour meeting\n    meeting_duration = 60  # 1 hour\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Return the first available slot that fits\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Format as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No available time slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_586"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:9:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(zachary_busy, nicole_busy, work_hours, duration):\n    # Convert all time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # 9:00 is 0 minutes\n    \n    # Convert minutes back to time string\n    def minutes_to_time(m):\n        hh = 9 + m // 60\n        mm = m % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work = time_to_minutes(work_hours[0])\n    end_work = time_to_minutes(work_hours[1])\n    duration_min = duration * 60\n    \n    # Generate busy slots in minutes for Zachary and Nicole\n    def parse_busy_slots(busy_slots):\n        slots = []\n        for slot in busy_slots:\n            start, end = map(time_to_minutes, slot.split(' to '))\n            slots.append((start, end))\n        return slots\n    \n    zachary_slots = parse_busy_slots(zachary_busy)\n    nicole_slots = parse_busy_slots(nicole_busy)\n    \n    # Combine and sort all busy slots\n    all_busy = zachary_slots + nicole_slots\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    prev_end = start_work\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < end_work:\n        free_slots.append((prev_end, end_work))\n    \n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return (minutes_to_time(meeting_start), minutes_to_time(meeting_end))\n    \n    return None\n\n# Input data\nzachary_busy = [\n    \"9:30 to 10:00\",\n    \"11:00 to 11:30\",\n    \"13:30 to 14:30\",\n    \"15:00 to 15:30\",\n    \"16:00 to 16:30\"\n]\n\nnicole_busy = [\n    \"9:30 to 15:00\",\n    \"15:30 to 17:00\"\n]\n\nwork_hours = (\"9:00\", \"17:00\")\nduration = 0.5  # half an hour\n\n# Find meeting time\nmeeting_time = find_meeting_time(zachary_busy, nicole_busy, work_hours, duration)\n\n# Output the result in HH:MM:HH:MM format\nif meeting_time:\n    print(f\"{meeting_time[0]}:{meeting_time[1]}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_587"
        },
        {
            "final_program_time": "{15:30:16:30}",
            "expected_time": "{15:30:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(kimberly_busy, eric_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Offset by 9:00 (540 minutes)\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes  # Add back the 9:00 offset\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    # Parse work hours\n    work_start, work_end = map(time_to_minutes, work_hours.split(' to '))\n    work_end -= duration  # Last possible start time\n\n    # Parse busy slots\n    def parse_busy_slots(busy_slots):\n        slots = []\n        for slot in busy_slots:\n            start, end = map(time_to_minutes, slot.split(' to '))\n            slots.append((start, end))\n        return slots\n\n    kimberly_slots = parse_busy_slots(kimberly_busy)\n    eric_slots = parse_busy_slots(eric_busy)\n\n    # Combine and sort all busy slots\n    all_busy = kimberly_slots + eric_slots\n    all_busy.sort()\n\n    # Find the earliest available slot\n    current_start = work_start\n    for start, end in all_busy:\n        if start > current_start and start - current_start >= duration:\n            return f\"{minutes_to_time(current_start)}:{minutes_to_time(current_start + duration)}\"\n        current_start = max(current_start, end)\n    \n    # Check after last busy slot\n    if current_start <= work_end:\n        return f\"{minutes_to_time(current_start)}:{minutes_to_time(current_start + duration)}\"\n    \n    return \"No available slot\"\n\n# Input data\nkimberly_busy = [\n    \"9:00 to 9:30\",\n    \"13:30 to 14:00\",\n    \"15:00 to 15:30\",\n    \"16:30 to 17:00\"\n]\n\neric_busy = [\n    \"9:00 to 9:30\",\n    \"10:00 to 12:30\",\n    \"13:00 to 15:30\",\n    \"16:30 to 17:00\"\n]\n\nwork_hours = \"9:00 to 17:00\"\nduration = 60  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(kimberly_busy, eric_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_588"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define Laura's busy times in minutes since midnight\n    laura_busy = [\n        (11 * 60 + 30, 12 * 60 + 30),  # 11:30 - 12:30\n        (14 * 60 + 30, 15 * 60),        # 14:30 - 15:00\n        (16 * 60, 16 * 60 + 30)         # 16:00 - 16:30\n    ]\n\n    # Define Paul's busy times in minutes since midnight\n    paul_busy = [\n        (9 * 60 + 30, 10 * 60),         # 9:30 - 10:00\n        (11 * 60, 14 * 60 + 30),        # 11:00 - 14:30\n        (15 * 60, 17 * 60)              # 15:00 - 17:00\n    ]\n\n    # Paul's constraint: does not want to meet after 9:30 (so only before 9:30)\n    paul_constraint = 9 * 60 + 30  # 9:30\n\n    # Meeting duration in minutes\n    meeting_duration = 30\n\n    # Combine all busy times and sort them\n    all_busy = laura_busy + paul_busy\n    all_busy.sort()\n\n    # Find potential slots before Paul's constraint (9:30)\n    potential_start = work_start\n    potential_end = paul_constraint\n\n    # Check if there's a slot before 9:30\n    if potential_end - potential_start >= meeting_duration:\n        # Check if the slot is free for both\n        slot_free = True\n        for busy_start, busy_end in all_busy:\n            if busy_start < potential_end and busy_end > potential_start:\n                slot_free = False\n                break\n        if slot_free:\n            # Format the time as HH:MM:HH:MM\n            start_hh = potential_start // 60\n            start_mm = potential_start % 60\n            end_hh = (potential_start + meeting_duration) // 60\n            end_mm = (potential_start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    # If no slot found before 9:30, return None (though the task says a solution exists)\n    return None\n\n# Run the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_589"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(megan_schedule, emily_schedule, work_hours, duration):\n    # Parse work hours\n    work_start, work_end = [int(time.replace(':', '')) for time in work_hours.split(' to ')]\n    \n    # Convert schedules to minutes since 9:00 (540 minutes)\n    def parse_time(time_str):\n        hours, minutes = map(int, time_str.split(':'))\n        return hours * 60 + minutes\n    \n    # Generate busy slots in minutes\n    def get_busy_slots(schedule):\n        busy_slots = []\n        for slot in schedule:\n            start, end = map(parse_time, slot.split(' to '))\n            busy_slots.append((start, end))\n        return busy_slots\n    \n    megan_busy = get_busy_slots(megan_schedule)\n    emily_busy = get_busy_slots(emily_schedule)\n    \n    # Combine and sort all busy slots\n    all_busy = megan_busy + emily_busy\n    all_busy.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = parse_time('9:00')\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    # Check after last busy slot\n    if prev_end < parse_time('17:00'):\n        free_slots.append((prev_end, parse_time('17:00')))\n    \n    # Find first slot that fits the duration\n    for start, end in free_slots:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def format_time(minutes):\n                hours = minutes // 60\n                mins = minutes % 60\n                return f\"{hours:02d}:{mins:02d}\"\n            return f\"{format_time(meeting_start)}:{format_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Input data\nmegan_schedule = [\"9:30 to 10:00\", \"11:30 to 12:00\"]\nemily_schedule = [\"9:00 to 10:30\", \"11:00 to 12:00\", \"12:30 to 13:00\", \"13:30 to 14:30\", \"15:30 to 16:30\"]\nwork_hours = \"9:00 to 17:00\"\nduration = 60  # minutes\n\n# Find and print meeting time\nprint(find_meeting_time(megan_schedule, emily_schedule, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_590"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Kenneth's schedule (in minutes since midnight)\n    kenneth_busy = [\n        (9 * 60, 9 * 60 + 30),   # 9:00-9:30\n        (11 * 60, 11 * 60 + 30),  # 11:00-11:30\n        (15 * 60, 15 * 60 + 30),  # 15:00-15:30\n        (16 * 60 + 30, 17 * 60)   # 16:30-17:00\n    ]\n    # Kenneth doesn't want to meet before 13:00\n    kenneth_no_meet_before = 13 * 60  # 13:00 in minutes\n\n    # Melissa's schedule (in minutes since midnight)\n    melissa_busy = [\n        (10 * 60 + 30, 13 * 60),      # 10:30-13:00\n        (14 * 60, 14 * 60 + 30),      # 14:00-14:30\n        (15 * 60 + 30, 16 * 60 + 30)  # 15:30-16:30\n    ]\n\n    # Combine all busy times and sort\n    all_busy = []\n    for start, end in kenneth_busy:\n        all_busy.append((start, end, 'Kenneth'))\n    for start, end in melissa_busy:\n        all_busy.append((start, end, 'Melissa'))\n    all_busy.sort()\n\n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n\n    for start, end, _ in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Filter slots based on Kenneth's preference (not before 13:00)\n    filtered_slots = []\n    for start, end in available_slots:\n        if start >= kenneth_no_meet_before:\n            filtered_slots.append((start, end))\n        elif end > kenneth_no_meet_before:\n            filtered_slots.append((kenneth_no_meet_before, end))\n\n    # Find first slot that can fit the meeting\n    for start, end in filtered_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No available time slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_591"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:11:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours\n    start_work_min = time_to_minutes(start_work)\n    end_work_min = time_to_minutes(end_work)\n    duration_min = duration * 60\n    \n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy_intervals in participants_busy.values():\n        for interval in busy_intervals:\n            start, end = interval\n            all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    prev_end = start_work_min\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > prev_end:\n            free_intervals.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n    \n    if prev_end < end_work_min:\n        free_intervals.append((prev_end, end_work_min))\n    \n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define the participants' busy times and work hours\nparticipants_busy = {\n    \"Katherine\": [(\"10:00\", \"11:00\")],\n    \"Alexander\": [(\"09:00\", \"11:00\"), (\"12:00\", \"17:00\")],\n}\n\nwork_hours = (\"09:00\", \"17:00\")\nmeeting_duration = 0.5  # in hours\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_592"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Elijah's busy times and constraints (in minutes)\n    elijah_busy = [(9 * 60, 10 * 60)]  # 9:00-10:00\n    elijah_no_meet_after = 15 * 60      # 15:00\n\n    # Beverly's busy times (in minutes)\n    beverly_busy = [\n        (9 * 60, 12.5 * 60),    # 9:00-12:30\n        (13.5 * 60, 15.5 * 60), # 13:30-15:30\n        (16.5 * 60, 17 * 60)    # 16:30-17:00\n    ]\n\n    # Combine all busy intervals for both participants\n    all_busy = elijah_busy + beverly_busy\n    all_busy.sort()  # Sort by start time\n\n    # Find free slots by checking gaps between busy intervals\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Add the slot after the last busy interval if any\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check each free slot for availability and Elijah's constraint\n    for slot_start, slot_end in free_slots:\n        # Adjust slot_end to respect Elijah's no-meet-after constraint\n        effective_end = min(slot_end, elijah_no_meet_after)\n        if effective_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{int(meeting_start // 60):02d}:{int(meeting_start % 60):02d}:{int(meeting_end // 60):02d}:{int(meeting_end % 60):02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_593"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Generate all busy intervals for each participant\n    busy_intervals = []\n    for participant in participants_busy_times:\n        for interval in participant:\n            start, end = interval.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            busy_intervals.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the earliest available slot that fits the duration\n    duration = duration_minutes\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return (f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\")\n    \n    return None\n\n# Define the participants' busy times\nadam_busy = [\n    \"9:30 to 10:00\",\n    \"12:30 to 13:00\",\n    \"14:30 to 15:00\",\n    \"16:30 to 17:00\"\n]\n\nroy_busy = [\n    \"10:00 to 11:00\",\n    \"11:30 to 13:00\",\n    \"13:30 to 14:30\",\n    \"16:30 to 17:00\"\n]\n\nparticipants_busy_times = [adam_busy, roy_busy]\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_594"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Christina's busy slots in minutes\n    christina_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n\n    # Elizabeth's busy slots in minutes\n    elizabeth_busy = [\n        (9 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 15 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n\n    # Combine all busy slots for both participants\n    all_busy = christina_busy + elizabeth_busy\n    all_busy.sort()  # Sort by start time\n\n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the earliest free slot that can fit 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = (start + meeting_duration) // 60\n            end_mm = (start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_595"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Deborah's schedule and constraints\n    deborah_busy = [\n        (9 * 60, 10 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (15 * 60, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    deborah_no_meet_after = 12 * 60  # No meetings after 12:00\n    \n    # Theresa's schedule\n    theresa_busy = [\n        (9 * 60, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 17 * 60)\n    ]\n    \n    # Generate available slots for Deborah (before 12:00)\n    deborah_available = []\n    prev_end = work_start\n    for start, end in sorted(deborah_busy):\n        if start > prev_end and prev_end < deborah_no_meet_after:\n            deborah_available.append((prev_end, min(start, deborah_no_meet_after)))\n        prev_end = max(prev_end, end)\n    if prev_end < deborah_no_meet_after:\n        deborah_available.append((prev_end, deborah_no_meet_after))\n    \n    # Generate available slots for Theresa\n    theresa_available = []\n    prev_end = work_start\n    for start, end in sorted(theresa_busy):\n        if start > prev_end:\n            theresa_available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        theresa_available.append((prev_end, work_end))\n    \n    # Find overlapping slots of at least 30 minutes\n    meeting_duration = 30\n    for deb_start, deb_end in deborah_available:\n        for the_start, the_end in theresa_available:\n            start = max(deb_start, the_start)\n            end = min(deb_end, the_end)\n            if end - start >= meeting_duration:\n                # Return the first available slot\n                return f\"{start//60:02d}:{start%60:02d}:{(start+meeting_duration)//60:02d}:{(start+meeting_duration)%60:02d}\"\n    \n    return \"No meeting time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_596"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:30:14:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participant_busy_slots, work_hours_start, work_hours_end, meeting_duration):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    meeting_duration_min = meeting_duration * 60\n    \n    # Generate all busy slots for all participants in minutes\n    all_busy_slots = []\n    for busy_slots in participant_busy_slots:\n        for slot in busy_slots:\n            start, end = map(time_to_minutes, slot.split(':'))\n            all_busy_slots.append((start, end))\n    \n    # Sort all busy slots by start time\n    all_busy_slots.sort()\n    \n    # Find available slots by checking gaps between busy slots and work hours\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy_slots:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    # Check the slot after the last busy slot\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define the participants' busy slots\nroy_busy = [\"11:00:11:30\", \"12:00:12:30\", \"15:00:15:30\", \"16:30:17:00\"]\nmelissa_busy = [\"9:00:13:30\", \"14:00:15:00\", \"15:30:17:00\"]\n\n# Combine all participants' busy slots\nall_busy_slots = [roy_busy, melissa_busy]\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 0.5  # in hours\n\n# Find the meeting time\nmeeting_time = find_meeting_time(all_busy_slots, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_597"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define Sara's busy slots in minutes\n    sara_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (13 * 60, 14 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Define Randy's busy slots in minutes\n    randy_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60, 17 * 60)\n    ]\n    \n    # Sara's preference to avoid meetings after 11:00\n    sara_preference_end = 11 * 60\n    \n    # Meeting duration in minutes\n    meeting_duration = 30\n    \n    # Generate all possible slots within work hours\n    possible_slots = []\n    current_time = work_start\n    \n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 15  # Check every 15 minutes for efficiency\n    \n    # Filter slots that don't conflict with Sara's or Randy's schedule and respect Sara's preference\n    valid_slots = []\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        \n        # Check Sara's busy slots\n        sara_conflict = False\n        for busy_start, busy_end in sara_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                sara_conflict = True\n                break\n        \n        # Check Randy's busy slots\n        randy_conflict = False\n        for busy_start, busy_end in randy_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                randy_conflict = True\n                break\n        \n        # Check Sara's preference\n        sara_preference_ok = slot_start < sara_preference_end\n        \n        if not sara_conflict and not randy_conflict and sara_preference_ok:\n            valid_slots.append(slot)\n    \n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start, meeting_end = valid_slots[0]\n        # Format the output as HH:MM:HH:MM\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        print(f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\")\n    else:\n        print(\"No valid meeting time found.\")\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_598"
        },
        {
            "final_program_time": "{11:00:12:00}",
            "expected_time": "{11:00:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert busy intervals to minutes\n    judith_busy = [\n        (12 * 60, 14 * 60 + 30),  # 12:00-14:30\n        (15 * 60 + 30, 16 * 60)   # 15:30-16:00\n    ]\n    mason_busy = [\n        (9 * 60 + 30, 11 * 60),    # 9:30-11:00\n        (12 * 60 + 30, 13 * 60 + 30),  # 12:30-13:30\n        (14 * 60, 14 * 60 + 30),   # 14:00-14:30\n        (15 * 60, 15 * 60 + 30),   # 15:00-15:30\n        (16 * 60 + 30, 17 * 60)    # 16:30-17:00\n    ]\n    \n    # Combine and sort all busy intervals\n    all_busy = judith_busy + mason_busy\n    all_busy.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Find the first free slot that can accommodate the meeting (1 hour)\n    meeting_duration = 60\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_599"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_earliest_meeting_time(bruce_schedule, jessica_schedule, work_hours, duration_minutes=30):\n    # Convert work hours to minutes since midnight for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Function to parse schedule into blocked times in minutes\n    def parse_schedule(schedule):\n        blocked = []\n        for day, intervals in schedule.items():\n            for interval in intervals:\n                start_h, start_m = interval[0], interval[1]\n                end_h, end_m = interval[2], interval[3]\n                start = start_h * 60 + start_m\n                end = end_h * 60 + end_m\n                blocked.append((start, end))\n        return blocked\n    \n    # Parse both schedules\n    bruce_blocked = parse_schedule(bruce_schedule)\n    jessica_blocked = parse_schedule(jessica_schedule)\n    \n    # Combine and sort all blocked times\n    all_blocked = bruce_blocked + jessica_blocked\n    all_blocked.sort()\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in all_blocked:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Check for a slot that can fit the meeting\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            start_h = meeting_start // 60\n            start_m = meeting_start % 60\n            end_h = meeting_end // 60\n            end_m = meeting_end % 60\n            return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    \n    return None\n\n# Define schedules\nbruce_schedule = {\n    \"Monday\": [\n        (9, 30, 10, 0),\n        (11, 0, 11, 30),\n        (12, 0, 12, 30),\n        (13, 30, 14, 0),\n        (14, 30, 15, 0),\n        (16, 0, 16, 30)\n    ],\n    \"Tuesday\": [\n        (12, 0, 12, 30),\n        (13, 30, 14, 0)\n    ]\n}\n\njessica_schedule = {\n    \"Monday\": [\n        (9, 0, 17, 0)\n    ],\n    \"Tuesday\": [\n        (9, 30, 12, 30),\n        (13, 0, 17, 0)\n    ]\n}\n\n# Work hours: 9:00 to 17:00 (9*60 to 17*60 in minutes)\nwork_hours = (9, 17)\n\n# Find earliest meeting time on Monday or Tuesday\n# Check Monday first\nmonday_time = find_earliest_meeting_time(\n    {\"Monday\": bruce_schedule[\"Monday\"]},\n    {\"Monday\": jessica_schedule[\"Monday\"]},\n    work_hours\n)\n\nif monday_time:\n    print(monday_time)\nelse:\n    # Check Tuesday\n    tuesday_time = find_earliest_meeting_time(\n        {\"Tuesday\": bruce_schedule[\"Tuesday\"]},\n        {\"Tuesday\": jessica_schedule[\"Tuesday\"]},\n        work_hours\n    )\n    print(tuesday_time)\n```",
            "count": "calendar_scheduling_example_600"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to check\n    days = ['Monday', 'Tuesday']\n\n    # Mark's blocked times in minutes since midnight\n    mark_blocked = {\n        'Monday': [\n            (9 * 60, 9 * 60 + 30),    # 9:00-9:30\n            (10 * 60, 10 * 60 + 30),   # 10:00-10:30\n            (12 * 60 + 30, 13 * 60),  # 12:30-13:00\n            (16 * 60, 16 * 60 + 30),  # 16:00-16:30\n        ],\n        'Tuesday': [\n            (9 * 60, 10 * 60),        # 9:00-10:00\n            (12 * 60, 12 * 60 + 30),  # 12:00-12:30\n            (14 * 60, 14 * 60 + 30),  # 14:00-14:30\n        ]\n    }\n\n    # Marie's blocked times in minutes since midnight\n    marie_blocked = {\n        'Monday': [\n            (9 * 60 + 30, 11 * 60 + 30),  # 9:30-11:30\n            (12 * 60, 17 * 60),           # 12:00-17:00\n        ],\n        'Tuesday': [\n            (9 * 60, 17 * 60),            # 9:00-17:00\n        ]\n    }\n\n    # Iterate through each day\n    for day in days:\n        # Collect all blocked times for both participants\n        all_blocked = mark_blocked.get(day, []) + marie_blocked.get(day, [])\n        all_blocked.sort()\n\n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n\n        for start, end in all_blocked:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n\n        # Check after last blocked time\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n\n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= meeting_duration:\n                # Convert to HH:MM format\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_time = slot_start + meeting_duration\n                end_hh = end_time // 60\n                end_mm = end_time % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_601"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check (Monday and Tuesday)\n    days = ['Monday', 'Tuesday']\n    \n    # Define Anna's and Cheryl's schedules in minutes since midnight\n    # Format: {day: [(start1, end1), (start2, end2), ...]}\n    anna_schedule = {\n        'Monday': [\n            (9 * 60, 9 * 60 + 30),\n            (10 * 60, 11 * 60 + 30),\n            (12 * 60, 12 * 60 + 30),\n            (13 * 60, 13 * 60 + 30),\n            (14 * 60, 15 * 60),\n            (15 * 60 + 30, 16 * 60 + 30)\n        ],\n        'Tuesday': [\n            (9 * 60, 9 * 60 + 30),\n            (10 * 60, 10 * 60 + 30),\n            (12 * 60, 12 * 60 + 30),\n            (14 * 60 + 30, 15 * 60)\n        ]\n    }\n    \n    cheryl_schedule = {\n        'Monday': [\n            (9 * 60, 12 * 60 + 30),\n            (13 * 60, 16 * 60 + 30)\n        ],\n        'Tuesday': [\n            (9 * 60, 10 * 60),\n            (11 * 60, 13 * 60),\n            (13 * 60 + 30, 15 * 60 + 30),\n            (16 * 60, 17 * 60)\n        ]\n    }\n    \n    meeting_duration = 30  # minutes\n    \n    # Prefer Tuesday due to Cheryl's preference to avoid Monday\n    preferred_days = ['Tuesday', 'Monday']\n    \n    for day in preferred_days:\n        # Collect all busy intervals for both participants\n        busy_intervals = []\n        if day in anna_schedule:\n            busy_intervals.extend(anna_schedule[day])\n        if day in cheryl_schedule:\n            busy_intervals.extend(cheryl_schedule[day])\n        \n        # Sort busy intervals by start time\n        busy_intervals.sort()\n        \n        # Find free slots by checking gaps between busy intervals and work hours\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in busy_intervals:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy interval\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= meeting_duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_602"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to check (Monday and Tuesday)\n    days = ['Monday', 'Tuesday']\n    \n    # Define Anna's and Margaret's schedules in minutes\n    anna_schedule = {\n        'Monday': [\n            (9 * 60, 9 * 60 + 30),    # 9:00-9:30\n            (11 * 60, 12 * 60),        # 11:00-12:00\n            (14 * 60, 14 * 60 + 30),   # 14:00-14:30\n            (15 * 60, 15 * 60 + 30),   # 15:00-15:30\n        ],\n        'Tuesday': [\n            (9 * 60, 10 * 60),         # 9:00-10:00\n            (12 * 60 + 30, 13 * 60 + 30),  # 12:30-13:30\n            (16 * 60 + 30, 17 * 60),   # 16:30-17:00\n        ],\n    }\n    \n    margaret_schedule = {\n        'Monday': [\n            (9 * 60, 14 * 60),        # 9:00-14:00\n            (14 * 60 + 30, 17 * 60),   # 14:30-17:00\n        ],\n        'Tuesday': [\n            (9 * 60, 10 * 60 + 30),    # 9:00-10:30\n            (11 * 60 + 30, 12 * 60),   # 11:30-12:00\n            (12 * 60 + 30, 14 * 60 + 30),  # 12:30-14:30\n            (15 * 60 + 30, 17 * 60),    # 15:30-17:00\n        ],\n    }\n    \n    # Anna's preference: not before 14:30 on Tuesday\n    anna_preference = {\n        'Tuesday': 14 * 60 + 30  # 14:30\n    }\n    \n    meeting_duration = 60  # 1 hour\n    \n    # Iterate through each day\n    for day in days:\n        # Get busy slots for both participants\n        anna_busy = anna_schedule.get(day, [])\n        margaret_busy = margaret_schedule.get(day, [])\n        \n        # Combine and sort all busy slots\n        all_busy = anna_busy + margaret_busy\n        all_busy.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            potential_start = slot_start\n            potential_end = potential_start + meeting_duration\n            \n            # Ensure the slot can fit the meeting\n            if potential_end <= slot_end:\n                # Check Anna's preference for Tuesday\n                if day == 'Tuesday' and potential_start < anna_preference['Tuesday']:\n                    continue\n                \n                # Check if both are free\n                anna_free = True\n                for start, end in anna_busy:\n                    if not (potential_end <= start or potential_start >= end):\n                        anna_free = False\n                        break\n                \n                margaret_free = True\n                for start, end in margaret_busy:\n                    if not (potential_end <= start or potential_start >= end):\n                        margaret_free = False\n                        break\n                \n                if anna_free and margaret_free:\n                    # Convert minutes back to HH:MM format\n                    start_hh = potential_start // 60\n                    start_mm = potential_start % 60\n                    end_hh = potential_end // 60\n                    end_mm = potential_end % 60\n                    \n                    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_603"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to check\n    days = ['Monday', 'Tuesday']\n\n    # Define busy slots for each person in minutes since midnight\n    stephanie_busy = {\n        'Monday': [\n            (9 * 60 + 30, 10 * 60),    # 9:30-10:00\n            (12 * 60, 12 * 60 + 30),   # 12:00-12:30\n            (14 * 60, 15 * 60)         # 14:00-15:00\n        ],\n        'Tuesday': []\n    }\n\n    billy_busy = {\n        'Monday': [\n            (9 * 60, 17 * 60)  # 9:00-17:00 (entire day)\n        ],\n        'Tuesday': [\n            (9 * 60 + 30, 12 * 60 + 30),  # 9:30-12:30\n            (13 * 60, 17 * 60)             # 13:00-17:00\n        ]\n    }\n\n    # Billy's preference: not before 11:30 on Tuesday\n    billy_preference_start = 11 * 60 + 30  # 11:30 in minutes\n\n    # Iterate through each day\n    for day in days:\n        if day == 'Monday':\n            # Check Monday\n            # Stephanie's available slots on Monday (outside her busy times)\n            steph_available = []\n            prev_end = work_start\n            for start, end in sorted(stephanie_busy['Monday']):\n                if start > prev_end:\n                    steph_available.append((prev_end, start))\n                prev_end = end\n            if work_end > prev_end:\n                steph_available.append((prev_end, work_end))\n\n            # Billy is entirely busy on Monday, so no overlap possible\n            continue\n        elif day == 'Tuesday':\n            # Check Tuesday\n            # Stephanie's available slots on Tuesday (entire day, no busy times)\n            steph_available = [(work_start, work_end)]\n\n            # Billy's available slots on Tuesday (outside his busy times and considering preference)\n            billy_available = []\n            prev_end = work_start\n            for start, end in sorted(billy_busy['Tuesday']):\n                if start > prev_end:\n                    billy_available.append((prev_end, start))\n                prev_end = end\n            if work_end > prev_end:\n                billy_available.append((prev_end, work_end))\n\n            # Filter Billy's available slots based on preference (not before 11:30)\n            billy_available_preferred = []\n            for start, end in billy_available:\n                if start < billy_preference_start:\n                    if end > billy_preference_start:\n                        start = billy_preference_start\n                    else:\n                        continue\n                billy_available_preferred.append((start, end))\n\n            # Find overlapping slots between Stephanie and Billy (preferred)\n            for steph_start, steph_end in steph_available:\n                for billy_start, billy_end in billy_available_preferred:\n                    overlap_start = max(steph_start, billy_start)\n                    overlap_end = min(steph_end, billy_end)\n                    if overlap_end - overlap_start >= meeting_duration:\n                        # Found a suitable slot\n                        start_time = overlap_start\n                        end_time = start_time + meeting_duration\n                        # Format the output as HH:MM:HH:MM\n                        return f\"{start_time // 60:02d}:{start_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_604"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check (Monday and Tuesday)\n    days = ['Monday', 'Tuesday']\n    \n    # Define busy slots for Jesse and Kenneth in minutes since midnight\n    jesse_busy = {\n        'Monday': [(13 * 60, 13 * 60 + 30), (15 * 60 + 30, 16 * 60)],\n        'Tuesday': [(9 * 60, 9 * 60 + 30), (13 * 60, 13 * 60 + 30), \n                    (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)]\n    }\n    \n    kenneth_busy = {\n        'Monday': [(9 * 60, 10 * 60), (11 * 60 + 30, 14 * 60), \n                   (15 * 60, 15 * 60 + 30)],\n        'Tuesday': [(9 * 60, 12 * 60 + 30), (13 * 60, 14 * 60), \n                    (16 * 60, 16 * 60 + 30)]\n    }\n    \n    # Preferences\n    jesse_prefers_monday = True  # Jesse prefers to avoid Tuesday\n    kenneth_avoid_monday_after_12 = True  # Kenneth avoids Monday after 12:00\n    \n    # Iterate through days in order (Monday first)\n    for day in days:\n        if day == 'Monday' and jesse_prefers_monday:\n            pass  # Monday is preferred\n        elif day == 'Tuesday' and jesse_prefers_monday:\n            continue  # Skip Tuesday if Jesse prefers Monday\n        \n        # Get busy slots for the day\n        jesse_day_busy = jesse_busy.get(day, [])\n        kenneth_day_busy = kenneth_busy.get(day, [])\n        \n        # Combine and sort all busy slots\n        all_busy = jesse_day_busy + kenneth_day_busy\n        all_busy.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for 30-minute availability\n        for start, end in free_slots:\n            duration_needed = 30\n            if end - start >= duration_needed:\n                # Check Kenneth's Monday after 12:00 constraint\n                if day == 'Monday' and kenneth_avoid_monday_after_12:\n                    if start >= 12 * 60:\n                        continue  # Skip this slot\n                \n                # Found a valid slot\n                meeting_start = start\n                meeting_end = meeting_start + duration_needed\n                \n                # Convert back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                \n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_605"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check (Monday is 0, Tuesday is 1)\n    days = [\"Monday\", \"Tuesday\"]\n    \n    # Define busy slots for Amy and Denise in minutes since midnight\n    amy_busy = {\n        \"Monday\": [\n            (10 * 60, 11 * 60),    # 10:00-11:00\n            (12 * 60, 12 * 60 + 30), # 12:00-12:30\n            (15 * 60 + 30, 17 * 60)  # 15:30-17:00\n        ],\n        \"Tuesday\": [\n            (9 * 60, 10 * 60),       # 9:00-10:00\n            (11 * 60 + 30, 12 * 60), # 11:30-12:00\n            (13 * 60 + 30, 14 * 60), # 13:30-14:00\n            (15 * 60 + 30, 16 * 60), # 15:30-16:00\n            (16 * 60 + 30, 17 * 60)  # 16:30-17:00\n        ]\n    }\n    \n    denise_busy = {\n        \"Monday\": [\n            (9 * 60, 9 * 60 + 30),   # 9:00-9:30\n            (10 * 60, 17 * 60)       # 10:00-17:00\n        ],\n        \"Tuesday\": [\n            (9 * 60, 10 * 60 + 30), # 9:00-10:30\n            (12 * 60 + 30, 16 * 60), # 12:30-16:00\n            (16 * 60 + 30, 17 * 60)  # 16:30-17:00\n        ]\n    }\n    \n    # Duration of the meeting in minutes\n    duration = 30\n    \n    # Denise doesn't want to meet on Tuesday, so only check Monday\n    day = \"Monday\"\n    \n    # Collect all busy slots for the day\n    busy_slots = []\n    busy_slots.extend(amy_busy[day])\n    busy_slots.extend(denise_busy[day])\n    \n    # Sort busy slots by start time\n    busy_slots.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    prev_end = work_start\n    free_slots = []\n    for start, end in busy_slots:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    # Check the slot after the last busy slot\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_606"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Albert's blocked times on Tuesday (in minutes since midnight)\n    albert_tuesday_blocked = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Denise's blocked times on Monday (in minutes since midnight)\n    denise_monday_blocked = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 11 * 60 + 30),\n        (12 * 60, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Albert cannot meet on Monday after 11:00\n    albert_monday_blocked_after = 11 * 60\n    \n    # Check Monday first (Albert can only meet before 11:00)\n    monday_start = work_start\n    monday_end = albert_monday_blocked_after\n    duration = 30\n    \n    # Find available slots on Monday\n    # Albert is free before 11:00, so we check Denise's Monday blocks\n    # Generate Denise's Monday busy times before 11:00\n    denise_monday_before_11 = [(start, end) for start, end in denise_monday_blocked if end <= monday_end]\n    \n    # Find gaps in Denise's schedule on Monday before 11:00\n    denise_monday_free = []\n    prev_end = monday_start\n    for start, end in sorted(denise_monday_before_11):\n        if start > prev_end:\n            denise_monday_free.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if monday_end > prev_end:\n        denise_monday_free.append((prev_end, monday_end))\n    \n    # Check for a 30-minute slot in Denise's free times on Monday\n    for start, end in denise_monday_free:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    # If Monday doesn't work, check Tuesday\n    # Albert's and Denise's blocked times on Tuesday\n    albert_tuesday_blocked = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    denise_tuesday_blocked = [\n        (9 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 16 * 60 + 30)\n    ]\n    \n    # Combine and sort all blocked times for Tuesday\n    all_tuesday_blocked = albert_tuesday_blocked + denise_tuesday_blocked\n    all_tuesday_blocked.sort()\n    \n    # Find free slots on Tuesday\n    prev_end = work_start\n    tuesday_free = []\n    for start, end in all_tuesday_blocked:\n        if start > prev_end:\n            tuesday_free.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if work_end > prev_end:\n        tuesday_free.append((prev_end, work_end))\n    \n    # Check for a 30-minute slot in the free times\n    for start, end in tuesday_free:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_607"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define Doris's busy times in minutes since midnight\n    doris_busy = {\n        'Monday': [(9 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 11 * 60), (11 * 60 + 30, 17 * 60)]\n    }\n    \n    # Jessica prefers to avoid Monday, so prioritize Tuesday\n    days = ['Tuesday', 'Monday']\n    \n    meeting_duration = 30  # minutes\n    \n    for day in days:\n        # Get Doris's busy times for the day\n        busy_times = doris_busy.get(day, [])\n        \n        # Generate free slots for Doris\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in sorted(busy_times):\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for availability\n        for start, end in free_slots:\n            slot_duration = end - start\n            if slot_duration >= meeting_duration:\n                meeting_start = start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_608"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert schedules to minutes since midnight for easier comparison\n    emily_schedule = {\n        \"Monday\": [\n            (10 * 60 + 30, 11 * 60),    # 10:30-11:00\n            (11 * 60 + 30, 12 * 60),    # 11:30-12:00\n            (13 * 60 + 30, 14 * 60),    # 13:30-14:00\n            (14 * 60 + 30, 15 * 60),    # 14:30-15:00\n            (16 * 60, 17 * 60)          # 16:00-17:00\n        ],\n        \"Tuesday\": [\n            (9 * 60 + 30, 10 * 60),     # 9:30-10:00\n            (11 * 60, 12 * 60),         # 11:00-12:00\n            (16 * 60 + 30, 17 * 60)     # 16:30-17:00\n        ]\n    }\n    \n    zachary_schedule = {\n        \"Monday\": [\n            (9 * 60, 11 * 60),          # 9:00-11:00\n            (11 * 60 + 30, 14 * 60 + 30), # 11:30-14:30\n            (15 * 60, 17 * 60)          # 15:00-17:00\n        ],\n        \"Tuesday\": [\n            (9 * 60, 13 * 60),          # 9:00-13:00\n            (13 * 60 + 30, 14 * 60 + 30), # 13:30-14:30\n            (15 * 60, 15 * 60 + 30),    # 15:00-15:30\n            (16 * 60, 16 * 60 + 30)      # 16:00-16:30\n        ]\n    }\n    \n    # Check Monday first (Zachary's preference)\n    day = \"Monday\"\n    emily_busy = emily_schedule[day]\n    zachary_busy = zachary_schedule[day]\n    \n    # Combine and sort all busy intervals\n    all_busy = emily_busy + zachary_busy\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy intervals\n    prev_end = work_start\n    free_slots = []\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Check for a 30-minute slot\n    for start, end in free_slots:\n        if end - start >= 30:\n            # Found a suitable slot\n            meeting_start = start\n            meeting_end = meeting_start + 30\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    # If Monday doesn't work, check Tuesday (though Zachary prefers not to)\n    day = \"Tuesday\"\n    emily_busy = emily_schedule[day]\n    zachary_busy = zachary_schedule[day]\n    \n    all_busy = emily_busy + zachary_busy\n    all_busy.sort()\n    \n    prev_end = work_start\n    free_slots = []\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    for start, end in free_slots:\n        if end - start >= 30:\n            meeting_start = start\n            meeting_end = meeting_start + 30\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_609"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check (Monday is 0, Tuesday is 1)\n    days = [\"Monday\", \"Tuesday\"]\n    \n    # Patrick's busy slots in minutes since midnight\n    patrick_busy = {\n        \"Monday\": [(11 * 60, 11 * 60 + 30), (15 * 60, 16 * 60)],\n        \"Tuesday\": [(9 * 60 + 30, 10 * 60), (11 * 60, 11 * 60 + 30), (12 * 60 + 30, 13 * 60), (16 * 60, 17 * 60)]\n    }\n    \n    # Richard's busy slots in minutes since midnight\n    richard_busy = {\n        \"Monday\": [(9 * 60, 10 * 60), (11 * 60, 11 * 60 + 30), (12 * 60 + 30, 14 * 60), (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        \"Tuesday\": [(9 * 60, 9 * 60 + 30), (10 * 60, 11 * 60), (11 * 60 + 30, 13 * 60 + 30), (14 * 60, 15 * 60), (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)]\n    }\n    \n    meeting_duration = 30  # minutes\n    \n    # Patrick cannot meet on Monday, so only check Tuesday\n    day = \"Tuesday\"\n    \n    # Richard prefers not to meet after 14:00 on Tuesday, so adjust work_end\n    adjusted_work_end = 14 * 60\n    \n    # Collect all busy slots for both participants on Tuesday\n    busy_slots = patrick_busy[day] + richard_busy[day]\n    busy_slots.sort()  # Sort by start time\n    \n    # Find free slots\n    previous_end = work_start\n    free_slots = []\n    \n    for start, end in busy_slots:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the remaining time after the last busy slot\n    if previous_end < adjusted_work_end:\n        free_slots.append((previous_end, adjusted_work_end))\n    \n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_610"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday']\n    \n    # Define Ann's constraints and blocked times\n    ann_blocked = {\n        'Monday': [(13 * 60 + 30, 14 * 60 + 30)],  # 13:30-14:30\n        'Tuesday': [(9 * 60, 9 * 60 + 30), (15 * 60 + 30, 16 * 60)]  # 9:00-9:30, 15:30-16:00\n    }\n    ann_no_monday_after_11 = True\n    \n    # Define Joshua's blocked times\n    joshua_blocked = {\n        'Monday': [(10 * 60, 11 * 60), (11 * 60 + 30, 12 * 60 + 30), (14 * 60, 16 * 60)],  # 10:00-11:00, 11:30-12:30, 14:00-16:00\n        'Tuesday': [(9 * 60 + 30, 10 * 60 + 30), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 14 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)]  # 9:30-10:30, 11:30-12:00, 12:30-14:30, 15:00-15:30, 16:00-17:00\n    }\n    joshua_no_tuesday = True\n    \n    meeting_duration = 30  # minutes\n    \n    # Iterate through each day\n    for day in days:\n        if day == 'Monday' and ann_no_monday_after_11:\n            # Ann doesn't want to meet on Monday after 11:00, so adjust work_end for Monday\n            day_work_end = 11 * 60\n        else:\n            day_work_end = work_end\n        \n        if day == 'Tuesday' and joshua_no_tuesday:\n            continue  # Skip Tuesday if Joshua doesn't want to meet\n        \n        # Combine all blocked times for the day\n        blocked_times = []\n        \n        # Add Ann's blocked times\n        if day in ann_blocked:\n            blocked_times.extend(ann_blocked[day])\n        \n        # Add Joshua's blocked times\n        if day in joshua_blocked:\n            blocked_times.extend(joshua_blocked[day])\n        \n        # Sort blocked times by start time\n        blocked_times.sort()\n        \n        # Find available slots\n        available_slots = []\n        prev_end = work_start\n        \n        for start, end in blocked_times:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after last blocked time\n        if prev_end < day_work_end:\n            available_slots.append((prev_end, day_work_end))\n        \n        # Check each available slot for a meeting duration\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= meeting_duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_611"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday']\n    \n    # Define busy slots for Joshua and Diane in minutes since midnight\n    joshua_busy = {\n        'Monday': [(11 * 60 + 30, 12 * 60)],  # 11:30-12:00\n        'Tuesday': [\n            (9 * 60, 9 * 60 + 30),    # 9:00-9:30\n            (14 * 60, 14 * 60 + 30),  # 14:00-14:30\n            (16 * 60, 16 * 60 + 30)   # 16:00-16:30\n        ]\n    }\n    \n    diane_busy = {\n        'Monday': [\n            (9 * 60 + 30, 10 * 60 + 30),  # 9:30-10:30\n            (11 * 60, 14 * 60),           # 11:00-14:00\n            (15 * 60, 16 * 60 + 30)       # 15:00-16:30\n        ],\n        'Tuesday': [\n            (9 * 60, 10 * 60),            # 9:00-10:00\n            (10 * 60 + 30, 11 * 60),      # 10:30-11:00\n            (11 * 60 + 30, 12 * 60),     # 11:30-12:00\n            (13 * 60, 14 * 60 + 30),      # 13:00-14:30\n            (15 * 60 + 30, 16 * 60 + 30) # 15:30-16:30\n        ]\n    }\n    \n    # Check each day for the earliest available 30-minute slot\n    for day in days:\n        # Combine and sort all busy slots for both participants\n        busy_slots = joshua_busy.get(day, []) + diane_busy.get(day, [])\n        busy_slots.sort()\n        \n        # Merge overlapping or adjacent busy slots\n        merged_busy = []\n        for start, end in busy_slots:\n            if not merged_busy:\n                merged_busy.append((start, end))\n            else:\n                last_start, last_end = merged_busy[-1]\n                if start <= last_end:\n                    new_end = max(end, last_end)\n                    merged_busy[-1] = (last_start, new_end)\n                else:\n                    merged_busy.append((start, end))\n        \n        # Check the time before the first busy slot\n        if not merged_busy:\n            # No busy slots, the entire day is free\n            return f\"{minutes_to_time(work_start)}:{minutes_to_time(work_start + 30)}\"\n        \n        first_start, first_end = merged_busy[0]\n        if work_start < first_start:\n            available_start = work_start\n            available_end = first_start\n            if available_end - available_start >= 30:\n                return f\"{minutes_to_time(available_start)}:{minutes_to_time(available_start + 30)}\"\n        \n        # Check between busy slots\n        for i in range(1, len(merged_busy)):\n            prev_end = merged_busy[i-1][1]\n            curr_start = merged_busy[i][0]\n            if curr_start - prev_end >= 30:\n                return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + 30)}\"\n        \n        # Check after the last busy slot\n        last_start, last_end = merged_busy[-1]\n        if last_end < work_end:\n            available_start = last_end\n            available_end = work_end\n            if available_end - available_start >= 30:\n                return f\"{minutes_to_time(available_start)}:{minutes_to_time(available_start + 30)}\"\n    \n    return \"No time found\"  # Shouldn't happen as per the problem statement\n\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_612"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Define the days to check\n    days = ['Monday', 'Tuesday']\n\n    # Define schedules for each person for each day\n    schedules = {\n        'Sharon': {\n            'Monday': [(10 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60), (13 * 60, 15 * 60)],\n            'Tuesday': [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60), (14 * 60, 14 * 60 + 30), (16 * 60, 17 * 60)]\n        },\n        'Logan': {\n            'Monday': [(9 * 60, 9 * 60 + 30), (10 * 60, 12 * 60), (12 * 60 + 30, 14 * 60 + 30), (15 * 60 + 30, 17 * 60)],\n            'Tuesday': [(9 * 60, 14 * 60 + 30), (15 * 60 + 30, 17 * 60)]\n        }\n    }\n\n    # Iterate through each day\n    for day in days:\n        # Collect all busy intervals for both participants\n        busy_intervals = []\n        for person in schedules:\n            busy_intervals.extend(schedules[person][day])\n        \n        # Sort the busy intervals by start time\n        busy_intervals.sort()\n\n        # Find free intervals by checking gaps between busy intervals\n        free_intervals = []\n        prev_end = work_start\n\n        for start, end in busy_intervals:\n            if start > prev_end:\n                free_intervals.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check the interval after the last busy interval\n        if prev_end < work_end:\n            free_intervals.append((prev_end, work_end))\n\n        # Check each free interval for availability\n        for start, end in free_intervals:\n            if end - start >= meeting_duration:\n                # Convert minutes back to HH:MM format\n                start_hh = start // 60\n                start_mm = start % 60\n                end_hh = (start + meeting_duration) // 60\n                end_mm = (start + meeting_duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_613"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define the days to check\n    days = ['Monday', 'Tuesday']\n    \n    # Define blocked times for each person in minutes since midnight\n    ralph_blocked = {\n        'Monday': [\n            (9 * 60, 9 * 60 + 30),    # 9:00-9:30\n            (10 * 60 + 30, 11 * 60),   # 10:30-11:00\n            (11 * 60 + 30, 12 * 60),   # 11:30-12:00\n            (13 * 60, 13 * 60 + 30),  # 13:00-13:30\n            (14 * 60 + 30, 15 * 60),   # 14:30-15:00\n            (16 * 60, 17 * 60)         # 16:00-17:00\n        ],\n        'Tuesday': [\n            (10 * 60, 11 * 60),       # 10:00-11:00\n            (13 * 60 + 30, 15 * 60)    # 13:30-15:00\n        ]\n    }\n    \n    patricia_blocked = {\n        'Monday': [\n            (9 * 60, 11 * 60 + 30),   # 9:00-11:30\n            (12 * 60, 14 * 60),       # 12:00-14:00\n            (14 * 60 + 30, 16 * 60)   # 14:30-16:00\n        ],\n        'Tuesday': [\n            (10 * 60 + 30, 12 * 60),  # 10:30-12:00\n            (13 * 60 + 30, 15 * 60),   # 13:30-15:00\n            (16 * 60, 17 * 60)         # 16:00-17:00\n        ]\n    }\n    \n    # Function to find available slots for a person on a given day\n    def get_available_slots(blocked, day):\n        slots = []\n        blocked_times = blocked.get(day, [])\n        blocked_times.sort()  # Ensure blocked times are in order\n        \n        prev_end = work_start\n        for start, end in blocked_times:\n            if start > prev_end:\n                slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            slots.append((prev_end, work_end))\n        return slots\n    \n    # Check each day for overlapping available slots\n    for day in days:\n        ralph_slots = get_available_slots(ralph_blocked, day)\n        patricia_slots = get_available_slots(patricia_blocked, day)\n        \n        # Find overlapping slots between Ralph and Patricia\n        for r_start, r_end in ralph_slots:\n            for p_start, p_end in patricia_slots:\n                overlap_start = max(r_start, p_start)\n                overlap_end = min(r_end, p_end)\n                if overlap_end - overlap_start >= 30:  # Meeting duration is 30 minutes\n                    # Convert minutes back to HH:MM format\n                    start_hh = overlap_start // 60\n                    start_mm = overlap_start % 60\n                    end_hh = (overlap_start + 30) // 60\n                    end_mm = (overlap_start + 30) % 60\n                    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_614"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define blocked times for Raymond and Gerald on Monday and Tuesday\n    # Format: (day, start, end) where day is 0 for Monday, 1 for Tuesday\n    raymond_blocked = [\n        (0, 9 * 60, 10 * 60),    # Monday 9:00-10:00\n        (0, 12 * 60, 12 * 60 + 30),  # Monday 12:00-12:30\n        (0, 13 * 60 + 30, 14 * 60 + 30),  # Monday 13:30-14:30\n        (0, 16 * 60, 16 * 60 + 30),  # Monday 16:00-16:30\n        (1, 9 * 60, 10 * 60 + 30),  # Tuesday 9:00-10:30\n        (1, 13 * 60 + 30, 14 * 60 + 30),  # Tuesday 13:30-14:30\n        (1, 16 * 60, 16 * 60 + 30),  # Tuesday 16:00-16:30\n    ]\n    \n    gerald_blocked = [\n        (0, 9 * 60, 10 * 60 + 30),  # Monday 9:00-10:30\n        (0, 11 * 60, 14 * 60),      # Monday 11:00-14:00\n        (0, 14 * 60 + 30, 15 * 60), # Monday 14:30-15:00\n        (0, 15 * 60 + 30, 17 * 60), # Monday 15:30-17:00\n        (1, 9 * 60, 10 * 60 + 30), # Tuesday 9:00-10:30\n        (1, 11 * 60, 13 * 60),     # Tuesday 11:00-13:00\n        (1, 13 * 60 + 30, 14 * 60 + 30),  # Tuesday 13:30-14:30\n        (1, 15 * 60, 17 * 60),      # Tuesday 15:00-17:00\n    ]\n\n    # Prefer Monday (day 0) over Tuesday (day 1) due to Raymond's preference\n    days_to_check = [0, 1]\n\n    for day in days_to_check:\n        # Generate all possible slots for the day\n        slots = []\n        current_time = work_start\n        while current_time + meeting_duration <= work_end:\n            slots.append((current_time, current_time + meeting_duration))\n            current_time += 1  # Check every minute for availability\n\n        # Check each slot for availability\n        for slot_start, slot_end in slots:\n            # Check Raymond's availability\n            raymond_available = True\n            for blocked_day, blocked_start, blocked_end in raymond_blocked:\n                if blocked_day == day and not (slot_end <= blocked_start or slot_start >= blocked_end):\n                    raymond_available = False\n                    break\n            \n            if not raymond_available:\n                continue\n\n            # Check Gerald's availability\n            gerald_available = True\n            for blocked_day, blocked_start, blocked_end in gerald_blocked:\n                if blocked_day == day and not (slot_end <= blocked_start or slot_start >= blocked_end):\n                    gerald_available = False\n                    break\n            \n            if gerald_available:\n                # Convert minutes back to HH:MM format\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_hh = slot_end // 60\n                end_mm = slot_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No available time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_615"
        }
    ]
}