{
    "0shot": [
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert all time strings to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = map(time_to_minutes, work_hours.split(' to '))\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules.values():\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability of all participants\n    for interval in free_intervals:\n        start, end = interval\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = {\n    \"Michelle\": [\"11:00 to 12:00\"],\n    \"Steven\": [\"9:00 to 9:30\", \"11:30 to 12:00\", \"13:30 to 14:00\", \"15:30 to 16:00\"],\n    \"Jerry\": [\"9:00 to 9:30\", \"10:00 to 11:00\", \"11:30 to 12:30\", \"13:00 to 14:30\", \"15:30 to 16:00\", \"16:30 to 17:00\"]\n}\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nmeeting_duration = 60  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, meeting_duration))\n```",
            "count": "calendar_scheduling_example_0"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each participant's busy slots to minutes\n    raymond_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    billy_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (12 * 60, 13 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    donald_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 11 * 60),\n        (12 * 60, 13 * 60),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n\n    # Billy's preference: avoid after 15:00\n    billy_preference_end = 15 * 60\n\n    # Generate all possible slots\n    possible_slots = []\n    current_time = work_start\n\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        # Check if the slot is free for all and respects Billy's preference\n        raymond_free = all(not (start <= current_time < end or start < slot_end <= end) for start, end in raymond_busy)\n        billy_free = all(not (start <= current_time < end or start < slot_end <= end) for start, end in billy_busy)\n        donald_free = all(not (start <= current_time < end or start < slot_end <= end) for start, end in donald_busy)\n        billy_preference_ok = slot_end <= billy_preference_end\n\n        if raymond_free and billy_free and donald_free and billy_preference_ok:\n            possible_slots.append((current_time, slot_end))\n        \n        current_time += 30  # Check in 30-minute increments\n\n    # Select the first available slot\n    if possible_slots:\n        start, end = possible_slots[0]\n        # Convert back to HH:MM format\n        start_hh = start // 60\n        start_mm = start % 60\n        end_hh = end // 60\n        end_mm = end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_1"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define each person's busy slots in minutes since midnight\n    roy_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60)\n    ]\n    \n    kathryn_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    amy_busy = [\n        (9 * 60, 14 * 60 + 30),\n        (15 * 60, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Amy's preference: not after 15:30\n    amy_preference_end = 15 * 60 + 30\n    \n    # Generate all possible slots within work hours\n    possible_slots = []\n    current_time = work_start\n    \n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 15  # check every 15 minutes for efficiency\n    \n    # Check each slot against everyone's schedule and Amy's preference\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        \n        # Check Amy's preference\n        if slot_start >= amy_preference_end:\n            continue\n        \n        # Check Roy's availability\n        roy_available = True\n        for busy_start, busy_end in roy_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                roy_available = False\n                break\n        if not roy_available:\n            continue\n        \n        # Check Kathryn's availability\n        kathryn_available = True\n        for busy_start, busy_end in kathryn_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                kathryn_available = False\n                break\n        if not kathryn_available:\n            continue\n        \n        # Check Amy's availability\n        amy_available = True\n        for busy_start, busy_end in amy_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                amy_available = False\n                break\n        if not amy_available:\n            continue\n        \n        # If all checks passed, return this slot\n        return f\"{slot_start // 60:02d}:{slot_start % 60:02d}:{slot_end // 60:02d}:{slot_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_2"
        },
        {
            "final_program_time": "{9:30:10:30}",
            "expected_time": "{9:30:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Convert each person's busy slots to minutes\n    arthur_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 12 * 60),\n        (16 * 60, 17 * 60)\n    ]\n    michael_busy = [\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30)\n    ]\n    samantha_busy = [\n        (10 * 60 + 30, 11 * 60),\n        (12 * 60, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n\n    # Combine all busy slots and sort them\n    all_busy = arthur_busy + michael_busy + samantha_busy\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    prev_end = work_start\n\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        if end > prev_end:\n            prev_end = end\n\n    if work_end > prev_end:\n        free_slots.append((prev_end, work_end))\n\n    # Check each free slot for availability for all participants\n    for slot_start, slot_end in free_slots:\n        slot_duration = slot_end - slot_start\n        if slot_duration >= meeting_duration:\n            # Check if the slot is free for all\n            arthur_free = all(not (s < slot_start + meeting_duration and e > slot_start) for s, e in arthur_busy)\n            michael_free = all(not (s < slot_start + meeting_duration and e > slot_start) for s, e in michael_busy)\n            samantha_free = all(not (s < slot_start + meeting_duration and e > slot_start) for s, e in samantha_busy)\n\n            if arthur_free and michael_free and samantha_free:\n                # Convert minutes back to HH:MM format\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_hh = (slot_start + meeting_duration) // 60\n                end_mm = (slot_start + meeting_duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_3"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Parse work hours\n    start_work, end_work = work_hours\n    start_h, start_m = map(int, start_work.split(':'))\n    end_h, end_m = map(int, end_work.split(':'))\n    \n    # Convert work hours to minutes\n    work_start = start_h * 60 + start_m\n    work_end = end_h * 60 + end_m\n    \n    # Initialize busy slots for all participants\n    busy_slots = []\n    for busy in participants_busy:\n        slots = []\n        for slot in busy:\n            start, end = slot\n            s_h, s_m = map(int, start.split(':'))\n            e_h, e_m = map(int, end.split(':'))\n            slots.append((s_h * 60 + s_m, e_h * 60 + e_m))\n        busy_slots.append(slots)\n    \n    # Find all possible slots\n    possible_slots = []\n    current_time = work_start\n    while current_time + duration <= work_end:\n        slot_end = current_time + duration\n        valid = True\n        for participant in busy_slots:\n            for busy_start, busy_end in participant:\n                if not (slot_end <= busy_start or current_time >= busy_end):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            possible_slots.append((current_time, slot_end))\n        current_time += 15  # Check in 15-minute increments\n    \n    if not possible_slots:\n        return None\n    \n    # Return the first possible slot\n    start, end = possible_slots[0]\n    start_h = start // 60\n    start_m = start % 60\n    end_h = end // 60\n    end_m = end % 60\n    return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n\n# Define participants' busy times\nparticipants_busy = [\n    [(\"14:00\", \"14:30\"), (\"15:30\", \"16:00\")],  # Donna\n    [(\"11:00\", \"11:30\"), (\"16:30\", \"17:00\")],  # John\n    [(\"09:00\", \"10:00\"), (\"10:30\", \"14:00\"), (\"14:30\", \"17:00\")]  # Billy\n]\n\n# Define work hours and meeting duration\nwork_hours = (\"09:00\", \"17:00\")\nduration = 30  # minutes\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_4"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert blocked times to minutes since midnight\n    kathryn_blocked = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60 + 30, 14 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    charlotte_blocked = [\n        (12 * 60, 12 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    lauren_blocked = [\n        (9 * 60, 10 * 60),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60 + 30, 14 * 60 + 30),\n        (15 * 60, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    charlotte_no_meet_after = 13 * 60 + 30  # 13:30\n\n    # Generate all possible slots\n    possible_slots = []\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 1  # Check every minute\n\n    # Check each slot against constraints\n    for slot_start, slot_end in possible_slots:\n        # Check Charlotte's \"no meet after 13:30\" constraint\n        if slot_start >= charlotte_no_meet_after:\n            continue\n\n        # Check Kathryn's availability\n        kathryn_available = True\n        for block_start, block_end in kathryn_blocked:\n            if not (slot_end <= block_start or slot_start >= block_end):\n                kathryn_available = False\n                break\n        if not kathryn_available:\n            continue\n\n        # Check Charlotte's availability\n        charlotte_available = True\n        for block_start, block_end in charlotte_blocked:\n            if not (slot_end <= block_start or slot_start >= block_end):\n                charlotte_available = False\n                break\n        if not charlotte_available:\n            continue\n\n        # Check Lauren's availability\n        lauren_available = True\n        for block_start, block_end in lauren_blocked:\n            if not (slot_end <= block_start or slot_start >= block_end):\n                lauren_available = False\n                break\n        if not lauren_available:\n            continue\n\n        # If all checks passed, return this slot\n        return f\"{slot_start // 60:02d}:{slot_start % 60:02d}:{slot_end // 60:02d}:{slot_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_5"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration):\n    # Convert all time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 9:00 (0 minutes)\n    \n    # Convert work hours to minutes\n    work_start = time_to_minutes(work_hours[0])\n    work_end = time_to_minutes(work_hours[1])\n    \n    # Collect all busy times for all participants\n    all_busy_times = []\n    for busy_times in participants_busy_times:\n        for start, end in busy_times:\n            all_busy_times.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy times by start time\n    all_busy_times.sort()\n    \n    # Find free slots by merging all busy times\n    merged_busy = []\n    for start, end in all_busy_times:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Check the time before the first busy slot\n    if merged_busy and merged_busy[0][0] > work_start:\n        if merged_busy[0][0] - work_start >= duration:\n            return work_hours[0], minutes_to_time(work_start + duration)\n    \n    # Check the time between busy slots\n    for i in range(1, len(merged_busy)):\n        prev_end = merged_busy[i-1][1]\n        curr_start = merged_busy[i][0]\n        if curr_start - prev_end >= duration:\n            start_time = minutes_to_time(prev_end + 540)  # Add 540 to convert back to HH:MM\n            end_time = minutes_to_time(prev_end + duration + 540)\n            return start_time, end_time\n    \n    # Check the time after the last busy slot\n    if merged_busy and merged_busy[-1][1] < work_end:\n        if work_end - merged_busy[-1][1] >= duration:\n            start_time = minutes_to_time(merged_busy[-1][1] + 540)\n            end_time = minutes_to_time(merged_busy[-1][1] + duration + 540)\n            return start_time, end_time\n    \n    # If no busy times, the entire work hours are free\n    if not merged_busy and (work_end - work_start) >= duration:\n        return work_hours[0], minutes_to_time(work_start + duration + 540)\n    \n    return None\n\ndef minutes_to_time(minutes):\n    hh = (minutes) // 60\n    mm = (minutes) % 60\n    return f\"{hh:02d}:{mm:02d}\"\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 60  # minutes\n\n# Define participants' busy times in HH:MM format\nparticipants_busy_times = [\n    [],  # Thomas has no busy times\n    [(\"10:30\", \"11:00\"), (\"13:30\", \"14:00\")],  # Dylan's busy times\n    [(\"9:00\", \"11:00\"), (\"11:30\", \"14:30\"), (\"16:00\", \"17:00\")],  # Jerry's busy times\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours, duration)\n\n# Format the output as HH:MM:HH:MM\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{start}:{end}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_6"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each participant's blocked times to minutes since 9:00\n    heather_blocked = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 11 * 60),\n        (13 * 60, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    nicholas_blocked = []  # No meetings\n    zachary_blocked = [\n        (9 * 60, 10 * 60 + 30),\n        (11 * 60, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 16 * 60 + 30)\n    ]\n    zachary_preference_end = 14 * 60  # Prefers not to meet after 14:00\n\n    # Combine all blocked times for each participant\n    blocked_times = {\n        'Heather': heather_blocked,\n        'Nicholas': nicholas_blocked,\n        'Zachary': zachary_blocked\n    }\n\n    # Find all possible slots that work for everyone\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        # Check if the slot is before Zachary's preference\n        if slot_end > zachary_preference_end:\n            current_time += 1\n            continue\n        # Check if the slot is free for all participants\n        all_free = True\n        for participant, blocks in blocked_times.items():\n            for block_start, block_end in blocks:\n                if not (slot_end <= block_start or current_time >= block_end):\n                    all_free = False\n                    break\n            if not all_free:\n                break\n        if all_free:\n            # Convert back to HH:MM format\n            start_hh = current_time // 60\n            start_mm = current_time % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n        current_time += 1  # Increment by 1 minute to check next slot\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_7"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes, work_start, work_end):\n    # Convert all time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start_min\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n    \n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nadam_schedule = [\n    \"10:00 to 10:30\",\n    \"12:30 to 13:00\",\n    \"13:30 to 14:30\"\n]\n\njerry_schedule = [\n    \"09:00 to 09:30\",\n    \"12:00 to 12:30\",\n    \"15:00 to 16:00\"\n]\n\nmatthew_schedule = [\n    \"09:30 to 11:00\",\n    \"11:30 to 12:30\",\n    \"13:00 to 14:00\",\n    \"14:30 to 17:00\"\n]\n\n# Combine all schedules\nparticipants_schedules = [adam_schedule, jerry_schedule, matthew_schedule]\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, 30, \"09:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_8"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\ndiane_schedule = [\n    \"9:00 to 9:30\",\n    \"12:00 to 12:30\",\n    \"14:30 to 15:30\"\n]\n\nkelly_schedule = [\n    \"9:30 to 10:00\",\n    \"10:30 to 11:00\"\n]\n\ndeborah_schedule = [\n    \"9:00 to 9:30\",\n    \"10:00 to 14:00\",\n    \"14:30 to 17:00\"\n]\n\n# Combine all schedules\nparticipants_schedules = [diane_schedule, kelly_schedule, deborah_schedule]\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_9"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define busy slots for each participant in minutes since midnight\n    diana_busy = [(11 * 60 + 30, 12 * 60), (13 * 60, 13 * 60 + 30)]\n    ethan_busy = []  # No meetings\n    janet_busy = [(9 * 60, 10 * 60), (12 * 60 + 30, 13 * 60), (14 * 60, 15 * 60), (15 * 60 + 30, 17 * 60)]\n    janet_preference_end = 12 * 60  # Janet doesn't want to meet after 12:00\n\n    # Combine all busy slots and sort them\n    all_busy = diana_busy + ethan_busy + janet_busy\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check each free slot for availability and Janet's preference\n    for slot_start, slot_end in free_slots:\n        # Calculate the latest possible start time in this slot\n        latest_start = slot_end - meeting_duration\n        if latest_start >= slot_start:\n            # The slot can accommodate the meeting\n            actual_start = max(slot_start, latest_start)\n            actual_end = actual_start + meeting_duration\n            # Check Janet's preference (not after 12:00)\n            if actual_end <= janet_preference_end:\n                # Format the time as HH:MM:HH:MM\n                return f\"{actual_start // 60:02d}:{actual_start % 60:02d}:{actual_end // 60:02d}:{actual_end % 60:02d}\"\n\n    # If no slot found (though the problem states there is one)\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_10"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert all time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's busy slots\n    for busy_slots in participants_busy:\n        new_free_slots = []\n        for busy_start, busy_end in busy_slots:\n            busy_start_min = time_to_minutes(busy_start)\n            busy_end_min = time_to_minutes(busy_end)\n            temp_slots = []\n            for slot_start, slot_end in free_slots:\n                if busy_end_min <= slot_start or busy_start_min >= slot_end:\n                    # No overlap, keep the slot as is\n                    temp_slots.append((slot_start, slot_end))\n                else:\n                    # There is an overlap, split the slot\n                    if slot_start < busy_start_min:\n                        temp_slots.append((slot_start, busy_start_min))\n                    if slot_end > busy_end_min:\n                        temp_slots.append((busy_end_min, slot_end))\n            free_slots = temp_slots\n        if not free_slots:\n            return None  # No possible slot\n    \n    # Now find the intersection of all free slots (already done in the loop)\n    # Check if any remaining slot can fit the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return (minutes_to_time(meeting_start), minutes_to_time(meeting_end))\n    \n    return None\n\n# Define the participants' busy times\nparticipants_busy = [\n    [(\"09:30\", \"10:00\"), (\"10:30\", \"11:00\"), (\"12:30\", \"13:00\"), (\"14:30\", \"15:00\"), (\"16:00\", \"17:00\")],  # Alexander\n    [(\"09:00\", \"09:30\"), (\"11:30\", \"12:30\"), (\"13:00\", \"14:30\")],  # Elizabeth\n    [(\"09:00\", \"14:30\"), (\"15:30\", \"17:00\")]  # Walter\n]\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nmeeting_duration = 30  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, meeting_duration)\n\n# Output the result in the required format\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{start}:{end}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_11"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:14:00}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert all time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = work_hours\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start_min, work_end_min)]\n    \n    # Process each participant's schedule to find common free slots\n    for schedule in participents_schedules:\n        busy_slots = []\n        for slot in schedule:\n            start, end = map(time_to_minutes, slot.split(':'))\n            busy_slots.append((start, end))\n        # Sort the busy slots by start time\n        busy_slots.sort()\n        # Merge overlapping or adjacent busy slots\n        merged_busy = []\n        for start, end in busy_slots:\n            if not merged_busy:\n                merged_busy.append((start, end))\n            else:\n                last_start, last_end = merged_busy[-1]\n                if start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = last_start\n                    new_end = max(last_end, end)\n                    merged_busy[-1] = (new_start, new_end)\n                else:\n                    merged_busy.append((start, end))\n        # Calculate free slots for this participant\n        participant_free = []\n        prev_end = work_start_min\n        for start, end in merged_busy:\n            if start > prev_end:\n                participant_free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end_min:\n            participant_free.append((prev_end, work_end_min))\n        # Intersect with current free slots\n        new_free_slots = []\n        i = j = 0\n        while i < len(free_slots) and j < len(participant_free):\n            fs_start, fs_end = free_slots[i]\n            pf_start, pf_end = participant_free[j]\n            # Find the overlap\n            overlap_start = max(fs_start, pf_start)\n            overlap_end = min(fs_end, pf_end)\n            if overlap_start < overlap_end:\n                new_free_slots.append((overlap_start, overlap_end))\n            # Move the pointer which ends first\n            if fs_end < pf_end:\n                i += 1\n            else:\n                j += 1\n        free_slots = new_free_slots\n    \n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= duration_min:\n            meeting_end = start + duration_min\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    return \"No suitable time found\"\n\n# Define the schedules and constraints\nparticipants_schedules = [\n    [],  # David has no meetings\n    [\"09:30:10:00\", \"11:00:11:30\", \"12:00:13:00\", \"14:00:14:30\", \"16:00:16:30\"],  # Debra\n    [\"09:00:12:00\", \"14:00:17:00\"],  # Kevin\n]\nwork_hours = (\"09:00\", \"17:00\")\nduration = 1  # hour\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_12"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Gerald's busy slots in minutes (9:00-9:30, 13:00-14:00, 15:00-15:30, 16:00-17:00)\n    gerald_busy = [(9*60, 9*60 + 30), (13*60, 14*60), (15*60, 15*60 + 30), (16*60, 17*60)]\n    # Gerald prefers no meetings before 13:00\n    gerald_preferred_start = 13 * 60\n\n    # Barbara's busy slots in minutes (9:30-10:00, 11:30-14:00, 14:30-15:00, 15:30-17:00)\n    barbara_busy = [(9*60 + 30, 10*60), (11*60 + 30, 14*60), (14*60 + 30, 15*60), (15*60 + 30, 17*60)]\n\n    # Roy is free all day, so no constraints\n\n    # Generate all possible slots starting from 13:00 to 17:00 - meeting_duration\n    possible_slots = []\n    current_time = max(work_start, gerald_preferred_start)\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        # Check if the slot is free for Gerald and Barbara\n        gerald_free = True\n        for start, end in gerald_busy:\n            if not (slot_end <= start or current_time >= end):\n                gerald_free = False\n                break\n        barbara_free = True\n        for start, end in barbara_busy:\n            if not (slot_end <= start or current_time >= end):\n                barbara_free = False\n                break\n        if gerald_free and barbara_free:\n            possible_slots.append((current_time, slot_end))\n        current_time += 15  # Check every 15 minutes\n\n    # Select the first available slot\n    if possible_slots:\n        start, end = possible_slots[0]\n        # Convert back to HH:MM format\n        start_hh = start // 60\n        start_mm = start % 60\n        end_hh = end // 60\n        end_mm = end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_13"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' schedules and constraints\n    brandon_busy = [\n        (13 * 60, 14 * 60),    # 13:00-14:00\n        (15 * 60 + 30, 16 * 60),  # 15:30-16:00\n        (16 * 60 + 30, 17 * 60)   # 16:30-17:00\n    ]\n    brandon_preference_start = 14 * 60 + 30  # 14:30\n\n    jerry_busy = []  # No meetings\n\n    bradley_busy = [\n        (9 * 60, 11 * 60 + 30),  # 9:00-11:30\n        (12 * 60, 15 * 60),      # 12:00-15:00\n        (16 * 60, 16 * 60 + 30)   # 16:00-16:30\n    ]\n\n    # Combine all busy times and sort\n    all_busy = brandon_busy + bradley_busy  # Jerry has no busy times\n    all_busy.sort()\n\n    # Find available slots\n    available_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n\n    # Filter slots based on duration (30 minutes) and Brandon's preference\n    meeting_duration = 30\n    valid_slots = []\n\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration:\n            actual_start = max(slot_start, brandon_preference_start)\n            if actual_start + meeting_duration <= slot_end:\n                valid_slots.append((actual_start, actual_start + meeting_duration))\n\n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start, meeting_end = valid_slots[0]\n    else:\n        return None\n\n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n\n    start_time = minutes_to_time(meeting_start)\n    end_time = minutes_to_time(meeting_end)\n\n    return f\"{start_time}:{end_time}\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_14"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Define participants' schedules and constraints\n    joyce_busy = [\n        (11 * 60, 11 * 60 + 30),    # 11:00-11:30\n        (13 * 60 + 30, 14 * 60),    # 13:30-14:00\n        (14 * 60 + 30, 16 * 60 + 30) # 14:30-16:30\n    ]\n    christine_busy = []  # No meetings\n    christine_constraint = (12 * 60, work_end)  # Can't meet before 12:00\n    alexander_busy = [\n        (9 * 60, 11 * 60),          # 9:00-11:00\n        (12 * 60, 12 * 60 + 30),    # 12:00-12:30\n        (13 * 60 + 30, 15 * 60),    # 13:30-15:00\n        (15 * 60 + 30, 16 * 60),    # 15:30-16:00\n        (16 * 60 + 30, 17 * 60)    # 16:30-17:00\n    ]\n\n    # Meeting duration in minutes\n    duration = 30\n\n    # Generate all possible slots\n    possible_slots = []\n    current_time = work_start\n\n    while current_time + duration <= work_end:\n        slot_start = current_time\n        slot_end = current_time + duration\n\n        # Check Christine's constraint (can't meet before 12:00)\n        if slot_start < 12 * 60:\n            current_time += 15  # Check in 15-minute increments\n            continue\n\n        # Check Joyce's availability\n        joyce_available = True\n        for busy_start, busy_end in joyce_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                joyce_available = False\n                break\n\n        # Check Alexander's availability\n        alexander_available = True\n        for busy_start, busy_end in alexander_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                alexander_available = False\n                break\n\n        # If all are available, add the slot\n        if joyce_available and alexander_available:\n            possible_slots.append((slot_start, slot_end))\n\n        current_time += 15  # Check in 15-minute increments\n\n    # Select the first available slot\n    if possible_slots:\n        meeting_start, meeting_end = possible_slots[0]\n        # Convert minutes back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        print(f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\")\n    else:\n        print(\"No available time slot found.\")\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_15"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work_hours start at 9:00\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = 9 + minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split('-')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Initialize free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's schedule to find common free slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = busy.split('-')\n            busy_start = time_to_minutes(start)\n            busy_end = time_to_minutes(end)\n            busy_slots.append((busy_start, busy_end))\n        \n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Calculate free slots for this participant\n        current_free = []\n        prev_end = work_start\n        for start, end in busy_slots:\n            if start > prev_end:\n                current_free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            current_free.append((prev_end, work_end))\n        \n        # Intersect current_free with existing free_slots\n        new_free_slots = []\n        i = j = 0\n        while i < len(free_slots) and j < len(current_free):\n            start1, end1 = free_slots[i]\n            start2, end2 = current_free[j]\n            \n            # Find overlapping interval\n            start = max(start1, start2)\n            end = min(end1, end2)\n            if start < end:\n                new_free_slots.append((start, end))\n            \n            # Move the pointer which ends first\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        \n        free_slots = new_free_slots\n    \n    # Find the first slot that can fit the meeting duration\n    duration_min = duration * 60\n    for start, end in free_slots:\n        if end - start >= duration_min:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration_min)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"09:30-10:30\", \"13:30-14:00\", \"14:30-15:00\", \"15:30-16:00\", \"16:30-17:00\"],  # Scott\n    [],  # Gabriel\n    [\"09:00-10:00\", \"10:30-12:30\", \"13:00-17:00\"],  # Christine\n]\n\n# Define meeting duration in hours (0.5 hours = 30 minutes)\nduration = 0.5\nwork_hours = \"9:00-17:00\"\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_16"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Convert blocked times to minutes since midnight\n    margaret_blocked = [\n        (9 * 60, 10 * 60),    # 9:00-10:00\n        (10 * 60 + 30, 11 * 60),  # 10:30-11:00\n        (11 * 60 + 30, 12 * 60),  # 11:30-12:00\n        (13 * 60, 13 * 60 + 30),  # 13:00-13:30\n        (15 * 60, 15 * 60 + 30)   # 15:00-15:30\n    ]\n    donna_blocked = [\n        (14 * 60 + 30, 15 * 60),  # 14:30-15:00\n        (16 * 60, 16 * 60 + 30)   # 16:00-16:30\n    ]\n    helen_blocked = [\n        (9 * 60, 9 * 60 + 30),    # 9:00-9:30\n        (10 * 60, 11 * 60 + 30),  # 10:00-11:30\n        (13 * 60, 14 * 60),        # 13:00-14:00\n        (14 * 60 + 30, 15 * 60),  # 14:30-15:00\n        (15 * 60 + 30, 17 * 60)   # 15:30-17:00\n    ]\n    helen_no_meet_after = 13 * 60 + 30  # 13:30\n\n    meeting_duration = 30  # minutes\n\n    # Combine all blocked times and sort them\n    all_blocked = []\n    for start, end in margaret_blocked:\n        all_blocked.append((start, end, 'Margaret'))\n    for start, end in donna_blocked:\n        all_blocked.append((start, end, 'Donna'))\n    for start, end in helen_blocked:\n        all_blocked.append((start, end, 'Helen'))\n    all_blocked.sort()\n\n    # Find available slots\n    available_slots = []\n    current_time = work_start\n\n    for start, end, person in all_blocked:\n        if start > current_time:\n            available_slots.append((current_time, start))\n        current_time = max(current_time, end)\n    if current_time < work_end:\n        available_slots.append((current_time, work_end))\n\n    # Filter slots based on Helen's preference (before 13:30)\n    filtered_slots = []\n    for start, end in available_slots:\n        if end <= helen_no_meet_after:\n            filtered_slots.append((start, end))\n\n    # Find the first slot that fits the meeting duration\n    for start, end in filtered_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_17"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Billy's busy slots in minutes\n    billy_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    # Patricia's busy slots in minutes\n    patricia_busy = [\n        (9 * 60, 12 * 60 + 30),\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    # Billy's preference to avoid meetings after 15:30\n    billy_preference_end = 15 * 60 + 30\n\n    # Generate all possible meeting slots\n    possible_slots = []\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        # Check if the slot works for everyone\n        billy_free = all(not (start < slot_end and end > current_time) for start, end in billy_busy)\n        patricia_free = all(not (start < slot_end and end > current_time) for start, end in patricia_busy)\n        # Check Billy's preference\n        billy_preference_ok = slot_end <= billy_preference_end\n        if billy_free and patricia_free and billy_preference_ok:\n            possible_slots.append((current_time, slot_end))\n        current_time += 30  # Check every 30 minutes\n\n    # Select the first available slot\n    if possible_slots:\n        start, end = possible_slots[0]\n        # Convert minutes back to HH:MM format\n        start_hh = start // 60\n        start_mm = start % 60\n        end_hh = end // 60\n        end_mm = end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_18"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration_hours):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_hours * 60\n    \n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy_times in participants_busy_times:\n        for interval in busy_times:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Check the available slots between work hours and busy intervals\n    prev_end = work_start\n    available_slots = []\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define the participants' busy times\nstephen_busy = [\"10:00 to 10:30\", \"13:00 to 13:30\", \"14:30 to 15:00\", \"16:00 to 16:30\"]\nedward_busy = [\"9:00 to 9:30\", \"10:00 to 10:30\", \"13:30 to 14:30\", \"15:00 to 16:00\"]\nangela_busy = [\"9:00 to 11:30\", \"12:30 to 13:00\", \"13:30 to 15:30\", \"16:00 to 17:00\"]\n\n# Combine all busy times\nparticipants_busy_times = [stephen_busy, edward_busy, angela_busy]\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_hours = 1\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_19"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert each person's busy slots to minutes\n    ralph_busy = [\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60)\n    ]\n    peter_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (11 * 60, 13 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    daniel_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 15 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n    daniel_preference = 13 * 60 + 30  # Prefers no meetings after 13:30\n\n    # Combine all busy slots\n    all_busy = ralph_busy + peter_busy + daniel_busy\n    all_busy.sort()  # Sort by start time\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check each free slot for a 30-minute window that fits all constraints\n    meeting_duration = 30\n    for slot_start, slot_end in free_slots:\n        current_start = slot_start\n        while current_start + meeting_duration <= slot_end:\n            current_end = current_start + meeting_duration\n            # Check if it's before Daniel's preference (13:30)\n            if current_end <= daniel_preference:\n                return f\"{current_start // 60:02d}:{current_start % 60:02d}:{current_end // 60:02d}:{current_end % 60:02d}\"\n            current_start += 1  # Increment by 1 minute to check next possible slot\n\n    # If no slot found before preference, check after (though not preferred)\n    for slot_start, slot_end in free_slots:\n        current_start = slot_start\n        while current_start + meeting_duration <= slot_end:\n            current_end = current_start + meeting_duration\n            return f\"{current_start // 60:02d}:{current_start % 60:02d}:{current_end // 60:02d}:{current_end % 60:02d}\"\n            current_start += 1\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_20"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration):\n    # Convert all time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 (9:00)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    work_start, work_end = work_hours.split(' to ')\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Generate all busy intervals in minutes\n    all_busy = []\n    for busy_times in participants_busy_times.values():\n        for busy in busy_times:\n            start, end = busy.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            all_busy.append((start_min, end_min))\n    \n    # Sort all busy intervals\n    all_busy.sort()\n    \n    # Find free intervals\n    free_intervals = []\n    prev_end = work_start_min\n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n    \n    # Find the first free interval that can fit the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' busy times\nparticipants_busy_times = {\n    'Bobby': [],\n    'Scott': ['11:30 to 12:00', '15:30 to 16:00'],\n    'Kimberly': ['11:00 to 12:00', '12:30 to 13:00', '13:30 to 14:00', '14:30 to 15:00', '15:30 to 17:00']\n}\n\n# Define work hours and meeting duration\nwork_hours = '9:00 to 17:00'\nmeeting_duration = 60  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy_times, work_hours, meeting_duration))\n```",
            "count": "calendar_scheduling_example_21"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    duration = 60        # 1 hour in minutes\n\n    # Convert each person's busy times to minutes since midnight\n    theresa_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (12 * 60 + 30, 13 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    charles_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (14 * 60, 15 * 60 + 30)\n    ]\n    betty_busy = [\n        (9 * 60, 10 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 14 * 60),\n        (15 * 60, 16 * 60)\n    ]\n\n    # Combine all busy times into a single list\n    all_busy = theresa_busy + charles_busy + betty_busy\n\n    # Sort busy times by start time\n    all_busy.sort()\n\n    # Find the earliest available slot\n    current_time = work_start\n    for busy_start, busy_end in all_busy:\n        if busy_start > current_time:\n            if busy_start - current_time >= duration:\n                # Found a slot\n                end_time = current_time + duration\n                return f\"{current_time // 60:02d}:{current_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n        if busy_end > current_time:\n            current_time = busy_end\n\n    # Check after the last busy slot\n    if work_end - current_time >= duration:\n        end_time = current_time + duration\n        return f\"{current_time // 60:02d}:{current_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n\n    return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_22"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = work_hours\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = busy\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            busy_intervals.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start_min\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        available_slots.append((prev_end, work_end_min))\n    \n    # Check each available slot for sufficient duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [(\"11:30\", \"12:00\"), (\"13:00\", \"15:00\"), (\"16:00\", \"16:30\")],  # Billy\n    [(\"09:00\", \"09:30\"), (\"10:00\", \"10:30\"), (\"13:00\", \"13:30\"), (\"14:00\", \"14:30\")],  # Maria\n    [(\"09:30\", \"10:00\"), (\"12:00\", \"12:30\"), (\"13:30\", \"15:00\"), (\"15:30\", \"17:00\")],  # William\n]\n\n# Define work hours and meeting duration\nwork_hours = (\"09:00\", \"17:00\")\nduration = 1  # hour\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_23"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define Brenda's busy slots in minutes\n    brenda_busy = [\n        (9 * 60 + 30, 10 * 60),      # 9:30 to 10:00\n        (11 * 60 + 30, 12 * 60 + 30), # 11:30 to 12:30\n        (14 * 60, 16 * 60 + 30)       # 14:00 to 16:30\n    ]\n    \n    # Benjamin's constraint: cannot meet after 9:30\n    benjamin_constraint = 9 * 60 + 30  # 9:30 in minutes\n    \n    # Generate all possible 30-minute slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + 30 <= work_end:\n        slot_end = current_time + 30\n        # Check if the slot is before Benjamin's constraint\n        if slot_end <= benjamin_constraint:\n            # Check if Brenda is free during this slot\n            brenda_free = True\n            for busy_start, busy_end in brenda_busy:\n                if not (slot_end <= busy_start or current_time >= busy_end):\n                    brenda_free = False\n                    break\n            if brenda_free:\n                possible_slots.append((current_time, slot_end))\n        current_time += 15  # Check every 15 minutes for flexibility\n    \n    # Select the first available slot\n    if possible_slots:\n        meeting_start, meeting_end = possible_slots[0]\n        # Convert minutes back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_24"
        },
        {
            "final_program_time": "{13:30:14:30}",
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define busy intervals in minutes for each participant\n    anthony_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (12 * 60, 13 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    pamela_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    zachary_busy = [\n        (9 * 60, 11 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60, 17 * 60)\n    ]\n\n    # Pamela's constraint: no meetings after 14:30\n    pamela_no_meet_after = 14 * 60 + 30\n\n    # Meeting duration in minutes\n    duration = 60\n\n    # Generate all possible slots within work hours\n    possible_slots = []\n    current_start = work_start\n    while current_start + duration <= work_end:\n        possible_slots.append((current_start, current_start + duration))\n        current_start += 30  # Check every 30 minutes for efficiency\n\n    # Check each slot against all constraints\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n\n        # Check Pamela's time constraint\n        if slot_start >= pamela_no_meet_after:\n            continue\n\n        # Check Anthony's availability\n        anthony_available = True\n        for busy_start, busy_end in anthony_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                anthony_available = False\n                break\n        if not anthony_available:\n            continue\n\n        # Check Pamela's availability\n        pamela_available = True\n        for busy_start, busy_end in pamela_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                pamela_available = False\n                break\n        if not pamela_available:\n            continue\n\n        # Check Zachary's availability\n        zachary_available = True\n        for busy_start, busy_end in zachary_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                zachary_available = False\n                break\n        if not zachary_available:\n            continue\n\n        # If all checks passed, return this slot\n        return f\"{slot_start // 60:02d}:{slot_start % 60:02d}:{slot_end // 60:02d}:{slot_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_25"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:30:16:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(schedules, duration, work_start, work_end):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for person in schedules:\n        for interval in schedules[person]:\n            start, end = map(time_to_minutes, interval.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start_min\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        available_slots.append((prev_end, work_end_min))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define the schedules\nschedules = {\n    \"Katherine\": [],\n    \"Nicole\": [],\n    \"Kevin\": [\"9:00:10:00\", \"10:30:11:30\", \"12:00:15:30\", \"16:30:17:00\"]\n}\n\n# Find a 1-hour meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(schedules, 1, \"9:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_26"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability\n    duration_min = duration * 60\n    for start, end in free_intervals:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"10:00 to 10:30\", \"15:30 to 16:00\"],  # Jesse\n    [],                                    # Kathryn\n    [\"10:30 to 11:00\", \"11:30 to 12:30\", \"13:30 to 14:30\", \"15:00 to 16:30\"]  # Megan\n]\n\n# Define meeting parameters\nmeeting_duration = 30  # minutes\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\n\n# Find the earliest available meeting time\nmeeting_time = find_meeting_time(participants_schedules, meeting_duration, work_hours_start, work_hours_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_27"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_start=\"09:00\", work_end=\"17:00\"):\n    # Convert time strings to minutes since 00:00 for easier calculations\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Initialize the busy slots for all participants\n    busy_slots = []\n    for schedule in participants_schedules:\n        person_busy = []\n        for slot in schedule:\n            start, end = map(time_to_minutes, slot.split(' to '))\n            person_busy.append((start, end))\n        busy_slots.append(person_busy)\n    \n    # Find all possible meeting slots that fit within work hours\n    possible_slots = []\n    current_time = work_start_min\n    \n    while current_time + duration_minutes <= work_end_min:\n        slot_end = current_time + duration_minutes\n        valid = True\n        \n        # Check if the slot is free for all participants\n        for person_busy in busy_slots:\n            for start, end in person_busy:\n                if not (slot_end <= start or current_time >= end):\n                    valid = False\n                    break\n            if not valid:\n                break\n        \n        if valid:\n            possible_slots.append((current_time, slot_end))\n        \n        current_time += 15  # Check in 15-minute increments\n    \n    if not possible_slots:\n        return None\n    \n    # Find the earliest available slot\n    earliest_slot = possible_slots[0]\n    start_min, end_min = earliest_slot\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_time = minutes_to_time(start_min)\n    end_time = minutes_to_time(end_min)\n    \n    return f\"{start_time}:{end_time}\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"13:00 to 13:30\", \"16:00 to 16:30\"],  # Brittany\n    [],                                    # Emily (free all day)\n    [\"09:00 to 11:00\", \"11:30 to 14:30\", \"15:00 to 17:00\"],  # Doris\n]\n\n# Find the earliest meeting time\nmeeting_time = find_meeting_time(participants_schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_28"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:00:13:00}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    # Initialize the free slots within work hours\n    start_work = time_to_minutes(work_hours[0])\n    end_work = time_to_minutes(work_hours[1])\n    free_slots = [(start_work, end_work)]\n\n    # Function to subtract busy slots from free slots\n    def subtract_busy_slots(free_slots, busy_start, busy_end):\n        new_slots = []\n        for slot_start, slot_end in free_slots:\n            if busy_start >= slot_end or busy_end <= slot_start:\n                new_slots.append((slot_start, slot_end))\n            else:\n                if slot_start < busy_start:\n                    new_slots.append((slot_start, busy_start))\n                if slot_end > busy_end:\n                    new_slots.append((busy_end, slot_end))\n        return new_slots\n\n    # Process each participant's schedule\n    for schedule in participents_schedules:\n        for busy in schedule:\n            busy_start = time_to_minutes(busy[0])\n            busy_end = time_to_minutes(busy[1])\n            free_slots = subtract_busy_slots(free_slots, busy_start, busy_end)\n\n    # Find the first slot that can fit the duration\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No suitable time found\"\n\n# Define the participants' schedules\nmadison_schedule = [(\"09:30\", \"10:00\"), (\"11:30\", \"12:00\")]\ndiana_schedule = [(\"11:00\", \"11:30\"), (\"13:00\", \"13:30\")]\nshirley_schedule = [(\"09:00\", \"12:00\"), (\"13:30\", \"15:00\"), (\"15:30\", \"17:00\")]\n\nparticipants_schedules = [madison_schedule, diana_schedule, shirley_schedule]\nwork_hours = (\"09:00\", \"17:00\")\nduration = 60  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_29"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy times in minutes since midnight\n    jeffrey_busy = [\n        (9 * 60 + 30, 10 * 60),    # 9:30-10:00\n        (10 * 60 + 30, 11 * 60)    # 10:30-11:00\n    ]\n    \n    virginia_busy = [\n        (9 * 60, 9 * 60 + 30),     # 9:00-9:30\n        (10 * 60, 10 * 60 + 30),   # 10:00-10:30\n        (14 * 60 + 30, 15 * 60),   # 14:30-15:00\n        (16 * 60, 16 * 60 + 30)    # 16:00-16:30\n    ]\n    \n    melissa_busy = [\n        (9 * 60, 11 * 60 + 30),    # 9:00-11:30\n        (12 * 60, 12 * 60 + 30),   # 12:00-12:30\n        (13 * 60, 15 * 60),        # 13:00-15:00\n        (16 * 60, 17 * 60)         # 16:00-17:00\n    ]\n    \n    # Melissa's preference: not after 14:00\n    preference_end = 14 * 60\n    \n    # Meeting duration in minutes\n    duration = 30\n    \n    # Generate all possible slots within work hours, considering Melissa's preference\n    possible_slots = []\n    current_time = work_start\n    \n    while current_time + duration <= min(work_end, preference_end):\n        # Check if the slot is free for all participants\n        jeffrey_free = all(not (start <= current_time < end or start < current_time + duration <= end) \n                           for start, end in jeffrey_busy)\n        virginia_free = all(not (start <= current_time < end or start < current_time + duration <= end) \n                           for start, end in virginia_busy)\n        melissa_free = all(not (start <= current_time < end or start < current_time + duration <= end) \n                          for start, end in melissa_busy)\n        \n        if jeffrey_free and virginia_free and melissa_free:\n            possible_slots.append((current_time, current_time + duration))\n        \n        current_time += 15  # Check every 15 minutes for efficiency\n    \n    # Select the first available slot\n    if possible_slots:\n        start, end = possible_slots[0]\n        # Convert minutes back to HH:MM format\n        start_hh = start // 60\n        start_mm = start % 60\n        end_hh = end // 60\n        end_mm = end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_30"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each participant's busy times to minutes since midnight\n    richard_busy = [\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    martha_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (13 * 60, 13 * 60 + 30)\n    ]\n    kimberly_busy = [\n        (9 * 60, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60, 16 * 60)\n    ]\n\n    # Martha's preference: not before 14:00\n    martha_preference_start = 14 * 60\n\n    # Combine all busy times and sort\n    all_busy = []\n    for start, end in richard_busy:\n        all_busy.append((start, end, 'Richard'))\n    for start, end in martha_busy:\n        all_busy.append((start, end, 'Martha'))\n    for start, end in kimberly_busy:\n        all_busy.append((start, end, 'Kimberly'))\n    all_busy.sort()\n\n    # Find available slots\n    available_slots = []\n    current_time = max(work_start, martha_preference_start)\n\n    while current_time + meeting_duration <= work_end:\n        conflict = False\n        for busy_start, busy_end, person in all_busy:\n            if not (current_time + meeting_duration <= busy_start or current_time >= busy_end):\n                conflict = True\n                current_time = busy_end\n                break\n        if not conflict:\n            available_slots.append((current_time, current_time + meeting_duration))\n            current_time += meeting_duration\n\n    # Return the first available slot\n    if available_slots:\n        start, end = available_slots[0]\n        start_hr = start // 60\n        start_min = start % 60\n        end_hr = end // 60\n        end_min = end % 60\n        return f\"{start_hr:02d}:{start_min:02d}:{end_hr:02d}:{end_min:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_31"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' busy times in minutes since midnight\n    emily_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    melissa_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (14 * 60 + 30, 15 * 60)\n    ]\n    frank_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60 + 30),\n        (15 * 60, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    # Frank's constraint: doesn't want to meet after 9:30 (but his busy times already reflect this)\n    # Meeting duration is 30 minutes\n    duration = 30\n\n    # Combine all busy times and sort them\n    all_busy = emily_busy + melissa_busy + frank_busy\n    all_busy.sort()\n\n    # Find the earliest available slot\n    previous_end = work_start\n    for start, end in all_busy:\n        if start > previous_end and (start - previous_end) >= duration:\n            # Check if the slot is before Frank's constraint (before or at 9:30)\n            if previous_end <= 9 * 60 + 30 - duration:\n                return format_time(previous_end, previous_end + duration)\n        previous_end = max(previous_end, end)\n    \n    # Check after the last busy slot\n    if work_end - previous_end >= duration and previous_end <= 9 * 60 + 30 - duration:\n        return format_time(previous_end, previous_end + duration)\n    \n    # If no slot found (though the problem states there is one)\n    return \"No time found\"\n\ndef format_time(start_min, end_min):\n    start_h = start_min // 60\n    start_m = start_min % 60\n    end_h = end_min // 60\n    end_m = end_min % 60\n    return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n\n# Execute and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_32"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define each person's busy times in minutes (start, end)\n    lisa_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    bobby_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    randy_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n\n    # Bobby's preference: avoid after 15:00\n    bobby_preference_end = 15 * 60\n\n    # Combine all busy times and sort them\n    all_busy = lisa_busy + bobby_busy + randy_busy\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Add the slot after the last busy time if within work hours\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Filter free slots that are at least 30 minutes and respect Bobby's preference\n    meeting_duration = 30\n    valid_slots = []\n\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Check if the slot is entirely before Bobby's preference end time\n            if end <= bobby_preference_end:\n                valid_slots.append((start, end))\n            # Or if the slot starts early enough to fit the meeting before preference\n            elif start <= bobby_preference_end - meeting_duration:\n                valid_slots.append((start, min(end, bobby_preference_end)))\n\n    # Find the earliest valid slot\n    if valid_slots:\n        earliest_slot = min(valid_slots)\n        meeting_start = earliest_slot[0]\n        meeting_end = meeting_start + meeting_duration\n    else:\n        # If no slot before preference, check all free slots (though problem states a solution exists)\n        for start, end in free_slots:\n            if end - start >= meeting_duration:\n                meeting_start = start\n                meeting_end = start + meeting_duration\n                break\n\n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n\n    start_time = minutes_to_time(meeting_start)\n    end_time = minutes_to_time(meeting_end)\n\n    return f\"{start_time}:{end_time}\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_33"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert all time strings to minutes since start of the day\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Initialize the free time slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Function to subtract busy slots from free slots\n    def subtract_busy(free_slots, busy_start, busy_end):\n        new_slots = []\n        for start, end in free_slots:\n            if busy_end <= start or busy_start >= end:\n                new_slots.append((start, end))\n            else:\n                if start < busy_start:\n                    new_slots.append((start, busy_start))\n                if end > busy_end:\n                    new_slots.append((busy_end, end))\n        return new_slots\n    \n    # Process each participant's busy slots\n    for busy_slots in participants_busy:\n        for busy in busy_slots:\n            busy_start, busy_end = map(time_to_minutes, busy.split(' to '))\n            free_slots = subtract_busy(free_slots, busy_start, busy_end)\n    \n    # Find the first free slot that can accommodate the meeting\n    duration_min = duration * 60\n    for start, end in free_slots:\n        if end - start >= duration_min:\n            meeting_end = start + duration_min\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' busy slots\nparticipants_busy = [\n    [\"10:00 to 10:30\", \"11:00 to 12:00\", \"13:00 to 14:00\", \"16:00 to 16:30\"],  # Richard\n    [\"10:00 to 10:30\", \"11:30 to 13:00\", \"13:30 to 14:00\", \"14:30 to 17:00\"],  # Noah\n]\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nduration = 1  # hour\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_34"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' schedules and constraints in minutes\n    # Bradley: free all day but doesn't want to meet before 14:30\n    bradley_constraint = 14 * 60 + 30  # 14:30 in minutes\n    \n    # Zachary's meetings\n    zachary_busy = [\n        (10 * 60, 10 * 60 + 30),   # 10:00-10:30\n        (15 * 60, 15 * 60 + 30)     # 15:00-15:30\n    ]\n    \n    # Teresa's blocked times\n    teresa_busy = [\n        (9 * 60, 10 * 60 + 30),     # 9:00-10:30\n        (11 * 60, 12 * 60 + 30),    # 11:00-12:30\n        (13 * 60, 14 * 60),         # 13:00-14:00\n        (14 * 60 + 30, 16 * 60 + 30) # 14:30-16:30\n    ]\n    \n    meeting_duration = 30  # minutes\n    \n    # Generate all possible 30-minute slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 1  # Check every minute\n    \n    # Check each slot against all constraints\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        \n        # Bradley's constraint: not before 14:30\n        if slot_start < bradley_constraint:\n            continue\n        \n        # Check Zachary's busy times\n        zachary_conflict = False\n        for busy_start, busy_end in zachary_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                zachary_conflict = True\n                break\n        if zachary_conflict:\n            continue\n        \n        # Check Teresa's busy times\n        teresa_conflict = False\n        for busy_start, busy_end in teresa_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                teresa_conflict = True\n                break\n        if teresa_conflict:\n            continue\n        \n        # If no conflicts, return this slot\n        start_h = slot_start // 60\n        start_m = slot_start % 60\n        end_h = slot_end // 60\n        end_m = slot_end % 60\n        return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_35"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    duration = 60          # 1 hour in minutes\n\n    # Busy intervals for each participant in minutes since midnight\n    ryan_busy = [(9 * 60, 9 * 60 + 30), (12 * 60 + 30, 13 * 60)]\n    ruth_busy = []  # No meetings\n    denise_busy = [(9 * 60 + 30, 10 * 60 + 30), (12 * 60, 13 * 60), (14 * 60 + 30, 16 * 60 + 30)]\n    denise_no_meet_after = 12 * 60 + 30  # Denise doesn't want to meet after 12:30\n\n    # Combine all busy intervals and sort them\n    all_busy = ryan_busy + ruth_busy + denise_busy\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy intervals and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Filter free slots that meet duration and Denise's constraint\n    valid_slots = []\n    for start, end in free_slots:\n        slot_start = start\n        slot_end = end\n        # Ensure the slot is at least 'duration' long\n        if slot_end - slot_start >= duration:\n            # Check Denise's constraint: meeting must end by 12:30\n            if slot_start + duration <= denise_no_meet_after:\n                valid_slots.append((slot_start, slot_end))\n\n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No valid time slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_36"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, meeting_duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes  # Add 540 to convert back to 24-hour format\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n\n    # Initialize the free slots for the day (work hours)\n    free_slots = [(work_start, work_end)]\n\n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        blocked_slots = []\n        for block in schedule:\n            start, end = block.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            blocked_slots.append((start_min, end_min))\n        \n        # Sort blocked slots by start time\n        blocked_slots.sort()\n\n        # Update free_slots by subtracting blocked slots\n        new_free_slots = []\n        for free_start, free_end in free_slots:\n            current_start = free_start\n            for block_start, block_end in blocked_slots:\n                if block_start > current_start:\n                    new_free_slots.append((current_start, block_start))\n                current_start = max(current_start, block_end)\n            if current_start < free_end:\n                new_free_slots.append((current_start, free_end))\n        free_slots = new_free_slots\n\n    # Find the first slot that can fit the meeting\n    meeting_duration_min = meeting_duration * 60\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration_min:\n            meeting_end = slot_start + meeting_duration_min\n            return f\"{minutes_to_time(slot_start)}:{minutes_to_time(meeting_end)}\"\n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"11:00 to 11:30\", \"12:00 to 12:30\", \"15:30 to 16:30\"],  # Gregory\n    [],  # Teresa\n    [\"9:00 to 10:30\", \"11:00 to 16:00\", \"16:30 to 17:00\"],  # Carol\n]\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nmeeting_duration = 0.5  # in hours\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, meeting_duration))\n```",
            "count": "calendar_scheduling_example_37"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(schedules, duration, work_hours):\n    # Convert all time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start, work_end = map(time_to_minutes, work_hours.split(' to '))\n    \n    # Collect all busy intervals for each participant\n    busy_intervals = []\n    for person in schedules.values():\n        for interval in person:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Check for available slots between work hours and busy intervals\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            \n            meeting_start = minutes_to_time(slot_start)\n            meeting_end = minutes_to_time(slot_start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No available slot found\"\n\n# Define the schedules\nschedules = {\n    \"Catherine\": [\"10:30 to 11:00\", \"12:30 to 13:30\", \"14:30 to 15:00\"],\n    \"Michael\": [\"9:30 to 10:30\", \"12:00 to 13:00\", \"13:30 to 14:00\", \"15:00 to 15:30\"],\n    \"Alexander\": [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:00 to 12:00\", \"13:00 to 13:30\", \"14:00 to 16:00\", \"16:30 to 17:00\"]\n}\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_hours = \"9:00 to 17:00\"\n\n# Find and print the meeting time\nprint(find_meeting_time(schedules, duration, work_hours))\n```",
            "count": "calendar_scheduling_example_38"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration_minutes):\n    # Convert work hours and schedules to minutes for easier calculation\n    work_start, work_end = work_hours\n    work_start_min = work_start[0] * 60 + work_start[1]\n    work_end_min = work_end[0] * 60 + work_end[1]\n    \n    # Initialize the free slots for all participants within work hours\n    free_slots = []\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start = busy[0][0] * 60 + busy[0][1]\n            end = busy[1][0] * 60 + busy[1][1]\n            busy_slots.append((start, end))\n        \n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Generate free slots by finding gaps between busy slots and work hours\n        current_time = work_start_min\n        free = []\n        for busy_start, busy_end in busy_slots:\n            if busy_start > current_time:\n                free.append((current_time, busy_start))\n            current_time = max(current_time, busy_end)\n        if current_time < work_end_min:\n            free.append((current_time, work_end_min))\n        \n        free_slots.append(free)\n    \n    # Find overlapping free slots across all participants\n    common_free_slots = free_slots[0]\n    for participant_free in free_slots[1:]:\n        new_common = []\n        i = j = 0\n        while i < len(common_free_slots) and j < len(participant_free):\n            slot1 = common_free_slots[i]\n            slot2 = participant_free[j]\n            # Find the overlap between slot1 and slot2\n            overlap_start = max(slot1[0], slot2[0])\n            overlap_end = min(slot1[1], slot2[1])\n            if overlap_start < overlap_end:\n                new_common.append((overlap_start, overlap_end))\n            # Move the pointer which ends first\n            if slot1[1] < slot2[1]:\n                i += 1\n            else:\n                j += 1\n        common_free_slots = new_common\n    \n    # Find the earliest slot that can fit the meeting duration\n    for slot in common_free_slots:\n        start, end = slot\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return None\n\n# Define work hours (9:00 to 17:00)\nwork_hours = ((9, 0), (17, 0))\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Emily is free the entire day\n    [   # Victoria's busy slots\n        ((13, 30), (14, 0)),\n        ((14, 30), (15, 30)),\n        ((16, 30), (17, 0))\n    ],\n    [   # Nancy's busy slots\n        ((9, 0), (14, 0)),\n        ((14, 30), (15, 30))\n    ]\n]\n\n# Meeting duration is 30 minutes\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_39"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = map(time_to_minutes, work_hours.split(' to '))\n    duration_min = duration * 60\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        busy = []\n        for meeting in schedule:\n            start, end = map(time_to_minutes, meeting.split(' to '))\n            busy.append((start, end))\n        all_busy.append(busy)\n    \n    # Find all possible free slots for each participant\n    all_free_slots = []\n    for busy in all_busy:\n        free_slots = []\n        # Start from work start time\n        prev_end = work_start\n        for start, end in sorted(busy, key=lambda x: x[0]):\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        # Check the time after last meeting until work end\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        all_free_slots.append(free_slots)\n    \n    # Find overlapping free slots across all participants\n    common_free_slots = all_free_slots[0]\n    for free_slots in all_free_slots[1:]:\n        new_common_slots = []\n        i = j = 0\n        while i < len(common_free_slots) and j < len(free_slots):\n            start1, end1 = common_free_slots[i]\n            start2, end2 = free_slots[j]\n            # Find the overlap\n            overlap_start = max(start1, start2)\n            overlap_end = min(end1, end2)\n            if overlap_start < overlap_end:\n                new_common_slots.append((overlap_start, overlap_end))\n            # Move the pointer which ends first\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free_slots = new_common_slots\n    \n    # Find the first slot that can fit the duration\n    for start, end in common_free_slots:\n        if end - start >= duration_min:\n            meeting_end = start + duration_min\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\njacob_schedule = [\"10:00 to 11:00\", \"11:30 to 12:00\", \"16:00 to 16:30\"]\ngabriel_schedule = [\"9:30 to 11:30\", \"13:00 to 13:30\", \"15:00 to 15:30\"]\nmatthew_schedule = [\"9:00 to 9:30\", \"10:30 to 11:00\", \"11:30 to 12:00\", \"12:30 to 14:00\", \"15:30 to 16:30\"]\n\nparticipants_schedules = [jacob_schedule, gabriel_schedule, matthew_schedule]\nwork_hours = \"9:00 to 17:00\"\nmeeting_duration = 1  # in hours\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_40"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Alan's constraints: available after 14:30\n    alan_start = 14 * 60 + 30  # 14:30 in minutes\n    alan_end = work_end\n\n    # Nancy's busy times in minutes since midnight\n    nancy_busy = [\n        (11 * 60, 12 * 60 + 30),  # 11:00-12:30\n        (13 * 60, 13 * 60 + 30),  # 13:00-13:30\n        (14 * 60, 15 * 60)        # 14:00-15:00\n    ]\n\n    # Patricia's busy times in minutes since midnight\n    patricia_busy = [\n        (10 * 60, 12 * 60),       # 10:00-12:00\n        (12 * 60 + 30, 13 * 60),  # 12:30-13:00\n        (13 * 60 + 30, 16 * 60)   # 13:30-16:00\n    ]\n\n    # Combine all busy times for Nancy and Patricia\n    combined_busy = nancy_busy + patricia_busy\n    # Sort by start time\n    combined_busy.sort()\n\n    # Find potential slots after Alan's start time\n    potential_start = alan_start\n    for busy_start, busy_end in combined_busy:\n        if busy_start > potential_start:\n            # Check if the slot is long enough\n            if busy_start - potential_start >= meeting_duration:\n                # Found a valid slot\n                end_time = potential_start + meeting_duration\n                return f\"{potential_start // 60:02d}:{potential_start % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n        # Update potential_start to the end of the current busy period if it's later\n        if busy_end > potential_start:\n            potential_start = busy_end\n\n    # Check the slot after the last busy period\n    if work_end - potential_start >= meeting_duration:\n        end_time = potential_start + meeting_duration\n        return f\"{potential_start // 60:02d}:{potential_start % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n\n    # Default return (though the problem states a solution exists)\n    return \"No time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_41"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work_hours start at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = 9 + minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    start_min = time_to_minutes(work_hours[0])\n    end_min = time_to_minutes(work_hours[1])\n    duration_min = duration * 60\n\n    # Initialize a list to track busy intervals for all participants\n    busy_intervals = []\n\n    # Collect all busy intervals for each participant\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start = time_to_minutes(busy[0])\n            end = time_to_minutes(busy[1])\n            busy_intervals.append((start, end))\n\n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find the first available slot\n    prev_end = start_min\n    for start, end in merged:\n        if start - prev_end >= duration_min:\n            # Found a slot\n            meeting_start = prev_end\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n        prev_end = max(prev_end, end)\n\n    # Check after the last busy interval\n    if end_min - prev_end >= duration_min:\n        meeting_start = prev_end\n        meeting_end = meeting_start + duration_min\n        return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No available slot found\"\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration_hours = 1\n\n# Define participants' schedules\nparticipants_schedules = [\n    [(\"9:00\", \"9:30\"), (\"11:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:30\", \"14:00\"), (\"16:00\", \"17:00\")],  # Julie\n    [(\"9:00\", \"9:30\"), (\"13:00\", \"13:30\"), (\"15:00\", \"15:30\"), (\"16:00\", \"16:30\")],  # Sean\n    [(\"10:00\", \"10:30\"), (\"11:00\", \"13:00\"), (\"15:30\", \"17:00\")],  # Lori\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_42"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Convert each participant's meetings to minutes\n    albert_meetings = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    gregory_meetings = [\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    benjamin_meetings = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 13 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n\n    # Combine all meetings and blocked times\n    all_busy = []\n    for meeting in albert_meetings + gregory_meetings + benjamin_meetings:\n        all_busy.append(meeting)\n    all_busy.sort()\n\n    # Find the earliest available 30-minute slot\n    current_time = work_start\n    meeting_duration = 30\n\n    for busy_start, busy_end in all_busy:\n        if current_time + meeting_duration <= busy_start:\n            # Check if all participants are free during this slot\n            if (not is_busy(current_time, current_time + meeting_duration, albert_meetings) and\n                not is_busy(current_time, current_time + meeting_duration, gregory_meetings) and\n                not is_busy(current_time, current_time + meeting_duration, benjamin_meetings)):\n                # Format the time as HH:MM:HH:MM\n                start_hh = current_time // 60\n                start_mm = current_time % 60\n                end_hh = (current_time + meeting_duration) // 60\n                end_mm = (current_time + meeting_duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n        current_time = max(current_time, busy_end)\n\n    # Check after the last busy time\n    if current_time + meeting_duration <= work_end:\n        start_hh = current_time // 60\n        start_mm = current_time % 60\n        end_hh = (current_time + meeting_duration) // 60\n        end_mm = (current_time + meeting_duration) % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No available time found\"\n\ndef is_busy(start, end, meetings):\n    for busy_start, busy_end in meetings:\n        if not (end <= busy_start or start >= busy_end):\n            return True\n    return False\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_43"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each participant's busy slots to minutes\n    ronald_busy = [\n        (11 * 60 + 30, 12 * 60),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n    amanda_busy = [\n        (9 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    isabella_preference_end = 13 * 60  # Prefers not after 13:00\n\n    # Generate all possible 30-minute slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 1  # Check every minute for a slot\n\n    # Check each slot against constraints\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        # Check Isabella's preference (not after 13:00)\n        if slot_start >= isabella_preference_end:\n            continue\n        # Check Ronald's availability\n        ronald_available = True\n        for busy_start, busy_end in ronald_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                ronald_available = False\n                break\n        if not ronald_available:\n            continue\n        # Check Amanda's availability\n        amanda_available = True\n        for busy_start, busy_end in amanda_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                amanda_available = False\n                break\n        if not amanda_available:\n            continue\n        # If all checks passed, return this slot\n        return f\"{slot_start // 60:02d}:{slot_start % 60:02d}:{slot_end // 60:02d}:{slot_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_44"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert all time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = work_hours.split(' to ')\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participans_schedules.values():\n        for interval in schedule:\n            start, end = interval.split(' to ')\n            busy_intervals.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals during work hours\n    free_intervals = []\n    prev_end = work_start_min\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n    \n    # Check each free interval for availability of all participants\n    for start, end in free_intervals:\n        available_duration = end - start\n        if available_duration >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define the participants' schedules\nparticipants_schedules = {\n    \"Andrew\": [],\n    \"Grace\": [],\n    \"Samuel\": [\"9:00 to 10:30\", \"11:30 to 12:00\", \"13:00 to 13:30\", \"14:00 to 16:00\", \"16:30 to 17:00\"]\n}\n\n# Meeting duration in minutes (half an hour)\nduration = 30\n\n# Work hours\nwork_hours = \"9:00 to 17:00\"\n\n# Find the earliest available meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_45"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:30:12:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append(interval)\n    \n    # Find available slots by checking gaps between merged intervals and work hours\n    available_slots = []\n    previous_end = work_start\n    \n    for interval in merged:\n        current_start, current_end = interval\n        if current_start > previous_end:\n            available_slots.append((previous_end, current_start))\n        previous_end = max(previous_end, current_end)\n    \n    # Check the slot after the last busy interval\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Find the first available slot that can accommodate the meeting\n    for slot in available_slots:\n        start, end = slot\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return None\n\n# Define the participants' schedules\narthur_schedule = [\"09:30:10:00\", \"14:00:14:30\"]\ntheresa_schedule = [\"09:00:09:30\", \"12:00:13:00\", \"15:00:16:30\"]\ncarl_schedule = [\"09:00:11:30\", \"12:00:14:00\", \"14:30:17:00\"]\n\n# Combine all schedules\nparticipants_schedules = [arthur_schedule, theresa_schedule, carl_schedule]\n\n# Define work hours and meeting duration\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_46"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Parse work hours\n    work_start, work_end = work_hours.split(' to ')\n    work_start = int(work_start.split(':')[0]) * 60 + int(work_start.split(':')[1])\n    work_end = int(work_end.split(':')[0]) * 60 + int(work_end.split(':')[1])\n    \n    # Initialize busy slots for all participants\n    busy_slots = []\n    for schedule in participants_schedules:\n        person_busy = []\n        for meeting in schedule:\n            start, end = meeting.split(' to ')\n            start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n            end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n            person_busy.append((start_min, end_min))\n        busy_slots.append(person_busy)\n    \n    # Find all possible meeting slots\n    possible_slots = []\n    current_time = work_start\n    while current_time + duration <= work_end:\n        slot_valid = True\n        for person in busy_slots:\n            for meeting in person:\n                if not (current_time + duration <= meeting[0] or current_time >= meeting[1]):\n                    slot_valid = False\n                    break\n            if not slot_valid:\n                break\n        if slot_valid:\n            possible_slots.append((current_time, current_time + duration))\n        current_time += 15  # Check in 15-minute increments\n    \n    if not possible_slots:\n        return None\n    \n    # Return the first available slot\n    start, end = possible_slots[0]\n    start_h = start // 60\n    start_m = start % 60\n    end_h = end // 60\n    end_m = end % 60\n    return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n\n# Define participants' schedules\ndavid_schedule = []\neric_schedule = [\"9:00 to 9:30\", \"10:30 to 11:30\", \"15:00 to 15:30\"]\nroger_schedule = [\"9:30 to 10:30\", \"11:00 to 12:00\", \"12:30 to 13:00\", \"14:30 to 15:00\", \"15:30 to 16:30\"]\n\nparticipants_schedules = [david_schedule, eric_schedule, roger_schedule]\nwork_hours = \"9:00 to 17:00\"\nduration = 60  # minutes\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_47"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Convert each participant's busy slots to minutes\n    # Janet's busy slots: 9:30-10:30, 12:30-13:00, 14:00-14:30\n    janet_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60, 14 * 60 + 30)\n    ]\n    \n    # Rachel has no meetings\n    rachel_busy = []\n    \n    # Cynthia's busy slots: 9:30-10:00, 11:00-11:30, 12:30-14:30, 16:00-17:00\n    cynthia_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 14 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n    \n    # Cynthia's preference: not before 13:30\n    cynthia_preference_start = 13 * 60 + 30  # 13:30 in minutes\n\n    # Combine all busy slots\n    all_busy = []\n    for slot in janet_busy:\n        all_busy.append(('Janet', slot))\n    for slot in rachel_busy:\n        all_busy.append(('Rachel', slot))\n    for slot in cynthia_busy:\n        all_busy.append(('Cynthia', slot))\n    \n    # Sort all busy slots by start time\n    all_busy.sort(key=lambda x: x[1][0])\n\n    # Find potential meeting slots\n    potential_slots = []\n    previous_end = work_start\n\n    for _, (start, end) in all_busy:\n        if start > previous_end:\n            potential_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        potential_slots.append((previous_end, work_end))\n\n    # Filter slots that are long enough and meet Cynthia's preference\n    valid_slots = []\n    for slot in potential_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= meeting_duration and slot_start >= cynthia_preference_start:\n            valid_slots.append(slot)\n    \n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        print(f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\")\n    else:\n        print(\"No valid meeting time found.\")\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_48"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since midnight\n    teresa_busy = [\n        (9 * 60, 10 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    kathleen_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    patricia_busy = [\n        (9 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n\n    # Kathleen's preference: not after 14:30 (so before 14:30)\n    kathleen_preference_end = 14 * 60 + 30\n\n    # Generate all possible slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 1  # Check every minute\n\n    # Check each slot against everyone's schedule and preferences\n    for slot in possible_slots:\n        start, end = slot\n        # Check if the slot is before Kathleen's preference end time\n        if end > kathleen_preference_end:\n            continue\n        # Check Teresa's availability\n        teresa_available = True\n        for busy_start, busy_end in teresa_busy:\n            if not (end <= busy_start or start >= busy_end):\n                teresa_available = False\n                break\n        if not teresa_available:\n            continue\n        # Check Kathleen's availability\n        kathleen_available = True\n        for busy_start, busy_end in kathleen_busy:\n            if not (end <= busy_start or start >= busy_end):\n                kathleen_available = False\n                break\n        if not kathleen_available:\n            continue\n        # Check Patricia's availability\n        patricia_available = True\n        for busy_start, busy_end in patricia_busy:\n            if not (end <= busy_start or start >= busy_end):\n                patricia_available = False\n                break\n        if not patricia_available:\n            continue\n        # If all checks passed, return this slot\n        return f\"{start // 60:02d}:{start % 60:02d}:{end // 60:02d}:{end % 60:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_49"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:30:14:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(duration, work_start, work_end, schedules):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by looking at gaps between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start_min\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        available_slots.append((prev_end, work_end_min))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define the problem parameters\nduration = 1  # hours\nwork_start = \"09:00\"\nwork_end = \"17:00\"\n# Emma's schedule\nemma_schedule = [\"09:00:10:30\", \"11:00:12:00\", \"12:30:13:30\", \"14:30:15:30\", \"16:00:16:30\"]\n# Daniel and Roy have no meetings\ndaniel_schedule = []\nroy_schedule = []\nschedules = [daniel_schedule, roy_schedule, emma_schedule]\n\n# Find and print the meeting time\nprint(find_meeting_time(duration, work_start, work_end, schedules))\n```",
            "count": "calendar_scheduling_example_50"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work hours start at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = 9 + minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    # Initialize work hours in minutes\n    start_work = time_to_minutes(work_hours[0])\n    end_work = time_to_minutes(work_hours[1])\n\n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules.values():\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort intervals by start time\n    busy_intervals.sort()\n\n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = start_work\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < end_work:\n        free_intervals.append((prev_end, end_work))\n\n    # Find the first free interval that can fit the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"Brandon\": [\"11:30 to 12:00\", \"12:30 to 13:30\", \"14:00 to 14:30\"],\n    \"Donna\": [\"10:00 to 10:30\", \"12:00 to 12:30\"],\n    \"Jack\": [\"9:30 to 10:00\", \"10:30 to 11:00\", \"11:30 to 12:30\", \"13:00 to 14:30\", \"15:30 to 17:00\"]\n}\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 60  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_51"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Parse work hours\n    work_start, work_end = [int(time.split(':')[0]) + int(time.split(':')[1])/60 for time in work_hours.split(' to ')]\n    \n    # Initialize available slots as the entire work day\n    available_slots = [(work_start, work_end)]\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = [int(time.split(':')[0]) + int(time.split(':')[1])/60 for time in busy.split(' to ')]\n            busy_slots.append((start, end))\n        \n        # Merge overlapping busy slots\n        busy_slots.sort()\n        merged_busy = []\n        for busy in busy_slots:\n            if not merged_busy:\n                merged_busy.append(busy)\n            else:\n                last_start, last_end = merged_busy[-1]\n                current_start, current_end = busy\n                if current_start <= last_end:\n                    merged_busy[-1] = (last_start, max(last_end, current_end))\n                else:\n                    merged_busy.append(busy)\n        \n        # Subtract busy slots from available slots\n        new_available_slots = []\n        for avail_start, avail_end in available_slots:\n            current_start = avail_start\n            for busy_start, busy_end in merged_busy:\n                if busy_start > current_start and busy_start <= avail_end:\n                    new_available_slots.append((current_start, busy_start))\n                current_start = max(current_start, busy_end)\n            if current_start < avail_end:\n                new_available_slots.append((current_start, avail_end))\n        available_slots = new_available_slots\n    \n    # Find the first available slot that can fit the meeting\n    for slot in available_slots:\n        start, end = slot\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = int(meeting_start)\n            start_mm = int((meeting_start - start_hh) * 60)\n            end_hh = int(meeting_end)\n            end_mm = int((meeting_end - end_hh) * 60)\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No available slot found\"\n\n# Define participants' schedules\ngrace_schedule = [\n    \"9:00 to 9:30\",\n    \"10:00 to 11:00\",\n    \"16:00 to 16:30\"\n]\nrandy_schedule = [\n    \"12:30 to 13:00\",\n    \"16:00 to 16:30\"\n]\nsusan_schedule = [\n    \"9:00 to 14:30\",\n    \"15:30 to 16:00\"\n]\n\n# Define meeting constraints\nwork_hours = \"9:00 to 17:00\"\nduration = 1.0  # 1 hour\n\n# Find meeting time\nmeeting_time = find_meeting_time([grace_schedule, randy_schedule, susan_schedule], work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_52"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:30:16:30}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert all time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 9:00 (0 minutes)\n    \n    # Convert work hours to minutes\n    work_start, work_end = map(time_to_minutes, work_hours.split('-'))\n    \n    # Generate busy intervals in minutes for each participant\n    busy_intervals = []\n    for busy_slots in participents_busy.values():\n        participant_intervals = []\n        for slot in busy_slots:\n            start, end = map(time_to_minutes, slot.split('-'))\n            participant_intervals.append((start, end))\n        busy_intervals.append(participant_intervals)\n    \n    # Find all busy intervals for all participants\n    all_busy = []\n    for intervals in busy_intervals:\n        all_busy.extend(intervals)\n    all_busy.sort()\n    \n    # Merge overlapping busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append([start, end])\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1][1] = max(last_end, end)\n            else:\n                merged.append([start, end])\n    \n    # Find available slots\n    available = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n    \n    # Check for a slot that fits the duration\n    duration_min = duration * 60\n    for start, end in available:\n        if end - start >= duration_min:\n            # Convert back to HH:MM format\n            start_hh = (start + 540) // 60\n            start_mm = (start + 540) % 60\n            end_hh = (start + 540 + duration_min) // 60\n            end_mm = (start + 540 + duration_min) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}-{end_hh:02d}:{end_mm:02d}\"\n    return \"No available slot found\"\n\n# Define the participants' busy times\nparticipants_busy = {\n    \"Alice\": [\"9:30-10:00\", \"12:30-13:00\", \"14:30-15:00\", \"16:30-17:00\"],\n    \"Arthur\": [\"9:00-9:30\", \"10:00-11:00\", \"11:30-12:00\", \"13:00-14:00\", \"15:00-15:30\", \"16:30-17:00\"],\n    \"Noah\": []\n}\n\n# Define work hours and meeting duration\nwork_hours = \"9:00-17:00\"\nduration = 1  # in hours\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_53"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Convert blocked times to minutes since midnight\n    isabella_blocked = [(11 * 60, 11 * 60 + 30), (15 * 60 + 30, 16 * 60)]\n    tyler_blocked = [(9 * 60, 10 * 60)]\n    jordan_blocked = [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60), \n                      (12 * 60 + 30, 13 * 60 + 30), (14 * 60, 14 * 60 + 30),\n                      (15 * 60, 16 * 60)]\n\n    # Tyler cannot meet after 16:00\n    tyler_no_meet_after = 16 * 60\n\n    # Combine all blocked times for each participant\n    blocked_times = {\n        'Isabella': isabella_blocked,\n        'Tyler': tyler_blocked,\n        'Jordan': jordan_blocked\n    }\n\n    # Find all possible 1-hour slots that work for everyone\n    possible_slots = []\n    current_time = work_start\n    meeting_duration = 60  # 1 hour\n\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        slot_valid = True\n\n        # Check Isabella's availability\n        for start, end in blocked_times['Isabella']:\n            if not (slot_end <= start or current_time >= end):\n                slot_valid = False\n                break\n        if not slot_valid:\n            current_time += 15  # Check next 15-minute interval\n            continue\n\n        # Check Tyler's availability\n        for start, end in blocked_times['Tyler']:\n            if not (slot_end <= start or current_time >= end):\n                slot_valid = False\n                break\n        if not slot_valid:\n            current_time += 15\n            continue\n        if slot_end > tyler_no_meet_after:\n            slot_valid = False\n        if not slot_valid:\n            current_time += 15\n            continue\n\n        # Check Jordan's availability\n        for start, end in blocked_times['Jordan']:\n            if not (slot_end <= start or current_time >= end):\n                slot_valid = False\n                break\n        if not slot_valid:\n            current_time += 15\n            continue\n\n        if slot_valid:\n            possible_slots.append((current_time, slot_end))\n            break  # Return the first valid slot found\n\n        current_time += 15\n\n    if possible_slots:\n        start, end = possible_slots[0]\n        # Convert minutes back to HH:MM format\n        start_hh = start // 60\n        start_mm = start % 60\n        end_hh = end // 60\n        end_mm = end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_54"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability across all participants\n    # Since all participants' busy intervals are merged, any free interval is common\n    for start, end in free_intervals:\n        if end - start >= duration * 60:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration * 60)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"14:00 to 14:30\", \"16:00 to 16:30\"],  # Keith\n    [],                                    # Christine\n    [\"09:00 to 10:30\", \"11:30 to 17:00\"]   # Cynthia\n]\n\n# Define work hours and meeting duration\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 1  # in hours\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration))\n```",
            "count": "calendar_scheduling_example_55"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = (minutes + 540) // 60\n        mm = (minutes + 540) % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    # Parse work hours\n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n\n    # Initialize busy slots for all participants\n    busy_slots = []\n    for schedule in participants_schedules:\n        person_busy = []\n        for slot in schedule:\n            start, end = slot.split(' to ')\n            person_busy.append((time_to_minutes(start), time_to_minutes(end)))\n        busy_slots.append(person_busy)\n\n    # Find all possible slots\n    possible_slots = []\n    current_time = work_start\n    while current_time + duration <= work_end:\n        slot_valid = True\n        for person in busy_slots:\n            for busy_start, busy_end in person:\n                if not (current_time + duration <= busy_start or current_time >= busy_end):\n                    slot_valid = False\n                    break\n            if not slot_valid:\n                break\n        if slot_valid:\n            possible_slots.append((current_time, current_time + duration))\n        current_time += 15  # Check every 15 minutes\n\n    if not possible_slots:\n        return None\n\n    # Return the first available slot\n    start, end = possible_slots[0]\n    return f\"{minutes_to_time(start)}:{minutes_to_time(end)}\"\n\n# Define the problem\nparticipants_schedules = [\n    [\"12:00 to 13:00\", \"13:30 to 14:00\", \"15:00 to 15:30\"],  # Jeremy\n    [\"09:30 to 10:00\", \"13:00 to 13:30\", \"16:00 to 17:00\"],  # Donna\n    [\"09:00 to 11:00\", \"11:30 to 12:00\", \"12:30 to 17:00\"],  # Robert\n]\nwork_hours = \"09:00 to 17:00\"\nduration = 30  # minutes\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_56"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define each participant's busy times in minutes (start, end)\n    virginia_busy = [(10 * 60, 12 * 60)]\n    charles_busy = [(12 * 60, 12 * 30), (13 * 60, 13 * 30)]\n    megan_busy = [(9 * 60, 12 * 60), (13 * 30, 16 * 60), (16 * 30, 17 * 60)]\n    \n    # Charles' preference: avoid before 14:30\n    charles_preference_start = 14 * 60 + 30\n    \n    # Combine all busy times and sort\n    all_busy = virginia_busy + charles_busy + megan_busy\n    all_busy.sort()\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Check for a 30-minute slot that fits Charles' preference\n    meeting_duration = 30\n    for slot_start, slot_end in available_slots:\n        # Adjust slot_start to meet Charles' preference\n        adjusted_start = max(slot_start, charles_preference_start)\n        if adjusted_start + meeting_duration <= slot_end:\n            # Format the time as HH:MM:HH:MM\n            start_hh = adjusted_start // 60\n            start_mm = adjusted_start % 60\n            end_hh = (adjusted_start + meeting_duration) // 60\n            end_mm = (adjusted_start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_57"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for meeting in schedule:\n            start, end = map(time_to_minutes, meeting.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability for all participants\n    for interval in free_intervals:\n        start, end = interval\n        available_duration = end - start\n        if available_duration >= duration_minutes:\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration_minutes)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\njoan_schedule = [\"11:00 to 11:30\", \"12:30 to 13:00\"]\ntheresa_schedule = [\"12:00 to 12:30\", \"15:00 to 15:30\"]\nshirley_schedule = [\"9:30 to 10:30\", \"11:00 to 12:00\", \"13:00 to 14:00\", \"15:30 to 16:30\"]\n\nparticipants_schedules = [joan_schedule, theresa_schedule, shirley_schedule]\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 60  # 1 hour\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes))\n```",
            "count": "calendar_scheduling_example_58"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Jeffrey's constraints: available after 14:00\n    jeffrey_free = [(14 * 60, work_end)]\n\n    # Jack's busy times in minutes\n    jack_busy = [\n        (10 * 60 + 30, 11 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n    # Calculate Jack's free times\n    jack_free = []\n    prev_end = work_start\n    for start, end in sorted(jack_busy):\n        if start > prev_end:\n            jack_free.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        jack_free.append((prev_end, work_end))\n\n    # Judith's busy times in minutes\n    judith_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    # Calculate Judith's free times\n    judith_free = []\n    prev_end = work_start\n    for start, end in sorted(judith_busy):\n        if start > prev_end:\n            judith_free.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        judith_free.append((prev_end, work_end))\n\n    # Find overlapping free times for all three\n    meeting_duration = 30\n    possible_slots = []\n\n    # Iterate through Jeffrey's free times (only after 14:00)\n    for jf_start, jf_end in jeffrey_free:\n        # Iterate through Jack's free times\n        for jk_start, jk_end in jack_free:\n            # Find overlap between Jeffrey and Jack\n            overlap_start = max(jf_start, jk_start)\n            overlap_end = min(jf_end, jk_end)\n            if overlap_start >= overlap_end:\n                continue\n            # Iterate through Judith's free times\n            for ju_start, ju_end in judith_free:\n                # Find overlap with Judith\n                final_start = max(overlap_start, ju_start)\n                final_end = min(overlap_end, ju_end)\n                if final_start >= final_end:\n                    continue\n                # Check if there's enough time for the meeting\n                if final_end - final_start >= meeting_duration:\n                    possible_slots.append((final_start, final_start + meeting_duration))\n\n    # Select the earliest possible slot\n    if possible_slots:\n        best_slot = min(possible_slots)\n        start_h, start_m = divmod(best_slot[0], 60)\n        end_h, end_m = divmod(best_slot[1], 60)\n        print(f\"{int(start_h):02d}:{int(start_m):02d}:{int(end_h):02d}:{int(end_m):02d}\")\n    else:\n        print(\"No suitable time found.\")\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_59"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes\n    lisa_busy = [\n        (10 * 60 + 30, 11 * 60),    # 10:30-11:00\n        (11 * 60 + 30, 12 * 60),    # 11:30-12:00\n        (14 * 60, 15 * 60)          # 14:00-15:00\n    ]\n    raymond_busy = [\n        (9 * 60, 10 * 60),          # 9:00-10:00\n        (10 * 60 + 30, 11 * 60),    # 10:30-11:00\n        (11 * 60 + 30, 15 * 60),    # 11:30-15:00\n        (16 * 60, 17 * 60)          # 16:00-17:00\n    ]\n    # Dorothy is free all day but prefers no meetings after 10:30\n    dorothy_preference_end = 10 * 60 + 30  # 10:30\n\n    # Combine all busy slots\n    all_busy = lisa_busy + raymond_busy\n    # Sort by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check after last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Now check Dorothy's preference (no meetings after 10:30)\n    # So we only consider slots that start and end before or at 10:30\n    valid_slots = []\n    for start, end in free_slots:\n        slot_end = start + meeting_duration\n        if slot_end <= dorothy_preference_end and slot_end <= end:\n            valid_slots.append((start, slot_end))\n\n    # Select the first valid slot\n    if valid_slots:\n        meeting_start, meeting_end = valid_slots[0]\n    else:\n        return \"No valid time found\"\n\n    # Convert back to HH:MM format\n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n\n    start_time = minutes_to_time(meeting_start)\n    end_time = minutes_to_time(meeting_end)\n    return f\"{start_time}:{end_time}\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_60"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:30:14:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start, work_end = map(time_to_minutes, work_hours)\n    busy_slots = []\n    \n    for person in participants_busy:\n        for slot in participants_busy[person]:\n            start, end = map(time_to_minutes, slot)\n            busy_slots.append((start, end))\n    \n    # Sort all busy slots by start time\n    busy_slots.sort()\n    \n    # Find all free slots by merging busy intervals\n    merged_busy = []\n    for start, end in busy_slots:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Check the time before the first busy slot\n    if merged_busy:\n        first_busy_start, _ = merged_busy[0]\n        if first_busy_start - work_start >= duration:\n            return (work_start, work_start + duration)\n    \n    # Check the time between busy slots\n    for i in range(1, len(merged_busy)):\n        prev_end = merged_busy[i-1][1]\n        curr_start = merged_busy[i][0]\n        if curr_start - prev_end >= duration:\n            return (prev_end, prev_end + duration)\n    \n    # Check the time after the last busy slot\n    if merged_busy:\n        last_busy_end = merged_busy[-1][1]\n        if work_end - last_busy_end >= duration:\n            return (last_busy_end, last_busy_end + duration)\n    else:\n        # No busy slots, the entire work hours are free\n        return (work_start, work_start + duration)\n    \n    return None\n\ndef minutes_to_time(minutes):\n    hh = minutes // 60\n    mm = minutes % 60\n    return f\"{hh:02d}:{mm:02d}\"\n\n# Define participants' busy times\nparticipants_busy = {\n    'Robert': [],\n    'Lisa': ['9:30-10:00', '11:30-12:00'],\n    'Patrick': ['9:30-11:30', '12:30-13:30', '16:00-17:00'],\n}\n\n# Define work hours and meeting duration\nwork_hours = ('9:00', '17:00')\nduration_minutes = 60\n\n# Find a meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration_minutes)\n\nif meeting_time:\n    start, end = meeting_time\n    start_time = minutes_to_time(start)\n    end_time = minutes_to_time(end)\n    print(f\"{start_time}:{end_time}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_61"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(schedules, work_hours, duration):\n    start_work, end_work = work_hours\n    # Convert all times to minutes since midnight for easier calculation\n    work_start = start_work[0] * 60 + start_work[1]\n    work_end = end_work[0] * 60 + end_work[1]\n    \n    # Initialize the list of busy intervals\n    busy_intervals = []\n    \n    for schedule in schedules:\n        for interval in schedule:\n            start = interval[0][0] * 60 + interval[0][1]\n            end = interval[1][0] * 60 + interval[1][1]\n            busy_intervals.append((start, end))\n    \n    # Sort the busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find the free intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability\n    for start, end in free_intervals:\n        if end - start >= duration * 60:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = (start + duration * 60) // 60\n            end_mm = (start + duration * 60) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time slot found\"\n\n# Define the schedules\nabigail_schedule = []\nmichael_schedule = []\nsharon_schedule = [\n    ((9, 0), (13, 0)),\n    ((14, 0), (17, 0))\n]\n\nschedules = [abigail_schedule, michael_schedule, sharon_schedule]\nwork_hours = ((9, 0), (17, 0))\nduration = 1  # 1 hour\n\n# Find the meeting time\nmeeting_time = find_meeting_time(schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_62"
        },
        {
            "final_program_time": "{16:00:17:00}",
            "expected_time": "{16:00:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_work, end_work = work_hours\n    # Convert all times to minutes since midnight for easier calculation\n    start_min = start_work[0] * 60 + start_work[1]\n    end_min = end_work[0] * 60 + end_work[1]\n    \n    # Generate all possible slots within work hours\n    possible_slots = []\n    current_start = start_min\n    while current_start + duration <= end_min:\n        possible_slots.append((current_start, current_start + duration))\n        current_start += 30  # Check in 30-minute increments\n    \n    # Check each slot against all participants' schedules\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        valid = True\n        for schedule in participants_schedules:\n            for busy_start, busy_end in schedule:\n                busy_start_min = busy_start[0] * 60 + busy_start[1]\n                busy_end_min = busy_end[0] * 60 + busy_end[1]\n                # Check if slot overlaps with any busy period\n                if not (slot_end <= busy_start_min or slot_start >= busy_end_min):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            # Convert back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No valid slot found\"\n\n# Define work hours and meeting duration\nwork_hours = ((9, 0), (17, 0))  # 9:00 to 17:00\nduration = 60  # 1 hour in minutes\n\n# Define participants' schedules in (HH, MM) format\nmadison_schedule = []\njudith_schedule = [((10, 0), (10, 30)), ((11, 0), (12, 0)), ((12, 30), (13, 0))]\nroger_schedule = [((9, 0), (9, 30)), ((10, 30), (11, 0)), ((12, 0), (12, 30)), ((13, 0), (13, 30)), ((14, 0), (16, 0))]\n\nparticipants_schedules = [madison_schedule, judith_schedule, roger_schedule]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_63"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_work, end_work = work_hours\n    busy_slots = []\n    \n    # Collect all busy slots\n    for schedule in participants_schedules.values():\n        busy_slots.extend(schedule)\n    \n    # Sort busy slots by start time\n    busy_slots.sort()\n    \n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = start_work\n    \n    for start, end in busy_slots:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < end_work:\n        free_slots.append((previous_end, end_work))\n    \n    # Check each free slot for availability in all participants' schedules\n    for slot_start, slot_end in free_slots:\n        slot_duration = (slot_end - slot_start).total_seconds() / 3600\n        if slot_duration >= duration:\n            # Check if all participants are free during this slot\n            all_free = True\n            for schedule in participants_schedules.values():\n                for busy_start, busy_end in schedule:\n                    if busy_start < slot_end and busy_end > slot_start:\n                        all_free = False\n                        break\n                if not all_free:\n                    break\n            if all_free:\n                return slot_start, slot_start + timedelta(hours=duration)\n    \n    return None\n\n# Define work hours and meeting duration\nfrom datetime import datetime, timedelta\n\nwork_hours = (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))\nduration = 1  # hours\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"Nancy\": [\n        (datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n        (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\"))\n    ],\n    \"Albert\": [],\n    \"Nathan\": [\n        (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n        (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\")),\n        (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))\n    ]\n}\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\n\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{start.strftime('%H:%M')}:{end.strftime('%H:%M')}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_64"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define busy intervals in minutes since midnight\n    john_busy = [\n        (12 * 60 + 30, 13 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    andrea_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (11 * 60, 12 * 60 + 30),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    lisa_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (12 * 60, 12 * 60 + 30),\n        (14 * 60, 15 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    # Andrea cannot meet after 16:30\n    andrea_cutoff = 16 * 60 + 30\n    \n    # Meeting duration is 30 minutes\n    duration = 30\n    \n    # Generate all possible slots within work hours\n    for start in range(work_start, work_end - duration + 1, 15):  # Check every 15 minutes\n        end = start + duration\n        # Check if the slot is within Andrea's cutoff\n        if end > andrea_cutoff:\n            continue\n        # Check John's availability\n        john_available = True\n        for busy_start, busy_end in john_busy:\n            if not (end <= busy_start or start >= busy_end):\n                john_available = False\n                break\n        if not john_available:\n            continue\n        # Check Andrea's availability\n        andrea_available = True\n        for busy_start, busy_end in andrea_busy:\n            if not (end <= busy_start or start >= busy_end):\n                andrea_available = False\n                break\n        if not andrea_available:\n            continue\n        # Check Lisa's availability\n        lisa_available = True\n        for busy_start, busy_end in lisa_busy:\n            if not (end <= busy_start or start >= busy_end):\n                lisa_available = False\n                break\n        if lisa_available:\n            # Convert start and end back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = end // 60\n            end_mm = end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_65"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(schedules, duration, work_start, work_end):\n    # Convert all time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n    \n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Initialize the merged busy intervals\n    busy_intervals = []\n    for person, intervals in schedules.items():\n        for start, end in intervals:\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            busy_intervals.append((start_min, end_min))\n    \n    # Sort the intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                new_end = max(last_end, current_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append(interval)\n    \n    # Find the available slots\n    available = []\n    prev_end = 0\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        available.append((prev_end, work_end_min))\n    \n    # Check for a slot that can fit the duration\n    for start, end in available:\n        if end - start >= duration:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No available time slot found\"\n\n# Define the schedules\nschedules = {\n    \"Ronald\": [],\n    \"Maria\": [],\n    \"Charles\": [(\"9:00\", \"10:30\"), (\"11:00\", \"11:30\"), (\"13:30\", \"14:00\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:30\")]\n}\n\n# Define meeting parameters\nduration = 60  # 1 hour in minutes\nwork_start = \"9:00\"\nwork_end = \"17:00\"\n\n# Find and print the meeting time\nprint(find_meeting_time(schedules, duration, work_start, work_end))\n```",
            "count": "calendar_scheduling_example_66"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define busy intervals in minutes since midnight\n    jacqueline_busy = [\n        (13 * 60, 13 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    linda_busy = [\n        (9 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60 + 30, 16 * 60 + 30)\n    ]\n    # Linda cannot meet after 14:00\n    linda_no_meet_after = 14 * 60\n    \n    # Duration of the meeting in minutes\n    duration = 30\n    \n    # Generate all possible slots within work hours\n    possible_slots = []\n    current_time = work_start\n    \n    while current_time + duration <= work_end:\n        slot_end = current_time + duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 30  # Check every 30 minutes for efficiency\n    \n    # Check each slot against everyone's constraints\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        \n        # Check Jacqueline's availability\n        jacqueline_available = True\n        for busy_start, busy_end in jacqueline_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                jacqueline_available = False\n                break\n        if not jacqueline_available:\n            continue\n        \n        # Check Linda's availability and constraints\n        linda_available = True\n        for busy_start, busy_end in linda_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                linda_available = False\n                break\n        # Check if slot is after Linda's no-meet time\n        if slot_start >= linda_no_meet_after:\n            linda_available = False\n        if not linda_available:\n            continue\n        \n        # Christian is free all day, so no need to check\n        \n        # If we reach here, the slot is good for everyone\n        # Convert minutes back to HH:MM format\n        start_hh = slot_start // 60\n        start_mm = slot_start % 60\n        end_hh = slot_end // 60\n        end_mm = slot_end % 60\n        \n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_67"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration_minutes):\n    # Convert work hours and schedules to minutes since start of day\n    work_start, work_end = work_hours\n    work_start_min = work_start[0] * 60 + work_start[1]\n    work_end_min = work_end[0] * 60 + work_end[1]\n    \n    # Generate all possible time slots within work hours\n    possible_slots = []\n    current_time = work_start_min\n    while current_time + duration_minutes <= work_end_min:\n        possible_slots.append((current_time, current_time + duration_minutes))\n        current_time += 1  # Check every minute\n    \n    # Check each slot against all participants' schedules\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        valid = True\n        for schedule in participants_schedules:\n            for busy_start, busy_end in schedule:\n                busy_start_min = busy_start[0] * 60 + busy_start[1]\n                busy_end_min = busy_end[0] * 60 + busy_end[1]\n                # Check if slot overlaps with any busy period\n                if not (slot_end <= busy_start_min or slot_start >= busy_end_min):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            # Convert back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No available slot found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours = ((9, 0), (17, 0))\n\n# Define participants' schedules in HH:MM format\nmichael_schedule = [\n    ((10, 0), (10, 30)),\n    ((11, 30), (12, 0)),\n    ((13, 30), (14, 0)),\n    ((15, 30), (16, 0))\n]\nbryan_schedule = []\nlauren_schedule = [\n    ((9, 0), (10, 30)),\n    ((14, 30), (17, 0))\n]\n\nparticipants_schedules = [michael_schedule, bryan_schedule, lauren_schedule]\n\n# Find the earliest available 30-minute slot\nmeeting_time = find_meeting_time(participants_schedules, work_hours, 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_68"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:00:11:00}",
            "type_error": "SyntaxError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find the earliest available slot\n    prev_end = work_start\n    for busy_start, busy_end in all_busy:\n        if busy_start > prev_end:\n            available_start = prev_end\n            available_end = busy_start\n            if available_end - available_start >= duration:\n                return (minutes_to_time(available_start), (minutes_to_time(available_start + duration))\n        prev_end = max(prev_end, busy_end)\n    \n    # Check the slot after the last busy interval\n    if work_end - prev_end >= duration:\n        return (minutes_to_time(prev_end), (minutes_to_time(prev_end + duration)))\n    \n    return None\n\n# Define the schedules\nshirley_schedule = [\"11:00 to 11:30\", \"14:00 to 15:00\", \"16:00 to 16:30\"]\nstephen_schedule = [\"13:00 to 13:30\", \"15:30 to 16:00\"]\npaul_schedule = [\"9:00 to 10:00\", \"11:00 to 17:00\"]\n\nparticipants_schedules = [shirley_schedule, stephen_schedule, paul_schedule]\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration = 60  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration)\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{start}:{end}\")\nelse:\n    print(\"No available time slot found.\")\n```",
            "count": "calendar_scheduling_example_69"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration_minutes):\n    # Convert work hours and schedules to minutes since 9:00 (540 minutes)\n    work_start = 9 * 60\n    work_end = 17 * 60\n    duration = duration_minutes\n    \n    # Initialize a list to hold all busy intervals in minutes\n    busy_intervals = []\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start_h, start_m = map(int, busy.split(' to ')[0].split(':'))\n            end_h, end_m = map(int, busy.split(' to ')[1].split(':'))\n            start = start_h * 60 + start_m\n            end = end_h * 60 + end_m\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find the earliest available slot\n    prev_end = work_start\n    for start, end in merged:\n        if start - prev_end >= duration:\n            meeting_start = prev_end\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n        prev_end = max(prev_end, end)\n    \n    # Check after the last busy interval\n    if work_end - prev_end >= duration:\n        meeting_start = prev_end\n        meeting_end = meeting_start + duration\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\ndenise_schedule = [\"12:00 to 12:30\", \"15:30 to 16:00\"]\nangela_schedule = []\nnatalie_schedule = [\"9:00 to 11:30\", \"12:00 to 13:00\", \"14:00 to 14:30\", \"15:00 to 17:00\"]\n\nparticipants_schedules = [denise_schedule, angela_schedule, natalie_schedule]\nwork_hours = (\"9:00\", \"17:00\")\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_70"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define blocked times in minutes since midnight\n    john_blocked = [(12 * 60 + 30, 13 * 60), (16 * 60 + 30, 17 * 60)]\n    ethan_blocked = [(9 * 60, 10 * 60), (11 * 60 + 30, 14 * 60), (14 * 60 + 30, 17 * 60)]\n\n    # John's preference: not after 12:00\n    john_preference_end = 12 * 60\n\n    # Meeting duration in minutes\n    meeting_duration = 30\n\n    # Generate possible time slots\n    possible_slots = []\n    current_start = work_start\n\n    while current_start + meeting_duration <= work_end:\n        current_end = current_start + meeting_duration\n        # Check if the slot fits everyone's constraints\n        john_ok = True\n        for block_start, block_end in john_blocked:\n            if not (current_end <= block_start or current_start >= block_end):\n                john_ok = False\n                break\n        ethan_ok = True\n        for block_start, block_end in ethan_blocked:\n            if not (current_end <= block_start or current_start >= block_end):\n                ethan_ok = False\n                break\n        # Check John's preference\n        if john_ok and ethan_ok and current_end <= john_preference_end:\n            possible_slots.append((current_start, current_end))\n        current_start += 15  # Check every 15 minutes\n\n    if possible_slots:\n        # Select the earliest possible slot\n        meeting_start, meeting_end = possible_slots[0]\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_71"
        },
        {
            "final_program_time": "{13:30:14:30}",
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy)\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals_sorted = sorted(busy_intervals, key=lambda x: x[0])\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals_sorted:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    previous_end = work_start\n    for start, end in merged:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Find the first available slot that can fit the meeting duration\n    duration_minutes = duration * 60\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules\nmason_schedule = []  # No meetings\namy_schedule = [(\"09:30\", \"11:30\"), (\"13:00\", \"13:30\"), (\"16:30\", \"17:00\")]\nchristopher_schedule = [(\"09:00\", \"10:00\"), (\"12:00\", \"13:30\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:30\")]\n\nparticipants_schedules = [mason_schedule, amy_schedule, christopher_schedule]\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 1  # in hours\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules=participants_schedules, \n                       work_hours_start=work_hours_start, \n                       work_hours_end=work_hours_end, \n                       duration=meeting_duration))\n```",
            "count": "calendar_scheduling_example_72"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration):\n    # Convert all time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    all_busy_intervals = []\n    for busy_times in participants_busy_times:\n        for interval in busy_times:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            all_busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_intervals = []\n    for start, end in all_busy_intervals:\n        if not merged_intervals:\n            merged_intervals.append([start, end])\n        else:\n            last_start, last_end = merged_intervals[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                merged_intervals[-1][1] = max(end, last_end)\n            else:\n                merged_intervals.append([start, end])\n    \n    # Find available slots by checking gaps between merged intervals and work hours\n    available_slots = []\n    previous_end = work_start\n    for start, end in merged_intervals:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Check each available slot for sufficient duration\n    meeting_duration_min = meeting_duration * 60\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define the participants' busy times\nbradley_busy = [\"9:30 to 10:00\", \"13:00 to 13:30\", \"14:30 to 15:00\", \"16:30 to 17:00\"]\nandrew_busy = [\"9:00 to 9:30\", \"12:30 to 13:30\", \"14:00 to 14:30\", \"15:00 to 16:00\"]\nmelissa_busy = [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:00 to 14:00\", \"15:00 to 15:30\", \"16:00 to 16:30\"]\n\nparticipants_busy_times = [bradley_busy, andrew_busy, melissa_busy]\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 0.5  # in hours\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_73"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    duration = 60         # 1 hour in minutes\n\n    # Convert each person's busy times to minutes since 9:00\n    # Eric's busy times: 10:00-12:00\n    eric_busy = [(10 * 60, 12 * 60)]\n    # Albert's busy times: 12:00-12:30, 15:30-16:00\n    albert_busy = [(12 * 60, 12 * 60 + 30), (15 * 60 + 30, 16 * 60)]\n    # Katherine's busy times: 10:00-11:00, 11:30-14:00, 15:00-15:30\n    katherine_busy = [(10 * 60, 11 * 60), (11 * 60 + 30, 14 * 60), (15 * 60, 15 * 60 + 30)]\n\n    # Eric's constraint: no meetings after 15:30\n    eric_constraint = 15 * 60 + 30\n\n    # Combine all busy times and sort them\n    all_busy = eric_busy + albert_busy + katherine_busy\n    all_busy.sort()\n\n    # Find the earliest available slot\n    previous_end = work_start\n    for start, end in all_busy:\n        if start > previous_end:\n            # Check if the slot is long enough and before Eric's constraint\n            if (start - previous_end) >= duration and (previous_end + duration) <= eric_constraint:\n                # Convert back to HH:MM format\n                start_hh = previous_end // 60\n                start_mm = previous_end % 60\n                end_hh = (previous_end + duration) // 60\n                end_mm = (previous_end + duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n        previous_end = max(previous_end, end)\n\n    # Check after the last busy slot\n    if (work_end - previous_end) >= duration and (previous_end + duration) <= eric_constraint:\n        start_hh = previous_end // 60\n        start_mm = previous_end % 60\n        end_hh = (previous_end + duration) // 60\n        end_mm = (previous_end + duration) % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_74"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:14:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration_hours):\n    # Convert all times to minutes since midnight for easier calculation\n    start_min = work_hours_start * 60\n    end_min = work_hours_end * 60\n    duration_min = duration_hours * 60\n\n    # Initialize a list to keep track of all busy intervals\n    busy_intervals = []\n\n    # Collect all busy intervals from each participant\n    for person in participants_busy_times.values():\n        for interval in person:\n            start = interval[0] * 60\n            end = interval[1] * 60\n            busy_intervals.append((start, end))\n\n    # Sort the busy intervals by start time\n    busy_intervals_sorted = sorted(busy_intervals, key=lambda x: x[0])\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for interval in busy_intervals_sorted:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append(interval)\n\n    # Find available slots by checking gaps between merged intervals\n    available_slots = []\n    previous_end = start_min\n\n    for interval in merged:\n        current_start, current_end = interval\n        if current_start > previous_end:\n            available_slots.append((previous_end, current_start))\n        previous_end = max(previous_end, current_end)\n\n    # Check the slot after the last busy interval\n    if previous_end < end_min:\n        available_slots.append((previous_end, end_min))\n\n    # Find the first available slot that can fit the meeting duration\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No available slot found\"\n\n# Define the participants' busy times\nparticipants_busy_times = {\n    \"Jacob\": [(9.0, 9.5), (12.5, 13.0), (14.5, 15.0), (16.5, 17.0)],\n    \"Amanda\": [(10.0, 10.5), (12.0, 12.5)],\n    \"Lisa\": [(11.0, 13.0), (14.5, 16.5)]\n}\n\n# Define work hours and meeting duration\nwork_hours_start = 9.0\nwork_hours_end = 17.0\nduration_hours = 1.0\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_75"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    \"\"\"\n    Find a meeting time that fits all participants' schedules within work hours.\n    \n    Args:\n        participants_schedules: List of lists of busy intervals for each participant.\n        work_hours: Tuple (start, end) of the working day in HH:MM format.\n        duration: Duration of the meeting in minutes.\n    \n    Returns:\n        A string representing the proposed meeting time in HH:MM:HH:MM format.\n    \"\"\"\n    # Convert work hours and busy intervals to minutes since midnight for easier calculation\n    work_start = convert_to_minutes(work_hours[0])\n    work_end = convert_to_minutes(work_hours[1])\n    \n    # Collect all busy intervals from all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start = convert_to_minutes(interval[0])\n            end = convert_to_minutes(interval[1])\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots between work hours and busy intervals\n    available = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting duration\n    for slot in available:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return (f\"{convert_to_hhmm(meeting_start)}:{convert_to_hhmm(meeting_end)}\")\n    \n    return \"No available time slot found\"\n\ndef convert_to_minutes(time_str):\n    \"\"\"Convert HH:MM time string to minutes since midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(':'))\n    return hours * 60 + minutes\n\ndef convert_to_hhmm(minutes):\n    \"\"\"Convert minutes since midnight to HH:MM format.\"\"\"\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Define the participants' schedules\njoyce_schedule = []\nbeverly_schedule = [\n    (\"09:30\", \"10:00\"),\n    (\"11:00\", \"11:30\"),\n    (\"12:30\", \"13:00\"),\n    (\"14:00\", \"14:30\"),\n    (\"15:30\", \"16:00\"),\n    (\"16:30\", \"17:00\")\n]\npeter_schedule = [\n    (\"09:30\", \"10:30\"),\n    (\"11:30\", \"13:00\"),\n    (\"14:30\", \"15:30\"),\n    (\"16:30\", \"17:00\")\n]\n\n# Combine all schedules\nparticipants_schedules = [joyce_schedule, beverly_schedule, peter_schedule]\n\n# Define work hours and meeting duration\nwork_hours = (\"09:00\", \"17:00\")\nduration = 60  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_76"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    duration = 30         # meeting duration in minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    donald_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (15 * 60 + 30, 16 * 60 + 30)\n    ]\n    # Donald doesn't want to meet after 12:00\n    donald_busy.append((12 * 60, work_end))\n\n    joyce_busy = [\n        (11 * 60, 13 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n\n    abigail_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60, 14 * 60),\n        (15 * 60, 17 * 60)\n    ]\n\n    # Combine all busy slots\n    all_busy = donald_busy + joyce_busy + abigail_busy\n\n    # Sort busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check after last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_77"
        },
        {
            "final_program_time": "{12:30:13:30}",
            "expected_time": "{12:30:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours\n    start_min = time_to_minutes(start_work)\n    end_min = time_to_minutes(end_work)\n    \n    # Initialize the free time slots as the entire work day\n    free_slots = [(start_min, end_min)]\n    \n    # Process each participant's busy slots to find common free time\n    for busy_slots in participants_busy:\n        new_free_slots = []\n        for busy_start, busy_end in busy_slots:\n            busy_start_min = time_to_minutes(busy_start)\n            busy_end_min = time_to_minutes(busy_end)\n            updated_slots = []\n            for slot_start, slot_end in free_slots:\n                if busy_end_min <= slot_start or busy_start_min >= slot_end:\n                    # No overlap, keep the slot as is\n                    updated_slots.append((slot_start, slot_end))\n                else:\n                    # Overlap, split the slot\n                    if slot_start < busy_start_min:\n                        updated_slots.append((slot_start, busy_start_min))\n                    if busy_end_min < slot_end:\n                        updated_slots.append((busy_end_min, slot_end))\n            free_slots = updated_slots\n        if not free_slots:\n            return None  # No common free time\n    \n    # Merge adjacent or overlapping slots (not necessary here but good practice)\n    merged_slots = []\n    for slot in sorted(free_slots):\n        if not merged_slots:\n            merged_slots.append(slot)\n        else:\n            last_start, last_end = merged_slots[-1]\n            current_start, current_end = slot\n            if current_start <= last_end:\n                # Merge slots\n                new_slot = (last_start, max(last_end, current_end))\n                merged_slots[-1] = new_slot\n            else:\n                merged_slots.append(slot)\n    \n    # Find the first slot that can accommodate the meeting duration\n    duration_min = duration * 60\n    for slot_start, slot_end in merged_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_end = slot_start + duration_min\n            return f\"{minutes_to_time(slot_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return None\n\n# Define the participants' busy times\nparticipants_busy = [\n    [(\"9:00\", \"10:00\"), (\"11:00\", \"12:00\")],  # Ronald\n    [(\"10:30\", \"11:00\"), (\"14:00\", \"14:30\")],  # Teresa\n    [(\"9:00\", \"12:30\"), (\"14:00\", \"15:30\"), (\"16:00\", \"17:00\")],  # Carol\n]\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration_hours = 1\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_78"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:10:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert all time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start, work_end = map(time_to_minutes, work_hours.split(':'))\n    \n    # Initialize all available slots as free\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's busy slots\n    for busy_slots in participants_busy:\n        new_free_slots = []\n        for busy_start, busy_end in busy_slots:\n            busy_start = time_to_minutes(busy_start)\n            busy_end = time_to_minutes(busy_end)\n            updated_free_slots = []\n            for slot_start, slot_end in free_slots:\n                if busy_start >= slot_end or busy_end <= slot_start:\n                    # No overlap, keep the slot as is\n                    updated_free_slots.append((slot_start, slot_end))\n                else:\n                    # Split the slot around the busy time\n                    if slot_start < busy_start:\n                        updated_free_slots.append((slot_start, busy_start))\n                    if slot_end > busy_end:\n                        updated_free_slots.append((busy_end, slot_end))\n            free_slots = updated_free_slots\n    \n    # Find the first slot that can fit the meeting duration\n    duration_minutes = duration * 60\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    return None\n\n# Define the participants' busy times\namy_busy = [(\"11:00\", \"11:30\"), (\"12:00\", \"12:30\")]\nemma_busy = []\njohn_busy = [(\"10:00\", \"10:30\"), (\"11:30\", \"12:00\"), (\"12:30\", \"16:00\"), (\"16:30\", \"17:00\")]\n\n# Combine all busy times\nparticipants_busy = [amy_busy, emma_busy, john_busy]\n\n# Define work hours and meeting duration\nwork_hours = \"9:00:17:00\"\nduration_hours = 1\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_79"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since midnight\n    michelle_busy = [\n        (9 * 60 + 30, 10 * 60 + 0),\n        (12 * 60 + 30, 13 * 60 + 0)\n    ]\n    billy_busy = [\n        (10 * 60 + 30, 11 * 60 + 0),\n        (11 * 60 + 30, 12 * 60 + 0),\n        (14 * 60 + 30, 15 * 60 + 0),\n        (16 * 60 + 0, 16 * 60 + 30)\n    ]\n    alexis_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (11 * 60 + 0, 12 * 60 + 0),\n        (12 * 60 + 30, 13 * 60 + 0),\n        (13 * 60 + 30, 14 * 60 + 30),\n        (16 * 60 + 0, 16 * 60 + 30)\n    ]\n    alexis_preference_end = 15 * 60  # 15:00 in minutes\n\n    # Generate all possible time slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 1  # Check every minute\n\n    # Check each slot against everyone's busy times and Alexis's preference\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        # Check if slot is before Alexis's preference end time\n        if slot_start >= alexis_preference_end:\n            continue\n        # Check Michelle's availability\n        michelle_available = True\n        for busy_start, busy_end in michelle_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                michelle_available = False\n                break\n        if not michelle_available:\n            continue\n        # Check Billy's availability\n        billy_available = True\n        for busy_start, busy_end in billy_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                billy_available = False\n                break\n        if not billy_available:\n            continue\n        # Check Alexis's availability\n        alexis_available = True\n        for busy_start, busy_end in alexis_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                alexis_available = False\n                break\n        if not alexis_available:\n            continue\n        # If all checks passed, return this slot\n        start_hh = slot_start // 60\n        start_mm = slot_start % 60\n        end_hh = slot_end // 60\n        end_mm = slot_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_80"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 9:00 (540 minutes)\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes  # Add back 540 minutes to start from 9:00\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    # Parse work hours\n    work_start, work_end = map(time_to_minutes, work_hours.split(' to '))\n    work_end -= duration  # No meeting can start after this time\n\n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules.values():\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            busy_intervals.append((start, end))\n    busy_intervals.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1] = (last_start, max(last_end, end))\n            else:\n                merged.append((start, end))\n\n    # Find the first available slot\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end and start - prev_end >= duration:\n            meeting_start = prev_end\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n        prev_end = max(prev_end, end)\n    \n    # Check after last busy interval\n    if prev_end <= work_end and work_end + duration - prev_end >= duration:\n        meeting_start = prev_end\n        meeting_end = meeting_start + duration\n        return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"Jeremy\": [\"14:30 to 15:30\"],\n    \"Lawrence\": [\"15:30 to 16:00\", \"16:30 to 17:00\"],\n    \"Helen\": [\n        \"9:30 to 10:00\",\n        \"10:30 to 11:00\",\n        \"11:30 to 12:00\",\n        \"13:00 to 14:00\",\n        \"15:00 to 15:30\",\n        \"16:00 to 17:00\"\n    ]\n}\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nmeeting_duration = 60  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, meeting_duration))\n```",
            "count": "calendar_scheduling_example_81"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes, work_start, work_end):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration = duration_minutes\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start = time_to_minutes(busy[0])\n            end = time_to_minutes(busy[1])\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start_min\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n    \n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nmichael_schedule = [\n    (\"09:30\", \"10:30\"),\n    (\"15:00\", \"15:30\"),\n    (\"16:00\", \"16:30\")\n]\n\neric_schedule = []\n\narthur_schedule = [\n    (\"09:00\", \"12:00\"),\n    (\"13:00\", \"15:00\"),\n    (\"15:30\", \"16:00\"),\n    (\"16:30\", \"17:00\")\n]\n\nparticipants_schedules = [michael_schedule, eric_schedule, arthur_schedule]\nmeeting_duration = 30\nwork_start = \"09:00\"\nwork_end = \"17:00\"\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, meeting_duration, work_start, work_end))\n```",
            "count": "calendar_scheduling_example_82"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{10:00:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    all_busy_intervals = []\n    for busy_intervals in participants_busy_times.values():\n        for interval in busy_intervals:\n            start, end = interval.split(' to ')\n            all_busy_intervals.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in all_busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability of all participants\n    for interval in free_intervals:\n        start, end = interval\n        duration = end - start\n        if duration >= meeting_duration * 60:\n            meeting_end = start + meeting_duration * 60\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' busy times\nparticipants_busy_times = {\n    \"Anthony\": [\"14:00 to 14:30\", \"15:00 to 15:30\"],\n    \"Ronald\": [\"9:00 to 10:00\", \"12:00 to 12:30\", \"13:30 to 14:00\"],\n    \"Jonathan\": [\"9:00 to 10:00\", \"11:00 to 11:30\", \"12:00 to 13:00\", \"14:00 to 14:30\", \"15:00 to 17:00\"]\n}\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 1  # in hours\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration))\n```",
            "count": "calendar_scheduling_example_83"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration):\n    # Convert all time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = map(time_to_minutes, work_hours)\n    duration_minutes = duration * 60\n    \n    # Generate all busy intervals for each participant in minutes\n    busy_intervals = []\n    for person in participants_busy_times:\n        person_intervals = []\n        for interval in participants_busy_times[person]:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            person_intervals.append((start, end))\n        busy_intervals.append(person_intervals)\n    \n    # Combine all busy intervals and sort them\n    all_busy = []\n    for intervals in busy_intervals:\n        all_busy.extend(intervals)\n    all_busy.sort()\n    \n    # Find the earliest available slot\n    current_start = work_start\n    for start, end in all_busy:\n        if start > current_start and start - current_start >= duration_minutes:\n            return f\"{minutes_to_time(current_start)}:{minutes_to_time(current_start + duration_minutes)}\"\n        current_start = max(current_start, end)\n    \n    # Check after the last busy interval\n    if work_end - current_start >= duration_minutes:\n        return f\"{minutes_to_time(current_start)}:{minutes_to_time(current_start + duration_minutes)}\"\n    \n    return \"No available slot found\"\n\n# Define the participants' busy times\nparticipants_busy_times = {\n    \"Kevin\": [\"9:30 to 10:00\", \"10:30 to 11:00\", \"15:00 to 16:00\"],\n    \"Ryan\": [\"10:30 to 11:30\", \"12:30 to 13:00\", \"13:30 to 14:00\"],\n    \"Eugene\": [\"9:00 to 9:30\", \"10:00 to 11:00\", \"12:30 to 17:00\"]\n}\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 1  # in hours\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_84"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define busy intervals in minutes since midnight\n    # Kelly is free all day, so no busy intervals\n    kelly_busy = []\n    \n    # Julia's busy intervals\n    julia_busy = [\n        (9 * 60 + 30, 10 * 60),      # 9:30-10:00\n        (14 * 60, 14 * 60 + 30),     # 14:00-14:30\n        (15 * 60, 15 * 60 + 30),     # 15:00-15:30\n        (16 * 60 + 30, 17 * 60)      # 16:30-17:00\n    ]\n    # Julia's preference: not after 13:30 (so before 13:30)\n    julia_preference_end = 13 * 60 + 30  # 13:30 in minutes\n    \n    # Martha's busy intervals\n    martha_busy = [\n        (9 * 60, 11 * 60),           # 9:00-11:00\n        (12 * 60, 15 * 60)           # 12:00-15:00\n    ]\n    \n    # Combine all busy intervals for all participants\n    # Since Kelly is free, we only need to consider Julia and Martha\n    all_busy = julia_busy + martha_busy\n    \n    # Generate potential slots\n    potential_slots = []\n    current_start = work_start\n    \n    while current_start + meeting_duration <= work_end:\n        current_end = current_start + meeting_duration\n        slot_valid = True\n        \n        # Check if the slot overlaps with any busy interval\n        for busy_start, busy_end in all_busy:\n            if not (current_end <= busy_start or current_start >= busy_end):\n                slot_valid = False\n                break\n        \n        # Also check Julia's preference (must start and end before 13:30)\n        if current_start >= julia_preference_end:\n            slot_valid = False\n        \n        if slot_valid:\n            potential_slots.append((current_start, current_end))\n        \n        current_start += 15  # Check every 15 minutes for efficiency\n    \n    # Select the first valid slot\n    if potential_slots:\n        meeting_start, meeting_end = potential_slots[0]\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No valid slot found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_85"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for person in schedules:\n        for interval in schedules[person]:\n            start, end = interval.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            busy_intervals.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find free intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Find the first free interval that can fit the meeting\n    for start, end in free_intervals:\n        if end - start >= duration * 60:\n            meeting_start = start\n            meeting_end = meeting_start + duration * 60\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define schedules and constraints\nschedules = {\n    \"Samuel\": [\n        \"9:00 to 9:30\",\n        \"10:00 to 10:30\",\n        \"12:00 to 12:30\",\n        \"14:00 to 15:00\",\n        \"16:00 to 16:30\"\n    ],\n    \"Emma\": [],\n    \"Brittany\": [\n        \"11:30 to 14:30\",\n        \"15:00 to 15:30\",\n        \"16:30 to 17:00\"\n    ]\n}\nwork_hours = \"9:00 to 17:00\"\nduration = 1  # in hours\n\n# Find and print the meeting time\nprint(find_meeting_time(schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_86"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, duration, work_hours):\n    # Convert all time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    all_busy = []\n    for person in participants_busy.values():\n        for interval in person:\n            start, end = interval.split(' to ')\n            all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Merge overlapping or adjacent free intervals (though sorting should prevent overlaps)\n    merged = []\n    for start, end in free_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1] = (last_start, end)\n            else:\n                merged.append((start, end))\n    \n    # Check each free interval for sufficient duration\n    duration_min = duration * 60\n    for start, end in merged:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' busy times\nparticipants_busy = {\n    \"Brittany\": [\"12:00 to 13:30\", \"14:30 to 15:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"],\n    \"Wayne\": [\"9:30 to 10:00\", \"13:00 to 15:00\", \"16:30 to 17:00\"],\n    \"Charles\": [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:30 to 13:30\", \"14:30 to 16:30\"]\n}\n\n# Meeting duration in hours (0.5 hours = 30 minutes)\nmeeting_duration = 0.5\n\n# Work hours\nwork_hours = \"9:00 to 17:00\"\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, meeting_duration, work_hours))\n```",
            "count": "calendar_scheduling_example_87"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:30}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Parse work hours\n    work_start, work_end = work_hours.split(' to ')\n    work_start = int(work_start.split(':')[0]) * 60 + int(work_start.split(':')[1])\n    work_end = int(work_end.split(':')[0]) * 60 + int(work_end.split(':')[1])\n    \n    # Initialize busy slots for all participants\n    busy_slots = []\n    \n    # Process each participant's schedule\n    for schedule in participents_schedules:\n        participant_busy = []\n        for busy in schedule.split('; '):\n            if 'to' in busy:\n                start, end = busy.split(' to ')\n                start_time = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n                end_time = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n                participant_busy.append((start_time, end_time))\n        busy_slots.append(participant_busy)\n    \n    # Find all available slots\n    available_slots = []\n    current_time = work_start\n    \n    while current_time + duration <= work_end:\n        slot_available = True\n        slot_end = current_time + duration\n        \n        # Check if the slot is available for all participants\n        for participant in busy_slots:\n            for busy_start, busy_end in participant:\n                if not (slot_end <= busy_start or current_time >= busy_end):\n                    slot_available = False\n                    break\n            if not slot_available:\n                break\n        \n        if slot_available:\n            available_slots.append((current_time, slot_end))\n        \n        current_time += 15  # Check in 15-minute increments\n    \n    if not available_slots:\n        return None\n    \n    # Return the first available slot\n    first_slot = available_slots[0]\n    start_hour = first_slot[0] // 60\n    start_min = first_slot[0] % 60\n    end_hour = first_slot[1] // 60\n    end_min = first_slot[1] % 60\n    \n    return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n\n# Define the problem\nparticipants_schedules = [\n    \"\",  # Dennis has no meetings\n    \"9:00 to 9:30; 12:30 to 13:00\",  # Joseph\n    \"9:00 to 10:30; 11:30 to 12:00; 13:30 to 14:00; 14:30 to 17:00\"  # Isabella\n]\nwork_hours = \"9:00 to 17:00\"\nduration = 60  # 1 hour in minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_88"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:00:16:00}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 (9:00)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Initialize the free slots for all participants\n    free_slots = []\n    for schedule in participents_schedules:\n        busy = []\n        for block in schedule:\n            start, end = block.split(' to ')\n            busy.append((time_to_minutes(start), time_to_minutes(end)))\n        # Sort busy intervals\n        busy.sort()\n        # Calculate free intervals\n        free = []\n        prev_end = work_start\n        for start, end in busy:\n            if start > prev_end:\n                free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            free.append((prev_end, work_end))\n        free_slots.append(free)\n    \n    # Find common free slots\n    common_free = free_slots[0]\n    for slots in free_slots[1:]:\n        new_common = []\n        i = j = 0\n        while i < len(common_free) and j < len(slots):\n            start1, end1 = common_free[i]\n            start2, end2 = slots[j]\n            # Find the overlap\n            start = max(start1, start2)\n            end = min(end1, end2)\n            if start < end:\n                new_common.append((start, end))\n            # Move the pointer which ends first\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free = new_common\n    \n    # Find the first slot that can fit the duration\n    for start, end in common_free:\n        if end - start >= duration:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define the schedules\nmichelle_schedule = [\"11:00 to 12:00\", \"14:00 to 15:00\"]\nandrea_schedule = [\"9:00 to 9:30\", \"11:30 to 12:30\", \"13:30 to 14:00\", \"14:30 to 15:00\", \"16:00 to 16:30\"]\ndouglas_schedule = [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:00 to 15:00\", \"16:00 to 17:00\"]\n\nparticipants_schedules = [michelle_schedule, andrea_schedule, douglas_schedule]\nwork_hours = \"9:00 to 17:00\"\nduration = 60  # 1 hour in minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_89"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    adam_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    willie_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    gloria_busy = [\n        (9 * 60 + 30, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    # Gloria's preference: avoid after 15:30 (i.e., 15 * 60 + 30)\n    gloria_preference_end = 15 * 60 + 30\n\n    # Generate all possible slots and check availability\n    for start in range(work_start, work_end - meeting_duration + 1, 15):  # Check every 15 minutes\n        end = start + meeting_duration\n        # Check if the slot is within Gloria's preference\n        if end > gloria_preference_end:\n            continue\n        # Check Adam's availability\n        adam_available = True\n        for busy_start, busy_end in adam_busy:\n            if not (end <= busy_start or start >= busy_end):\n                adam_available = False\n                break\n        if not adam_available:\n            continue\n        # Check Willie's availability\n        willie_available = True\n        for busy_start, busy_end in willie_busy:\n            if not (end <= busy_start or start >= busy_end):\n                willie_available = False\n                break\n        if not willie_available:\n            continue\n        # Check Gloria's availability\n        gloria_available = True\n        for busy_start, busy_end in gloria_busy:\n            if not (end <= busy_start or start >= busy_end):\n                gloria_available = False\n                break\n        if not gloria_available:\n            continue\n        # If all are available, return the slot\n        start_time = f\"{start // 60:02d}:{start % 60:02d}\"\n        end_time = f\"{end // 60:02d}:{end % 60:02d}\"\n        return f\"{start_time}:{end_time}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_90"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:14:00}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert work hours and meeting times to minutes for easier calculation\n    work_start, work_end = work_hours\n    work_start_min = work_start[0] * 60 + work_start[1]\n    work_end_min = work_end[0] * 60 + work_end[1]\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    busy_intervals = []\n    \n    for person in participents_schedules:\n        for meeting in participents_schedules[person]:\n            start, end = meeting\n            start_min = start[0] * 60 + start[1]\n            end_min = end[0] * 60 + end[1]\n            busy_intervals.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    previous_end = work_start_min\n    \n    for start, end in merged:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy interval\n    if previous_end < work_end_min:\n        available_slots.append((previous_end, work_end_min))\n    \n    # Find the first available slot that can fit the duration\n    duration_min = duration * 60\n    for start, end in available_slots:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return None\n\n# Define the participants' schedules\nparticipants_schedules = {\n    \"Danielle\": [\n        ((9, 0), (10, 0)),\n        ((10, 30), (11, 0)),\n        ((14, 30), (15, 0)),\n        ((15, 30), (16, 0)),\n        ((16, 30), (17, 0))\n    ],\n    \"Bruce\": [\n        ((11, 0), (11, 30)),\n        ((12, 30), (13, 0)),\n        ((14, 0), (14, 30)),\n        ((15, 30), (16, 0))\n    ],\n    \"Eric\": [\n        ((9, 0), (9, 30)),\n        ((10, 0), (11, 0)),\n        ((11, 30), (13, 0)),\n        ((14, 30), (15, 30))\n    ]\n}\n\n# Define work hours and meeting duration\nwork_hours = ((9, 0), (17, 0))\nduration = 1  # in hours\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_91"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can accommodate the meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define the participants' schedules\njacqueline_schedule = [\"9:30 to 10:00\", \"16:30 to 17:00\"]\nhenry_schedule = []  # Free all day\nwilliam_schedule = [\"9:30 to 10:30\", \"12:30 to 15:00\", \"15:30 to 17:00\"]\n\nparticipants_schedules = [jacqueline_schedule, henry_schedule, william_schedule]\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 60  # 1 hour\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes))\n```",
            "count": "calendar_scheduling_example_92"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert all time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for busy_slots in participants_busy.values():\n        for slot in busy_slots:\n            start, end = slot.split(' to ')\n            busy_intervals.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for a slot that can fit the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' busy times\nparticipants_busy = {\n    \"Austin\": [\"10:30 to 11:00\", \"13:30 to 14:00\"],\n    \"Danielle\": [\"9:00 to 10:00\", \"11:00 to 12:00\", \"13:00 to 13:30\", \"15:30 to 16:00\"],\n    \"Charles\": [\"9:00 to 11:30\", \"12:00 to 12:30\", \"13:00 to 17:00\"],\n}\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nmeeting_duration = 30  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, work_hours, meeting_duration))\n```",
            "count": "calendar_scheduling_example_93"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' schedules and constraints\n    # Nicholas is free all day\n    nicholas_free = [(work_start, work_end)]\n\n    # Elizabeth's meetings in minutes\n    elizabeth_meetings = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60 + 30, 14 * 60 + 30),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    elizabeth_free = []\n    prev_end = work_start\n    for start, end in sorted(elizabeth_meetings):\n        if start > prev_end:\n            elizabeth_free.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        elizabeth_free.append((prev_end, work_end))\n\n    # Sandra's meetings in minutes and constraint (not before 13:00)\n    sandra_meetings = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 13 * 60 + 30),\n        (15 * 60 + 30, 16 * 60 + 30)\n    ]\n    sandra_free = []\n    prev_end = max(work_start, 13 * 60)  # Sandra can't meet before 13:00\n    for start, end in sorted(sandra_meetings):\n        if start > prev_end:\n            sandra_free.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        sandra_free.append((prev_end, work_end))\n\n    # Find overlapping free times for all participants\n    common_free = []\n    i = j = k = 0\n    while i < len(nicholas_free) and j < len(elizabeth_free) and k < len(sandra_free):\n        n_start, n_end = nicholas_free[i]\n        e_start, e_end = elizabeth_free[j]\n        s_start, s_end = sandra_free[k]\n\n        # Find the overlapping start and end\n        overlap_start = max(n_start, e_start, s_start)\n        overlap_end = min(n_end, e_end, s_end)\n\n        if overlap_start < overlap_end:\n            common_free.append((overlap_start, overlap_end))\n        \n        # Move the pointer which has the earliest end time\n        if n_end <= e_end and n_end <= s_end:\n            i += 1\n        elif e_end <= n_end and e_end <= s_end:\n            j += 1\n        else:\n            k += 1\n\n    # Find the first slot that can accommodate a 30-minute meeting\n    meeting_duration = 30\n    for slot in common_free:\n        start, end = slot\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_94"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' schedules and constraints in minutes\n    jennifer_busy = [\n        (12 * 60, 12 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    jennifer_preference = 12 * 60 + 30  # Not before 12:30\n\n    gary_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n\n    frances_busy = [\n        (9 * 60, 11 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (13 * 60, 17 * 60)\n    ]\n\n    # Duration of the meeting in minutes\n    duration = 30\n\n    # Generate all possible time slots\n    possible_slots = []\n    current_time = work_start\n\n    while current_time + duration <= work_end:\n        slot_end = current_time + duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 30  # Check every 30 minutes\n\n    # Check each slot against all constraints\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n\n        # Check Jennifer's availability and preference\n        jennifer_available = True\n        for busy_start, busy_end in jennifer_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                jennifer_available = False\n                break\n        if slot_start < jennifer_preference:\n            jennifer_available = False\n\n        # Check Gary's availability\n        gary_available = True\n        for busy_start, busy_end in gary_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                gary_available = False\n                break\n\n        # Check Frances' availability\n        frances_available = True\n        for busy_start, busy_end in frances_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                frances_available = False\n                break\n\n        # If all are available, return the slot\n        if jennifer_available and gary_available and frances_available:\n            # Convert minutes back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_95"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:9:30}",
            "type_error": "TypeError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # 9:00 is 540 minutes\n    \n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes  # Convert back to absolute minutes\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    start_min = time_to_minutes(start_work)\n    end_min = time_to_minutes(end_work)\n    \n    # Initialize a list to mark busy times\n    busy = [False] * (end_min - start_min)\n    \n    # Mark busy times for each participant\n    for schedule in participants_schedules:\n        for busy_range in schedule:\n            start, end = busy_range.split(' to ')\n            start_busy = time_to_minutes(start)\n            end_busy = time_to_minutes(end)\n            # Mark the range in the busy list\n            for i in range(max(0, start_busy - start_min), min(len(busy), end_busy - start_min)):\n                busy[i] = True\n    \n    # Find a free slot of duration minutes\n    duration_min = duration * 60  # Convert hours to minutes\n    current_start = 0\n    while current_start < len(busy):\n        if not busy[current_start]:\n            # Check if the next 'duration_min' slots are free\n            slot_available = True\n            for i in range(current_start, min(current_start + duration_min, len(busy))):\n                if busy[i]:\n                    slot_available = False\n                    current_start = i + 1\n                    break\n            if slot_available and (current_start + duration_min) <= len(busy):\n                end_slot = current_start + duration_min\n                start_time = minutes_to_time(current_start + start_min)\n                end_time = minutes_to_time(end_slot + start_min)\n                return f\"{start_time}:{end_time}\"\n        else:\n            current_start += 1\n    return \"No available slot found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"9:30 to 10:00\", \"10:30 to 11:00\", \"11:30 to 13:00\", \"15:00 to 15:30\"],  # Christopher\n    [\"9:30 to 10:00\", \"11:00 to 11:30\", \"12:00 to 12:30\", \"13:30 to 14:30\", \"15:00 to 15:30\"],  # Robert\n    [\"10:00 to 17:00\"]  # Wayne\n]\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nduration = 0.5  # half an hour\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_96"
        },
        {
            "final_program_time": "{16:00:17:00}",
            "expected_time": "{16:00:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n    \n    # Convert each person's busy slots to minutes since midnight\n    joseph_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60 + 30, 15 * 60 + 30)\n    ]\n    kyle_busy = [\n        (12 * 60 + 30, 13 * 60 + 30)\n    ]\n    joan_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    \n    # Joseph's constraint: not before 14:30\n    joseph_constraint = 14 * 60 + 30\n    \n    # Combine all busy slots\n    all_busy = []\n    for busy in [joseph_busy, kyle_busy, joan_busy]:\n        all_busy.extend(busy)\n    \n    # Sort busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that fits the meeting duration and Joseph's constraint\n    for start, end in free_slots:\n        slot_start = max(start, joseph_constraint)\n        if end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_97"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define busy intervals in minutes for each participant\n    juan_busy = [(9 * 60, 10 * 60 + 30), (15 * 60 + 30, 16 * 60)]\n    marilyn_busy = [(11 * 60, 11 * 60 + 30), (12 * 60 + 30, 13 * 60)]\n    ronald_busy = [(9 * 60, 10 * 60 + 30), (12 * 60, 12 * 60 + 30), \n                   (13 * 60, 13 * 60 + 30), (14 * 60, 16 * 60 + 30)]\n    \n    # Juan cannot meet after 16:00\n    juan_limit = 16 * 60\n    \n    # Combine all busy intervals and sort them\n    all_busy = juan_busy + marilyn_busy + ronald_busy\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy intervals\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the time after the last busy interval\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Check each free slot for a 30-minute window that fits all constraints\n    meeting_duration = 30\n    for slot_start, slot_end in free_slots:\n        current_start = slot_start\n        while current_start + meeting_duration <= slot_end:\n            # Check if the meeting fits and respects Juan's limit\n            if current_start + meeting_duration <= juan_limit:\n                return (\n                    f\"{current_start // 60:02d}:{current_start % 60:02d}:\"\n                    f\"{(current_start + meeting_duration) // 60:02d}:{(current_start + meeting_duration) % 60:02d}\"\n                )\n            current_start += 1  # Move to the next minute\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_98"
        },
        {
            "final_program_time": "{15:00:16:00}",
            "expected_time": "{15:00:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Define each person's busy times in minutes since midnight\n    stephanie_busy = [(9 * 60, 9 * 60 + 30), (13 * 60 + 30, 14 * 60)]\n    scott_busy = [(9 * 60, 10 * 60), (11 * 60, 12 * 60 + 30), (14 * 60 + 30, 15 * 60), (16 * 60, 17 * 60)]\n    mark_preference = (15 * 60, work_end)  # Mark prefers after 15:00\n\n    # Combine all busy times and sort\n    all_busy = stephanie_busy + scott_busy\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy times and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Filter free slots that meet the duration and Mark's preference\n    valid_slots = []\n    for start, end in free_slots:\n        slot_start = max(start, mark_preference[0])\n        slot_end = min(end, mark_preference[1])\n        if slot_end - slot_start >= meeting_duration:\n            valid_slots.append((slot_start, slot_end))\n\n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Format the output as HH:MM:HH:MM\n        return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    else:\n        return \"No valid time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_99"
        },
        {
            "final_program_time": "{11:00:12:00}",
            "expected_time": "{11:00:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy times for all participants\n    all_busy_times = []\n    for busy_times in participants_busy_times:\n        for start, end in busy_times:\n            all_busy_times.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy times by start time\n    all_busy_times.sort()\n    \n    # Find free slots by checking gaps between busy times and work hours\n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy_times:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Check each free slot for availability of duration\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' busy times\ndenise_busy = []\njoseph_busy = []\nhenry_busy = [(\"09:00\", \"09:30\"), (\"10:00\", \"10:30\"), (\"12:00\", \"14:30\"), (\"15:00\", \"16:00\"), (\"16:30\", \"17:00\")]\nchristian_busy = [(\"09:00\", \"11:00\"), (\"14:30\", \"15:30\"), (\"16:00\", \"17:00\")]\n\nparticipants_busy_times = [denise_busy, joseph_busy, henry_busy, christian_busy]\n\n# Define work hours and meeting duration\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 60  # 1 hour\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_100"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    start, end = work_hours\n    # Convert time strings to minutes since 9:00 for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 9 * 60  # Offset by 9:00 (540 minutes)\n\n    def minutes_to_time(minutes):\n        total_minutes = 9 * 60 + minutes\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    # Initialize the free slots for all participants\n    free_slots = []\n    for schedule in participants_schedules:\n        busy = []\n        for block in schedule:\n            s, e = block.split(' to ')\n            busy.append((time_to_minutes(s), time_to_minutes(e)))\n        # Generate free slots by finding gaps between busy blocks\n        free = []\n        prev_end = 0\n        for s, e in sorted(busy):\n            if s > prev_end:\n                free.append((prev_end, s))\n            prev_end = max(prev_end, e)\n        if prev_end < time_to_minutes(end):\n            free.append((prev_end, time_to_minutes(end)))\n        free_slots.append(free)\n\n    # Find overlapping free slots across all participants\n    common_free = free_slots[0]\n    for slots in free_slots[1:]:\n        new_common = []\n        i = j = 0\n        while i < len(common_free) and j < len(slots):\n            s1, e1 = common_free[i]\n            s2, e2 = slots[j]\n            # Find the overlap\n            overlap_s = max(s1, s2)\n            overlap_e = min(e1, e2)\n            if overlap_s < overlap_e:\n                new_common.append((overlap_s, overlap_e))\n            # Move the pointer which ends first\n            if e1 < e2:\n                i += 1\n            else:\n                j += 1\n        common_free = new_common\n\n    # Find the first slot that can fit the duration\n    for slot in common_free:\n        s, e = slot\n        if e - s >= duration:\n            meeting_start = minutes_to_time(s)\n            meeting_end = minutes_to_time(s + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n\n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"10:00 to 10:30\", \"14:30 to 15:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"],  # Madison\n    [],  # Linda\n    [\"9:00 to 12:00\", \"12:30 to 16:00\", \"16:30 to 17:00\"],  # Logan\n    [\"9:30 to 11:00\", \"11:30 to 12:00\", \"13:00 to 14:30\", \"15:00 to 15:30\", \"16:00 to 17:00\"],  # Virginia\n]\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_hours = (\"9:00\", \"17:00\")\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, duration, work_hours))\n```",
            "count": "calendar_scheduling_example_101"
        },
        {
            "final_program_time": "{11:00:12:00}",
            "expected_time": "{11:00:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert all schedules to minutes for easier comparison\n    # Each person's busy times are represented as (start, end) in minutes\n    dylan_busy = [(14 * 60, 15 * 60)]\n    kathryn_busy = [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30)]\n    hannah_busy = [(9 * 60, 10 * 60 + 30), (12 * 60 + 30, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)]\n    anna_busy = [(9 * 60, 11 * 60), (12 * 60, 14 * 60), (14 * 60 + 30, 15 * 60), (16 * 60, 16 * 60 + 30)]\n    \n    # Combine all busy times and sort them\n    all_busy = dylan_busy + kathryn_busy + hannah_busy + anna_busy\n    all_busy.sort()\n    \n    # Find the earliest available slot of 60 minutes\n    current_time = work_start\n    meeting_duration = 60\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > current_time:\n            if busy_start - current_time >= meeting_duration:\n                # Found a slot\n                end_time = current_time + meeting_duration\n                return f\"{current_time // 60:02d}:{current_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n        # Update current_time to the end of the busy period if it's later\n        if busy_end > current_time:\n            current_time = busy_end\n    \n    # Check the remaining time after the last busy period\n    if work_end - current_time >= meeting_duration:\n        end_time = current_time + meeting_duration\n        return f\"{current_time // 60:02d}:{current_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n    \n    # If no slot found (though the problem states there is one)\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_102"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all blocked time slots\n    blocked_slots = []\n    for schedule in participants_schedules:\n        for slot in schedule:\n            start, end = map(time_to_minutes, slot.split(' to '))\n            blocked_slots.append((start, end))\n    \n    # Sort blocked slots by start time\n    blocked_slots.sort()\n    \n    # Find available slots by checking gaps between blocked slots and work hours\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in blocked_slots:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Check each available slot for duration\n    duration = duration_minutes\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\ndiane_schedule = [\"9:30 to 10:00\", \"14:30 to 15:00\"]\njack_schedule = [\"13:30 to 14:00\", \"14:30 to 15:00\"]\neugene_schedule = [\"9:00 to 10:00\", \"10:30 to 11:30\", \"12:00 to 14:30\", \"15:00 to 16:30\"]\npatricia_schedule = [\"9:30 to 10:30\", \"11:00 to 12:00\", \"12:30 to 14:00\", \"15:00 to 16:30\"]\n\nall_schedules = [diane_schedule, jack_schedule, eugene_schedule, patricia_schedule]\n\n# Find meeting time\nmeeting_time = find_meeting_time(all_schedules, \"9:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_103"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time strings to minutes since 9:00 (work_hours_start)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - work_hours_start) * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = work_hours_start + (minutes // 60)\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        person_busy = []\n        for block in schedule:\n            start, end = block.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            person_busy.append((start_min, end_min))\n        busy_intervals.append(person_busy)\n    \n    # Find the earliest and latest possible times in minutes\n    earliest_start = 0\n    latest_end = (work_hours_end - work_hours_start) * 60\n    \n    # Generate all possible time slots and check for availability\n    for start in range(earliest_start, latest_end - duration_minutes + 1):\n        end = start + duration_minutes\n        if end > latest_end:\n            continue\n        # Check if the slot is free for all participants\n        all_free = True\n        for person_busy in busy_intervals:\n            person_free = True\n            for (busy_start, busy_end) in person_busy:\n                if not (end <= busy_start or start >= busy_end):\n                    person_free = False\n                    break\n            if not person_free:\n                all_free = False\n                break\n        if all_free:\n            start_time = minutes_to_time(start)\n            end_time = minutes_to_time(end)\n            return f\"{start_time}:{end_time}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"9:00 to 10:30\", \"16:30 to 17:00\"],  # Karen\n    [\"9:30 to 10:00\", \"10:30 to 11:00\", \"11:30 to 12:30\", \"15:30 to 16:00\", \"16:30 to 17:00\"],  # Brandon\n    [\"9:00 to 10:30\", \"11:00 to 14:00\", \"14:30 to 17:00\"],  # Donald\n    [\"9:00 to 9:30\", \"10:30 to 11:00\", \"11:30 to 12:00\", \"13:30 to 14:00\", \"14:30 to 15:30\", \"16:00 to 17:00\"]  # Kelly\n]\n\n# Define work hours and meeting duration\nwork_hours_start = 9\nwork_hours_end = 17\nduration_minutes = 30\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_104"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between merged intervals and work hours\n    available = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n    \n    # Check each available slot for the first that can fit the duration\n    duration_min = duration * 60\n    for start, end in available:\n        if end - start >= duration_min:\n            meeting_end = start + duration_min\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules\njason_schedule = [\n    \"9:00 to 10:00\",\n    \"10:30 to 11:00\",\n    \"11:30 to 12:00\",\n    \"12:30 to 13:00\",\n    \"14:00 to 14:30\"\n]\n\nwilliam_schedule = [\n    \"9:00 to 9:30\",\n    \"11:30 to 12:00\",\n    \"14:00 to 14:30\",\n    \"16:30 to 17:00\"\n]\n\nfrances_schedule = [\n    \"9:00 to 9:30\",\n    \"10:00 to 10:30\",\n    \"11:00 to 12:30\",\n    \"13:30 to 16:00\"\n]\n\nrachel_schedule = [\n    \"9:00 to 9:30\",\n    \"10:00 to 10:30\",\n    \"11:00 to 14:00\",\n    \"14:30 to 16:00\",\n    \"16:30 to 17:00\"\n]\n\n# Combine all schedules\nparticipants_schedules = [jason_schedule, william_schedule, frances_schedule, rachel_schedule]\n\n# Find a meeting time\nmeeting_time = find_meeting_time(participants_schedules, 30, \"9:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_105"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{10:00:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n    \n    # Check each available slot for sufficient duration\n    for slot in available:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"12:30 to 13:30\", \"14:30 to 15:00\", \"16:30 to 17:00\"],  # Olivia\n    [],  # Anna\n    [\"09:00 to 10:00\", \"11:30 to 16:00\", \"16:30 to 17:00\"],  # Virginia\n    [\"09:00 to 09:30\", \"11:00 to 11:30\", \"13:00 to 14:00\", \"14:30 to 16:00\", \"16:30 to 17:00\"],  # Paul\n]\n\n# Define meeting parameters\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 60  # 1 hour\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_106"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert all time strings to minutes since 9:00 (work_hours_start)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - work_hours_start * 60\n\n    work_hours_start_min = time_to_minutes(f\"{work_hours_start}:00\")\n    work_hours_end_min = time_to_minutes(f\"{work_hours_end}:00\")\n\n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append([start, end])\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1][1] = max(end, last_end)\n            else:\n                merged.append([start, end])\n\n    # Check the available slots before first busy interval, between intervals, and after last busy interval\n    available_slots = []\n    prev_end = work_hours_start_min\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = end\n    if prev_end < work_hours_end_min:\n        available_slots.append((prev_end, work_hours_end_min))\n\n    # Find the first available slot that can fit the meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = (minutes + work_hours_start * 60) // 60\n                mm = (minutes + work_hours_start * 60) % 60\n                return f\"{hh:02d}:{mm:02d}\"\n\n            meeting_start = minutes_to_time(slot_start)\n            meeting_end = minutes_to_time(slot_start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n\n    return \"No available slot found\"\n\n# Define the participants' schedules\npeter_schedule = [\n    \"9:00 to 9:30\",\n    \"10:30 to 11:00\",\n    \"11:30 to 12:00\",\n    \"12:30 to 13:00\"\n]\njudith_schedule = []\nkeith_schedule = [\n    \"11:30 to 12:00\",\n    \"12:30 to 15:00\",\n    \"15:30 to 16:00\",\n    \"16:30 to 17:00\"\n]\nevelyn_schedule = [\n    \"9:00 to 12:30\",\n    \"13:30 to 15:30\",\n    \"16:30 to 17:00\"\n]\n\nparticipants_schedules = [peter_schedule, judith_schedule, keith_schedule, evelyn_schedule]\nmeeting_duration = 30  # minutes\nwork_hours_start = 9\nwork_hours_end = 17\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, meeting_duration, work_hours_start, work_hours_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_107"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each person's busy slots to minutes\n    # Lisa's busy slots: 9:00-9:30, 10:00-10:30, 13:00-14:00, 15:00-16:00\n    lisa_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (13 * 60, 14 * 60),\n        (15 * 60, 16 * 60)\n    ]\n    \n    # Dorothy's busy slots: 9:00-9:30, 10:30-11:30, 13:30-14:00, 14:30-15:30\n    dorothy_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 11 * 60 + 30),\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60 + 30)\n    ]\n    \n    # Anthony's busy slots: 9:00-10:00, 11:00-12:30, 13:00-14:00, 15:00-16:30\n    anthony_busy = [\n        (9 * 60, 10 * 60),\n        (11 * 60, 12 * 60 + 30),\n        (13 * 60, 14 * 60),\n        (15 * 60, 16 * 60 + 30)\n    ]\n    \n    # Ryan's busy slots: 9:00-12:30, 13:00-16:30\n    ryan_busy = [\n        (9 * 60, 12 * 60 + 30),\n        (13 * 60, 16 * 60 + 30)\n    ]\n    \n    # Lisa cannot meet before 14:30\n    lisa_constraint = 14 * 60 + 30\n    \n    # Meeting duration is 30 minutes\n    duration = 30\n    \n    # Generate all possible slots and check for availability\n    for start in range(work_start, work_end - duration + 1, 15):  # Check every 15 minutes\n        end = start + duration\n        # Check Lisa's constraints\n        if start < lisa_constraint:\n            continue\n        # Check if the slot is free for everyone\n        lisa_free = all(not (s < end and e > start) for s, e in lisa_busy)\n        dorothy_free = all(not (s < end and e > start) for s, e in dorothy_busy)\n        anthony_free = all(not (s < end and e > start) for s, e in anthony_busy)\n        ryan_free = all(not (s < end and e > start) for s, e in ryan_busy)\n        \n        if lisa_free and dorothy_free and anthony_free and ryan_free:\n            # Convert start and end back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = end // 60\n            end_mm = end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_108"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy blocks to minutes since 9:00\n    marie_busy = [(11*60, 11*60 + 30), (15*60, 16*60 + 30)]\n    janice_busy = [(12*60 + 30, 13*60), (13*60 + 30, 15*60)]\n    elijah_busy = [(10*60, 13*60), (14*60 + 30, 15*60), (16*60, 16*60 + 30)]\n    theresa_busy = [(9*60 + 30, 10*60 + 30), (12*60, 13*60), (13*60 + 30, 14*60),\n                    (14*60 + 30, 15*60), (15*60 + 30, 16*60), (16*60 + 30, 17*60)]\n    theresa_no_meet_after = 12 * 60  # No meetings after 12:00\n\n    # Generate all possible 30-minute slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 1  # Check every minute for availability\n\n    # Check each slot against everyone's constraints\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n\n        # Check Theresa's preference (no meetings after 12:00)\n        if slot_start >= theresa_no_meet_after:\n            continue\n\n        # Check Marie's availability\n        marie_available = True\n        for busy_start, busy_end in marie_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                marie_available = False\n                break\n        if not marie_available:\n            continue\n\n        # Check Janice's availability\n        janice_available = True\n        for busy_start, busy_end in janice_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                janice_available = False\n                break\n        if not janice_available:\n            continue\n\n        # Check Elijah's availability\n        elijah_available = True\n        for busy_start, busy_end in elijah_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                elijah_available = False\n                break\n        if not elijah_available:\n            continue\n\n        # Check Theresa's availability\n        theresa_available = True\n        for busy_start, busy_end in theresa_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                theresa_available = False\n                break\n        if not theresa_available:\n            continue\n\n        # If all checks passed, return this slot\n        start_h = slot_start // 60\n        start_m = slot_start % 60\n        end_h = slot_end // 60\n        end_m = slot_end % 60\n        return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n\n    return \"No suitable time found\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_109"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define each person's busy times in minutes (start, end)\n    helen_busy = [\n        (9 * 60, 12 * 60),\n        (12 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    ashley_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    grace_preference_end = 15 * 60  # Grace prefers no meetings after 15:00\n\n    # Combine all busy times for Helen and Ashley\n    combined_busy = helen_busy + ashley_busy\n    # Sort by start time\n    combined_busy.sort()\n\n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = work_start\n\n    for busy_start, busy_end in combined_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    # Check the time after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Filter free slots that are at least 30 minutes and before Grace's preference\n    possible_slots = []\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= 30 and slot_start < grace_preference_end:\n            possible_slots.append((slot_start, slot_end))\n\n    # Select the earliest possible slot\n    if possible_slots:\n        meeting_start = possible_slots[0][0]\n        meeting_end = meeting_start + 30\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_110"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:00:12:30}",
            "type_error": "SyntaxError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours=('09:00', '17:00')):\n    # Convert time strings to minutes since 00:00 for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start, work_end = map(time_to_minutes, work_hours)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    \n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            all_busy.append((time_to_minutes(busy_start), time_to_minutes(busy_end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append([start, end])\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = [new_start, new_end]\n            else:\n                merged_busy.append([start, end])\n    \n    # Find available slots by looking at gaps between busy intervals\n    available_slots = []\n    previous_end = work_start\n    \n    for start, end in merged_busy:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy interval\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [('09:00', '10:00'), ('10:30', '11:30'), ('12:30', '13:00'), ('13:30', '14:00')],  # Gregory\n    [],  # Natalie\n    [('09:00', '11:30'), ('13:30', '17:00')],  # Christine\n    [('09:00', '09:30'), ('10:30', '12:00'), ('12:30', '14:00'), ('14:30', '17:00')],  # Vincent\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_111"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration_minutes):\n    # Convert work hours and schedules to minutes since start of day\n    work_start, work_end = work_hours\n    work_start_min = work_start[0] * 60 + work_start[1]\n    work_end_min = work_end[0] * 60 + work_end[1]\n    \n    # Initialize the free slots for all participants\n    free_slots = []\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start_min = busy[0][0] * 60 + busy[0][1]\n            end_min = busy[1][0] * 60 + busy[1][1]\n            busy_slots.append((start_min, end_min))\n        \n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Calculate free slots for the participant\n        participant_free = []\n        prev_end = work_start_min\n        for busy_start, busy_end in busy_slots:\n            if busy_start > prev_end:\n                participant_free.append((prev_end, busy_start))\n            prev_end = max(prev_end, busy_end)\n        if prev_end < work_end_min:\n            participant_free.append((prev_end, work_end_min))\n        \n        free_slots.append(participant_free)\n    \n    # Find overlapping free slots across all participants\n    common_free = free_slots[0]\n    for participant_free in free_slots[1:]:\n        new_common_free = []\n        i = j = 0\n        while i < len(common_free) and j < len(participant_free):\n            start1, end1 = common_free[i]\n            start2, end2 = participant_free[j]\n            \n            # Find overlap\n            overlap_start = max(start1, start2)\n            overlap_end = min(end1, end2)\n            \n            if overlap_start < overlap_end:\n                new_common_free.append((overlap_start, overlap_end))\n            \n            # Move the pointer which ends first\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free = new_common_free\n    \n    # Find the first slot that can accommodate the meeting\n    for slot in common_free:\n        start, end = slot\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return None\n\n# Define work hours (9:00 to 17:00)\nwork_hours = ((9, 0), (17, 0))\n\n# Define participants' schedules in HH:MM format converted to tuples\nparticipants_schedules = [\n    # Jean's schedule\n    [\n        ((11, 0), (11, 30)),\n        ((12, 30), (13, 30)),\n        ((14, 0), (14, 30)),\n        ((15, 0), (15, 30)),\n        ((16, 30), (17, 0))\n    ],\n    # Jose's schedule (no meetings)\n    [],\n    # Samuel's schedule\n    [\n        ((9, 0), (12, 0)),\n        ((12, 30), (16, 0)),\n        ((16, 30), (17, 0))\n    ],\n    # Henry's schedule\n    [\n        ((9, 0), (10, 30)),\n        ((14, 0), (14, 30)),\n        ((15, 0), (17, 0))\n    ]\n]\n\n# Meeting duration is 30 minutes\nduration = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_112"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:00:10:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find available slots by merging busy intervals\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nbradley_schedule = [\"9:30:10:00\", \"12:30:13:00\", \"13:30:14:00\", \"15:30:16:00\"]\nteresa_schedule = [\"10:30:11:00\", \"12:00:12:30\", \"13:00:13:30\", \"14:30:15:00\"]\nelizabeth_schedule = [\"9:00:9:30\", \"10:30:11:30\", \"13:00:13:30\", \"14:30:15:00\", \"15:30:17:00\"]\nchristian_schedule = [\"9:00:9:30\", \"10:30:17:00\"]\n\n# Combine all schedules\nparticipants_schedules = [bradley_schedule, teresa_schedule, elizabeth_schedule, christian_schedule]\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, \"9:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_113"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    stephanie_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    cheryl_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    bradley_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 11 * 60 + 30),\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    steven_busy = [\n        (9 * 60, 12 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 17 * 60)\n    ]\n\n    # Combine all busy slots\n    all_busy = []\n    for slot in stephanie_busy:\n        all_busy.append(('Stephanie', slot))\n    for slot in cheryl_busy:\n        all_busy.append(('Cheryl', slot))\n    for slot in bradley_busy:\n        all_busy.append(('Bradley', slot))\n    for slot in steven_busy:\n        all_busy.append(('Steven', slot))\n\n    # Sort all busy slots by start time\n    all_busy.sort(key=lambda x: x[1][0])\n\n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n\n    for person, (start, end) in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check if there's a free slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate 60 minutes\n    meeting_duration = 60\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Check if all participants are free during this slot\n            valid = True\n            # Check Stephanie\n            for s_start, s_end in stephanie_busy:\n                if not (end <= s_start or start >= s_end):\n                    valid = False\n                    break\n            if not valid:\n                continue\n            # Check Cheryl\n            for c_start, c_end in cheryl_busy:\n                if not (end <= c_start or start >= c_end):\n                    valid = False\n                    break\n            if not valid:\n                continue\n            # Check Bradley\n            for b_start, b_end in bradley_busy:\n                if not (end <= b_start or start >= b_end):\n                    valid = False\n                    break\n            if not valid:\n                continue\n            # Check Steven\n            for st_start, st_end in steven_busy:\n                if not (end <= st_start or start >= st_end):\n                    valid = False\n                    break\n            if valid:\n                # Convert minutes back to HH:MM format\n                start_hh = start // 60\n                start_mm = start % 60\n                end_hh = (start + meeting_duration) // 60\n                end_mm = (start + meeting_duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_114"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy times in minutes since midnight\n    busy_times = {\n        'Jose': [],\n        'Catherine': [(12 * 60, 12 * 60 + 30), (15 * 60, 15 * 60 + 30)],\n        'Rachel': [\n            (9 * 60, 9 * 60 + 30),\n            (10 * 60, 11 * 60),\n            (11 * 60 + 30, 12 * 60),\n            (12 * 60 + 30, 13 * 60),\n            (14 * 60, 16 * 60),\n            (16 * 60 + 30, 17 * 60)\n        ],\n        'Lori': [\n            (9 * 60, 12 * 60),\n            (13 * 60, 13 * 60 + 30),\n            (14 * 60 + 30, 15 * 60 + 30),\n            (16 * 60 + 30, 17 * 60)\n        ]\n    }\n    \n    # Catherine's preference: not before 14:00\n    preference_start = 14 * 60\n    \n    # Meeting duration in minutes\n    duration = 30\n    \n    # Generate all possible slots and check availability\n    for start in range(preference_start, work_end - duration + 1, 15):  # Check in 15-minute increments\n        end = start + duration\n        if end > work_end:\n            continue\n        \n        # Check if the slot is free for all participants\n        all_free = True\n        for participant, busy_slots in busy_times.items():\n            for busy_start, busy_end in busy_slots:\n                if not (end <= busy_start or start >= busy_end):\n                    all_free = False\n                    break\n            if not all_free:\n                break\n        \n        if all_free:\n            # Format the time as HH:MM:HH:MM\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = end // 60\n            end_mm = end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_115"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define busy intervals in minutes for each participant\n    adam_busy = [(14 * 60, 15 * 60)]\n    john_busy = [(13 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30), \n                 (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)]\n    stephanie_busy = [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 11 * 60), \n                      (11 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)]\n    anna_busy = [(9 * 60 + 30, 10 * 60), (12 * 60, 12 * 60 + 30), \n                 (13 * 60, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)]\n    \n    # Anna's preference: not before 14:30\n    anna_preference_start = 14 * 60 + 30\n    \n    # Meeting duration in minutes\n    meeting_duration = 30\n    \n    # Generate all possible slots starting from 14:30 to end of work day\n    for start in range(anna_preference_start, work_end - meeting_duration + 1, 15):\n        end = start + meeting_duration\n        # Check if the slot is free for all participants\n        adam_free = all(not (start < busy_end and end > busy_start) for busy_start, busy_end in adam_busy)\n        john_free = all(not (start < busy_end and end > busy_start) for busy_start, busy_end in john_busy)\n        stephanie_free = all(not (start < busy_end and end > busy_start) for busy_start, busy_end in stephanie_busy)\n        anna_free = all(not (start < busy_end and end > busy_start) for busy_start, busy_end in anna_busy)\n        \n        if adam_free and john_free and stephanie_free and anna_free:\n            # Format the time as HH:MM:HH:MM\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = end // 60\n            end_mm = end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_116"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    brian_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (12 * 60, 13 * 60),\n        (14 * 60, 14 * 60 + 30)\n    ]\n    ronald_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    denise_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    jesse_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 13 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n\n    # Jesse's preference: avoid after 15:00\n    jesse_preference_end = 15 * 60\n\n    # Generate all possible slots\n    possible_slots = []\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        # Check if the slot is before Jesse's preference\n        if slot_end > jesse_preference_end:\n            current_time += 1\n            continue\n        # Check if all are free\n        brian_free = all(not (start <= current_time < end or start < slot_end <= end) for start, end in brian_busy)\n        ronald_free = all(not (start <= current_time < end or start < slot_end <= end) for start, end in ronald_busy)\n        denise_free = all(not (start <= current_time < end or start < slot_end <= end) for start, end in denise_busy)\n        jesse_free = all(not (start <= current_time < end or start < slot_end <= end) for start, end in jesse_busy)\n        if brian_free and ronald_free and denise_free and jesse_free:\n            possible_slots.append((current_time, slot_end))\n        current_time += 1\n\n    # Select the first available slot\n    if possible_slots:\n        start, end = possible_slots[0]\n        # Convert back to HH:MM format\n        start_hh = start // 60\n        start_mm = start % 60\n        end_hh = end // 60\n        end_mm = end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_117"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for person in participants_schedules:\n        busy_intervals = []\n        for interval in participants_schedules[person]:\n            start, end = interval.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            busy_intervals.append((start_min, end_min))\n        all_busy_intervals.append(busy_intervals)\n    \n    # Find all possible free intervals for all participants\n    possible_start_times = []\n    \n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        valid = True\n        for busy_intervals in all_busy_intervals:\n            for start, end in busy_intervals:\n                if current_time < end and current_time + meeting_duration > start:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            possible_start_times.append(current_time)\n        current_time += 15  # Check every 15 minutes for efficiency\n    \n    if possible_start_times:\n        first_available = possible_start_times[0]\n        end_time = first_available + meeting_duration\n        return f\"{minutes_to_time(first_available)}:{minutes_to_time(end_time)}\"\n    else:\n        return \"No available time found\"\n\n# Define the participants' schedules\nparticipants_schedules = {\n    'Ruth': ['9:30 to 10:00', '11:00 to 11:30', '12:00 to 12:30', '13:00 to 13:30', '14:30 to 15:00', '16:00 to 16:30'],\n    'Angela': ['9:00 to 9:30', '12:30 to 13:00', '13:30 to 15:00', '16:00 to 16:30'],\n    'Lisa': ['10:30 to 11:00', '11:30 to 14:00', '14:30 to 15:30', '16:00 to 17:00'],\n    'Cheryl': ['9:00 to 10:30', '11:00 to 11:30', '12:30 to 14:00', '16:00 to 16:30']\n}\n\n# Define work hours and meeting duration\nwork_hours_start = '9:00'\nwork_hours_end = '17:00'\nmeeting_duration = 30  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_118"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours=('09:00', '17:00')):\n    # Convert work hours to minutes since midnight\n    work_start = int(work_hours[0].split(':')[0]) * 60 + int(work_hours[0].split(':')[1])\n    work_end = int(work_hours[1].split(':')[0]) * 60 + int(work_hours[1].split(':')[1])\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for schedule in participants_schedules:\n        busy_intervals = []\n        for interval in schedule:\n            start, end = interval.split(' to ')\n            start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n            end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n            busy_intervals.append((start_min, end_min))\n        all_busy_intervals.append(busy_intervals)\n    \n    # Find all possible slots where all participants are free\n    for time in range(work_start, work_end - duration_minutes + 1):\n        slot_start = time\n        slot_end = time + duration_minutes\n        valid = True\n        \n        for busy_intervals in all_busy_intervals:\n            overlap = False\n            for (busy_start, busy_end) in busy_intervals:\n                if not (slot_end <= busy_start or slot_start >= busy_end):\n                    overlap = True\n                    break\n            if overlap:\n                valid = False\n                break\n        \n        if valid:\n            # Format the time as HH:MM:HH:MM\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"09:00 to 09:30\", \"10:30 to 11:30\", \"13:30 to 14:00\", \"14:30 to 15:30\"],  # Scott\n    [\"10:00 to 10:30\", \"14:30 to 15:00\"],  # Laura\n    [\"09:00 to 09:30\", \"10:00 to 15:00\", \"15:30 to 17:00\"],  # Marilyn\n    [\"09:00 to 09:30\", \"10:00 to 10:30\", \"11:00 to 12:00\", \"12:30 to 16:00\", \"16:30 to 17:00\"]  # Natalie\n]\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules))\n```",
            "count": "calendar_scheduling_example_119"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    # Debra's busy slots: 9:00-10:00, 12:00-12:30, 13:00-14:30\n    debra_busy = [\n        (9 * 60, 10 * 60),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 14 * 60 + 30)\n    ]\n    \n    # Christopher's busy slots: 9:30-10:00, 12:00-13:00, 13:30-14:00, 14:30-15:00, 16:30-17:00\n    # Also, Christopher prefers no meetings after 13:00, so we add a constraint\n    christopher_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (12 * 60, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    christopher_preference_end = 13 * 60  # Prefers no meetings after 13:00\n    \n    # Evelyn's busy slots: 9:30-10:30, 11:30-12:00, 12:30-14:30, 15:30-16:00\n    evelyn_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 14 * 60 + 30),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    \n    # Wayne's busy slots: 9:00-9:30, 10:00-10:30, 11:00-12:30, 13:00-13:30, 14:00-16:00\n    wayne_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 16 * 60)\n    ]\n    \n    # Combine all busy slots for each person\n    schedules = {\n        'Debra': debra_busy,\n        'Christopher': christopher_busy,\n        'Evelyn': evelyn_busy,\n        'Wayne': wayne_busy\n    }\n    \n    # Find all possible slots where everyone is free\n    for start in range(work_start, work_end - meeting_duration + 1):\n        end = start + meeting_duration\n        # Check if the slot is within Christopher's preference (before 13:00)\n        if end <= christopher_preference_end:\n            all_free = True\n            for person, busy_slots in schedules.items():\n                for busy_start, busy_end in busy_slots:\n                    if not (end <= busy_start or start >= busy_end):\n                        all_free = False\n                        break\n                if not all_free:\n                    break\n            if all_free:\n                return f\"{start // 60:02d}:{start % 60:02d}:{end // 60:02d}:{end % 60:02d}\"\n    \n    # If no slot found before 13:00, check after (though Christopher prefers not)\n    for start in range(work_start, work_end - meeting_duration + 1):\n        end = start + meeting_duration\n        all_free = True\n        for person, busy_slots in schedules.items():\n            for busy_start, busy_end in busy_slots:\n                if not (end <= busy_start or start >= busy_end):\n                    all_free = False\n                    break\n            if not all_free:\n                break\n        if all_free:\n            return f\"{start // 60:02d}:{end // 60:02d}:{start % 60:02d}:{end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_120"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert all time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = map(time_to_minutes, work_hours.split(':'))\n    duration_minutes = duration * 60\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules.values():\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find available slots by merging busy intervals\n    available_slots = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define the participants' schedules\nparticipants_schedules = {\n    \"Jerry\": [\"11:30:12:00\", \"16:00:16:30\"],\n    \"Benjamin\": [],\n    \"Andrew\": [\"09:30:10:30\", \"11:30:12:30\", \"13:00:13:30\", \"14:00:15:30\"],\n    \"Anna\": [\"09:00:11:30\", \"12:00:12:30\", \"13:00:17:00\"]\n}\n\n# Define meeting duration (in hours) and work hours\nmeeting_duration = 0.5  # half an hour\nwork_hours = \"9:00:17:00\"\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, meeting_duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_121"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:00:15:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, meeting_duration):\n    # Convert time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work hours start at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = 9 + minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    start_work = time_to_minutes(work_hours[0])\n    end_work = time_to_minutes(work_hours[1])\n    duration = meeting_duration * 60\n\n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules.values():\n        for interval in schedule:\n            start = time_to_minutes(interval[0])\n            end = time_to_minutes(interval[1])\n            busy_intervals.append((start, end))\n\n    # Sort all busy intervals\n    busy_intervals.sort()\n\n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find available slots\n    available_slots = []\n    prev_end = start_work\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < end_work:\n        available_slots.append((prev_end, end_work))\n\n    # Check each available slot for sufficient duration\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            meeting_start = minutes_to_time(slot_start)\n            meeting_end = minutes_to_time(slot_start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n\n    return \"No available slot found\"\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nmeeting_duration = 0.5  # half an hour\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"Diana\": [(\"12:00\", \"13:30\"), (\"14:00\", \"15:00\"), (\"16:30\", \"17:00\")],\n    \"Rebecca\": [(\"9:00\", \"9:30\"), (\"10:00\", \"11:30\"), (\"13:00\", \"13:30\"), (\"14:30\", \"15:00\")],\n    \"Madison\": [(\"9:30\", \"10:30\"), (\"11:00\", \"12:30\"), (\"13:30\", \"15:00\"), (\"15:30\", \"16:30\")],\n    \"Carol\": [(\"9:00\", \"9:30\"), (\"10:00\", \"10:30\"), (\"11:00\", \"11:30\"), (\"12:00\", \"14:00\"), (\"14:30\", \"15:00\"), (\"16:00\", \"17:00\")]\n}\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_122"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define each participant's busy times in minutes since midnight\n    # Format: list of (start, end) tuples\n    thomas_busy = []\n    catherine_busy = [(13 * 60, 13 * 60 + 30), (14 * 60, 15 * 60 + 30)]\n    ruth_busy = [(9 * 60 + 30, 14 * 60 + 30), (15 * 60 + 30, 16 * 60 + 30)]\n    andrew_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60 + 30, 16 * 60)\n    ]\n\n    # Combine all busy times and sort them\n    all_busy = thomas_busy + catherine_busy + ruth_busy + andrew_busy\n    all_busy.sort()\n\n    # Find the earliest available slot\n    previous_end = work_start\n    for start, end in all_busy:\n        if start > previous_end and start - previous_end >= meeting_duration:\n            # Found a slot\n            proposed_start = previous_end\n            proposed_end = proposed_start + meeting_duration\n            return f\"{proposed_start // 60:02d}:{proposed_start % 60:02d}:{proposed_end // 60:02d}:{proposed_end % 60:02d}\"\n        previous_end = max(previous_end, end)\n\n    # Check after the last busy slot\n    if work_end - previous_end >= meeting_duration:\n        proposed_start = previous_end\n        proposed_end = proposed_start + meeting_duration\n        return f\"{proposed_start // 60:02d}:{proposed_start % 60:02d}:{proposed_end // 60:02d}:{proposed_end % 60:02d}\"\n\n    # If no slot found (though the problem states one exists)\n    return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_123"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    michael_busy = [(16 * 60, 17 * 60)]\n    hannah_busy = [(9 * 60 + 30, 10 * 60 + 30),\n                   (12 * 60, 12 * 60 + 30),\n                   (13 * 60 + 30, 14 * 60),\n                   (15 * 60 + 30, 16 * 60),\n                   (16 * 60 + 30, 17 * 60)]\n    brenda_busy = [(9 * 60 + 30, 11 * 60 + 30),\n                   (12 * 60, 13 * 60),\n                   (13 * 60 + 30, 14 * 60 + 30),\n                   (15 * 60, 17 * 60)]\n    anthony_busy = [(9 * 60, 11 * 60),\n                    (12 * 60, 12 * 60 + 30),\n                    (13 * 60 + 30, 14 * 60),\n                    (15 * 60 + 30, 16 * 60 + 30)]\n    \n    # Hannah's preference: not before 14:30\n    hannah_preference_start = 14 * 60 + 30\n\n    # Combine all busy slots\n    all_busy = []\n    for person_busy in [michael_busy, hannah_busy, brenda_busy, anthony_busy]:\n        all_busy.extend(person_busy)\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Filter free slots that are >= meeting_duration and after Hannah's preference\n    possible_slots = []\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration and slot_start >= hannah_preference_start:\n            possible_slots.append((slot_start, slot_end))\n    \n    # Select the earliest possible slot\n    if possible_slots:\n        meeting_start = possible_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_124"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define participants' busy times in minutes since midnight\n    jesse_busy = [(12 * 60 + 30, 13 * 60), (15 * 60, 15 * 60 + 30)]\n    alan_busy = [(9 * 60, 9 * 60 + 30), (16 * 60, 16 * 60 + 30)]\n    elijah_busy = [(9 * 60, 12 * 60), (12 * 60 + 30, 13 * 60), (14 * 60, 15 * 60), (15 * 60 + 30, 17 * 60)]\n    amy_busy = [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 12 * 60), (13 * 60, 13 * 60 + 30), (14 * 60, 15 * 60), (16 * 60, 16 * 60 + 30)]\n    \n    # Jesse's constraint: not before 12:30\n    jesse_constraint = 12 * 60 + 30\n    \n    # Meeting duration\n    duration = 30\n    \n    # Combine all busy times\n    all_busy = jesse_busy + alan_busy + elijah_busy + amy_busy\n    \n    # Generate free slots by finding gaps between busy times\n    all_busy.sort()\n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Filter free slots that meet duration and Jesse's constraint\n    valid_slots = []\n    for start, end in free_slots:\n        if end - start >= duration and start >= jesse_constraint:\n            valid_slots.append((start, end))\n    \n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + duration\n        # Format the output as HH:MM:HH:MM\n        return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    else:\n        return \"No valid time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_125"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Define participants' busy times in minutes since midnight\n    lawrence_busy = [(14 * 60, 16 * 60)]\n    sharon_busy = [(10 * 60 + 30, 11 * 60), (12 * 60 + 30, 13 * 60 + 30), (15 * 60, 15 * 60 + 30)]\n    aaron_busy = [(9 * 60 + 30, 11 * 60 + 30), (12 * 60, 14 * 60), (14 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)]\n    amy_busy = [(9 * 60 + 30, 11 * 60), (12 * 60, 13 * 60), (14 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)]\n\n    # Lawrence's preference: not before 13:00\n    preference_start = 13 * 60\n\n    # Combine all busy times\n    all_busy = []\n    for busy in [lawrence_busy, sharon_busy, aaron_busy, amy_busy]:\n        all_busy.extend(busy)\n\n    # Sort busy times by start time\n    all_busy.sort()\n\n    # Find free slots\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check for a 30-minute slot that fits Lawrence's preference\n    meeting_duration = 30\n    for start, end in free_slots:\n        if start >= preference_start:\n            available_start = start\n            available_end = min(end, available_start + meeting_duration)\n            if available_end - available_start >= meeting_duration:\n                # Convert back to HH:MM format\n                start_hh = available_start // 60\n                start_mm = available_start % 60\n                end_hh = (available_start + meeting_duration) // 60\n                end_mm = (available_start + meeting_duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    # If no slot found after preference, check before (though Lawrence prefers not)\n    for start, end in free_slots:\n        available_start = start\n        available_end = min(end, available_start + meeting_duration)\n        if available_end - available_start >= meeting_duration:\n            start_hh = available_start // 60\n            start_mm = available_start % 60\n            end_hh = (available_start + meeting_duration) // 60\n            end_mm = (available_start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_126"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert each participant's busy slots to minutes\n    # Kathleen: 13:00-14:00, 15:00-15:30, 16:00-16:30\n    kathleen_busy = [\n        (13 * 60, 14 * 60),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    # Kathleen doesn't want to meet before 13:30\n    kathleen_min_start = 13 * 60 + 30\n\n    # Frank: no meetings\n    frank_busy = []\n\n    # Christopher: 9:00-9:30, 10:00-11:30, 13:30-14:00, 15:30-17:00\n    christopher_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 11 * 60 + 30),\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n\n    # Kathryn: 9:00-10:00, 10:30-11:30, 12:30-13:00, 13:30-14:00, 14:30-15:00, 15:30-17:00\n    kathryn_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n\n    # Combine all busy slots for all participants\n    all_busy = kathleen_busy + frank_busy + christopher_busy + kathryn_busy\n\n    # Generate free slots by inverting busy slots within work hours\n    free_slots = []\n    previous_end = work_start\n    for start, end in sorted(all_busy):\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that is at least 30 minutes and meets Kathleen's constraint\n    meeting_duration = 30\n    for start, end in free_slots:\n        slot_start = max(start, kathleen_min_start)\n        if slot_start + meeting_duration <= end:\n            # Convert back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = (slot_start + meeting_duration) // 60\n            end_mm = (slot_start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_127"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Define participants' schedules and constraints\n    # Each entry is a list of (start, end) in minutes\n    catherine = [\n        (9 * 60, 10 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    harold = [\n        (12 * 60 + 30, 13 * 60),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    ann = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60, 15 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    randy = [\n        (9 * 60, 12 * 60),\n        (13 * 60, 14 * 60),\n        (14 * 60 + 30, 15 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n\n    # Harold cannot meet before 14:00\n    harold_constraint = 14 * 60\n\n    # Meeting duration is 30 minutes\n    duration = 30\n\n    # Combine all busy times and sort them\n    all_busy = []\n    for person in [catherine, harold, ann, randy]:\n        all_busy.extend(person)\n    all_busy.sort()\n\n    # Find available slots by checking gaps between busy times\n    available_slots = []\n    prev_end = work_start\n\n    for start, end in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n\n    if work_end > prev_end:\n        available_slots.append((prev_end, work_end))\n\n    # Filter slots that are >= duration and after Harold's constraint\n    possible_slots = []\n    for start, end in available_slots:\n        if end - start >= duration and start >= harold_constraint:\n            possible_slots.append((start, end))\n\n    # The first suitable slot is the earliest possible\n    if possible_slots:\n        meeting_start = possible_slots[0][0]\n        meeting_end = meeting_start + duration\n        # Format the output as HH:MM:HH:MM\n        return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_128"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    start_hour, end_hour = work_hours\n    # Convert work hours to minutes for easier calculation\n    work_start = start_hour * 60\n    work_end = end_hour * 60\n    \n    # Initialize a list to keep track of busy times for all participants\n    busy_times = []\n    \n    for schedule in participants_schedules:\n        personal_busy = []\n        for meeting in schedule:\n            start, end = meeting\n            start_min = start[0] * 60 + start[1]\n            end_min = end[0] * 60 + end[1]\n            personal_busy.append((start_min, end_min))\n        busy_times.append(personal_busy)\n    \n    # Check all possible time slots within work hours\n    for time in range(work_start, work_end - duration + 1):\n        end_time = time + duration\n        # Check if the time slot is free for all participants\n        all_free = True\n        for personal_busy in busy_times:\n            free = True\n            for (busy_start, busy_end) in personal_busy:\n                if not (end_time <= busy_start or time >= busy_end):\n                    free = False\n                    break\n            if not free:\n                all_free = False\n                break\n        if all_free:\n            # Convert back to HH:MM format\n            start_hh = time // 60\n            start_mm = time % 60\n            end_hh = end_time // 60\n            end_mm = end_time % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No available time slot found\"\n\n# Define the participants' schedules\njacqueline = [\n    ((10, 0), (10, 30)),\n    ((11, 0), (11, 30)),\n    ((12, 30), (13, 0)),\n    ((14, 0), (15, 0)),\n    ((16, 0), (16, 30))\n]\nadam = []\ngerald = [\n    ((9, 0), (11, 0)),\n    ((11, 30), (12, 0)),\n    ((14, 0), (15, 0)),\n    ((15, 30), (17, 0))\n]\nwayne = [\n    ((9, 0), (10, 0)),\n    ((10, 30), (11, 30)),\n    ((13, 0), (15, 0)),\n    ((15, 30), (16, 0)),\n    ((16, 30), (17, 0))\n]\n\nparticipants_schedules = [jacqueline, adam, gerald, wayne]\nmeeting_duration = 30  # minutes\nwork_hours = (9, 17)   # 9:00 to 17:00\n\n# Find the earliest available time\nmeeting_time = find_meeting_time(participants_schedules, meeting_duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_129"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals\n    busy_intervals = []\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals_sorted = sorted(busy_intervals, key=lambda x: x[0])\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals_sorted:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\njohn_schedule = [\n    \"9:00 to 9:30\",\n    \"10:00 to 10:30\",\n    \"11:00 to 11:30\",\n    \"13:00 to 14:30\"\n]\n\nralph_schedule = [\n    \"13:30 to 14:00\",\n    \"14:30 to 15:00\",\n    \"15:30 to 16:30\"\n]\n\ndaniel_schedule = [\n    \"9:00 to 9:30\",\n    \"10:30 to 11:00\",\n    \"12:00 to 13:00\",\n    \"13:30 to 16:30\"\n]\n\nkeith_schedule = [\n    \"10:30 to 14:30\",\n    \"15:00 to 17:00\"\n]\n\nparticipants_schedules = [john_schedule, ralph_schedule, daniel_schedule, keith_schedule]\nmeeting_duration = 30  # minutes\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, meeting_duration, work_hours_start, work_hours_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_130"
        },
        {
            "final_program_time": "{15:30:16:30}",
            "expected_time": "{15:30:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert all time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work_hours start at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = 9 + minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    start_work = time_to_minutes(work_hours[0])\n    end_work = time_to_minutes(work_hours[1]) - duration  # Latest possible start time\n\n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy_intervals in participants_busy.values():\n        for interval in busy_intervals:\n            start, end = interval.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            all_busy.append((start_min, end_min))\n\n    # Sort all busy intervals by start time\n    all_busy.sort()\n\n    # Find the first available slot\n    current_time = start_work\n    for start, end in all_busy:\n        if start > current_time and start - current_time >= duration:\n            # Found a slot\n            meeting_end = current_time + duration\n            return f\"{minutes_to_time(current_time)}:{minutes_to_time(meeting_end)}\"\n        current_time = max(current_time, end)\n    \n    # Check after the last busy interval\n    if current_time <= end_work:\n        meeting_end = current_time + duration\n        return f\"{minutes_to_time(current_time)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' busy times\nparticipants_busy = {\n    \"Walter\": [\"9:30 to 10:00\", \"13:00 to 13:30\"],\n    \"Jacob\": [\"11:00 to 11:30\", \"13:00 to 13:30\"],\n    \"Jennifer\": [\"9:30 to 10:30\", \"11:30 to 12:00\", \"12:30 to 15:00\"],\n    \"Joan\": [\"9:30 to 10:00\", \"10:30 to 11:30\", \"12:00 to 12:30\", \"13:00 to 14:00\", \"14:30 to 15:30\"],\n}\n\n# Work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 60  # minutes\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_131"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:30:10:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, duration_minutes, work_start, work_end):\n    # Convert all times to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration = duration_minutes\n    \n    # Collect all busy time slots\n    all_busy_slots = []\n    for busy_slots in participants_busy_times.values():\n        for slot in busy_slots:\n            start, end = map(time_to_minutes, slot.split(':'))\n            all_busy_slots.append((start, end))\n    \n    # Sort the busy slots by start time\n    all_busy_slots_sorted = sorted(all_busy_slots, key=lambda x: x[0])\n    \n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    prev_end = work_start_min\n    \n    for start, end in all_busy_slots_sorted:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        free_slots.append((prev_end, work_end_min))\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' busy times\nparticipants_busy_times = {\n    \"Diana\": [\"10:30:11:00\", \"12:30:13:00\", \"14:30:15:00\", \"15:30:16:00\"],\n    \"Harold\": [\"10:00:11:00\", \"11:30:16:30\"],\n    \"Philip\": [\"09:00:09:30\", \"10:30:12:00\", \"12:30:13:30\", \"14:00:17:00\"],\n    \"Joe\": []  # Joe has no busy times\n}\n\n# Parameters\nduration_minutes = 30\nwork_start = \"09:00\"\nwork_end = \"17:00\"\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, duration_minutes, work_start, work_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_132"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours_start, work_hours_end, duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n\n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy_intervals in participants_busy.values():\n        for interval in busy_intervals:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n\n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n\n    # Check each free interval for availability of duration\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' busy times\nparticipants_busy = {\n    \"Janice\": [\"11:30 to 12:30\"],\n    \"Isabella\": [],\n    \"Linda\": [\"9:30 to 11:30\", \"12:00 to 13:00\", \"13:30 to 16:30\"],\n    \"Billy\": [\"9:00 to 9:30\", \"10:30 to 11:30\", \"13:30 to 14:00\", \"14:30 to 16:00\", \"16:30 to 17:00\"]\n}\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30  # half an hour\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_133"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:13:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = work_hours\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start_min, work_end_min)]\n    \n    # Subtract busy slots from free slots for each participant\n    for person, busy_slots in participants_busy.items():\n        new_free_slots = []\n        for free_start, free_end in free_slots:\n            current_start = free_start\n            for busy_start, busy_end in busy_slots:\n                busy_start_min = time_to_minutes(busy_start)\n                busy_end_min = time_to_minutes(busy_end)\n                if busy_start_min >= free_end:\n                    break\n                if busy_end_min <= free_start:\n                    continue\n                if current_start < busy_start_min:\n                    new_free_slots.append((current_start, busy_start_min))\n                current_start = max(current_start, busy_end_min)\n            if current_start < free_end:\n                new_free_slots.append((current_start, free_end))\n        free_slots = new_free_slots\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_end = slot_start + duration_min\n            return f\"{minutes_to_time(slot_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 0.5  # half an hour\n\n# Define busy slots for each participant\nparticipants_busy = {\n    \"Alice\": [\n        (\"10:00\", \"10:30\"),\n        (\"14:30\", \"15:00\"),\n        (\"15:30\", \"16:30\")\n    ],\n    \"Charlotte\": [],\n    \"Stephanie\": [\n        (\"9:00\", \"9:30\"),\n        (\"10:30\", \"11:00\"),\n        (\"11:30\", \"13:00\"),\n        (\"13:30\", \"14:30\"),\n        (\"15:00\", \"15:30\")\n    ],\n    \"Ethan\": [\n        (\"9:00\", \"12:00\"),\n        (\"12:30\", \"13:00\"),\n        (\"13:30\", \"14:30\"),\n        (\"15:00\", \"15:30\"),\n        (\"16:00\", \"17:00\")\n    ]\n}\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_134"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    # Eric is free all day\n    eric_busy = []\n    \n    # Ashley's busy slots: 10:00-10:30, 11:00-12:00, 12:30-13:00, 15:00-16:00\n    ashley_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (15 * 60, 16 * 60)\n    ]\n    \n    # Ronald's busy slots: 9:00-9:30, 10:00-11:30, 12:30-14:00, 14:30-17:00\n    ronald_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 17 * 60)\n    ]\n    \n    # Larry's busy slots: 9:00-12:00, 13:00-17:00\n    larry_busy = [\n        (9 * 60, 12 * 60),\n        (13 * 60, 17 * 60)\n    ]\n    \n    # Combine all busy slots\n    all_busy = []\n    for person_busy in [eric_busy, ashley_busy, ronald_busy, larry_busy]:\n        all_busy.extend(person_busy)\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can fit the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_135"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' schedules and constraints\n    diana_busy = [(10*60+30, 11*60), (11*60+30, 12*60), (13*60+30, 14*60), (14*60+30, 15*60), (16*60, 17*60)]\n    diana_constraint = 9 * 60 + 30  # Cannot meet before 9:30\n\n    gerald_busy = [(9*60+30, 10*60), (12*60+30, 13*60), (15*60, 15*60+30), (16*60, 16*60+30)]\n\n    timothy_busy = [(10*60, 12*60), (12*60+30, 14*60), (14*60+30, 15*60), (16*60, 17*60)]\n\n    julie_busy = [(9*60+30, 10*60), (10*60+30, 11*60), (11*60+30, 15*60+30), (16*60, 17*60)]\n\n    # Combine all busy times\n    all_busy = []\n    for busy in [diana_busy, gerald_busy, timothy_busy, julie_busy]:\n        all_busy.extend(busy)\n\n    # Sort all busy times by start time\n    all_busy.sort()\n\n    # Find available slots\n    available_slots = []\n    prev_end = max(work_start, diana_constraint)\n\n    for start, end in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Find the first available slot that is at least 30 minutes\n    meeting_duration = 30\n    for slot in available_slots:\n        start, end = slot\n        if end - start >= meeting_duration:\n            # Convert start time to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_time = start + meeting_duration\n            end_hh = end_time // 60\n            end_mm = end_time % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_136"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy times in minutes (start, end)\n    rebecca_busy = [(10*60 + 30, 11*60), (12*60 + 30, 13*60)]\n    donald_busy = [(12*60, 12*60 + 30), (15*60, 15*60 + 30)]\n    diana_busy = [(9*60 + 30, 11*60), (12*60 + 30, 13*60), (13*60 + 30, 14*60), (14*60 + 30, 17*60)]\n    jesse_busy = [(9*60 + 30, 12*60 + 30), (13*60, 13*60 + 30), (14*60 + 30, 15*60), (16*60, 17*60)]\n    \n    # Diana cannot meet before 14:00\n    diana_min_time = 14 * 60\n    \n    # Combine all busy times\n    all_busy = rebecca_busy + donald_busy + diana_busy + jesse_busy\n    \n    # Sort busy times by start time\n    all_busy.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = work_start\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > prev_end:\n            free_slots.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Filter free slots that are at least 30 minutes and after Diana's min time\n    possible_slots = []\n    for start, end in free_slots:\n        if end - start >= 30 and start >= diana_min_time:\n            possible_slots.append((start, end))\n    \n    # Select the earliest possible slot\n    if possible_slots:\n        meeting_start = possible_slots[0][0]\n        meeting_end = meeting_start + 30\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_137"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' busy times in minutes since midnight\n    # Juan is free all day\n    emma_busy = [(9 * 60 + 30, 10 * 60 + 30), (12 * 60 + 30, 13 * 60 + 30)]\n    gloria_busy = [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), \n                    (11 * 60, 11 * 60 + 30), (12 * 60 + 30, 14 * 60),\n                    (16 * 60, 17 * 60)]\n    joan_busy = [(9 * 60, 9 * 60 + 30), (10 * 60, 12 * 60), \n                 (13 * 60, 14 * 60), (14 * 60 + 30, 17 * 60)]\n    \n    # Emma cannot meet before 12:30\n    emma_constraint = 12 * 60 + 30\n\n    # Combine all busy times and sort them\n    all_busy = emma_busy + gloria_busy + joan_busy\n    all_busy.sort()\n\n    # Initialize candidate start time\n    candidate_start = max(work_start, emma_constraint)\n\n    # Check for available slots\n    for busy_start, busy_end in all_busy:\n        if busy_start > candidate_start:\n            # Check if there's enough time before the next busy period\n            if busy_start - candidate_start >= 30:\n                # Format the time as HH:MM:HH:MM\n                start_hh = candidate_start // 60\n                start_mm = candidate_start % 60\n                end_hh = (candidate_start + 30) // 60\n                end_mm = (candidate_start + 30) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n        # Update candidate_start to the end of the current busy period\n        candidate_start = max(candidate_start, busy_end)\n    \n    # Check after the last busy period\n    if work_end - candidate_start >= 30:\n        start_hh = candidate_start // 60\n        start_mm = candidate_start % 60\n        end_hh = (candidate_start + 30) // 60\n        end_mm = (candidate_start + 30) % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_138"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours_start='9:00', work_hours_end='17:00'):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            all_busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_intervals = []\n    for start, end in all_busy_intervals:\n        if not merged_intervals:\n            merged_intervals.append([start, end])\n        else:\n            last_start, last_end = merged_intervals[-1]\n            if start <= last_end:\n                merged_intervals[-1][1] = max(end, last_end)\n            else:\n                merged_intervals.append([start, end])\n    \n    # Find the earliest available slot\n    prev_end = work_start\n    for start, end in merged_intervals:\n        if start - prev_end >= duration_minutes:\n            # Found a slot\n            meeting_start = prev_end\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n        prev_end = max(prev_end, end)\n    \n    # Check after the last busy interval\n    if work_end - prev_end >= duration_minutes:\n        meeting_start = prev_end\n        meeting_end = meeting_start + duration_minutes\n        def minutes_to_time(minutes):\n            hh = minutes // 60\n            mm = minutes % 60\n            return f\"{hh:02d}:{mm:02d}\"\n        return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"9:00 to 9:30\", \"12:00 to 12:30\", \"13:00 to 14:00\"],  # Jose\n    [\"10:30 to 11:00\", \"12:30 to 13:30\", \"14:30 to 15:00\"],  # Sean\n    [\"9:00 to 9:30\", \"10:00 to 11:30\", \"13:00 to 13:30\", \"14:00 to 14:30\", \"15:00 to 17:00\"],  # Denise\n    [\"9:00 to 10:00\", \"10:30 to 11:30\", \"12:00 to 17:00\"]  # Amanda\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_139"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    start_hour, end_hour = work_hours\n    # Convert work hours to minutes\n    start_time = start_hour * 60\n    end_time = end_hour * 60\n    \n    # Initialize a list to keep track of busy times for all participants\n    busy_times = []\n    \n    for schedule in participants_schedules:\n        for block in schedule:\n            start_block = block[0] * 60 + block[1]\n            end_block = block[2] * 60 + block[3]\n            busy_times.append((start_block, end_block))\n    \n    # Sort all busy times by start time\n    busy_times.sort()\n    \n    # Find all free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = start_time\n    \n    for start, end in busy_times:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy time\n    if previous_end < end_time:\n        free_slots.append((previous_end, end_time))\n    \n    # Now, merge overlapping or adjacent busy times to find common free slots\n    # But since we have all busy times, we can directly look for gaps >= duration\n    # in the merged busy times\n    merged_busy = []\n    for start, end in busy_times:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Now find free slots between merged busy times\n    common_free_slots = []\n    previous_end = start_time\n    \n    for start, end in merged_busy:\n        if start > previous_end:\n            common_free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy time\n    if previous_end < end_time:\n        common_free_slots.append((previous_end, end_time))\n    \n    # Now find the first slot that can fit the duration\n    for slot in common_free_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration * 60:\n            # Found a suitable slot\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration * 60\n            # Convert back to hours and minutes\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules in terms of (HH, MM, HH, MM) blocks\nwillie_schedule = [\n    (12, 0, 12, 30),\n    (15, 30, 16, 0)\n]\n\ncharlotte_schedule = [\n    (9, 30, 10, 0),\n    (14, 0, 14, 30),\n    (15, 0, 16, 0)\n]\n\nnoah_schedule = [\n    (10, 0, 10, 30),\n    (11, 0, 12, 0),\n    (13, 0, 15, 0),\n    (15, 30, 17, 0)\n]\n\nevelyn_schedule = [\n    (9, 0, 10, 0),\n    (10, 30, 11, 30),\n    (13, 30, 16, 0),\n    (16, 30, 17, 0)\n]\n\n# Combine all schedules\nall_schedules = [\n    willie_schedule,\n    charlotte_schedule,\n    noah_schedule,\n    evelyn_schedule\n]\n\n# Meeting duration in hours\nduration = 0.5  # half an hour\n\n# Work hours from 9:00 to 17:00\nwork_hours = (9, 17)\n\n# Find the meeting time\nmeeting_time = find_meeting_time(all_schedules, duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_140"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:00:15:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m - 540  # 540 minutes = 9:00\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        h = (minutes + 540) // 60\n        m = (minutes + 540) % 60\n        return f\"{h:02d}:{m:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    start_min = time_to_minutes(start_work)\n    end_min = time_to_minutes(end_work)\n    \n    # Initialize a list to track busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = busy.split(' to ')\n            start_busy = time_to_minutes(start)\n            end_busy = time_to_minutes(end)\n            busy_intervals.append((start_busy, end_busy))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = start_min\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < end_min:\n        free_intervals.append((prev_end, end_min))\n    \n    # Check each free interval for a slot that fits the meeting duration\n    duration_min = duration * 60  # Convert hours to minutes\n    for start, end in free_intervals:\n        if end - start >= duration_min:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration_min)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nlinda_schedule = [\n    \"10:00 to 11:30\",\n    \"12:00 to 12:30\",\n    \"13:00 to 14:00\"\n]\n\nsamantha_schedule = [\n    \"10:30 to 11:00\",\n    \"16:00 to 16:30\"\n]\n\nralph_schedule = [\n    \"9:00 to 10:00\",\n    \"10:30 to 12:00\",\n    \"12:30 to 13:30\",\n    \"14:00 to 15:00\",\n    \"16:30 to 17:00\"\n]\n\nkatherine_schedule = [\n    \"10:00 to 12:30\",\n    \"13:30 to 14:00\",\n    \"14:30 to 15:00\",\n    \"15:30 to 16:00\"\n]\n\nparticipants_schedules = [\n    linda_schedule,\n    samantha_schedule,\n    ralph_schedule,\n    katherine_schedule\n]\n\n# Find a 30-minute meeting time between 9:00 to 17:00\nmeeting_time = find_meeting_time(participants_schedules, 0.5, \"9:00 to 17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_141"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define each person's blocked times in minutes (start, end)\n    richard_blocked = [(9 * 60, 10 * 60)]\n    sarah_blocked = [(11 * 60, 11 * 60 + 30), (14 * 60, 14 * 60 + 30)]\n    gloria_blocked = [(9 * 60, 12 * 60 + 30), (13 * 60 + 30, 14 * 60), \n                      (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60)]\n    kathleen_blocked = [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 11 * 60),\n                        (12 * 60, 12 * 60 + 30), (13 * 60 + 30, 15 * 60 + 30),\n                        (16 * 60, 16 * 60 + 30)]\n\n    # Gloria's preference: not before 14:30\n    gloria_preference_start = 14 * 60 + 30\n\n    # Combine all blocked times\n    all_blocked = []\n    all_blocked.extend([(start, end, \"Richard\") for start, end in richard_blocked])\n    all_blocked.extend([(start, end, \"Sarah\") for start, end in sarah_blocked])\n    all_blocked.extend([(start, end, \"Gloria\") for start, end in gloria_blocked])\n    all_blocked.extend([(start, end, \"Kathleen\") for start, end in kathleen_blocked])\n\n    # Sort blocked times by start time\n    all_blocked.sort()\n\n    # Find available slots\n    available_slots = []\n    current_time = max(work_start, gloria_preference_start)\n\n    while current_time + meeting_duration <= work_end:\n        slot_available = True\n        slot_end = current_time + meeting_duration\n\n        for blocked_start, blocked_end, person in all_blocked:\n            if not (slot_end <= blocked_start or current_time >= blocked_end):\n                slot_available = False\n                current_time = blocked_end\n                break\n\n        if slot_available:\n            available_slots.append((current_time, slot_end))\n            current_time = slot_end\n        else:\n            # Move to the next possible start time\n            pass\n\n    if not available_slots:\n        return \"No available time slot found.\"\n\n    # Select the first available slot\n    meeting_start, meeting_end = available_slots[0]\n\n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n\n    start_time = minutes_to_time(meeting_start)\n    end_time = minutes_to_time(meeting_end)\n\n    return f\"{start_time}:{end_time}\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_142"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define busy intervals in minutes for each participant\n    marilyn_busy = [(9 * 60, 10 * 60)]\n    timothy_busy = [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30)]\n    peter_busy = [(9 * 60 + 30, 12 * 60 + 30), (13 * 60, 14 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)]\n    patrick_busy = [(9 * 60, 10 * 60), (11 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60, 15 * 60)]\n    \n    # Peter's preference: avoid meetings before 14:30\n    peter_preference_start = 14 * 60 + 30\n    \n    # Combine all busy intervals\n    all_busy = marilyn_busy + timothy_busy + peter_busy + patrick_busy\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by checking gaps between busy intervals\n    free_intervals = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the interval after the last busy interval\n    if previous_end < work_end:\n        free_intervals.append((previous_end, work_end))\n    \n    # Filter free intervals that are at least 30 minutes and after Peter's preference\n    meeting_duration = 30\n    suitable_intervals = []\n    \n    for start, end in free_intervals:\n        if end - start >= meeting_duration and start >= peter_preference_start:\n            suitable_intervals.append((start, end))\n    \n    # Select the earliest suitable interval\n    if suitable_intervals:\n        meeting_start = suitable_intervals[0][0]\n        meeting_end = meeting_start + meeting_duration\n    else:\n        # If no interval after preference, check all free intervals (though problem states solution exists)\n        for start, end in free_intervals:\n            if end - start >= meeting_duration:\n                meeting_start = start\n                meeting_end = meeting_start + meeting_duration\n                break\n    \n    # Format the output\n    start_hh = meeting_start // 60\n    start_mm = meeting_start % 60\n    end_hh = meeting_end // 60\n    end_mm = meeting_end % 60\n    \n    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_143"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:00:12:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 9:00 (0 minutes)\n    \n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Initialize the free slots for all participants\n    free_slots = []\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = busy.split(' to ')\n            busy_start = time_to_minutes(start)\n            busy_end = time_to_minutes(end)\n            busy_slots.append((busy_start, busy_end))\n        \n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Calculate free slots\n        current_time = work_start\n        free = []\n        for start, end in busy_slots:\n            if start > current_time:\n                free.append((current_time, start))\n            current_time = max(current_time, end)\n        if current_time < work_end:\n            free.append((current_time, work_end))\n        \n        free_slots.append(free)\n    \n    # Find intersection of all free slots\n    common_free = free_slots[0]\n    for slots in free_slots[1:]:\n        new_common = []\n        i = j = 0\n        while i < len(common_free) and j < len(slots):\n            start1, end1 = common_free[i]\n            start2, end2 = slots[j]\n            \n            # Find overlap\n            start = max(start1, start2)\n            end = min(end1, end2)\n            if start < end:\n                new_common.append((start, end))\n            \n            # Move the pointer which ends first\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free = new_common\n    \n    # Find the first slot that can fit the duration\n    duration_min = duration * 60\n    for start, end in common_free:\n        if end - start >= duration_min:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration_min)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Diane is free all day\n    [\"10:30 to 11:00\", \"16:00 to 16:30\"],  # Olivia\n    [\"9:00 to 9:30\", \"10:30 to 12:00\", \"12:30 to 15:00\", \"15:30 to 17:00\"],  # Vincent\n    [\"9:00 to 10:30\", \"11:00 to 12:00\", \"12:30 to 17:00\"],  # Steven\n]\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nduration = 0.5  # half hour\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_144"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_work, end_work = work_hours\n    # Convert time to minutes for easier calculation\n    start_min = start_work[0] * 60 + start_work[1]\n    end_min = end_work[0] * 60 + end_work[1]\n    \n    # Initialize a list to track busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for meeting in schedule:\n            start_meet = meeting[0][0] * 60 + meeting[0][1]\n            end_meet = meeting[1][0] * 60 + meeting[1][1]\n            busy_intervals.append((start_meet, end_meet))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append(interval)\n    \n    # Find available slots by checking gaps between merged intervals and work hours\n    available_slots = []\n    prev_end = start_min\n    \n    for interval in merged:\n        current_start, current_end = interval\n        if current_start > prev_end:\n            available_slots.append((prev_end, current_start))\n        prev_end = max(prev_end, current_end)\n    \n    # Check the time after the last meeting until end of work day\n    if prev_end < end_min:\n        available_slots.append((prev_end, end_min))\n    \n    # Check each available slot for duration\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            # Convert back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = (slot_start + duration) // 60\n            end_mm = (slot_start + duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available slot found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours = ((9, 0), (17, 0))\n\n# Define participants' schedules in HH:MM format converted to tuples\nparticipants_schedules = [\n    [],  # Marilyn has no meetings\n    [((10, 30), (11, 0)), ((12, 0), (12, 30)), ((13, 0), (13, 30)), ((16, 0), (16, 30))],  # Carolyn\n    [((10, 30), (12, 0)), ((13, 0), (14, 30)), ((15, 30), (16, 30))],  # Charles\n    [((9, 30), (13, 0)), ((13, 30), (17, 0))]  # Lori\n]\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_145"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 9:00 (0 minutes)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = (minutes + 540) // 60\n        mm = (minutes + 540) % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = work_hours.split(' to ')\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Initialize a list to track busy intervals for all participants\n    all_busy = []\n    \n    for person, schedules in participants_schedules.items():\n        for interval in schedules:\n            start, end = interval.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            all_busy.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start_min\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n    \n    # Check each free interval for availability of duration\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_end = start + duration\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    'Anna': ['9:00 to 9:30', '10:30 to 11:00', '12:00 to 12:30', '14:30 to 15:00', '16:00 to 17:00'],\n    'Dennis': ['12:00 to 13:30', '15:00 to 15:30'],\n    'Zachary': ['9:00 to 10:30', '12:00 to 12:30', '13:00 to 17:00'],\n    'Bobby': ['9:30 to 11:00', '11:30 to 12:00', '12:30 to 14:30', '15:00 to 17:00']\n}\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_hours = '9:00 to 17:00'\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, duration, work_hours))\n```",
            "count": "calendar_scheduling_example_146"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define busy intervals in minutes for each participant\n    busy_intervals = {\n        'Janice': [(9 * 60, 9 * 60 + 30), (15 * 60, 16 * 60 + 30)],\n        'Alexander': [(9 * 60, 9 * 60 + 30), (10 * 60, 12 * 60 + 30), \n                     (13 * 60, 14 * 60), (14 * 60 + 30, 15 * 60 + 30), \n                     (16 * 60, 17 * 60)],\n        'Thomas': [(9 * 60, 11 * 60), (13 * 60, 13 * 60 + 30), \n                   (14 * 60 + 30, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n    }\n\n    # Alexander doesn't want to meet before 13:00\n    alexander_constraint = 13 * 60\n\n    # Meeting duration is 30 minutes\n    duration = 30\n\n    # Generate all busy intervals for all participants\n    all_busy = []\n    for person, intervals in busy_intervals.items():\n        for start, end in intervals:\n            all_busy.append((start, end))\n    # Add Alexander's constraint as a busy interval before 13:00\n    all_busy.append((work_start, alexander_constraint))\n\n    # Sort all busy intervals by start time\n    all_busy.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_end = max(end, last_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find available slots between work hours and busy intervals\n    available = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n\n    # Find the first available slot that can fit the meeting\n    for start, end in available:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No available time slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_147"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define each person's busy times in minutes since midnight\n    # Format: (start, end)\n    deborah_busy = [\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (16 * 60, 17 * 60)\n    ]\n    samuel_busy = [\n        (11 * 60 + 30, 12 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    betty_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 14 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n    stephen_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (13 * 60, 15 * 60),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    stephen_constraint = 14 * 60  # Cannot meet before 14:00\n\n    # Combine all busy times\n    all_busy = []\n    for busy in [deborah_busy, samuel_busy, betty_busy, stephen_busy]:\n        all_busy.extend(busy)\n\n    # Sort all busy times by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy times and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Now check each free slot for availability for all participants\n    # Also respect Stephen's constraint\n    potential_slots = []\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            actual_start = max(slot_start, stephen_constraint)\n            if actual_start + meeting_duration <= slot_end:\n                potential_slots.append((actual_start, actual_start + meeting_duration))\n\n    # Now check each potential slot against individual calendars\n    valid_slots = []\n    for slot_start, slot_end in potential_slots:\n        valid = True\n        # Check Deborah\n        for start, end in deborah_busy:\n            if not (slot_end <= start or slot_start >= end):\n                valid = False\n                break\n        if not valid:\n            continue\n        # Check Samuel\n        for start, end in samuel_busy:\n            if not (slot_end <= start or slot_start >= end):\n                valid = False\n                break\n        if not valid:\n            continue\n        # Check Betty\n        for start, end in betty_busy:\n            if not (slot_end <= start or slot_start >= end):\n                valid = False\n                break\n        if not valid:\n            continue\n        # Check Stephen\n        for start, end in stephen_busy:\n            if not (slot_end <= start or slot_start >= end):\n                valid = False\n                break\n        if valid and slot_start >= stephen_constraint:\n            valid_slots.append((slot_start, slot_end))\n\n    if valid_slots:\n        # Return the first valid slot\n        best_slot = valid_slots[0]\n        start_h = best_slot[0] // 60\n        start_m = best_slot[0] % 60\n        end_h = best_slot[1] // 60\n        end_m = best_slot[1] % 60\n        return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    else:\n        return \"No valid slot found\"\n\n# Execute and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_148"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Parse work hours\n    work_start, work_end = [int(time.replace(':', '')) for time in work_hours.split(' to ')]\n    \n    # Initialize available slots for each participant\n    available_slots = []\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = [int(time.replace(':', '')) for time in busy.split(' to ')]\n            busy_slots.append((start, end))\n        # Sort busy slots\n        busy_slots.sort()\n        # Generate free slots\n        free_slots = []\n        prev_end = work_start\n        for start, end in busy_slots:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        available_slots.append(free_slots)\n    \n    # Find overlapping free slots\n    common_slots = available_slots[0]\n    for slots in available_slots[1:]:\n        new_common_slots = []\n        i = j = 0\n        while i < len(common_slots) and j < len(slots):\n            slot_start = max(common_slots[i][0], slots[j][0])\n            slot_end = min(common_slots[i][1], slots[j][1])\n            if slot_start < slot_end:\n                new_common_slots.append((slot_start, slot_end))\n            if common_slots[i][1] < slots[j][1]:\n                i += 1\n            else:\n                j += 1\n        common_slots = new_common_slots\n    \n    # Find first slot that can accommodate the meeting duration\n    duration_mins = duration * 100  # Convert to HHMM format (e.g., 0.5 hours -> 30 mins -> 0030)\n    for slot in common_slots:\n        slot_duration = slot[1] - slot[0]\n        if slot_duration >= duration_mins:\n            start_time = f\"{slot[0] // 100:02d}:{slot[0] % 100:02d}\"\n            end_time = f\"{(slot[0] + duration_mins) // 100:02d}:{(slot[0] + duration_mins) % 100:02d}\"\n            return f\"{start_time}:{end_time}\"\n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Diane has no meetings\n    [],  # Russell has no meetings\n    [\"09:00 to 10:00\", \"10:30 to 11:30\", \"12:00 to 13:00\", \"13:30 to 14:00\", \"14:30 to 17:00\"],  # Kathryn\n    [\"09:00 to 09:30\", \"10:00 to 11:00\", \"11:30 to 12:30\", \"14:00 to 15:30\", \"16:00 to 17:00\"]   # Joshua\n]\n\n# Define meeting duration in hours\nduration = 0.5  # half an hour\n\n# Define work hours\nwork_hours = \"9:00 to 17:00\"\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, duration, work_hours))\n```",
            "count": "calendar_scheduling_example_149"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, duration, work_hours):\n    # Convert all time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours\n    start_min = time_to_minutes(start_work)\n    end_min = time_to_minutes(end_work)\n    \n    # Generate all possible slots within work hours\n    possible_slots = []\n    current_min = start_min\n    while current_min + duration <= end_min:\n        possible_slots.append((current_min, current_min + duration))\n        current_min += 1  # Check every minute\n    \n    # Check each slot against all participants' busy times\n    for slot_start, slot_end in possible_slots:\n        slot_valid = True\n        for busy_list in participants_busy:\n            for busy_start, busy_end in busy_list:\n                busy_start_min = time_to_minutes(busy_start)\n                busy_end_min = time_to_minutes(busy_end)\n                # Check if slot overlaps with any busy time\n                if not (slot_end <= busy_start_min or slot_start >= busy_end_min):\n                    slot_valid = False\n                    break\n            if not slot_valid:\n                break\n        if slot_valid:\n            return f\"{minutes_to_time(slot_start)}:{minutes_to_time(slot_end)}\"\n    return \"No suitable time found\"\n\n# Define participants' busy times\nparticipants_busy = [\n    [],  # Andrew has no meetings\n    [(\"09:30\", \"10:00\"), (\"12:00\", \"12:30\"), (\"14:00\", \"14:30\"), (\"15:30\", \"16:00\")],  # Dennis\n    [(\"09:30\", \"11:00\"), (\"11:30\", \"12:30\"), (\"14:00\", \"15:00\"), (\"16:00\", \"16:30\")],  # Nancy\n    [(\"09:00\", \"09:30\"), (\"10:30\", \"11:30\"), (\"12:00\", \"12:30\"), (\"14:00\", \"15:30\"), (\"16:30\", \"17:00\")],  # Alexander\n]\n\n# Meeting duration in minutes\nduration = 30  # half an hour\n\n# Work hours\nwork_hours = (\"09:00\", \"17:00\")\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, duration, work_hours))\n```",
            "count": "calendar_scheduling_example_150"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' busy times in minutes since midnight\n    peter_busy = []\n    patricia_busy = [(11 * 60, 11 * 60 + 30), (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60), (16 * 60, 16 * 60 + 30)]\n    megan_busy = [(9 * 60, 10 * 60 + 30), (11 * 60, 12 * 60), (12 * 60 + 30, 14 * 60 + 30), (15 * 60, 16 * 60 + 30)]\n    amber_busy = [(9 * 60 + 30, 10 * 60 + 30), (11 * 60, 13 * 60), (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60)]\n\n    # Megan cannot meet before 11:00\n    megan_constraint = 11 * 60\n\n    # Combine all busy times\n    all_busy = peter_busy + patricia_busy + megan_busy + amber_busy\n    all_busy.sort()\n\n    # Find available slots\n    available_slots = []\n    prev_end = max(work_start, megan_constraint)\n\n    for start, end in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Find the first available slot that can fit 30 minutes\n    meeting_duration = 30\n    for slot in available_slots:\n        start, end = slot\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_151"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30       # 30 minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    aaron_busy = [\n        (9*60, 9*60 + 30),\n        (11*60 + 30, 12*60),\n        (12*60 + 30, 14*60),\n        (15*60 + 30, 16*60)\n    ]\n    sarah_busy = [\n        (10*60 + 30, 11*60 + 30),\n        (12*60 + 30, 13*60),\n        (13*60 + 30, 14*60 + 30),\n        (16*60, 16*60 + 30)\n    ]\n    martha_busy = [\n        (9*60, 9*60 + 30),\n        (10*60 + 30, 12*60),\n        (12*60 + 30, 13*60 + 30),\n        (14*60, 14*60 + 30),\n        (15*60 + 30, 17*60)\n    ]\n    heather_busy = [\n        (9*60, 10*60),\n        (11*60 + 30, 12*60),\n        (13*60, 14*60 + 30),\n        (15*60, 15*60 + 30),\n        (16*60, 16*60 + 30)\n    ]\n\n    sarah_preference_start = 13 * 60 + 30  # 13:30 in minutes\n\n    # Generate all possible 30-minute slots in the work hours\n    possible_slots = []\n    current_time = work_hours_start\n    while current_time + meeting_duration <= work_hours_end:\n        slot_start = current_time\n        slot_end = current_time + meeting_duration\n        possible_slots.append((slot_start, slot_end))\n        current_time += 1  # Check every minute for availability\n\n    # Check each slot against everyone's busy times and Sarah's preference\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n\n        # Check Sarah's preference\n        if slot_start < sarah_preference_start:\n            continue\n\n        # Check Aaron's availability\n        aaron_available = True\n        for busy_start, busy_end in aaron_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                aaron_available = False\n                break\n        if not aaron_available:\n            continue\n\n        # Check Sarah's availability\n        sarah_available = True\n        for busy_start, busy_end in sarah_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                sarah_available = False\n                break\n        if not sarah_available:\n            continue\n\n        # Check Martha's availability\n        martha_available = True\n        for busy_start, busy_end in martha_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                martha_available = False\n                break\n        if not martha_available:\n            continue\n\n        # Check Heather's availability\n        heather_available = True\n        for busy_start, busy_end in heather_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                heather_available = False\n                break\n        if not heather_available:\n            continue\n\n        # If all checks passed, return this slot\n        start_hour = slot_start // 60\n        start_min = slot_start % 60\n        end_hour = slot_end // 60\n        end_min = slot_end % 60\n        return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_152"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_start, work_end):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for schedule in participants_schedules:\n        busy_intervals = []\n        for busy_block in schedule:\n            start, end = busy_block.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            busy_intervals.append((start_min, end_min))\n        all_busy_intervals.append(busy_intervals)\n    \n    # Find all possible free intervals for each participant\n    all_free_intervals = []\n    for busy_intervals in all_busy_intervals:\n        free_intervals = []\n        prev_end = work_start_min\n        for start, end in sorted(busy_intervals):\n            if start > prev_end:\n                free_intervals.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end_min:\n            free_intervals.append((prev_end, work_end_min))\n        all_free_intervals.append(free_intervals)\n    \n    # Find overlapping free intervals across all participants\n    common_free_intervals = all_free_intervals[0]\n    for free_intervals in all_free_intervals[1:]:\n        new_common = []\n        i = j = 0\n        while i < len(common_free_intervals) and j < len(free_intervals):\n            start1, end1 = common_free_intervals[i]\n            start2, end2 = free_intervals[j]\n            overlap_start = max(start1, start2)\n            overlap_end = min(end1, end2)\n            if overlap_start < overlap_end:\n                new_common.append((overlap_start, overlap_end))\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free_intervals = new_common\n    \n    # Find the first interval that can accommodate the meeting duration\n    for start, end in common_free_intervals:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    return None\n\n# Define participants' schedules\nlogan_schedule = [\"11:00 to 11:30\", \"16:30 to 17:00\"]\nbruce_schedule = [\"9:00 to 9:30\", \"10:00 to 10:30\", \"14:00 to 14:30\", \"15:00 to 15:30\"]\njoan_schedule = [\"9:00 to 9:30\", \"10:00 to 11:00\", \"12:30 to 14:00\", \"14:30 to 15:30\", \"16:00 to 17:00\"]\nkevin_schedule = [\"9:00 to 9:30\", \"11:30 to 13:30\", \"14:30 to 17:00\"]\n\nparticipants_schedules = [logan_schedule, bruce_schedule, joan_schedule, kevin_schedule]\nmeeting_duration = 30  # minutes\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, meeting_duration, work_hours_start, work_hours_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_153"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:30:15:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, duration, work_hours):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    start_work, end_work = work_hours.split('-')\n    start_min = time_to_minutes(start_work)\n    end_min = time_to_minutes(end_work)\n    \n    # Initialize a list to mark busy intervals\n    timeline = [0] * (end_min - start_min)\n    \n    # Mark busy intervals for each participant\n    for person in participants_busy.values():\n        for busy in person:\n            start, end = busy.split('-')\n            start_busy = time_to_minutes(start)\n            end_busy = time_to_minutes(end)\n            # Mark the busy slots\n            for i in range(start_busy, end_busy):\n                if i < len(timeline):\n                    timeline[i] += 1\n    \n    # Find the first interval where all are free\n    required_slots = duration * 2  # Assuming each slot is 30 minutes for half-hour\n    current_free = 0\n    for i in range(len(timeline)):\n        if timeline[i] == 0:\n            current_free += 1\n            if current_free >= required_slots:\n                start_time = i - current_free + 1\n                end_time = start_time + required_slots\n                return f\"{minutes_to_time(start_time)}:{minutes_to_time(end_time)}\"\n        else:\n            current_free = 0\n    return \"No suitable time found\"\n\n# Define participants' busy times\nparticipants_busy = {\n    'Ann': [],\n    'Kelly': ['12:30-13:00', '14:00-14:30', '15:00-15:30', '16:30-17:00'],\n    'Benjamin': ['9:00-10:30', '11:00-11:30', '12:30-14:00', '15:00-16:30'],\n    'Pamela': ['9:30-11:00', '11:30-12:30', '13:00-14:30', '15:00-17:00']\n}\n\n# Meeting duration in hours (0.5 for half an hour)\nduration = 0.5\nwork_hours = '9:00-17:00'\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, duration, work_hours))\n```",
            "count": "calendar_scheduling_example_154"
        },
        {
            "final_program_time": "{13:30:14:30}",
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_work, end_work = work_hours\n    # Convert all times to minutes since midnight for easier calculation\n    start_min = start_work[0] * 60 + start_work[1]\n    end_min = end_work[0] * 60 + end_work[1]\n    \n    # Initialize a list to represent the availability of each minute in the workday\n    availability = [True] * (end_min - start_min)\n    \n    # For each participant, mark their busy times as unavailable\n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            busy_start_min = busy_start[0] * 60 + busy_start[1]\n            busy_end_min = busy_end[0] * 60 + busy_end[1]\n            # Only consider busy times within work hours\n            overlap_start = max(busy_start_min, start_min)\n            overlap_end = min(busy_end_min, end_min)\n            for minute in range(overlap_start - start_min, overlap_end - start_min):\n                availability[minute] = False\n    \n    # Find the first available slot of the required duration\n    required_slots = duration * 60\n    current_slot_length = 0\n    for minute in range(len(availability)):\n        if availability[minute]:\n            current_slot_length += 1\n            if current_slot_length >= required_slots:\n                # Calculate the start time of the meeting\n                meeting_start_min = start_min + minute - current_slot_length + 1\n                meeting_start_hour = meeting_start_min // 60\n                meeting_start_minute = meeting_start_min % 60\n                # Calculate the end time of the meeting\n                meeting_end_min = meeting_start_min + required_slots\n                meeting_end_hour = meeting_end_min // 60\n                meeting_end_minute = meeting_end_min % 60\n                # Format the output as HH:MM:HH:MM\n                return f\"{meeting_start_hour:02d}:{meeting_start_minute:02d}:{meeting_end_hour:02d}:{meeting_end_minute:02d}\"\n        else:\n            current_slot_length = 0\n    return \"No available slot found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours = ((9, 0), (17, 0))\n\n# Define each participant's schedule as a list of busy time slots (each slot is a tuple of (start, end))\njean_schedule = []\ndennis_schedule = [\n    ((10, 30), (11, 0)),\n    ((12, 0), (12, 30)),\n    ((14, 30), (15, 0)),\n    ((16, 0), (16, 30))\n]\nruth_schedule = [\n    ((9, 30), (12, 0)),\n    ((12, 30), (13, 30)),\n    ((15, 0), (16, 30))\n]\neugene_schedule = [\n    ((9, 0), (9, 30)),\n    ((11, 0), (11, 30)),\n    ((12, 0), (12, 30)),\n    ((13, 0), (13, 30)),\n    ((14, 30), (15, 30)),\n    ((16, 0), (17, 0))\n]\n\n# Combine all participants' schedules\nparticipants_schedules = [jean_schedule, dennis_schedule, ruth_schedule, eugene_schedule]\n\n# Duration of the meeting in hours (1 hour)\nduration = 1\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_155"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for duration availability\n    for interval in free_intervals:\n        start, end = interval\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return (minutes_to_time(meeting_start), minutes_to_time(meeting_end))\n    \n    return None\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"9:00 to 9:30\", \"11:00 to 11:30\", \"15:30 to 16:00\", \"16:30 to 17:00\"],  # Alexander\n    [\"9:00 to 9:30\", \"12:30 to 13:00\"],  # Paul\n    [\"9:30 to 10:00\", \"11:00 to 11:30\", \"12:00 to 17:00\"],  # Elijah\n    [\"9:00 to 10:00\", \"10:30 to 11:30\", \"12:00 to 13:30\", \"14:00 to 14:30\", \"15:30 to 16:00\", \"16:30 to 17:00\"]  # Mark\n]\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\n\n# Find the earliest meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end)\nif meeting_time:\n    print(f\"{meeting_time[0]}:{meeting_time[1]}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_156"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    duration = 30         # meeting duration in minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    # Richard has no meetings\n    richard_busy = []\n    \n    # Debra's busy slots\n    debra_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    \n    # Matthew's busy slots\n    matthew_busy = [\n        (9 * 60, 13 * 60),\n        (14 * 60 + 30, 15 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n    \n    # Elizabeth's busy slots\n    elizabeth_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    \n    # Combine all busy slots for all participants\n    all_busy = []\n    for person in [richard_busy, debra_busy, matthew_busy, elizabeth_busy]:\n        all_busy.extend(person)\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            # Convert back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = (slot_start + duration) // 60\n            end_mm = (slot_start + duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_157"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    russell_busy = [\n        (9 * 60 + 30, 10 * 60 + 0),\n        (13 * 60 + 0, 13 * 60 + 30),\n        (15 * 60 + 30, 16 * 60 + 30)\n    ]\n    debra_busy = [\n        (11 * 60 + 0, 11 * 60 + 30),\n        (13 * 60 + 0, 13 * 60 + 30),\n        (14 * 60 + 0, 14 * 60 + 30),\n        (15 * 60 + 30, 16 * 60 + 0)\n    ]\n    philip_busy = [\n        (9 * 60 + 0, 9 * 60 + 30),\n        (10 * 60 + 30, 12 * 60 + 30),\n        (14 * 60 + 0, 15 * 60 + 0),\n        (15 * 60 + 30, 17 * 60 + 0)\n    ]\n    peter_busy = [\n        (9 * 60 + 0, 9 * 60 + 30),\n        (10 * 60 + 0, 11 * 60 + 30),\n        (12 * 60 + 0, 12 * 60 + 30),\n        (13 * 60 + 0, 15 * 60 + 0),\n        (15 * 60 + 30, 16 * 60 + 0)\n    ]\n\n    # Philip's preference: avoid before 13:30\n    philip_preference_start = 13 * 60 + 30\n\n    # Generate all possible slots (every minute) and check availability\n    for start in range(max(work_start, philip_preference_start), work_end - meeting_duration + 1):\n        end = start + meeting_duration\n        slot_ok = True\n\n        # Check Russell's availability\n        for busy_start, busy_end in russell_busy:\n            if not (end <= busy_start or start >= busy_end):\n                slot_ok = False\n                break\n        if not slot_ok:\n            continue\n\n        # Check Debra's availability\n        for busy_start, busy_end in debra_busy:\n            if not (end <= busy_start or start >= busy_end):\n                slot_ok = False\n                break\n        if not slot_ok:\n            continue\n\n        # Check Philip's availability\n        for busy_start, busy_end in philip_busy:\n            if not (end <= busy_start or start >= busy_end):\n                slot_ok = False\n                break\n        if not slot_ok:\n            continue\n\n        # Check Peter's availability\n        for busy_start, busy_end in peter_busy:\n            if not (end <= busy_start or start >= busy_end):\n                slot_ok = False\n                break\n        if not slot_ok:\n            continue\n\n        # If all checks passed, return this slot\n        start_hour = start // 60\n        start_min = start % 60\n        end_hour = end // 60\n        end_min = end % 60\n        return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_158"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define participants' busy times in minutes (start, end)\n    virginia_busy = [\n        (9 * 60, 11 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (14 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    paul_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 14 * 60),\n        (15 * 60 + 30, 16 * 60 + 30)\n    ]\n    \n    # Nathan's preference: avoid before 13:00\n    nathan_preference_start = 13 * 60\n    \n    # Meeting duration in minutes\n    meeting_duration = 30\n    \n    # Combine all busy times and sort\n    all_busy = virginia_busy + paul_busy\n    all_busy.sort()\n    \n    # Find free slots\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Filter slots that are >= meeting_duration and after Nathan's preference\n    possible_slots = []\n    for start, end in free_slots:\n        if end - start >= meeting_duration and start >= nathan_preference_start:\n            possible_slots.append((start, end))\n    \n    # Select the earliest possible slot\n    if possible_slots:\n        meeting_start = possible_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_159"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' schedules and constraints\n    schedules = {\n        \"Nathan\": [(10 * 60 + 30, 11 * 60), (13 * 60, 13 * 60 + 30)],\n        \"Jacob\": [(13 * 60, 13 * 60 + 30), (15 * 60 + 30, 16 * 60)],\n        \"Katherine\": [(9 * 60 + 30, 11 * 60), (11 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60 + 30)],\n        \"Samantha\": [(9 * 60, 11 * 60), (11 * 60 + 30, 13 * 60 + 30), (14 * 60, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n    }\n    # Jacob's constraint: not before 14:30\n    jacob_constraint = 14 * 60 + 30\n\n    # Meeting duration in minutes\n    duration = 30\n\n    # Generate all possible time slots within work hours, checking every 30 minutes\n    for start in range(work_start, work_end - duration + 1, 30):\n        end = start + duration\n        # Check Jacob's constraint\n        if start < jacob_constraint:\n            continue\n        # Check each participant's availability\n        all_available = True\n        for person, busy_slots in schedules.items():\n            for busy_start, busy_end in busy_slots:\n                if not (end <= busy_start or start >= busy_end):\n                    all_available = False\n                    break\n            if not all_available:\n                break\n        if all_available:\n            # Format the time as HH:MM:HH:MM\n            return f\"{start // 60:02d}:{start % 60:02d}:{end // 60:02d}:{end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_160"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy times in minutes since midnight\n    ryan_busy = [(12 * 60 + 30, 13 * 60), (15 * 60 + 30, 16 * 60)]\n    margaret_busy = [(11 * 60, 12 * 60), (13 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30)]\n    willie_busy = [(9 * 60 + 30, 11 * 60), (12 * 60, 13 * 60), (13 * 60 + 30, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)]\n    shirley_busy = [(10 * 60, 10 * 60 + 30), (11 * 60, 11 * 60 + 30), (12 * 60, 13 * 60), (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)]\n    \n    # Margaret's preference: not before 13:30\n    margaret_preference_start = 13 * 60 + 30\n    \n    # Combine all busy times\n    all_busy = []\n    for busy in [ryan_busy, margaret_busy, willie_busy, shirley_busy]:\n        all_busy.extend(busy)\n    \n    # Sort busy times by start time\n    all_busy.sort()\n    \n    # Find free slots\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Check each free slot for availability and Margaret's preference\n    meeting_duration = 30\n    for slot_start, slot_end in free_slots:\n        if slot_start >= margaret_preference_start:\n            available_start = slot_start\n            available_end = slot_end\n            if available_end - available_start >= meeting_duration:\n                # Convert back to HH:MM format\n                start_hh = available_start // 60\n                start_mm = available_start % 60\n                end_hh = (available_start + meeting_duration) // 60\n                end_mm = (available_start + meeting_duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_161"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert each participant's busy slots to minutes since midnight\n    angela_busy = [\n        (10 * 60, 11 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    judith_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    thomas_busy = [\n        (9 * 60, 10 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (13 * 60, 14 * 60),\n        (14 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    # David has no busy slots\n\n    # Combine all busy slots for all participants\n    all_busy = []\n    for busy in [angela_busy, judith_busy, thomas_busy]:\n        all_busy.extend(busy)\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the time after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = (start + meeting_duration) // 60\n            end_mm = (start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_162"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    duration = 30         # meeting duration in minutes\n\n    # Convert each participant's busy slots to minutes\n    jason_busy = [(10 * 60 + 30, 13 * 60), (14 * 60, 14 * 60 + 30)]\n    hannah_busy = []  # No meetings\n    gary_busy = [(9 * 60, 10 * 60), (10 * 60 + 30, 15 * 60), (16 * 60 + 30, 17 * 60)]\n    pamela_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60, 16 * 60 + 30)\n    ]\n\n    # Combine all busy slots\n    all_busy = jason_busy + hannah_busy + gary_busy + pamela_busy\n\n    # Sort busy slots by start time\n    all_busy_sorted = sorted(all_busy, key=lambda x: x[0])\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    prev_end = work_start\n\n    for busy_start, busy_end in all_busy_sorted:\n        if busy_start > prev_end:\n            free_slots.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_163"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    duration = 30        # meeting duration in minutes\n\n    # Convert each participant's busy slots to minutes\n    # Jennifer's busy slots\n    jennifer_busy = [\n        (12 * 60 + 30, 13 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n\n    # Jean's busy slots and preference to avoid after 15:30\n    jean_busy = [\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    jean_preference_end = 15 * 60 + 30  # 15:30\n\n    # Jerry's busy slots\n    jerry_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n\n    # Carl's busy slots\n    carl_busy = [\n        (9 * 60, 11 * 60),\n        (12 * 60, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n\n    # Combine all busy slots\n    all_busy = jennifer_busy + jean_busy + jerry_busy + carl_busy\n\n    # Generate free slots by finding gaps between busy slots\n    all_busy.sort()\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check each free slot for availability for all participants and Jean's preference\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Check Jean's preference (meeting should end by 15:30)\n            if meeting_end <= jean_preference_end:\n                # Check if all participants are free\n                all_free = True\n                # Jennifer\n                for bs in jennifer_busy:\n                    if not (meeting_end <= bs[0] or meeting_start >= bs[1]):\n                        all_free = False\n                        break\n                if not all_free:\n                    continue\n                # Jean\n                for bs in jean_busy:\n                    if not (meeting_end <= bs[0] or meeting_start >= bs[1]):\n                        all_free = False\n                        break\n                if not all_free:\n                    continue\n                # Jerry\n                for bs in jerry_busy:\n                    if not (meeting_end <= bs[0] or meeting_start >= bs[1]):\n                        all_free = False\n                        break\n                if not all_free:\n                    continue\n                # Carl\n                for bs in carl_busy:\n                    if not (meeting_end <= bs[0] or meeting_start >= bs[1]):\n                        all_free = False\n                        break\n                if all_free:\n                    # Convert to HH:MM format\n                    start_hh = meeting_start // 60\n                    start_mm = meeting_start % 60\n                    end_hh = meeting_end // 60\n                    end_mm = meeting_end % 60\n                    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Run the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_164"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_start=9 * 60, work_end=17 * 60):\n    # Convert all schedules to minutes since start of day\n    busy_slots = []\n    for schedule in participants_schedules:\n        for start, end in schedule:\n            busy_slots.append((start, end))\n    \n    # Sort all busy slots by start time\n    busy_slots.sort()\n    \n    # Merge overlapping or adjacent busy slots\n    merged = []\n    for start, end in busy_slots:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find the earliest available slot\n    prev_end = work_start\n    for start, end in merged:\n        if start - prev_end >= duration_minutes:\n            return (prev_end, prev_end + duration_minutes)\n        prev_end = max(prev_end, end)\n    \n    # Check after the last busy slot\n    if work_end - prev_end >= duration_minutes:\n        return (prev_end, prev_end + duration_minutes)\n    \n    return None\n\n# Define participants' schedules in minutes since 9:00 (work_start)\nparticipants_schedules = [\n    [],  # Anthony has no meetings\n    [(9.5 * 60, 10 * 60), (12.5 * 60, 13.5 * 60), (15.5 * 60, 17 * 60)],  # Stephanie\n    [(9 * 60, 10.5 * 60), (11.5 * 60, 12.5 * 60), (13 * 60, 13.5 * 60), (14 * 60, 16 * 60)],  # Emma\n    [(10 * 60, 11 * 60), (11.5 * 60, 12.5 * 60), (14 * 60, 14.5 * 60), (15.5 * 60, 17 * 60)],  # Kathleen\n]\n\nmeeting_slot = find_meeting_time(participants_schedules)\n\nif meeting_slot:\n    start, end = meeting_slot\n    # Convert minutes back to HH:MM format\n    start_hh = start // 60\n    start_mm = start % 60\n    end_hh = end // 60\n    end_mm = end % 60\n    print(f\"{int(start_hh):02d}:{int(start_mm):02d}:{int(end_hh):02d}:{int(end_mm):02d}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_165"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration_min = duration * 60\n\n    # Initialize the free slots for the day\n    free_slots = []\n    current_start = work_start\n\n    # Generate all possible slots during work hours\n    while current_start + duration_min <= work_end:\n        free_slots.append((current_start, current_start + duration_min))\n        current_start += 30  # Assuming 30-minute increments for simplicity\n\n    # Check each slot against all participants' schedules\n    for slot_start, slot_end in free_slots:\n        slot_ok = True\n        for person, meetings in participants_schedules.items():\n            for meeting in meetings:\n                meeting_start = time_to_minutes(meeting[0])\n                meeting_end = time_to_minutes(meeting[1])\n                # Check if slot overlaps with any meeting\n                if not (slot_end <= meeting_start or slot_start >= meeting_end):\n                    slot_ok = False\n                    break\n            if not slot_ok:\n                break\n        if slot_ok:\n            return f\"{minutes_to_time(slot_start)}:{minutes_to_time(slot_end)}\"\n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    'Sara': [('10:00', '10:30'), ('15:00', '15:30'), ('16:00', '17:00')],\n    'Lauren': [],\n    'Jose': [('9:00', '10:30'), ('11:00', '12:00'), ('13:00', '13:30'), ('14:00', '17:00')],\n    'Henry': [('10:00', '10:30'), ('11:00', '14:00'), ('14:30', '16:00')]\n}\n\n# Find a meeting time\nmeeting_time = find_meeting_time(participants_schedules, 30, '9:00', '17:00')\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_166"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time slots to minutes since start of the day for easier calculation\n    work_start = work_hours_start * 60\n    work_end = work_hours_end * 60\n    duration = duration_minutes\n\n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n\n    for participant, schedules in participants_schedules.items():\n        for start, end in schedules:\n            busy_intervals.append((start[0] * 60 + start[1], end[0] * 60 + end[1]))\n\n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n\n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find the available slots by looking at the gaps between busy intervals\n    available_slots = []\n    previous_end = work_start\n\n    for start, end in merged:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check the slot after the last busy interval\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n\n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No available time slot found\"\n\n# Define the participants' schedules in HH:MM format converted to tuples of (HH, MM)\nparticipants_schedules = {\n    \"Marilyn\": [((10, 30), (11, 30)), ((12, 0), (12, 30)), ((15, 30), (16, 00))],\n    \"George\": [],\n    \"Stephanie\": [((10, 30), (12, 30)), ((13, 30), (16, 30))],\n    \"Kimberly\": [((9, 00), (10, 30)), ((12, 30), (13, 00)), ((13, 30), (15, 00)), ((15, 30), (17, 00))],\n}\n\n# Define work hours and meeting duration\nwork_hours_start = 9\nwork_hours_end = 17\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_167"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize a list to keep track of all busy intervals\n    all_busy_intervals = []\n    \n    for person, busy_intervals in participants_busy_times.items():\n        for interval in busy_intervals:\n            start, end = interval.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            all_busy_intervals.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Find free intervals by inverting busy intervals\n    free_intervals = []\n    previous_end = work_start\n    \n    for start, end in all_busy_intervals:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_intervals.append((previous_end, work_end))\n    \n    # Check each free interval for availability of all participants\n    potential_slots = []\n    for start, end in free_intervals:\n        if end - start >= meeting_duration:\n            potential_slots.append((start, start + meeting_duration))\n    \n    # The first suitable slot is the earliest possible\n    if potential_slots:\n        slot_start, slot_end = potential_slots[0]\n        return f\"{minutes_to_time(slot_start)}:{minutes_to_time(slot_end)}\"\n    else:\n        return \"No available slot found\"\n\n# Define the participants' busy times\nparticipants_busy_times = {\n    \"Jean\": [\"13:00 to 13:30\", \"14:00 to 14:30\", \"16:00 to 17:00\"],\n    \"Lauren\": [\"9:30 to 10:00\", \"10:30 to 11:00\"],\n    \"Olivia\": [\"9:00 to 11:00\", \"12:30 to 16:00\", \"16:30 to 17:00\"],\n    \"Scott\": [\"9:00 to 11:30\", \"13:30 to 14:00\", \"14:30 to 15:30\"],\n}\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 60  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_168"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    start, end = work_hours\n    # Convert time strings to minutes for easier calculation\n    start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n    end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n    duration_min = duration * 60\n    \n    # Initialize the free slots for all participants\n    free_slots = []\n    for schedule in participants_schedules:\n        busy = []\n        for slot in schedule:\n            s, e = slot.split(' to ')\n            s_min = int(s.split(':')[0]) * 60 + int(s.split(':')[1])\n            e_min = int(e.split(':')[0]) * 60 + int(e.split(':')[1])\n            busy.append((s_min, e_min))\n        # Sort the busy slots\n        busy.sort()\n        # Calculate free slots\n        free = []\n        prev_end = start_min\n        for slot in busy:\n            s, e = slot\n            if s > prev_end:\n                free.append((prev_end, s))\n            prev_end = max(prev_end, e)\n        if prev_end < end_min:\n            free.append((prev_end, end_min))\n        free_slots.append(free)\n    \n    # Find overlapping free slots\n    common_free = free_slots[0]\n    for slots in free_slots[1:]:\n        new_common = []\n        i = j = 0\n        while i < len(common_free) and j < len(slots):\n            s1, e1 = common_free[i]\n            s2, e2 = slots[j]\n            # Find the overlap\n            overlap_start = max(s1, s2)\n            overlap_end = min(e1, e2)\n            if overlap_start < overlap_end:\n                new_common.append((overlap_start, overlap_end))\n            if e1 < e2:\n                i += 1\n            else:\n                j += 1\n        common_free = new_common\n    \n    # Find the first slot that can fit the meeting\n    for slot in common_free:\n        s, e = slot\n        if e - s >= duration_min:\n            meeting_start = s\n            meeting_end = s + duration_min\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Donna has no meetings\n    [],  # Lisa has no meetings\n    [   # Philip's schedule\n        \"9:00 to 10:30\",\n        \"11:00 to 12:00\",\n        \"12:30 to 14:00\",\n        \"14:30 to 15:00\",\n        \"15:30 to 17:00\"\n    ],\n    [   # Albert's schedule\n        \"9:30 to 10:00\",\n        \"11:00 to 12:30\",\n        \"13:30 to 14:30\",\n        \"15:00 to 15:30\",\n        \"16:00 to 16:30\"\n    ]\n]\n\n# Define meeting duration (0.5 hours = 30 minutes) and work hours (9:00 to 17:00)\nduration = 0.5\nwork_hours = (\"9:00\", \"17:00\")\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_169"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy times in minutes (start, end)\n    gary_busy = [(9.5 * 60, 10 * 60), (12 * 60, 12.5 * 60)]\n    douglas_busy = [(10.5 * 60, 11 * 60), (11.5 * 60, 12 * 60), (14 * 60, 14.5 * 60), (16.5 * 60, 17 * 60)]\n    elizabeth_busy = [(11.5 * 60, 13.5 * 60), (14 * 60, 15 * 60), (16 * 60, 17 * 60)]\n    daniel_busy = [(10.5 * 60, 12.5 * 60), (14 * 60, 17 * 60)]\n    \n    # Gary's preference: not after 10:00 (so before 10:00)\n    gary_pref_end = 10 * 60\n    \n    # Combine all busy times and sort\n    all_busy = gary_busy + douglas_busy + elizabeth_busy + daniel_busy\n    all_busy.sort()\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Check for a 30-minute slot that fits Gary's preference (before 10:00)\n    meeting_duration = 30\n    for slot_start, slot_end in available_slots:\n        if slot_start >= gary_pref_end:\n            continue  # Skip slots after Gary's preference\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{int(meeting_start // 60):02d}:{int(meeting_start % 60):02d}:{int(meeting_end // 60):02d}:{int(meeting_end % 60):02d}\"\n    \n    # If no slot found before 10:00, look for any other slot (though problem states a solution exists)\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            return f\"{int(meeting_start // 60):02d}:{int(meeting_start % 60):02d}:{int(meeting_end // 60):02d}:{int(meeting_end % 60):02d}\"\n    \n    return \"No time found\"  # Should not reach here per problem statement\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_170"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Convert each participant's busy slots to minutes\n    kevin_busy = [(10 * 60 + 30, 11 * 60), (14 * 60, 14 * 60 + 30)]\n    carolyn_busy = [(11 * 60 + 30, 12 * 60), (16 * 60, 16 * 60 + 30)]\n    stephanie_busy = [(9 * 60, 10 * 60 + 30), (11 * 60, 12 * 60 + 30), \n                      (13 * 60 + 30, 14 * 60 + 30), (15 * 60, 17 * 60)]\n    isabella_busy = [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 11 * 60), \n                     (11 * 60 + 30, 14 * 60 + 30), (15 * 60, 17 * 60)]\n\n    # Combine all busy slots\n    all_busy = kevin_busy + carolyn_busy + stephanie_busy + isabella_busy\n\n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_171"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:00:14:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours\n    start_min = time_to_minutes(start_work)\n    end_min = time_to_minutes(end_work)\n    duration_min = duration * 60\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(start_min, end_min)]\n    \n    # Process each participant's busy slots to find common free time\n    for person in participants_busy:\n        new_free_slots = []\n        for busy_start, busy_end in person:\n            busy_start_min = time_to_minutes(busy_start)\n            busy_end_min = time_to_minutes(busy_end)\n            temp_slots = []\n            for slot_start, slot_end in free_slots:\n                if busy_end_min <= slot_start or busy_start_min >= slot_end:\n                    # No overlap, keep the slot as is\n                    temp_slots.append((slot_start, slot_end))\n                else:\n                    # Overlap, split the slot\n                    if slot_start < busy_start_min:\n                        temp_slots.append((slot_start, busy_start_min))\n                    if slot_end > busy_end_min:\n                        temp_slots.append((busy_end_min, slot_end))\n            free_slots = temp_slots\n        if not free_slots:\n            return None  # No common free time\n    \n    # Find the first slot that can accommodate the meeting duration\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return None\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 0.5  # half an hour\n\n# Define each participant's busy times\nparticipants_busy = [\n    # Patrick's busy slots\n    [(\"9:00\", \"9:30\"), (\"10:00\", \"10:30\"), (\"13:30\", \"14:00\"), (\"16:00\", \"16:30\")],\n    # Kayla's busy slots\n    [(\"12:30\", \"13:30\"), (\"15:00\", \"15:30\"), (\"16:00\", \"16:30\")],\n    # Carl's busy slots\n    [(\"10:30\", \"11:00\"), (\"12:00\", \"12:30\"), (\"13:00\", \"13:30\"), (\"14:30\", \"17:00\")],\n    # Christian's busy slots\n    [(\"9:00\", \"12:30\"), (\"13:00\", \"14:00\"), (\"14:30\", \"17:00\")],\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_172"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert all schedules to minutes since midnight\n    # Each person's busy times are represented as a list of (start, end) tuples in minutes\n    jacqueline_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    \n    harold_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (15 * 60, 17 * 60)\n    ]\n    harold_no_meet_after = 13 * 60  # Harold doesn't want to meet after 13:00\n    \n    arthur_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 12 * 60 + 30),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    \n    kelly_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 11 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    \n    # Duration of the meeting in minutes\n    duration = 30\n    \n    # Collect all busy times for all participants\n    all_busy = jacqueline_busy + harold_busy + arthur_busy + kelly_busy\n    \n    # Generate all possible time slots within work hours, checking for availability\n    current_time = work_start\n    while current_time + duration <= work_end:\n        slot_end = current_time + duration\n        # Check if the slot is free for everyone\n        is_available = True\n        \n        # Check Jacqueline's schedule\n        for start, end in jacqueline_busy:\n            if not (slot_end <= start or current_time >= end):\n                is_available = False\n                break\n        if not is_available:\n            current_time += 5  # Move to next possible slot (5-minute increments)\n            continue\n        \n        # Check Harold's schedule and constraint\n        for start, end in harold_busy:\n            if not (slot_end <= start or current_time >= end):\n                is_available = False\n                break\n        if not is_available:\n            current_time += 5\n            continue\n        if current_time >= harold_no_meet_after:\n            is_available = False\n        if not is_available:\n            current_time += 5\n            continue\n        \n        # Check Arthur's schedule\n        for start, end in arthur_busy:\n            if not (slot_end <= start or current_time >= end):\n                is_available = False\n                break\n        if not is_available:\n            current_time += 5\n            continue\n        \n        # Check Kelly's schedule\n        for start, end in kelly_busy:\n            if not (slot_end <= start or current_time >= end):\n                is_available = False\n                break\n        if not is_available:\n            current_time += 5\n            continue\n        \n        # If all checks passed, return the slot\n        start_h = current_time // 60\n        start_m = current_time % 60\n        end_h = slot_end // 60\n        end_m = slot_end % 60\n        return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n        \n        current_time += 5\n    \n    return \"No available slot found\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_173"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:30:14:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between merged intervals and work hours\n    available_slots = []\n    previous_end = work_start\n    for start, end in merged:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Check each available slot for sufficient duration\n    meeting_duration_min = meeting_duration * 60\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"11:30:12:00\", \"14:30:16:00\"],  # Kevin\n    [\"10:00:11:00\"],                 # David\n    [\"9:00:11:30\", \"12:00:13:00\", \"14:00:15:30\", \"16:00:17:00\"],  # Stephen\n    [\"9:00:13:30\", \"14:30:17:00\"]    # Helen\n]\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 0.5  # in hours\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_174"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each participant's blocked times to minutes since midnight\n    roger_blocked = [\n        (12 * 60 + 30, 13 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    jesse_blocked = [\n        (10 * 60, 10 * 60 + 30),\n        (12 * 60 + 30, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30)\n    ]\n    daniel_blocked = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    maria_blocked = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60, 13 * 60),\n        (13 * 60 + 30, 14 * 60 + 30),\n        (15 * 60, 16 * 60 + 30)\n    ]\n    maria_min_time = 12 * 60 + 30  # Maria can't meet before 12:30\n\n    # Combine all blocked times for all participants\n    all_blocked = []\n    for start, end in roger_blocked:\n        all_blocked.append((start, end, \"Roger\"))\n    for start, end in jesse_blocked:\n        all_blocked.append((start, end, \"Jesse\"))\n    for start, end in daniel_blocked:\n        all_blocked.append((start, end, \"Daniel\"))\n    for start, end in maria_blocked:\n        all_blocked.append((start, end, \"Maria\"))\n\n    # Sort all blocked times by start time\n    all_blocked.sort()\n\n    # Find available slots\n    available_slots = []\n    current_time = max(work_start, maria_min_time)\n\n    for start, end, _ in all_blocked:\n        if start > current_time:\n            available_slots.append((current_time, start))\n        current_time = max(current_time, end)\n    if current_time < work_end:\n        available_slots.append((current_time, work_end))\n\n    # Check each available slot for a meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Check if all participants are free during this time\n            all_free = True\n            # Roger\n            for start, end, person in all_blocked:\n                if person == \"Roger\" and not (end <= meeting_start or start >= meeting_end):\n                    all_free = False\n                    break\n            if not all_free:\n                continue\n            # Jesse\n            for start, end, person in all_blocked:\n                if person == \"Jesse\" and not (end <= meeting_start or start >= meeting_end):\n                    all_free = False\n                    break\n            if not all_free:\n                continue\n            # Daniel\n            for start, end, person in all_blocked:\n                if person == \"Daniel\" and not (end <= meeting_start or start >= meeting_end):\n                    all_free = False\n                    break\n            if not all_free:\n                continue\n            # Maria\n            for start, end, person in all_blocked:\n                if person == \"Maria\" and not (end <= meeting_start or start >= meeting_end):\n                    all_free = False\n                    break\n            if all_free:\n                # Convert back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No available time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_175"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration_minutes):\n    # Convert all times to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    meeting_duration = meeting_duration_minutes\n\n    # Collect all busy times for all participants\n    all_busy_times = []\n    for busy_times in participants_busy_times.values():\n        for start, end in busy_times:\n            all_busy_times.append((time_to_minutes(start), time_to_minutes(end)))\n\n    # Sort busy times by start time\n    all_busy_times.sort()\n\n    # Find free slots by checking gaps between busy times and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy_times:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No suitable time found\"\n\n# Define the participants' busy times\nparticipants_busy_times = {\n    \"Gary\": [(\"9:00\", \"9:30\"), (\"14:00\", \"14:30\")],\n    \"Melissa\": [(\"12:00\", \"13:00\"), (\"14:30\", \"15:00\"), (\"16:00\", \"16:30\")],\n    \"Alan\": [(\"9:00\", \"10:00\"), (\"10:30\", \"11:30\"), (\"12:00\", \"17:00\")],\n    \"Kevin\": [(\"9:00\", \"9:30\"), (\"10:00\", \"10:30\"), (\"12:00\", \"16:00\")],\n}\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_176"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:00:12:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's busy times\n    for busy_slots in participants_busy_times:\n        new_free_slots = []\n        for busy_start, busy_end in busy_slots:\n            busy_start_min = time_to_minutes(busy_start)\n            busy_end_min = time_to_minutes(busy_end)\n            updated_free_slots = []\n            for slot_start, slot_end in free_slots:\n                if busy_end_min <= slot_start or busy_start_min >= slot_end:\n                    # No overlap, keep the slot as is\n                    updated_free_slots.append((slot_start, slot_end))\n                else:\n                    # There is an overlap, split the slot\n                    if slot_start < busy_start_min:\n                        updated_free_slots.append((slot_start, busy_start_min))\n                    if busy_end_min < slot_end:\n                        updated_free_slots.append((busy_end_min, slot_end))\n            free_slots = updated_free_slots\n        if not free_slots:\n            return None  # No possible slot\n    \n    # Find the first slot that can fit the meeting\n    meeting_duration_min = meeting_duration * 60\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration_min:\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            start_time = minutes_to_time(slot_start)\n            end_time = minutes_to_time(slot_start + meeting_duration_min)\n            return f\"{start_time}:{end_time}\"\n    return None\n\n# Define the participants' busy times\nparticipants_busy_times = [\n    # Richard's busy times\n    [(\"9:00\", \"9:30\"), (\"11:30\", \"12:00\"), (\"13:00\", \"13:30\"), (\"16:00\", \"16:30\")],\n    # Joseph's busy times\n    [(\"9:30\", \"10:30\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:30\"), (\"14:00\", \"14:30\")],\n    # Gabriel's busy times\n    [(\"9:00\", \"11:00\"), (\"11:30\", \"12:00\"), (\"12:30\", \"17:00\")],\n    # Brenda's busy times\n    [(\"9:00\", \"12:00\"), (\"12:30\", \"16:30\")]\n]\n\n# Find a meeting time\nmeeting_time = find_meeting_time(\n    participants_busy_times=participants_busy_times,\n    work_hours_start=\"9:00\",\n    work_hours_end=\"17:00\",\n    meeting_duration=0.5  # 0.5 hours = 30 minutes\n)\n\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_177"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start, end = work_hours\n    busy_times = []\n    \n    # Collect all busy intervals from all participants\n    for schedule in participants_schedules.values():\n        for busy_start, busy_end in schedule:\n            busy_times.append((busy_start, busy_end))\n    \n    # Sort all busy intervals by start time\n    busy_times.sort()\n    \n    # Find all free intervals by checking gaps between busy intervals\n    free_times = []\n    previous_end = start\n    \n    for busy_start, busy_end in busy_times:\n        if busy_start > previous_end:\n            free_times.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    # Check the time after the last busy interval until end of work hours\n    if previous_end < end:\n        free_times.append((previous_end, end))\n    \n    # Find the first free interval that can accommodate the meeting duration\n    for free_start, free_end in free_times:\n        if (free_end - free_start) >= duration:\n            meeting_start = free_start\n            meeting_end = meeting_start + duration\n            return f\"{meeting_start:02d}:00:{meeting_end:02d}:00\"\n    \n    return \"No suitable time found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (9, 17)\n\n# Define participants' schedules in 24-hour format as integers for simplicity\nparticipants_schedules = {\n    \"Aaron\": [(9, 9.5), (10.5, 11)],\n    \"Bryan\": [(9, 9.5), (14.5, 15)],\n    \"Philip\": [(9, 9.5), (10, 10.5), (13.5, 15), (15.5, 17)],\n    \"Ronald\": [(9, 9.5), (10, 10.5), (11.5, 12), (13, 15.5)],\n}\n\n# Meeting duration in hours\nduration = 1\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_178"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert all time slots to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots between work hours and busy intervals\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Check each available slot for duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"12:00 to 12:30\", \"15:00 to 15:30\"],  # Joseph\n    [\"09:30 to 10:00\", \"14:00 to 14:30\"],  # Laura\n    [\"09:00 to 09:30\", \"10:00 to 10:30\", \"11:00 to 11:30\", \"12:00 to 12:30\", \"13:30 to 14:00\", \"14:30 to 16:00\"],  # Jeffrey\n    [\"09:30 to 12:30\", \"13:00 to 17:00\"],  # Jeremy\n]\n\n# Define work hours and meeting duration\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_179"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Convert each participant's busy slots to minutes since 9:00\n    david_busy = [(14*60, 14*60 + 30), (16*60 + 30, 17*60)]\n    ethan_busy = [(13*60, 13*60 + 30), (14*60 + 30, 15*60)]\n    bradley_busy = [(9*60 + 30, 10*60 + 30), (11*60, 12*60), (13*60 + 30, 14*60), (15*60 + 30, 17*60)]\n    natalie_busy = [(9*60 + 30, 10*60), (10*60 + 30, 12*60), (12*60 + 30, 15*60 + 30), (16*60, 17*60)]\n    \n    # Natalie's preference: not after 10:30 (10*60 + 30)\n    preference_end = 10 * 60 + 30\n    \n    # Combine all busy slots\n    all_busy = david_busy + ethan_busy + bradley_busy + natalie_busy\n    \n    # Generate all possible 30-minute slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + 30 <= work_end:\n        slot_start = current_time\n        slot_end = current_time + 30\n        possible_slots.append((slot_start, slot_end))\n        current_time += 30  # Check every 30 minutes\n    \n    # Check each slot for availability and Natalie's preference\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        # Check if slot is within Natalie's preference\n        if slot_end > preference_end:\n            continue\n        # Check if slot overlaps with any busy time\n        overlap = False\n        for busy_start, busy_end in all_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                overlap = True\n                break\n        if not overlap:\n            # Convert back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_180"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define each person's busy times in minutes since midnight\n    # Samuel is free all day\n    samuel_busy = []\n    \n    # Evelyn's busy times\n    evelyn_busy = [\n        (9 * 60, 10 * 60),\n        (11 * 60, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    \n    # Ruth's busy times\n    ruth_busy = [\n        (9 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Amanda's busy times and constraint (not before 16:00)\n    amanda_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    amanda_constraint = 16 * 60  # Can't meet before 16:00\n    \n    # Combine all busy times\n    all_busy = []\n    all_busy.extend(evelyn_busy)\n    all_busy.extend(ruth_busy)\n    all_busy.extend(amanda_busy)\n    \n    # Sort all busy times by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    prev_end = work_start\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > prev_end:\n            free_slots.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n    \n    # Check the remaining time after the last busy slot\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Filter free slots that meet duration and Amanda's constraint\n    possible_slots = []\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Check if the slot is after Amanda's constraint\n            if slot_start >= amanda_constraint:\n                possible_slots.append((slot_start, slot_end))\n    \n    # Select the earliest possible slot\n    if possible_slots:\n        meeting_start = possible_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Format the output as HH:MM:HH:MM\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_181"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert each participant's busy slots to minutes\n    emma_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 11 * 60),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    doris_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (12 * 60 + 30, 13 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    randy_busy = [\n        (9 * 60 + 30, 11 * 60),\n        (12 * 60 + 30, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n    # Ann is free all day\n\n    # Combine all busy slots\n    all_busy = emma_busy + doris_busy + randy_busy\n\n    # Sort busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the time after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Filter free slots that are at least 30 minutes and meet Doris's preference (before or at 12:30)\n    meeting_duration = 30\n    valid_slots = []\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Check if the slot starts before or at 12:30 (Doris's preference)\n            if start <= 12 * 60 + 30:\n                valid_slots.append((start, end))\n\n    # If no slots before 12:30, consider all free slots\n    if not valid_slots:\n        valid_slots = [slot for slot in free_slots if slot[1] - slot[0] >= meeting_duration]\n\n    # Select the earliest possible slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n    else:\n        return \"No available slot found\"\n\n    # Convert back to HH:MM format\n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n\n    return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_182"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since midnight\n    benjamin_busy = [\n        (12 * 60 + 30, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60 + 30)\n    ]\n    philip_busy = [\n        (11 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    jessica_busy = [\n        (9 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60 + 30, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    ashley_busy = [\n        (10 * 60, 12 * 60),\n        (12 * 60 + 30, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60, 16 * 60 + 30)\n    ]\n\n    # Combine all busy slots\n    all_busy = benjamin_busy + philip_busy + jessica_busy + ashley_busy\n\n    # Generate free slots by finding gaps between busy slots\n    all_busy.sort()  # Sort by start time\n    free_slots = []\n    previous_end = work_start\n\n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the earliest free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_183"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:00:15:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy_slots in participants_busy.values():\n        for slot in busy_slots:\n            start, end = slot.split(' to ')\n            all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting duration\n    duration_min = duration * 60\n    for start, end in available:\n        if end - start >= duration_min:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration_min)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No available slot found\"\n\n# Define participants' busy times\nparticipants_busy = {\n    'Raymond': ['9:30 to 10:00', '12:30 to 14:30', '15:30 to 16:00'],\n    'Sophia': [],\n    'Lori': ['9:00 to 9:30', '10:30 to 13:00', '14:30 to 15:00', '15:30 to 17:00'],\n    'Dorothy': ['9:00 to 13:30', '14:00 to 15:00', '16:00 to 16:30'],\n}\n\n# Define work hours and meeting duration\nwork_hours = '9:00 to 17:00'\nduration = 0.5  # half an hour\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_184"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Convert each participant's busy slots to minutes\n    kimberly_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 12 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    marie_busy = [\n        (10 * 60, 11 * 60),\n        (11 * 60 + 30, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    diana_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 14 * 60 + 30),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    # Megan has no meetings but prefers to avoid before 10:00\n    megan_preferred_start = 10 * 60\n    \n    # Combine all busy slots\n    all_busy = kimberly_busy + marie_busy + diana_busy\n    # Add Megan's preference as a busy slot (before 10:00)\n    all_busy.append((work_start, megan_preferred_start))\n    \n    # Sort busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can fit 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_185"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:00:14:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy_times in participants_busy_times.values():\n        for start, end in busy_times:\n            all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append([start, end])\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                merged_busy[-1][1] = max(end, last_end)\n            else:\n                merged_busy.append([start, end])\n    \n    # Find free intervals between work hours and busy times\n    free_intervals = []\n    prev_end = work_start\n    for start, end in merged_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Find the first free interval that can accommodate the meeting\n    meeting_duration_min = meeting_duration * 60\n    for start, end in free_intervals:\n        if end - start >= meeting_duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' busy times\nparticipants_busy_times = {\n    'Richard': [],\n    'Frances': [],\n    'Andrea': [('9:30', '10:00'), ('10:30', '14:00'), ('14:30', '16:00'), ('16:30', '17:00')],\n    'Cheryl': [('9:00', '10:30'), ('11:00', '12:30'), ('13:00', '14:00'), ('14:30', '15:00'), ('16:00', '16:30')],\n}\n\n# Define work hours and meeting duration\nwork_hours_start = '9:00'\nwork_hours_end = '17:00'\nmeeting_duration = 0.5  # in hours\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration))\n```",
            "count": "calendar_scheduling_example_186"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Initialize busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        person_busy = []\n        for block in schedule:\n            start, end = block.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            person_busy.append((start_min, end_min))\n        busy_intervals.append(person_busy)\n    \n    # Find all possible meeting start times (every minute)\n    possible_starts = []\n    for start in range(work_start, work_end - duration + 1):\n        end = start + duration\n        valid = True\n        # Check against each participant's busy intervals\n        for person in busy_intervals:\n            for (busy_start, busy_end) in person:\n                if not (end <= busy_start or start >= busy_end):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            possible_starts.append(start)\n    \n    if not possible_starts:\n        return \"No available time slot found.\"\n    \n    # Return the first available time slot\n    meeting_start = possible_starts[0]\n    meeting_end = meeting_start + duration\n    return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n# Define participants' schedules\ndouglas = [\"10:00 to 10:30\", \"11:00 to 12:00\", \"12:30 to 13:00\", \"15:30 to 16:30\"]\ngloria = [\"10:30 to 11:00\", \"16:30 to 17:00\"]\npeter = [\"9:00 to 10:00\", \"11:00 to 11:30\", \"12:30 to 13:30\", \"14:30 to 15:00\", \"16:00 to 17:00\"]\nryan = [\"9:30 to 10:00\", \"10:30 to 11:30\", \"12:00 to 12:30\", \"13:00 to 14:00\", \"15:00 to 17:00\"]\n\nparticipants_schedules = [douglas, gloria, peter, ryan]\nduration = 30  # minutes\nwork_hours = \"9:00 to 17:00\"\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, duration, work_hours))\n```",
            "count": "calendar_scheduling_example_187"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define each participant's busy times in minutes (start, end)\n    beverly_busy = [(10*60, 11*60), (13*60, 13*60 + 30), (15*60, 15*60 + 30)]\n    brenda_busy = [(10*60 + 30, 11*60), (11*60 + 30, 12*60 + 30), (13*60, 13*60 + 30), (14*60 + 30, 15*60), (16*60 + 30, 17*60)]\n    lori_busy = [(9*60 + 30, 11*60), (12*60 + 30, 13*60), (14*60, 15*60 + 30), (16*60, 16*60 + 30)]\n    ronald_busy = [(9*60, 11*60), (11*60 + 30, 15*60 + 30), (16*60, 17*60)]\n    \n    # Beverly's preference: not before 15:00\n    preferred_start = 15 * 60\n    \n    # Meeting duration in minutes\n    duration = 30\n    \n    # Combine all busy times\n    all_busy = beverly_busy + brenda_busy + lori_busy + ronald_busy\n    \n    # Generate available slots by finding gaps between busy times\n    all_busy.sort()  # Sort by start time\n    available_slots = []\n    current_time = work_start\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > current_time:\n            available_slots.append((current_time, busy_start))\n        current_time = max(current_time, busy_end)\n    if current_time < work_end:\n        available_slots.append((current_time, work_end))\n    \n    # Filter slots that are at least 30 minutes and meet Beverly's preference\n    possible_slots = []\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration and slot_start >= preferred_start:\n            possible_slots.append((slot_start, slot_start + duration))\n    \n    # Select the earliest possible slot\n    if possible_slots:\n        meeting_start, meeting_end = possible_slots[0]\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        print(f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\")\n    else:\n        print(\"No available time slot found.\")\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_188"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:00:14:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, duration, work_start, work_end):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Initialize the free slots for the day (9:00-17:00)\n    free_slots = []\n    current_start = work_start_min\n    \n    # Collect all busy slots and sort them\n    all_busy = []\n    for busy_slots in participants_busy.values():\n        for start, end in busy_slots:\n            all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy slots\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Generate free slots between busy times\n    for start, end in merged_busy:\n        if current_start < start:\n            free_slots.append((current_start, start))\n        current_start = max(current_start, end)\n    if current_start < work_end_min:\n        free_slots.append((current_start, work_end_min))\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                h = minutes // 60\n                m = minutes % 60\n                return f\"{h:02d}:{m:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    return None\n\n# Define participants' busy times\nparticipants_busy = {\n    'Judy': [('9:30', '10:00'), ('15:00', '15:30')],\n    'Lori': [('14:30', '15:00'), ('16:00', '16:30')],\n    'Andrea': [('9:00', '9:30'), ('10:30', '11:30'), ('12:30', '13:00'), ('13:30', '14:00'), ('15:00', '16:00'), ('16:30', '17:00')],\n    'Mark': [('9:30', '14:00'), ('14:30', '15:00'), ('16:00', '17:00')],\n}\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_busy, 0.5, '9:00', '17:00')\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_189"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' busy times in minutes (start, end)\n    cheryl_busy = [\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60, 14 * 60),\n        (15 * 60, 16 * 60 + 30)\n    ]\n    raymond_busy = [\n        (11 * 60, 11 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60 + 30)\n    ]\n    karen_busy = [\n        (9 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 14 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    joan_busy = [\n        (9 * 60, 10 * 60 + 30),\n        (11 * 60, 12 * 60 + 30),\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n\n    # Raymond's preference: not after 11:30 (so before 11:30)\n    # But since all his busy times start at or after 11:00, we can ignore this preference\n    # because no slots are available before 11:30 that work for everyone.\n\n    # Combine all busy times and sort\n    all_busy = cheryl_busy + raymond_busy + karen_busy + joan_busy\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    prev_end = work_start\n\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n\n    if work_end > prev_end:\n        free_slots.append((prev_end, work_end))\n\n    # Check for a 30-minute slot\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Found a suitable slot\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_190"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:30:12:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, meeting_duration, work_hours_start, work_hours_end):\n    # Convert all time strings to minutes since start of the day\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals from all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for sufficient duration\n    meeting_duration_min = meeting_duration * 60\n    for start, end in free_intervals:\n        if end - start >= meeting_duration_min:\n            meeting_end = start + meeting_duration_min\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Beverly's calendar is wide open\n    [],  # Austin is free the entire day\n    [\"09:00:09:30\", \"10:30:11:00\", \"12:00:12:30\", \"13:30:15:00\", \"15:30:16:30\"],  # Rachel\n    [\"09:30:11:30\", \"12:00:13:30\", \"14:00:15:30\", \"16:00:17:00\"],  # Andrea\n]\n\n# Find a 30-minute meeting between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, 30, \"09:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_191"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each participant's busy slots to minutes\n    thomas_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    \n    amanda_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (13 * 60 + 30, 14 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    joe_busy = [\n        (9 * 60, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    # Joe cannot meet after 14:00, so add constraint\n    joe_busy.append((14 * 60, 17 * 60))\n    \n    christina_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (11 * 60, 13 * 60),\n        (14 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Combine all busy slots\n    all_busy = thomas_busy + amanda_busy + joe_busy + christina_busy\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check if there's a free slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Look for the first free slot that is at least 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert start time back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_time = start + meeting_duration\n            end_hh = end_time // 60\n            end_mm = end_time % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_192"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours\n    start_min = time_to_minutes(start_work)\n    end_min = time_to_minutes(end_work)\n    \n    # Initialize a list to track busy intervals for all participants\n    all_busy = []\n    for busy_slots in participants_busy:\n        participant_busy = []\n        for slot in busy_slots:\n            start, end = slot\n            participant_busy.append((time_to_minutes(start), time_to_minutes(end)))\n        all_busy.append(participant_busy)\n    \n    # Find all possible slots where no one is busy\n    possible_slots = []\n    current_time = start_min\n    \n    while current_time + duration <= end_min:\n        slot_valid = True\n        for participant in all_busy:\n            for busy_start, busy_end in participant:\n                if not (current_time + duration <= busy_start or current_time >= busy_end):\n                    slot_valid = False\n                    break\n            if not slot_valid:\n                break\n        \n        if slot_valid:\n            possible_slots.append((current_time, current_time + duration))\n            current_time += duration\n        else:\n            current_time += 1  # Check next minute\n    \n    if not possible_slots:\n        return None\n    \n    # Return the first valid slot\n    first_slot = possible_slots[0]\n    start_time = minutes_to_time(first_slot[0])\n    end_time = minutes_to_time(first_slot[1])\n    return f\"{start_time}:{end_time}\"\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 30  # minutes\n\n# Define busy slots for each participant\nparticipants_busy = [\n    [(\"9:30\", \"10:00\"), (\"10:30\", \"11:00\"), (\"11:30\", \"12:00\"), (\"13:30\", \"14:00\"), (\"15:00\", \"15:30\"), (\"16:00\", \"16:30\")],  # Lisa\n    [(\"9:00\", \"9:30\"), (\"11:30\", \"12:00\"), (\"14:00\", \"15:00\")],  # Joshua\n    [(\"9:00\", \"10:30\"), (\"11:00\", \"12:00\"), (\"12:30\", \"13:30\"), (\"14:00\", \"15:00\"), (\"16:30\", \"17:00\")],  # James\n    [(\"9:00\", \"14:00\"), (\"14:30\", \"15:30\"), (\"16:00\", \"17:00\")]  # Steven\n]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_193"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours=('09:00', '17:00')):\n    # Convert all time strings to minutes since 9:00 for easier comparison\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work_hours start at 9:00\n\n    work_start, work_end = work_hours\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n\n    # Collect all busy intervals for each participant\n    busy_intervals = []\n    for schedule in participants_schedules.values():\n        for busy in schedule:\n            start, end = busy.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            busy_intervals.append((start_min, end_min))\n\n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n\n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start_min\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n\n    # Now, find overlapping free intervals across all participants\n    # To simplify, we'll merge all busy intervals and find gaps\n    # But in reality, we should find common free times across all participants\n    # So a better approach is to find times when no one is busy\n    # Let's instead find all busy intervals for any participant and invert them\n\n    # Merge all busy intervals from all participants\n    merged_busy = []\n    for start, end in busy_intervals:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n\n    # Now find gaps between merged busy intervals\n    common_free = []\n    prev_end = work_start_min\n    for start, end in merged_busy:\n        if start > prev_end:\n            common_free.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        common_free.append((prev_end, work_end_min))\n\n    # Find the first free interval that can fit the meeting\n    for start, end in common_free:\n        if end - start >= duration_minutes:\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = 9 + minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration_minutes)\n            return f\"{meeting_start}:{meeting_end}\"\n\n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    'Dennis': [\n        '9:30 to 10:30',\n        '11:30 to 12:00',\n        '13:30 to 14:00',\n        '14:30 to 15:00',\n        '15:30 to 16:00'\n    ],\n    'Victoria': [\n        '9:00 to 9:30',\n        '10:30 to 11:00',\n        '11:30 to 12:00',\n        '12:30 to 13:00',\n        '14:30 to 15:30'\n    ],\n    'Samantha': [\n        '9:00 to 10:00',\n        '10:30 to 11:00',\n        '11:30 to 12:30',\n        '13:00 to 14:00',\n        '14:30 to 15:00',\n        '16:00 to 17:00'\n    ],\n    'Jeffrey': [\n        '9:00 to 9:30',\n        '10:30 to 11:00',\n        '11:30 to 13:00',\n        '13:30 to 15:00',\n        '15:30 to 16:00',\n        '16:30 to 17:00'\n    ]\n}\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_194"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define busy intervals for each participant in minutes since midnight\n    donna_busy = [(11 * 60 + 30, 12 * 60), (14 * 60 + 30, 15 * 60)]\n    andrea_busy = [(9 * 60, 9 * 60 + 30), (11 * 60 + 30, 14 * 60), (15 * 60 + 30, 16 * 60 + 30)]\n    dylan_busy = [(9 * 60, 9 * 60 + 30), (10 * 60, 11 * 60), (11 * 60 + 30, 17 * 60)]\n    \n    # Aaron's constraint: avoid after 10:30 (10:30 in minutes is 10*60 + 30 = 630)\n    aaron_constraint = 10 * 60 + 30\n    \n    # Meeting duration is 30 minutes\n    duration = 30\n    \n    # Generate all possible 30-minute slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + duration <= work_end:\n        slot_end = current_time + duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 1  # Check every minute\n    \n    # Check each slot against all constraints\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        \n        # Check Aaron's constraint (slot must start before or at 10:30)\n        if slot_start > aaron_constraint:\n            continue\n        \n        # Check Donna's availability\n        donna_available = True\n        for busy_start, busy_end in donna_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                donna_available = False\n                break\n        if not donna_available:\n            continue\n        \n        # Check Andrea's availability\n        andrea_available = True\n        for busy_start, busy_end in andrea_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                andrea_available = False\n                break\n        if not andrea_available:\n            continue\n        \n        # Check Dylan's availability\n        dylan_available = True\n        for busy_start, busy_end in dylan_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                dylan_available = False\n                break\n        if not dylan_available:\n            continue\n        \n        # If all checks passed, return this slot\n        return f\"{slot_start // 60:02d}:{slot_start % 60:02d}:{slot_end // 60:02d}:{slot_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_195"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy_intervals = []\n    for schedule in participants_schedules:\n        participant_busy = []\n        for busy in schedule:\n            start, end = busy.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            participant_busy.append((start_min, end_min))\n        all_busy_intervals.append(participant_busy)\n    \n    # Find all free intervals for each participant\n    all_free_intervals = []\n    for busy_intervals in all_busy_intervals:\n        free_intervals = []\n        # Sort busy intervals by start time\n        busy_intervals.sort()\n        # Check before first busy interval\n        if busy_intervals[0][0] > work_start:\n            free_intervals.append((work_start, busy_intervals[0][0]))\n        # Check between busy intervals\n        for i in range(1, len(busy_intervals)):\n            prev_end = busy_intervals[i-1][1]\n            curr_start = busy_intervals[i][0]\n            if curr_start > prev_end:\n                free_intervals.append((prev_end, curr_start))\n        # Check after last busy interval\n        if busy_intervals[-1][1] < work_end:\n            free_intervals.append((busy_intervals[-1][1], work_end))\n        all_free_intervals.append(free_intervals)\n    \n    # Find overlapping free intervals across all participants\n    common_free_intervals = all_free_intervals[0]\n    for free_intervals in all_free_intervals[1:]:\n        new_common_free = []\n        i = j = 0\n        while i < len(common_free_intervals) and j < len(free_intervals):\n            start1, end1 = common_free_intervals[i]\n            start2, end2 = free_intervals[j]\n            # Find the overlap\n            overlap_start = max(start1, start2)\n            overlap_end = min(end1, end2)\n            if overlap_start < overlap_end:\n                new_common_free.append((overlap_start, overlap_end))\n            # Move the pointer which ends first\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free_intervals = new_common_free\n    \n    # Find the first interval that can fit the duration\n    for interval in common_free_intervals:\n        start, end = interval\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = start + duration\n            return (f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\")\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"10:00 to 11:00\", \"15:00 to 15:30\", \"16:30 to 17:00\"],  # Jonathan\n    [\"10:30 to 11:00\", \"11:30 to 12:00\"],                   # Lisa\n    [\"9:00 to 13:00\", \"13:30 to 14:30\", \"15:00 to 17:00\"],  # Jerry\n    [\"9:30 to 14:30\", \"15:00 to 17:00\"]                     # Emma\n]\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30  # half an hour\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_196"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours_start=\"9:00\", work_hours_end=\"17:00\"):\n    # Convert work hours to minutes since midnight\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's schedule to find common free slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_slots.append((start, end))\n        # Sort the busy slots by start time\n        busy_slots.sort()\n        \n        # Subtract busy slots from current free slots\n        new_free_slots = []\n        for free_start, free_end in free_slots:\n            current_start = free_start\n            for busy_start, busy_end in busy_slots:\n                if busy_start > current_start:\n                    new_free_slots.append((current_start, busy_start))\n                current_start = max(current_start, busy_end)\n            if current_start < free_end:\n                new_free_slots.append((current_start, free_end))\n        free_slots = new_free_slots\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot in free_slots:\n        start, end = slot\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [],  # Hannah is free all day\n    [\"9:00 to 10:00\", \"12:00 to 12:30\", \"16:30 to 17:00\"],  # Austin\n    [\"9:00 to 10:00\", \"10:30 to 13:00\", \"13:30 to 14:00\"],  # Donna\n    [\"9:00 to 12:30\", \"13:00 to 15:00\", \"15:30 to 17:00\"],  # Bobby\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_197"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy blocks to minutes since 9:00\n    # Keith: 9:00-9:30, 10:30-12:00, 12:30-13:30\n    keith_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 13 * 60 + 30)\n    ]\n    # Wayne: 9:00-9:30, 10:30-11:00, 14:30-15:00, 16:00-16:30\n    wayne_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 11 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    # Harold: 9:00-10:00, 10:30-11:00, 11:30-12:30, 13:00-14:00, 15:00-15:30\n    harold_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (13 * 60, 14 * 60),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    # Ralph: 9:00-9:30, 10:30-15:30, 16:00-16:30\n    ralph_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 15 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n\n    # Wayne prefers after 16:00, so prioritize times after 16:00\n    preferred_start = 16 * 60\n\n    # Check if preferred time works (16:00-16:30 is blocked, so next is 16:30-17:00)\n    start_time = preferred_start + 30  # 16:30\n    end_time = start_time + meeting_duration\n    if end_time <= work_end:\n        # Check if all are free\n        all_free = True\n        # Check Keith\n        for start, end in keith_busy:\n            if not (end_time <= start or start_time >= end):\n                all_free = False\n                break\n        if all_free:\n            # Check Wayne\n            for start, end in wayne_busy:\n                if not (end_time <= start or start_time >= end):\n                    all_free = False\n                    break\n            if all_free:\n                # Check Harold\n                for start, end in harold_busy:\n                    if not (end_time <= start or start_time >= end):\n                        all_free = False\n                        break\n                if all_free:\n                    # Check Ralph\n                    for start, end in ralph_busy:\n                        if not (end_time <= start or start_time >= end):\n                            all_free = False\n                            break\n                    if all_free:\n                        return f\"{start_time // 60:02d}:{start_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n\n    # If preferred time doesn't work, check other times\n    for start_time in range(work_start, work_end - meeting_duration + 1, 15):  # check every 15 minutes\n        end_time = start_time + meeting_duration\n        if end_time > work_end:\n            continue\n        # Skip times before 16:00 due to Wayne's preference\n        if start_time < 16 * 60:\n            continue\n        # Check if all are free\n        all_free = True\n        # Check Keith\n        for start, end in keith_busy:\n            if not (end_time <= start or start_time >= end):\n                all_free = False\n                break\n        if not all_free:\n            continue\n        # Check Wayne\n        for start, end in wayne_busy:\n            if not (end_time <= start or start_time >= end):\n                all_free = False\n                break\n        if not all_free:\n            continue\n        # Check Harold\n        for start, end in harold_busy:\n            if not (end_time <= start or start_time >= end):\n                all_free = False\n                break\n        if not all_free:\n            continue\n        # Check Ralph\n        for start, end in ralph_busy:\n            if not (end_time <= start or start_time >= end):\n                all_free = False\n                break\n        if all_free:\n            return f\"{start_time // 60:02d}:{start_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n\n    # If no time after 16:00 works, check earlier (though Wayne prefers after 16:00)\n    for start_time in range(work_start, work_end - meeting_duration + 1, 15):\n        end_time = start_time + meeting_duration\n        if end_time > work_end:\n            continue\n        # Check if all are free\n        all_free = True\n        # Check Keith\n        for start, end in keith_busy:\n            if not (end_time <= start or start_time >= end):\n                all_free = False\n                break\n        if not all_free:\n            continue\n        # Check Wayne\n        for start, end in wayne_busy:\n            if not (end_time <= start or start_time >= end):\n                all_free = False\n                break\n        if not all_free:\n            continue\n        # Check Harold\n        for start, end in harold_busy:\n            if not (end_time <= start or start_time >= end):\n                all_free = False\n                break\n        if not all_free:\n            continue\n        # Check Ralph\n        for start, end in ralph_busy:\n            if not (end_time <= start or start_time >= end):\n                all_free = False\n                break\n        if all_free:\n            return f\"{start_time // 60:02d}:{start_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n\n    return \"No time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_198"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' schedules and constraints\n    schedules = {\n        'Elizabeth': [(11 * 60 + 30, 12 * 60), (13 * 60 + 30, 14 * 60), (15 * 60, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n        'Christian': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (11 * 60, 11 * 60 + 30), (12 * 60 + 30, 13 * 60 + 30), (15 * 60 + 30, 17 * 60)],\n        'Isabella': [(9 * 60 + 30, 11 * 60 + 30), (12 * 60 + 30, 13 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n    }\n    \n    # Carol's constraint: not before 12:30\n    carol_constraint = 12 * 60 + 30\n    \n    # Duration of the meeting in minutes\n    duration = 30\n    \n    # Generate all possible time slots\n    possible_slots = []\n    current_time = max(work_start, carol_constraint)\n    \n    while current_time + duration <= work_end:\n        possible_slots.append((current_time, current_time + duration))\n        current_time += 30  # Check every 30 minutes\n    \n    # Check each slot against all participants' schedules\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        valid = True\n        \n        # Check Elizabeth's schedule\n        for meeting in schedules['Elizabeth']:\n            if not (slot_end <= meeting[0] or slot_start >= meeting[1]):\n                valid = False\n                break\n        if not valid:\n            continue\n        \n        # Check Christian's schedule\n        for meeting in schedules['Christian']:\n            if not (slot_end <= meeting[0] or slot_start >= meeting[1]):\n                valid = False\n                break\n        if not valid:\n            continue\n        \n        # Check Isabella's schedule\n        for meeting in schedules['Isabella']:\n            if not (slot_end <= meeting[0] or slot_start >= meeting[1]):\n                valid = False\n                break\n        if not valid:\n            continue\n        \n        # If all checks passed, return this slot\n        start_h = slot_start // 60\n        start_m = slot_start % 60\n        end_h = slot_end // 60\n        end_m = slot_end % 60\n        return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    \n    return \"No suitable time found\"\n\n# Run the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_199"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes\n    # Format: (start_minute, end_minute)\n    stephen_busy = []\n    elijah_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    william_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    jeremy_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 12 * 60),\n        (13 * 60, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    timothy_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 14 * 60 + 30),\n        (15 * 60 + 30, 16 * 60)\n    ]\n\n    # Combine all busy slots\n    all_busy = elijah_busy + william_busy + jeremy_busy + timothy_busy\n\n    # Generate free slots by inverting busy slots\n    all_busy.sort()  # Sort by start time\n    free_slots = []\n    previous_end = work_start\n\n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_200"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each participant's blocked times to minutes since midnight\n    sarah_blocks = [(12 * 60, 12 * 60 + 30), (15 * 60, 15 * 60 + 30)]\n    shirley_blocks = [(13 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60)]\n    harold_blocks = [(9 * 60, 10 * 60), (10 * 60 + 30, 12 * 60 + 30), (13 * 60, 17 * 60)]\n    terry_blocks = [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60 + 30), (12 * 60, 17 * 60)]\n    \n    # Sara has no meetings, so no blocks\n    \n    # Combine all blocked times\n    all_blocks = sarah_blocks + shirley_blocks + harold_blocks + terry_blocks\n    \n    # Sort blocks by start time\n    all_blocks.sort()\n    \n    # Find free slots by checking gaps between blocks and work hours\n    free_slots = []\n    previous_end = work_start\n    \n    for block in all_blocks:\n        if block[0] > previous_end:\n            free_slots.append((previous_end, block[0]))\n        previous_end = max(previous_end, block[1])\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Check for a slot that is at least 30 minutes long\n    meeting_duration = 30\n    for slot in free_slots:\n        if slot[1] - slot[0] >= meeting_duration:\n            # Return the first suitable slot\n            start_hour = slot[0] // 60\n            start_min = slot[0] % 60\n            end_hour = (slot[0] + meeting_duration) // 60\n            end_min = (slot[0] + meeting_duration) % 60\n            return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_201"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n\n    # Collect all busy intervals for all participants\n    all_busy_intervals = []\n    for busy_times in participants_busy_times.values():\n        for interval in busy_times:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            all_busy_intervals.append((start, end))\n\n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n\n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in all_busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n\n    # Check each free interval for availability for all participants\n    for interval in free_intervals:\n        start, end = interval\n        duration = end - start\n        if duration >= meeting_duration:\n            # Check if this interval is free for all participants\n            valid = True\n            for participant, busy_times in participants_busy_times.items():\n                participant_free = True\n                # Check if the interval overlaps with any of the participant's busy times\n                for busy_interval in busy_times:\n                    busy_start, busy_end = map(time_to_minutes, busy_interval.split(' to '))\n                    if not (end <= busy_start or start >= busy_end):\n                        participant_free = False\n                        break\n                if not participant_free:\n                    valid = False\n                    break\n            if valid:\n                meeting_end = start + meeting_duration\n                return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No suitable time found\"\n\n# Define the participants' busy times\nparticipants_busy_times = {\n    \"Lawrence\": [],\n    \"Christine\": [\"9:00 to 9:30\", \"12:30 to 13:00\"],\n    \"Barbara\": [\"10:30 to 11:30\", \"12:00 to 12:30\", \"13:00 to 13:30\", \"14:00 to 14:30\", \"15:30 to 16:00\"],\n    \"Stephanie\": [\"10:00 to 11:00\", \"11:30 to 12:00\", \"12:30 to 13:30\", \"14:30 to 15:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"],\n    \"Hannah\": [\"9:00 to 10:00\", \"10:30 to 12:00\", \"12:30 to 13:00\", \"14:00 to 15:30\", \"16:00 to 16:30\"]\n}\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 30  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_202"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time slots to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n\n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n\n    # Function to subtract busy slots from free slots\n    def subtract_busy_slots(free_slots, busy_start, busy_end):\n        new_free_slots = []\n        for slot_start, slot_end in free_slots:\n            if busy_start >= slot_end or busy_end <= slot_start:\n                new_free_slots.append((slot_start, slot_end))\n            else:\n                if slot_start < busy_start:\n                    new_free_slots.append((slot_start, busy_start))\n                if slot_end > busy_end:\n                    new_free_slots.append((busy_end, slot_end))\n        return new_free_slots\n\n    # Process each participant's busy slots\n    for participant, busy_slots in participants_schedules.items():\n        for busy_start_str, busy_end_str in busy_slots:\n            busy_start = time_to_minutes(busy_start_str)\n            busy_end = time_to_minutes(busy_end_str)\n            free_slots = subtract_busy_slots(free_slots, busy_start, busy_end)\n\n    # Find the earliest slot that fits the duration\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = {\n    'Elijah': [('10:00', '11:00'), ('12:00', '12:30'), ('15:00', '15:30')],\n    'Janet': [('9:30', '10:30'), ('13:30', '15:30')],\n    'Brian': [],\n    'Carl': [('9:30', '16:30')],\n    'Timothy': [('10:30', '12:00'), ('13:30', '14:00'), ('14:30', '16:00'), ('16:30', '17:00')]\n}\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, '9:00', '17:00', 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_203"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability for all participants\n    # Since the problem states a solution exists, we return the first suitable interval\n    for interval in free_intervals:\n        start, end = interval\n        if end - start >= duration:\n            meeting_end = start + duration\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\n# Define each participant's busy times\nparticipants_schedules = [\n    [\"10:00 to 10:30\", \"11:30 to 12:00\", \"12:30 to 13:00\", \"13:30 to 14:00\", \"15:00 to 15:30\", \"16:00 to 16:30\"],  # Benjamin\n    [\"10:00 to 10:30\", \"11:00 to 11:30\", \"12:00 to 12:30\", \"14:30 to 16:00\"],  # Juan\n    [\"9:00 to 9:30\", \"10:00 to 10:30\", \"12:30 to 13:00\", \"14:00 to 14:30\"],  # Heather\n    [\"9:00 to 11:00\", \"11:30 to 12:30\", \"14:00 to 14:30\", \"15:00 to 16:00\", \"16:30 to 17:00\"],  # Nathan\n    [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:00 to 13:00\", \"13:30 to 15:00\", \"15:30 to 17:00\"],  # Jacob\n]\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes))\n```",
            "count": "calendar_scheduling_example_204"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:30:12:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n\n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(':'))\n            busy_intervals.append((start, end))\n\n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n\n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Find the first available slot that can fit the meeting\n    duration_minutes = duration * 60\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"10:30:11:30\", \"12:00:12:30\", \"13:00:13:30\", \"14:00:14:30\", \"15:00:15:30\"],  # Julia\n    [],                                                                           # Joshua\n    [\"09:00:09:30\", \"12:00:12:30\", \"15:30:16:30\"],                                # Nicholas\n    [\"09:00:11:00\", \"12:00:12:30\", \"13:00:13:30\", \"14:00:15:00\", \"16:00:17:00\"], # David\n    [\"09:00:09:30\", \"12:30:13:00\", \"13:30:15:00\", \"15:30:17:00\"],                # Melissa\n]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, 30, \"09:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_205"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Convert all schedules to minutes since midnight\n    # Each person's busy times are represented as a list of (start, end) tuples in minutes\n    schedules = {\n        'Shirley': [(10 * 60 + 30, 11 * 60), (12 * 60, 12 * 60 + 30)],\n        'Jacob': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (11 * 60, 11 * 60 + 30),\n                  (12 * 60 + 30, 13 * 60 + 30), (14 * 60 + 30, 15 * 60)],\n        'Stephen': [(11 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60)],\n        'Margaret': [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 12 * 60 + 30), (13 * 60, 13 * 60 + 30),\n                     (15 * 60, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n        'Mason': [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60), (11 * 60 + 30, 12 * 60 + 30),\n                  (13 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n    }\n    \n    # Margaret's preference: not before 14:30\n    margaret_preference_start = 14 * 60 + 30\n    \n    # Meeting duration in minutes\n    meeting_duration = 30\n    \n    # Collect all busy times from all participants\n    all_busy = []\n    for person in schedules:\n        for start, end in schedules[person]:\n            all_busy.append((start, end))\n    \n    # Sort all busy times by start time\n    all_busy.sort()\n    \n    # Find available slots by merging busy intervals\n    available_slots = []\n    current_start = work_start\n    \n    for start, end in all_busy:\n        if start > current_start:\n            available_slots.append((current_start, start))\n        current_start = max(current_start, end)\n    \n    if current_start < work_end:\n        available_slots.append((current_start, work_end))\n    \n    # Filter slots that are at least meeting_duration long and meet Margaret's preference\n    valid_slots = []\n    for start, end in available_slots:\n        slot_start = max(start, margaret_preference_start)\n        if end - slot_start >= meeting_duration:\n            valid_slots.append((slot_start, end))\n    \n    # The first valid slot is the earliest possible meeting time\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available time slot found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_206"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, duration, work_start, work_end):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n\n    # Initialize the free slots for each participant\n    free_slots = []\n    for participant in participants_busy:\n        busy_slots = participants_busy[participant]\n        # Convert busy slots to minutes\n        busy_min = []\n        for slot in busy_slots:\n            start, end = map(time_to_minutes, slot.split(':'))\n            busy_min.append((start, end))\n        # Sort busy slots by start time\n        busy_min.sort()\n        # Generate free slots\n        free = []\n        prev_end = work_start_min\n        for start, end in busy_min:\n            if start > prev_end:\n                free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end_min:\n            free.append((prev_end, work_end_min))\n        free_slots.append(free)\n\n    # Find common free slots\n    common_free = free_slots[0]\n    for free in free_slots[1:]:\n        new_common = []\n        i = j = 0\n        while i < len(common_free) and j < len(free):\n            start1, end1 = common_free[i]\n            start2, end2 = free[j]\n            # Find overlap\n            start = max(start1, start2)\n            end = min(end1, end2)\n            if start < end:\n                new_common.append((start, end))\n            # Move the pointer which ends first\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free = new_common\n\n    # Find the earliest slot that fits the duration\n    for start, end in common_free:\n        if end - start >= duration_min:\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration_min)\n            return f\"{meeting_start}:{meeting_end}\"\n    return None\n\n# Define participants' busy slots\nparticipants_busy = {\n    'Walter': [],\n    'Danielle': [],\n    'Julia': ['09:30:10:00', '10:30:11:00', '13:30:14:00', '16:00:16:30'],\n    'Samuel': ['09:00:11:00', '11:30:12:30', '13:00:14:30', '15:00:15:30', '16:00:17:00'],\n    'Lori': ['10:00:10:30', '11:00:11:30', '12:00:12:30', '13:00:14:30', '15:00:17:00'],\n}\n\n# Meeting duration in hours (0.5 hours = 30 minutes)\nduration = 0.5\nwork_start = '09:00'\nwork_end = '17:00'\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy, duration, work_start, work_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_207"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define each person's busy times in minutes (start, end)\n    busy_times = {\n        'Jesse': [(10 * 60, 10 * 60 + 30), (15 * 60, 15 * 60 + 30)],\n        'Nancy': [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 11 * 60), (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60)],\n        'Isabella': [(9 * 60, 10 * 60), (11 * 60 + 30, 12 * 60), (15 * 60 + 30, 16 * 60)],\n        'Harold': [(9 * 60, 10 * 60), (10 * 60 + 30, 16 * 60 + 30)],\n        'Linda': [(9 * 60, 10 * 60), (12 * 60, 12 * 60 + 30), (13 * 60 + 30, 16 * 60)],\n    }\n    \n    # Combine all busy times and sort\n    all_busy = []\n    for person in busy_times:\n        all_busy.extend(busy_times[person])\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Check each free slot for availability for all participants\n    meeting_duration = 30\n    valid_slots = []\n    \n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Check if all participants are free during this slot\n            all_free = True\n            for person in busy_times:\n                person_busy = busy_times[person]\n                for busy_start, busy_end in person_busy:\n                    if not (slot_start >= busy_end or slot_start + meeting_duration <= busy_start):\n                        # Overlap found, person is busy\n                        all_free = False\n                        break\n                if not all_free:\n                    break\n            if all_free:\n                valid_slots.append((slot_start, slot_start + meeting_duration))\n    \n    # Return the first valid slot found\n    if valid_slots:\n        start = valid_slots[0][0]\n        end = valid_slots[0][1]\n        # Convert minutes back to HH:MM format\n        start_hh = start // 60\n        start_mm = start % 60\n        end_hh = end // 60\n        end_mm = end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No valid slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_208"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Convert each participant's busy slots to minutes\n    michael_busy = [(10 * 60 + 30, 11 * 60), (14 * 60 + 30, 15 * 60)]\n    samuel_busy = [(10 * 60 + 30, 11 * 60), (12 * 60 + 30, 13 * 60), \n                    (13 * 60 + 30, 14 * 60 + 30), (15 * 60 + 30, 16 * 60), \n                    (16 * 60 + 30, 17 * 60)]\n    aaron_busy = [(11 * 60, 11 * 60 + 30), (12 * 60 + 30, 13 * 60), \n                   (13 * 60 + 30, 14 * 60), (15 * 60, 15 * 60 + 30), \n                   (16 * 60, 17 * 60)]\n    judith_busy = [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 11 * 60 + 30), \n                    (12 * 60, 12 * 60 + 30), (14 * 60, 15 * 60), \n                    (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)]\n    kevin_busy = [(9 * 60, 11 * 60), (11 * 60 + 30, 13 * 60), \n                   (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60), \n                   (15 * 60 + 30, 16 * 60)]\n    \n    # Combine all busy slots\n    all_busy = michael_busy + samuel_busy + aaron_busy + judith_busy + kevin_busy\n    \n    # Generate free slots by inverting busy slots\n    free_slots = []\n    current_time = work_start\n    \n    # Sort all busy slots by start time\n    all_busy_sorted = sorted(all_busy, key=lambda x: x[0])\n    \n    for busy_start, busy_end in all_busy_sorted:\n        if busy_start > current_time:\n            free_slots.append((current_time, busy_start))\n        current_time = max(current_time, busy_end)\n    \n    if current_time < work_end:\n        free_slots.append((current_time, work_end))\n    \n    # Find the first free slot that is at least 30 minutes long\n    meeting_duration = 30\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Convert back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = (slot_start + meeting_duration) // 60\n            end_mm = (slot_start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_209"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each person's busy slots to minutes\n    raymond_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60, 11 * 60 + 30),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    daniel_busy = [\n        (11 * 60, 11 * 60 + 30),\n        (14 * 60, 14 * 60 + 30)\n    ]\n    \n    julia_busy = [\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60)\n    ]\n    \n    laura_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 12 * 60 + 30),\n        (15 * 60 + 30, 16 * 60 + 30)\n    ]\n    \n    willie_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 12 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Combine all busy slots\n    all_busy = raymond_busy + daniel_busy + julia_busy + laura_busy + willie_busy\n    \n    # Generate free slots by inverting busy slots\n    free_slots = []\n    current_time = work_start\n    \n    # Sort all busy slots by start time\n    sorted_busy = sorted(all_busy, key=lambda x: x[0])\n    \n    for busy_start, busy_end in sorted_busy:\n        if busy_start > current_time:\n            free_slots.append((current_time, busy_start))\n        current_time = max(current_time, busy_end)\n    \n    if current_time < work_end:\n        free_slots.append((current_time, work_end))\n    \n    # Check each free slot to see if it's free for everyone\n    meeting_duration = 30\n    valid_slots = []\n    \n    for slot_start, slot_end in free_slots:\n        slot_duration = slot_end - slot_start\n        if slot_duration >= meeting_duration:\n            # Check if this slot is free for everyone\n            raymond_free = all(not (busy_end > slot_start and busy_start < slot_start + meeting_duration) for busy_start, busy_end in raymond_busy)\n            daniel_free = all(not (busy_end > slot_start and busy_start < slot_start + meeting_duration) for busy_start, busy_end in daniel_busy)\n            julia_free = all(not (busy_end > slot_start and busy_start < slot_start + meeting_duration) for busy_start, busy_end in julia_busy)\n            laura_free = all(not (busy_end > slot_start and busy_start < slot_start + meeting_duration) for busy_start, busy_end in laura_busy)\n            willie_free = all(not (busy_end > slot_start and busy_start < slot_start + meeting_duration) for busy_start, busy_end in willie_busy)\n            \n            if raymond_free and daniel_free and julia_free and laura_free and willie_free:\n                valid_slots.append((slot_start, slot_start + meeting_duration))\n    \n    if not valid_slots:\n        return None\n    \n    # Find the earliest valid slot\n    earliest_slot = min(valid_slots, key=lambda x: x[0])\n    \n    # Convert to HH:MM format\n    start_hh = earliest_slot[0] // 60\n    start_mm = earliest_slot[0] % 60\n    end_hh = earliest_slot[1] // 60\n    end_mm = earliest_slot[1] % 60\n    \n    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_210"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_start, work_end):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find the earliest available slot\n    prev_end = work_start_min\n    for start, end in merged:\n        if start - prev_end >= duration_min:\n            # Found a suitable slot\n            meeting_start = prev_end\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n        prev_end = max(prev_end, end)\n    \n    # Check after the last busy interval\n    if work_end_min - prev_end >= duration_min:\n        meeting_start = prev_end\n        meeting_end = meeting_start + duration_min\n        return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Douglas is free the entire day\n    [\"09:30 to 10:00\", \"11:00 to 11:30\"],  # Mary\n    [\"09:00 to 10:00\", \"10:30 to 11:30\", \"13:30 to 14:30\"],  # Billy\n    [\"09:30 to 10:00\", \"11:00 to 11:30\", \"13:30 to 16:00\", \"16:30 to 17:00\"],  # Russell\n    [\"09:00 to 10:00\", \"10:30 to 12:00\", \"12:30 to 17:00\"],  # Judy\n]\n\n# Find the earliest available 30-minute slot between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, 30, \"09:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_211"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define busy intervals for each participant in minutes\n    katherine_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60)\n    ]\n    \n    carl_busy = [\n        (10 * 60 + 30, 11 * 60 + 30)\n    ]\n    \n    charles_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60 + 30)\n    ]\n    \n    gerald_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60)\n    ]\n    \n    stephanie_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 12 * 60),\n        (13 * 60, 14 * 60),\n        (15 * 60, 16 * 60)\n    ]\n    \n    # Combine all busy intervals\n    all_busy = katherine_busy + carl_busy + charles_busy + gerald_busy + stephanie_busy\n    \n    # Sort busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by checking gaps between busy intervals\n    free_intervals = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the interval after the last busy interval\n    if previous_end < work_end:\n        free_intervals.append((previous_end, work_end))\n    \n    # Filter out intervals that are less than 30 minutes\n    free_intervals = [(start, end) for start, end in free_intervals if end - start >= 30]\n    \n    # Apply Charles' constraint: no meetings after 16:00\n    free_intervals = [(start, end) for start, end in free_intervals if start < 16 * 60]\n    \n    # Select the first available interval\n    if free_intervals:\n        meeting_start = free_intervals[0][0]\n        meeting_end = meeting_start + 30\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_212"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_work, end_work = work_hours\n    busy_slots = []\n    \n    # Collect all busy slots from all participants\n    for schedule in participants_schedules:\n        busy_slots.extend(schedule)\n    \n    # Sort all busy slots by start time\n    busy_slots.sort()\n    \n    # Merge overlapping or adjacent busy slots\n    merged_slots = []\n    for slot in busy_slots:\n        if not merged_slots:\n            merged_slots.append(slot)\n        else:\n            last_start, last_end = merged_slots[-1]\n            current_start, current_end = slot\n            if current_start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged_slots[-1] = (new_start, new_end)\n            else:\n                merged_slots.append(slot)\n    \n    # Find free slots between work hours considering merged busy slots\n    free_slots = []\n    previous_end = start_work\n    \n    for slot in merged_slots:\n        slot_start, slot_end = slot\n        if slot_start > previous_end:\n            free_slots.append((previous_end, slot_start))\n        previous_end = max(previous_end, slot_end)\n    \n    if previous_end < end_work:\n        free_slots.append((previous_end, end_work))\n    \n    # Find the first free slot that can accommodate the meeting duration\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        if (slot_end - slot_start) >= duration:\n            return f\"{slot_start}:{slot_start + duration}\"\n    \n    return \"No suitable time found\"\n\n# Define work hours (9:00 to 17:00 in 24-hour format)\nwork_hours = (9.0, 17.0)\nmeeting_duration = 1.0  # 1 hour\n\n# Define each participant's busy slots in 24-hour format as (start, end)\njeremy_schedule = [(9.0, 9.5), (11.0, 11.5), (13.5, 14.0), (15.0, 15.5)]\ndiana_schedule = []\nbeverly_schedule = []\ndiane_schedule = [(9.0, 9.5), (10.0, 10.5), (12.5, 13.5), (14.0, 14.5), (15.5, 17.0)]\nmegan_schedule = [(9.0, 10.0), (10.5, 11.5), (12.5, 13.0), (14.0, 16.5)]\n\nparticipants_schedules = [jeremy_schedule, diana_schedule, beverly_schedule, diane_schedule, megan_schedule]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, meeting_duration)\n\n# Format the output as HH:MM:HH:MM\nif meeting_time != \"No suitable time found\":\n    start, end = meeting_time.split(':')\n    start_h = int(float(start))\n    start_m = int((float(start) - start_h) * 60)\n    end_h = int(float(end))\n    end_m = int((float(end) - end_h) * 60)\n    print(f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\")\nelse:\n    print(meeting_time)\n```",
            "count": "calendar_scheduling_example_213"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours=('09:00', '17:00')):\n    # Convert time strings to minutes since 9:00 for easier calculation\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m - 9 * 60  # Offset by 9:00 (start of work day)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        h = (minutes // 60) + 9\n        m = minutes % 60\n        return f\"{h:02d}:{m:02d}\"\n    \n    start_work, end_work = work_hours\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find the earliest available slot\n    prev_end = work_start\n    for start, end in merged:\n        if start - prev_end >= duration_minutes:\n            return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + duration_minutes)}\"\n        prev_end = max(prev_end, end)\n    \n    # Check after the last busy interval\n    if work_end - prev_end >= duration_minutes:\n        return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + duration_minutes)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Donna is free\n    [],  # Susan is free\n    [\"09:00 to 09:30\", \"11:30 to 12:00\", \"13:00 to 13:30\", \"16:30 to 17:00\"],  # Ethan\n    [\"09:30 to 10:00\", \"10:30 to 11:00\", \"11:30 to 12:00\", \"13:00 to 14:00\", \"15:00 to 16:30\"],  # Adam\n    [\"09:00 to 10:30\", \"11:00 to 11:30\", \"12:00 to 12:30\", \"13:00 to 14:30\", \"15:00 to 15:30\", \"16:00 to 16:30\"],  # Jordan\n]\n\n# Find the earliest available meeting time\nmeeting_time = find_meeting_time(participants_schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_214"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, duration, work_hours):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start, work_end = map(time_to_minutes, work_hours.split('-'))\n    duration_min = duration * 60\n\n    # Generate all busy intervals for all participants\n    all_busy = []\n    for busy_times in participants_busy_times.values():\n        for start, end in busy_times:\n            all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort busy intervals by start time\n    all_busy.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find free slots between work hours and busy intervals\n    free_slots = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n\n    # Find the earliest free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define the participants' busy times\nparticipants_busy_times = {\n    \"Steven\": [],\n    \"Roy\": [],\n    \"Cynthia\": [\n        (\"09:30\", \"10:30\"),\n        (\"11:30\", \"12:00\"),\n        (\"13:00\", \"13:30\"),\n        (\"15:00\", \"16:00\")\n    ],\n    \"Lauren\": [\n        (\"09:00\", \"09:30\"),\n        (\"10:30\", \"11:00\"),\n        (\"11:30\", \"12:00\"),\n        (\"13:00\", \"13:30\"),\n        (\"14:00\", \"14:30\"),\n        (\"15:00\", \"15:30\"),\n        (\"16:00\", \"17:00\")\n    ],\n    \"Robert\": [\n        (\"10:30\", \"11:00\"),\n        (\"11:30\", \"12:00\"),\n        (\"12:30\", \"13:30\"),\n        (\"14:00\", \"16:00\")\n    ]\n}\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, 30, \"09:00-17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_215"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each participant's busy slots to minutes since 9:00\n    # Format: (start_minute, end_minute)\n    kathleen_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    ashley_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (15 * 60 + 30, 16 * 60 + 30)\n    ]\n    christian_busy = [\n        (9 * 60, 13 * 60),\n        (13 * 60 + 30, 15 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    matthew_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60 + 30),\n        (15 * 60, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n\n    # Combine all busy slots\n    all_busy = []\n    all_busy.extend(kathleen_busy)\n    all_busy.extend(ashley_busy)\n    all_busy.extend(christian_busy)\n    all_busy.extend(matthew_busy)\n\n    # Sort busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n\n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n\n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_216"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define each person's busy times in minutes since midnight\n    # Format: (start, end) in minutes\n    busy_times = {\n        'Lauren': [(9 * 60 + 30, 10 * 60), (14 * 60 + 30, 15 * 60)],\n        'Willie': [(9 * 60 + 30, 11 * 60 + 30), (12 * 60 + 30, 14 * 60), (15 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Lori': [(9 * 60 + 30, 10 * 60), (11 * 60, 11 * 60 + 30), (12 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30), (15 * 60, 16 * 60)],\n    }\n\n    # Lauren cannot meet after 14:30 (14*60 + 30)\n    lauren_cutoff = 14 * 60 + 30\n\n    # Combine all busy times and sort them\n    all_busy = []\n    for person, times in busy_times.items():\n        for start, end in times:\n            all_busy.append((start, end))\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy times and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Filter free slots that are at least meeting_duration long and before Lauren's cutoff\n    valid_slots = []\n    for start, end in free_slots:\n        if end - start >= meeting_duration and start + meeting_duration <= lauren_cutoff:\n            valid_slots.append((start, end))\n\n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_217"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each person's busy slots to minutes\n    sharon_busy = [\n        (12 * 60, 13 * 60),\n        (13 * 60 + 30, 14 * 60 + 30),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    elizabeth_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60)\n    ]\n    danielle_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 11 * 60),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60 + 30, 14 * 60)\n    ]\n    david_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60, 14 * 60 + 30),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    charles_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 11 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (15 * 60, 17 * 60)\n    ]\n    \n    # Combine all busy slots\n    all_busy = sharon_busy + elizabeth_busy + danielle_busy + david_busy + charles_busy\n    \n    # Generate free slots by inverting busy slots\n    free_slots = []\n    current_time = work_start\n    \n    # Sort all busy slots by start time\n    all_busy_sorted = sorted(all_busy, key=lambda x: x[0])\n    \n    for busy_start, busy_end in all_busy_sorted:\n        if busy_start > current_time:\n            free_slots.append((current_time, busy_start))\n        current_time = max(current_time, busy_end)\n    \n    if current_time < work_end:\n        free_slots.append((current_time, work_end))\n    \n    # Check each free slot to see if it's free for everyone\n    meeting_duration = 30\n    valid_slots = []\n    \n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Check if this slot is free for everyone\n            is_free_for_all = True\n            \n            # Check Sharon\n            for busy_start, busy_end in sharon_busy:\n                if not (slot_start >= busy_end or slot_start + meeting_duration <= busy_start):\n                    is_free_for_all = False\n                    break\n            if not is_free_for_all:\n                continue\n            \n            # Check Elizabeth\n            for busy_start, busy_end in elizabeth_busy:\n                if not (slot_start >= busy_end or slot_start + meeting_duration <= busy_start):\n                    is_free_for_all = False\n                    break\n            if not is_free_for_all:\n                continue\n            \n            # Check Danielle\n            for busy_start, busy_end in danielle_busy:\n                if not (slot_start >= busy_end or slot_start + meeting_duration <= busy_start):\n                    is_free_for_all = False\n                    break\n            if not is_free_for_all:\n                continue\n            \n            # Check David\n            for busy_start, busy_end in david_busy:\n                if not (slot_start >= busy_end or slot_start + meeting_duration <= busy_start):\n                    is_free_for_all = False\n                    break\n            if not is_free_for_all:\n                continue\n            \n            # Check Charles\n            for busy_start, busy_end in charles_busy:\n                if not (slot_start >= busy_end or slot_start + meeting_duration <= busy_start):\n                    is_free_for_all = False\n                    break\n            if not is_free_for_all:\n                continue\n            \n            valid_slots.append((slot_start, slot_start + meeting_duration))\n    \n    if valid_slots:\n        # Return the first valid slot\n        start = valid_slots[0][0]\n        end = valid_slots[0][1]\n        # Convert to HH:MM format\n        start_hh = start // 60\n        start_mm = start % 60\n        end_hh = end // 60\n        end_mm = end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_218"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = busy.split(' to ')\n            busy_start = time_to_minutes(start)\n            busy_end = time_to_minutes(end)\n            busy_intervals.append((busy_start, busy_end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Check each available slot for sufficient duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30  # meeting duration in minutes\n\n# Define each participant's busy intervals\nparticipants_schedules = [\n    [\"9:00 to 9:30\", \"10:00 to 11:00\", \"11:30 to 12:00\", \"14:30 to 15:30\"],  # Thomas\n    [\"12:00 to 12:30\", \"13:00 to 14:00\", \"15:00 to 15:30\"],  # Terry\n    [\"11:30 to 12:00\", \"12:30 to 13:30\", \"14:00 to 14:30\", \"16:00 to 17:00\"],  # Kenneth\n    [\"9:30 to 10:00\", \"10:30 to 11:30\", \"12:00 to 14:00\", \"15:00 to 15:30\", \"16:00 to 17:00\"],  # Andrew\n    [\"9:00 to 10:30\", \"11:30 to 13:00\", \"13:30 to 14:30\", \"15:00 to 15:30\", \"16:00 to 16:30\"],  # Sharon\n]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_219"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy times in minutes (start, end)\n    mason_busy = []\n    evelyn_busy = []\n    jose_busy = [(9 * 60 + 30, 10 * 60), (11 * 60 + 30, 12 * 60)]\n    helen_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (11 * 60, 12 * 60),\n        (13 * 60, 14 * 60 + 30),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    beverly_busy = [\n        (9 * 60, 12 * 60 + 30),\n        (13 * 60, 15 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Jose cannot meet after 15:30\n    jose_constraint = 15 * 60 + 30\n    \n    # Combine all busy times\n    all_busy = []\n    all_busy.extend([(start, end, 'Jose') for start, end in jose_busy])\n    all_busy.extend([(start, end, 'Helen') for start, end in helen_busy])\n    all_busy.extend([(start, end, 'Beverly') for start, end in beverly_busy])\n    \n    # Sort busy times by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = work_start\n    \n    for busy_start, busy_end, _ in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    # Check the end of the day\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Filter free slots that are at least 30 minutes and respect Jose's constraint\n    meeting_duration = 30\n    valid_slots = []\n    \n    for start, end in free_slots:\n        if end > jose_constraint:\n            end = min(end, jose_constraint)\n            if end <= start:\n                continue\n        if end - start >= meeting_duration:\n            valid_slots.append((start, end))\n    \n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n    else:\n        return None\n    \n    # Convert to HH:MM format\n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n    \n    start_time = minutes_to_time(meeting_start)\n    end_time = minutes_to_time(meeting_end)\n    \n    return f\"{start_time}:{end_time}\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_220"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define each participant's busy times in minutes since midnight\n    busy_times = {\n        'Megan': [(12 * 60, 12 * 60 + 30), (15 * 60 + 30, 16 * 60)],\n        'Jacob': [],\n        'Kathryn': [],\n        'Keith': [(9 * 60, 11 * 60), (11 * 60 + 30, 12 * 60 + 30), (13 * 60 + 30, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Matthew': [(9 * 60 + 30, 11 * 60 + 30), (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60 + 30)],\n    }\n\n    # Combine all busy times and sort them\n    all_busy = []\n    for person in busy_times:\n        for start, end in busy_times[person]:\n            all_busy.append((start, end))\n    all_busy.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n\n    # Find available slots by checking gaps between busy times\n    available_slots = []\n    previous_end = work_start\n    for start, end in merged_busy:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n\n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No available time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_221"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 (9:00)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = (minutes + 540) // 60\n        mm = (minutes + 540) % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Initialize the availability list (all times are available)\n    start_min = time_to_minutes(work_hours[0])\n    end_min = time_to_minutes(work_hours[1])\n    total_slots = end_min - start_min\n    availability = [True] * total_slots\n    \n    # Mark busy times for each participant\n    for person in participants_busy:\n        for busy_range in person:\n            start = time_to_minutes(busy_range[0])\n            end = time_to_minutes(busy_range[1])\n            for i in range(start, end):\n                if i < total_slots:\n                    availability[i] = False\n    \n    # Find the first available slot of the given duration\n    required_slots = duration // 30  # Assuming 30-minute slots for simplicity\n    current_slot = 0\n    while current_slot <= total_slots - required_slots:\n        if all(availability[current_slot + i] for i in range(required_slots)):\n            start_time = minutes_to_time(current_slot)\n            end_time = minutes_to_time(current_slot + required_slots * 30)\n            return f\"{start_time}:{end_time}\"\n        current_slot += 1\n    \n    return \"No available time slot found\"\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 30  # minutes\n\n# Define participants' busy times\nparticipants_busy = [\n    [(\"9:30\", \"10:00\"), (\"10:30\", \"11:00\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:00\")],  # Betty\n    [(\"11:30\", \"12:30\"), (\"14:00\", \"15:00\")],  # Evelyn\n    [(\"9:30\", \"10:00\"), (\"10:30\", \"11:00\"), (\"11:30\", \"12:00\"), (\"13:00\", \"13:30\"), (\"15:00\", \"16:00\")],  # John\n    [(\"10:30\", \"13:00\"), (\"13:30\", \"17:00\")],  # Andrea\n    [(\"10:00\", \"10:30\"), (\"11:00\", \"12:00\"), (\"13:00\", \"13:30\"), (\"14:00\", \"15:00\"), (\"15:30\", \"16:30\")]   # Eric\n]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_222"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:11:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Find the earliest free interval that can accommodate the meeting\n    duration_minutes = duration * 60\n    for start, end in free_intervals:\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Participants' schedules\nparticipants_schedules = [\n    [\"9:00 to 9:30\", \"12:00 to 12:30\", \"13:30 to 14:30\"],  # Frances\n    [\"15:00 to 15:30\", \"16:00 to 16:30\"],                  # Sarah\n    [\"10:00 to 10:30\", \"13:30 to 14:00\", \"14:30 to 15:30\"], # Christopher\n    [\"9:30 to 11:00\", \"12:00 to 12:30\", \"13:00 to 13:30\", \"15:00 to 16:30\"], # Bobby\n    [\"9:00 to 10:30\", \"12:00 to 12:30\", \"13:00 to 13:30\", \"14:00 to 14:30\", \"15:30 to 16:00\", \"16:30 to 17:00\"]  # Janice\n]\n\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 0.5  # half an hour\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_223"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours=('09:00', '17:00')):\n    # Convert work hours to minutes since midnight\n    start_work, end_work = work_hours\n    work_start = int(start_work.split(':')[0]) * 60 + int(start_work.split(':')[1])\n    work_end = int(end_work.split(':')[0]) * 60 + int(end_work.split(':')[1])\n    \n    # Initialize the free slots for all participants\n    free_slots = []\n    \n    for name, busy_slots in participants_schedules.items():\n        # Convert busy slots to minutes\n        busy_intervals = []\n        for slot in busy_slots:\n            start, end = slot.split(' to ')\n            start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n            end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n            busy_intervals.append((start_min, end_min))\n        \n        # Sort busy intervals\n        busy_intervals.sort()\n        \n        # Find free intervals for this participant\n        free_intervals = []\n        prev_end = work_start\n        \n        for start, end in busy_intervals:\n            if start > prev_end:\n                free_intervals.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_intervals.append((prev_end, work_end))\n        \n        free_slots.append(free_intervals)\n    \n    # Find overlapping free intervals across all participants\n    common_free_intervals = free_slots[0]\n    \n    for intervals in free_slots[1:]:\n        new_common = []\n        i = j = 0\n        while i < len(common_free_intervals) and j < len(intervals):\n            start1, end1 = common_free_intervals[i]\n            start2, end2 = intervals[j]\n            \n            # Find overlap\n            overlap_start = max(start1, start2)\n            overlap_end = min(end1, end2)\n            \n            if overlap_start < overlap_end:\n                new_common.append((overlap_start, overlap_end))\n            \n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free_intervals = new_common\n    \n    # Find the first interval that can fit the meeting\n    for start, end in common_free_intervals:\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return None\n\n# Define participants' schedules\nparticipants_schedules = {\n    'Marilyn': ['16:00 to 17:00'],\n    'Wayne': ['09:30 to 10:00', '10:30 to 11:30', '12:00 to 12:30', '13:00 to 14:00'],\n    'Julia': ['12:30 to 13:00', '14:00 to 14:30'],\n    'Deborah': ['09:00 to 11:00', '11:30 to 14:30', '15:00 to 15:30', '16:30 to 17:00'],\n    'Virginia': ['09:00 to 09:30', '10:00 to 11:30', '12:30 to 13:30', '15:00 to 17:00']\n}\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_224"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30       # 30 minutes\n    \n    # Convert each person's busy slots to minutes since midnight\n    jean_busy = [\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    doris_busy = [\n        (10 * 60, 11 * 60 + 30),\n        (12 * 60, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    \n    joan_busy = [\n        (9 * 60, 11 * 60 + 30),\n        (12 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 16 * 60 + 30)\n    ]\n    \n    # Doris cannot meet before 15:00\n    doris_constraint = 15 * 60\n    \n    # Combine all busy times and constraints\n    all_busy = jean_busy + doris_busy + joan_busy\n    \n    # Generate free slots by finding gaps in busy times\n    all_busy_sorted = sorted(all_busy, key=lambda x: x[0])\n    free_slots = []\n    previous_end = work_hours_start\n    \n    for start, end in all_busy_sorted:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_hours_end:\n        free_slots.append((previous_end, work_hours_end))\n    \n    # Check free slots for meeting duration and Doris's constraint\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        # Adjust slot start to respect Doris's constraint\n        effective_start = max(slot_start, doris_constraint)\n        if effective_start + meeting_duration <= slot_end:\n            # Convert back to HH:MM format\n            start_hh = effective_start // 60\n            start_mm = effective_start % 60\n            end_time = effective_start + meeting_duration\n            end_hh = end_time // 60\n            end_mm = end_time % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_225"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy slots in minutes\n    busy_slots = {\n        'Maria': [(9*60 + 30, 10*60), (11*60, 12*60), (15*60 + 30, 16*60)],\n        'Gary': [(10*60, 10*60 + 30), (13*60, 13*60 + 30), (14*60 + 30, 15*60), (16*60 + 30, 17*60)],\n        'Betty': [],\n        'Charlotte': [(9*60 + 30, 12*60), (13*60, 13*60 + 30), (14*60, 14*60 + 30), (15*60 + 30, 16*60)],\n        'Jerry': [(9*60 + 30, 10*60), (10*60 + 30, 12*60 + 30), (13*60, 16*60 + 30)],\n    }\n    \n    # Maria cannot meet before 9:30\n    maria_constraint = 9 * 60 + 30\n    \n    # Meeting duration in minutes\n    meeting_duration = 30\n    \n    # Combine all busy slots from all participants\n    all_busy = []\n    for person in busy_slots:\n        for slot in busy_slots[person]:\n            all_busy.append(slot)\n    \n    # Add Maria's constraint as a busy slot if needed\n    if maria_constraint > work_start:\n        all_busy.append((work_start, maria_constraint))\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_226"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Convert all schedules to minutes since midnight\n    # Each person's busy times are represented as a list of (start, end) tuples in minutes\n    natalie_busy = []\n    david_busy = [(11 * 60 + 30, 12 * 60), (14 * 60 + 30, 15 * 60)]\n    douglas_busy = [(9 * 60 + 30, 10 * 60), (11 * 60 + 30, 12 * 60), \n                    (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60)]\n    ralph_busy = [(9 * 60, 9 * 60 + 30), (10 * 60, 11 * 60), \n                  (11 * 60 + 30, 12 * 60 + 30), (13 * 60 + 30, 15 * 60), \n                  (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)]\n    jordan_busy = [(9 * 60, 10 * 60), (12 * 60, 12 * 60 + 30), \n                   (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60), \n                   (15 * 60 + 30, 17 * 60)]\n    \n    # Combine all busy times and sort them\n    all_busy = david_busy + douglas_busy + ralph_busy + jordan_busy\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = work_start\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    # Check the time after the last busy slot until work_end\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Filter free slots that are at least 30 minutes and meet David's preference (after 14:00)\n    meeting_duration = 30\n    valid_slots = []\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration and slot_start >= 14 * 60:\n            valid_slots.append((slot_start, slot_end))\n    \n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No valid slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_227"
        },
        {
            "final_program_time": "{15:00:15:01}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 9:00 (0 minutes)\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    # Parse work hours\n    work_start, work_end = map(time_to_minutes, work_hours.split(' to '))\n    \n    # Initialize a list to mark busy intervals\n    timeline = [False] * (work_end - work_start)\n    \n    # Mark busy times for each participant\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            for i in range(start, end):\n                if 0 <= i < len(timeline):\n                    timeline[i] = True\n    \n    # Find the first available slot of duration\n    required_slots = duration // 30  # assuming duration is in minutes, e.g., 30 for half hour\n    current_slots = 0\n    \n    for i in range(len(timeline)):\n        if not timeline[i]:\n            current_slots += 1\n            if current_slots >= required_slots:\n                start_time = i - required_slots + 1\n                end_time = start_time + required_slots\n                start_str = minutes_to_time(start_time)\n                end_str = minutes_to_time(end_time)\n                return f\"{start_str}:{end_str}\"\n        else:\n            current_slots = 0\n    \n    return \"No available slot found\"\n\n# Participants' schedules\nparticipants_schedules = [\n    [\"11:00 to 11:30\", \"16:00 to 16:30\"],  # Mason\n    [\"9:30 to 10:00\", \"11:30 to 12:00\"],  # Anthony\n    [\"9:30 to 10:00\", \"11:00 to 11:30\", \"13:00 to 14:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"],  # Teresa\n    [\"9:00 to 10:30\", \"11:00 to 12:30\", \"13:00 to 15:00\", \"16:00 to 17:00\"],  # Katherine\n    [\"9:30 to 12:00\", \"12:30 to 13:00\", \"14:00 to 14:30\", \"16:00 to 16:30\"],  # Brian\n]\n\n# Meeting duration in minutes\nduration = 30\n\n# Work hours\nwork_hours = \"9:00 to 17:00\"\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, duration, work_hours))\n```",
            "count": "calendar_scheduling_example_228"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Define participants' busy times in minutes since midnight\n    busy_times = {\n        'Brittany': [],\n        'Wayne': [],\n        'Betty': [(10.5 * 60, 11 * 60), (15 * 60, 15.5 * 60)],\n        'Diane': [(9 * 60, 9.5 * 60), (10 * 60, 11 * 60), (11.5 * 60, 13 * 60), (13.5 * 60, 16.5 * 60)],\n        'Larry': [(9 * 60, 11 * 60), (11.5 * 60, 13 * 60), (13.5 * 60, 17 * 60)],\n    }\n\n    # Betty's preference: avoid meetings after 11:30\n    betty_preference_end = 11.5 * 60\n\n    # Generate all possible 30-minute slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + 30 <= work_end:\n        slot_start = current_time\n        slot_end = slot_start + 30\n        possible_slots.append((slot_start, slot_end))\n        current_time += 1  # Check every minute\n\n    # Check each slot against all constraints\n    for slot_start, slot_end in possible_slots:\n        # Check Betty's preference\n        if slot_start >= betty_preference_end:\n            continue\n\n        # Check if slot is free for all participants\n        all_free = True\n        for person, busy in busy_times.items():\n            for busy_start, busy_end in busy:\n                if not (slot_end <= busy_start or slot_start >= busy_end):\n                    all_free = False\n                    break\n            if not all_free:\n                break\n\n        if all_free:\n            # Format the time as HH:MM:HH:MM\n            start_hh = int(slot_start // 60)\n            start_mm = int(slot_start % 60)\n            end_hh = int(slot_end // 60)\n            end_mm = int(slot_end % 60)\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_229"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:30:15:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_hour, end_hour = work_hours\n    # Convert work hours to minutes for easier calculation\n    start_time = start_hour * 60\n    end_time = end_hour * 60\n    \n    # Initialize a list to keep track of busy intervals in minutes\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start = busy[0] * 60\n            end = busy[1] * 60\n            busy_intervals.append((start, end))\n    \n    # Sort the busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append(interval)\n    \n    # Check the available slots before the first busy interval, between intervals, and after the last busy interval\n    available_slots = []\n    \n    # Before the first busy interval\n    if merged:\n        first_start, first_end = merged[0]\n        if first_start > start_time:\n            available_slots.append((start_time, first_start))\n    else:\n        # No busy intervals, the whole day is available\n        available_slots.append((start_time, end_time))\n    \n    # Between busy intervals\n    for i in range(1, len(merged)):\n        prev_end = merged[i-1][1]\n        current_start = merged[i][0]\n        if current_start > prev_end:\n            available_slots.append((prev_end, current_start))\n    \n    # After the last busy interval\n    if merged:\n        last_start, last_end = merged[-1]\n        if last_end < end_time:\n            available_slots.append((last_end, end_time))\n    \n    # Check each available slot for a duration that fits\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration * 60:\n            # Found a suitable slot, return the first possible one\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration * 60\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules in hours\nparticipants_schedules = [\n    [],  # Jessica is free all day\n    [(10.0, 10.5), (16.0, 16.5)],  # Joshua\n    [(12.0, 12.5), (16.0, 16.5)],  # Robert\n    [(10.0, 11.0), (11.5, 12.0), (13.0, 13.5), (14.0, 14.5), (15.0, 16.5)],  # Samuel\n    [(9.0, 12.0), (12.5, 14.5), (15.0, 17.0)],  # Jennifer\n]\n\n# Define work hours and meeting duration\nwork_hours = (9.0, 17.0)\nduration = 0.5  # half an hour\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_230"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_start, work_end):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start_min = time_to_minutes(busy[0])\n            end_min = time_to_minutes(busy[1])\n            all_busy.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots between work hours and busy intervals\n    available = []\n    prev_end = work_start_min\n    \n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        available.append((prev_end, work_end_min))\n    \n    # Find the first available slot that can fit the meeting\n    for slot in available:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [(\"10:00\", \"10:30\"), (\"12:30\", \"13:00\"), (\"16:00\", \"17:00\")],  # Betty\n    [],  # Olivia\n    [(\"11:30\", \"12:00\"), (\"14:00\", \"14:30\"), (\"15:00\", \"15:30\"), (\"16:00\", \"16:30\")],  # Brandon\n    [(\"09:30\", \"10:00\"), (\"11:00\", \"12:30\"), (\"13:00\", \"15:00\")],  # Lori\n    [(\"09:00\", \"10:30\"), (\"11:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"13:30\"), (\"15:00\", \"17:00\")]  # Rachel\n]\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, 30, \"09:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_231"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:00:12:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert time strings to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's schedule to find common free slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_slots.append((start, end))\n        \n        # Sort the busy slots by start time\n        busy_slots.sort()\n        \n        # Calculate free slots for the current participant\n        current_free = []\n        prev_end = work_start\n        for start, end in busy_slots:\n            if start > prev_end:\n                current_free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            current_free.append((prev_end, work_end))\n        \n        # Intersect current free slots with the common free slots\n        new_free_slots = []\n        i = j = 0\n        while i < len(free_slots) and j < len(current_free):\n            fs_start, fs_end = free_slots[i]\n            cf_start, cf_end = current_free[j]\n            \n            # Find the overlap\n            overlap_start = max(fs_start, cf_start)\n            overlap_end = min(fs_end, cf_end)\n            \n            if overlap_start < overlap_end:\n                new_free_slots.append((overlap_start, overlap_end))\n            \n            # Move the pointer which ends first\n            if fs_end < cf_end:\n                i += 1\n            else:\n                j += 1\n        \n        free_slots = new_free_slots\n    \n    # Find the first free slot that can accommodate the meeting duration\n    for start, end in free_slots:\n        if end - start >= duration:\n            meeting_end = start + duration\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [],  # Joyce is free the entire day\n    [\"09:00:09:30\", \"14:30:15:00\"],  # Judith\n    [\"10:00:10:30\", \"14:00:14:30\", \"15:00:16:00\"],  # Bradley\n    [\"09:00:12:00\", \"12:30:14:30\", \"15:00:17:00\"],  # Terry\n    [\"09:00:09:30\", \"10:00:10:30\", \"11:00:12:00\", \"12:30:13:00\", \"14:00:15:00\", \"16:00:16:30\"],  # Hannah\n]\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_232"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define meeting duration\n    meeting_duration = 30  # minutes\n    \n    # Define each person's busy times in minutes since midnight\n    # Format: (start, end)\n    samuel_busy = [\n        (12 * 60 + 30, 13 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    \n    jesse_busy = []  # No meetings\n    \n    willie_busy = []  # Wide open\n    \n    joyce_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60, 13 * 60),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    mark_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 16 * 60)\n    ]\n    \n    # Mark's preference: avoid after 13:00 (but still possible if no other slot)\n    mark_preferred_end = 13 * 60\n    \n    # Combine all busy times\n    all_busy = []\n    for person in [samuel_busy, jesse_busy, willie_busy, joyce_busy, mark_busy]:\n        all_busy.extend(person)\n    \n    # Sort busy times by start time\n    all_busy.sort()\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > prev_end:\n            available_slots.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n    \n    # Check after last busy slot\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Filter slots that are long enough and meet Mark's preference\n    valid_slots = []\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration:\n            valid_slots.append((slot_start, slot_end))\n    \n    # Prioritize slots before Mark's preferred end time (13:00)\n    preferred_slots = [slot for slot in valid_slots if slot[1] <= mark_preferred_end]\n    if preferred_slots:\n        best_slot = preferred_slots[0]\n    elif valid_slots:\n        best_slot = valid_slots[0]\n    else:\n        return None\n    \n    # Format the best slot as HH:MM:HH:MM\n    start_hh = best_slot[0] // 60\n    start_mm = best_slot[0] % 60\n    end_hh = (best_slot[0] + meeting_duration) // 60\n    end_mm = (best_slot[0] + meeting_duration) % 60\n    \n    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_233"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Convert each participant's busy slots to minutes\n    # Format: list of (start, end) in minutes\n    barbara_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60, 11 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    bruce_busy = [\n        (11 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    robert_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (11 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 16 * 60 + 30)\n    ]\n    \n    michelle_busy = [\n        (9 * 60, 10 * 60),\n        (11 * 60, 14 * 60 + 30),\n        (15 * 60, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Catherine is free all day, so no busy slots\n    \n    # Combine all busy slots\n    all_busy = barbara_busy + bruce_busy + robert_busy + michelle_busy\n    \n    # Sort busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    prev_end = work_start\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > prev_end:\n            free_slots.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Check each free slot for 30-minute availability\n    meeting_duration = 30\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Found a suitable slot\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_234"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:10:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_start, work_end):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start_min, work_end_min)]\n    \n    # Process each participant's schedule to find common free slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for slot in schedule:\n            start, end = map(time_to_minutes, slot.split(':'))\n            busy_slots.append((start, end))\n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Merge overlapping or adjacent busy slots\n        merged_busy = []\n        for start, end in busy_slots:\n            if not merged_busy:\n                merged_busy.append((start, end))\n            else:\n                last_start, last_end = merged_busy[-1]\n                if start <= last_end:\n                    merged_busy[-1] = (last_start, max(end, last_end))\n                else:\n                    merged_busy.append((start, end))\n        \n        # Calculate free slots for this participant\n        participant_free = []\n        prev_end = work_start_min\n        for start, end in merged_busy:\n            if start > prev_end:\n                participant_free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end_min:\n            participant_free.append((prev_end, work_end_min))\n        \n        # Intersect with common free slots\n        new_free_slots = []\n        i = j = 0\n        while i < len(free_slots) and j < len(participant_free):\n            fs_start, fs_end = free_slots[i]\n            pf_start, pf_end = participant_free[j]\n            \n            # Find overlap\n            overlap_start = max(fs_start, pf_start)\n            overlap_end = min(fs_end, pf_end)\n            if overlap_start < overlap_end:\n                new_free_slots.append((overlap_start, overlap_end))\n            \n            # Move the pointer which ends first\n            if fs_end < pf_end:\n                i += 1\n            else:\n                j += 1\n        \n        free_slots = new_free_slots\n    \n    # Find the first slot that can fit the meeting\n    for start, end in free_slots:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"12:30:13:00\", \"14:00:14:30\", \"15:00:15:30\", \"16:00:16:30\"],  # Amber\n    [\"11:00:11:30\", \"15:30:16:00\"],  # Alice\n    [],  # Brian\n    [\"11:00:11:30\", \"12:30:13:30\", \"14:30:17:00\"],  # Ryan\n    [\"10:30:11:00\", \"11:30:12:00\", \"12:30:14:30\", \"15:00:17:00\"],  # Jonathan\n]\n\n# Find a 1-hour meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, 1, \"9:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_235"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:00:10:30}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours\n    start_min = time_to_minutes(start_work)\n    end_min = time_to_minutes(end_work)\n    \n    # Initialize the list of busy intervals\n    busy_intervals = []\n    \n    # Process each participant's schedule\n    for schedule in participans_schedules:\n        for busy in schedule:\n            start, end = busy\n            busy_start = time_to_minutes(start)\n            busy_end = time_to_minutes(end)\n            busy_intervals.append((busy_start, busy_end))\n    \n    # Sort the busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append([start, end])\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1][1] = max(last_end, end)\n            else:\n                merged.append([start, end])\n    \n    # Find the first available slot\n    prev_end = start_min\n    for start, end in merged:\n        if start - prev_end >= duration:\n            return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + duration)}\"\n        prev_end = max(prev_end, end)\n    \n    # Check after the last busy interval\n    if end_min - prev_end >= duration:\n        return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + duration)}\"\n    \n    return \"No available slot found\"\n\n# Define the participants' schedules\ngregory_schedule = []\njoyce_schedule = []\nchristopher_schedule = [(\"09:00\", \"09:30\"), (\"15:00\", \"15:30\")]\ndorothy_schedule = [(\"09:30\", \"10:00\"), (\"11:00\", \"14:00\"), (\"14:30\", \"15:30\"), (\"16:30\", \"17:00\")]\ncynthia_schedule = [(\"09:30\", \"10:00\"), (\"10:30\", \"11:00\"), (\"13:00\", \"15:00\"), (\"15:30\", \"16:30\")]\n\nparticipants_schedules = [\n    gregory_schedule,\n    joyce_schedule,\n    christopher_schedule,\n    dorothy_schedule,\n    cynthia_schedule\n]\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_hours = (\"09:00\", \"17:00\")\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_236"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 (9:00)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Initialize the free time slots for all participants\n    free_slots = []\n    for person in participants_busy:\n        busy_slots = participants_busy[person]\n        person_free = []\n        prev_end = work_start\n        \n        for busy in busy_slots:\n            busy_start, busy_end = busy.split(' to ')\n            busy_start_min = time_to_minutes(busy_start)\n            busy_end_min = time_to_minutes(busy_end)\n            \n            if prev_end < busy_start_min:\n                person_free.append((prev_end, busy_start_min))\n            prev_end = max(prev_end, busy_end_min)\n        \n        if prev_end < work_end:\n            person_free.append((prev_end, work_end))\n        \n        free_slots.append(person_free)\n    \n    # Find intersection of all free slots\n    common_free = free_slots[0]\n    for person_slots in free_slots[1:]:\n        new_common = []\n        i = j = 0\n        while i < len(common_free) and j < len(person_slots):\n            start1, end1 = common_free[i]\n            start2, end2 = person_slots[j]\n            \n            start_max = max(start1, start2)\n            end_min = min(end1, end2)\n            \n            if start_max < end_min:\n                new_common.append((start_max, end_min))\n            \n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free = new_common\n    \n    # Find the first slot that can fit the duration\n    for slot in common_free:\n        start, end = slot\n        if end - start >= duration:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' busy times\nparticipants_busy = {\n    \"Carol\": [\"9:30 to 10:00\", \"10:30 to 11:00\", \"12:30 to 13:30\", \"15:30 to 16:00\", \"16:30 to 17:00\"],\n    \"Cynthia\": [\"9:00 to 10:00\", \"14:00 to 14:30\", \"16:30 to 17:00\"],\n    \"Judy\": [\"9:00 to 10:00\", \"11:00 to 12:00\", \"12:30 to 13:00\", \"14:00 to 14:30\"],\n    \"Alan\": [\"10:00 to 11:00\", \"13:00 to 15:30\", \"16:30 to 17:00\"],\n    \"Linda\": [\"9:30 to 12:30\", \"13:00 to 16:00\"]\n}\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nduration_minutes = 30  # Half an hour\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_237"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:9:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = map(time_to_minutes, work_hours.split(' to '))\n    duration_min = duration * 60\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        person_busy = []\n        for meeting in schedule:\n            start, end = map(time_to_minutes, meeting.split(' to '))\n            person_busy.append((start, end))\n        busy_intervals.append(person_busy)\n    \n    # Find all possible free intervals for each participant\n    free_intervals_per_person = []\n    \n    for person_busy in busy_intervals:\n        person_free = []\n        prev_end = work_start\n        \n        for start, end in sorted(person_busy, key=lambda x: x[0]):\n            if start > prev_end:\n                person_free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            person_free.append((prev_end, work_end))\n        \n        free_intervals_per_person.append(person_free)\n    \n    # Find overlapping free intervals across all participants\n    common_free = free_intervals_per_person[0]\n    \n    for person_free in free_intervals_per_person[1:]:\n        new_common_free = []\n        i = j = 0\n        \n        while i < len(common_free) and j < len(person_free):\n            start1, end1 = common_free[i]\n            start2, end2 = person_free[j]\n            \n            overlap_start = max(start1, start2)\n            overlap_end = min(end1, end2)\n            \n            if overlap_start < overlap_end:\n                new_common_free.append((overlap_start, overlap_end))\n            \n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        \n        common_free = new_common_free\n    \n    # Find the first common free interval that can fit the meeting\n    for start, end in common_free:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"10:00 to 10:30\", \"13:00 to 14:00\", \"14:30 to 15:00\", \"16:00 to 17:00\"],  # Alexander\n    [],                                                                         # Dylan\n    [],                                                                         # Elizabeth\n    [\"9:30 to 11:00\", \"11:30 to 17:00\"],                                       # Edward\n    [\"10:00 to 10:30\", \"11:00 to 12:00\", \"12:30 to 13:30\", \"14:00 to 15:30\", \"16:00 to 17:00\"]  # Douglas\n]\n\n# Define meeting duration (0.5 hours = 30 minutes) and work hours\nmeeting_duration = 0.5\nwork_hours = \"9:00 to 17:00\"\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, meeting_duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_238"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:11:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration_minutes):\n    # Convert work hours and busy times to minutes since start of day\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    duration = duration_minutes\n    \n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy_times in participants_busy_times.values():\n        for start, end in busy_times:\n            all_busy.append((start * 60, end * 60))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Check the available slots between work hours and merged busy intervals\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return None\n\n# Define participants' busy times in their local time (HH.HH format)\nparticipants_busy_times = {\n    \"Jennifer\": [],\n    \"Gabriel\": [(13.0, 13.5), (14.0, 14.5)],\n    \"Andrew\": [(12.0, 12.5), (16.5, 17.0)],\n    \"Carolyn\": [(9.0, 11.0), (12.0, 13.0), (13.5, 14.5), (15.0, 17.0)],\n    \"Alexis\": [(9.5, 11.0), (11.5, 17.0)],\n}\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (9.0, 17.0)\nmeeting_duration = 30  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_239"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours=('09:00', '17:00')):\n    # Convert all time strings to minutes since 00:00 for easier comparison\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start, work_end = map(time_to_minutes, work_hours)\n    \n    # Generate all busy intervals for each participant\n    busy_intervals = []\n    for schedule in participants_schedules.values():\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by examining the gaps between busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Merge overlapping or adjacent free intervals (not necessary here but good practice)\n    merged = []\n    for start, end in free_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1] = (last_start, end)\n            else:\n                merged.append((start, end))\n    \n    # Find the earliest free interval that can accommodate the meeting\n    duration = duration_minutes\n    for start, end in merged:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    return None\n\n# Define participants' schedules\nparticipants_schedules = {\n    'Edward': ['9:00 to 10:30', '12:30 to 13:00', '13:30 to 14:00', '15:00 to 15:30'],\n    'Daniel': ['11:00 to 11:30', '15:00 to 15:30'],\n    'Jonathan': ['9:00 to 10:30', '14:30 to 15:00', '15:30 to 16:00', '16:30 to 17:00'],\n    'Samuel': ['9:30 to 11:30', '12:00 to 12:30', '14:00 to 16:30'],\n    'Paul': ['10:00 to 11:00', '12:30 to 13:00', '13:30 to 14:00', '14:30 to 16:00', '16:30 to 17:00'],\n}\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_240"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy times in minutes\n    busy_times = {\n        'Terry': [(13 * 60 + 30, 14 * 60), (16 * 60 + 30, 17 * 60)],\n        'Janet': [(9 * 60 + 30, 10 * 60), (12 * 60 + 30, 13 * 60), \n                  (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60 + 30), \n                  (16 * 60 + 30, 17 * 60)],\n        'Lauren': [],\n        'Sharon': [(9 * 60 + 30, 10 * 60 + 30), (11 * 60 + 30, 12 * 60), \n                    (12 * 60 + 30, 17 * 60)],\n        'Adam': [(9 * 60 + 30, 10 * 60 + 30), (11 * 60, 17 * 60)]\n    }\n    \n    # Adam's preference: avoid before 10:30\n    preference_start = 10 * 60 + 30\n    \n    # Generate all busy slots combined\n    all_busy = []\n    for person in busy_times:\n        all_busy.extend(busy_times[person])\n    \n    # Sort busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the end of the day\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Filter free slots that are at least 30 minutes and after Adam's preference\n    meeting_duration = 30\n    valid_slots = []\n    \n    for start, end in free_slots:\n        if end - start >= meeting_duration and start >= preference_start:\n            valid_slots.append((start, end))\n    \n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No valid slot found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_241"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:00:16:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_hour, end_hour = work_hours\n    # Convert work hours to minutes for easier calculation\n    start_time = start_hour * 60\n    end_time = end_hour * 60\n    \n    # Initialize a list to keep track of busy times for all participants\n    busy_times = []\n    \n    # Collect all busy intervals from each participant\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start_busy = busy[0] * 60\n            end_busy = busy[1] * 60\n            busy_times.append((start_busy, end_busy))\n    \n    # Sort all busy intervals by start time\n    busy_times.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for busy in busy_times:\n        if not merged:\n            merged.append(busy)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = busy\n            if current_start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append(busy)\n    \n    # Find available slots by checking gaps between merged busy intervals\n    available_slots = []\n    previous_end = start_time\n    \n    for busy_start, busy_end in merged:\n        if busy_start > previous_end:\n            available_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    # Check the slot after the last busy interval\n    if previous_end < end_time:\n        available_slots.append((previous_end, end_time))\n    \n    # Find the first available slot that can fit the meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration * 60:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration * 60\n            # Convert back to hours and minutes\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules in hours\nparticipants_schedules = [\n    [(9, 11), (15, 16)],  # Anthony\n    [(12.5, 14), (14.5, 15.5), (16.5, 17)],  # Zachary\n    [(9, 10)],  # Russell\n    [(9, 14.5), (15, 16), (16.5, 17)],  # Gary\n    [(9, 11), (11.5, 12.5), (13, 15.5), (16.5, 17)]  # Helen\n]\n\n# Define work hours and meeting duration\nwork_hours = (9, 17)\nduration = 0.5  # half an hour\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_242"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each participant's busy slots to minutes since 9:00\n    # Douglas has no meetings\n    douglas_busy = []\n    \n    # Debra: 15:30 to 16:30 \u2192 390 to 450\n    debra_busy = [(15 * 60 + 30, 16 * 60 + 30)]\n    \n    # Frank: 10:00-11:00 (60-120), 12:00-12:30 (180-210), 13:30-14:00 (270-300), 15:00-16:00 (360-420)\n    frank_busy = [\n        (10 * 60, 11 * 60),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60, 16 * 60)\n    ]\n    \n    # Nicholas: 9:00-10:00 (0-60), 11:00-12:30 (120-150), 13:30-15:00 (270-360), 15:30-16:00 (390-420), 16:30-17:00 (450-480)\n    nicholas_busy = [\n        (9 * 60, 10 * 60),\n        (11 * 60, 12 * 60 + 30),\n        (13 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Mark: 10:00-11:30 (60-150), 12:00-12:30 (180-210), 13:30-14:30 (270-330), 15:00-17:00 (360-480)\n    mark_busy = [\n        (10 * 60, 11 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60 + 30, 14 * 60 + 30),\n        (15 * 60, 17 * 60)\n    ]\n    \n    # Combine all busy slots\n    all_busy = douglas_busy + debra_busy + frank_busy + nicholas_busy + mark_busy\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check if there's a free slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_243"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each participant's busy slots to minutes since 9:00\n    # Walter has no meetings\n    walter_busy = []\n    \n    # Cynthia's busy slots: 9:00-9:30, 10:00-10:30, 13:30-14:30, 15:00-16:00\n    cynthia_busy = [\n        (9*60, 9*60 + 30),\n        (10*60, 10*60 + 30),\n        (13*60 + 30, 14*60 + 30),\n        (15*60, 16*60)\n    ]\n    \n    # Ann's busy slots: 10:00-11:00, 13:00-13:30, 14:00-15:00, 16:00-16:30\n    ann_busy = [\n        (10*60, 11*60),\n        (13*60, 13*60 + 30),\n        (14*60, 15*60),\n        (16*60, 16*60 + 30)\n    ]\n    \n    # Catherine's busy slots: 9:00-11:30, 12:30-13:30, 14:30-17:00\n    catherine_busy = [\n        (9*60, 11*60 + 30),\n        (12*60 + 30, 13*60 + 30),\n        (14*60 + 30, 17*60)\n    ]\n    \n    # Kyle's busy slots: 9:00-9:30, 10:00-11:30, 12:00-12:30, 13:00-14:30, 15:00-16:00\n    kyle_busy = [\n        (9*60, 9*60 + 30),\n        (10*60, 11*60 + 30),\n        (12*60, 12*60 + 30),\n        (13*60, 14*60 + 30),\n        (15*60, 16*60)\n    ]\n    \n    # Combine all busy slots for all participants\n    all_busy = walter_busy + cynthia_busy + ann_busy + catherine_busy + kyle_busy\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_244"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:00:16:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time slots to minutes since start of the day for easier comparison\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n\n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_intervals.append((start, end))\n\n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find the first available slot\n    prev_end = work_start\n    for start, end in merged:\n        if start - prev_end >= duration:\n            # Found a slot\n            meeting_start = prev_end\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n        prev_end = max(prev_end, end)\n\n    # Check after the last busy interval\n    if work_end - prev_end >= duration:\n        meeting_start = prev_end\n        meeting_end = meeting_start + duration\n        def minutes_to_time(minutes):\n            hh = minutes // 60\n            mm = minutes % 60\n            return f\"{hh:02d}:{mm:02d}\"\n        return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"14:30:15:30\"],  # Amanda\n    [\"11:00:11:30\", \"14:00:14:30\"],  # Margaret\n    [\"09:00:09:30\", \"10:00:11:00\", \"12:00:13:00\", \"14:00:14:30\"],  # Walter\n    [\"09:00:11:00\", \"11:30:13:00\", \"14:00:16:00\", \"16:30:17:00\"],  # Larry\n    [\"09:00:11:00\", \"13:00:14:00\", \"15:00:15:30\", \"16:30:17:00\"],  # John\n]\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, \"09:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_245"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert work hours to minutes\n    start_time = work_hours_start[0] * 60 + work_hours_start[1]\n    end_time = work_hours_end[0] * 60 + work_hours_end[1]\n    \n    # Initialize a list to keep track of busy intervals in minutes\n    busy_intervals = []\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start_busy = busy[0] * 60 + busy[1]\n            end_busy = busy[2] * 60 + busy[3]\n            busy_intervals.append((start_busy, end_busy))\n    \n    # Sort busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append(interval)\n    \n    # Find available slots\n    available_slots = []\n    previous_end = start_time\n    \n    for interval in merged:\n        current_start, current_end = interval\n        if current_start > previous_end:\n            available_slots.append((previous_end, current_start))\n        previous_end = max(previous_end, current_end)\n    \n    if previous_end < end_time:\n        available_slots.append((previous_end, end_time))\n    \n    # Check each available slot for sufficient duration\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_minutes:\n            # Found a suitable slot\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return None\n\n# Define work hours (9:00 to 17:00)\nwork_hours_start = (9, 0)\nwork_hours_end = (17, 0)\n\n# Define participants' schedules in HH:MM format converted to tuples\nparticipants_schedules = [\n    [(13, 30, 14, 0), (14, 30, 15, 0)],  # Jacob\n    [(9, 30, 10, 0), (11, 30, 12, 0), (13, 0, 13, 30), (16, 0, 16, 30)],  # Diana\n    [(9, 30, 10, 30), (11, 0, 12, 30), (15, 30, 16, 0)],  # Adam\n    [(9, 30, 10, 0), (10, 30, 12, 0), (13, 0, 15, 30), (16, 0, 16, 30)],  # Angela\n    [(9, 0, 9, 30), (10, 30, 11, 30), (13, 0, 15, 0), (16, 30, 17, 0)],  # Dennis\n]\n\n# Meeting duration is 30 minutes\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_246"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:00:14:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 9:00 (0 minutes)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours\n    start_min = time_to_minutes(start_work)\n    end_min = time_to_minutes(end_work)\n    \n    # Initialize a list to track busy intervals for all participants\n    all_busy = []\n    for busy_slots in participants_busy.values():\n        for slot in busy_slots:\n            start, end = slot\n            all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append([start, end])\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1][1] = max(end, last_end)\n            else:\n                merged.append([start, end])\n    \n    # Find available slots between 9:00 and 17:00 (0 to 480 minutes)\n    available = []\n    prev_end = start_min\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < end_min:\n        available.append((prev_end, end_min))\n    \n    # Check for the first available slot that can fit the meeting duration\n    duration_min = duration * 60\n    for start, end in available:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' busy times\nparticipants_busy = {\n    'Charles': [('11:00', '12:30'), ('16:30', '17:00')],\n    'Bryan': [('13:30', '14:00'), ('15:30', '17:00')],\n    'Ruth': [],\n    'Keith': [('09:00', '09:30'), ('10:00', '10:30'), ('11:30', '12:00'), ('13:00', '14:00'), ('14:30', '17:00')],\n    'William': [('09:00', '11:30'), ('12:30', '13:00'), ('15:30', '16:30')]\n}\n\n# Define work hours and meeting duration\nwork_hours = ('09:00', '17:00')\nduration = 0.5  # half an hour\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_247"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_hour, end_hour = work_hours\n    # Convert work hours to minutes for easier calculation\n    start_time = start_hour * 60\n    end_time = end_hour * 60\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start = busy[0] * 60\n            end = busy[1] * 60\n            all_busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for busy in all_busy_intervals:\n        if not merged:\n            merged.append(busy)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = busy\n            if current_start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append(busy)\n    \n    # Find the earliest available slot\n    previous_end = start_time\n    for busy_start, busy_end in merged:\n        if busy_start > previous_end:\n            # Check if the gap is enough for the meeting\n            if busy_start - previous_end >= duration:\n                # Convert back to hours and minutes\n                start_meeting = previous_end\n                end_meeting = start_meeting + duration\n                return (start_meeting // 60, start_meeting % 60, end_meeting // 60, end_meeting % 60)\n        previous_end = max(previous_end, busy_end)\n    \n    # Check the time after the last busy interval\n    if end_time - previous_end >= duration:\n        start_meeting = previous_end\n        end_meeting = start_meeting + duration\n        return (start_meeting // 60, start_meeting % 60, end_meeting // 60, end_meeting % 60)\n    \n    return None\n\n# Define work hours and meeting duration\nwork_hours = (9, 17)  # 9:00 to 17:00\nduration = 30  # minutes\n\n# Define each participant's busy intervals in hours\nbilly = [(10, 10.5), (11.5, 12), (14.5, 16.5)]\njoe = [(9.5, 10), (11.5, 12)]\nbrittany = [(13.5, 14), (15.5, 16)]\ngrace = [(9.5, 10), (10.5, 11), (11.5, 12.5), (13.5, 16.5)]\ndennis = [(9.5, 10.5), (11, 12), (12.5, 13), (13.5, 14), (14.5, 15), (15.5, 17)]\n\nparticipants_schedules = [billy, joe, brittany, grace, dennis]\n\n# Find the earliest available meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\n\n# Format the output as HH:MM:HH:MM\nif meeting_time:\n    start_h, start_m, end_h, end_m = meeting_time\n    print(f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\")\nelse:\n    print(\"No available time slot found.\")\n```",
            "count": "calendar_scheduling_example_248"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    duration = 30         # meeting duration in minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    # Julie: 13:30-15:30 \u2192 270-330\n    julie_busy = [(13 * 60 + 30, 15 * 60 + 30)]\n    # Betty: 10:30-11:00, 13:00-13:30, 14:00-14:30, 15:30-16:00\n    betty_busy = [(10 * 60 + 30, 11 * 60), (13 * 60, 13 * 60 + 30),\n                  (14 * 60, 14 * 60 + 30), (15 * 60 + 30, 16 * 60)]\n    # Kayla: free all day\n    kayla_busy = []\n    # Heather: 9:00-9:30, 10:30-11:00, 11:30-13:00, 13:30-15:00\n    heather_busy = [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 11 * 60),\n                    (11 * 60 + 30, 13 * 60), (13 * 60 + 30, 15 * 60)]\n    # Keith: 9:30-11:00, 11:30-13:30, 14:30-15:00\n    keith_busy = [(9 * 60 + 30, 11 * 60), (11 * 60 + 30, 13 * 60 + 30),\n                  (14 * 60 + 30, 15 * 60)]\n\n    # Combine all busy times\n    all_busy = julie_busy + betty_busy + kayla_busy + heather_busy + keith_busy\n\n    # Betty prefers no meetings after 15:00, so we'll treat 15:00-17:00 as busy for her\n    betty_preferred_busy = (15 * 60, 17 * 60)\n    all_busy.append(betty_preferred_busy)\n\n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    prev_end = work_start\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_249"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Find the first free interval that can accommodate the meeting\n    meeting_duration_min = duration * 60\n    for start, end in free_intervals:\n        if end - start >= meeting_duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"10:00 to 10:30\", \"11:30 to 12:00\", \"12:30 to 13:00\", \"16:00 to 16:30\"],  # Dorothy\n    [\"11:30 to 12:00\", \"12:30 to 13:00\"],  # Kenneth\n    [\"09:30 to 10:00\", \"16:30 to 17:00\"],  # Madison\n    [\"09:00 to 09:30\", \"11:00 to 12:00\", \"12:30 to 15:30\", \"16:00 to 16:30\"],  # Brandon\n    [\"10:00 to 10:30\", \"11:00 to 11:30\", \"12:00 to 12:30\", \"13:30 to 15:00\", \"15:30 to 16:30\"],  # Judith\n]\n\n# Find a meeting time\nmeeting_time = find_meeting_time(participants_schedules, \"09:00\", \"17:00\", 0.5)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_250"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define participants' busy times in minutes (start, end)\n    willie_busy = [\n        (10 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60 + 30, 15 * 60 + 30)\n    ]\n    \n    diana_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    olivia_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (11 * 60, 11 * 60 + 30)\n    ]\n    \n    kyle_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    kathleen_busy = [\n        (9 * 60, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Diana's preference: avoid before 14:30\n    diana_preference_start = 14 * 60 + 30\n    \n    # Meeting duration in minutes\n    duration = 30\n    \n    # Collect all busy intervals\n    all_busy = []\n    for busy in [willie_busy, diana_busy, olivia_busy, kyle_busy, kathleen_busy]:\n        all_busy.extend(busy)\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Filter free intervals that are after Diana's preference and long enough\n    possible_slots = []\n    for start, end in free_intervals:\n        if start >= diana_preference_start and (end - start) >= duration:\n            possible_slots.append((start, end))\n    \n    # Select the earliest possible slot\n    if possible_slots:\n        meeting_start = possible_slots[0][0]\n        meeting_end = meeting_start + duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_251"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes\n    daniel_busy = [(9 * 60 + 30, 10 * 60), (12 * 60 + 30, 13 * 60)]\n    wayne_busy = [(13 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30)]\n    gloria_busy = [(10 * 60 + 30, 11 * 60), (11 * 60 + 30, 12 * 60)]\n    stephanie_busy = [(9 * 60 + 30, 15 * 60 + 30)]\n    megan_busy = [(9 * 60, 10 * 60 + 30), (11 * 60, 14 * 60), (15 * 60, 16 * 60 + 30)]\n\n    # Combine all busy slots\n    all_busy = daniel_busy + wayne_busy + gloria_busy + stephanie_busy + megan_busy\n\n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check each free slot for availability for all participants\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Check if the slot works for everyone\n            valid = True\n            # Daniel's availability\n            for start, end in daniel_busy:\n                if not (slot_start >= end or slot_start + meeting_duration <= start):\n                    valid = False\n                    break\n            if not valid:\n                continue\n            # Wayne's availability\n            for start, end in wayne_busy:\n                if not (slot_start >= end or slot_start + meeting_duration <= start):\n                    valid = False\n                    break\n            if not valid:\n                continue\n            # Gloria's availability\n            for start, end in gloria_busy:\n                if not (slot_start >= end or slot_start + meeting_duration <= start):\n                    valid = False\n                    break\n            if not valid:\n                continue\n            # Stephanie's availability\n            for start, end in stephanie_busy:\n                if not (slot_start >= end or slot_start + meeting_duration <= start):\n                    valid = False\n                    break\n            if not valid:\n                continue\n            # Megan's availability\n            for start, end in megan_busy:\n                if not (slot_start >= end or slot_start + meeting_duration <= start):\n                    valid = False\n                    break\n            if valid:\n                # Convert minutes back to HH:MM format\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_hh = (slot_start + meeting_duration) // 60\n                end_mm = (slot_start + meeting_duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_252"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:30:12:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes, work_start, work_end):\n    # Convert time strings to minutes since 9:00 (work_start)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - work_start * 60\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_hh = (minutes + work_start * 60) // 60\n        total_mm = (minutes + work_start * 60) % 60\n        return f\"{total_hh:02d}:{total_mm:02d}\"\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(0, (work_end - work_start) * 60)]\n    \n    # Process each participant's schedule to find common free slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_slots.append((start, end))\n        \n        # Merge overlapping or adjacent busy slots\n        busy_slots.sort()\n        merged_busy = []\n        for start, end in busy_slots:\n            if not merged_busy:\n                merged_busy.append((start, end))\n            else:\n                last_start, last_end = merged_busy[-1]\n                if start <= last_end:\n                    merged_busy[-1] = (last_start, max(end, last_end))\n                else:\n                    merged_busy.append((start, end))\n        \n        # Subtract busy slots from free slots\n        new_free_slots = []\n        for free_start, free_end in free_slots:\n            current_start = free_start\n            for busy_start, busy_end in merged_busy:\n                if busy_start > current_start:\n                    new_free_slots.append((current_start, busy_start))\n                current_start = max(current_start, busy_end)\n            if current_start < free_end:\n                new_free_slots.append((current_start, free_end))\n        free_slots = new_free_slots\n    \n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= duration_minutes:\n            meeting_end = start + duration_minutes\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Bryan is free all day\n    [],  # Lori is free all day\n    [\"9:30:11:00\", \"12:00:12:30\"],  # Kimberly\n    [\"9:00:9:30\", \"11:00:11:30\", \"12:30:13:30\", \"14:00:15:00\", \"15:30:16:30\"],  # Beverly\n    [\"9:30:11:30\", \"12:00:17:00\"],  # Dennis\n]\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, 30, 9, 17)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_253"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration):\n    # Convert all time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 (9:00)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = map(time_to_minutes, work_hours.split(':'))\n    duration_min = duration * 60\n    \n    # Collect all busy times for all participants\n    all_busy = []\n    for busy_times in participants_busy_times.values():\n        for start, end in busy_times:\n            all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy times by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy times and work hours\n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' busy times\nparticipants_busy_times = {\n    'Cheryl': [],\n    'Judith': [],\n    'Ann': [],\n    'Joseph': [\n        ('9:00', '10:30'),\n        ('11:00', '11:30'),\n        ('13:00', '14:00'),\n        ('14:30', '15:30'),\n        ('16:00', '17:00')\n    ],\n    'Douglas': [\n        ('9:00', '12:30'),\n        ('13:00', '14:30'),\n        ('15:00', '17:00')\n    ]\n}\n\n# Define work hours and meeting duration\nwork_hours = \"9:00:17:00\"  # Assuming this means 9:00 to 17:00\nduration = 0.5  # 0.5 hours = 30 minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy_times, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_254"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define each person's busy slots in minutes (start, end)\n    michael = [(9*60, 9*60+30), (10*60, 10*60+30), (13*60+30, 14*60), (16*60+30, 17*60)]\n    vincent = [(12*60+30, 13*60), (13*60+30, 14*60)]\n    laura = []\n    frank = [(9*60+30, 10*60+30), (11*60+30, 12*60+30), (14*60, 15*60), (16*60, 17*60)]\n    dylan = [(9*60+30, 15*60+30), (16*60, 17*60)]\n    \n    # Combine all busy slots\n    all_busy = michael + vincent + laura + frank + dylan\n    all_busy.sort()  # Sort by start time\n    \n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Check each free slot for 30-minute availability\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert start time back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = (start + meeting_duration) // 60\n            end_mm = (start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_255"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours=('09:00', '17:00')):\n    # Convert time strings to minutes since 9:00 for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work_hours start at 9:00\n\n    start_work, end_work = work_hours\n    start_min = time_to_minutes(start_work)\n    end_min = time_to_minutes(end_work)\n    \n    # Initialize the available slots as all time within work hours\n    available_slots = [(start_min, end_min)]\n    \n    # Process each participant's schedule to find common available slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = busy\n            busy_slots.append((time_to_minutes(start), time_to_minutes(end)))\n        # Sort the busy slots by start time\n        busy_slots.sort()\n        \n        # Merge overlapping or adjacent busy slots\n        merged_busy = []\n        for start, end in busy_slots:\n            if not merged_busy:\n                merged_busy.append((start, end))\n            else:\n                last_start, last_end = merged_busy[-1]\n                if start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged_busy[-1] = (new_start, new_end)\n                else:\n                    merged_busy.append((start, end))\n        \n        # Subtract the busy slots from available_slots\n        new_available_slots = []\n        for avail_start, avail_end in available_slots:\n            current_start = avail_start\n            for busy_start, busy_end in merged_busy:\n                if busy_end <= current_start:\n                    continue  # Busy slot is before current available\n                if busy_start >= avail_end:\n                    break     # Busy slot is after current available\n                if busy_start > current_start:\n                    new_available_slots.append((current_start, busy_start))\n                current_start = max(current_start, busy_end)\n            if current_start < avail_end:\n                new_available_slots.append((current_start, avail_end))\n        available_slots = new_available_slots\n    \n    # Find the first available slot that can fit the meeting\n    for slot in available_slots:\n        start, end = slot\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = 9 + minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    return None\n\n# Define the participants' schedules based on the task\nparticipants_schedules = [\n    [],  # Carol has no meetings\n    [(\"09:00\", \"09:30\"), (\"10:00\", \"10:30\"), (\"14:00\", \"15:00\")],  # Lori\n    [(\"09:30\", \"10:00\"), (\"12:30\", \"13:30\"), (\"14:00\", \"14:30\")],  # Patricia\n    [(\"09:00\", \"12:00\"), (\"12:30\", \"14:30\"), (\"15:00\", \"17:00\")],  # Alexis\n    [(\"09:00\", \"11:30\"), (\"12:30\", \"15:30\"), (\"16:00\", \"16:30\")],  # Tyler\n]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_256"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert all time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # 9:00 is 0 minutes\n\n    # Convert work hours to minutes\n    work_start = time_to_minutes(work_hours[0])\n    work_end = time_to_minutes(work_hours[1])\n\n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy in participants_busy:\n        for interval in busy:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n\n    # Find free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    prev_end = work_start\n\n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n\n    # Check each free interval for a slot that fits the meeting duration\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = 9 + minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' busy times\nparticipants_busy = [\n    [\"12:00 to 13:00\", \"13:30 to 14:00\", \"14:30 to 15:30\", \"16:30 to 17:00\"],  # Jennifer\n    [],  # Gregory\n    [],  # Stephanie\n    [\"9:00 to 9:30\", \"11:00 to 11:30\", \"12:00 to 12:30\", \"13:00 to 13:30\", \"14:00 to 15:30\", \"16:30 to 17:00\"],  # Lori\n    [\"9:00 to 11:30\", \"12:00 to 13:00\", \"13:30 to 14:30\", \"15:00 to 16:30\"],  # Jessica\n]\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 30  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_257"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert each participant's busy slots to minutes\n    juan_busy = [\n        (10 * 60 + 30, 11 * 60),\n        (12 * 60, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    marilyn_busy = [\n        (11 * 60, 11 * 60 + 30),\n        (13 * 60 + 30, 14 * 60)\n    ]\n    brian_busy = [\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n    ruth_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (13 * 60, 17 * 60)\n    ]\n    diana_busy = [\n        (9 * 60 + 30, 11 * 60 + 30),\n        (12 * 60, 16 * 60)\n    ]\n\n    # Combine all busy slots\n    all_busy = juan_busy + marilyn_busy + brian_busy + ruth_busy + diana_busy\n\n    # Sort busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check each free slot for a 30-minute window\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert start time back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = (start + meeting_duration) // 60\n            end_mm = (start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_258"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each participant's busy times to minutes since 9:00\n    # Randy's busy times (and constraint: not after 15:30)\n    randy_busy = [\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (16 * 60, 17 * 60)\n    ]\n    randy_constraint = 15 * 60 + 30  # 15:30\n    \n    # Carolyn's busy times\n    carolyn_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60, 11 * 60 + 30),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    # Christina's busy times\n    christina_busy = [\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60 + 30, 14 * 60)\n    ]\n    \n    # Amy's busy times\n    amy_busy = [\n        (9 * 60, 11 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60 + 30, 15 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n    \n    # Christine's busy times\n    christine_busy = [\n        (9 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60, 13 * 60),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    # Combine all busy times into a single list of intervals\n    all_busy = []\n    for busy in [randy_busy, carolyn_busy, christina_busy, amy_busy, christine_busy]:\n        all_busy.extend(busy)\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Filter free intervals to those that are at least 30 minutes and meet Randy's constraint\n    meeting_duration = 30\n    valid_slots = []\n    \n    for start, end in free_intervals:\n        if end - start >= meeting_duration:\n            # Check if the slot starts before Randy's constraint (15:30)\n            if start + meeting_duration <= randy_constraint:\n                valid_slots.append((start, start + meeting_duration))\n    \n    # The first valid slot is the earliest possible meeting time\n    if valid_slots:\n        meeting_start, meeting_end = valid_slots[0]\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No valid time slot found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_259"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:00:12:30}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert all time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work_hours start at 9:00\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = 9 + minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    work_start, work_end = work_hours.split(' to ')\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participans_schedules.values():\n        for busy in schedule:\n            start, end = busy.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            busy_intervals.append((start_min, end_min))\n    \n    # Sort busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots\n    available = []\n    prev_end = work_start_min\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        available.append((prev_end, work_end_min))\n    \n    # Check each available slot for duration\n    for slot_start, slot_end in available:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"Sharon\": [],\n    \"Ryan\": [\"10:00 to 11:00\", \"12:30 to 13:00\", \"14:00 to 14:30\"],\n    \"Isabella\": [\"11:00 to 11:30\", \"14:00 to 14:30\"],\n    \"Anna\": [\"9:00 to 10:00\", \"11:00 to 11:30\", \"13:00 to 14:30\", \"15:00 to 17:00\"],\n    \"Vincent\": [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:30 to 12:00\", \"13:30 to 16:00\"],\n}\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_hours = \"9:00 to 17:00\"\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_260"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{10:00:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability across all participants\n    # Since Alan is free all day, we only need to ensure the interval is free for others\n    # But to generalize, we can consider the merged busy intervals\n    \n    # Now, find the first free interval that can accommodate the meeting duration\n    meeting_duration_min = meeting_duration * 60\n    \n    for start, end in free_intervals:\n        if end - start >= meeting_duration_min:\n            meeting_end = start + meeting_duration_min\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"9:00 to 9:30\", \"11:30 to 12:00\", \"13:00 to 13:30\", \"15:30 to 16:00\"],  # Lisa\n    [\"13:00 to 13:30\", \"14:00 to 14:30\"],  # Frances\n    [],  # Alan\n    [\"9:30 to 10:00\", \"11:00 to 11:30\", \"13:00 to 14:00\", \"14:30 to 16:30\"],  # Linda\n    [\"9:00 to 9:30\", \"11:00 to 11:30\", \"12:00 to 12:30\", \"13:30 to 17:00\"],  # Shirley\n]\n\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 1  # in hours\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_261"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert all time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work_hours start at 9:00\n    \n    start_work, end_work = work_hours\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules.values():\n        for interval in schedule:\n            start, end = interval\n            busy_start = time_to_minutes(start)\n            busy_end = time_to_minutes(end)\n            busy_intervals.append((busy_start, busy_end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = 9 + minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            start_time = minutes_to_time(meeting_start)\n            end_time = minutes_to_time(meeting_end)\n            return f\"{start_time}:{end_time}\"\n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"Doris\": [(\"10:30\", \"11:00\"), (\"16:30\", \"17:00\")],\n    \"Dennis\": [(\"9:30\", \"10:00\"), (\"10:30\", \"11:00\"), (\"14:00\", \"14:30\"), (\"15:30\", \"16:00\")],\n    \"Matthew\": [(\"9:30\", \"10:30\"), (\"13:00\", \"13:30\"), (\"15:00\", \"15:30\")],\n    \"Andrea\": [(\"9:00\", \"10:00\"), (\"10:30\", \"11:30\"), (\"12:00\", \"13:00\"), (\"14:00\", \"14:30\"), (\"15:30\", \"17:00\")],\n    \"Brandon\": [(\"9:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"17:00\")]\n}\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\n# Work hours (9:00 to 17:00)\nwork_hours = (\"9:00\", \"17:00\")\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, duration, work_hours))\n```",
            "count": "calendar_scheduling_example_262"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each participant's busy slots to minutes since 9:00\n    # Nicholas has no meetings\n    nicholas_busy = []\n    \n    # Robert's busy slots\n    robert_busy = [\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60)\n    ]\n    \n    # Gary's busy slots\n    gary_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (13 * 60, 13 * 60 + 30)\n    ]\n    \n    # Doris's busy slots\n    doris_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 11 * 60),\n        (11 * 60 + 30, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    # Beverly's busy slots and preference (avoid before 11:30)\n    beverly_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 16 * 60 + 30)\n    ]\n    beverly_preference_start = 11 * 60 + 30  # 11:30\n    \n    # Combine all busy slots\n    all_busy = robert_busy + gary_busy + doris_busy + beverly_busy\n    \n    # Generate free slots by finding gaps in the combined busy slots\n    all_busy.sort()  # Sort by start time\n    free_slots = []\n    previous_end = work_start\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Filter free slots that are at least 30 minutes and meet Beverly's preference\n    valid_slots = []\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration and slot_start >= beverly_preference_start:\n            valid_slots.append((slot_start, slot_end))\n    \n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No valid slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_263"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time slots to minutes since start of the day for easier comparison\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n\n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n\n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n\n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:00 to 12:00\", \"13:00 to 13:30\", \"16:00 to 16:30\"],  # Amber\n    [\"11:00 to 11:30\", \"14:00 to 14:30\"],  # Christian\n    [\"11:00 to 11:30\", \"12:00 to 13:30\", \"14:00 to 14:30\", \"15:30 to 16:00\"],  # Natalie\n    [\"9:30 to 12:30\", \"14:00 to 14:30\", \"15:00 to 15:30\", \"16:00 to 17:00\"],  # Douglas\n    [\"9:00 to 9:30\", \"10:00 to 10:30\", \"12:00 to 13:00\", \"14:00 to 17:00\"],  # Larry\n]\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, \"9:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_264"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:30:15:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find the earliest time when everyone is free\n    current_start = work_start\n    \n    for start, end in busy_intervals:\n        if start > current_start:\n            # Check if there's enough time before the next busy interval\n            if start - current_start >= duration:\n                meeting_end = current_start + duration\n                if meeting_end <= work_end:\n                    return f\"{minutes_to_time(current_start)}:{minutes_to_time(meeting_end)}\"\n        # Update current_start to the end of the current busy interval if it's later\n        if end > current_start:\n            current_start = end\n    \n    # Check the remaining time after the last busy interval\n    if work_end - current_start >= duration:\n        meeting_end = current_start + duration\n        return f\"{minutes_to_time(current_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [],  # Cheryl is free\n    [\"09:30:10:00\", \"12:00:13:00\", \"14:00:14:30\", \"16:00:17:00\"],  # Juan\n    [],  # Alan is free\n    [\"09:00:10:30\", \"12:00:14:30\", \"15:00:16:00\"],  # Christina\n    [\"09:00:14:00\", \"15:00:17:00\"],  # Grace\n]\n\n# Define work hours and meeting duration\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes))\n```",
            "count": "calendar_scheduling_example_265"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:11:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since 9:00 (work_hours_start)\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m - work_hours_start * 60\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        h = (minutes + work_hours_start * 60) // 60\n        m = (minutes + work_hours_start * 60) % 60\n        return f\"{h:02d}:{m:02d}\"\n\n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots between work hours\n    available = []\n    prev_end = 0\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < (work_hours_end - work_hours_start) * 60:\n        available.append((prev_end, (work_hours_end - work_hours_start) * 60))\n    \n    # Find the first available slot that fits the duration\n    duration = duration_minutes\n    for start, end in available:\n        if end - start >= duration:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"09:30:10:00\", \"10:30:11:00\"],  # Joe\n    [\"11:30:12:00\", \"15:00:15:30\"],  # Keith\n    [\"09:00:09:30\", \"13:00:13:30\"],  # Patricia\n    [\"09:00:11:00\", \"11:30:16:30\"],  # Nancy\n    [\"09:00:10:00\", \"10:30:11:00\", \"11:30:12:30\", \"13:00:14:00\", \"14:30:15:00\", \"15:30:16:00\", \"16:30:17:00\"]  # Pamela\n]\n\n# Define work hours and meeting duration\nwork_hours_start = 9\nwork_hours_end = 17\nduration_minutes = 30\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes))\n```",
            "count": "calendar_scheduling_example_266"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy times in minutes (start, end)\n    deborah_busy = [(9*60, 9*60 + 30), (14*60, 14*60 + 30)]\n    gary_busy = [(12*60 + 30, 13*60), (14*60 + 30, 15*60)]\n    emma_busy = []\n    carolyn_busy = [(9*60 + 30, 12*60), (12*60 + 30, 15*60 + 30), (16*60, 16*60 + 30)]\n    karen_busy = [\n        (9*60 + 30, 10*60),\n        (10*60 + 30, 11*60),\n        (11*60 + 30, 12*60),\n        (12*60 + 30, 13*60),\n        (13*60 + 30, 14*60),\n        (15*60, 16*60 + 30)\n    ]\n    \n    # Emma's preference: not before 13:30\n    emma_preference_start = 13*60 + 30\n    \n    # Combine all busy times\n    all_busy = deborah_busy + gary_busy + carolyn_busy + karen_busy\n    \n    # Generate available slots (inverted busy times)\n    all_busy.sort()\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Filter slots that are at least 30 minutes and meet Emma's preference\n    meeting_duration = 30\n    valid_slots = []\n    \n    for start, end in available_slots:\n        if end - start >= meeting_duration:\n            slot_start = max(start, emma_preference_start)\n            if slot_start + meeting_duration <= end:\n                valid_slots.append((slot_start, slot_start + meeting_duration))\n    \n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start, meeting_end = valid_slots[0]\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        print(f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\")\n    else:\n        print(\"No valid slot found\")\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_267"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each person's busy slots to minutes since 9:00\n    # Jesse: 10:30-11:00, 11:30-12:00, 13:30-15:30\n    jesse_busy = [\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60 + 30, 15 * 60 + 30)\n    ]\n    \n    # Cheryl: 9:30-10:00, 12:30-13:00, 14:30-16:00, 16:30-17:00\n    cheryl_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Elizabeth: free all day\n    elizabeth_busy = []\n    \n    # Diana: 9:00-12:00, 12:30-13:30, 14:00-17:00\n    diana_busy = [\n        (9 * 60, 12 * 60),\n        (12 * 60 + 30, 13 * 60 + 30),\n        (14 * 60, 17 * 60)\n    ]\n    \n    # Barbara: 9:00-11:00, 11:30-12:00, 12:30-14:30, 15:00-16:30\n    barbara_busy = [\n        (9 * 60, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 14 * 60 + 30),\n        (15 * 60, 16 * 60 + 30)\n    ]\n    \n    # Combine all busy slots\n    all_busy = jesse_busy + cheryl_busy + elizabeth_busy + diana_busy + barbara_busy\n    \n    # Sort busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Check each free slot for a 30-minute window\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert back to HH:MM format\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_268"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since midnight\n    busy_slots = {\n        'Virginia': [(9*60 + 30, 10*60 + 30), (11*60, 11*60 + 30), (12*60, 12*60 + 30), (16*60, 17*60)],\n        'Melissa': [(11*60 + 30, 12*60 + 30), (14*60 + 30, 15*60), (16*60 + 30, 17*60)],\n        'Emma': [(10*60, 13*60 + 30), (14*60, 14*60 + 30), (15*60, 17*60)],\n        'Jacqueline': [(10*60, 11*60), (11*60 + 30, 12*60), (13*60, 14*60 + 30), (15*60 + 30, 16*60), (16*60 + 30, 17*60)],\n    }\n\n    # Collect all busy slots from all participants except Jacob (free all day)\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n\n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check the slot after the last busy slot until work_end\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_269"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    duration = 30         # meeting duration in minutes\n\n    # Define busy intervals for each participant in minutes since midnight\n    frances_busy = [(9*60, 10*60 + 30), (12*60 + 30, 13*60)]\n    kimberly_busy = [(9*60, 9*60 + 30), (12*60, 13*60 + 30), (14*60, 14*60 + 30), (15*60, 15*60 + 30), (16*60, 17*60)]\n    christopher_busy = [(9*60 + 30, 10*60 + 30), (11*60, 14*60 + 30), (15*60 + 30, 17*60)]\n    \n    # Kimberly's preference: avoid meetings after 12:30 (12*60 + 30)\n    kimberly_preference_cutoff = 12 * 60 + 30\n\n    # Combine all busy intervals\n    all_busy = frances_busy + kimberly_busy + christopher_busy\n    # Sort by start time\n    all_busy.sort()\n\n    # Find free slots\n    free_slots = []\n    prev_end = work_start\n\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n\n    # Filter free slots that are at least 'duration' long and meet Kimberly's preference\n    possible_slots = []\n    for start, end in free_slots:\n        if end - start >= duration:\n            # Check if the slot is entirely before Kimberly's preference cutoff\n            if end <= kimberly_preference_cutoff:\n                possible_slots.append((start, end))\n    \n    # If no slots before cutoff, consider all free slots\n    if not possible_slots:\n        for start, end in free_slots:\n            if end - start >= duration:\n                possible_slots.append((start, end))\n\n    # Select the earliest possible slot\n    if possible_slots:\n        start, end = possible_slots[0]\n        # Convert minutes back to HH:MM format\n        start_hh = start // 60\n        start_mm = start % 60\n        end_hh = (start + duration) // 60\n        end_mm = (start + duration) % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_270"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:30:16:00}",
            "type_error": "SyntaxError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start, end = work_hours\n    # Convert time strings to minutes for easier calculation\n    start_min = time_to_minutes(start)\n    end_min = time_to_minutes(end)\n    duration_min = duration * 60\n    \n    # Initialize a list to track busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            busy_start = time_to_minutes(busy[0])\n            busy_end = time_to_minutes(busy[1])\n            busy_intervals.append((busy_start, busy_end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find the earliest available slot\n    previous_end = start_min\n    for interval in busy_intervals:\n        current_start, current_end = interval\n        if current_start > previous_end:\n            available_start = previous_end\n            available_end = current_start\n            if available_end - available_start >= duration_min:\n                return (minutes_to_time(available_start), minutes_to_time(available_start + duration_min)\n        previous_end = max(previous_end, current_end)\n    \n    # Check the slot after the last busy interval\n    if end_min - previous_end >= duration_min:\n        return (minutes_to_time(previous_end), minutes_to_time(previous_end + duration_min))\n    \n    return None\n\ndef time_to_minutes(time_str):\n    hours, minutes = map(int, time_str.split(':'))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Define work hours and meeting duration\nwork_hours = ('9:00', '17:00')\nduration = 0.5  # 0.5 hours = 30 minutes\n\n# Define participants' schedules\nparticipants_schedules = [\n    [('9:30', '10:00'), ('12:00', '14:00'), ('16:30', '17:00')],  # Teresa\n    [('11:30', '12:00'), ('14:00', '14:30')],  # Amanda\n    [],  # Frances\n    [('9:00', '12:00'), ('12:30', '14:00'), ('14:30', '15:30'), ('16:30', '17:00')],  # Evelyn\n    [('9:00', '10:00'), ('10:30', '11:30'), ('12:00', '13:00'), ('13:30', '15:30'), ('16:00', '17:00')]  # Betty\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nif meeting_time:\n    print(f\"{meeting_time[0]}:{meeting_time[1]}\")\nelse:\n    print(\"No available time slot found.\")\n```",
            "count": "calendar_scheduling_example_271"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Convert all blocked times to minutes since midnight\n    blocked_slots = {\n        'Teresa': [(9*60 + 30, 10*60), (12*60, 13*60), (14*60, 14*60 + 30)],\n        'Scott': [(9*60, 9*60 + 30), (10*60, 11*60), (11*60 + 30, 12*60), (15*60, 16*60)],\n        'Eric': [(12*60, 12*60 + 30), (13*60, 13*60 + 30), (14*60 + 30, 15*60 + 30)],\n        'Maria': [(9*60, 10*60), (10*60 + 30, 12*60), (12*60 + 30, 13*60 + 30), (14*60, 15*60 + 30)],\n        'Emily': [(9*60, 11*60 + 30), (12*60 + 30, 14*60), (14*60 + 30, 15*60), (16*60 + 30, 17*60)],\n    }\n    \n    # Collect all blocked slots\n    all_blocked = []\n    for person in blocked_slots:\n        all_blocked.extend(blocked_slots[person])\n    \n    # Sort blocked slots by start time\n    all_blocked.sort()\n    \n    # Find free slots by checking gaps between blocked slots and work hours\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_blocked:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the time after the last blocked slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can accommodate 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_272"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 9:00 (0 minutes)\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    # Initialize the work hours in minutes\n    start_work = time_to_minutes(work_hours[0])\n    end_work = time_to_minutes(work_hours[1])\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules.values():\n        for interval in schedule:\n            start, end = interval\n            busy_start = time_to_minutes(start)\n            busy_end = time_to_minutes(end)\n            busy_intervals.append((busy_start, busy_end))\n    \n    # Sort the busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    prev_end = start_work\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < end_work:\n        free_intervals.append((prev_end, end_work))\n    \n    # Check each free interval for availability of duration\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"John\": [\"11:30-12:00\", \"13:30-14:00\", \"15:00-15:30\", \"16:00-16:30\"],\n    \"Frank\": [\"12:00-13:30\", \"15:00-15:30\"],\n    \"Randy\": [],\n    \"Larry\": [\"9:00-11:00\", \"11:30-12:00\", \"13:30-14:00\", \"14:30-15:00\", \"16:30-17:00\"],\n    \"Beverly\": [\"9:00-11:00\", \"12:00-12:30\", \"13:30-17:00\"],\n}\n\n# Convert each participant's schedule to list of intervals\nfor name in participants_schedules:\n    intervals = []\n    for interval in participants_schedules[name]:\n        start, end = interval.split('-')\n        intervals.append((start, end))\n    participants_schedules[name] = intervals\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 30  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_273"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define each person's busy slots in minutes\n    busy_slots = {\n        'Kevin': [(11 * 60 + 30, 12 * 60), (14 * 60, 14 * 60 + 30), (16 * 60, 17 * 60)],\n        'Joyce': [],\n        'Kathryn': [(9 * 60, 9 * 60 + 30), (11 * 60 + 30, 12 * 60)],\n        'Bruce': [(9 * 60, 10 * 60 + 30), (11 * 60, 13 * 60 + 30), (14 * 60, 17 * 60)],\n        'Ronald': [(9 * 60 + 30, 11 * 60), (11 * 60 + 30, 13 * 60 + 30), \n                    (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)]\n    }\n\n    # Duration of the meeting in minutes\n    duration = 30\n\n    # Iterate through each minute in the work hours\n    for start_time in range(work_start, work_end - duration + 1):\n        end_time = start_time + duration\n        all_available = True\n\n        # Check each person's availability\n        for person, slots in busy_slots.items():\n            for (busy_start, busy_end) in slots:\n                # Check if the proposed slot overlaps with any busy slot\n                if not (end_time <= busy_start or start_time >= busy_end):\n                    all_available = False\n                    break\n            if not all_available:\n                break\n\n        if all_available:\n            # Convert minutes back to HH:MM format\n            start_hh = start_time // 60\n            start_mm = start_time % 60\n            end_hh = end_time // 60\n            end_mm = end_time % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No available time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_274"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since midnight\n    busy_slots = {\n        'Jose': [(11 * 60, 11 * 60 + 30), (12 * 60 + 30, 13 * 60)],\n        'Albert': [(10 * 60, 10 * 60 + 30), (11 * 60, 11 * 60 + 30), (13 * 60, 14 * 60 + 30), (15 * 60, 15 * 60 + 30)],\n        'Brenda': [(10 * 60, 10 * 60 + 30), (11 * 60, 11 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60 + 30)],\n        'Bruce': [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 13 * 60), (13 * 60 + 30, 16 * 60 + 30)],\n        'Jacob': [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 11 * 60 + 30), (12 * 60, 14 * 60), (15 * 60, 15 * 60 + 30)]\n    }\n\n    # Collect all busy slots\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n\n    # Sort busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check the time after the last busy slot until work_end\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_275"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert each participant's busy slots to minutes\n    christine_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30)\n    ]\n    \n    natalie_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    # Willie is free all day but can't meet after 12:00\n    willie_busy = [(12 * 60, work_end)]\n    \n    anna_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    \n    evelyn_busy = [\n        (11 * 60, 12 * 60),\n        (12 * 60 + 30, 13 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (16 * 60, 17 * 60)\n    ]\n    \n    # Combine all busy slots\n    all_busy = christine_busy + natalie_busy + willie_busy + anna_busy + evelyn_busy\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    # Check after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that is at least 30 minutes long\n    meeting_duration = 30\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Convert back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = (slot_start + meeting_duration) // 60\n            end_mm = (slot_start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_276"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each person's busy slots to minutes\n    # Virginia's busy slots\n    virginia_busy = [\n        (9 * 60, 10 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    \n    # Lawrence's busy slots\n    lawrence_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 17 * 60)\n    ]\n    \n    # Angela's busy slots\n    angela_busy = [\n        (9 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Marilyn and Diana have no meetings, so their busy slots are empty\n    \n    # Combine all busy slots\n    all_busy = virginia_busy + lawrence_busy + angela_busy\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Check each free slot for a 30-minute window\n    meeting_duration = 30\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Found a suitable slot\n            start_hour = slot_start // 60\n            start_min = slot_start % 60\n            end_hour = (slot_start + meeting_duration) // 60\n            end_min = (slot_start + meeting_duration) % 60\n            return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_277"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m - 540  # Subtract 540 to start from 0 (9:00)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        h = (minutes + 540) // 60\n        m = (minutes + 540) % 60\n        return f\"{h:02d}:{m:02d}\"\n    \n    # Initialize the availability list (0 to 480 minutes, 9:00-17:00 is 8 hours)\n    availability = [True] * (work_hours[1] - work_hours[0])\n    \n    # Mark busy times for each participant\n    for person, busy_slots in participants_busy.items():\n        for slot in busy_slots:\n            start = time_to_minutes(slot[0])\n            end = time_to_minutes(slot[1])\n            for i in range(start, end):\n                if i >= 0 and i < len(availability):\n                    availability[i] = False\n    \n    # Find the first available slot of duration\n    duration_min = duration\n    start_time = None\n    for i in range(len(availability) - duration_min + 1):\n        if all(availability[i:i+duration_min]):\n            start_time = i\n            break\n    \n    if start_time is not None:\n        end_time = start_time + duration_min\n        return f\"{minutes_to_time(start_time)}:{minutes_to_time(end_time)}\"\n    else:\n        return \"No available slot found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (9 * 60, 17 * 60)  # 9:00 and 17:00 in minutes since midnight\n\n# Define participants' busy times\nparticipants_busy = {\n    'Donald': [('10:00', '10:30'), ('11:30', '13:00'), ('15:30', '16:00'), ('16:30', '17:00')],\n    'Gregory': [('9:30', '10:00'), ('12:00', '12:30'), ('13:00', '13:30'), ('14:30', '15:00')],\n    'Roy': [('10:00', '10:30'), ('12:30', '13:00')],\n    'Jack': [('9:00', '9:30'), ('10:00', '13:30'), ('14:00', '16:00')],\n    'Paul': [('9:00', '11:30'), ('12:00', '12:30'), ('13:00', '13:30'), ('15:00', '16:30')]\n}\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_278"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define busy slots for each participant in minutes\n    busy_slots = {\n        'Thomas': [(9 * 60, 9 * 60 + 30), (14 * 60, 14 * 60 + 30)],\n        'Albert': [(9 * 60 + 30, 11 * 60), (12 * 60, 13 * 60), (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Margaret': [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 11 * 60 + 30), (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 15 * 60 + 30), (16 * 60, 17 * 60)],\n    }\n\n    # Betty's preference: not after 13:00\n    betty_preference_end = 13 * 60\n\n    # Collect all busy slots\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n\n    # Add Betty's preference as a busy slot after 13:00\n    all_busy.append((betty_preference_end, work_end))\n\n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check for a free slot that is at least 30 minutes long\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Return the first suitable slot\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_279"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:9:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert all time strings to minutes since 9:00 (work_hours_start)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # 9:00 is 0 minutes\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = 9 + minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration_min = duration * 60\n\n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules.values():\n        for busy in schedule:\n            start = time_to_minutes(busy[0])\n            end = time_to_minutes(busy[1])\n            all_busy.append((start, end))\n\n    # Sort all busy intervals by start time\n    all_busy.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find available slots by checking gaps between merged intervals\n    available = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n\n    # Find the first available slot that fits the duration\n    for slot in available:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No available time slot found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"Charles\": [(\"13:00\", \"14:30\"), (\"15:00\", \"16:30\")],\n    \"Adam\": [(\"12:00\", \"12:30\"), (\"16:00\", \"16:30\")],\n    \"Jason\": [(\"9:30\", \"10:00\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"15:00\", \"15:30\")],\n    \"Daniel\": [(\"9:30\", \"10:30\"), (\"11:00\", \"11:30\"), (\"12:30\", \"13:00\"), (\"14:00\", \"15:30\"), (\"16:00\", \"16:30\")],\n    \"Ethan\": [(\"10:00\", \"12:00\"), (\"12:30\", \"14:30\"), (\"16:00\", \"17:00\")]\n}\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, \"9:00\", \"17:00\", 0.5)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_280"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration_minutes):\n    # Convert work hours to minutes since midnight\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's busy times\n    for busy_times in participants_busy_times:\n        new_free_slots = []\n        for slot in free_slots:\n            current_start = slot[0]\n            for busy in busy_times:\n                busy_start = busy[0] * 60\n                busy_end = busy[1] * 60\n                if busy_start > current_start:\n                    new_free_slots.append((current_start, busy_start))\n                current_start = max(current_start, busy_end)\n            if current_start < slot[1]:\n                new_free_slots.append((current_start, slot[1]))\n        free_slots = new_free_slots\n    \n    # Find the first slot that can accommodate the meeting duration\n    for slot in free_slots:\n        slot_duration = slot[1] - slot[0]\n        if slot_duration >= duration_minutes:\n            meeting_start = slot[0]\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No suitable time found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (9, 17)\n\n# Define each participant's busy times in HH.MM format\nparticipants_busy_times = [\n    [],  # Rebecca\n    [],  # Alexander\n    [(11.5, 12), (12.5, 13), (13.5, 14.5), (15, 15.5), (16, 16.5)],  # Angela\n    [(9.5, 10), (10.5, 15), (15.5, 16.5)],  # Beverly\n    [(9.5, 11), (11.5, 12), (13, 13.5), (14, 15), (16.5, 17)]  # Peter\n]\n\n# Meeting duration in minutes (30 minutes)\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_281"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_hour, end_hour = work_hours\n    # Convert work hours to minutes\n    start_time = start_hour * 60\n    end_time = end_hour * 60\n    \n    # Initialize a list to track busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules.values():\n        all_busy.extend(schedule)\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for busy in all_busy:\n        if not merged:\n            merged.append(busy)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = busy\n            if current_start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append(busy)\n    \n    # Find available slots between work hours and busy intervals\n    available = []\n    prev_end = start_time\n    for busy_start, busy_end in merged:\n        if busy_start > prev_end:\n            available.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n    if prev_end < end_time:\n        available.append((prev_end, end_time))\n    \n    # Check each available slot for sufficient duration\n    for slot_start, slot_end in available:\n        if slot_end - slot_start >= duration:\n            # Convert back to hours and minutes\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = (slot_start + duration) // 60\n            end_mm = (slot_start + duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules in minutes since midnight\nparticipants_schedules = {\n    \"Larry\": [(10*60 + 30, 11*60), (11*60 + 30, 12*60)],\n    \"Juan\": [],\n    \"Emily\": [],\n    \"Joan\": [(9*60 + 30, 11*60), (11*60 + 30, 12*60), (12*60 + 30, 14*60), (15*60, 15*60 + 30)],\n    \"Julie\": [(9*60, 11*60 + 30), (12*60 + 30, 17*60)],\n}\n\n# Define work hours and meeting duration\nwork_hours = (9*60, 17*60)  # 9:00 to 17:00 in minutes\nduration = 30  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_282"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start, work_end = map(time_to_minutes, work_hours)\n    duration_min = duration * 60\n\n    # Collect all busy times for all participants\n    all_busy_times = []\n    for busy_times in participants_busy_times.values():\n        for start, end in busy_times:\n            all_busy_times.append((time_to_minutes(start), time_to_minutes(end)))\n\n    # Sort all busy times by start time\n    all_busy_times.sort()\n\n    # Generate available slots by finding gaps between busy times and work hours\n    available_slots = []\n    prev_end = work_start\n\n    for start, end in all_busy_times:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No available time slot found\"\n\n# Define participants' busy times\nparticipants_busy_times = {\n    \"Rachel\": [(\"12:00\", \"12:30\"), (\"15:00\", \"15:30\")],\n    \"Alexander\": [(\"14:00\", \"14:30\"), (\"15:00\", \"15:30\")],\n    \"Aaron\": [(\"09:00\", \"10:30\"), (\"11:30\", \"17:00\")],\n    \"Hannah\": [(\"09:00\", \"09:30\"), (\"11:00\", \"11:30\"), (\"12:30\", \"14:30\"), (\"15:00\", \"15:30\"), (\"16:00\", \"16:30\")],\n    \"Juan\": []\n}\n\n# Define work hours and meeting duration\nwork_hours = (\"09:00\", \"17:00\")\nduration = 0.5  # half an hour\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_283"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_start=9 * 60, work_end=17 * 60):\n    # Convert all schedules to minutes since midnight for easier comparison\n    busy_slots = []\n    for schedule in participants_schedules:\n        for start, end in schedule:\n            busy_slots.append((start, end))\n    \n    # Sort all busy slots by start time\n    busy_slots.sort()\n    \n    # Merge overlapping or adjacent busy slots\n    merged_slots = []\n    for start, end in busy_slots:\n        if not merged_slots:\n            merged_slots.append((start, end))\n        else:\n            last_start, last_end = merged_slots[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged_slots[-1] = (new_start, new_end)\n            else:\n                merged_slots.append((start, end))\n    \n    # Find available slots between work hours, outside merged busy slots\n    available_slots = []\n    previous_end = work_start\n    for start, end in merged_slots:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for start, end in available_slots:\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return None\n\n# Define participants' schedules in minutes since midnight\nparticipants_schedules = [\n    [],  # Frances has no meetings\n    [(10 * 60 + 30, 11 * 60 + 0), (14 * 60 + 0, 14 * 60 + 30), (16 * 60 + 0, 17 * 60 + 0)],  # Jack\n    [(12 * 60 + 30, 13 * 60 + 0), (14 * 60 + 0, 14 * 60 + 30)],  # Susan\n    [(9 * 60 + 0, 10 * 60 + 0), (10 * 60 + 30, 11 * 60 + 30), (12 * 60 + 0, 12 * 60 + 30), \n     (15 * 60 + 0, 16 * 60 + 0), (16 * 60 + 30, 17 * 60 + 0)],  # Scott\n    [(9 * 60 + 0, 10 * 60 + 0), (11 * 60 + 0, 14 * 60 + 0), (14 * 60 + 30, 16 * 60 + 0), \n     (16 * 60 + 30, 17 * 60 + 0)],  # Joan\n]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_284"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    duration = 30         # meeting duration in minutes\n\n    # Define each person's busy times in minutes since midnight\n    logan_busy = [(10 * 60, 10 * 60 + 30), (14 * 60, 14 * 60 + 30)]\n    kathryn_busy = []\n    jennifer_busy = []\n    alexis_busy = [(9 * 60, 11 * 60), (12 * 60, 14 * 60), (15 * 60, 16 * 60)]\n    roy_busy = [(9 * 60, 10 * 60 + 30), (12 * 60, 12 * 60 + 30), \n                (13 * 60, 13 * 60 + 30), (14 * 60, 15 * 60), (16 * 60, 16 * 60 + 30)]\n\n    # Alexis's preference: not before 16:30\n    alexis_preference_start = 16 * 60 + 30\n\n    # Combine all busy times\n    all_busy = logan_busy + kathryn_busy + jennifer_busy + alexis_busy + roy_busy\n\n    # Generate available slots by finding gaps in busy times\n    all_busy.sort()\n    available_slots = []\n    prev_end = work_start\n\n    for start, end in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Filter slots that meet duration and Alexis's preference\n    valid_slots = []\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration and slot_start >= alexis_preference_start:\n            valid_slots.append(slot)\n\n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No valid slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_285"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Check each available slot for sufficient duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"9:00 to 10:30\", \"15:00 to 15:30\"],  # Ralph\n    [],                                   # John\n    [],                                   # Sharon\n    [\"9:30 to 13:30\", \"14:00 to 17:00\"], # Sophia\n    [\"9:00 to 10:30\", \"12:00 to 13:30\", \"15:00 to 15:30\", \"16:30 to 17:00\"]  # Samantha\n]\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 30  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration))\n```",
            "count": "calendar_scheduling_example_286"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:30:10:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes, work_start, work_end):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start_min, work_end_min)]\n    \n    # Process each participant's busy slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_slots.append((start, end))\n        \n        # Sort the busy slots\n        busy_slots.sort()\n        \n        # Update free_slots by subtracting busy slots\n        new_free_slots = []\n        for free_start, free_end in free_slots:\n            current_start = free_start\n            for busy_start, busy_end in busy_slots:\n                if busy_start >= free_end:\n                    break\n                if busy_end <= current_start:\n                    continue\n                if busy_start > current_start:\n                    new_free_slots.append((current_start, busy_start))\n                current_start = max(current_start, busy_end)\n            if current_start < free_end:\n                new_free_slots.append((current_start, free_end))\n        free_slots = new_free_slots\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' busy schedules\nparticipants_schedules = [\n    [\"10:00:10:30\", \"11:30:12:30\", \"14:30:15:30\", \"16:00:16:30\"],  # Aaron\n    [],  # Lori\n    [],  # Jordan\n    [\"9:00:9:30\", \"10:00:13:00\", \"14:00:14:30\", \"15:00:16:00\"],  # Noah\n    [\"9:00:9:30\", \"10:00:16:00\", \"16:30:17:00\"],  # Susan\n]\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_start = \"9:00\"\nwork_end = \"17:00\"\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_start, work_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_287"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:00:10:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    meeting_duration_min = meeting_duration * 60\n\n    # Initialize the list of busy intervals for all participants\n    all_busy_intervals = []\n    for busy_times in participants_busy_times:\n        for interval in busy_times:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            all_busy_intervals.append((start, end))\n\n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged_intervals = []\n    for start, end in all_busy_intervals:\n        if not merged_intervals:\n            merged_intervals.append([start, end])\n        else:\n            last_start, last_end = merged_intervals[-1]\n            if start <= last_end:\n                merged_intervals[-1][1] = max(end, last_end)\n            else:\n                merged_intervals.append([start, end])\n\n    # Find available slots by checking gaps between merged intervals and work hours\n    available_slots = []\n    prev_end = work_start\n    for start, end in merged_intervals:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Find the first available slot that can accommodate the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No available time slot found\"\n\n# Define the participants' busy times\nparticipants_busy_times = [\n    [\"9:30 to 10:00\", \"14:30 to 15:00\"],  # Dennis\n    [\"10:30 to 11:00\", \"11:30 to 12:30\", \"13:00 to 13:30\"],  # Ralph\n    [\"11:00 to 11:30\", \"12:00 to 13:00\", \"14:00 to 15:00\", \"15:30 to 16:00\"],  # Jesse\n    [\"9:00 to 10:00\", \"10:30 to 12:00\", \"13:00 to 15:00\", \"15:30 to 17:00\"],  # Deborah\n    [\"9:00 to 9:30\", \"10:30 to 11:30\", \"12:00 to 13:30\", \"14:00 to 17:00\"],  # Karen\n]\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 0.5  # in hours\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_288"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert all schedules to minutes for easier comparison\n    # Each person's busy times are represented as (start, end) in minutes\n    janet_busy = [\n        (10 * 60 + 30, 11 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    \n    alexander_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    alan_busy = [\n        (9 * 60, 11 * 60),\n        (13 * 60, 14 * 60),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    henry_busy = [\n        (9 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 17 * 60)\n    ]\n    \n    # Combine all busy times\n    all_busy = janet_busy + alexander_busy + alan_busy + henry_busy\n    \n    # Sort all busy times by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    prev_end = work_start\n    \n    for busy in all_busy:\n        start, end = busy\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    # Check the time after the last busy slot until work_end\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Find the first free slot that can accommodate 30 minutes\n    meeting_duration = 30\n    for slot in free_slots:\n        start, end = slot\n        if end - start >= meeting_duration:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = (start + meeting_duration) // 60\n            end_mm = (start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_289"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define each person's busy times in minutes since midnight\n    busy_times = {\n        'Ryan': [],\n        'Susan': [],\n        'Joyce': [(10 * 60, 10 * 60 + 30), (15 * 60 + 30, 16 * 60)],\n        'Jacob': [(9 * 60, 11 * 60), (12 * 60 + 30, 13 * 60), (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Lauren': [(9 * 60, 10 * 60), (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 17 * 60)],\n    }\n\n    # Lauren's preference: avoid after 13:00 (but already blocked in schedule)\n    # Combine all busy times\n    all_busy = []\n    for person in busy_times:\n        all_busy.extend(busy_times[person])\n    \n    # Sort busy times by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy times and work hours\n    free_slots = []\n    prev_end = work_start\n\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    # Check after last busy time\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n\n    # Find the first free slot that can fit the meeting\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= meeting_duration:\n            # Convert back to HH:MM format\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_290"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration_minutes):\n    # Convert all time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work_hours start at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = 9 + minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    start_work = time_to_minutes(work_hours[0])\n    end_work = time_to_minutes(work_hours[1])\n    \n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy_times in participants_busy_times.values():\n        for busy in busy_times:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals\n    all_busy.sort()\n    \n    # Find free intervals by merging busy intervals\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Find the gaps between busy intervals that are within work hours\n    free_intervals = []\n    prev_end = start_work\n    for start, end in merged_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < end_work:\n        free_intervals.append((prev_end, end_work))\n    \n    # Check each free interval for a slot that fits the meeting duration\n    for start, end in free_intervals:\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            return (minutes_to_time(meeting_start), minutes_to_time(meeting_end))\n    \n    return None\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration_minutes = 30\n\n# Define participants' busy times\nparticipants_busy_times = {\n    \"Pamela\": [],\n    \"Randy\": [\"10:30 to 12:00\", \"14:30 to 15:30\", \"16:30 to 17:00\"],\n    \"Elijah\": [\"13:00 to 13:30\", \"15:00 to 15:30\"],\n    \"Jerry\": [\"9:00 to 10:00\", \"10:30 to 15:30\", \"16:00 to 17:00\"],\n    \"Kevin\": [\"9:00 to 9:30\", \"10:00 to 11:00\", \"12:30 to 13:30\", \"14:00 to 14:30\", \"16:00 to 17:00\"],\n}\n\n# Find a meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours, duration_minutes)\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{start}:{end}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_291"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert each person's busy slots to minutes\n    larry_busy = [\n        (9 * 60, 10 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    harold_busy = [\n        (11 * 60 + 30, 12 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    elijah_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60)\n    ]\n    willie_busy = [\n        (9 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 13 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    patrick_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n\n    # Combine all busy slots\n    all_busy = larry_busy + harold_busy + elijah_busy + willie_busy + patrick_busy\n\n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by merging busy intervals\n    free_slots = []\n    prev_end = work_start\n\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n\n    # Check each free slot for the earliest 30-minute window\n    meeting_duration = 30\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_292"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    duration = 30         # meeting duration in minutes\n\n    # Define each person's busy times in minutes since 9:00\n    # Format: (start, end) in minutes\n    scott_busy = []\n    nicholas_busy = [(11*60, 11*60+30), (15*60+30, 16*60)]\n    donna_busy = [(9*60+30, 10*60), (12*60, 12*60+30), (14*60, 14*60+30), (16*60, 16*60+30)]\n    vincent_busy = [(9*60+30, 11*60), (11*60+30, 12*60), (13*60+30, 14*60+30), (15*60+30, 16*60+30)]\n    ann_busy = [(9*60+30, 11*60), (12*60, 13*60), (14*60, 15*60), (16*60+30, 17*60)]\n\n    # Vincent's constraint: no meetings after 14:30 (14*60 + 30)\n    vincent_max_time = 14 * 60 + 30\n\n    # Combine all busy times\n    all_busy = scott_busy + nicholas_busy + donna_busy + vincent_busy + ann_busy\n\n    # Generate free slots by finding gaps between busy times\n    # Sort all busy times by start time\n    all_busy.sort()\n    \n    # Initialize free slots\n    free_slots = []\n    prev_end = work_start\n\n    for busy_start, busy_end in all_busy:\n        if busy_start > prev_end:\n            free_slots.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n    \n    # Check the slot after the last busy time\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n\n    # Now find the first free slot that fits the duration and Vincent's constraint\n    for slot_start, slot_end in free_slots:\n        # Calculate the latest possible start time in this slot\n        latest_start = min(slot_end - duration, vincent_max_time - duration)\n        if latest_start >= slot_start:\n            # Found a valid slot\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_293"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = map(time_to_minutes, work_hours.split('-'))\n    \n    # Generate all possible busy intervals for all participants\n    all_busy_intervals = []\n    for busy_times in participants_busy_times.values():\n        for interval in busy_times:\n            start, end = map(time_to_minutes, interval.split('-'))\n            all_busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_intervals = []\n    for start, end in all_busy_intervals:\n        if not merged_intervals:\n            merged_intervals.append([start, end])\n        else:\n            last_start, last_end = merged_intervals[-1]\n            if start <= last_end:\n                merged_intervals[-1][1] = max(end, last_end)\n            else:\n                merged_intervals.append([start, end])\n    \n    # Find available slots between work hours and busy intervals\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged_intervals:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Check each available slot for a duration that fits\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}-{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define the participants' busy times\nparticipants_busy_times = {\n    \"Willie\": [],\n    \"Marilyn\": [\"14:00-14:30\", \"15:00-15:30\"],\n    \"Charlotte\": [\"9:00-9:30\", \"10:00-10:30\", \"11:00-11:30\", \"16:00-16:30\"],\n    \"Zachary\": [\"9:00-9:30\", \"10:00-11:00\", \"11:30-12:00\", \"12:30-13:30\", \"14:30-15:30\", \"16:00-17:00\"],\n    \"Noah\": [\"10:30-11:30\", \"12:00-14:00\", \"14:30-15:00\", \"15:30-17:00\"],\n}\n\n# Define work hours and meeting duration\nwork_hours = \"9:00-17:00\"\nmeeting_duration = 30  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_294"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:30:16:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours=('09:00', '17:00')):\n    # Convert all time strings to minutes since midnight for easier comparison\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start, work_end = map(time_to_minutes, work_hours)\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's schedule to find common free slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_slots.append((start, end))\n        # Sort the busy slots by start time\n        busy_slots.sort()\n        \n        # Merge overlapping or adjacent busy slots\n        merged_busy = []\n        for start, end in busy_slots:\n            if not merged_busy:\n                merged_busy.append((start, end))\n            else:\n                last_start, last_end = merged_busy[-1]\n                if start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged_busy[-1] = (new_start, new_end)\n                else:\n                    merged_busy.append((start, end))\n        \n        # Calculate free slots for this participant\n        participant_free = []\n        prev_end = work_start\n        for start, end in merged_busy:\n            if start > prev_end:\n                participant_free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            participant_free.append((prev_end, work_end))\n        \n        # Intersect with the current common free slots\n        new_free_slots = []\n        i = j = 0\n        while i < len(free_slots) and j < len(participant_free):\n            slot_start, slot_end = free_slots[i]\n            part_start, part_end = participant_free[j]\n            \n            # Find the overlap\n            overlap_start = max(slot_start, part_start)\n            overlap_end = min(slot_end, part_end)\n            \n            if overlap_start < overlap_end:\n                new_free_slots.append((overlap_start, overlap_end))\n            \n            # Move the pointer which ends first\n            if slot_end < part_end:\n                i += 1\n            else:\n                j += 1\n        \n        free_slots = new_free_slots\n    \n    # Find the first free slot that can fit the meeting duration\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration_minutes:\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            \n            meeting_start = minutes_to_time(slot_start)\n            meeting_end = minutes_to_time(slot_start + duration_minutes)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [],  # Joan is free all day\n    [\"09:00:10:00\", \"11:30:12:00\", \"16:30:17:00\"],  # Gloria\n    [\"09:30:10:00\", \"10:30:11:00\", \"12:00:13:00\", \"16:00:17:00\"],  # Ann\n    [\"09:00:10:00\", \"10:30:11:30\", \"13:00:13:30\", \"14:00:15:30\", \"16:00:17:00\"],  # Dorothy\n    [\"09:00:09:30\", \"10:00:15:30\", \"16:00:17:00\"],  # David\n]\n\n# Find the meeting time\nprint(find_meeting_time(participants_schedules))\n```",
            "count": "calendar_scheduling_example_295"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    albert_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    jessica_busy = [\n        (10 * 60, 11 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    lisa_busy = []  # Wide open\n    \n    danielle_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (11 * 60, 12 * 60),\n        (13 * 60 + 30, 16 * 60 + 30)\n    ]\n    \n    deborah_busy = [\n        (9 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (13 * 60, 14 * 60),\n        (15 * 60, 16 * 60)\n    ]\n    \n    # Combine all busy slots\n    all_busy = albert_busy + jessica_busy + danielle_busy + deborah_busy\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_296"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy times to minutes since midnight\n    # Carolyn: 10:00-10:30, 12:00-13:00, 13:30-14:00, 15:00-16:00\n    carolyn_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (12 * 60, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60, 16 * 60)\n    ]\n    \n    # Mark: 12:30-13:00, 15:00-15:30\n    mark_busy = [\n        (12 * 60 + 30, 13 * 60),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    \n    # Thomas: free all day, but prefers after 10:30\n    thomas_busy = [\n        (work_start, 10 * 60 + 30)\n    ]\n    \n    # Hannah: 9:30-11:00, 12:00-15:30, 16:00-17:00\n    hannah_busy = [\n        (9 * 60 + 30, 11 * 60),\n        (12 * 60, 15 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n    \n    # Abigail: 9:30-10:30, 12:00-12:30, 13:00-15:00, 16:00-16:30\n    abigail_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    # Combine all busy times for each participant\n    schedules = {\n        'Carolyn': carolyn_busy,\n        'Mark': mark_busy,\n        'Thomas': thomas_busy,\n        'Hannah': hannah_busy,\n        'Abigail': abigail_busy\n    }\n    \n    # Check for a valid time slot\n    for start in range(work_start, work_end - meeting_duration + 1, 15):  # Check every 15 minutes\n        end = start + meeting_duration\n        valid = True\n        \n        # Check against each person's schedule\n        for person, busy_times in schedules.items():\n            for busy_start, busy_end in busy_times:\n                if not (end <= busy_start or start >= busy_end):\n                    valid = False\n                    break\n            if not valid:\n                break\n        \n        if valid:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = end // 60\n            end_mm = end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No valid time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_297"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes, work_start, work_end):\n    # Convert time strings to minutes since start of day\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            all_busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between merged intervals and work hours\n    available_slots = []\n    previous_end = work_start_min\n    \n    for start, end in merged:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end_min:\n        available_slots.append((previous_end, work_end_min))\n    \n    # Check each available slot for sufficient duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_minutes:\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            \n            meeting_start = minutes_to_time(slot_start)\n            meeting_end = minutes_to_time(slot_start + duration_minutes)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"13:00 to 13:30\", \"14:00 to 14:30\"],  # Ryan\n    [],                                    # Randy\n    [],                                    # Diana\n    [\"9:00 to 10:30\", \"11:00 to 14:00\", \"14:30 to 15:00\", \"15:30 to 16:30\"],  # Stephanie\n    [\"9:00 to 9:30\", \"10:00 to 11:30\", \"13:00 to 14:00\", \"14:30 to 16:30\"],   # Doris\n]\n\n# Find a 30-minute meeting between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, 30, \"9:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_298"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_start, work_end):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start_min\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n    \n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"9:00 to 9:30\", \"10:30 to 11:30\", \"12:00 to 12:30\", \"13:00 to 13:30\", \"16:30 to 17:00\"],  # Jacqueline\n    [\"10:00 to 11:00\", \"11:30 to 12:30\", \"13:30 to 14:00\", \"15:30 to 16:00\"],  # Lauren\n    [],  # Billy\n    [\"9:30 to 10:30\", \"11:30 to 14:30\", \"15:00 to 16:00\"],  # Mark\n    [\"9:00 to 9:30\", \"10:30 to 11:30\", \"12:00 to 14:00\", \"14:30 to 15:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"],  # Teresa\n]\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, 30, \"9:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_299"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m - 540  # Subtract 540 to start from 0 (9:00)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        h = (minutes + 540) // 60\n        m = (minutes + 540) % 60\n        return f\"{h:02d}:{m:02d}\"\n    \n    start_min = time_to_minutes(work_hours[0])\n    end_min = time_to_minutes(work_hours[1])\n    \n    # Create a list of all busy intervals in minutes\n    all_busy = []\n    for busy_list in participants_busy.values():\n        for interval in busy_list:\n            start = time_to_minutes(interval[0])\n            end = time_to_minutes(interval[1])\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots\n    available = []\n    prev_end = start_min\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < end_min:\n        available.append((prev_end, end_min))\n    \n    # Find the first available slot that can fit the duration\n    for slot in available:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            meeting_start = minutes_to_time(slot_start)\n            meeting_end = minutes_to_time(slot_start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No available slot found\"\n\n# Define work hours and duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 30  # minutes\n\n# Define participants' busy times\nparticipants_busy = {\n    \"Eric\": [(\"10:00\", \"10:30\"), (\"12:30\", \"13:00\")],\n    \"Jeremy\": [(\"11:00\", \"12:00\"), (\"12:30\", \"13:00\"), (\"15:00\", \"15:30\")],\n    \"Joe\": [],\n    \"Brian\": [(\"9:00\", \"10:30\"), (\"11:00\", \"13:00\"), (\"13:30\", \"14:00\"), (\"14:30\", \"16:00\"), (\"16:30\", \"17:00\")],\n    \"Brittany\": [(\"9:00\", \"9:30\"), (\"10:30\", \"12:00\"), (\"13:30\", \"14:30\"), (\"15:00\", \"15:30\"), (\"16:30\", \"17:00\")],\n    \"Julia\": [(\"9:00\", \"11:00\"), (\"12:30\", \"13:00\"), (\"13:30\", \"15:00\"), (\"16:00\", \"17:00\")],\n}\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_300"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:11:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # 9:00 is 540 minutes\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    start_work, end_work = work_hours\n    start_min = time_to_minutes(start_work)\n    end_min = time_to_minutes(end_work)\n    duration_min = duration * 60\n\n    # Create a list of all busy intervals for all participants\n    all_busy = []\n    for busy_list in participants_busy.values():\n        for busy in busy_list:\n            start, end = busy\n            all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n\n    # Find available slots by merging all busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1] = (last_start, max(end, last_end))\n            else:\n                merged.append((start, end))\n\n    # Check the available slots before the first busy interval, between them, and after the last\n    available = []\n    prev_end = start_min\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < end_min:\n        available.append((prev_end, end_min))\n\n    # Find the first available slot that can fit the meeting\n    for slot in available:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No available slot found\"\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 0.5  # half an hour\n\n# Define each participant's busy times\nparticipants_busy = {\n    \"Amy\": [(\"13:00\", \"13:30\"), (\"15:30\", \"16:00\")],\n    \"Jonathan\": [(\"9:00\", \"9:30\"), (\"10:00\", \"10:30\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:00\")],\n    \"Brittany\": [(\"9:30\", \"10:00\"), (\"16:30\", \"17:00\")],\n    \"Matthew\": [(\"9:00\", \"10:00\"), (\"12:30\", \"14:30\"), (\"15:00\", \"15:30\"), (\"16:00\", \"16:30\")],\n    \"Catherine\": [(\"9:00\", \"10:30\"), (\"12:00\", \"14:00\"), (\"16:30\", \"17:00\")],\n    \"Carl\": [(\"10:00\", \"11:00\"), (\"11:30\", \"12:30\"), (\"13:00\", \"14:00\"), (\"14:30\", \"16:30\")],\n}\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_301"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Convert all schedules to minutes for easier comparison\n    # Each person's busy times in minutes (start, end)\n    schedules = {\n        'Nicole': [(10 * 60, 10 * 60 + 30), (14 * 60 + 30, 15 * 60)],\n        'Christine': [(11 * 60, 11 * 60 + 30), (12 * 60 + 30, 13 * 60)],\n        'Anna': [(9 * 60 + 30, 10 * 60 + 30), (11 * 60, 11 * 60 + 30), \n                 (12 * 60 + 30, 13 * 60), (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Terry': [(9 * 60 + 30, 11 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60, 15 * 60 + 30)],\n        'Julie': [(10 * 60, 12 * 60), (12 * 60 + 30, 13 * 60 + 30), (14 * 60, 15 * 60)],\n        'Abigail': [(9 * 60, 10 * 60), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 14 * 60), \n                    (14 * 60 + 30, 15 * 60), (16 * 60 + 30, 17 * 60)]\n    }\n    \n    # Anna's preference: not before 14:00\n    anna_preference_start = 14 * 60\n    \n    # Find all possible slots that are free for everyone\n    possible_slots = []\n    current_time = max(work_start, anna_preference_start)\n    meeting_duration = 30\n    \n    while current_time + meeting_duration <= work_end:\n        slot_valid = True\n        slot_start = current_time\n        slot_end = current_time + meeting_duration\n        \n        # Check for each person if the slot is free\n        for person, busy_slots in schedules.items():\n            for busy_start, busy_end in busy_slots:\n                if not (slot_end <= busy_start or slot_start >= busy_end):\n                    slot_valid = False\n                    break\n            if not slot_valid:\n                break\n        \n        if slot_valid:\n            possible_slots.append((slot_start, slot_end))\n        \n        current_time += 15  # Check in 15-minute increments\n    \n    if not possible_slots:\n        return \"No available slot found\"\n    \n    # Select the earliest possible slot\n    chosen_slot = possible_slots[0]\n    start_h = chosen_slot[0] // 60\n    start_m = chosen_slot[0] % 60\n    end_h = chosen_slot[1] // 60\n    end_m = chosen_slot[1] % 60\n    \n    return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_302"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each participant's busy slots to minutes\n    theresa_busy = [(9*60 + 30, 10*60 + 30), (15*60, 16*60)]\n    alexander_busy = [(12*60, 12*60 + 30), (13*60 + 30, 14*60)]\n    lisa_busy = [(10*60 + 30, 12*60 + 30), (13*60 + 30, 14*60 + 30), (16*60, 17*60)]\n    natalie_busy = [(9*60, 9*60 + 30), (11*60, 12*60 + 30), (13*60 + 30, 15*60 + 30), (16*60, 17*60)]\n    victoria_busy = [(9*60 + 30, 10*60 + 30), (11*60, 12*60 + 30), (13*60 + 30, 14*60 + 30), (15*60, 16*60 + 30)]\n    \n    # Virginia is free all day, so no busy slots\n    \n    # Combine all busy slots\n    all_busy = theresa_busy + alexander_busy + lisa_busy + natalie_busy + victoria_busy\n    \n    # Sort busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Check each free slot for a 30-minute window\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_303"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    # Christine: 9:30-10:30, 12:00-12:30, 13:00-13:30, 14:30-15:00, 16:00-16:30\n    christine_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    # Janice: wide open (no busy slots)\n    janice_busy = []\n    \n    # Bobby: 12:00-12:30, 14:30-15:00\n    bobby_busy = [\n        (12 * 60, 12 * 60 + 30),\n        (14 * 60 + 30, 15 * 60)\n    ]\n    \n    # Elizabeth: 9:00-9:30, 11:30-13:00, 13:30-14:00, 15:00-15:30, 16:00-17:00\n    elizabeth_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (11 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n    \n    # Tyler: 9:00-11:00, 12:00-12:30, 13:00-13:30, 15:30-16:00, 16:30-17:00\n    tyler_busy = [\n        (9 * 60, 11 * 60),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Edward: 9:00-9:30, 10:00-11:00, 11:30-14:00, 14:30-15:30, 16:00-17:00\n    edward_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 11 * 60),\n        (11 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n    \n    # Janice prefers not to meet after 13:00\n    janice_preference_end = 13 * 60\n    \n    # Combine all busy slots for all participants\n    all_busy = christine_busy + janice_busy + bobby_busy + elizabeth_busy + tyler_busy + edward_busy\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    # Check the time after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that fits the meeting duration and Janice's preference\n    for slot_start, slot_end in free_slots:\n        if slot_end > slot_start + meeting_duration:\n            actual_start = slot_start\n            actual_end = actual_start + meeting_duration\n            # Check if the slot is before Janice's preference end time\n            if actual_end <= janice_preference_end:\n                # Format the time as HH:MM:HH:MM\n                start_hh = actual_start // 60\n                start_mm = actual_start % 60\n                end_hh = actual_end // 60\n                end_mm = actual_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    # If no slot before Janice's preference, look for any slot (though problem states solution exists)\n    for slot_start, slot_end in free_slots:\n        if slot_end > slot_start + meeting_duration:\n            actual_start = slot_start\n            actual_end = actual_start + meeting_duration\n            start_hh = actual_start // 60\n            start_mm = actual_start % 60\n            end_hh = actual_end // 60\n            end_mm = actual_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_304"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Convert each participant's busy slots to minutes\n    ethan_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 12 * 60 + 30),\n        (13 * 60 + 30, 15 * 60)\n    ]\n    \n    beverly_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (13 * 60 + 30, 15 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    deborah_busy = [\n        (9 * 60, 11 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60 + 30),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n    \n    # Diane, Helen, and Arthur have no meetings, but Diane prefers before 15:30\n    diane_preference = 15 * 60 + 30\n    \n    # Combine all busy times and sort them\n    all_busy = ethan_busy + beverly_busy + deborah_busy\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Check each free slot for availability and duration (30 minutes)\n    meeting_duration = 30\n    valid_slots = []\n    \n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            slot_start = start\n            slot_end = start + meeting_duration\n            # Check if it fits within the slot and Diane's preference\n            while slot_end <= end:\n                if slot_end <= diane_preference:\n                    valid_slots.append((slot_start, slot_end))\n                slot_start += 1\n                slot_end += 1\n                # Early exit if slot is too small\n                if slot_end > end:\n                    break\n    \n    # Select the earliest valid slot\n    if valid_slots:\n        valid_slots.sort()\n        best_start, best_end = valid_slots[0]\n    else:\n        return None\n    \n    # Convert back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_time = minutes_to_time(best_start)\n    end_time = minutes_to_time(best_end)\n    \n    return f\"{start_time}:{end_time}\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_305"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time strings to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        person_busy = []\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            person_busy.append((start, end))\n        busy_intervals.append(person_busy)\n    \n    # Find all possible meeting start times in the work hours, checking every minute\n    for start in range(work_start, work_end - duration + 1):\n        end = start + duration\n        valid = True\n        # Check if this slot is free for all participants\n        for person_busy in busy_intervals:\n            person_free = True\n            for busy_start, busy_end in person_busy:\n                if not (end <= busy_start or start >= busy_end):\n                    person_free = False\n                    break\n            if not person_free:\n                valid = False\n                break\n        if valid:\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            start_time = minutes_to_time(start)\n            end_time = minutes_to_time(end)\n            return f\"{start_time}:{end_time}\"\n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"09:30:10:00\", \"11:00:12:30\", \"14:30:15:00\", \"16:30:17:00\"],  # Donald\n    [\"09:00:09:30\", \"10:30:11:30\", \"12:00:12:30\", \"13:00:14:00\"],  # Zachary\n    [],  # Kathryn\n    [\"09:00:09:30\", \"10:00:10:30\", \"11:30:12:00\", \"13:00:13:30\", \"14:00:17:00\"],  # Deborah\n    [\"09:00:09:30\", \"10:00:11:00\", \"11:30:12:30\", \"14:00:14:30\", \"15:00:16:00\"],  # Teresa\n    [\"09:30:10:30\", \"11:00:12:30\", \"13:00:14:00\", \"14:30:17:00\"],  # James\n]\n\n# Find a 30-minute meeting between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules=participants_schedules,\n                                 work_hours_start=\"09:00\",\n                                 work_hours_end=\"17:00\",\n                                 duration_minutes=30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_306"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time slots to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n\n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_intervals.append((start, end))\n\n    # Sort the busy intervals by start time\n    busy_intervals.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find available slots by looking at gaps between merged busy intervals\n    available_slots = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Find the first available slot that can fit the meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No available slot found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [],  # Ronald's calendar is wide open\n    [\"10:00:10:30\", \"12:00:12:30\"],  # Stephen\n    [\"11:00:11:30\", \"13:30:14:00\", \"15:30:16:00\", \"16:30:17:00\"],  # Brittany\n    [\"9:00:9:30\", \"10:00:10:30\", \"11:00:12:30\", \"13:00:15:00\", \"15:30:17:00\"],  # Dorothy\n    [\"9:30:10:30\", \"11:00:11:30\", \"12:00:12:30\", \"13:00:17:00\"],  # Rebecca\n    [\"9:00:9:30\", \"10:00:11:00\", \"11:30:12:00\", \"13:00:15:00\", \"15:30:16:30\"],  # Jordan\n]\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, \"9:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_307"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find all free intervals by merging busy intervals\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Find free intervals by checking gaps between merged busy intervals and work hours\n    free_intervals = []\n    previous_end = work_start\n    for start, end in merged_busy:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_intervals.append((previous_end, work_end))\n    \n    # Check each free interval for availability of all participants\n    for free_start, free_end in free_intervals:\n        if free_end - free_start >= meeting_duration:\n            # Check if this interval is free for all participants\n            valid = True\n            for schedule in participants_schedules:\n                participant_free = True\n                for busy in schedule:\n                    busy_start, busy_end = map(time_to_minutes, busy.split(' to '))\n                    # Check if free interval overlaps with any busy interval\n                    if not (free_end <= busy_start or free_start >= busy_end):\n                        participant_free = False\n                        break\n                if not participant_free:\n                    valid = False\n                    break\n            if valid:\n                meeting_start = minutes_to_time(free_start)\n                meeting_end = minutes_to_time(free_start + meeting_duration)\n                return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"10:00 to 10:30\", \"12:30 to 13:00\"],  # Adam\n    [\"12:30 to 13:00\", \"14:00 to 14:30\"],  # Frances\n    [\"10:30 to 11:00\", \"12:30 to 13:30\", \"16:00 to 16:30\"],  # Natalie\n    [\"10:30 to 11:00\", \"12:00 to 14:00\", \"14:30 to 16:00\"],  # Patrick\n    [\"9:00 to 10:00\", \"10:30 to 11:30\", \"12:00 to 13:00\", \"14:00 to 15:30\", \"16:00 to 16:30\"],  # Willie\n    [\"9:00 to 10:30\", \"11:00 to 16:30\"],  # Diana\n]\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 30  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration))\n```",
            "count": "calendar_scheduling_example_308"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Each participant's busy slots in minutes (start, end)\n    busy_slots = {\n        'Nicholas': [],\n        'Emma': [],\n        'Catherine': [(9*60, 9*60+30), (11*60+30, 12*60), (13*60+30, 14*60), (15*60+30, 16*60)],\n        'Steven': [(9*60, 9*60+30), (10*60, 16*60+30)],\n        'Adam': [(9*60, 10*60), (10*60+30, 13*60), (13*60+30, 14*60), (14*60+30, 16*60+30)],\n        'Lori': [(9*60, 11*60+30), (12*60+30, 13*60+30), (16*60, 16*60+30)],\n    }\n\n    # Collect all busy slots\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n\n    # Sort busy slots by start time\n    all_busy.sort()\n\n    # Merge overlapping or adjacent busy slots\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n    for start, end in merged_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_309"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Convert each participant's busy slots to minutes\n    helen_busy = [(12*60, 12*60+30), (15*60+30, 16*60)]\n    sophia_busy = [(11*60+30, 12*60), (13*60, 13*60+30), (15*60, 16*60)]\n    anthony_busy = [(9*60, 9*60+30), (10*60+30, 11*60+30), (12*60, 12*60+30), (15*60+30, 16*60+30)]\n    hannah_busy = [(9*60, 11*60), (12*60, 13*60+30), (14*60, 14*60+30), (15*60, 17*60)]\n    donna_busy = [(9*60, 9*60+30), (10*60, 10*60+30), (11*60, 13*60), (15*60, 17*60)]\n    brittany_busy = [(9*60+30, 10*60), (10*60+30, 12*60+30), (13*60, 14*60), (15*60+30, 16*60)]\n    \n    # Combine all busy slots\n    all_busy = helen_busy + sophia_busy + anthony_busy + hannah_busy + donna_busy + brittany_busy\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can accommodate 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert start time back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_time = start + meeting_duration\n            end_hh = end_time // 60\n            end_mm = end_time % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_310"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:30:12:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration_minutes):\n    # Convert work hours and schedules to minutes for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Initialize the list of busy intervals\n    busy_intervals = []\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        for start, end in schedule:\n            busy_intervals.append((start * 60, end * 60))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append(interval)\n    \n    # Find available slots by checking gaps between merged intervals and work hours\n    available_slots = []\n    previous_end = work_start\n    \n    for start, end in merged:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the time after the last busy interval until work_end\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Find the first available slot that can fit the meeting duration\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to hours and minutes\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time slot found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (9, 17)\n\n# Define meeting duration (30 minutes)\nduration_minutes = 30\n\n# Define participants' schedules in their local time (converted to 24-hour format)\nparticipants_schedules = [\n    [],  # Zachary - open\n    [],  # Douglas - open\n    [],  # Adam - open\n    [(9, 9.5), (10.5, 11.5), (12, 14), (14.5, 15), (15.5, 16.5)],  # Mark\n    [(9, 9.5), (10, 11.5), (12, 17)],  # Ashley\n    [(9.5, 10.5), (12, 12.5), (13.5, 14.5), (15, 15.5), (16, 17)]   # Jennifer\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_311"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time slots to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the busy slots for all participants\n    busy_slots = []\n    for schedule in participants_schedules:\n        person_busy = []\n        for slot in schedule:\n            start, end = map(time_to_minutes, slot.split(' to '))\n            person_busy.append((start, end))\n        busy_slots.append(person_busy)\n    \n    # Find all possible free slots for each participant\n    free_slots_per_person = []\n    for person_busy in busy_slots:\n        person_free = []\n        prev_end = work_start\n        for start, end in sorted(person_busy, key=lambda x: x[0]):\n            if start > prev_end:\n                person_free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            person_free.append((prev_end, work_end))\n        free_slots_per_person.append(person_free)\n    \n    # Find intersection of all free slots\n    common_free_slots = free_slots_per_person[0]\n    for person_free in free_slots_per_person[1:]:\n        new_common = []\n        i = j = 0\n        while i < len(common_free_slots) and j < len(person_free):\n            slot1_start, slot1_end = common_free_slots[i]\n            slot2_start, slot2_end = person_free[j]\n            \n            overlap_start = max(slot1_start, slot2_start)\n            overlap_end = min(slot1_end, slot2_end)\n            \n            if overlap_start < overlap_end:\n                new_common.append((overlap_start, overlap_end))\n            \n            if slot1_end < slot2_end:\n                i += 1\n            else:\n                j += 1\n        common_free_slots = new_common\n    \n    # Find the first slot that can fit the meeting duration\n    duration = duration_minutes\n    for slot_start, slot_end in common_free_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"10:30 to 11:30\", \"12:00 to 12:30\", \"15:30 to 16:00\"],  # Samantha\n    [\"14:00 to 14:30\", \"15:30 to 16:00\"],                   # Jerry\n    [],                                                      # Walter\n    [\"9:30 to 11:30\", \"12:00 to 12:30\", \"13:00 to 13:30\", \"14:30 to 15:00\", \"16:30 to 17:00\"],  # Sara\n    [\"9:00 to 13:00\", \"14:00 to 15:00\", \"16:00 to 17:00\"],  # Kenneth\n    [\"9:30 to 10:00\", \"10:30 to 11:30\", \"12:00 to 12:30\", \"13:00 to 13:30\", \"14:00 to 16:00\", \"16:30 to 17:00\"],  # Danielle\n]\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, \"9:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_312"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for schedule in participants_schedules:\n        busy_intervals = []\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n        all_busy_intervals.append(busy_intervals)\n    \n    # Find all possible meeting start times in the work hours\n    possible_starts = []\n    current_time = work_start\n    \n    while current_time + duration <= work_end:\n        valid = True\n        for busy_intervals in all_busy_intervals:\n            for start, end in busy_intervals:\n                if not (current_time + duration <= start or current_time >= end):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            possible_starts.append(current_time)\n        current_time += 15  # Check every 15 minutes for efficiency\n    \n    if not possible_starts:\n        return None\n    \n    # Select the earliest possible start time\n    meeting_start = possible_starts[0]\n    meeting_end = meeting_start + duration\n    \n    return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"10:00 to 10:30\", \"15:30 to 16:00\"],  # Carl\n    [\"09:30 to 10:30\", \"12:00 to 12:30\", \"14:00 to 15:30\"],  # Shirley\n    [\"09:00 to 10:30\", \"11:30 to 12:00\"],  # Timothy\n    [\"09:00 to 11:30\", \"12:00 to 13:00\", \"13:30 to 14:00\", \"14:30 to 16:30\"],  # Marilyn\n    [\"09:00 to 10:30\", \"13:00 to 15:00\", \"15:30 to 16:00\"],  # Martha\n    [\"09:00 to 11:00\", \"12:00 to 15:00\", \"15:30 to 16:30\"],  # Samantha\n]\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, \"09:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_313"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes, work_start, work_end):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start_min = time_to_minutes(busy[0])\n            end_min = time_to_minutes(busy[1])\n            all_busy.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    previous_end = work_start_min\n    \n    for start, end in merged_busy:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the time after the last busy interval until work end\n    if previous_end < work_end_min:\n        available_slots.append((previous_end, work_end_min))\n    \n    # Find the first available slot that can fit the meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules in HH:MM format\nparticipants_schedules = [\n    [],  # Lori\n    [],  # Kelly\n    [(\"10:00\", \"10:30\"), (\"11:30\", \"12:00\"), (\"15:30\", \"16:00\"), (\"16:30\", \"17:00\")],  # Tyler\n    [(\"09:00\", \"12:00\"), (\"12:30\", \"13:00\"), (\"13:30\", \"14:30\"), (\"15:00\", \"15:30\"), (\"16:00\", \"17:00\")],  # Julie\n    [(\"09:00\", \"13:00\"), (\"13:30\", \"15:30\"), (\"16:00\", \"17:00\")],  # Andrea\n    [(\"09:00\", \"12:30\"), (\"13:30\", \"17:00\")],  # Gabriel\n]\n\n# Meeting duration in minutes\nduration_minutes = 30\n\n# Work hours\nwork_start = \"09:00\"\nwork_end = \"17:00\"\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, duration_minutes, work_start, work_end))\n```",
            "count": "calendar_scheduling_example_314"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_start=\"09:00\", work_end=\"17:00\"):\n    # Convert time strings to minutes since 9:00 for easier calculation\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m - 9 * 60  # Subtract 9:00 to start from 0\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Initialize a list to mark busy intervals\n    busy_intervals = []\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_end = max(end, last_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find the first available slot of at least duration_minutes\n    prev_end = work_start_min\n    for start, end in merged:\n        if start - prev_end >= duration_minutes:\n            # Found a slot\n            meeting_start = prev_end\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                total_h = 9 + minutes // 60\n                total_m = minutes % 60\n                return f\"{total_h:02d}:{total_m:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n        prev_end = max(prev_end, end)\n    \n    # Check after the last busy interval\n    if work_end_min - prev_end >= duration_minutes:\n        meeting_start = prev_end\n        meeting_end = meeting_start + duration_minutes\n        def minutes_to_time(minutes):\n            total_h = 9 + minutes // 60\n            total_m = minutes % 60\n            return f\"{total_h:02d}:{total_m:02d}\"\n        return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Gloria is free\n    [\"09:00 to 10:00\"],  # Roy\n    [\"09:00 to 09:30\", \"11:00 to 12:00\", \"16:30 to 17:00\"],  # Kimberly\n    [\"09:00 to 09:30\", \"10:00 to 11:00\", \"13:00 to 13:30\", \"14:00 to 15:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"],  # Robert\n    [\"09:00 to 09:30\", \"10:00 to 11:00\", \"11:30 to 12:30\", \"13:00 to 14:00\", \"14:30 to 15:00\"],  # Jesse\n    [\"09:00 to 12:00\", \"13:00 to 17:00\"],  # Sophia\n]\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules))\n```",
            "count": "calendar_scheduling_example_315"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_start=\"09:00\", work_end=\"17:00\"):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Initialize the available slots as the entire work day\n    available_slots = [(work_start_min, work_end_min)]\n    \n    # Process each participant's busy slots\n    for person, busy_slots in participants_schedules.items():\n        new_available_slots = []\n        for slot_start, slot_end in available_slots:\n            current_start = slot_start\n            # Sort busy slots by start time for this person\n            sorted_busy = sorted(busy_slots, key=lambda x: x[0])\n            for busy_start, busy_end in sorted_busy:\n                if busy_start >= slot_end:\n                    break\n                if busy_end <= current_start:\n                    continue\n                if busy_start > current_start:\n                    new_available_slots.append((current_start, busy_start))\n                current_start = max(current_start, busy_end)\n            if current_start < slot_end:\n                new_available_slots.append((current_start, slot_end))\n        available_slots = new_available_slots\n        if not available_slots:\n            return None  # No available slot\n    \n    # Find the first available slot that fits the duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    return None\n\n# Define the participants' busy slots in minutes since midnight\nparticipants_schedules = {\n    \"Brittany\": [(570, 600), (630, 660), (690, 720), (780, 810), (960, 1020)],\n    \"Gloria\": [(540, 570), (600, 630), (780, 810), (900, 930)],\n    \"Lisa\": [(750, 780), (810, 840)],\n    \"Paul\": [(540, 570), (660, 780), (810, 840), (900, 930), (990, 1020)],\n    \"Justin\": [(570, 780), (810, 840), (900, 1020)],\n    \"Diana\": [(540, 630), (660, 690), (720, 810), (840, 870), (900, 930), (990, 1020)],\n}\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_316"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    start, end = work_hours\n    # Convert time strings to minutes for easier calculation\n    start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n    end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n    \n    # Initialize the free slots for all participants\n    free_slots = []\n    for participant in participants_schedules:\n        busy_slots = participants_schedules[participant]\n        participant_free = []\n        prev_end = start_min\n        \n        for slot in sorted(busy_slots, key=lambda x: x[0]):\n            slot_start = slot[0][0] * 60 + slot[0][1]\n            slot_end = slot[1][0] * 60 + slot[1][1]\n            if prev_end < slot_start:\n                participant_free.append((prev_end, slot_start))\n            prev_end = max(prev_end, slot_end)\n        \n        if prev_end < end_min:\n            participant_free.append((prev_end, end_min))\n        free_slots.append(participant_free)\n    \n    # Find common free slots\n    common_free = free_slots[0]\n    for participant in free_slots[1:]:\n        temp_common = []\n        i = j = 0\n        while i < len(common_free) and j < len(participant):\n            start1, end1 = common_free[i]\n            start2, end2 = participant[j]\n            \n            overlap_start = max(start1, start2)\n            overlap_end = min(end1, end2)\n            \n            if overlap_start < overlap_end:\n                temp_common.append((overlap_start, overlap_end))\n            \n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free = temp_common\n    \n    # Find the first slot that can fit the duration\n    for slot in common_free:\n        if slot[1] - slot[0] >= duration:\n            meeting_start = slot[0]\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return None\n\n# Define the participants' schedules\nparticipants = {\n    \"Virginia\": [],\n    \"Kevin\": [\n        ((14, 30), (15, 00)),\n        ((15, 30), (16, 00))\n    ],\n    \"Kimberly\": [\n        ((9, 30), (10, 30)),\n        ((11, 30), (12, 00)),\n        ((12, 30), (13, 00)),\n        ((13, 30), (14, 00)),\n        ((15, 00), (15, 30))\n    ],\n    \"Lawrence\": [\n        ((10, 00), (10, 30)),\n        ((11, 00), (11, 30)),\n        ((12, 00), (12, 30)),\n        ((13, 00), (14, 00)),\n        ((14, 30), (15, 30)),\n        ((16, 00), (16, 30))\n    ],\n    \"Donna\": [\n        ((10, 00), (11, 00)),\n        ((12, 00), (15, 00)),\n        ((15, 30), (16, 00)),\n        ((16, 30), (17, 00))\n    ],\n    \"Joe\": [\n        ((9, 30), (10, 00)),\n        ((11, 30), (12, 30)),\n        ((13, 00), (13, 30)),\n        ((14, 30), (16, 00)),\n        ((16, 30), (17, 00))\n    ]\n}\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_hours = (\"9:00\", \"17:00\")\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants, duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_317"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    busy_slots = {\n        'Shirley': [(11 * 60, 12 * 60)],\n        'Carl': [],\n        'Bradley': [],\n        'Kevin': [(9 * 60, 12 * 60 + 30), (13 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Walter': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (11 * 60, 12 * 60),\n                   (12 * 60 + 30, 13 * 60), (14 * 60 + 30, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n        'Anna': [(9 * 60, 10 * 60), (11 * 60, 13 * 60), (14 * 60, 15 * 60)]\n    }\n\n    # Combine all busy slots from all participants\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n\n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for slot in free_slots:\n        start, end = slot\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_318"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:30:12:00}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_start, work_end):\n    # Convert time strings to minutes since 9:00 (work_start)\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m - work_start_min\n\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    total_duration = work_end_min - work_start_min\n    timeline = [0] * total_duration  # 0 means free, increment for each busy participant\n\n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            start = max(time_to_minutes(busy_start), 0)\n            end = min(time_to_minutes(busy_end), total_duration)\n            for i in range(start, end):\n                timeline[i] += 1\n\n    required_free = len(participants_schedules)\n    duration_slots = duration * 2  # assuming 30-minute slots for half-hour\n\n    current_free = 0\n    for i in range(total_duration):\n        if timeline[i] == 0:\n            current_free += 1\n        else:\n            current_free = 0\n        if current_free >= duration_slots:\n            start_time = i - duration_slots + 1\n            end_time = i + 1\n            # Convert back to HH:MM format\n            start_h = (work_start_min + start_time) // 60\n            start_m = (work_start_min + start_time) % 60\n            end_h = (work_start_min + end_time) // 60\n            end_m = (work_start_min + end_time) % 60\n            return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    return \"No suitable time found\"\n\n# Define participants' schedules in HH:MM format\nparticipants_schedules = [\n    [(\"14:30\", \"15:00\"), (\"16:00\", \"16:30\")],  # Natalie\n    [],                                         # Evelyn\n    [],                                         # Andrea\n    [(\"09:00\", \"10:00\"), (\"10:30\", \"11:30\"), (\"12:30\", \"13:30\"), (\"14:30\", \"15:30\")],  # Kimberly\n    [(\"09:00\", \"10:00\"), (\"11:00\", \"11:30\"), (\"12:00\", \"14:00\"), (\"14:30\", \"16:00\")],  # Dennis\n    [(\"09:00\", \"11:00\"), (\"12:00\", \"17:00\")]   # Larry\n]\n\nduration = 30  # minutes\nwork_start = \"09:00\"\nwork_end = \"17:00\"\n\nprint(find_meeting_time(participants_schedules, duration, work_start, work_end))\n```",
            "count": "calendar_scheduling_example_319"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each participant's busy slots to minutes\n    diane_busy = [(9*60, 9*60 + 30), (12*60 + 30, 13*60)]\n    christian_busy = [(11*60 + 30, 12*60), (12*60 + 30, 13*60)]\n    jeffrey_busy = []\n    vincent_busy = [(9*60 + 30, 10*60 + 30), (11*60 + 30, 13*60 + 30), (14*60 + 30, 15*60), (16*60 + 30, 17*60)]\n    ethan_busy = [(9*60, 11*60), (11*60 + 30, 12*60), (12*60 + 30, 13*60), (13*60 + 30, 14*60 + 30), (15*60, 17*60)]\n    christine_busy = [(9*60, 11*60), (11*60 + 30, 16*60 + 30)]\n    \n    # Combine all busy slots\n    all_busy = diane_busy + christian_busy + jeffrey_busy + vincent_busy + ethan_busy + christine_busy\n    \n    # Generate free slots by inverting busy slots\n    free_slots = []\n    previous_end = work_start\n    for start, end in sorted(all_busy):\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can accommodate 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_320"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define each participant's busy times in minutes (start, end)\n    grace_busy = [(10*60 + 30, 11*60 + 30), (12*60, 12*60 + 30), (15*60, 15*60 + 30)]\n    ralph_busy = [(11*60, 11*60 + 30), (16*60, 16*60 + 30)]\n    harold_busy = []\n    kayla_busy = [(10*60, 10*60 + 30), (11*60, 11*60 + 30), (12*60, 12*60 + 30), (13*60 + 30, 17*60)]\n    andrea_busy = [(9*60, 10*60 + 30), (11*60, 13*60), (13*60 + 30, 17*60)]\n    maria_busy = [(9*60, 10*60 + 30), (11*60, 13*60), (15*60, 16*60 + 30)]\n    \n    # Combine all busy times\n    all_busy = grace_busy + ralph_busy + harold_busy + kayla_busy + andrea_busy + maria_busy\n    \n    # Sort busy times by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = work_start\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    # Check the slot after the last busy time\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can accommodate 30 minutes\n    meeting_duration = 30\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Convert minutes back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = (slot_start + meeting_duration) // 60\n            end_mm = (slot_start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_321"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Convert each participant's busy slots to minutes\n    busy_slots = {\n        'Kathryn': [(9.5 * 60, 10 * 60), (12.5 * 60, 14 * 60)],\n        'Jessica': [],\n        'Ruth': [(12.5 * 60, 13 * 60), (14.5 * 60, 15 * 60)],\n        'Matthew': [(9 * 60, 10 * 60), (11.5 * 60, 13 * 60), (13.5 * 60, 15 * 60), (15.5 * 60, 16 * 60), (16.5 * 60, 17 * 60)],\n        'Jennifer': [(9 * 60, 9.5 * 60), (10 * 60, 10.5 * 60), (11.5 * 60, 12 * 60), (12.5 * 60, 13 * 60), (15 * 60, 17 * 60)],\n        'Alice': [(9 * 60, 10.5 * 60), (12 * 60, 12.5 * 60), (15 * 60, 17 * 60)],\n    }\n\n    # Combine all busy slots\n    all_busy = []\n    for person in busy_slots:\n        for start, end in busy_slots[person]:\n            all_busy.append((start, end))\n    \n    # Sort busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check each free slot for availability for all participants\n    meeting_duration = 60  # 1 hour\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Check if all participants are free during this slot\n            valid = True\n            for person in busy_slots:\n                person_busy = False\n                for busy_start, busy_end in busy_slots[person]:\n                    if not (slot_start >= busy_end or slot_start + meeting_duration <= busy_start):\n                        person_busy = True\n                        break\n                if person_busy:\n                    valid = False\n                    break\n            if valid:\n                # Convert minutes back to HH:MM format\n                start_hh = int(slot_start // 60)\n                start_mm = int(slot_start % 60)\n                end_hh = int((slot_start + meeting_duration) // 60)\n                end_mm = int((slot_start + meeting_duration) % 60)\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_322"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:00:16:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration_min = duration * 60\n\n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(':'))\n            busy_intervals.append((start, end))\n\n    # Sort intervals by start time\n    busy_intervals.sort()\n\n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Find the first slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No available time slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"14:00:14:30\", \"15:30:16:00\"],  # Ralph\n    [],                              # Kenneth\n    [\"09:00:10:30\", \"13:00:13:30\", \"15:00:15:30\", \"16:30:17:00\"],  # Diane\n    [\"10:00:11:00\", \"12:00:15:00\", \"15:30:16:00\", \"16:30:17:00\"],  # Kayla\n    [\"09:30:10:00\", \"10:30:11:30\", \"12:30:14:30\", \"16:30:17:00\"],  # Bruce\n    [\"10:00:11:00\", \"11:30:12:00\", \"12:30:13:30\", \"14:30:15:00\", \"15:30:16:00\", \"16:30:17:00\"]  # Jesse\n]\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, 30, \"09:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_323"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since midnight\n    busy_slots = {\n        'Jacob': [(9*60, 9*60+30), (10*60, 11*60), (12*60, 12*60+30), (13*60+30, 14*60), (16*60, 16*60+30)],\n        'Nancy': [(11*60, 11*60+30), (14*60+30, 16*60)],\n        'Lori': [(9*60, 9*60+30), (11*60, 11*60+30), (12*60, 12*60+30), (13*60+30, 14*60)],\n        'Ann': [(10*60, 13*60), (14*60+30, 16*60+30)],\n        'Pamela': [(9*60, 9*60+30), (10*60+30, 11*60+30), (12*60, 12*60+30), (13*60+30, 15*60), (15*60+30, 16*60)],\n        'Anna': [(9*60+30, 11*60+30), (12*60, 13*60), (13*60+30, 14*60+30), (15*60, 17*60)],\n    }\n\n    # Collect all busy slots\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n\n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check the slot after the last busy slot until work_end\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Now, find the earliest free slot that fits the meeting duration and is free for everyone\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Check if this slot is free for everyone\n            valid = True\n            for person in busy_slots:\n                person_busy = busy_slots[person]\n                for busy_start, busy_end in person_busy:\n                    if not (slot_start >= busy_end or slot_start + meeting_duration <= busy_start):\n                        # Overlap found, slot is not free for this person\n                        valid = False\n                        break\n                if not valid:\n                    break\n            if valid:\n                # Convert start time back to HH:MM format\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_time = slot_start + meeting_duration\n                end_hh = end_time // 60\n                end_mm = end_time % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_324"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy times in minutes (start, end)\n    busy_times = {\n        'Jose': [(11 * 60, 11 * 60 + 30), (12 * 60 + 30, 13 * 60)],\n        'Keith': [(14 * 60, 14 * 60 + 30), (15 * 60, 15 * 60 + 30)],\n        'Logan': [(9 * 60, 10 * 60), (12 * 60, 12 * 60 + 30), (15 * 60, 15 * 60 + 30)],\n        'Megan': [(9 * 60, 10 * 60 + 30), (11 * 60, 12 * 60), (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 16 * 60 + 30)],\n        'Gary': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (11 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 16 * 60 + 30)],\n        'Bobby': [(11 * 60, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (13 * 60, 16 * 60)],\n    }\n    \n    # Jose's constraint: not after 15:30\n    jose_constraint = 15 * 60 + 30\n    \n    # Collect all busy intervals\n    all_busy = []\n    for person in busy_times:\n        for start, end in busy_times[person]:\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals\n    all_busy.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Filter free intervals that are at least 30 minutes and meet Jose's constraint\n    possible_slots = []\n    for start, end in free_intervals:\n        if end - start >= 30 and end <= jose_constraint:\n            possible_slots.append((start, end))\n    \n    # Find the earliest possible slot\n    if possible_slots:\n        earliest_slot = possible_slots[0]\n        meeting_start = earliest_slot[0]\n        meeting_end = meeting_start + 30\n        # Format the output\n        start_hour = meeting_start // 60\n        start_min = meeting_start % 60\n        end_hour = meeting_end // 60\n        end_min = meeting_end % 60\n        return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n    else:\n        return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_325"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_start=9*60, work_end=17*60):\n    # Convert all schedules to minutes since midnight for easier comparison\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start_h, start_m = map(int, interval[0].split(':'))\n            end_h, end_m = map(int, interval[1].split(':'))\n            start = start_h * 60 + start_m\n            end = end_h * 60 + end_m\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between merged intervals\n    available_slots = []\n    previous_end = work_start\n    for start, end in merged:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            start_h = meeting_start // 60\n            start_m = meeting_start % 60\n            end_h = meeting_end // 60\n            end_m = meeting_end % 60\n            return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [(\"09:30\", \"10:00\"), (\"10:30\", \"11:30\"), (\"12:30\", \"13:00\"), (\"14:00\", \"14:30\"), (\"16:00\", \"16:30\")],  # Jason\n    [(\"09:00\", \"09:30\"), (\"10:00\", \"11:00\"), (\"15:30\", \"17:00\")],  # Anthony\n    [(\"11:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"15:00\", \"15:30\"), (\"16:00\", \"16:30\")],  # Joan\n    [(\"09:00\", \"11:00\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"13:30\", \"15:30\"), (\"16:00\", \"17:00\")],  # Elizabeth\n    [(\"09:00\", \"10:00\"), (\"11:00\", \"11:30\"), (\"12:30\", \"13:00\"), (\"13:30\", \"16:30\")],  # Ryan\n    [(\"09:30\", \"10:30\"), (\"11:00\", \"11:30\"), (\"12:00\", \"13:00\"), (\"13:30\", \"14:00\"), (\"14:30\", \"16:00\"), (\"16:30\", \"17:00\")]  # Jeffrey\n]\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules))\n```",
            "count": "calendar_scheduling_example_326"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours=('09:00', '17:00')):\n    # Convert work hours to minutes since midnight\n    start_work, end_work = work_hours\n    work_start = int(start_work.split(':')[0]) * 60 + int(start_work.split(':')[1])\n    work_end = int(end_work.split(':')[0]) * 60 + int(end_work.split(':')[1])\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    busy_intervals = []\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        for block in schedule:\n            start, end = block.split(' to ')\n            start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n            end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n            busy_intervals.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for a slot that can fit the meeting\n    for start, end in free_intervals:\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            # Format the time as HH:MM:HH:MM\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"11:00 to 11:30\", \"12:00 to 12:30\", \"14:00 to 16:00\"],  # Cynthia\n    [\"10:00 to 11:30\", \"12:30 to 13:00\", \"14:00 to 14:30\", \"15:30 to 16:00\"],  # Megan\n    [],  # Christopher\n    [\"09:00 to 11:30\", \"12:00 to 13:00\", \"13:30 to 17:00\"],  # Philip\n    [\"09:00 to 10:30\", \"11:00 to 11:30\", \"12:30 to 15:30\", \"16:00 to 17:00\"],  # Ryan\n    [\"09:30 to 10:30\", \"11:00 to 11:30\", \"12:00 to 13:00\", \"14:00 to 14:30\", \"15:00 to 17:00\"],  # Lauren\n]\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules))\n```",
            "count": "calendar_scheduling_example_327"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define each participant's busy times in minutes (start, end)\n    busy_times = {\n        'Diana': [(13 * 60 + 30, 14 * 60), (16 * 60 + 30, 17 * 60)],\n        'Timothy': [(9 * 60, 9 * 60 + 30), (12 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30)],\n        'Patrick': [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 11 * 60), (11 * 60 + 30, 12 * 60 + 30), (14 * 60 + 30, 15 * 60), (16 * 60, 16 * 60 + 30)],\n        'Janet': [(9 * 60 + 30, 10 * 60 + 30), (11 * 60, 12 * 60), (13 * 60, 13 * 60 + 30), (14 * 60, 16 * 60 + 30)],\n        'Megan': [(9 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60, 17 * 60)],\n        'Evelyn': [(9 * 60, 10 * 60 + 30), (11 * 60, 12 * 60 + 30), (13 * 60, 17 * 60)],\n    }\n\n    # Combine all busy times and sort them\n    all_busy = []\n    for person in busy_times:\n        all_busy.extend(busy_times[person])\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check the slot after the last busy time\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that is at least 30 minutes long\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = (start + meeting_duration) // 60\n            end_mm = (start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_328"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_work, end_work = work_hours\n    # Convert work hours to minutes\n    start_min = start_work[0] * 60 + start_work[1]\n    end_min = end_work[0] * 60 + end_work[1]\n    \n    # Initialize a list to track busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for block in schedule:\n            start_block = block[0][0] * 60 + block[0][1]\n            end_block = block[1][0] * 60 + block[1][1]\n            busy_intervals.append((start_block, end_block))\n    \n    # Sort all busy intervals\n    busy_intervals.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = start_min\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < end_min:\n        free_intervals.append((prev_end, end_min))\n    \n    # Check for a free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = (start + duration) // 60\n            end_mm = (start + duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules in HH:MM format converted to tuples of (HH, MM)\nparticipants_schedules = [\n    [((11, 0), (11, 30)), ((16, 0), (16, 30))],  # Anna\n    [((9, 0), (9, 30)), ((15, 30), (16, 0))],     # Samuel\n    [],                                            # Joshua\n    [((9, 0), (10, 30)), ((12, 30), (14, 0)), ((16, 0), (17, 0))],  # Eugene\n    [((9, 0), (12, 0)), ((12, 30), (15, 0)), ((15, 30), (17, 0))],  # Debra\n    [((9, 30), (10, 0)), ((10, 30), (11, 30)), ((12, 30), (13, 30)), ((14, 30), (17, 0))]  # Carolyn\n]\n\nwork_hours = ((9, 0), (17, 0))  # 9:00 to 17:00\nduration = 30  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_329"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, duration_minutes=30, work_start=9 * 60, work_end=17 * 60):\n    # Convert all busy times to minutes since start of day and flatten\n    busy_slots = []\n    for person in participants_busy:\n        for slot in person:\n            start_h, start_m = map(int, slot.split(' to ')[0].split(':'))\n            end_h, end_m = map(int, slot.split(' to ')[1].split(':'))\n            busy_slots.append((start_h * 60 + start_m, end_h * 60 + end_m))\n    \n    # Sort all busy slots by start time\n    busy_slots.sort()\n    \n    # Merge overlapping or adjacent busy slots\n    merged = []\n    for start, end in busy_slots:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find free slots between work hours and busy slots\n    free_slots = []\n    previous_end = work_start\n    for start, end in merged:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            start_h = meeting_start // 60\n            start_m = meeting_start % 60\n            end_h = meeting_end // 60\n            end_m = meeting_end % 60\n            return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    return \"No suitable time found\"\n\n# Define participants' busy times\nparticipants_busy = [\n    [\"10:30 to 11:00\", \"12:00 to 12:30\", \"14:00 to 15:00\"],  # Terry\n    [\"9:30 to 10:30\", \"11:30 to 12:00\", \"14:00 to 14:30\"],    # Gloria\n    [],                                                       # Julie\n    [\"9:00 to 12:00\", \"12:30 to 13:00\", \"14:00 to 14:30\"],    # Albert\n    [\"9:00 to 10:00\", \"10:30 to 12:00\", \"12:30 to 13:00\", \"13:30 to 16:00\", \"16:30 to 17:00\"],  # Logan\n    [\"9:30 to 11:00\", \"11:30 to 13:00\", \"14:30 to 15:30\"],    # Alexander\n]\n\n# Find the earliest meeting time\nprint(find_meeting_time(participants_busy))\n```",
            "count": "calendar_scheduling_example_330"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    # Parse work hours\n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n\n    # Initialize a list to track busy intervals for all participants\n    all_busy = []\n\n    # Process each participant's schedule\n    for schedule in participants_schedules.values():\n        for busy in schedule:\n            start, end = busy.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            all_busy.append((start_min, end_min))\n\n    # Sort all busy intervals by start time\n    all_busy.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find available slots\n    available = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n\n    # Find the first available slot that can fit the meeting\n    for slot in available:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No available slot found\"\n\n# Define participants and their schedules\nparticipants_schedules = {\n    \"Evelyn\": [],\n    \"Patrick\": [\"12:00 to 13:00\", \"15:00 to 15:30\", \"16:30 to 17:00\"],\n    \"Anthony\": [\"9:30 to 10:30\", \"12:00 to 13:00\", \"13:30 to 14:00\", \"16:30 to 17:00\"],\n    \"Aaron\": [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:30 to 12:00\", \"12:30 to 13:30\", \"14:30 to 15:30\", \"16:30 to 17:00\"],\n    \"Abigail\": [\"9:00 to 11:00\", \"11:30 to 12:00\", \"12:30 to 14:00\", \"14:30 to 16:00\", \"16:30 to 17:00\"],\n    \"Vincent\": [\"9:00 to 10:30\", \"11:30 to 12:00\", \"14:00 to 17:00\"],\n}\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_hours = \"9:00 to 17:00\"\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, duration, work_hours))\n```",
            "count": "calendar_scheduling_example_331"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:00:14:30}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 (9:00)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    start_work_min = time_to_minutes(start_work)\n    end_work_min = time_to_minutes(end_work)\n    \n    # Initialize a list to track busy intervals for all participants\n    all_busy = []\n    for busy_slots in participents_busy.values():\n        for slot in busy_slots:\n            start, end = slot.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            all_busy.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = start_work_min\n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < end_work_min:\n        free_intervals.append((prev_end, end_work_min))\n    \n    # Check each free interval for availability of duration\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' busy slots\nparticipants_busy = {\n    \"Pamela\": [\"9:30 to 10:00\", \"15:00 to 15:30\", \"16:00 to 17:00\"],\n    \"Sandra\": [],\n    \"Helen\": [],\n    \"Zachary\": [\"9:00 to 11:00\", \"11:30 to 12:00\", \"12:30 to 13:30\", \"15:30 to 17:00\"],\n    \"Janice\": [\"9:30 to 14:00\", \"14:30 to 17:00\"],\n    \"Paul\": [\"9:30 to 11:30\", \"12:00 to 12:30\", \"13:00 to 13:30\", \"15:00 to 17:00\"]\n}\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nmeeting_duration = 30  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, work_hours, meeting_duration))\n```",
            "count": "calendar_scheduling_example_332"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:00:16:30}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time slots to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's busy slots to find common free time\n    for person, busy_slots in participents_schedules.items():\n        person_busy = []\n        for slot in busy_slots:\n            start, end = map(time_to_minutes, slot.split(':'))\n            person_busy.append((start, end))\n        # Sort the busy slots by start time\n        person_busy.sort()\n        \n        # Merge overlapping or adjacent busy slots\n        merged_busy = []\n        for start, end in person_busy:\n            if not merged_busy:\n                merged_busy.append((start, end))\n            else:\n                last_start, last_end = merged_busy[-1]\n                if start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = last_start\n                    new_end = max(last_end, end)\n                    merged_busy[-1] = (new_start, new_end)\n                else:\n                    merged_busy.append((start, end))\n        \n        # Calculate the person's free slots within work hours\n        person_free = []\n        prev_end = work_start\n        for start, end in merged_busy:\n            if start > prev_end:\n                person_free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            person_free.append((prev_end, work_end))\n        \n        # Intersect the person's free slots with the current common free slots\n        new_free_slots = []\n        i = j = 0\n        while i < len(free_slots) and j < len(person_free):\n            slot_start, slot_end = free_slots[i]\n            person_start, person_end = person_free[j]\n            \n            # Find the overlap between the current common slot and person's slot\n            overlap_start = max(slot_start, person_start)\n            overlap_end = min(slot_end, person_end)\n            \n            if overlap_start < overlap_end:\n                new_free_slots.append((overlap_start, overlap_end))\n            \n            # Move the pointer which ends first\n            if slot_end < person_end:\n                i += 1\n            else:\n                j += 1\n        \n        free_slots = new_free_slots\n        if not free_slots:\n            return None  # No common free time\n    \n    # Check if any remaining free slot can fit the meeting\n    for start, end in free_slots:\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = start + duration_minutes\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return None\n\n# Define the participants' schedules\nparticipants_schedules = {\n    \"Debra\": [\"15:00:16:00\"],\n    \"Sean\": [\"9:00:9:30\", \"12:00:12:30\", \"13:00:14:00\", \"14:30:15:00\", \"16:30:17:00\"],\n    \"Randy\": [\"11:00:12:00\", \"13:00:14:00\", \"15:00:15:30\", \"16:30:17:00\"],\n    \"Gary\": [\"9:30:11:00\", \"11:30:13:00\", \"14:00:15:30\", \"16:30:17:00\"],\n    \"Joseph\": [\"9:00:9:30\", \"10:30:11:00\", \"11:30:12:00\", \"12:30:13:00\", \"13:30:14:00\", \"15:00:16:00\", \"16:30:17:00\"],\n    \"Christina\": [\"9:00:10:00\", \"10:30:12:30\", \"14:00:16:00\"],\n}\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, \"9:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_333"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:30:10:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the free slots for the day (work hours)\n    free_slots = [{'start': work_start, 'end': work_end}]\n    \n    # Process each participant's schedule to find common free slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_slots.append({'start': start, 'end': end})\n        \n        # Merge overlapping or adjacent busy slots\n        busy_slots.sort(key=lambda x: x['start'])\n        merged_busy = []\n        for slot in busy_slots:\n            if not merged_busy:\n                merged_busy.append(slot)\n            else:\n                last = merged_busy[-1]\n                if slot['start'] <= last['end']:\n                    last['end'] = max(last['end'], slot['end'])\n                else:\n                    merged_busy.append(slot)\n        \n        # Subtract busy slots from current free slots\n        new_free_slots = []\n        for free in free_slots:\n            current_start = free['start']\n            for busy in merged_busy:\n                if busy['start'] > current_start:\n                    new_free_slots.append({'start': current_start, 'end': busy['start']})\n                current_start = max(current_start, busy['end'])\n            if current_start < free['end']:\n                new_free_slots.append({'start': current_start, 'end': free['end']})\n        free_slots = new_free_slots\n    \n    # Find the earliest slot that fits the duration\n    for slot in free_slots:\n        if slot['end'] - slot['start'] >= duration:\n            return slot['start'], slot['start'] + duration\n    \n    return None\n\n# Participants' schedules in HH:MM format\nparticipants_schedules = [\n    [],  # Albert is free all day\n    [\"9:00:9:30\", \"10:00:11:00\", \"15:30:16:00\"],  # Laura\n    [\"10:00:11:00\", \"13:00:13:30\", \"16:00:16:30\"],  # Elijah\n    [\"9:00:9:30\", \"10:00:11:30\", \"12:30:13:00\", \"13:30:14:00\", \"16:00:17:00\"],  # Kenneth\n    [\"9:00:9:30\", \"10:00:11:00\", \"12:30:14:30\", \"15:00:16:00\", \"16:30:17:00\"],  # Adam\n    [\"10:00:11:30\", \"13:30:15:00\", \"16:00:17:00\"],  # Heather\n]\n\n# Meeting duration in minutes\nduration = 30\n\n# Work hours\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end)\n\n# Convert minutes back to HH:MM format\ndef minutes_to_time(minutes):\n    hh = minutes // 60\n    mm = minutes % 60\n    return f\"{hh:02d}:{mm:02d}\"\n\nif meeting_time:\n    start_time = minutes_to_time(meeting_time[0])\n    end_time = minutes_to_time(meeting_time[1])\n    print(f\"{start_time}:{end_time}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_334"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Now, find a free interval that is common to all participants\n    # To do this, we need to find the intersection of all participants' free times\n    # But since we've combined all busy times, the free_intervals already represent when at least one person is free\n    # So we need to find when all are free, i.e., when no one is busy\n    \n    # Instead, a better approach is to find the times when no one is busy\n    # We can collect all busy intervals and merge them, then find the gaps\n    \n    # Merge all busy intervals\n    merged_busy = []\n    for start, end in busy_intervals:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Now find the free intervals between merged busy times and work hours\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in merged_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"9:00 to 9:30\", \"10:30 to 11:00\", \"11:30 to 12:30\"],  # Stephanie\n    [\"11:00 to 12:30\", \"14:00 to 14:30\"],  # Henry\n    [\"9:30 to 10:30\", \"14:30 to 15:00\", \"15:30 to 16:00\"],  # Janice\n    [\"9:00 to 10:00\", \"10:30 to 12:00\", \"13:00 to 13:30\", \"14:00 to 15:00\"],  # Judy\n    [\"10:00 to 10:30\", \"12:00 to 13:30\", \"14:00 to 15:30\", \"16:00 to 16:30\"],  # Victoria\n    [\"9:00 to 10:30\", \"11:00 to 12:00\", \"12:30 to 15:30\", \"16:00 to 16:30\"],  # Joe\n]\n\n# Work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_335"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert each participant's busy slots to minutes\n    busy_slots = {\n        'Cheryl': [(12 * 60 + 30, 13 * 60), (16 * 60 + 30, 17 * 60)],\n        'Bryan': [(11 * 60 + 30, 12 * 60 + 30), (16 * 60, 17 * 60)],\n        'Joseph': [],\n        'Maria': [(9 * 60, 9 * 60 + 30), (10 * 60, 11 * 60 + 30),\n                  (12 * 60, 12 * 60 + 30), (14 * 60, 14 * 60 + 30),\n                  (15 * 60, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Elizabeth': [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60),\n                     (12 * 60 + 30, 13 * 60 + 30), (15 * 60, 16 * 60),\n                     (16 * 60 + 30, 17 * 60)],\n        'Kimberly': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30),\n                     (11 * 60, 12 * 60), (12 * 60 + 30, 13 * 60),\n                     (13 * 60 + 30, 14 * 60), (16 * 60, 17 * 60)]\n    }\n\n    # Collect all busy slots\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n\n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check each free slot for availability for all participants\n    for slot_start, slot_end in free_slots:\n        duration_needed = 30  # minutes\n        if slot_end - slot_start >= duration_needed:\n            # Check if all participants are free during this slot\n            valid = True\n            for person in busy_slots:\n                person_busy = busy_slots[person]\n                for busy_start, busy_end in person_busy:\n                    if not (slot_start >= busy_end or slot_start + duration_needed <= busy_start):\n                        # Overlap found, not free\n                        valid = False\n                        break\n                if not valid:\n                    break\n            if valid:\n                # Convert minutes back to HH:MM format\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_hh = (slot_start + duration_needed) // 60\n                end_mm = (slot_start + duration_needed) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_336"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:30:10:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert time strings to minutes since start of the day\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append(interval)\n    \n    # Find available slots\n    available_slots = []\n    previous_end = work_start\n    \n    for interval in merged:\n        start, end = interval\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot in available_slots:\n        start, end = slot\n        if end - start >= duration:\n            meeting_end = start + duration\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"11:30:12:00\", \"14:00:14:30\"],  # John\n    [\"12:00:12:30\", \"14:00:15:00\", \"15:30:16:00\"],  # Megan\n    [],  # Brandon\n    [\"9:00:9:30\", \"10:00:10:30\", \"11:00:14:30\", \"15:00:16:00\", \"16:30:17:00\"],  # Kimberly\n    [\"10:00:11:00\", \"11:30:14:00\", \"15:00:15:30\"],  # Sean\n    [\"9:00:9:30\", \"10:30:12:00\", \"13:00:14:30\", \"16:00:16:30\"],  # Lori\n]\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_337"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each person's busy slots to minutes\n    alexander_busy = [(12*60, 12*60+30), (14*60+30, 16*60)]\n    amy_busy = [(10*60, 10*60+30), (12*60, 12*60+30), (15*60+30, 16*60), (16*60+30, 17*60)]\n    christopher_busy = [(10*60+30, 11*60+30)]\n    kyle_busy = [(9*60+30, 10*60), (11*60+30, 12*60+30), (13*60, 14*60), (14*60+30, 15*60+30), (16*60, 16*60+30)]\n    jerry_busy = [(9*60+30, 11*60+30), (12*60, 12*60+30), (13*60+30, 14*60), (15*60, 16*60)]\n    raymond_busy = [(9*60, 9*60+30), (10*60, 10*60+30), (11*60, 12*60+30), (13*60, 15*60+30), (16*60, 17*60)]\n    \n    # Combine all busy slots\n    all_busy = alexander_busy + amy_busy + christopher_busy + kyle_busy + jerry_busy + raymond_busy\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check if there's a free slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can accommodate 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_338"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:11:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration):\n    # Convert all time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work_hours start at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = 9 + minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    start_work = time_to_minutes(work_hours[0])\n    end_work = time_to_minutes(work_hours[1])\n    duration_min = duration * 60\n\n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy_times in participants_busy_times:\n        for start, end in busy_times:\n            all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals\n    all_busy.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find available slots\n    available = []\n    prev_end = start_work\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < end_work:\n        available.append((prev_end, end_work))\n\n    # Find the first available slot that can fit the meeting\n    for start, end in available:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    return \"No available time slot found\"\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 0.5  # 0.5 hours = 30 minutes\n\n# Define each participant's busy times\nparticipants_busy_times = [\n    [],  # Zachary is free all day\n    [(\"9:00\", \"10:00\"), (\"11:30\", \"12:00\"), (\"14:30\", \"15:30\"), (\"16:00\", \"16:30\")],  # Kenneth\n    [(\"9:30\", \"10:00\"), (\"16:00\", \"16:30\")],  # Judy\n    [(\"9:00\", \"10:00\"), (\"10:30\", \"11:00\"), (\"11:30\", \"12:30\"), (\"13:30\", \"14:00\"), (\"14:30\", \"16:00\"), (\"16:30\", \"17:00\")],  # Jean\n    [(\"9:30\", \"10:30\"), (\"11:30\", \"14:30\"), (\"15:00\", \"16:00\")],  # Sean\n    [(\"9:00\", \"9:30\"), (\"10:30\", \"11:00\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:30\"), (\"14:00\", \"16:00\"), (\"16:30\", \"17:00\")],  # Alice\n]\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy_times, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_339"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_start=9*60, work_end=17*60):\n    # Convert work hours to minutes since midnight for easier calculation\n    work_start_min = work_start\n    work_end_min = work_end\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    all_busy_intervals = []\n    \n    # Collect all busy intervals from each participant\n    for schedule in participants_schedules:\n        all_busy_intervals.extend(schedule)\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_intervals = []\n    for interval in all_busy_intervals:\n        if not merged_intervals:\n            merged_intervals.append(interval)\n        else:\n            last_start, last_end = merged_intervals[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged_intervals[-1] = (new_start, new_end)\n            else:\n                merged_intervals.append(interval)\n    \n    # Find free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    previous_end = work_start_min\n    \n    for interval in merged_intervals:\n        start, end = interval\n        if start > previous_end:\n            # There's a free interval before this busy interval\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check if there's a free interval after the last busy interval\n    if previous_end < work_end_min:\n        free_intervals.append((previous_end, work_end_min))\n    \n    # Find the first free interval that can accommodate the meeting duration\n    for interval in free_intervals:\n        start, end = interval\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules in minutes since midnight\nparticipants_schedules = [\n    # Aaron's schedule\n    [(10*60 + 30, 12*60), (13*60, 13*60 + 30), (14*60 + 30, 15*60), (16*60 + 30, 17*60)],\n    # Frank's schedule\n    [(9*60, 9*60 + 30), (11*60, 11*60 + 30), (12*60, 12*60 + 30), (14*60 + 30, 15*60 + 30), (16*60 + 30, 17*60)],\n    # Diane's schedule\n    [(9*60, 10*60)],\n    # Dylan's schedule\n    [(9*60 + 30, 10*60 + 30), (12*60, 15*60), (15*60 + 30, 16*60), (16*60 + 30, 17*60)],\n    # Alexis's schedule\n    [(9*60, 9*60 + 30), (10*60 + 30, 11*60), (12*60 + 30, 13*60), (13*60 + 30, 15*60), (15*60 + 30, 16*60), (16*60 + 30, 17*60)],\n    # Mason's schedule\n    [(9*60, 10*60), (10*60 + 30, 11*60 + 30), (12*60 + 30, 14*60 + 30), (15*60, 15*60 + 30), (16*60 + 30, 17*60)],\n]\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules))\n```",
            "count": "calendar_scheduling_example_340"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:30:17:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all times to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between merged intervals and work hours\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Check each available slot for sufficient duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_minutes:\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            \n            meeting_start = minutes_to_time(slot_start)\n            meeting_end = minutes_to_time(slot_start + duration_minutes)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"09:30:11:00\", \"13:00:14:00\", \"15:00:15:30\"],  # Ruth\n    [\"10:00:10:30\", \"11:00:12:00\", \"12:30:13:30\", \"15:00:15:30\"],  # Aaron\n    [\"13:00:13:30\", \"14:30:15:00\"],  # Brittany\n    [\"09:00:10:30\", \"11:00:12:00\", \"13:00:16:30\"],  # Jeffrey\n    [\"09:00:16:00\"],  # Virginia\n    [\"09:00:12:30\", \"13:00:14:00\", \"14:30:15:00\", \"15:30:16:30\"],  # Peter\n]\n\n# Find a 30-minute meeting slot between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, \"09:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_341"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time slots to minutes since start of the day for easier calculation\n    work_start = work_hours_start * 60\n    work_end = work_hours_end * 60\n    duration = duration_minutes\n\n    # Initialize a list to keep track of busy intervals for all participants\n    busy_intervals = []\n\n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start_h, start_m, end_h, end_m = interval\n            start = start_h * 60 + start_m\n            end = end_h * 60 + end_m\n            busy_intervals.append((start, end))\n\n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find available slots by checking gaps between merged intervals and work hours\n    available_slots = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Find the first available slot that can fit the meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_h = meeting_start // 60\n            start_m = meeting_start % 60\n            end_h = meeting_end // 60\n            end_m = meeting_end % 60\n            return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n\n    return \"No available slot found\"\n\n# Define participants' schedules in HH:MM:HH:MM format (converted to tuples for processing)\nparticipants_schedules = [\n    [(10, 0, 10, 30), (16, 0, 16, 30)],  # Ryan\n    [],                                   # Brandon\n    [(11, 0, 11, 30), (15, 30, 16, 0)],  # Sandra\n    [(9, 0, 12, 0), (12, 30, 13, 0), (14, 0, 16, 30)],  # Jonathan\n    [(9, 30, 11, 0), (12, 0, 13, 0), (14, 0, 16, 30)],  # Elijah\n    [(9, 0, 10, 30), (11, 30, 13, 0), (14, 30, 16, 30)] # Justin\n]\n\n# Work hours and meeting duration\nwork_hours_start = 9\nwork_hours_end = 17\nmeeting_duration = 60\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_342"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:00:16:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_hour, end_hour = work_hours\n    start_time = start_hour * 60\n    end_time = end_hour * 60\n    duration_minutes = duration * 60\n    \n    # Initialize a list to represent each minute in the workday\n    time_slots = [True] * (end_time - start_time)\n    \n    # Mark busy times for each participant\n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            busy_start_min = busy_start[0] * 60 + busy_start[1]\n            busy_end_min = busy_end[0] * 60 + busy_end[1]\n            # Adjust to work hours\n            busy_start_min = max(busy_start_min, start_time)\n            busy_end_min = min(busy_end_min, end_time)\n            # Mark the busy slots as False\n            for i in range(busy_start_min - start_time, busy_end_min - start_time):\n                if i < len(time_slots):\n                    time_slots[i] = False\n    \n    # Find the first available slot of duration_minutes\n    current_slot_start = None\n    consecutive_free = 0\n    for i in range(len(time_slots)):\n        if time_slots[i]:\n            if current_slot_start is None:\n                current_slot_start = i\n            consecutive_free += 1\n            if consecutive_free >= duration_minutes:\n                meeting_start = current_slot_start + start_time\n                meeting_start_hour = meeting_start // 60\n                meeting_start_min = meeting_start % 60\n                meeting_end = meeting_start + duration_minutes\n                meeting_end_hour = meeting_end // 60\n                meeting_end_min = meeting_end % 60\n                return f\"{meeting_start_hour:02d}:{meeting_start_min:02d}:{meeting_end_hour:02d}:{meeting_end_min:02d}\"\n        else:\n            current_slot_start = None\n            consecutive_free = 0\n    return \"No available slot found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (9, 17)\n\n# Define meeting duration (0.5 hours)\nduration = 0.5\n\n# Define each participant's busy times in (HH, MM) format\nparticipants_schedules = [\n    # Benjamin\n    [\n        ((9, 0), (9, 30)),\n        ((10, 30), (11, 0)),\n        ((13, 0), (15, 0))\n    ],\n    # Beverly\n    [\n        ((10, 0), (10, 30)),\n        ((12, 30), (13, 0))\n    ],\n    # Willie - no busy times\n    [],\n    # Ethan\n    [\n        ((10, 0), (10, 30)),\n        ((11, 30), (15, 0)),\n        ((15, 30), (16, 0)),\n        ((16, 30), (17, 0))\n    ],\n    # Marie\n    [\n        ((9, 0), (10, 30)),\n        ((11, 30), (13, 0)),\n        ((13, 30), (14, 0)),\n        ((16, 30), (17, 0))\n    ],\n    # Sandra\n    [\n        ((9, 0), (9, 30)),\n        ((10, 0), (11, 30)),\n        ((12, 0), (12, 30)),\n        ((13, 0), (16, 0)),\n        ((16, 30), (17, 0))\n    ]\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_343"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:9:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = meeting_duration * 60\n    \n    # Collect all busy intervals for all participants\n    all_busy_intervals = []\n    for busy_times in participants_busy_times.values():\n        for interval in busy_times:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            all_busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_intervals = []\n    for start, end in all_busy_intervals:\n        if not merged_intervals:\n            merged_intervals.append([start, end])\n        else:\n            last_start, last_end = merged_intervals[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_intervals[-1] = [new_start, new_end]\n            else:\n                merged_intervals.append([start, end])\n    \n    # Check for available slots between work hours and busy intervals\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged_intervals:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' busy times\nparticipants_busy_times = {\n    \"Noah\": [\"11:00 to 12:00\", \"12:30 to 13:00\", \"14:30 to 15:30\", \"16:30 to 17:00\"],\n    \"Ralph\": [\"10:30 to 11:00\", \"12:00 to 12:30\", \"13:00 to 14:00\", \"14:30 to 15:00\", \"16:30 to 17:00\"],\n    \"Sean\": [\"13:00 to 13:30\", \"14:30 to 15:30\", \"16:30 to 17:00\"],\n    \"John\": [\"9:30 to 10:30\", \"11:00 to 11:30\", \"13:00 to 16:00\", \"16:30 to 17:00\"],\n    \"Harold\": [\"9:30 to 10:00\", \"11:30 to 12:30\", \"13:00 to 13:30\", \"14:00 to 15:30\", \"16:30 to 17:00\"],\n    \"Austin\": [\"10:00 to 11:00\", \"11:30 to 14:00\", \"14:30 to 17:00\"]\n}\n\n# Work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 0.5  # half an hour\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_344"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy times in minutes since midnight\n    dennis_busy = [\n        (9 * 60 + 30, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    \n    elijah_busy = [\n        (10 * 60 + 30, 12 * 60 + 30),\n        (14 * 60, 15 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    christian_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (13 * 60, 15 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Willie's constraint: not before 10:00\n    willie_constraint = 10 * 60\n    \n    # Combine all busy times\n    all_busy = dennis_busy + elijah_busy + christian_busy\n    all_busy.sort()  # Sort by start time\n    \n    # Find free slots by merging busy intervals\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Generate potential free slots\n    free_slots = []\n    previous_end = max(work_start, willie_constraint)\n    \n    for start, end in merged_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy interval\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that is at least 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Return the first suitable slot\n            start_time = start\n            end_time = start_time + meeting_duration\n            # Format as HH:MM:HH:MM\n            return f\"{start_time // 60:02d}:{start_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_345"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:30:17:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_start, work_end):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            all_busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_intervals = []\n    for start, end in all_busy_intervals:\n        if not merged_intervals:\n            merged_intervals.append([start, end])\n        else:\n            last_start, last_end = merged_intervals[-1]\n            if start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                merged_intervals[-1][1] = max(end, last_end)\n            else:\n                merged_intervals.append([start, end])\n    \n    # Find the earliest available slot\n    previous_end = work_start_min\n    for start, end in merged_intervals:\n        if start - previous_end >= duration_min:\n            # Found a suitable slot\n            meeting_start = previous_end\n            meeting_end = meeting_start + duration_min\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy interval\n    if work_end_min - previous_end >= duration_min:\n        meeting_start = previous_end\n        meeting_end = meeting_start + duration_min\n        def minutes_to_time(minutes):\n            hh = minutes // 60\n            mm = minutes % 60\n            return f\"{hh:02d}:{mm:02d}\"\n        return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return None\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"9:00:9:30\", \"10:30:11:00\", \"13:00:14:00\"],  # Walter\n    [\"13:30:14:00\", \"14:30:15:00\"],  # Jessica\n    [\"11:00:11:30\", \"14:00:15:00\", \"16:00:16:30\"],  # Robert\n    [\"9:00:9:30\", \"10:30:11:00\", \"11:30:13:00\", \"13:30:14:30\", \"16:00:16:30\"],  # Nicole\n    [\"9:30:11:30\", \"12:00:12:30\", \"15:00:16:30\"],  # Dorothy\n    [\"9:00:10:30\", \"11:00:12:30\", \"13:30:15:30\"],  # Gabriel\n]\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, 0.5, \"9:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_346"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:30:14:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals\n    busy_intervals = []\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules.values():\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort the busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    # Check the slot after the last busy interval\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    meeting_duration_min = meeting_duration * 60\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    'Albert': ['12:30 to 13:00', '14:00 to 14:30'],\n    'Jean': [],\n    'William': ['10:00 to 11:00', '12:30 to 13:00', '14:30 to 16:00'],\n    'Alan': ['9:30 to 10:00', '10:30 to 11:30', '12:00 to 13:30', '14:30 to 15:30', '16:00 to 17:00'],\n    'Donna': ['9:00 to 10:00', '12:00 to 13:30', '14:00 to 15:00', '16:30 to 17:00'],\n    'Christina': ['9:00 to 11:00', '11:30 to 12:00', '12:30 to 13:00', '16:00 to 17:00'],\n}\n\n# Define work hours and meeting duration\nwork_hours_start = '9:00'\nwork_hours_end = '17:00'\nmeeting_duration = 0.5  # in hours\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_347"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    anna_busy = [(10*60 + 30, 11*60), (12*60 + 30, 13*60), (15*60, 16*60)]\n    benjamin_busy = [(10*60, 10*60 + 30), (11*60, 11*60 + 30), (12*60 + 30, 13*60), (14*60, 14*60 + 30)]\n    noah_busy = [(9*60 + 30, 13*60 + 30), (14*60, 14*60 + 30), (15*60, 15*60 + 30), (16*60, 17*60)]\n    bruce_busy = [(9*60 + 30, 10*60 + 30), (11*60, 13*60), (13*60 + 30, 14*60), (14*60 + 30, 17*60)]\n    matthew_busy = [(9*60 + 30, 16*60 + 30)]\n\n    # Combine all busy slots\n    all_busy = []\n    all_busy.extend(anna_busy)\n    all_busy.extend(benjamin_busy)\n    all_busy.extend(noah_busy)\n    all_busy.extend(bruce_busy)\n    all_busy.extend(matthew_busy)\n\n    # Sort busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_348"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert work hours to minutes since midnight for easier calculation\n    start_time = work_hours_start * 60\n    end_time = work_hours_end * 60\n    duration = duration_minutes\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            all_busy_intervals.append((busy_start * 60, busy_end * 60))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_intervals = []\n    for interval in all_busy_intervals:\n        if not merged_intervals:\n            merged_intervals.append(interval)\n        else:\n            last_start, last_end = merged_intervals[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged_intervals[-1] = (new_start, new_end)\n            else:\n                merged_intervals.append(interval)\n    \n    # Find the earliest available slot\n    previous_end = start_time\n    for busy_start, busy_end in merged_intervals:\n        if busy_start - previous_end >= duration:\n            # Found a suitable slot\n            meeting_start = previous_end\n            meeting_end = meeting_start + duration\n            return (meeting_start // 60, meeting_start % 60, meeting_end // 60, meeting_end % 60)\n        previous_end = max(previous_end, busy_end)\n    \n    # Check the time after the last busy interval\n    if end_time - previous_end >= duration:\n        meeting_start = previous_end\n        meeting_end = meeting_start + duration\n        return (meeting_start // 60, meeting_start % 60, meeting_end // 60, meeting_end % 60)\n    \n    # No suitable slot found (though the problem states one exists)\n    return None\n\n# Define participants' schedules in minutes since midnight (converted from HH:MM)\nparticipants_schedules = [\n    [(10 * 60, 11 * 60 + 30), (15 * 60, 15 * 60 + 30)],  # Carl\n    [],  # Patricia\n    [(11 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60)],  # Madison\n    [(10 * 60, 12 * 60), (13 * 60, 13 * 60 + 30), (14 * 60, 15 * 60), (16 * 60, 16 * 60 + 30)],  # Gloria\n    [(9 * 60, 10 * 60), (11 * 60 + 30, 12 * 60), (13 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],  # Kenneth\n    [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (13 * 60, 14 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],  # Betty\n]\n\n# Work hours and meeting duration\nwork_hours_start = 9\nwork_hours_end = 17\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\n\n# Format the output as HH:MM:HH:MM\nif meeting_time:\n    start_hour, start_minute, end_hour, end_minute = meeting_time\n    print(f\"{start_hour:02d}:{start_minute:02d}:{end_hour:02d}:{end_minute:02d}\")\nelse:\n    print(\"No suitable time found\")\n```",
            "count": "calendar_scheduling_example_349"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:00:15:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time slots to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's schedule to find common free slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_slots.append((start, end))\n        # Sort the busy slots by start time\n        busy_slots.sort()\n        \n        # Merge overlapping or adjacent busy slots\n        merged_busy = []\n        for start, end in busy_slots:\n            if not merged_busy:\n                merged_busy.append((start, end))\n            else:\n                last_start, last_end = merged_busy[-1]\n                if start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged_busy[-1] = (new_start, new_end)\n                else:\n                    merged_busy.append((start, end))\n        \n        # Subtract busy slots from current free slots\n        new_free_slots = []\n        for free_start, free_end in free_slots:\n            current_start = free_start\n            for busy_start, busy_end in merged_busy:\n                if busy_end <= current_start:\n                    continue  # busy slot is before current free slot\n                if busy_start >= free_end:\n                    break    # busy slot is after current free slot\n                if busy_start > current_start:\n                    new_free_slots.append((current_start, busy_start))\n                current_start = max(current_start, busy_end)\n            if current_start < free_end:\n                new_free_slots.append((current_start, free_end))\n        free_slots = new_free_slots\n    \n    # Find the first free slot that can accommodate the meeting duration\n    duration = duration_minutes\n    for start, end in free_slots:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return (f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\")\n    \n    return None\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"9:00:9:30\", \"14:00:15:00\", \"15:30:16:00\"],  # Madison\n    [],                                            # Cheryl\n    [],                                            # Walter\n    [\"9:30:11:00\", \"11:30:15:00\", \"16:00:17:00\"], # Donna\n    [\"9:00:9:30\", \"10:00:10:30\", \"11:00:15:00\", \"15:30:16:00\", \"16:30:17:00\"],  # Kathleen\n    [\"9:30:12:30\", \"13:00:13:30\", \"15:30:17:00\"], # Samuel\n]\n\n# Find a meeting time\nmeeting_time = find_meeting_time(participants_schedules, \"9:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_350"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy_intervals = []\n    for schedule in participants_schedules:\n        participant_busy = []\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            participant_busy.append((start, end))\n        all_busy_intervals.append(participant_busy)\n    \n    # Find all free intervals for each participant\n    all_free_intervals = []\n    for participant in all_busy_intervals:\n        free = []\n        # Check before first busy interval\n        if participant and participant[0][0] > work_start:\n            free.append((work_start, participant[0][0]))\n        # Check between busy intervals\n        for i in range(1, len(participant)):\n            prev_end = participant[i-1][1]\n            curr_start = participant[i][0]\n            if curr_start > prev_end:\n                free.append((prev_end, curr_start))\n        # Check after last busy interval\n        if participant and participant[-1][1] < work_end:\n            free.append((participant[-1][1], work_end))\n        # If no busy intervals, the whole day is free\n        if not participant:\n            free.append((work_start, work_end))\n        all_free_intervals.append(free)\n    \n    # Find overlapping free intervals across all participants\n    # Start with the first participant's free intervals\n    overlapping_free = all_free_intervals[0]\n    for participant_free in all_free_intervals[1:]:\n        new_overlapping = []\n        for slot1 in overlapping_free:\n            for slot2 in participant_free:\n                # Find the overlap between slot1 and slot2\n                overlap_start = max(slot1[0], slot2[0])\n                overlap_end = min(slot1[1], slot2[1])\n                if overlap_start < overlap_end:\n                    new_overlapping.append((overlap_start, overlap_end))\n        overlapping_free = new_overlapping\n        if not overlapping_free:\n            break  # No possible slots\n    \n    # Find the first overlapping free slot that can fit the meeting\n    duration = duration_minutes\n    for slot in overlapping_free:\n        slot_duration = slot[1] - slot[0]\n        if slot_duration >= duration:\n            meeting_start = slot[0]\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\n# Define each participant's busy intervals\nparticipants_schedules = [\n    [\"9:00 to 10:30\", \"11:00 to 11:30\", \"12:30 to 13:00\", \"16:30 to 17:00\"],  # Andrew\n    [\"10:30 to 11:00\", \"15:30 to 16:00\"],  # Rebecca\n    [\"9:00 to 9:30\", \"15:30 to 16:00\"],  # Harold\n    [\"9:00 to 11:00\", \"11:30 to 13:00\", \"14:00 to 15:00\", \"15:30 to 17:00\"],  # Douglas\n    [\"9:00 to 11:30\", \"13:30 to 16:00\"],  # Jean\n    [\"9:30 to 10:30\", \"11:00 to 13:00\", \"13:30 to 16:30\"],  # Larry\n]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_351"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_hour, end_hour = work_hours\n    # Convert work hours to minutes for easier calculation\n    start_time = start_hour * 60\n    end_time = end_hour * 60\n    \n    # Initialize a list to keep track of busy times for all participants\n    busy_times = []\n    \n    for schedule in participants_schedules:\n        personal_busy = []\n        for block in schedule:\n            start_block = block[0] * 60\n            end_block = block[1] * 60\n            personal_busy.append((start_block, end_block))\n        busy_times.append(personal_busy)\n    \n    # Check every possible time slot within work hours\n    for current_time in range(start_time, end_time - duration + 1):\n        end_slot = current_time + duration\n        # Check if the time slot is free for all participants\n        all_free = True\n        for personal_busy in busy_times:\n            free = True\n            for (busy_start, busy_end) in personal_busy:\n                if not (end_slot <= busy_start or current_time >= busy_end):\n                    free = False\n                    break\n            if not free:\n                all_free = False\n                break\n        if all_free:\n            # Convert back to HH:MM format\n            start_hh = current_time // 60\n            start_mm = current_time % 60\n            end_hh = end_slot // 60\n            end_mm = end_slot % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No available time slot found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (9, 17)\n\n# Define meeting duration (30 minutes)\nduration = 30\n\n# Define participants' schedules in 24-hour format (HH:MM to HH:MM)\nparticipants_schedules = [\n    [],  # Aaron has no meetings\n    [(10, 10.5), (11.5, 12), (12.5, 13), (14.5, 15), (15.5, 16), (16.5, 17)],  # Betty\n    [],  # Linda\n    [(9, 9.5), (10, 11), (12, 12.5), (13, 14.5), (16, 16.5)],  # Joan\n    [(9, 9.5), (10.5, 11), (11.5, 12), (12.5, 13), (13.5, 14.5), (15, 17)],  # Walter\n    [(9, 9.5), (10.5, 11), (11.5, 12), (12.5, 13.5), (14.5, 15.5), (16, 16.5)]  # Martha\n]\n\n# Find the earliest meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_352"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:30:10:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    meeting_duration_min = meeting_duration * 60\n    \n    # Initialize the free slots for the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's busy times\n    for busy_times in participants_busy_times:\n        new_free_slots = []\n        for busy_start, busy_end in busy_times:\n            busy_start_min = time_to_minutes(busy_start)\n            busy_end_min = time_to_minutes(busy_end)\n            temp_slots = []\n            for slot_start, slot_end in free_slots:\n                if busy_end_min <= slot_start or busy_start_min >= slot_end:\n                    # No overlap, keep the slot as is\n                    temp_slots.append((slot_start, slot_end))\n                else:\n                    # Overlap, split the slot\n                    if slot_start < busy_start_min:\n                        temp_slots.append((slot_start, busy_start_min))\n                    if slot_end > busy_end_min:\n                        temp_slots.append((busy_end_min, slot_end))\n            free_slots = temp_slots\n        if not free_slots:\n            return None  # No possible slot\n    \n    # Merge overlapping or adjacent slots\n    free_slots.sort()\n    merged_slots = []\n    for slot in free_slots:\n        if not merged_slots:\n            merged_slots.append(slot)\n        else:\n            last_start, last_end = merged_slots[-1]\n            current_start, current_end = slot\n            if current_start <= last_end:\n                # Merge the slots\n                new_slot = (last_start, max(last_end, current_end))\n                merged_slots[-1] = new_slot\n            else:\n                merged_slots.append(slot)\n    \n    # Find the first slot that can accommodate the meeting\n    for slot_start, slot_end in merged_slots:\n        if slot_end - slot_start >= meeting_duration_min:\n            meeting_end = slot_start + meeting_duration_min\n            return f\"{minutes_to_time(slot_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return None\n\n# Define the participants' busy times\nparticipants_busy_times = [\n    [(\"10:00\", \"10:30\"), (\"11:30\", \"12:30\"), (\"14:30\", \"15:00\")],  # Andrea\n    [(\"10:00\", \"11:00\"), (\"14:00\", \"14:30\"), (\"16:00\", \"16:30\")],  # Gloria\n    [],  # Philip\n    [(\"10:00\", \"10:30\"), (\"11:00\", \"12:00\"), (\"12:30\", \"13:00\"), (\"13:30\", \"15:30\"), (\"16:00\", \"17:00\")],  # Christian\n    [(\"10:00\", \"10:30\"), (\"11:30\", \"12:00\"), (\"12:30\", \"14:30\"), (\"15:00\", \"16:00\")],  # Denise\n    [(\"09:00\", \"09:30\"), (\"10:00\", \"13:30\"), (\"14:00\", \"17:00\")],  # Julie\n]\n\n# Find a meeting time\nmeeting_time = find_meeting_time(participants_busy_times, \"09:00\", \"17:00\", 0.5)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_353"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:30:17:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 (9:00)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Initialize a list to mark busy intervals\n    timeline = [0] * (work_end - work_start)\n    \n    # Mark busy intervals for each participant\n    for busy_slots in participants_busy.values():\n        for slot in busy_slots:\n            start, end = slot.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            for i in range(start_min, end_min):\n                if i < len(timeline):\n                    timeline[i] += 1\n    \n    # Find the first interval where all are free (timeline[i] == 0) for duration\n    required_slots = duration * 2  # Assuming half-hour slots (30 mins)\n    current_free = 0\n    \n    for i in range(len(timeline)):\n        if timeline[i] == 0:\n            current_free += 1\n            if current_free >= required_slots:\n                start_time = i - current_free + 1\n                end_time = start_time + required_slots\n                start_str = minutes_to_time(start_time)\n                end_str = minutes_to_time(end_time)\n                return f\"{start_str}:{end_str}\"\n        else:\n            current_free = 0\n    \n    return \"No suitable time found\"\n\n# Define participants' busy slots\nparticipants_busy = {\n    'Wayne': ['9:30 to 10:00', '11:30 to 12:00', '12:30 to 13:00', '15:00 to 15:30'],\n    'Larry': [],\n    'Richard': ['9:30 to 10:30', '11:30 to 12:00', '13:00 to 13:30'],\n    'Sophia': ['9:00 to 9:30', '11:00 to 15:30'],\n    'Jennifer': ['9:00 to 9:30', '10:30 to 13:00', '13:30 to 14:30', '15:00 to 16:00'],\n    'Theresa': ['9:30 to 10:00', '11:00 to 12:00', '12:30 to 13:30', '14:30 to 15:30', '16:00 to 16:30'],\n}\n\nwork_hours = '9:00 to 17:00'\nmeeting_duration = 0.5  # half an hour\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_354"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy times in minutes (start, end)\n    busy_times = {\n        'Vincent': [(12 * 60 + 30, 13 * 60), (14 * 60, 15 * 60), (16 * 60 + 30, 17 * 60)],\n        'Diane': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (12 * 60, 13 * 60 + 30),\n                  (14 * 60, 14 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n        'Juan': [(9 * 60, 9 * 60 + 30), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 14 * 60 + 30),\n                 (16 * 60, 17 * 60)],\n        'Joseph': [(9 * 60, 11 * 60), (12 * 60, 15 * 60)],\n    }\n    \n    # Austin's preference: not after 15:30\n    austin_preference_end = 15 * 60 + 30\n    \n    # Combine all busy times\n    all_busy = []\n    for person in busy_times:\n        all_busy.extend(busy_times[person])\n    \n    # Add Austin's preference as a \"busy\" time after 15:30\n    all_busy.append((austin_preference_end, work_end))\n    \n    # Sort busy times by start time\n    all_busy.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Find the first free slot that is at least 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Return the first 30-minute slot\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_355"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each person's busy slots to minutes since midnight\n    # Katherine: 12:00-12:30, 13:00-14:30\n    katherine_busy = [(12*60, 12*60 + 30), (13*60, 14*60 + 30)]\n    \n    # Rebecca: free all day\n    rebecca_busy = []\n    \n    # Julie: 9:00-9:30, 10:30-11:00, 13:30-14:00, 15:00-15:30\n    julie_busy = [(9*60, 9*60 + 30), (10*60 + 30, 11*60),\n                  (13*60 + 30, 14*60), (15*60, 15*60 + 30)]\n    \n    # Angela: 9:00-10:00, 10:30-11:00, 11:30-14:00, 14:30-15:00, 16:30-17:00\n    # Preference: avoid before 15:00\n    angela_busy = [(9*60, 10*60), (10*60 + 30, 11*60),\n                   (11*60 + 30, 14*60), (14*60 + 30, 15*60),\n                   (16*60 + 30, 17*60)]\n    angela_preference_start = 15 * 60  # 15:00\n    \n    # Nicholas: 9:30-11:00, 11:30-13:30, 14:00-16:00, 16:30-17:00\n    nicholas_busy = [(9*60 + 30, 11*60), (11*60 + 30, 13*60 + 30),\n                     (14*60, 16*60), (16*60 + 30, 17*60)]\n    \n    # Carl: 9:00-11:00, 11:30-12:30, 13:00-14:30, 15:00-16:00, 16:30-17:00\n    carl_busy = [(9*60, 11*60), (11*60 + 30, 12*60 + 30),\n                 (13*60, 14*60 + 30), (15*60, 16*60),\n                 (16*60 + 30, 17*60)]\n    \n    # Combine all busy slots\n    all_busy = katherine_busy + rebecca_busy + julie_busy + angela_busy + nicholas_busy + carl_busy\n    \n    # Generate free slots by inverting busy slots\n    all_busy.sort()  # Sort by start time\n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Filter free slots to find those that are at least 30 minutes and meet Angela's preference\n    meeting_duration = 30\n    valid_slots = []\n    \n    for start, end in free_slots:\n        if end - start >= meeting_duration and start >= angela_preference_start:\n            valid_slots.append((start, end))\n    \n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No valid time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_356"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each participant's busy slots to minutes since 9:00\n    # Format: list of (start, end) in minutes\n    eric_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    carol_busy = []\n    nicholas_busy = [\n        (11 * 60 + 30, 12 * 60),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    randy_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 11 * 60 + 30),\n        (13 * 60, 14 * 60),\n        (15 * 60, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    kevin_busy = [\n        (9 * 60, 10 * 60),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60, 13 * 60),\n        (13 * 60 + 30, 15 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    henry_busy = [\n        (9 * 60, 10 * 60),\n        (11 * 60, 12 * 60),\n        (13 * 60, 14 * 60),\n        (15 * 60 + 30, 16 * 60 + 30)\n    ]\n\n    # Combine all busy slots\n    all_busy = eric_busy + carol_busy + nicholas_busy + randy_busy + kevin_busy + henry_busy\n\n    # Generate available slots by finding gaps between busy times\n    all_busy.sort()  # Sort by start time\n    available_slots = []\n    prev_end = work_start\n\n    for busy_start, busy_end in all_busy:\n        if busy_start > prev_end:\n            available_slots.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_357"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define each participant's busy times in minutes (start, end)\n    busy_times = {\n        'Jennifer': [(10 * 60 + 30, 11 * 60), (13 * 60, 14 * 60), (16 * 60 + 30, 17 * 60)],\n        'Douglas': [(9 * 60, 9 * 60 + 30), (12 * 60 + 30, 13 * 60)],\n        'Lauren': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (13 * 60, 15 * 60)],\n        'Daniel': [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60), (11 * 60 + 30, 12 * 60 + 30), (13 * 60, 14 * 60 + 30), (15 * 60 + 30, 16 * 60 + 30)],\n        'Abigail': [(9 * 60 + 30, 10 * 60 + 30), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 14 * 60 + 30), (15 * 60 + 30, 16 * 60)],\n        'Catherine': [(9 * 60, 11 * 60), (11 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)]\n    }\n\n    # Collect all busy intervals\n    all_busy = []\n    for person in busy_times:\n        all_busy.extend(busy_times[person])\n\n    # Sort all busy intervals by start time\n    all_busy.sort()\n\n    # Find free intervals by checking gaps between busy intervals\n    free_intervals = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check the interval after the last busy time\n    if previous_end < work_end:\n        free_intervals.append((previous_end, work_end))\n\n    # Find the first free interval that is at least 30 minutes long\n    for start, end in free_intervals:\n        if end - start >= 30:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = (start + 30) // 60\n            end_mm = (start + 30) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_358"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:00:14:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    start, end = work_hours\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        h = minutes // 60\n        m = minutes % 60\n        return f\"{h:02d}:{m:02d}\"\n    \n    work_start = time_to_minutes(start)\n    work_end = time_to_minutes(end)\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    busy_intervals = []\n    \n    for person, schedules in participants_schedules.items():\n        for interval in schedules:\n            start_time, end_time = interval.split(' to ')\n            start_min = time_to_minutes(start_time)\n            end_min = time_to_minutes(end_time)\n            busy_intervals.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    prev_end = work_start\n    \n    for start_busy, end_busy in busy_intervals:\n        if start_busy > prev_end:\n            free_intervals.append((prev_end, start_busy))\n        prev_end = max(prev_end, end_busy)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Now check each free interval to see if it's long enough and doesn't overlap with any participant's busy time\n    # But since we've combined all busy times, any free interval is a potential candidate\n    # So we just need to find the first free interval that's >= duration\n    duration_min = duration * 60\n    for start_free, end_free in free_intervals:\n        if end_free - start_free >= duration_min:\n            # Check if this interval is free for all participants\n            all_free = True\n            for person, schedules in participants_schedules.items():\n                person_busy = False\n                for interval in schedules:\n                    s, e = interval.split(' to ')\n                    s_min = time_to_minutes(s)\n                    e_min = time_to_minutes(e)\n                    # Check if the proposed interval overlaps with any of the person's busy intervals\n                    if not (end_free <= s_min or start_free >= e_min):\n                        person_busy = True\n                        break\n                if person_busy:\n                    all_free = False\n                    break\n            if all_free:\n                return f\"{minutes_to_time(start_free)}:{minutes_to_time(start_free + duration_min)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    'Bryan': ['9:00 to 9:30', '10:00 to 10:30', '12:30 to 13:00', '16:00 to 16:30'],\n    'Sophia': ['13:00 to 13:30', '16:00 to 16:30'],\n    'Jeremy': [],\n    'Marie': ['9:00 to 9:30', '10:00 to 12:00', '13:00 to 14:00', '15:30 to 16:00'],\n    'Tyler': ['9:00 to 10:00', '11:00 to 11:30', '13:00 to 14:00', '14:30 to 17:00'],\n    'Emily': ['9:00 to 10:00', '11:00 to 12:30', '13:30 to 14:00', '14:30 to 15:30']\n}\n\n# Meeting duration in hours (0.5 hours = 30 minutes)\nduration = 0.5\nwork_hours = ('9:00', '17:00')\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, duration, work_hours))\n```",
            "count": "calendar_scheduling_example_359"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:9:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            all_busy.append((time_to_minutes(busy_start), time_to_minutes(busy_end)))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find the merged busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(start, last_start)\n                new_end = max(end, last_end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Check the available slots between work hours and merged busy intervals\n    available_slots = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    meeting_duration_min = meeting_duration * 60\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration_min:\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            meeting_start = minutes_to_time(slot_start)\n            meeting_end = minutes_to_time(slot_start + meeting_duration_min)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [(\"10:00\", \"10:30\"), (\"16:00\", \"16:30\")],  # Emily\n    [],                                         # Mason\n    [(\"10:30\", \"11:00\"), (\"14:00\", \"14:30\")],  # Maria\n    [(\"09:30\", \"10:00\"), (\"10:30\", \"12:30\"), (\"13:30\", \"14:00\"), (\"14:30\", \"15:30\"), (\"16:00\", \"17:00\")],  # Carl\n    [(\"09:30\", \"11:00\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:30\"), (\"14:00\", \"15:00\"), (\"16:00\", \"17:00\")],  # David\n    [(\"09:30\", \"10:30\"), (\"11:00\", \"11:30\"), (\"12:30\", \"13:30\"), (\"14:30\", \"17:00\")]  # Frank\n]\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, \"09:00\", \"17:00\", 0.5)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_360"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30       # 30 minutes\n    \n    # Convert each participant's busy slots to minutes\n    # Format: (start_minute, end_minute)\n    kenneth_busy = []\n    melissa_busy = []\n    joan_busy = [(10*60, 11*60), (12*60 + 30, 13*60 + 30), (15*60, 15*60 + 30), (16*60 + 30, 17*60)]\n    emily_busy = [(10*60, 11*60), (12*60 + 30, 14*60), (15*60, 15*60 + 30), (16*60, 17*60)]\n    brandon_busy = [(9*60 + 30, 10*60 + 30), (11*60, 11*60 + 30), (12*60 + 30, 14*60), (14*60 + 30, 15*60), (15*60 + 30, 17*60)]\n    christopher_busy = [(11*60 + 30, 14*60), (14*60 + 30, 15*60), (15*60 + 30, 16*60), (16*60 + 30, 17*60)]\n    \n    # Emily cannot meet before 9:30\n    emily_constraint = 9 * 60 + 30\n    \n    # Combine all busy slots\n    all_busy = kenneth_busy + melissa_busy + joan_busy + emily_busy + brandon_busy + christopher_busy\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find potential meeting slots\n    potential_slots = []\n    previous_end = max(work_hours_start, emily_constraint)\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            potential_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    # Check the slot after the last busy slot\n    if previous_end + meeting_duration <= work_hours_end:\n        potential_slots.append((previous_end, work_hours_end))\n    \n    # Find the first slot that fits the meeting duration\n    for slot_start, slot_end in potential_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_361"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy blocks to minutes since midnight\n    busy_blocks = {\n        'Megan': [(13 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60)],\n        'Jeremy': [(14 * 60, 15 * 60)],\n        'Sean': [(11 * 60, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (13 * 60 + 30, 14 * 60), (16 * 60, 16 * 60 + 30)],\n        'Dorothy': [(9 * 60, 10 * 60), (11 * 60, 11 * 60 + 30), (12 * 60, 13 * 60), (14 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Michael': [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 11 * 60 + 30), (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Jesse': [(10 * 60, 12 * 60 + 30), (14 * 60, 14 * 60 + 30), (16 * 60, 17 * 60)],\n    }\n\n    # Dorothy's preference: avoid after 15:00\n    dorothy_preference_end = 15 * 60\n\n    # Combine all busy blocks\n    all_busy = []\n    for person, blocks in busy_blocks.items():\n        all_busy.extend(blocks)\n    \n    # Sort all busy blocks by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy blocks and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the time after the last busy block\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Filter free slots that are at least meeting_duration long and meet Dorothy's preference\n    possible_slots = []\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            if end <= dorothy_preference_end:\n                possible_slots.append((start, end))\n    \n    # Also check slots that end after Dorothy's preference but start before\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            if start < dorothy_preference_end and end > dorothy_preference_end:\n                if dorothy_preference_end - start >= meeting_duration:\n                    possible_slots.append((start, dorothy_preference_end))\n    \n    # Find the earliest possible slot\n    if possible_slots:\n        possible_slots.sort()\n        best_start, best_end = possible_slots[0]\n        meeting_end = best_start + meeting_duration\n        # Format the output as HH:MM:HH:MM\n        return f\"{best_start // 60:02d}:{best_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    else:\n        return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_362"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    # Russell: 14:30-15:00, 15:30-17:00\n    russell_busy = [(14*60 + 30, 15*60), (15*60 + 30, 17*60)]\n    # Paul: 9:00-10:00, 10:30-12:30, 13:00-15:00, 15:30-16:00, 16:30-17:00\n    paul_busy = [(9*60, 10*60), (10*60 + 30, 12*60 + 30), (13*60, 15*60), (15*60 + 30, 16*60), (16*60 + 30, 17*60)]\n    # Donna: 9:00-9:30, 10:00-11:00, 11:30-12:30, 14:00-14:30, 15:00-15:30, 16:00-16:30\n    donna_busy = [(9*60, 9*60 + 30), (10*60, 11*60), (11*60 + 30, 12*60 + 30), (14*60, 14*60 + 30), (15*60, 15*60 + 30), (16*60, 16*60 + 30)]\n    # Isabella: 9:30-10:00, 11:00-11:30, 12:00-12:30, 13:00-13:30, 14:00-14:30, 15:00-15:30, 16:00-17:00\n    isabella_busy = [(9*60 + 30, 10*60), (11*60, 11*60 + 30), (12*60, 12*60 + 30), (13*60, 13*60 + 30), (14*60, 14*60 + 30), (15*60, 15*60 + 30), (16*60, 17*60)]\n\n    # Combine all busy times and sort\n    all_busy = russell_busy + paul_busy + donna_busy + isabella_busy\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = work_start\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can fit the meeting\n    for slot in free_slots:\n        start, end = slot\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_363"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy blocks to minutes since midnight\n    busy_blocks = {\n        'Virginia': [],\n        'Janet': [(9*60 + 30, 10*60), (12*60 + 30, 13*60), (13*60 + 30, 15*60 + 30)],\n        'Joyce': [(12*60 + 30, 13*60), (15*60 + 30, 17*60)],\n        'Catherine': [(9*60, 10*60), (10*60 + 30, 16*60 + 30)],\n        'Donna': [(9*60, 9*60 + 30), (11*60, 11*60 + 30), (13*60, 13*60 + 30), (14*60 + 30, 17*60)],\n        'Evelyn': [(10*60 + 30, 11*60), (12*60, 15*60 + 30), (16*60, 17*60)]\n    }\n\n    # Combine all busy blocks\n    all_busy = []\n    for person in busy_blocks:\n        all_busy.extend(busy_blocks[person])\n\n    # Sort busy blocks by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy blocks and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_364"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Convert each participant's busy slots to minutes\n    sarah_busy = [(11 * 60 + 30, 12 * 60), (15 * 60, 15 * 60 + 30)]\n    russell_busy = []\n    michael_busy = [(10 * 60 + 30, 11 * 60 + 30)]\n    charles_busy = [(10 * 60, 12 * 60), (13 * 60, 14 * 60), (14 * 60 + 30, 15 * 60), (16 * 60 + 30, 17 * 60)]\n    heather_busy = [(9 * 60, 10 * 60 + 30), (11 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60), (16 * 60, 16 * 60 + 30)]\n    sharon_busy = [(9 * 60, 9 * 60 + 30), (10 * 60, 12 * 60), (12 * 60 + 30, 13 * 60 + 30), (14 * 60, 14 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)]\n    \n    # Combine all busy slots\n    all_busy = sarah_busy + russell_busy + michael_busy + charles_busy + heather_busy + sharon_busy\n    \n    # Sort busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can accommodate 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_365"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:30:15:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours_start, work_hours_end, duration):\n    # Convert work hours to minutes\n    start_min = work_hours_start * 60\n    end_min = work_hours_end * 60\n    \n    # Initialize a list to keep track of busy times for all participants\n    all_busy = []\n    \n    # Collect all busy intervals from each participant\n    for busy in participants_busy:\n        for interval in busy:\n            start = interval[0] * 60\n            end = interval[1] * 60\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find free intervals between merged busy times\n    free_intervals = []\n    prev_end = start_min\n    \n    for start, end in merged:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    # Check the interval after the last busy time\n    if prev_end < end_min:\n        free_intervals.append((prev_end, end_min))\n    \n    # Find the first free interval that can accommodate the meeting duration\n    duration_min = duration * 60\n    for start, end in free_intervals:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            # Convert back to hours and minutes\n            start_h = meeting_start // 60\n            start_m = meeting_start % 60\n            end_h = meeting_end // 60\n            end_m = meeting_end % 60\n            return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    \n    return \"No suitable time found\"\n\n# Define work hours and meeting duration\nwork_hours_start = 9\nwork_hours_end = 17\nduration = 0.5  # half an hour\n\n# Define each participant's busy times in hours\nparticipants_busy = [\n    [(14, 14.5), (15, 15.5), (16, 17)],  # Jeffrey\n    [(9, 9.5), (10, 10.5)],              # Benjamin\n    [(9.5, 10), (15, 15.5)],             # Denise\n    [(9, 11.5), (12.5, 14.5), (16, 16.5)],  # Alexis\n    [(9, 10.5), (11, 12), (12.5, 14), (15, 17)],  # Shirley\n    [(9, 9.5), (10.5, 11), (12, 12.5), (13, 13.5), (14, 14.5), (15, 15.5), (16, 17)]  # Philip\n]\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, work_hours_start, work_hours_end, duration))\n```",
            "count": "calendar_scheduling_example_366"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define each person's busy times in minutes (start, end)\n    busy_times = {\n        'Carolyn': [(9.5 * 60, 10.5 * 60), (13.5 * 60, 14 * 60), (15 * 60, 15.5 * 60), (16 * 60, 17 * 60)],\n        'Jordan': [(9.5 * 60, 10 * 60), (10.5 * 60, 11 * 60), (13 * 60, 14.5 * 60), (16 * 60, 16.5 * 60)],\n        'Wayne': [(9 * 60, 9.5 * 60), (10.5 * 60, 11.5 * 60), (12.5 * 60, 13 * 60)],\n        'Megan': [(9 * 60, 9.5 * 60), (10 * 60, 11.5 * 60), (12 * 60, 13.5 * 60), (14 * 60, 14.5 * 60), (15 * 60, 15.5 * 60), (16 * 60, 16.5 * 60)],\n        'Billy': [(9 * 60, 11 * 60), (11.5 * 60, 15.5 * 60), (16 * 60, 17 * 60)],\n        'Peter': [(9 * 60, 10.5 * 60), (11 * 60, 13 * 60), (14 * 60, 15.5 * 60), (16 * 60, 17 * 60)]\n    }\n    \n    # Collect all busy intervals\n    all_busy = []\n    for person in busy_times:\n        all_busy.extend(busy_times[person])\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for a 30-minute slot\n    meeting_duration = 30\n    for interval in free_intervals:\n        start, end = interval\n        if end - start >= meeting_duration:\n            # Check if all participants are free during this interval\n            valid = True\n            meeting_start = start\n            meeting_end = start + meeting_duration\n            \n            for person in busy_times:\n                person_busy = busy_times[person]\n                for busy_start, busy_end in person_busy:\n                    if not (meeting_end <= busy_start or meeting_start >= busy_end):\n                        valid = False\n                        break\n                if not valid:\n                    break\n            \n            if valid:\n                # Convert minutes back to HH:MM format\n                def format_time(minutes):\n                    hours = int(minutes // 60)\n                    mins = int(minutes % 60)\n                    return f\"{hours:02d}:{mins:02d}\"\n                \n                return f\"{format_time(meeting_start)}:{format_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_367"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert each participant's busy slots to minutes\n    patrick_busy = [(11*60 + 30, 12*60), (15*60, 15*60 + 30)]\n    john_busy = [(11*60 + 30, 12*60 + 30), (13*60, 14*60), (14*60 + 30, 15*60), (15*60 + 30, 16*60)]\n    samantha_busy = [(12*60, 12*60 + 30), (16*60 + 30, 17*60)]\n    billy_busy = [(9*60, 9*60 + 30), (10*60, 11*60), (12*60 + 30, 14*60), (15*60 + 30, 16*60), (16*60 + 30, 17*60)]\n    christine_busy = [(9*60, 10*60), (10*60 + 30, 14*60), (15*60, 15*60 + 30)]\n    ruth_busy = [(9*60, 10*60), (10*60 + 30, 11*60), (11*60 + 30, 12*60), (12*60 + 30, 16*60), (16*60 + 30, 17*60)]\n\n    # Combine all busy slots\n    all_busy = patrick_busy + john_busy + samantha_busy + billy_busy + christine_busy + ruth_busy\n\n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert start time back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_time = start + meeting_duration\n            end_hh = end_time // 60\n            end_mm = end_time % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_368"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' busy slots in minutes\n    busy_slots = {\n        'Charles': [],\n        'Kayla': [(12 * 60, 13 * 60)],\n        'Cynthia': [],\n        'Rebecca': [(10 * 60, 10 * 60 + 30), (12 * 60, 14 * 60), (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Randy': [(10 * 60, 11 * 60 + 30), (12 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Hannah': [(9 * 60, 9 * 60 + 30), (10 * 60, 12 * 60), (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)]\n    }\n\n    # Kayla's constraint: not before 10:30\n    kayla_constraint = 10 * 60 + 30\n\n    # Meeting duration in minutes\n    meeting_duration = 30\n\n    # Combine all busy slots\n    all_busy = []\n    for person in busy_slots:\n        for start, end in busy_slots[person]:\n            all_busy.append((start, end))\n    all_busy.sort()\n\n    # Find free slots\n    free_slots = []\n    prev_end = work_start\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n\n    # Filter free slots that meet duration and Kayla's constraint\n    valid_slots = []\n    for start, end in free_slots:\n        if end - start >= meeting_duration and start >= kayla_constraint:\n            valid_slots.append((start, end))\n\n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Format the output as HH:MM:HH:MM\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No valid slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_369"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define each person's busy times in minutes (start, end)\n    schedules = {\n        'Peter': [(10*60 + 30, 11*60), (11*60 + 30, 12*60), (13*60, 13*60 + 30), (15*60 + 30, 16*60)],\n        'Grace': [(11*60 + 30, 13*60), (15*60, 15*60 + 30)],\n        'Julie': [(9*60 + 30, 10*60), (10*60 + 30, 11*60), (14*60, 15*60), (15*60 + 30, 16*60 + 30)],\n        'Kayla': [(11*60 + 30, 12*60), (12*60 + 30, 14*60 + 30), (15*60, 16*60), (16*60 + 30, 17*60)],\n        'Emma': [(9*60, 9*60 + 30), (10*60 + 30, 11*60), (11*60 + 30, 12*60), (13*60, 15*60 + 30)],\n        'Scott': [(9*60, 10*60), (12*60, 12*60 + 30), (13*60, 14*60), (14*60 + 30, 15*60 + 30), (16*60, 16*60 + 30)],\n    }\n    \n    # Kayla's preference: not before 11:00\n    kayla_preference_start = 11 * 60\n    \n    # Collect all busy intervals\n    all_busy = []\n    for person in schedules:\n        for start, end in schedules[person]:\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Filter free intervals that are at least 30 minutes and after Kayla's preference\n    possible_slots = []\n    for start, end in free_intervals:\n        if end - start >= 30 and start >= kayla_preference_start:\n            possible_slots.append((start, end))\n    \n    # Find the first possible slot that fits everyone\n    for slot_start, slot_end in possible_slots:\n        # Check if the slot is free for everyone\n        all_free = True\n        for person in schedules:\n            person_busy = schedules[person]\n            for busy_start, busy_end in person_busy:\n                if not (slot_start >= busy_end or slot_start + 30 <= busy_start):\n                    all_free = False\n                    break\n            if not all_free:\n                break\n        if all_free:\n            # Format the time as HH:MM:HH:MM\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = (slot_start + 30) // 60\n            end_mm = (slot_start + 30) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_370"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' schedules as lists of busy intervals in minutes\n    schedules = {\n        'Mark': [(11 * 60, 11 * 60 + 30), (12 * 60 + 30, 13 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Logan': [(11 * 60 + 30, 12 * 60), (13 * 60, 13 * 60 + 30)],\n        'Isabella': [(9 * 60, 9 * 60 + 30), (11 * 60, 11 * 60 + 30)],\n        'Nathan': [(9 * 60, 9 * 60 + 30), (10 * 60, 13 * 60), (13 * 60 + 30, 14 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Anna': [(9 * 60, 10 * 60), (11 * 60, 13 * 60), (13 * 60 + 30, 14 * 60), (16 * 60 + 30, 17 * 60)],\n        'Dylan': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (11 * 60, 12 * 60 + 30), (13 * 60, 14 * 60 + 30), (15 * 60, 16 * 60)],\n    }\n\n    # Collect all busy intervals from all participants\n    all_busy = []\n    for person in schedules:\n        all_busy.extend(schedules[person])\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n\n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append([start, end])\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1][1] = max(last_end, end)\n            else:\n                merged.append([start, end])\n\n    # Find available slots between work hours and busy intervals\n    available = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n\n    # Check each available slot for a 30-minute window\n    meeting_duration = 30\n    for start, end in available:\n        if end - start >= meeting_duration:\n            # Convert start time back to HH:MM format\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No available time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_371"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            all_busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Find the earliest time when everyone is free for the duration\n    current_time = work_start\n    for start, end in all_busy_intervals:\n        if start > current_time:\n            # Check if there's enough time before the next busy interval starts\n            if start - current_time >= duration_minutes:\n                # Found a suitable slot\n                meeting_end = current_time + duration_minutes\n                # Convert back to HH:MM format\n                def minutes_to_time(minutes):\n                    hh = minutes // 60\n                    mm = minutes % 60\n                    return f\"{hh:02d}:{mm:02d}\"\n                return f\"{minutes_to_time(current_time)}:{minutes_to_time(meeting_end)}\"\n        # Update current_time to the end of this busy interval if it's later\n        if end > current_time:\n            current_time = end\n        # If we've gone past work hours, break\n        if current_time >= work_end:\n            break\n    \n    # Check the time after the last busy interval\n    if work_end - current_time >= duration_minutes:\n        meeting_end = current_time + duration_minutes\n        def minutes_to_time(minutes):\n            hh = minutes // 60\n            mm = minutes % 60\n            return f\"{hh:02d}:{mm:02d}\"\n        return f\"{minutes_to_time(current_time)}:{minutes_to_time(meeting_end)}\"\n    \n    return None\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"10:30 to 11:30\", \"14:00 to 14:30\", \"16:00 to 16:30\"],  # Barbara\n    [\"11:30 to 13:00\", \"13:30 to 14:00\"],  # Arthur\n    [\"09:30 to 10:00\", \"10:30 to 11:00\", \"12:00 to 12:30\", \"14:00 to 15:30\"],  # Elijah\n    [\"09:00 to 13:00\", \"13:30 to 14:30\", \"15:00 to 17:00\"],  # Natalie\n    [\"09:30 to 10:00\", \"11:00 to 12:00\", \"13:30 to 15:30\", \"16:30 to 17:00\"],  # Philip\n    [\"09:00 to 13:00\", \"13:30 to 15:30\", \"16:00 to 17:00\"],  # Jordan\n]\n\n# Define work hours and meeting duration\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_372"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time strings to minutes since 9:00 (work_hours_start)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - work_hours_start) * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = work_hours_start + (minutes // 60)\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy_intervals = []\n    for schedule in participants_schedules:\n        busy_intervals = []\n        for busy in schedule:\n            start, end = busy.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            busy_intervals.append((start_min, end_min))\n        all_busy_intervals.append(busy_intervals)\n    \n    # Merge all busy intervals into a single list\n    merged_busy = []\n    for intervals in all_busy_intervals:\n        merged_busy.extend(intervals)\n    \n    # Sort the merged intervals by start time\n    merged_busy.sort()\n    \n    # Find the free intervals by checking gaps between busy intervals\n    free_intervals = []\n    previous_end = 0\n    for start, end in merged_busy:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the end of the day\n    total_work_minutes = (work_hours_end - work_hours_start) * 60\n    if previous_end < total_work_minutes:\n        free_intervals.append((previous_end, total_work_minutes))\n    \n    # Now, find the earliest free interval that can accommodate the meeting\n    for interval in free_intervals:\n        start, end = interval\n        if end - start >= duration_minutes:\n            # Check if this interval is free for all participants\n            all_free = True\n            for participant_intervals in all_busy_intervals:\n                participant_free = True\n                for busy_start, busy_end in participant_intervals:\n                    if not (end <= busy_start or start >= busy_end):\n                        participant_free = False\n                        break\n                if not participant_free:\n                    all_free = False\n                    break\n            if all_free:\n                return f\"{minutes_to_time(start)}:{minutes_to_time(start + duration_minutes)}\"\n    \n    return \"No suitable time found\"\n\n# Define work hours and meeting duration\nwork_hours_start = 9\nwork_hours_end = 17\nduration_minutes = 30\n\n# Define each participant's busy intervals\nparticipants_schedules = [\n    [],  # Julia\n    [\"9:00 to 9:30\", \"10:00 to 11:00\", \"12:00 to 12:30\"],  # Joseph\n    [\"9:30 to 10:00\", \"12:30 to 13:00\", \"14:00 to 16:00\"],  # Donna\n    [\"9:30 to 11:00\", \"11:30 to 12:00\", \"12:30 to 14:00\", \"15:00 to 16:30\"],  # Bruce\n    [\"9:00 to 9:30\", \"10:30 to 11:30\", \"12:30 to 13:00\", \"14:00 to 15:30\", \"16:00 to 16:30\"],  # Bobby\n    [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:30 to 12:00\", \"13:00 to 13:30\", \"14:00 to 14:30\", \"15:00 to 16:30\"],  # Arthur\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_373"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(schedules, duration, start_hour, end_hour):\n    # Convert all busy times to minutes since start_hour\n    start_min = start_hour * 60\n    end_min = end_hour * 60\n    busy_intervals = []\n    \n    for person in schedules:\n        for busy in schedules[person]:\n            start = busy[0].split(':')\n            end = busy[1].split(':')\n            start_busy = int(start[0]) * 60 + int(start[1])\n            end_busy = int(end[0]) * 60 + int(end[1])\n            busy_intervals.append((start_busy, end_busy))\n    \n    # Sort all busy intervals\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                new_end = max(last_end, current_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append(interval)\n    \n    # Find the earliest available slot\n    prev_end = start_min\n    for interval in merged:\n        current_start, current_end = interval\n        if current_start - prev_end >= duration:\n            return (prev_end, prev_end + duration)\n        prev_end = max(prev_end, current_end)\n    \n    # Check after the last busy interval\n    if end_min - prev_end >= duration:\n        return (prev_end, prev_end + duration)\n    \n    return None\n\n# Define the schedules\nschedules = {\n    'Lori': [('9:30', '10:00'), ('11:00', '11:30'), ('12:00', '12:30'), ('13:30', '14:30'), ('16:30', '17:00')],\n    'Victoria': [],\n    'Natalie': [],\n    'Pamela': [('9:30', '10:30'), ('11:00', '12:00'), ('13:00', '13:30'), ('14:00', '15:00'), ('16:30', '17:00')],\n    'Justin': [('9:00', '10:00'), ('10:30', '11:30'), ('12:00', '13:00'), ('13:30', '15:00'), ('15:30', '17:00')],\n    'Martha': [('9:00', '11:30'), ('12:30', '13:00'), ('13:30', '15:00'), ('15:30', '16:00')]\n}\n\nduration = 30  # minutes\nstart_hour = 9\nend_hour = 17\n\nmeeting_time = find_meeting_time(schedules, duration, start_hour, end_hour)\n\nif meeting_time:\n    start = meeting_time[0]\n    end = meeting_time[1]\n    start_hh = start // 60\n    start_mm = start % 60\n    end_hh = end // 60\n    end_mm = end % 60\n    print(f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_374"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time slots to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Function to subtract busy slots from free slots\n    def subtract_busy_slots(free_slots, busy_start, busy_end):\n        new_free_slots = []\n        for slot_start, slot_end in free_slots:\n            if busy_end <= slot_start or busy_start >= slot_end:\n                # No overlap, keep the slot as is\n                new_free_slots.append((slot_start, slot_end))\n            else:\n                # There is an overlap, split the free slot\n                if slot_start < busy_start:\n                    new_free_slots.append((slot_start, busy_start))\n                if slot_end > busy_end:\n                    new_free_slots.append((busy_end, slot_end))\n        return new_free_slots\n    \n    # Process each participant's busy slots\n    for participant, busy_slots in participants_schedules.items():\n        for busy_start_str, busy_end_str in busy_slots:\n            busy_start = time_to_minutes(busy_start_str)\n            busy_end = time_to_minutes(busy_end_str)\n            free_slots = subtract_busy_slots(free_slots, busy_start, busy_end)\n    \n    # Find the first free slot that can accommodate the meeting duration\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = {\n    \"Julie\": [(\"12:00\", \"12:30\"), (\"13:30\", \"14:00\"), (\"15:00\", \"16:00\")],\n    \"Sara\": [(\"11:00\", \"11:30\"), (\"15:00\", \"15:30\")],\n    \"Donna\": [(\"10:30\", \"11:00\"), (\"12:30\", \"13:30\"), (\"14:30\", \"15:00\")],\n    \"Keith\": [(\"09:00\", \"16:00\")],\n    \"Dylan\": [(\"09:00\", \"09:30\"), (\"10:00\", \"10:30\"), (\"11:00\", \"12:30\"), (\"13:30\", \"16:00\")],\n    \"Jose\": [(\"09:00\", \"10:30\"), (\"12:00\", \"14:30\"), (\"15:30\", \"16:30\")]\n}\n\n# Define work hours and meeting duration\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_375"
        },
        {
            "final_program_time": "{11:30:11:31}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = (minutes + 540) // 60\n        mm = (minutes + 540) % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    # Initialize the free slots for the day (9:00-17:00 is 480 minutes)\n    free_slots = [True] * 480  # 9:00-17:00 (8 hours = 480 minutes)\n\n    # Mark busy times for each participant\n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            start = time_to_minutes(busy_start)\n            end = time_to_minutes(busy_end)\n            # Clamp to work hours\n            start = max(0, start)\n            end = min(480, end)\n            for i in range(start, end):\n                if i < 480:\n                    free_slots[i] = False\n\n    # Find the first available slot of duration\n    required_slots = duration // 30  # Assuming 30-minute intervals\n    current_streak = 0\n    for i in range(480):\n        if free_slots[i]:\n            current_streak += 1\n            if current_streak >= required_slots:\n                start_time = i - current_streak + 1\n                end_time = i + 1\n                start_str = minutes_to_time(start_time)\n                end_str = minutes_to_time(end_time)\n                return f\"{start_str}:{end_str}\"\n        else:\n            current_streak = 0\n\n    return \"No available slot\"\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 30  # minutes\n\n# Define participants' schedules\nparticipants_schedules = [\n    [(\"12:00\", \"13:00\"), (\"14:30\", \"15:30\")],  # Larry\n    [(\"10:30\", \"11:00\"), (\"14:30\", \"15:00\")],  # Angela\n    [],                                         # Christina\n    [(\"9:30\", \"10:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"14:30\"), (\"15:00\", \"16:00\")],  # Scott\n    [(\"9:30\", \"11:30\"), (\"12:00\", \"15:00\"), (\"16:00\", \"17:00\")],  # Matthew\n    [(\"9:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"13:30\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:30\")]  # Charlotte\n]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_376"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert all schedules to minutes for easier comparison\n    # Each person's busy times are represented as (start, end) in minutes\n    busy_times = {\n        'Rebecca': [(13 * 60, 13 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n        'Peter': [\n            (9 * 60, 9 * 60 + 30),\n            (10 * 60 + 30, 11 * 60 + 30),\n            (12 * 60 + 30, 13 * 60),\n            (14 * 60, 14 * 60 + 30),\n            (15 * 60, 16 * 60),\n            (16 * 60 + 30, 17 * 60)\n        ],\n        'Lawrence': [\n            (9 * 60, 9 * 60 + 30),\n            (10 * 60, 11 * 60),\n            (12 * 60, 13 * 60),\n            (13 * 60 + 30, 14 * 60),\n            (14 * 60 + 30, 15 * 60),\n            (16 * 60 + 30, 17 * 60)\n        ],\n        'Randy': [\n            (9 * 60, 9 * 60 + 30),\n            (10 * 60, 11 * 60 + 30),\n            (12 * 60, 13 * 60),\n            (13 * 60 + 30, 15 * 60 + 30),\n            (16 * 60, 17 * 60)\n        ]\n    }\n    \n    # Randy's preference: not after 10:30 (10:30 = 10*60 + 30)\n    randy_preference_end = 10 * 60 + 30\n    \n    # Generate all possible 30-minute slots within work hours\n    for start in range(work_start, work_end - 30 + 1):\n        end = start + 30\n        # Check if the slot is within Randy's preference\n        if end > randy_preference_end:\n            continue\n        # Check if the slot is free for everyone\n        all_free = True\n        for person, busy_slots in busy_times.items():\n            for busy_start, busy_end in busy_slots:\n                if not (end <= busy_start or start >= busy_end):\n                    all_free = False\n                    break\n            if not all_free:\n                break\n        if all_free:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = end // 60\n            end_mm = end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_377"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy slots in minutes\n    busy_slots = {\n        'Marie': [(11 * 60, 11 * 60 + 30), (12 * 60 + 30, 15 * 60)],\n        'Mark': [(11 * 60 + 30, 12 * 60 + 30), (15 * 60 + 30, 16 * 60 + 30)],\n        'Patrick': [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 11 * 60), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60), (16 * 60, 17 * 60)],\n        'Julie': [(9 * 60, 10 * 60), (11 * 60, 11 * 60 + 30), (12 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 17 * 60)],\n        'Emma': [(9 * 60, 10 * 60), (10 * 60 + 30, 12 * 60 + 30), (13 * 60 + 30, 15 * 60), (15 * 60 + 30, 17 * 60)],\n        'Daniel': [(9 * 60, 10 * 60), (11 * 60, 12 * 60), (13 * 60 + 30, 15 * 60), (16 * 60 + 30, 17 * 60)],\n    }\n    \n    # Patrick's constraint: no meetings after 12:00\n    patrick_constraint = 12 * 60\n    \n    # Combine all busy slots\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n    \n    # Add Patrick's constraint as a busy slot for everyone\n    all_busy.append((patrick_constraint, work_end))\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by merging busy intervals\n    free_slots = []\n    prev_end = work_start\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Check each free slot for 30-minute availability\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert start time back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_time = start + meeting_duration\n            end_hh = end_time // 60\n            end_mm = end_time % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_378"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:9:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_start, work_end, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 (9:00)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    all_busy = []\n    for busy_list in participants_busy:\n        for busy in busy_list:\n            start, end = busy.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            all_busy.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots between merged busy intervals\n    available = []\n    prev_end = work_start_min\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        available.append((prev_end, work_end_min))\n    \n    # Check each available slot for sufficient duration\n    for slot in available:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' busy times\nparticipants_busy = [\n    [\"10:30 to 11:30\", \"13:00 to 13:30\", \"14:30 to 15:00\"],  # Carolyn\n    [\"14:30 to 15:00\", \"16:30 to 17:00\"],  # Russell\n    [\"10:00 to 10:30\", \"16:30 to 17:00\"],  # Emma\n    [\"9:30 to 10:30\", \"11:00 to 11:30\", \"12:30 to 14:30\", \"15:30 to 17:00\"],  # Maria\n    [\"9:30 to 10:30\", \"11:00 to 11:30\", \"12:00 to 14:00\", \"15:00 to 15:30\"],  # Mason\n    [\"10:00 to 12:30\", \"13:00 to 13:30\", \"15:00 to 16:00\"],  # Hannah\n]\n\nwork_start = \"9:00\"\nwork_end = \"17:00\"\nduration = 0.5  # half an hour\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, work_start, work_end, duration))\n```",
            "count": "calendar_scheduling_example_379"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes, work_start, work_end):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration = duration_minutes\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start_min = time_to_minutes(busy[0])\n            end_min = time_to_minutes(busy[1])\n            all_busy.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start_min\n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n    \n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Adam has no meetings\n    [(\"10:00\", \"11:00\"), (\"12:00\", \"13:00\"), (\"15:30\", \"16:30\")],  # Jacqueline\n    [(\"09:30\", \"10:30\"), (\"11:00\", \"11:30\"), (\"13:30\", \"14:00\"), (\"15:00\", \"15:30\"), (\"16:00\", \"16:30\")],  # Denise\n    [(\"09:30\", \"10:30\"), (\"11:00\", \"13:00\"), (\"14:00\", \"15:00\"), (\"15:30\", \"16:30\")],  # Kimberly\n    [(\"09:30\", \"10:30\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:30\"), (\"14:00\", \"16:00\"), (\"16:30\", \"17:00\")],  # Ann\n    [(\"09:30\", \"10:30\"), (\"11:30\", \"12:30\"), (\"13:00\", \"14:30\"), (\"16:00\", \"16:30\")],  # Steven\n]\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, 30, \"09:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_380"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the free slots for the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Function to subtract busy slots from free slots\n    def subtract_busy_slots(free_slots, busy_start, busy_end):\n        new_free_slots = []\n        for slot_start, slot_end in free_slots:\n            if busy_end <= slot_start or busy_start >= slot_end:\n                new_free_slots.append((slot_start, slot_end))\n            else:\n                if slot_start < busy_start:\n                    new_free_slots.append((slot_start, busy_start))\n                if slot_end > busy_end:\n                    new_free_slots.append((busy_end, slot_end))\n        return new_free_slots\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        for busy_start_str, busy_end_str in schedule:\n            busy_start = time_to_minutes(busy_start_str)\n            busy_end = time_to_minutes(busy_end_str)\n            free_slots = subtract_busy_slots(free_slots, busy_start, busy_end)\n    \n    # Find the first free slot that can accommodate the meeting duration\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    return None\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\n# Define participants' schedules\nparticipants_schedules = [\n    [(\"9:30\", \"10:30\"), (\"12:30\", \"13:00\"), (\"15:30\", \"16:00\")],  # Larry\n    [(\"11:00\", \"11:30\"), (\"16:00\", \"16:30\")],  # Julie\n    [(\"9:00\", \"9:30\"), (\"16:00\", \"16:30\")],  # Jason\n    [(\"10:00\", \"10:30\"), (\"11:00\", \"11:30\"), (\"12:00\", \"13:30\"), (\"15:00\", \"16:30\")],  # Mason\n    [(\"9:00\", \"11:30\"), (\"12:00\", \"14:00\"), (\"14:30\", \"17:00\")],  # Alan\n    [(\"9:30\", \"10:00\"), (\"11:30\", \"13:00\"), (\"13:30\", \"14:00\"), (\"14:30\", \"15:30\"), (\"16:00\", \"16:30\")]  # Bruce\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_381"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_hour, end_hour = work_hours\n    # Convert work hours to minutes for easier calculation\n    start_time = start_hour * 60\n    end_time = end_hour * 60\n    \n    # Initialize a list to keep track of busy times for all participants\n    busy_times = []\n    \n    for schedule in participants_schedules:\n        person_busy = []\n        for block in schedule:\n            start_block = block[0] * 60\n            end_block = block[1] * 60\n            person_busy.append((start_block, end_block))\n        busy_times.append(person_busy)\n    \n    # Check every possible time slot within work hours\n    for time in range(start_time, end_time - duration + 1):\n        end_slot = time + duration\n        valid = True\n        # Check against each participant's schedule\n        for person in busy_times:\n            person_valid = True\n            for block_start, block_end in person:\n                if not (end_slot <= block_start or time >= block_end):\n                    person_valid = False\n                    break\n            if not person_valid:\n                valid = False\n                break\n        if valid:\n            # Convert back to HH:MM format\n            start_hh = time // 60\n            start_mm = time % 60\n            end_hh = end_slot // 60\n            end_mm = end_slot % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No valid time found\"\n\n# Define participants' schedules in 24-hour format (HH.HH)\nparticipants_schedules = [\n    [(13.0, 14.5), (16.5, 17.0)],  # Debra\n    [],                             # Ryan\n    [(12.0, 12.5), (14.0, 15.0), (15.5, 16.0)],  # Maria\n    [(9.5, 10.0), (11.0, 13.0), (13.5, 15.0), (15.5, 16.5)],  # Timothy\n    [(10.0, 11.0), (12.5, 13.0), (14.0, 15.0), (15.5, 17.0)],  # Pamela\n    [(9.5, 11.0), (11.5, 14.0), (14.5, 15.5), (16.0, 17.0)],   # Ethan\n]\n\nwork_hours = (9, 17)  # 9:00 to 17:00\nduration = 30  # minutes\n\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_382"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each person's busy slots to minutes\n    busy_slots = {\n        'Diane': [(10 * 60, 10 * 60 + 30), (14 * 60 + 30, 15 * 60)],\n        'Rachel': [(11 * 60 + 30, 12 * 60), (13 * 60, 13 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Amber': [(9 * 60, 9 * 60 + 30), (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60), (15 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Shirley': [(10 * 60, 11 * 60), (11 * 60 + 30, 12 * 60), (13 * 60 + 30, 14 * 60), (15 * 60, 17 * 60)],\n        'Joshua': [(9 * 60, 10 * 60 + 30), (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 15 * 60), (16 * 60, 16 * 60 + 30)],\n        'Lisa': [(9 * 60 + 30, 10 * 60), (12 * 60 + 30, 14 * 60), (15 * 60, 17 * 60)]\n    }\n    \n    # Collect all busy slots\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the earliest free slot that is at least 30 minutes long\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = (start + meeting_duration) // 60\n            end_mm = (start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_383"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each person's busy slots to minutes\n    busy_slots = {\n        'Stephen': [(11 * 60, 12 * 60)],\n        'Diane': [(9 * 60 + 30, 10 * 60), (11 * 60 + 30, 12 * 60), (13 * 60, 14 * 60), (15 * 60 + 30, 16 * 60 + 30)],\n        'Joe': [(12 * 60 + 30, 13 * 60), (14 * 60 + 30, 15 * 60)],\n        'Diana': [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 11 * 60 + 30), (12 * 60 + 30, 16 * 60)],\n        'Julia': [(9 * 60 + 30, 12 * 60), (12 * 60 + 30, 17 * 60)],\n        'Stephanie': [(9 * 60, 11 * 60), (11 * 60 + 30, 12 * 60), (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)],\n    }\n    \n    # Combine all busy slots\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n    \n    # Sort busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the time after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that is at least 30 minutes long\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = (start + meeting_duration) // 60\n            end_mm = (start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_384"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_start, work_end):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find the earliest available slot\n    prev_end = work_start_min\n    for start, end in all_busy:\n        if start > prev_end:\n            available_start = prev_end\n            available_end = start\n            if available_end - available_start >= duration_min:\n                return (minutes_to_time(available_start), \n                        minutes_to_time(available_start + duration_min))\n        prev_end = max(prev_end, end)\n    \n    # Check the slot after the last busy interval\n    if work_end_min - prev_end >= duration_min:\n        return (minutes_to_time(prev_end), \n                minutes_to_time(prev_end + duration_min))\n    \n    return None\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"12:00 to 12:30\", \"13:00 to 14:00\", \"14:30 to 15:00\"],  # Noah\n    [\"10:30 to 11:30\", \"12:30 to 13:00\", \"14:00 to 15:00\", \"16:00 to 16:30\"],  # Jesse\n    [\"10:00 to 10:30\", \"11:30 to 12:00\"],  # Amy\n    [\"9:30 to 10:30\", \"11:00 to 12:00\", \"12:30 to 13:30\", \"14:00 to 15:00\", \"15:30 to 16:30\"],  # Timothy\n    [\"9:00 to 11:00\", \"13:00 to 14:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"],  # Eugene\n    [\"9:00 to 10:00\", \"10:30 to 13:00\", \"13:30 to 15:00\", \"16:00 to 17:00\"],  # Theresa\n]\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, 30, \"9:00\", \"17:00\")\nif meeting_time:\n    print(f\"{meeting_time[0]}:{meeting_time[1]}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_385"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Define participants' schedules and constraints\n    schedules = {\n        'Bryan': [(9.5 * 60, 10 * 60), (13.5 * 60, 14.5 * 60), (15 * 60, 16.5 * 60)],\n        'Matthew': [(9 * 60, 9.5 * 60), (10.5 * 60, 12 * 60), (14 * 60, 14.5 * 60), (15.5 * 60, 16 * 60)],\n        'Margaret': [(9 * 60, 9.5 * 60), (10.5 * 60, 12 * 60), (12.5 * 60, 13 * 60), (13.5 * 60, 14.5 * 60), (15 * 60, 15.5 * 60)],\n        'Donald': [(9 * 60, 10 * 60), (10.5 * 60, 13.5 * 60), (14 * 60, 14.5 * 60), (15.5 * 60, 17 * 60)],\n        'Jason': [(9 * 60, 10 * 60), (12 * 60, 12.5 * 60), (13 * 60, 13.5 * 60), (15 * 60, 17 * 60)],\n    }\n    \n    # Jason's constraint: not before 10:30\n    jason_constraint = 10.5 * 60\n    \n    # Meeting duration in minutes\n    duration = 30\n    \n    # Collect all busy intervals\n    busy_intervals = []\n    for person, intervals in schedules.items():\n        for start, end in intervals:\n            busy_intervals.append((start, end))\n    \n    # Add Jason's constraint as a busy interval if needed\n    if jason_constraint > work_start:\n        busy_intervals.append((work_start, jason_constraint))\n    \n    # Sort intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find free slots\n    free_slots = []\n    previous_end = work_start\n    for start, end in merged:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Format the output as HH:MM:HH:MM\n            start_hh = int(meeting_start // 60)\n            start_mm = int(meeting_start % 60)\n            end_hh = int(meeting_end // 60)\n            end_mm = int(meeting_end % 60)\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_386"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(schedules, duration, start_hour, end_hour):\n    # Convert work hours to minutes\n    work_start = start_hour * 60\n    work_end = end_hour * 60\n    \n    # Initialize a list to track busy times for all participants\n    all_busy = []\n    \n    # Collect all busy intervals for each participant\n    for person in schedules:\n        for interval in schedules[person]:\n            start, end = interval\n            all_busy.append((start[0] * 60 + start[1], end[0] * 60 + end[1]))\n    \n    # Sort all busy intervals\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots between work hours and busy times\n    available = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n    \n    # Check each available slot for sufficient duration\n    for start, end in available:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time slot found\"\n\n# Define the schedules for each participant\nschedules = {\n    \"Bruce\": [\n        ((9, 0), (9, 30)),\n        ((10, 0), (11, 0)),\n        ((12, 30), (13, 0)),\n        ((14, 0), (14, 30)),\n        ((16, 0), (16, 30))\n    ],\n    \"Dorothy\": [],\n    \"Joyce\": [],\n    \"Jessica\": [\n        ((11, 30), (13, 0)),\n        ((13, 30), (14, 0)),\n        ((14, 30), (16, 30))\n    ],\n    \"Aaron\": [\n        ((9, 0), (10, 30)),\n        ((11, 30), (12, 0)),\n        ((13, 0), (13, 30)),\n        ((14, 30), (15, 30)),\n        ((16, 0), (16, 30))\n    ],\n    \"Kathryn\": [\n        ((9, 0), (9, 30)),\n        ((10, 0), (10, 30)),\n        ((12, 30), (14, 0)),\n        ((14, 30), (17, 0))\n    ]\n}\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\n# Work hours (9:00 to 17:00)\nstart_hour = 9\nend_hour = 17\n\n# Find the meeting time\nmeeting_time = find_meeting_time(schedules, duration, start_hour, end_hour)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_387"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours=('09:00', '17:00')):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    work_start, work_end = map(time_to_minutes, work_hours)\n    busy_slots = []\n\n    # Collect all busy slots from each participant\n    for schedule in participants_schedules.values():\n        for busy_start, busy_end in schedule:\n            start = time_to_minutes(busy_start)\n            end = time_to_minutes(busy_end)\n            busy_slots.append((start, end))\n\n    # Sort all busy slots by start time\n    busy_slots.sort()\n\n    # Merge overlapping or adjacent busy slots\n    merged_slots = []\n    for start, end in busy_slots:\n        if not merged_slots:\n            merged_slots.append([start, end])\n        else:\n            last_start, last_end = merged_slots[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                merged_slots[-1][1] = max(end, last_end)\n            else:\n                merged_slots.append([start, end])\n\n    # Find available slots between work hours and busy slots\n    available_slots = []\n    previous_end = work_start\n\n    for start, end in merged_slots:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n\n    # Find the first available slot that can fit the meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    'Amy': [],\n    'Karen': [('09:30', '10:00'), ('12:30', '13:00')],\n    'Mark': [('10:30', '11:30'), ('13:00', '13:30'), ('15:30', '16:00')],\n    'Madison': [('09:00', '12:00'), ('12:30', '13:30'), ('15:30', '16:00'), ('16:30', '17:00')],\n    'Michelle': [('09:00', '09:30'), ('10:00', '10:30'), ('11:00', '11:30'), ('12:00', '14:00'), ('14:30', '15:00'), ('15:30', '16:30')],\n    'Brandon': [('09:30', '15:00'), ('15:30', '17:00')],\n}\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_388"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    duration = 30        # meeting duration in minutes\n\n    # Convert each participant's busy slots to minutes since 9:00\n    busy_slots = {\n        'Debra': [(11*60, 11*60 + 30), (13*60 + 30, 14*60)],\n        'Sara': [],\n        'Theresa': [(13*60 + 30, 14*60), (15*60 + 30, 16*60)],\n        'Carol': [(9*60, 10*60), (11*60, 11*60 + 30), (12*60, 13*60 + 30), (15*60, 15*60 + 30), (16*60, 16*60 + 30)],\n        'Justin': [(9*60, 9*60 + 30), (10*60, 14*60), (14*60 + 30, 15*60 + 30), (16*60 + 30, 17*60)],\n        'Edward': [(9*60 + 30, 10*60 + 30), (11*60 + 30, 13*60), (13*60 + 30, 14*60), (16*60, 17*60)],\n    }\n\n    # Combine all busy slots and sort them\n    all_busy = []\n    for person in busy_slots.values():\n        all_busy.extend(person)\n    all_busy.sort()\n\n    # Find the earliest available slot\n    current_time = work_start\n    for start, end in all_busy:\n        if current_time + duration <= start:\n            # Found a slot\n            break\n        if end > current_time:\n            current_time = end\n    else:\n        # Check if there's time at the end of the day\n        if current_time + duration <= work_end:\n            pass\n        else:\n            return None  # No slot found (though the problem states there is one)\n\n    # Ensure the slot is within work hours and doesn't conflict with any busy times\n    # Double-check against all individual schedules\n    proposed_start = current_time\n    proposed_end = proposed_start + duration\n\n    for person in busy_slots.values():\n        for start, end in person:\n            if not (proposed_end <= start or proposed_start >= end):\n                # Conflict found, need to move to the next possible slot\n                return find_next_available_slot(all_busy, work_start, work_end, duration)\n\n    # Format the time as HH:MM:HH:MM\n    start_hh = proposed_start // 60\n    start_mm = proposed_start % 60\n    end_hh = proposed_end // 60\n    end_mm = proposed_end % 60\n\n    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\ndef find_next_available_slot(all_busy, work_start, work_end, duration):\n    current_time = work_start\n    for start, end in all_busy:\n        if current_time + duration <= start:\n            return current_time\n        if end > current_time:\n            current_time = end\n    if current_time + duration <= work_end:\n        return current_time\n    return None\n\nmeeting_time = find_meeting_time()\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_389"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration):\n    # Convert all time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 9:00 (0 minutes)\n    \n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Collect all busy times for all participants\n    all_busy_times = []\n    for busy_times in participants_busy_times.values():\n        for busy in busy_times:\n            start, end = busy.split(' to ')\n            all_busy_times.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort busy times by start time\n    all_busy_times.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = work_start\n    for start, end in all_busy_times:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' busy times\nparticipants_busy_times = {\n    \"Katherine\": [\"10:00 to 10:30\", \"11:00 to 11:30\", \"12:30 to 13:30\", \"15:00 to 15:30\", \"16:30 to 17:00\"],\n    \"Justin\": [\"9:00 to 10:30\", \"11:00 to 12:00\", \"12:30 to 13:30\", \"14:30 to 15:00\", \"15:30 to 16:30\"],\n    \"Abigail\": [\"10:30 to 11:00\", \"12:30 to 15:00\", \"15:30 to 16:30\"],\n    \"Kayla\": [\"9:30 to 10:00\", \"11:30 to 12:00\", \"12:30 to 14:00\", \"14:30 to 15:00\", \"15:30 to 16:30\"],\n}\n\n# Jason and Christopher have no meetings, so their busy times are empty\nparticipants_busy_times = {\n    \"Jason\": [],\n    \"Christopher\": [],\n    **participants_busy_times\n}\n\n# Work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nduration = 30  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy_times, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_390"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:30:16:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration_min = duration * 60\n    \n    # Generate all busy intervals for each participant\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration = 0.5  # in hours\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"10:00 to 10:30\", \"12:30 to 13:00\"],  # Bryan\n    [],                                    # Billy\n    [],                                    # Alexander\n    [\"9:00 to 13:00\", \"13:30 to 14:30\", \"15:00 to 15:30\", \"16:00 to 16:30\"],  # Sophia\n    [\"9:00 to 9:30\", \"10:30 to 11:30\", \"12:30 to 13:00\", \"13:30 to 14:00\", \"14:30 to 15:30\", \"16:30 to 17:00\"],  # Larry\n    [\"9:30 to 14:00\", \"14:30 to 15:00\"],  # Nicole\n]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_391"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - work_hours_start * 60\n\n    work_start_min = time_to_minutes(f\"{work_hours_start}:00\")\n    work_end_min = time_to_minutes(f\"{work_hours_end}:00\")\n    \n    # Initialize a list to track busy intervals for all participants\n    all_busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = busy.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            all_busy_intervals.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Find free intervals by inverting busy intervals\n    free_intervals = []\n    prev_end = work_start_min\n    for start, end in all_busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n    \n    # Merge overlapping or adjacent free intervals (not necessary here but good practice)\n    merged_free = []\n    for start, end in free_intervals:\n        if not merged_free:\n            merged_free.append([start, end])\n        else:\n            last_start, last_end = merged_free[-1]\n            if start <= last_end:\n                merged_free[-1] = [last_start, max(last_end, end)]\n            else:\n                merged_free.append([start, end])\n    \n    # Find the first free interval that can accommodate the meeting\n    for start, end in merged_free:\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                total_hh = (minutes + work_hours_start * 60) // 60\n                total_mm = (minutes + work_hours_start * 60) % 60\n                return f\"{total_hh:02d}:{total_mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    return \"No suitable time found\"\n\n# Define work hours and meeting duration\nwork_hours_start = 9\nwork_hours_end = 17\nduration_minutes = 30\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"11:30 to 12:30\", \"14:00 to 14:30\", \"15:30 to 16:00\"],  # Donald\n    [\"10:30 to 11:00\", \"13:00 to 14:00\", \"15:00 to 16:00\", \"16:30 to 17:00\"],  # Alice\n    [\"10:30 to 11:00\", \"12:00 to 12:30\", \"13:00 to 14:00\", \"16:00 to 17:00\"],  # Doris\n    [\"9:00 to 9:30\", \"10:00 to 11:00\", \"12:00 to 12:30\", \"13:00 to 14:00\", \"15:00 to 15:30\", \"16:30 to 17:00\"],  # Jesse\n    [\"9:00 to 11:00\", \"11:30 to 13:00\", \"13:30 to 17:00\"],  # Noah\n    [\"9:00 to 9:30\", \"10:00 to 11:00\", \"12:00 to 12:30\", \"14:30 to 15:00\", \"15:30 to 17:00\"],  # Jerry\n]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_392"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:00:12:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval to see if it can accommodate the meeting\n    meeting_duration_min = meeting_duration * 60\n    for start, end in free_intervals:\n        if end - start >= meeting_duration_min:\n            # Check if all participants are free during this interval\n            all_free = True\n            meeting_start = start\n            meeting_end = start + meeting_duration_min\n            \n            for schedule in participants_schedules:\n                participant_free = True\n                for busy in schedule:\n                    busy_start, busy_end = map(time_to_minutes, busy.split(':'))\n                    if not (meeting_end <= busy_start or meeting_start >= busy_end):\n                        participant_free = False\n                        break\n                if not participant_free:\n                    all_free = False\n                    break\n            \n            if all_free:\n                return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Samantha is free\n    [\"9:00:9:30\", \"11:00:11:30\"],  # Nancy\n    [],  # Steven is free\n    [\"11:00:12:00\", \"13:00:13:30\", \"14:00:16:30\"],  # William\n    [\"9:00:12:00\", \"12:30:13:00\", \"13:30:17:00\"],  # Karen\n    [\"9:00:11:00\", \"11:30:12:00\", \"12:30:13:00\", \"13:30:15:00\", \"15:30:17:00\"],  # Tyler\n]\n\n# Find a meeting time\nmeeting_time = find_meeting_time(participants_schedules, \"9:00\", \"17:00\", 0.5)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_393"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours=('09:00', '17:00')):\n    # Convert work hours to minutes\n    start_work = int(work_hours[0].split(':')[0]) * 60 + int(work_hours[0].split(':')[1])\n    end_work = int(work_hours[1].split(':')[0]) * 60 + int(work_hours[1].split(':')[1])\n    \n    # Initialize busy slots for all participants\n    busy_slots = []\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        participant_busy = []\n        for meeting in schedule:\n            start, end = meeting.split(' to ')\n            start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n            end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n            participant_busy.append((start_min, end_min))\n        busy_slots.append(participant_busy)\n    \n    # Find common free slots\n    for time in range(start_work, end_work - duration_minutes + 1):\n        end_time = time + duration_minutes\n        all_free = True\n        for participant in busy_slots:\n            is_free = True\n            for start, end in participant:\n                if not (end_time <= start or time >= end):\n                    is_free = False\n                    break\n            if not is_free:\n                all_free = False\n                break\n        if all_free:\n            # Format the time as HH:MM\n            start_hh = time // 60\n            start_mm = time % 60\n            end_hh = end_time // 60\n            end_mm = end_time % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Nicole\n    [],  # Randy\n    [\"10:00 to 11:00\"],  # Michelle\n    [\"09:00 to 10:30\", \"11:00 to 11:30\", \"12:00 to 13:30\", \"14:00 to 15:30\"],  # Matthew\n    [\"10:00 to 11:00\", \"11:30 to 12:00\", \"13:00 to 13:30\", \"14:30 to 16:00\", \"16:30 to 17:00\"],  # Andrea\n    [\"09:00 to 09:30\", \"10:30 to 13:30\", \"14:00 to 14:30\", \"15:00 to 17:00\"]  # Douglas\n]\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules))\n```",
            "count": "calendar_scheduling_example_394"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration_minutes):\n    # Convert work hours and busy times to minutes for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Generate all possible time slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + duration_minutes <= work_end:\n        possible_slots.append((current_time, current_time + duration_minutes))\n        current_time += 1  # Check every minute\n    \n    # Check each slot against all participants' busy times\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        valid = True\n        for busy_times in participants_busy_times:\n            for busy_start, busy_end in busy_times:\n                busy_start_min = busy_start[0] * 60 + busy_start[1]\n                busy_end_min = busy_end[0] * 60 + busy_end[1]\n                # Check if slot overlaps with any busy time\n                if not (slot_end <= busy_start_min or slot_start >= busy_end_min):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            # Convert the slot back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No available slot found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (9, 17)\n\n# Define each participant's busy times in HH:MM format\nparticipants_busy_times = [\n    # Jonathan's busy times\n    [\n        ((9, 0), (9, 30)),\n        ((10, 30), (11, 0)),\n        ((13, 0), (13, 30)),\n        ((15, 30), (16, 0))\n    ],\n    # George's busy times\n    [\n        ((9, 0), (9, 30)),\n        ((10, 0), (10, 30)),\n        ((11, 30), (12, 30)),\n        ((15, 0), (15, 30)),\n        ((16, 30), (17, 0))\n    ],\n    # Stephen's busy times\n    [\n        ((9, 0), (9, 30)),\n        ((10, 0), (11, 0)),\n        ((11, 30), (12, 0)),\n        ((12, 30), (13, 0)),\n        ((13, 30), (14, 0)),\n        ((15, 0), (17, 0))\n    ],\n    # Betty's busy times\n    [\n        ((9, 0), (10, 0)),\n        ((10, 30), (11, 0)),\n        ((11, 30), (12, 30)),\n        ((13, 30), (14, 0)),\n        ((15, 0), (16, 0))\n    ],\n    # Frank's busy times\n    [\n        ((9, 0), (11, 30)),\n        ((12, 0), (14, 30)),\n        ((15, 0), (17, 0))\n    ]\n]\n\n# Meeting duration in minutes\nduration = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_395"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to make 9:00 as 0\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Initialize the busy slots for all participants\n    busy_slots = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = busy.split(' to ')\n            busy_start = time_to_minutes(start)\n            busy_end = time_to_minutes(end)\n            busy_slots.append((busy_start, busy_end))\n    \n    # Sort all busy slots by start time\n    busy_slots.sort()\n    \n    # Merge overlapping or adjacent busy slots\n    merged = []\n    for start, end in busy_slots:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy slots and work hours\n    available_slots = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Check each available slot for sufficient duration\n    for slot in available_slots:\n        start, end = slot\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Andrea\n    [\"9:00 to 9:30\", \"14:00 to 14:30\"],  # Jack\n    [\"9:30 to 10:30\", \"13:00 to 14:00\", \"15:00 to 15:30\", \"16:30 to 17:00\"],  # Madison\n    [\"9:30 to 10:30\", \"11:00 to 11:30\", \"12:00 to 13:30\", \"14:30 to 15:30\", \"16:00 to 17:00\"],  # Rachel\n    [\"9:00 to 11:30\", \"12:00 to 16:30\"],  # Douglas\n    [\"9:00 to 9:30\", \"13:00 to 14:00\", \"14:30 to 17:00\"],  # Ryan\n]\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nmeeting_duration = 30  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, meeting_duration))\n```",
            "count": "calendar_scheduling_example_396"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert work hours and schedules to minutes for easier calculation\n    work_start, work_end = work_hours\n    work_start_min = work_start[0] * 60 + work_start[1]\n    work_end_min = work_end[0] * 60 + work_end[1]\n    \n    # Initialize the free slots for all participants\n    free_slots = []\n    for participant in participants_schedules:\n        busy_slots = participants_schedules[participant]\n        participant_free = []\n        prev_end = work_start_min\n        \n        for slot in busy_slots:\n            slot_start = slot[0][0] * 60 + slot[0][1]\n            slot_end = slot[1][0] * 60 + slot[1][1]\n            \n            if prev_end < slot_start:\n                participant_free.append((prev_end, slot_start))\n            prev_end = max(prev_end, slot_end)\n        \n        if prev_end < work_end_min:\n            participant_free.append((prev_end, work_end_min))\n        \n        free_slots.append(participant_free)\n    \n    # Find common free slots across all participants\n    common_free = free_slots[0]\n    for participant_free in free_slots[1:]:\n        new_common_free = []\n        i = j = 0\n        while i < len(common_free) and j < len(participant_free):\n            start = max(common_free[i][0], participant_free[j][0])\n            end = min(common_free[i][1], participant_free[j][1])\n            if start < end:\n                new_common_free.append((start, end))\n            if common_free[i][1] < participant_free[j][1]:\n                i += 1\n            else:\n                j += 1\n        common_free = new_common_free\n    \n    # Find the first slot that can fit the meeting duration\n    for slot in common_free:\n        if slot[1] - slot[0] >= duration:\n            start_hour = slot[0] // 60\n            start_min = slot[0] % 60\n            end_hour = (slot[0] + duration) // 60\n            end_min = (slot[0] + duration) % 60\n            return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n    return \"No suitable time found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours = ((9, 0), (17, 0))\n\n# Define participants' schedules in minutes\nparticipants = {\n    \"Jonathan\": [],\n    \"Matthew\": [((10, 0), (10, 30)), ((14, 0), (14, 30)), ((15, 0), (15, 30)), ((16, 0), (16, 30))],\n    \"Carl\": [((9, 30), (10, 0)), ((13, 30), (14, 0))],\n    \"Ryan\": [((9, 30), (11, 0)), ((11, 30), (12, 30)), ((13, 0), (13, 30)), ((15, 0), (16, 0))],\n    \"Albert\": [((9, 0), (9, 30)), ((10, 0), (12, 30)), ((13, 0), (15, 30)), ((16, 0), (16, 30))],\n    \"Danielle\": [((9, 0), (9, 30)), ((10, 30), (11, 30)), ((12, 30), (14, 30)), ((15, 0), (15, 30))],\n}\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\n\n# Find and print the meeting time\nprint(find_meeting_time(participants, duration, work_hours))\n```",
            "count": "calendar_scheduling_example_397"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:13:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between merged intervals and work hours\n    available_slots = []\n    previous_end = work_start\n    \n    for start, end in merged:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy interval\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    duration = duration_minutes\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"9:00:11:00\", \"13:30:14:00\", \"16:00:16:30\"],  # Doris\n    [\"10:00:12:00\"],                                # Theresa\n    [],                                             # Christian\n    [\"9:30:10:00\", \"11:30:12:00\", \"12:30:13:00\", \"13:30:14:00\", \"14:30:15:00\", \"15:30:17:00\"],  # Terry\n    [\"9:00:10:30\", \"11:00:11:30\", \"12:00:13:00\", \"13:30:14:30\", \"15:00:17:00\"],  # Carolyn\n    [\"9:00:9:30\", \"11:30:12:00\", \"12:30:13:00\", \"14:30:17:00\"]  # Kyle\n]\n\n# Find a 30-minute meeting slot between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, \"9:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_398"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy times to minutes since midnight\n    busy_slots = {\n        'Andrew': [(11 * 60, 11 * 60 + 30), (15 * 60 + 30, 16 * 60)],\n        'Lawrence': [(9 * 60 + 30, 10 * 60), (11 * 60 + 30, 12 * 60)],\n        'Olivia': [(9 * 60, 10 * 60), (11 * 60, 12 * 60), (12 * 60 + 30, 13 * 60 + 30), (14 * 60 + 30, 15 * 60), (16 * 60, 16 * 60 + 30)],\n        'Bruce': [(9 * 60, 11 * 60 + 30), (12 * 60, 13 * 60), (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 16 * 60 + 30)],\n        'Joyce': [(9 * 60 + 30, 12 * 60 + 30), (13 * 60 + 30, 14 * 60 + 30), (15 * 60 + 30, 16 * 60 + 30)],\n    }\n\n    # Combine all busy slots\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n    all_busy.sort()\n\n    # Merge overlapping or adjacent busy slots\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n\n    # Find free slots between work hours and busy times\n    free_slots = []\n    previous_end = work_start\n    for start, end in merged_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can fit the meeting\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_399"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert work hours and busy times to minutes\n    start_work, end_work = work_hours\n    work_start_min = start_work[0] * 60 + start_work[1]\n    work_end_min = end_work[0] * 60 + end_work[1]\n    \n    # Initialize the free slots for the day\n    free_slots = []\n    current_start = work_start_min\n    \n    # Generate all possible busy times across all participants\n    all_busy = []\n    for busy in participants_busy:\n        for slot in busy:\n            start = slot[0][0] * 60 + slot[0][1]\n            end = slot[1][0] * 60 + slot[1][1]\n            all_busy.append((start, end))\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy slots\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Find free slots between merged busy times\n    free_slots = []\n    prev_end = work_start_min\n    for start, end in merged_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        free_slots.append((prev_end, work_end_min))\n    \n    # Check each free slot for duration availability\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            # Convert back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = (slot_start + duration) // 60\n            end_mm = (slot_start + duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return None\n\n# Define work hours (9:00 to 17:00)\nwork_hours = ((9, 0), (17, 0))\n\n# Define busy slots for each participant in HH:MM format\nparticipants_busy = [\n    # Rachel is free\n    [],\n    # Katherine: 10:00-11:00, 12:30-13:00, 14:00-15:00, 16:00-16:30\n    [((10, 0), (11, 0)), ((12, 30), (13, 0)), ((14, 0), (15, 0)), ((16, 0), (16, 30))],\n    # Kelly: 11:30-12:30, 13:00-14:30, 16:00-16:30\n    [((11, 30), (12, 30)), ((13, 0), (14, 30)), ((16, 0), (16, 30))],\n    # Cynthia: 13:30-14:00, 14:30-15:30, 16:00-16:30\n    [((13, 30), (14, 0)), ((14, 30), (15, 30)), ((16, 0), (16, 30))],\n    # Anthony: 9:00-11:00, 12:00-17:00\n    [((9, 0), (11, 0)), ((12, 0), (17, 0))],\n    # Ryan: 9:00-11:00, 12:30-13:30, 14:00-14:30, 15:00-16:30\n    [((9, 0), (11, 0)), ((12, 30), (13, 30)), ((14, 0), (14, 30)), ((15, 0), (16, 30))],\n    # Richard: 9:30-10:30, 12:00-13:30, 15:30-17:00\n    [((9, 30), (10, 30)), ((12, 0), (13, 30)), ((15, 30), (17, 0))]\n]\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_400"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Define busy intervals for each participant in minutes since midnight\n    busy_times = {\n        'Evelyn': [(9 * 60 + 30, 10 * 60), (11 * 60 + 30, 12 * 60)],\n        'Gregory': [(10 * 60, 10 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Vincent': [(10 * 60, 10 * 60 + 30), (11 * 60, 12 * 60), (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60), (15 * 60, 16 * 60 + 30)],\n        'Philip': [(9 * 60, 10 * 60 + 30), (11 * 60, 11 * 60 + 30), (12 * 60, 13 * 60), (15 * 60, 17 * 60)],\n        'William': [(9 * 60, 10 * 60), (11 * 60, 13 * 60), (13 * 60 + 30, 14 * 60 + 30), (15 * 60, 17 * 60)],\n    }\n\n    # William's preference: not after 13:30 (13 * 60 + 30)\n    william_preference_end = 13 * 60 + 30\n\n    # Generate all busy intervals\n    all_busy = []\n    for person in busy_times:\n        for start, end in busy_times[person]:\n            all_busy.append((start, end))\n\n    # Add William's preference as a constraint\n    all_busy.append((william_preference_end, work_end))\n\n    # Sort all busy intervals\n    all_busy.sort()\n\n    # Find free slots\n    free_slots = []\n    prev_end = work_start\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n\n    # Check for a 30-minute slot\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Found a suitable slot\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_401"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:30:15:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        person_busy = []\n        for block in schedule:\n            start, end = map(time_to_minutes, block.split(':'))\n            person_busy.append((start, end))\n        busy_intervals.append(person_busy)\n    \n    # Find all possible meeting start times (every minute in work hours)\n    possible_starts = []\n    for start in range(work_start, work_end - duration + 1):\n        end = start + duration\n        valid = True\n        # Check against each participant's busy intervals\n        for person_busy in busy_intervals:\n            for busy_start, busy_end in person_busy:\n                if not (end <= busy_start or start >= busy_end):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            possible_starts.append(start)\n    \n    if not possible_starts:\n        return \"No available time slot found.\"\n    \n    # Select the earliest possible start time\n    meeting_start = possible_starts[0]\n    meeting_end = meeting_start + duration\n    \n    return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"11:00:11:30\", \"13:00:13:30\", \"15:30:16:00\", \"16:30:17:00\"],  # Samantha\n    [],  # Brian\n    [\"13:30:14:00\", \"16:00:16:30\"],  # Arthur\n    [],  # Matthew\n    [\"09:00:10:00\", \"10:30:11:30\", \"12:00:13:00\", \"14:00:14:30\", \"16:00:16:30\"],  # Marilyn\n    [\"09:30:11:00\", \"11:30:13:30\", \"14:00:14:30\", \"15:00:16:00\"],  # Mark\n    [\"09:30:11:00\", \"11:30:14:30\", \"15:00:15:30\"],  # Andrea\n]\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, \"09:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_402"
        },
        {
            "final_program_time": "{13:00:13:01}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, meeting_duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 9:00 (0 minutes)\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes  # Add back 540 to get actual time\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    # Parse work hours\n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n\n    # Initialize a list to mark busy times\n    time_slots = [False] * (work_end - work_start)\n    \n    # Mark busy times for each participant\n    for participant, schedules in participants_schedules.items():\n        for meeting in schedules:\n            start, end = meeting.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            # Mark all slots in this meeting as busy\n            for i in range(start_min, end_min):\n                if i < len(time_slots):\n                    time_slots[i] = True\n\n    # Find a free slot of meeting_duration (30 minutes)\n    required_slots = meeting_duration // 30\n    current_free = 0\n    for i in range(len(time_slots)):\n        if not time_slots[i]:\n            current_free += 1\n            if current_free >= required_slots:\n                start_slot = i - required_slots + 1\n                start_time = minutes_to_time(start_slot)\n                end_time = minutes_to_time(start_slot + required_slots)\n                return f\"{start_time}:{end_time}\"\n        else:\n            current_free = 0\n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    'Wayne': ['14:30 to 15:00', '15:30 to 16:00'],\n    'Edward': [],\n    'Lauren': [],\n    'Helen': [],\n    'Michael': ['9:00 to 10:00', '10:30 to 11:30', '12:00 to 13:00', '13:30 to 14:30', '16:00 to 17:00'],\n    'Joseph': ['9:00 to 12:00', '14:00 to 14:30', '15:30 to 16:00'],\n    'Vincent': ['9:00 to 10:30', '11:30 to 13:00', '13:30 to 14:00', '14:30 to 17:00'],\n}\n\nwork_hours = '9:00 to 17:00'\nmeeting_duration = 30  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, meeting_duration))\n```",
            "count": "calendar_scheduling_example_403"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:14:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration_min = duration * 60\n\n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n\n    # Process each participant's schedule to find common free slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_slots.append((start, end))\n        # Sort busy slots by start time\n        busy_slots.sort()\n\n        # Merge overlapping or adjacent busy slots\n        merged_busy = []\n        for start, end in busy_slots:\n            if not merged_busy:\n                merged_busy.append((start, end))\n            else:\n                last_start, last_end = merged_busy[-1]\n                if start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged_busy[-1] = (new_start, new_end)\n                else:\n                    merged_busy.append((start, end))\n\n        # Calculate free slots for this participant\n        participant_free = []\n        prev_end = work_start\n        for start, end in merged_busy:\n            if start > prev_end:\n                participant_free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            participant_free.append((prev_end, work_end))\n\n        # Intersect with current free slots\n        new_free_slots = []\n        i = j = 0\n        while i < len(free_slots) and j < len(participant_free):\n            fs_start, fs_end = free_slots[i]\n            pf_start, pf_end = participant_free[j]\n\n            # Find the overlap\n            overlap_start = max(fs_start, pf_start)\n            overlap_end = min(fs_end, pf_end)\n            if overlap_start < overlap_end:\n                new_free_slots.append((overlap_start, overlap_end))\n\n            # Move the pointer which ends first\n            if fs_end < pf_end:\n                i += 1\n            else:\n                j += 1\n\n        free_slots = new_free_slots\n        if not free_slots:\n            return None  # No possible slot\n\n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= duration_min:\n            meeting_end = start + duration_min\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n\n    return None  # No suitable slot found\n\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"09:00:10:00\", \"14:30:15:00\", \"15:30:16:00\"],  # Kayla\n    [\"12:00:12:30\", \"14:00:15:00\", \"16:30:17:00\"],  # Sandra\n    [\"09:30:10:30\", \"11:00:11:30\", \"12:30:13:00\"],  # Ryan\n    [],  # Kathleen\n    [\"09:30:12:00\", \"14:00:14:30\", \"15:00:17:00\"],  # Walter\n    [\"09:00:11:00\", \"11:30:12:00\", \"12:30:13:00\", \"14:00:15:00\"],  # Arthur\n    [\"10:00:11:30\", \"12:00:13:00\", \"14:30:15:30\", \"16:30:17:00\"],  # Heather\n]\n\n# Find a meeting time\nmeeting_time = find_meeting_time(participants_schedules, \"09:00\", \"17:00\", 1)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_404"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:30:16:00}",
            "type_error": "TypeError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_hour, end_hour = work_hours\n    # Convert work hours to minutes for easier calculation\n    start_time = start_hour * 60\n    end_time = end_hour * 60\n    duration_min = duration * 60\n    \n    # Initialize a list to keep track of busy times for all participants\n    busy_times = []\n    \n    for schedule in participants_schedules:\n        personal_busy = []\n        for block in schedule:\n            start_block = block[0] * 60 + block[1]\n            end_block = block[2] * 60 + block[3]\n            personal_busy.append((start_block, end_block))\n        busy_times.append(personal_busy)\n    \n    # Check all possible time slots within work hours\n    for time in range(start_time, end_time - duration_min + 1, 15):  # Check in 15-minute increments\n        end_slot = time + duration_min\n        slot_ok = True\n        for personal_busy in busy_times:\n            for (busy_start, busy_end) in personal_busy:\n                if not (end_slot <= busy_start or time >= busy_end):\n                    slot_ok = False\n                    break\n            if not slot_ok:\n                break\n        if slot_ok:\n            # Convert back to HH:MM format\n            start_hh = time // 60\n            start_mm = time % 60\n            end_hh = end_slot // 60\n            end_mm = end_slot % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No suitable time found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (9, 17)\n\n# Define meeting duration (0.5 hours)\nduration = 0.5\n\n# Define participants' schedules in HH, MM, HH, MM format\nparticipants_schedules = [\n    # Emily\n    [(9, 0, 9, 30), (11, 0, 11, 30), (14, 0, 14, 30), (16, 30, 17, 0)],\n    # Brian\n    [(9, 30, 10, 0), (14, 30, 15, 30), (16, 30, 17, 0)],\n    # Gerald (free)\n    [],\n    # Julia (free)\n    [],\n    # Logan\n    [(9, 0, 10, 0), (11, 0, 14, 0), (16, 0, 17, 0)],\n    # Judith\n    [(9, 0, 11, 0), (11, 30, 13, 0), (15, 0, 15, 30), (16, 0, 17, 0)],\n    # Michael\n    [(9, 0, 9, 30), (10, 0, 11, 0), (11, 30, 12, 30), (13, 0, 15, 30), (16, 0, 17, 0)],\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_405"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 (9:00)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    work_start, work_end = map(time_to_minutes, work_hours.split(' to '))\n    \n    # Collect all busy intervals\n    busy_intervals = []\n    for schedule in participants_schedules.values():\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_end = max(end, last_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find the first available slot\n    prev_end = work_start\n    for start, end in merged:\n        if start - prev_end >= duration:\n            meeting_start = prev_end\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n        prev_end = max(prev_end, end)\n    \n    # Check after last busy interval\n    if work_end - prev_end >= duration:\n        meeting_start = prev_end\n        meeting_end = meeting_start + duration\n        return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"Alan\": [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:00 to 12:30\", \"14:00 to 14:30\"],\n    \"Michael\": [],\n    \"Michelle\": [],\n    \"Roy\": [\"9:30 to 10:00\", \"12:30 to 13:00\", \"13:30 to 14:30\"],\n    \"Judy\": [\"9:00 to 10:30\", \"11:00 to 15:30\", \"16:00 to 17:00\"],\n    \"Natalie\": [\"9:00 to 9:30\", \"11:00 to 12:30\", \"13:00 to 17:00\"],\n    \"Brian\": [\"9:30 to 10:30\", \"11:00 to 12:00\", \"13:30 to 14:00\", \"14:30 to 15:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"]\n}\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_hours = \"9:00 to 17:00\"\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_406"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define busy intervals for each participant in minutes\n    busy_times = {\n        'Alice': [],\n        'Daniel': [(10 * 60, 10 * 60 + 30), (15 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Scott': [(9 * 60, 10 * 60), (12 * 60, 13 * 60), (14 * 60, 14 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Lori': [(12 * 60 + 30, 13 * 60), (16 * 60, 16 * 60 + 30)],\n        'Cynthia': [(9 * 60, 9 * 60 + 30), (11 * 60, 11 * 60 + 30), (12 * 60, 13 * 60), \n                    (13 * 60 + 30, 14 * 60 + 30), (15 * 60 + 30, 16 * 60 + 30)],\n        'Jeffrey': [(9 * 60, 11 * 60 + 30), (12 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Hannah': [(9 * 60, 11 * 60), (12 * 60, 12 * 60 + 30), (13 * 60, 15 * 60), (16 * 60 + 30, 17 * 60)],\n    }\n    \n    # Collect all busy intervals from all participants\n    all_busy = []\n    for person in busy_times:\n        all_busy.extend(busy_times[person])\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by checking gaps between busy intervals\n    free_intervals = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the interval after the last busy interval\n    if previous_end < work_end:\n        free_intervals.append((previous_end, work_end))\n    \n    # Find the first free interval that can accommodate a 30-minute meeting\n    meeting_duration = 30\n    for start, end in free_intervals:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_407"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:13:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_start, work_end, duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Collect all busy intervals for all participants\n    all_busy_intervals = []\n    for busy_times in participants_busy_times.values():\n        for interval in busy_times:\n            start, end = interval.split(' to ')\n            all_busy_intervals.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start_min\n    \n    for start, end in all_busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n    \n    # Find the first free interval that can accommodate the meeting\n    for interval in free_intervals:\n        start, end = interval\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return None\n\n# Define the participants' busy times\nparticipants_busy_times = {\n    \"Noah\": [],\n    \"Teresa\": [\"11:00 to 12:00\", \"14:00 to 15:00\", \"16:00 to 17:00\"],\n    \"Bradley\": [\"9:00 to 9:30\", \"10:00 to 10:30\", \"15:00 to 15:30\", \"16:00 to 16:30\"],\n    \"Philip\": [\"9:00 to 9:30\", \"11:30 to 12:00\", \"12:30 to 13:00\", \"16:30 to 17:00\"],\n    \"Joyce\": [\"9:30 to 10:00\", \"11:30 to 12:30\", \"13:30 to 14:30\", \"15:30 to 17:00\"],\n    \"Ryan\": [\"9:00 to 10:30\", \"11:00 to 11:30\", \"14:00 to 17:00\"],\n    \"Aaron\": [\"10:00 to 12:00\", \"14:00 to 14:30\", \"15:00 to 16:30\"],\n}\n\n# Define work hours and meeting duration\nwork_start = \"9:00\"\nwork_end = \"17:00\"\nduration = 0.5  # half an hour\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_start, work_end, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_408"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each person's busy slots to minutes\n    alan_busy = [(9*60, 9*60+30), (10*60, 11*60), (11*60+30, 12*60)]\n    mason_busy = [(13*60+30, 14*60), (16*60+30, 17*60)]\n    dennis_busy = [(9*60, 9*60+30), (14*60+30, 15*60)]\n    brenda_busy = [(10*60+30, 11*60), (12*60, 13*60+30), (14*60+30, 15*60+30), (16*60, 17*60)]\n    juan_busy = [(9*60+30, 10*60), (10*60+30, 11*60), (11*60+30, 13*60), (14*60+30, 15*60), (16*60, 17*60)]\n    angela_busy = [(9*60, 10*60), (10*60+30, 11*60), (11*60+30, 12*60), (13*60, 14*60), (15*60, 15*60+30), (16*60+30, 17*60)]\n    \n    # Theresa is free all day\n    \n    # Combine all busy slots\n    all_busy = alan_busy + mason_busy + dennis_busy + brenda_busy + juan_busy + angela_busy\n    \n    # Generate free slots by finding gaps between busy slots\n    all_busy_sorted = sorted(all_busy, key=lambda x: x[0])\n    \n    # Initialize free slots\n    free_slots = []\n    prev_end = work_start\n    \n    for busy_start, busy_end in all_busy_sorted:\n        if busy_start > prev_end:\n            free_slots.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n    \n    # Check the end of the day\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Find the first free slot that is at least 30 minutes and meets Mason's preference (before 14:00)\n    meeting_duration = 30\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Check Mason's preference (meeting should end by 14:00)\n            if slot_start + meeting_duration <= 14 * 60:\n                # Format the time as HH:MM:HH:MM\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_hh = (slot_start + meeting_duration) // 60\n                end_mm = (slot_start + meeting_duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    # If no slot before 14:00, find any slot (though problem states solution exists)\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = (slot_start + meeting_duration) // 60\n            end_mm = (slot_start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_409"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Participants' busy times in minutes (start, end)\n    busy_times = {\n        'David': [(9 * 60, 9 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Robert': [(9 * 60 + 30, 10 * 60), (13 * 60, 13 * 60 + 30)],\n        'Christine': [(9 * 60, 10 * 60), (13 * 60, 13 * 60 + 30), (14 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Kelly': [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60), (12 * 60, 12 * 60 + 30), (13 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60)],\n        'Paul': [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 11 * 60), (11 * 60 + 30, 12 * 60), (13 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30), (15 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n    }\n    \n    # Paul's preference: avoid after 11:00 (11 * 60)\n    paul_preference_cutoff = 11 * 60\n    \n    # Collect all busy slots\n    all_busy = []\n    for person in busy_times:\n        for start, end in busy_times[person]:\n            all_busy.append((start, end))\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by merging busy intervals\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Filter free slots that are at least 30 minutes and before Paul's cutoff\n    meeting_duration = 30\n    valid_slots = []\n    \n    for start, end in free_slots:\n        if end - start >= meeting_duration and start < paul_preference_cutoff:\n            valid_slots.append((start, end))\n    \n    # If no slots before Paul's cutoff, look after (though not preferred)\n    if not valid_slots:\n        for start, end in free_slots:\n            if end - start >= meeting_duration:\n                valid_slots.append((start, end))\n    \n    # Select the earliest possible slot\n    if valid_slots:\n        best_start = valid_slots[0][0]\n        best_end = best_start + meeting_duration\n    else:\n        return None\n    \n    # Convert to HH:MM format\n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n    \n    start_time = minutes_to_time(best_start)\n    end_time = minutes_to_time(best_end)\n    \n    return f\"{start_time}:{end_time}\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_410"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each participant's busy slots to minutes\n    busy_slots = {\n        'Edward': [(11*60 + 30, 12*60), (16*60, 16*60 + 30)],\n        'Samantha': [(14*60, 14*60 + 30), (15*60, 15*60 + 30), (16*60, 17*60)],\n        'Jacob': [(11*60 + 30, 13*60 + 30), (16*60, 17*60)],\n        'Vincent': [(9*60 + 30, 10*60), (11*60, 11*60 + 30), (12*60, 12*60 + 30), \n                    (13*60, 13*60 + 30), (15*60, 15*60 + 30), (16*60 + 30, 17*60)],\n        'William': [(9*60, 14*60), (14*60 + 30, 15*60 + 30), (16*60, 17*60)],\n        'Alexander': [(9*60, 10*60 + 30), (11*60, 13*60 + 30), (14*60 + 30, 15*60 + 30), \n                      (16*60, 17*60)],\n        'Dylan': [(9*60 + 30, 12*60), (12*60 + 30, 14*60 + 30), (15*60, 15*60 + 30), \n                  (16*60, 17*60)],\n    }\n    \n    # Combine all busy slots\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n    all_busy.sort()\n    \n    # Find free slots by inverting busy slots\n    free_slots = []\n    prev_end = work_start\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Find the first free slot that can fit 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = (start + meeting_duration) // 60\n            end_mm = (start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_411"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration_min = duration * 60\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration_min:\n            meeting_end = start + duration_min\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"11:30 to 12:00\", \"13:30 to 14:00\", \"15:00 to 15:30\", \"16:00 to 16:30\"],  # Douglas\n    [],                                                                         # Susan\n    [],                                                                         # Donna\n    [\"09:00 to 09:30\", \"12:30 to 13:00\", \"13:30 to 14:00\", \"15:00 to 15:30\"],  # Elizabeth\n    [\"09:00 to 09:30\", \"10:00 to 11:00\", \"11:30 to 12:00\", \"13:00 to 13:30\", \"14:30 to 15:00\", \"15:30 to 16:30\"],  # Ralph\n    [\"09:00 to 10:00\", \"11:30 to 12:30\", \"13:00 to 14:00\", \"14:30 to 15:00\", \"16:00 to 16:30\"],  # Paul\n    [\"09:00 to 09:30\", \"10:00 to 10:30\", \"12:30 to 14:30\", \"15:00 to 15:30\", \"16:30 to 17:00\"],  # Ryan\n]\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, \"09:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_412"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert all time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work_hours start at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = 9 + minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    start_work = time_to_minutes(work_hours[0])\n    end_work = time_to_minutes(work_hours[1])\n    \n    # Initialize a list to track busy intervals for all participants\n    all_busy = []\n    for busy_slots in participants_busy.values():\n        for slot in busy_slots:\n            start = time_to_minutes(slot[0])\n            end = time_to_minutes(slot[1])\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Check for available slots before the first busy interval\n    if merged and merged[0][0] > start_work:\n        available_start = start_work\n        available_end = merged[0][0]\n        if available_end - available_start >= duration:\n            return f\"{minutes_to_time(available_start)}:{minutes_to_time(available_start + duration)}\"\n    \n    # Check for available slots between busy intervals\n    for i in range(1, len(merged)):\n        prev_end = merged[i-1][1]\n        curr_start = merged[i][0]\n        if curr_start - prev_end >= duration:\n            return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + duration)}\"\n    \n    # Check for available slots after the last busy interval\n    if merged and merged[-1][1] < end_work:\n        available_start = merged[-1][1]\n        available_end = end_work\n        if available_end - available_start >= duration:\n            return f\"{minutes_to_time(available_start)}:{minutes_to_time(available_start + duration)}\"\n    \n    # If no busy intervals, the whole day is available\n    if not merged:\n        return f\"{work_hours[0]}:{minutes_to_time(time_to_minutes(work_hours[0]) + duration)}\"\n    \n    return \"No available slot found\"\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 30  # minutes\n\n# Define each participant's busy times\nparticipants_busy = {\n    \"Carl\": [],\n    \"Patrick\": [(\"9:00\", \"9:30\"), (\"11:30\", \"12:00\")],\n    \"Thomas\": [],\n    \"Bryan\": [(\"9:30\", \"10:00\"), (\"12:30\", \"13:00\"), (\"15:00\", \"15:30\"), (\"16:00\", \"16:30\")],\n    \"Matthew\": [(\"9:30\", \"11:00\"), (\"11:30\", \"13:30\"), (\"14:00\", \"14:30\"), (\"15:00\", \"16:00\")],\n    \"Bruce\": [(\"9:00\", \"10:00\"), (\"10:30\", \"11:30\"), (\"12:30\", \"16:30\")],\n    \"William\": [(\"10:00\", \"12:00\"), (\"12:30\", \"13:00\"), (\"14:00\", \"14:30\"), (\"15:30\", \"16:30\")],\n}\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_413"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define each participant's busy times in minutes (start, end)\n    evelyn_busy = [(9*60, 9*60+30), (12*60, 12*60+30), (14*60+30, 15*60), (15*60+30, 16*60)]\n    kelly_busy = [(10*60, 10*60+30), (15*60+30, 17*60)]\n    margaret_busy = [(9*60, 9*60+30), (10*60, 11*60+30), (12*60, 13*60+30), (14*60, 15*60), (16*60+30, 17*60)]\n    lauren_busy = [(9*60+30, 10*60+30), (11*60, 12*60), (12*60+30, 13*60), (14*60+30, 15*60), (16*60, 17*60)]\n    henry_busy = [(9*60+30, 10*60+30), (11*60, 11*60+30), (12*60, 13*60), (15*60, 15*60+30), (16*60, 17*60)]\n    \n    # Combine all busy times\n    all_busy = evelyn_busy + kelly_busy + margaret_busy + lauren_busy + henry_busy\n    \n    # Sort all busy times by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy time\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can accommodate 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_414"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find the earliest available slot\n    current_time = work_start\n    for start, end in all_busy:\n        if start > current_time:\n            # Check if the gap is enough for the meeting\n            if start - current_time >= duration_minutes:\n                meeting_end = current_time + duration_minutes\n                return f\"{minutes_to_time(current_time)}:{minutes_to_time(meeting_end)}\"\n        # Update current_time to the end of this busy interval if it's later\n        if end > current_time:\n            current_time = end\n        # If current_time exceeds work hours, break\n        if current_time >= work_end:\n            break\n    \n    # Check the slot after the last busy interval\n    if work_end - current_time >= duration_minutes:\n        meeting_end = current_time + duration_minutes\n        return f\"{minutes_to_time(current_time)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"10:30 to 11:00\", \"15:00 to 15:30\"],  # Paul\n    [\"10:30 to 11:00\", \"15:30 to 16:00\"],  # Kyle\n    [\"09:00 to 10:00\", \"13:00 to 13:30\", \"14:00 to 14:30\", \"15:30 to 16:00\", \"16:30 to 17:00\"],  # Christian\n    [\"09:00 to 09:30\", \"12:00 to 12:30\", \"14:00 to 15:00\", \"15:30 to 16:30\"],  # Alice\n    [\"10:30 to 15:00\", \"15:30 to 16:00\"],  # Kelly\n    [\"09:00 to 09:30\", \"10:30 to 11:30\", \"12:30 to 14:30\", \"15:00 to 16:00\", \"16:30 to 17:00\"],  # Brian\n    [\"10:30 to 11:30\", \"12:00 to 13:30\", \"14:00 to 15:00\", \"15:30 to 17:00\"],  # James\n]\n\n# Find a 30-minute meeting slot between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, \"09:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_415"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    duration = 30        # meeting duration in minutes\n\n    # Convert each person's busy times to minutes since midnight\n    busy_times = {\n        'Jack': [(9*60 + 30, 10*60), (13*60, 13*60 + 30), (14*60, 15*60), (15*60 + 30, 16*60), (16*60 + 30, 17*60)],\n        'Frank': [(12*60 + 30, 13*60), (13*60 + 30, 14*60)],\n        'Theresa': [],\n        'Ronald': [],\n        'Alexander': [(9*60 + 30, 10*60), (10*60 + 30, 11*60), (11*60 + 30, 12*60 + 30), (13*60, 13*60 + 30), (15*60, 15*60 + 30), (16*60, 17*60)],\n        'Peter': [(9*60 + 30, 10*60), (12*60, 13*60), (13*60 + 30, 15*60), (16*60, 17*60)],\n        'Anthony': [(9*60 + 30, 10*60), (11*60 + 30, 13*60), (13*60 + 30, 15*60), (16*60, 16*60 + 30)],\n    }\n\n    # Ronald's preference: avoid after 11:00 (11*60)\n    ronald_preference_end = 11 * 60\n\n    # Combine all busy times into a single list\n    all_busy = []\n    for person, times in busy_times.items():\n        all_busy.extend(times)\n\n    # Add Ronald's preference as a busy time if needed\n    all_busy.append((ronald_preference_end, work_end))\n\n    # Sort all busy times by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check the time after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_416"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_start=9 * 60, work_end=17 * 60):\n    # Convert all schedules to minutes since midnight for easier comparison\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start_h, start_m = map(int, interval[0].split(':'))\n            end_h, end_m = map(int, interval[1].split(':'))\n            start = start_h * 60 + start_m\n            end = end_h * 60 + end_m\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                new_end = max(last_end, current_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append(interval)\n    \n    # Find the first available slot\n    previous_end = work_start\n    for interval in merged:\n        start, end = interval\n        if start > previous_end:\n            if start - previous_end >= duration_minutes:\n                # Found a slot\n                meeting_start = previous_end\n                meeting_end = meeting_start + duration_minutes\n                return (\n                    f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:\"\n                    f\"{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n                )\n        previous_end = max(previous_end, end)\n    \n    # Check after the last busy interval\n    if work_end - previous_end >= duration_minutes:\n        meeting_start = previous_end\n        meeting_end = meeting_start + duration_minutes\n        return (\n            f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:\"\n            f\"{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n        )\n    \n    return \"No available slot found\"\n\n# Define participants' schedules in HH:MM format\nparticipants_schedules = [\n    [],  # Anthony has no meetings\n    [],  # Teresa is free\n    [(\"10:00\", \"10:30\"), (\"11:30\", \"12:30\"), (\"13:30\", \"14:00\"), (\"16:00\", \"17:00\")],  # Vincent\n    [(\"09:00\", \"09:30\"), (\"10:30\", \"11:00\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:30\"), (\"16:00\", \"16:30\")],  # Kevin\n    [(\"09:00\", \"09:30\"), (\"10:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"14:00\"), (\"15:00\", \"16:30\")],  # Julie\n    [(\"09:30\", \"10:00\"), (\"10:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"13:30\", \"14:00\"), (\"14:30\", \"15:00\"), (\"16:00\", \"16:30\")],  # Tyler\n    [(\"09:00\", \"12:30\"), (\"13:00\", \"14:00\"), (\"14:30\", \"17:00\")],  # Bryan\n]\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules))\n```",
            "count": "calendar_scheduling_example_417"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    duration = 30        # meeting duration in minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    busy_slots = {\n        'Jack': [],\n        'Dylan': [(9*60, 9*60 + 30), (16*60 + 30, 17*60)],\n        'Janice': [(9*60 + 30, 10*60), (12*60, 12*60 + 30), (14*60, 14*60 + 30), (16*60 + 30, 17*60)],\n        'Willie': [(9*60 + 30, 10*60), (11*60 + 30, 12*60), (14*60, 15*60)],\n        'Donna': [(9*60 + 30, 11*60), (11*60 + 30, 13*60), (13*60 + 30, 14*60), (14*60 + 30, 15*60), (16*60, 17*60)],\n        'Peter': [(10*60 + 30, 11*60 + 30), (12*60 + 30, 13*60), (13*60 + 30, 14*60 + 30), (15*60 + 30, 17*60)],\n        'Raymond': [(9*60, 9*60 + 30), (10*60 + 30, 11*60), (12*60 + 30, 13*60 + 30), (14*60 + 30, 15*60), (15*60 + 30, 17*60)],\n    }\n\n    # Collect all busy slots\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n\n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= duration:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = (start + duration) // 60\n            end_mm = (start + duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_418"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define each participant's busy intervals in minutes since 9:00\n    busy_times = {\n        'Shirley': [],\n        'Mary': [(16 * 60, 17 * 60)],\n        'Doris': [(10 * 60 + 30, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (15 * 60, 16 * 60 + 30)],\n        'Daniel': [(9 * 60, 9 * 60 + 30), (10 * 60, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Madison': [(9 * 60, 9 * 60 + 30), (10 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Albert': [(10 * 60, 11 * 60), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60), (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 17 * 60)],\n        'Stephanie': [(9 * 60 + 30, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60, 15 * 60)],\n    }\n    \n    # Combine all busy intervals\n    all_busy = []\n    for person in busy_times:\n        all_busy.extend(busy_times[person])\n    \n    # Sort the busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by inverting the busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Find the first free interval that can accommodate 30 minutes\n    meeting_duration = 30\n    for start, end in free_intervals:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_419"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 (9:00)\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes  # Add 540 to start from 9:00\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    # Initialize the work hours in minutes\n    start_work = time_to_minutes(work_hours[0])\n    end_work = time_to_minutes(work_hours[1])\n    \n    # Initialize a list to keep track of busy intervals\n    busy_intervals = []\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort the busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append([start, end])\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1][1] = max(last_end, end)\n            else:\n                merged.append([start, end])\n    \n    # Find available slots\n    available = []\n    prev_end = start_work\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < end_work:\n        available.append((prev_end, end_work))\n    \n    # Check for a slot that can fit the duration\n    for start, end in available:\n        if end - start >= duration:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No available slot found\"\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 30  # minutes\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"16:00 to 17:00\"],  # Larry\n    [\"9:30 to 10:30\", \"11:30 to 12:30\", \"13:30 to 14:00\", \"16:30 to 17:00\"],  # Elijah\n    [],  # Jean\n    [],  # Jesse\n    [\"9:30 to 10:30\", \"11:30 to 12:00\", \"13:00 to 14:00\", \"15:00 to 16:30\"],  # Walter\n    [\"9:00 to 9:30\", \"10:30 to 11:00\", \"11:30 to 12:30\", \"14:00 to 15:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"],  # Keith\n    [\"9:30 to 11:00\", \"11:30 to 17:00\"],  # Ethan\n]\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_420"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define busy intervals for each participant in minutes\n    busy_schedule = {\n        'Julia': [(10 * 60, 10 * 60 + 30), (12 * 60, 12 * 60 + 30), (13 * 60, 14 * 60), (15 * 60 + 30, 16 * 60 + 30)],\n        'Philip': [(10 * 60, 11 * 60), (12 * 60 + 30, 13 * 60 + 30), (15 * 60, 17 * 60)],\n        'Ashley': [(9 * 60, 11 * 60 + 30), (12 * 60, 14 * 60), (14 * 60 + 30, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Mark': [(9 * 60 + 30, 11 * 60 + 30), (12 * 60 + 30, 14 * 60 + 30), (15 * 60, 16 * 60)],\n    }\n    \n    # Collect all busy intervals\n    all_busy = []\n    for person in busy_schedule:\n        all_busy.extend(busy_schedule[person])\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Find free intervals between work hours and busy intervals\n    free_intervals = []\n    previous_end = work_start\n    \n    for start, end in merged_busy:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_intervals.append((previous_end, work_end))\n    \n    # Check for a free interval of at least 30 minutes\n    meeting_duration = 30\n    for start, end in free_intervals:\n        if end - start >= meeting_duration:\n            # Found a suitable time\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_421"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:30:16:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes, work_start, work_end):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    previous_end = work_start_min\n    \n    for start, end in merged:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy interval and before work end\n    if previous_end < work_end_min:\n        available_slots.append((previous_end, work_end_min))\n    \n    # Find the first available slot that can fit the meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"09:00:10:00\", \"12:00:12:30\", \"13:00:13:30\", \"14:00:15:00\"],  # Julie\n    [\"10:30:11:00\", \"14:30:15:00\"],                                # Ann\n    [],                                                             # Kenneth\n    [],                                                             # Austin\n    [\"09:00:09:30\", \"10:00:12:30\", \"13:00:13:30\", \"15:00:15:30\", \"16:00:17:00\"],  # Edward\n    [\"09:00:15:30\", \"16:30:17:00\"],                                # Christine\n    [\"09:00:10:00\", \"10:30:13:00\", \"13:30:15:30\", \"16:00:16:30\"],  # Carol\n]\n\n# Meeting duration in minutes\nduration_minutes = 30\n\n# Work hours\nwork_start = \"09:00\"\nwork_end = \"17:00\"\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, duration_minutes, work_start, work_end))\n```",
            "count": "calendar_scheduling_example_422"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration_minutes):\n    # Convert work hours and schedules to minutes since start of day\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            all_busy_intervals.append((busy_start * 60, busy_end * 60))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Find free intervals by merging and inverting busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for busy_start, busy_end in all_busy_intervals:\n        if busy_start > prev_end:\n            free_intervals.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability of all participants\n    for interval in free_intervals:\n        start, end = interval\n        if end - start >= duration_minutes:\n            # Check if this interval is free for all participants\n            all_free = True\n            for schedule in participants_schedules:\n                participant_free = True\n                for busy_start, busy_end in schedule:\n                    busy_start_min = busy_start * 60\n                    busy_end_min = busy_end * 60\n                    # Check if the interval overlaps with any busy time\n                    if not (end <= busy_start_min or start >= busy_end_min):\n                        participant_free = False\n                        break\n                if not participant_free:\n                    all_free = False\n                    break\n            if all_free:\n                # Convert start time back to hours and minutes\n                start_hour = start // 60\n                start_min = start % 60\n                end_hour = (start + duration_minutes) // 60\n                end_min = (start + duration_minutes) % 60\n                return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n    \n    return \"No suitable time found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (9, 17)\n\n# Define each participant's busy times in their local timezone\nparticipants_schedules = [\n    [(11, 12), (12.5, 13), (14, 14.5)],  # Frank\n    [(9.5, 10), (11, 11.5), (12.5, 13), (16.5, 17)],  # Julie\n    [],  # Donna\n    [],  # Ronald\n    [(9.5, 10.5), (11, 11.5), (12, 13), (13.5, 14), (14.5, 15), (16, 16.5)],  # Peter\n    [(10, 11), (11.5, 12), (12.5, 13), (14, 16)],  # Nancy\n    [(9.5, 11.5), (12.5, 13.5), (15, 16)],  # Scott\n]\n\n# Meeting duration is 30 minutes\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_423"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:00:16:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n\n    # Initialize the free time slots for all participants\n    free_slots = []\n    for busy_times in participants_busy_times:\n        # Convert busy times to minutes and sort them\n        busy_minutes = []\n        for start, end in busy_times:\n            busy_minutes.append((time_to_minutes(start), time_to_minutes(end)))\n        busy_minutes.sort()\n\n        # Calculate free slots for the participant\n        participant_free_slots = []\n        prev_end = work_start\n        for start, end in busy_minutes:\n            if start > prev_end:\n                participant_free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            participant_free_slots.append((prev_end, work_end))\n        free_slots.append(participant_free_slots)\n\n    # Find common free slots across all participants\n    common_free_slots = free_slots[0]\n    for participant_slots in free_slots[1:]:\n        new_common_slots = []\n        i = j = 0\n        while i < len(common_free_slots) and j < len(participant_slots):\n            slot1_start, slot1_end = common_free_slots[i]\n            slot2_start, slot2_end = participant_slots[j]\n            overlap_start = max(slot1_start, slot2_start)\n            overlap_end = min(slot1_end, slot2_end)\n            if overlap_start < overlap_end:\n                new_common_slots.append((overlap_start, overlap_end))\n            if slot1_end < slot2_end:\n                i += 1\n            else:\n                j += 1\n        common_free_slots = new_common_slots\n\n    # Find the first slot that can accommodate the meeting duration\n    meeting_duration_minutes = meeting_duration * 60\n    for start, end in common_free_slots:\n        if end - start >= meeting_duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration_minutes\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    return None\n\n# Define the participants' busy times\nparticipants_busy_times = [\n    [],  # Julie - free all day\n    [(\"09:30\", \"10:00\"), (\"15:00\", \"15:30\")],  # Marilyn\n    [],  # Olivia - free all day\n    [(\"12:30\", \"13:30\")],  # Emily\n    [(\"09:00\", \"12:00\"), (\"12:30\", \"13:00\"), (\"14:00\", \"16:00\"), (\"16:30\", \"17:00\")],  # Bruce\n    [(\"09:00\", \"14:30\"), (\"15:00\", \"16:00\"), (\"16:30\", \"17:00\")],  # Jeffrey\n    [(\"09:00\", \"10:00\"), (\"11:00\", \"12:30\"), (\"13:30\", \"15:00\"), (\"15:30\", \"16:00\"), (\"16:30\", \"17:00\")],  # Kyle\n]\n\n# Find a meeting time\nmeeting_time = find_meeting_time(participants_busy_times, \"09:00\", \"17:00\", 0.5)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_424"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for schedule in participants_schedules:\n        busy_intervals = []\n        for busy in schedule:\n            start, end = busy.split(' to ')\n            busy_start = time_to_minutes(start)\n            busy_end = time_to_minutes(end)\n            busy_intervals.append((busy_start, busy_end))\n        all_busy_intervals.append(busy_intervals)\n    \n    # Find all possible free intervals common to all participants\n    common_free_intervals = []\n    \n    # Check every minute in the work hours\n    current_time = work_start\n    while current_time + duration_minutes <= work_end:\n        is_free_for_all = True\n        for busy_intervals in all_busy_intervals:\n            is_free = True\n            for (busy_start, busy_end) in busy_intervals:\n                if not (current_time + duration_minutes <= busy_start or current_time >= busy_end):\n                    is_free = False\n                    break\n            if not is_free:\n                is_free_for_all = False\n                break\n        if is_free_for_all:\n            common_free_intervals.append((current_time, current_time + duration_minutes))\n            # Move to the end of this interval to avoid overlapping\n            current_time += duration_minutes\n        else:\n            current_time += 1  # Check next minute\n    \n    if not common_free_intervals:\n        return None\n    \n    # Return the first available interval\n    start, end = common_free_intervals[0]\n    return f\"{minutes_to_time(start)}:{minutes_to_time(end)}\"\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\n# Define each participant's busy intervals\nparticipants_schedules = [\n    [\"9:00 to 9:30\", \"11:00 to 11:30\", \"12:00 to 13:00\", \"15:00 to 16:00\"],  # Judy\n    [\"11:00 to 11:30\", \"14:00 to 14:30\"],  # Alice\n    [\"9:30 to 10:00\", \"13:00 to 14:00\", \"14:30 to 16:00\"],  # Christina\n    [\"13:30 to 14:30\", \"15:30 to 16:30\"],  # Barbara\n    [\"10:00 to 10:30\", \"11:00 to 11:30\", \"12:00 to 13:30\", \"14:00 to 14:30\", \"15:30 to 16:00\", \"16:30 to 17:00\"],  # Sharon\n    [\"9:00 to 10:00\", \"11:00 to 13:30\", \"14:00 to 15:30\"],  # Edward\n    [\"9:00 to 10:30\", \"11:00 to 13:00\", \"13:30 to 17:00\"],  # Sarah\n]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_425"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define each person's busy times in minutes since midnight\n    busy_times = {\n        'Donna': [(10*60, 10*60+30), (11*60, 12*60+30), (13*60, 13*60+30), (14*60+30, 15*60)],\n        'Albert': [(10*60, 10*60+30), (11*60, 11*60+30), (13*60+30, 15*60), (16*60, 16*60+30)],\n        'Jeremy': [],\n        'Grace': [(13*60, 13*60+30), (16*60+30, 17*60)],\n        'Matthew': [(10*60, 10*60+30), (11*60, 11*60+30), (12*60, 15*60), (15*60+30, 16*60+30)],\n        'Jean': [(11*60, 13*60+30), (14*60+30, 15*60+30), (16*60+30, 17*60)],\n        'Dylan': [(9*60, 9*60+30), (10*60, 10*60+30), (11*60+30, 12*60), (12*60+30, 13*60), \n                  (13*60+30, 14*60), (15*60, 15*60+30), (16*60, 17*60)],\n    }\n    \n    # Donna's preference: avoid before 10:00\n    preference_start = 10 * 60\n    \n    # Collect all busy intervals\n    all_busy = []\n    for person in busy_times:\n        all_busy.extend(busy_times[person])\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Filter free intervals based on Donna's preference\n    free_intervals = [(s, e) for s, e in free_intervals if s >= preference_start]\n    \n    # Check each free interval for a 30-minute slot\n    meeting_duration = 30\n    for start, end in free_intervals:\n        if end - start >= meeting_duration:\n            # Found a suitable time\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_426"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:30:10:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 (9:00)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes  # Add back 540 to start from 9:00\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Initialize the busy slots for all participants\n    busy_slots = []\n    for schedule in participants_schedules:\n        person_busy = []\n        for meeting in schedule:\n            start, end = meeting.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            person_busy.append((start_min, end_min))\n        busy_slots.append(person_busy)\n    \n    # Find all possible free slots for each participant\n    free_slots_per_person = []\n    for person_busy in busy_slots:\n        person_free = []\n        prev_end = work_start\n        for start, end in sorted(person_busy):\n            if start > prev_end:\n                person_free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            person_free.append((prev_end, work_end))\n        free_slots_per_person.append(person_free)\n    \n    # Find common free slots across all participants\n    common_free_slots = free_slots_per_person[0]\n    for person_free in free_slots_per_person[1:]:\n        new_common = []\n        i = j = 0\n        while i < len(common_free_slots) and j < len(person_free):\n            slot1_start, slot1_end = common_free_slots[i]\n            slot2_start, slot2_end = person_free[j]\n            start = max(slot1_start, slot2_start)\n            end = min(slot1_end, slot2_end)\n            if start < end:\n                new_common.append((start, end))\n            if slot1_end < slot2_end:\n                i += 1\n            else:\n                j += 1\n        common_free_slots = new_common\n    \n    # Find the first slot that can fit the duration\n    duration_min = duration * 60\n    for start, end in common_free_slots:\n        if end - start >= duration_min:\n            meeting_end = start + duration_min\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"11:30 to 12:00\", \"16:30 to 17:00\"],  # Nancy\n    [],  # Gloria\n    [\"9:00 to 9:30\", \"10:30 to 11:00\", \"11:30 to 12:00\", \"12:30 to 13:00\", \"15:00 to 15:30\", \"16:30 to 17:00\"],  # Harold\n    [],  # Katherine\n    [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:00 to 12:30\", \"13:30 to 15:00\", \"15:30 to 16:30\"],  # Tyler\n    [\"10:00 to 11:00\", \"11:30 to 13:00\", \"13:30 to 14:30\", \"15:00 to 16:00\", \"16:30 to 17:00\"],  # Larry\n    [\"9:00 to 9:30\", \"10:00 to 14:30\", \"15:00 to 17:00\"],  # Mark\n]\n\n# Parameters\nmeeting_duration = 0.5  # half an hour\nwork_hours = \"9:00 to 17:00\"\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, meeting_duration, work_hours))\n```",
            "count": "calendar_scheduling_example_427"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each participant's busy slots to minutes\n    busy_slots = {\n        'Denise': [],\n        'Amber': [(10 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60), (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Charles': [(9 * 60 + 30, 10 * 60), (11 * 60 + 30, 12 * 60 + 30), (13 * 60 + 30, 15 * 60)],\n        'Edward': [(11 * 60 + 30, 12 * 60 + 30), (14 * 60 + 30, 15 * 60), (16 * 60, 16 * 60 + 30)],\n        'Richard': [(9 * 60, 9 * 60 + 30), (11 * 60, 12 * 60 + 30), (14 * 60, 14 * 60 + 30), (15 * 60, 16 * 60 + 30)],\n        'Katherine': [(9 * 60, 11 * 60), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60), (16 * 60, 16 * 60 + 30)],\n        'Russell': [(9 * 60, 12 * 60), (12 * 60 + 30, 13 * 60), (14 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n    }\n    \n    # Collect all busy slots\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check if there's a free slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that is at least 30 minutes long\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = (start + meeting_duration) // 60\n            end_mm = (start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_428"
        },
        {
            "final_program_time": "{13:30:13:32}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - work_hours_start * 60\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = work_hours_start * 60 + minutes\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    # Initialize the availability list (all times initially free)\n    work_hours_total = (work_hours_end - work_hours_start) * 60\n    availability = [True] * work_hours_total\n\n    # Mark busy times for each participant\n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            start_min = time_to_minutes(busy_start)\n            end_min = time_to_minutes(busy_end)\n            for minute in range(start_min, end_min):\n                if minute < len(availability):\n                    availability[minute] = False\n\n    # Find the first available slot of 'duration' minutes\n    required_slots = duration * 2  # assuming 30-minute slots for half-hour\n    current_slot_length = 0\n\n    for minute, is_free in enumerate(availability):\n        if is_free:\n            current_slot_length += 1\n            if current_slot_length >= required_slots:\n                start_minute = minute - current_slot_length + 1\n                end_minute = start_minute + required_slots\n                start_time = minutes_to_time(start_minute)\n                end_time = minutes_to_time(end_minute)\n                return f\"{start_time}:{end_time}\"\n        else:\n            current_slot_length = 0\n\n    return \"No available slot found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours_start = 9\nwork_hours_end = 17\n\n# Define participants' schedules in HH:MM format\nparticipants_schedules = [\n    [(\"13:00\", \"13:30\"), (\"16:00\", \"16:30\")],  # Judy\n    [(\"10:00\", \"10:30\"), (\"12:00\", \"13:00\"), (\"14:00\", \"14:30\")],  # Olivia\n    [],  # Eric (free)\n    [(\"10:00\", \"10:30\"), (\"15:00\", \"15:30\")],  # Jacqueline\n    [(\"9:00\", \"10:00\"), (\"10:30\", \"12:00\"), (\"13:00\", \"13:30\"), (\"14:30\", \"15:00\"), (\"15:30\", \"17:00\")],  # Laura\n    [(\"9:00\", \"10:00\"), (\"11:00\", \"11:30\"), (\"12:30\", \"13:00\"), (\"14:00\", \"14:30\"), (\"15:30\", \"17:00\")],  # Tyler\n    [(\"9:30\", \"10:30\"), (\"11:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"13:30\"), (\"14:00\", \"14:30\"), (\"16:00\", \"17:00\")],  # Lisa\n]\n\n# Duration in half-hour units (1 = 30 minutes)\nduration = 1\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules=participants_schedules, \n                                 duration=duration, \n                                 work_hours_start=work_hours_start, \n                                 work_hours_end=work_hours_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_429"
        },
        {
            "final_program_time": "{12:30:13:30}",
            "expected_time": "{12:30:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert all time slots to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration_min = duration * 60\n\n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n\n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start\n\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Find the first available slot that can accommodate the meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"9:30 to 10:00\", \"16:30 to 17:00\"],  # Jessica\n    [\"9:30 to 10:00\", \"14:00 to 14:30\", \"15:00 to 16:00\"],  # Elijah\n    [\"11:00 to 11:30\", \"16:30 to 17:00\"],  # Ann\n    [],  # Marie\n    [\"9:00 to 10:00\", \"10:30 to 11:00\", \"11:30 to 12:30\", \"14:00 to 15:30\"],  # Kathryn\n    [\"9:00 to 11:00\", \"11:30 to 12:30\", \"16:00 to 17:00\"],  # Albert\n    [\"10:00 to 11:00\", \"12:00 to 12:30\", \"14:00 to 15:00\", \"15:30 to 17:00\"],  # Nicole\n]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, \"9:00\", \"17:00\", 1)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_430"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Participants' schedules and constraints\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30       # 30 minutes\n    \n    # Emma's busy times in minutes (9:30-10:30, 11:00-12:00, 12:30-13:00, 14:00-16:00, 16:30-17:00)\n    emma_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (11 * 60, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Alan's busy times (9:30-10:30, 11:00-17:00)\n    alan_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (11 * 60, 17 * 60)\n    ]\n    \n    # Philip's busy times (9:30-10:30, 11:00-12:30, 13:00-13:30, 14:30-15:00, 16:00-16:30)\n    philip_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (11 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    # William's preference: not before 9:30\n    william_pref_start = 9 * 60 + 30\n    \n    # Combine all busy times and sort them\n    all_busy = emma_busy + alan_busy + philip_busy\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = max(work_hours_start, william_pref_start)\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy time\n    if previous_end < work_hours_end:\n        free_slots.append((previous_end, work_hours_end))\n    \n    # Find the first free slot that can fit the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_431"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start = time_to_minutes(busy[0])\n            end = time_to_minutes(busy[1])\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find the earliest available slot\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available_duration = start - prev_end\n            if available_duration >= duration_minutes:\n                return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + duration_minutes)}\"\n        prev_end = max(prev_end, end)\n    \n    # Check after the last busy interval\n    if work_end - prev_end >= duration_minutes:\n        return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + duration_minutes)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules in HH:MM format\nparticipants_schedules = [\n    [(\"10:00\", \"10:30\"), (\"11:00\", \"11:30\"), (\"12:30\", \"13:30\"), (\"15:00\", \"15:30\"), (\"16:30\", \"17:00\")],  # Grace\n    [(\"10:00\", \"11:00\"), (\"12:30\", \"13:00\"), (\"13:30\", \"14:00\"), (\"14:30\", \"15:00\"), (\"16:00\", \"16:30\")],  # Nicholas\n    [(\"09:00\", \"10:00\"), (\"10:30\", \"12:00\"), (\"16:00\", \"16:30\")],  # Ann\n    [],  # Jacob\n    [(\"09:30\", \"14:00\"), (\"14:30\", \"16:00\")],  # Joe\n    [(\"09:30\", \"11:30\"), (\"12:00\", \"14:00\"), (\"14:30\", \"15:00\"), (\"16:30\", \"17:00\")],  # Stephanie\n    [(\"09:00\", \"14:00\"), (\"14:30\", \"16:30\")],  # Tyler\n]\n\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_432"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    start, end = work_hours\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(start)\n    work_end = time_to_minutes(end)\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's schedule to find common free slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            busy_start = time_to_minutes(busy[0])\n            busy_end = time_to_minutes(busy[1])\n            busy_slots.append((busy_start, busy_end))\n        # Sort the busy slots\n        busy_slots.sort()\n        # Merge overlapping or adjacent busy slots\n        merged_busy = []\n        for slot in busy_slots:\n            if not merged_busy:\n                merged_busy.append(slot)\n            else:\n                last_start, last_end = merged_busy[-1]\n                current_start, current_end = slot\n                if current_start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = last_start\n                    new_end = max(last_end, current_end)\n                    merged_busy[-1] = (new_start, new_end)\n                else:\n                    merged_busy.append(slot)\n        # Now find the free slots by subtracting busy from work hours\n        participant_free = []\n        prev_end = work_start\n        for busy_start, busy_end in merged_busy:\n            if busy_start > prev_end:\n                participant_free.append((prev_end, busy_start))\n            prev_end = max(prev_end, busy_end)\n        if prev_end < work_end:\n            participant_free.append((prev_end, work_end))\n        # Intersect the participant's free slots with the current common free slots\n        new_free_slots = []\n        i = j = 0\n        while i < len(free_slots) and j < len(participant_free):\n            slot_start, slot_end = free_slots[i]\n            part_start, part_end = participant_free[j]\n            # Find the overlap\n            overlap_start = max(slot_start, part_start)\n            overlap_end = min(slot_end, part_end)\n            if overlap_start < overlap_end:\n                new_free_slots.append((overlap_start, overlap_end))\n            # Move the pointer which ends first\n            if slot_end < part_end:\n                i += 1\n            else:\n                j += 1\n        free_slots = new_free_slots\n    \n    # Now find the first slot in free_slots that can fit the duration\n    duration_min = duration * 60\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [],  # Diane\n    [(\"09:30\", \"10:00\"), (\"11:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"13:30\"), (\"15:30\", \"16:00\"), (\"16:30\", \"17:00\")],  # Terry\n    [(\"09:30\", \"11:00\"), (\"15:00\", \"16:30\")],  # Jessica\n    [],  # Peter\n    [(\"09:00\", \"11:30\"), (\"12:00\", \"16:00\"), (\"16:30\", \"17:00\")],  # Gary\n    [(\"10:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"14:00\"), (\"14:30\", \"15:30\")],  # Gabriel\n    [(\"09:00\", \"09:30\"), (\"10:00\", \"11:30\"), (\"12:00\", \"13:00\"), (\"13:30\", \"14:00\"), (\"14:30\", \"17:00\")],  # Amanda\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, 30, (\"09:00\", \"17:00\"))\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_433"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    start, end = work_hours\n    # Convert time strings to minutes for easier calculation\n    start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n    end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules.values():\n        for busy in schedule:\n            busy_start, busy_end = busy\n            busy_start_min = int(busy_start.split(':')[0]) * 60 + int(busy_start.split(':')[1])\n            busy_end_min = int(busy_end.split(':')[0]) * 60 + int(busy_end.split(':')[1])\n            busy_intervals.append((busy_start_min, busy_end_min))\n    \n    # Sort the busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals\n    free_intervals = []\n    previous_end = start_min\n    \n    for start_busy, end_busy in busy_intervals:\n        if start_busy > previous_end:\n            free_intervals.append((previous_end, start_busy))\n        previous_end = max(previous_end, end_busy)\n    \n    if end_min > previous_end:\n        free_intervals.append((previous_end, end_min))\n    \n    # Check each free interval for availability for all participants\n    for free_start, free_end in free_intervals:\n        if free_end - free_start >= duration:\n            # Check if this interval is free for all participants\n            all_free = True\n            for schedule in participants_schedules.values():\n                participant_free = True\n                for busy_start, busy_end in schedule:\n                    busy_start_min = int(busy_start.split(':')[0]) * 60 + int(busy_start.split(':')[1])\n                    busy_end_min = int(busy_end.split(':')[0]) * 60 + int(busy_end.split(':')[1])\n                    if not (free_end <= busy_start_min or free_start >= busy_end_min):\n                        participant_free = False\n                        break\n                if not participant_free:\n                    all_free = False\n                    break\n            if all_free:\n                # Convert back to HH:MM format\n                meeting_start = f\"{free_start // 60:02d}:{free_start % 60:02d}\"\n                meeting_end = f\"{(free_start + duration) // 60:02d}:{(free_start + duration) % 60:02d}\"\n                return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    'Kayla': [('9:00', '9:30'), ('15:00', '15:30')],\n    'Karen': [],\n    'Henry': [('10:00', '10:30'), ('12:00', '12:30'), ('14:00', '14:30'), ('15:30', '16:00')],\n    'Randy': [('10:30', '11:30'), ('12:00', '12:30'), ('16:30', '17:00')],\n    'Stephanie': [('10:00', '11:30'), ('12:00', '13:30'), ('14:30', '16:30')],\n    'Tyler': [('10:00', '11:30'), ('12:00', '13:30'), ('15:00', '15:30'), ('16:30', '17:00')],\n    'Joe': [('9:00', '10:30'), ('11:00', '11:30'), ('12:00', '12:30'), ('13:00', '14:30'), ('15:00', '17:00')]\n}\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_hours = ('9:00', '17:00')\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_434"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time slots to minutes since start of day for easier calculation\n    work_start = work_hours_start[0] * 60 + work_hours_start[1]\n    work_end = work_hours_end[0] * 60 + work_hours_end[1]\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's busy slots\n    for schedule in participants_schedules:\n        new_free_slots = []\n        for busy_start, busy_end in schedule:\n            busy_start_min = busy_start[0] * 60 + busy_start[1]\n            busy_end_min = busy_end[0] * 60 + busy_end[1]\n            for slot_start, slot_end in free_slots:\n                if busy_end_min <= slot_start or busy_start_min >= slot_end:\n                    # No overlap, keep the slot as is\n                    new_free_slots.append((slot_start, slot_end))\n                else:\n                    # There is an overlap, split the slot\n                    if slot_start < busy_start_min:\n                        new_free_slots.append((slot_start, busy_start_min))\n                    if slot_end > busy_end_min:\n                        new_free_slots.append((busy_end_min, slot_end))\n        # Update free_slots to the intersection of current free_slots and new_free_slots\n        free_slots = new_free_slots\n    \n    # Merge overlapping or adjacent slots\n    free_slots.sort()\n    merged_slots = []\n    for slot in free_slots:\n        if not merged_slots:\n            merged_slots.append(slot)\n        else:\n            last_start, last_end = merged_slots[-1]\n            current_start, current_end = slot\n            if current_start <= last_end:\n                # Merge the slots\n                new_slot = (last_start, max(last_end, current_end))\n                merged_slots[-1] = new_slot\n            else:\n                merged_slots.append(slot)\n    \n    # Find the first slot that can fit the meeting\n    duration = duration_minutes\n    for slot_start, slot_end in merged_slots:\n        if slot_end - slot_start >= duration:\n            # Found a suitable slot\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' busy schedules in HH:MM format\nparticipants_schedules = [\n    # Lawrence\n    [( (10, 0), (10, 30) ), ( (13, 30), (14, 0) )],\n    # Shirley - no meetings\n    [],\n    # Alexander\n    [( (9, 30), (10, 0) ), ( (10, 30), (11, 30) ), ( (12, 30), (13, 0) )],\n    # Brian\n    [( (9, 0), (9, 30) ), ( (13, 30), (14, 0) )],\n    # Kathryn\n    [( (9, 0), (15, 0) ), ( (16, 0), (17, 0) )],\n    # Aaron\n    [( (9, 0), (11, 0) ), ( (11, 30), (12, 30) ), ( (13, 0), (13, 30) ), ( (14, 0), (15, 0) ), ( (16, 0), (16, 30) )],\n    # Janice\n    [( (9, 0), (11, 30) ), ( (12, 0), (12, 30) ), ( (13, 0), (15, 0) ), ( (15, 30), (16, 0) ), ( (16, 30), (17, 0) )]\n]\n\n# Define work hours and meeting duration\nwork_hours_start = (9, 0)  # 9:00\nwork_hours_end = (17, 0)    # 17:00\nduration = 30                # 30 minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration))\n```",
            "count": "calendar_scheduling_example_435"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:30:10:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by merging busy intervals\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = min(start, last_start)\n                new_end = max(end, last_end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Find the first available slot\n    previous_end = work_start\n    for start, end in merged_busy:\n        if start - previous_end >= duration_minutes:\n            # Found a slot\n            meeting_start = previous_end\n            meeting_end = meeting_start + duration_minutes\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n        previous_end = max(previous_end, end)\n    \n    # Check after the last busy interval\n    if work_end - previous_end >= duration_minutes:\n        meeting_start = previous_end\n        meeting_end = meeting_start + duration_minutes\n        return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"13:30:14:00\", \"14:30:15:00\"],  # Patrick\n    [\"09:00:09:30\", \"11:00:11:30\", \"12:00:12:30\", \"14:30:15:00\", \"16:00:17:00\"],  # Shirley\n    [\"09:00:09:30\", \"10:30:11:00\", \"11:30:12:00\", \"13:00:13:30\", \"16:00:17:00\"],  # Jeffrey\n    [\"11:30:12:00\", \"15:00:15:30\"],  # Gloria\n    [\"09:00:09:30\", \"10:30:12:00\", \"14:00:17:00\"],  # Nathan\n    [\"09:00:09:30\", \"10:00:11:00\", \"12:30:15:00\", \"15:30:16:30\"],  # Angela\n    [\"09:00:09:30\", \"10:00:10:30\", \"11:00:14:00\", \"14:30:16:30\"],  # David\n]\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, \"09:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_436"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy_times in participants_busy_times.values():\n        for busy in busy_times:\n            start, end = map(time_to_minutes, busy.split(':'))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals\n    all_busy.sort()\n    \n    # Find free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    prev_end = work_start\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > prev_end:\n            free_intervals.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' busy times\nparticipants_busy_times = {\n    \"Gerald\": [\"14:30:15:00\", \"15:30:16:00\"],\n    \"Paul\": [\"10:00:10:30\", \"11:30:12:30\", \"14:00:14:30\", \"15:30:16:00\", \"16:30:17:00\"],\n    \"Donald\": [\"9:00:10:30\", \"12:30:14:00\", \"14:30:15:00\", \"15:30:16:00\"],\n    \"Richard\": [\"9:00:10:30\", \"11:00:12:30\", \"13:00:15:30\", \"16:30:17:00\"],\n    \"Patrick\": [\"9:30:10:30\", \"11:30:12:00\", \"13:00:13:30\", \"15:00:17:00\"],\n    # Joshua and Alice have no busy times\n}\n\n# Work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_437"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each person's busy slots to minutes\n    george_busy = [(11*60 + 30, 12*60), (15*60, 15*60 + 30), (16*60, 17*60)]\n    emma_busy = [(9*60 + 30, 10*60), (11*60, 11*60 + 30), (12*60, 12*60 + 30), (15*60, 15*60 + 30), (16*60, 17*60)]\n    ashley_busy = [(9*60, 9*60 + 30), (10*60, 12*60 + 30), (14*60 + 30, 15*60 + 30)]\n    jose_busy = [(9*60, 11*60), (11*60 + 30, 13*60 + 30), (14*60 + 30, 16*60 + 30)]\n    charles_busy = [(9*60, 10*60), (10*60 + 30, 11*60), (12*60, 14*60), (14*60 + 30, 15*60 + 30), (16*60 + 30, 17*60)]\n    \n    # Combine all busy slots\n    all_busy = george_busy + emma_busy + ashley_busy + jose_busy + charles_busy\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Check each free slot for 30-minute availability\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert start time back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_time = start + meeting_duration\n            end_hh = end_time // 60\n            end_mm = end_time % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_438"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Each participant's busy blocks in minutes since midnight\n    busy_blocks = {\n        'Jeffrey': [(10 * 60 + 30, 11 * 60), (13 * 60 + 30, 14 * 60)],\n        'Nancy': [(11 * 60, 11 * 60 + 30), (14 * 60, 14 * 60 + 30), (15 * 60, 16 * 60)],\n        'Jordan': [(9 * 60, 9 * 60 + 30), (11 * 60 + 30, 12 * 60), (13 * 60 + 30, 14 * 60 + 30)],\n        'Samantha': [(11 * 60 + 30, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Jason': [(9 * 60, 10 * 60 + 30), (11 * 60, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (13 * 60 + 30, 14 * 60), (15 * 60 + 30, 16 * 60 + 30)],\n        'Shirley': [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60), (12 * 60, 13 * 60), (13 * 60 + 30, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Jessica': [(9 * 60 + 30, 10 * 60 + 30), (11 * 60, 11 * 60 + 30), (12 * 60, 15 * 60 + 30)],\n    }\n\n    # Combine all busy blocks and sort them\n    all_busy = []\n    for blocks in busy_blocks.values():\n        all_busy.extend(blocks)\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy blocks\n    free_slots = []\n    previous_end = work_start\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_439"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = meeting_duration\n\n    # Initialize the list of busy intervals for all participants\n    all_busy_intervals = []\n    for busy_times in participants_busy_times:\n        for start, end in busy_times:\n            all_busy_intervals.append((time_to_minutes(start), time_to_minutes(end)))\n\n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n\n    # Merge overlapping or adjacent intervals\n    merged_intervals = []\n    for start, end in all_busy_intervals:\n        if not merged_intervals:\n            merged_intervals.append((start, end))\n        else:\n            last_start, last_end = merged_intervals[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_intervals[-1] = (new_start, new_end)\n            else:\n                merged_intervals.append((start, end))\n\n    # Find available slots by checking gaps between merged intervals and work hours\n    available_slots = []\n    previous_end = work_start\n    for start, end in merged_intervals:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n\n    # Check each available slot for sufficient duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            # Found a suitable slot\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n\n            meeting_start = minutes_to_time(slot_start)\n            meeting_end = minutes_to_time(slot_start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n\n    return \"No suitable time found\"\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 30  # minutes\n\n# Define each participant's busy times in HH:MM format\nparticipants_busy_times = [\n    [(\"11:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"14:30\", \"15:00\"), (\"16:00\", \"16:30\")],  # Alan\n    [],  # Kyle\n    [],  # Zachary\n    [],  # Heather\n    [(\"10:00\", \"12:30\"), (\"13:00\", \"13:30\"), (\"14:00\", \"14:30\"), (\"15:00\", \"16:30\")],  # Joan\n    [(\"10:00\", \"11:00\"), (\"12:00\", \"16:00\")],  # Diane\n    [(\"09:30\", \"11:00\"), (\"12:30\", \"14:00\"), (\"14:30\", \"15:00\"), (\"15:30\", \"17:00\")],  # Julie\n]\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration))\n```",
            "count": "calendar_scheduling_example_440"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for meeting in schedule:\n            start, end = map(time_to_minutes, meeting.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by checking gaps between busy intervals\n    free_intervals = []\n    previous_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the time after the last busy interval until work_end\n    if previous_end < work_end:\n        free_intervals.append((previous_end, work_end))\n    \n    # Now merge free intervals from all participants by finding common free times\n    # Since we need a time when everyone is free, we look for intervals that are free for all\n    # But in this approach, we've combined all busy intervals first, so the free intervals are when no one is busy\n    \n    # Find the first free interval that can fit the meeting duration\n    duration = duration_minutes\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"11:30 to 12:00\", \"14:30 to 15:00\"],  # Joan\n    [\"9:00 to 10:00\", \"14:00 to 14:30\", \"16:00 to 16:30\"],  # Megan\n    [],  # Austin\n    [\"9:30 to 10:00\", \"11:30 to 12:00\", \"13:30 to 14:00\", \"16:00 to 16:30\"],  # Betty\n    [\"9:00 to 11:00\", \"12:00 to 13:00\", \"14:00 to 15:00\"],  # Judith\n    [\"9:30 to 10:00\", \"11:30 to 12:30\", \"13:00 to 14:00\", \"15:00 to 15:30\", \"16:00 to 17:00\"],  # Terry\n    [\"9:30 to 10:00\", \"10:30 to 11:00\", \"11:30 to 13:00\", \"14:00 to 16:00\", \"16:30 to 17:00\"],  # Kathryn\n]\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 30  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_441"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours\n    start_min = time_to_minutes(start_work)\n    end_min = time_to_minutes(end_work)\n    \n    # Initialize a list to mark busy intervals\n    timeline = [0] * (end_min - start_min)\n    \n    # Mark busy times for each participant\n    for schedule in participants_schedules:\n        for busy in schedule:\n            busy_start = time_to_minutes(busy[0])\n            busy_end = time_to_minutes(busy[1])\n            # Clamp to work hours\n            busy_start = max(busy_start, start_min)\n            busy_end = min(busy_end, end_min)\n            for i in range(busy_start - start_min, busy_end - start_min):\n                if i >= 0 and i < len(timeline):\n                    timeline[i] += 1\n    \n    # Find the first interval where all are free (timeline[i] == 0)\n    required_slots = duration\n    current_free = 0\n    for i in range(len(timeline)):\n        if timeline[i] == 0:\n            current_free += 1\n            if current_free >= required_slots:\n                start_time = i - required_slots + 1\n                end_time = i + 1\n                meeting_start = minutes_to_time(start_time + start_min)\n                meeting_end = minutes_to_time(end_time + start_min)\n                return f\"{meeting_start}:{meeting_end}\"\n        else:\n            current_free = 0\n    return \"No available slot found\"\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 30  # minutes\n\n# Define each participant's busy times\nparticipants_schedules = [\n    [(\"9:00\", \"9:30\"), (\"11:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"13:30\"), (\"14:00\", \"14:30\"), (\"15:30\", \"16:00\")],  # Christopher\n    [(\"9:00\", \"9:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"13:30\"), (\"14:00\", \"14:30\")],  # Karen\n    [(\"9:00\", \"9:30\"), (\"10:30\", \"11:00\"), (\"11:30\", \"12:00\"), (\"15:00\", \"15:30\")],  # Patricia\n    [(\"10:00\", \"10:30\"), (\"11:00\", \"11:30\"), (\"14:00\", \"14:30\"), (\"16:30\", \"17:00\")],  # Charlotte\n    [(\"9:00\", \"9:30\"), (\"12:00\", \"13:30\"), (\"14:00\", \"15:00\"), (\"15:30\", \"16:30\")],  # Roger\n    [(\"9:00\", \"9:30\"), (\"10:00\", \"11:30\"), (\"12:00\", \"17:00\")],  # Anna\n    [(\"10:30\", \"11:00\"), (\"12:00\", \"13:00\"), (\"13:30\", \"15:30\"), (\"16:30\", \"17:00\")],  # Dylan\n]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_442"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert work hours and busy times to minutes\n    start_hour, start_min = map(int, work_hours[0].split(':'))\n    end_hour, end_min = map(int, work_hours[1].split(':'))\n    work_start = start_hour * 60 + start_min\n    work_end = end_hour * 60 + end_min\n    \n    # Initialize a list to track busy intervals in minutes\n    busy_intervals = []\n    for person in participants_busy:\n        for interval in person:\n            start, end = interval.split(' to ')\n            start_h, start_m = map(int, start.split(':'))\n            end_h, end_m = map(int, end.split(':'))\n            busy_start = start_h * 60 + start_m\n            busy_end = end_h * 60 + end_m\n            busy_intervals.append((busy_start, busy_end))\n    \n    # Sort all busy intervals\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Check for available slots before the first busy interval\n    if merged:\n        first_start, first_end = merged[0]\n        if work_start + duration <= first_start:\n            return f\"{format_time(work_start)}:{format_time(work_start + duration)}\"\n    \n    # Check between busy intervals\n    for i in range(len(merged) - 1):\n        current_end = merged[i][1]\n        next_start = merged[i + 1][0]\n        if current_end + duration <= next_start:\n            return f\"{format_time(current_end)}:{format_time(current_end + duration)}\"\n    \n    # Check after last busy interval\n    last_end = merged[-1][1] if merged else work_start\n    if last_end + duration <= work_end:\n        return f\"{format_time(last_end)}:{format_time(last_end + duration)}\"\n    \n    return \"No available slot found\"\n\ndef format_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Define participants' busy times\nparticipants_busy = [\n    [\"14:00 to 14:30\", \"15:00 to 15:30\"],  # Jacob\n    [\"13:30 to 14:00\", \"16:00 to 16:30\"],  # Frances\n    [\"12:30 to 13:00\", \"14:00 to 14:30\"],  # Emily\n    [],                                    # Mark\n    [\"10:00 to 12:00\", \"13:00 to 14:30\", \"15:30 to 16:00\"],  # Linda\n    [\"9:30 to 10:00\", \"11:00 to 13:30\", \"14:00 to 14:30\", \"16:00 to 16:30\"],  # Robert\n    [\"9:30 to 11:30\", \"12:30 to 16:00\", \"16:30 to 17:00\"],  # Raymond\n]\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 30  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_443"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:00:16:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the free slots for the day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's schedule to find common free slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_slots.append((start, end))\n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Merge overlapping or adjacent busy slots\n        merged_busy = []\n        for start, end in busy_slots:\n            if not merged_busy:\n                merged_busy.append((start, end))\n            else:\n                last_start, last_end = merged_busy[-1]\n                if start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged_busy[-1] = (new_start, new_end)\n                else:\n                    merged_busy.append((start, end))\n        \n        # Calculate free slots for this participant\n        participant_free = []\n        prev_end = work_start\n        for start, end in merged_busy:\n            if start > prev_end:\n                participant_free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            participant_free.append((prev_end, work_end))\n        \n        # Intersect with current free slots\n        new_free_slots = []\n        i = j = 0\n        while i < len(free_slots) and j < len(participant_free):\n            slot_start, slot_end = free_slots[i]\n            part_start, part_end = participant_free[j]\n            \n            # Find overlap\n            overlap_start = max(slot_start, part_start)\n            overlap_end = min(slot_end, part_end)\n            \n            if overlap_start < overlap_end:\n                new_free_slots.append((overlap_start, overlap_end))\n            \n            # Move the pointer which ends first\n            if slot_end < part_end:\n                i += 1\n            else:\n                j += 1\n        \n        free_slots = new_free_slots\n    \n    # Find the first free slot that can accommodate the meeting\n    meeting_duration_min = meeting_duration * 60\n    for start, end in free_slots:\n        if end - start >= meeting_duration_min:\n            meeting_end = start + meeting_duration_min\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"12:00:12:30\", \"14:30:15:00\"],  # Abigail\n    [\"09:30:10:30\", \"13:30:14:00\", \"16:30:17:00\"],  # Roy\n    [],  # Brian\n    [\"12:00:13:00\", \"14:00:14:30\", \"15:30:16:00\"],  # Deborah\n    [\"09:30:10:00\", \"11:30:12:00\", \"12:30:13:00\", \"14:00:16:00\", \"16:30:17:00\"],  # Eric\n    [\"09:00:10:00\", \"10:30:12:00\", \"12:30:14:30\", \"15:00:16:00\", \"16:30:17:00\"],  # Susan\n    [\"09:30:10:00\", \"10:30:12:30\", \"14:00:15:00\", \"16:30:17:00\"],  # Joyce\n]\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, \"09:00\", \"17:00\", 0.5)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_444"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Now, find a free interval that is common to all participants\n    # To do this, we need to find overlapping free intervals across all participants\n    # But since it's complex, we'll instead look for a time slot where no one is busy\n    # We'll generate all possible slots and check availability\n    \n    # Generate all possible 30-minute slots within work hours\n    possible_slots = []\n    current_time = work_start\n    \n    while current_time + duration <= work_end:\n        slot_start = current_time\n        slot_end = slot_start + duration\n        possible_slots.append((slot_start, slot_end))\n        current_time += 15  # Check every 15 minutes for efficiency\n    \n    # Check each slot against all busy intervals\n    for slot_start, slot_end in possible_slots:\n        conflict = False\n        for busy_start, busy_end in busy_intervals:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                conflict = True\n                break\n        if not conflict:\n            return f\"{minutes_to_time(slot_start)}:{minutes_to_time(slot_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"11:00:11:30\", \"12:00:12:30\"],  # Sophia\n    [\"09:00:09:30\", \"14:30:15:00\"],  # Judith\n    [\"15:30:16:00\", \"16:30:17:00\"],  # Linda\n    [],                               # Ethan\n    [\"09:00:09:30\", \"10:00:11:00\", \"11:30:12:30\", \"13:30:17:00\"],  # Anna\n    [\"09:30:10:00\", \"10:30:11:30\", \"12:00:12:30\", \"13:00:13:30\", \"14:00:14:30\", \"15:00:16:00\"],  # Marie\n    [\"09:00:11:00\", \"11:30:12:30\", \"13:00:13:30\", \"14:00:16:00\", \"16:30:17:00\"],  # Olivia\n]\n\n# Meeting duration in minutes\nduration = 30\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_445"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    busy_slots = {\n        'Megan': [(9*60, 9*60+30), (10*60, 11*60), (12*60, 12*60+30)],\n        'Christine': [(9*60, 9*60+30), (11*60+30, 12*60), (13*60, 14*60), (15*60+30, 16*60+30)],\n        'Gabriel': [],\n        'Sara': [(11*60+30, 12*60), (14*60+30, 15*60)],\n        'Bruce': [(9*60+30, 10*60), (10*60+30, 12*60), (12*60+30, 14*60), (14*60+30, 15*60), (15*60+30, 16*60+30)],\n        'Kathryn': [(10*60, 15*60+30), (16*60, 16*60+30)],\n        'Billy': [(9*60, 9*60+30), (11*60, 11*60+30), (12*60, 14*60), (14*60+30, 15*60+30)],\n    }\n\n    # Combine all busy slots and sort them\n    all_busy = []\n    for person in busy_slots:\n        for slot in busy_slots[person]:\n            all_busy.append(slot)\n    all_busy.sort()\n\n    # Merge overlapping or adjacent busy slots\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n\n    # Find the earliest available slot\n    prev_end = work_start\n    for start, end in merged_busy:\n        if start - prev_end >= meeting_duration:\n            # Found a slot\n            meeting_start = prev_end\n            meeting_end = meeting_start + meeting_duration\n            return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n        prev_end = max(prev_end, end)\n\n    # Check after the last busy slot\n    if work_end - prev_end >= meeting_duration:\n        meeting_start = prev_end\n        meeting_end = meeting_start + meeting_duration\n        return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n\n    return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_446"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n\n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules.values():\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort intervals by start time\n    busy_intervals.sort()\n\n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find available slots between work hours and busy intervals\n    available_slots = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Check each available slot for sufficient duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"Joan\": [\"10:00 to 11:00\", \"14:00 to 14:30\", \"16:30 to 17:00\"],\n    \"Sean\": [\"12:30 to 13:30\"],\n    \"Christian\": [\"10:00 to 10:30\", \"11:00 to 11:30\", \"12:00 to 12:30\", \"13:00 to 13:30\", \"14:00 to 15:00\"],\n    \"Jerry\": [],\n    \"Jessica\": [\"10:00 to 11:00\", \"11:30 to 13:00\", \"13:30 to 14:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"],\n    \"Virginia\": [\"9:00 to 9:30\", \"10:30 to 12:00\", \"13:30 to 15:00\", \"16:30 to 17:00\"],\n    \"Harold\": [\"9:30 to 10:00\", \"10:30 to 13:00\", \"13:30 to 16:00\", \"16:30 to 17:00\"],\n}\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, \"9:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_447"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    # Format: list of (start, end) in minutes\n    busy_slots = {\n        'Thomas': [(9*60, 9*60 + 30), (11*60 + 30, 12*60 + 30), (16*60 + 30, 17*60)],\n        'Kyle': [(9*60, 9*60 + 30), (12*60, 12*60 + 30), (13*60, 13*60 + 30), (14*60 + 30, 15*60 + 30), (16*60, 16*60 + 30)],\n        'Helen': [],\n        'Anna': [(12*60, 12*60 + 30), (14*60 + 30, 15*60)],\n        'Lauren': [(9*60, 10*60), (10*60 + 30, 11*60), (11*60 + 30, 12*60), (13*60, 13*60 + 30), (14*60, 16*60), (16*60 + 30, 17*60)],\n        'Frances': [(11*60, 17*60)],\n        'Maria': [(9*60, 10*60), (12*60, 12*60 + 30), (13*60, 14*60), (15*60, 16*60), (16*60 + 30, 17*60)],\n    }\n\n    # Collect all busy slots from all participants\n    all_busy = []\n    for person in busy_slots:\n        for start, end in busy_slots[person]:\n            all_busy.append((start, end))\n\n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_448"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:11:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert time strings to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for schedule in participants_schedules:\n        busy_intervals = []\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n        all_busy_intervals.append(busy_intervals)\n    \n    # Find all possible free intervals for each participant\n    all_free_intervals = []\n    for busy_intervals in all_busy_intervals:\n        free_intervals = []\n        # Start with the beginning of the work day\n        previous_end = work_start\n        for start, end in sorted(busy_intervals):\n            if start > previous_end:\n                free_intervals.append((previous_end, start))\n            previous_end = max(previous_end, end)\n        # Add the interval from the last meeting end to work end\n        if previous_end < work_end:\n            free_intervals.append((previous_end, work_end))\n        all_free_intervals.append(free_intervals)\n    \n    # Find overlapping free intervals across all participants\n    common_free_intervals = all_free_intervals[0]\n    for free_intervals in all_free_intervals[1:]:\n        new_common_free = []\n        i = j = 0\n        while i < len(common_free_intervals) and j < len(free_intervals):\n            start1, end1 = common_free_intervals[i]\n            start2, end2 = free_intervals[j]\n            # Find the overlap\n            overlap_start = max(start1, start2)\n            overlap_end = min(end1, end2)\n            if overlap_start < overlap_end:\n                new_common_free.append((overlap_start, overlap_end))\n            # Move the pointer which ends first\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free_intervals = new_common_free\n    \n    # Find the first interval that can fit the meeting duration\n    duration_minutes = duration * 60\n    for start, end in common_free_intervals:\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Walter is free\n    [],  # Frances is free\n    [\"9:00 to 9:30\", \"10:30 to 11:00\", \"12:30 to 13:00\", \"13:30 to 14:00\"],  # Martha\n    [],  # Lori is free\n    [\"9:00 to 10:00\", \"10:30 to 11:00\", \"12:30 to 15:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"],  # Beverly\n    [\"9:00 to 11:00\", \"11:30 to 12:30\", \"13:00 to 14:00\", \"14:30 to 16:00\", \"16:30 to 17:00\"],  # Christine\n    [\"9:00 to 10:30\", \"11:30 to 12:00\", \"13:00 to 14:00\", \"15:00 to 17:00\"],  # Catherine\n]\n\n# Find a 30-minute meeting between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, 0.5, \"9:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_449"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours=('09:00', '17:00')):\n    # Convert work hours to minutes since midnight\n    start_work, end_work = work_hours\n    work_start = int(start_work.split(':')[0]) * 60 + int(start_work.split(':')[1])\n    work_end = int(end_work.split(':')[0]) * 60 + int(end_work.split(':')[1])\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for person, schedules in participants_schedules.items():\n        for interval in schedules:\n            start, end = interval.split(' to ')\n            start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n            end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n            all_busy_intervals.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Find all free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in all_busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Now, find a free interval that is common to all participants (i.e., not blocked by anyone)\n    # To do this, we need to find intervals where no one is busy\n    # We can represent the free time as the complement of the union of all busy intervals\n    # The free time is the time not covered by any busy interval\n    \n    # Merge all busy intervals to find the total blocked time\n    merged_busy = []\n    for start, end in sorted(all_busy_intervals):\n        if not merged_busy:\n            merged_busy.append([start, end])\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                merged_busy[-1][1] = max(last_end, end)\n            else:\n                merged_busy.append([start, end])\n    \n    # Now, find the free intervals as the gaps between merged busy intervals and work hours\n    free_for_all = []\n    prev_end_free = work_start\n    \n    for start, end in merged_busy:\n        if start > prev_end_free:\n            free_for_all.append((prev_end_free, start))\n        prev_end_free = max(prev_end_free, end)\n    \n    if prev_end_free < work_end:\n        free_for_all.append((prev_end_free, work_end))\n    \n    # Now, find the first free interval that can accommodate the meeting duration\n    for start, end in free_for_all:\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            # Format the time as HH:MM:HH:MM\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = {\n    'Jonathan': ['9:30 to 10:00', '12:30 to 13:30', '14:30 to 15:00'],\n    'Janice': ['9:00 to 9:30', '11:30 to 12:00', '12:30 to 13:30', '14:30 to 15:00', '16:00 to 16:30'],\n    'Walter': ['9:30 to 10:00', '11:30 to 12:00'],\n    'Mary': ['12:00 to 12:30', '13:30 to 14:00'],\n    'Roger': ['9:30 to 10:30', '11:00 to 12:30', '13:00 to 13:30', '14:00 to 15:30', '16:00 to 16:30'],\n    'Tyler': ['9:30 to 11:00', '11:30 to 12:30', '13:30 to 14:00', '15:00 to 16:00'],\n    'Arthur': ['10:00 to 11:30', '12:30 to 13:00', '13:30 to 14:00', '14:30 to 16:00']\n}\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules))\n```",
            "count": "calendar_scheduling_example_450"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each participant's busy slots to minutes\n    # Judy: 10:30-11:30, 12:00-13:00, 15:00-16:00\n    judy_busy = [(10*60 + 30, 11*60 + 30), (12*60, 13*60), (15*60, 16*60)]\n    \n    # Jack: 10:30-11:30, 12:30-13:00, 14:00-14:30, 15:00-15:30, 16:30-17:00\n    jack_busy = [(10*60 + 30, 11*60 + 30), (12*60 + 30, 13*60),\n                 (14*60, 14*60 + 30), (15*60, 15*60 + 30), (16*60 + 30, 17*60)]\n    \n    # Ronald: 10:30-11:00, 11:30-12:00, 12:30-13:00, 16:30-17:00\n    ronald_busy = [(10*60 + 30, 11*60), (11*60 + 30, 12*60),\n                   (12*60 + 30, 13*60), (16*60 + 30, 17*60)]\n    \n    # Sandra: no meetings, but doesn't want to meet before 13:30\n    sandra_busy = [(0, 13*60 + 30)]  # Treat as busy before 13:30\n    \n    # Ashley: 10:00-10:30, 11:00-13:00, 13:30-16:00\n    ashley_busy = [(10*60, 10*60 + 30), (11*60, 13*60), (13*60 + 30, 16*60)]\n    \n    # Heather: 9:00-9:30, 10:00-11:30, 12:00-12:30, 13:30-15:30, 16:30-17:00\n    heather_busy = [(9*60, 9*60 + 30), (10*60, 11*60 + 30), (12*60, 12*60 + 30),\n                    (13*60 + 30, 15*60 + 30), (16*60 + 30, 17*60)]\n    \n    # Terry: 9:00-10:00, 10:30-11:00, 12:00-13:00, 13:30-16:00\n    terry_busy = [(9*60, 10*60), (10*60 + 30, 11*60), (12*60, 13*60), (13*60 + 30, 16*60)]\n    \n    # Combine all busy slots\n    all_busy = (judy_busy + jack_busy + ronald_busy + sandra_busy +\n                ashley_busy + heather_busy + terry_busy)\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the end of the day\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that is at least 30 minutes long\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert start time back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_time = start + meeting_duration\n            end_hh = end_time // 60\n            end_mm = end_time % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_451"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_start, work_end):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between merged intervals and work hours\n    available_slots = []\n    prev_end = work_start_min\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        available_slots.append((prev_end, work_end_min))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Austin\n    [\"9:00:9:30\", \"10:00:10:30\", \"11:00:11:30\", \"13:30:14:00\", \"14:30:15:00\", \"16:00:16:30\"],  # Andrew\n    [\"11:00:11:30\", \"16:30:17:00\"],  # Raymond\n    [\"9:00:9:30\", \"10:00:10:30\", \"11:30:12:30\", \"15:30:16:00\", \"16:30:17:00\"],  # Mary\n    [\"9:30:10:00\", \"11:00:11:30\", \"12:00:12:30\", \"13:00:15:30\", \"16:00:17:00\"],  # Bobby\n    [\"9:00:10:30\", \"11:30:13:00\", \"13:30:16:30\"],  # Shirley\n    [\"9:30:10:30\", \"11:30:12:00\", \"13:00:14:30\", \"15:30:16:30\"],  # Jordan\n]\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules=participants_schedules, duration=30, work_start=\"9:00\", work_end=\"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_452"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:30:10:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_hour, end_hour = work_hours\n    # Convert work hours to minutes\n    start_time = start_hour * 60\n    end_time = end_hour * 60\n    \n    # Initialize a list to keep track of busy times for all participants\n    busy_times = []\n    \n    # Collect all busy intervals for each participant\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start = interval[0] * 60\n            end = interval[1] * 60\n            busy_times.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_times.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_times:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between merged intervals\n    available_slots = []\n    previous_end = start_time\n    \n    for start, end in merged:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy interval\n    if previous_end < end_time:\n        available_slots.append((previous_end, end_time))\n    \n    # Check each available slot for the required duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration * 60:\n            # Found a suitable slot\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration * 60\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available slot found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (9, 17)\n\n# Define meeting duration in hours (0.5 hours = 30 minutes)\nduration = 0.5\n\n# Define each participant's schedule as a list of busy intervals in HH:MM format\nparticipants_schedules = [\n    [(10.0, 10.5), (11.0, 11.5)],  # Natalie\n    [(9.0, 9.5), (13.0, 13.5)],     # Dylan\n    [(11.5, 12.0), (13.5, 14.0), (15.0, 15.5), (16.0, 16.5)],  # Pamela\n    [],                              # Charlotte\n    [(10.0, 11.0), (11.5, 12.5), (13.0, 13.5), (14.5, 17.0)],  # Ann\n    [(9.0, 9.5), (10.0, 13.5), (14.0, 14.5), (15.5, 17.0)],     # Jason\n    [(10.0, 11.0), (12.5, 14.5), (15.0, 16.0)],                 # Benjamin\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_453"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours=('09:00', '17:00')):\n    # Convert work hours to minutes since midnight\n    start_work, end_work = work_hours\n    work_start = int(start_work.split(':')[0]) * 60 + int(start_work.split(':')[1])\n    work_end = int(end_work.split(':')[0]) * 60 + int(end_work.split(':')[1])\n    \n    # Initialize the free slots for all participants\n    free_slots = []\n    \n    for participant, busy_slots in participants_schedules.items():\n        participant_free = []\n        # Start with the entire work day as free\n        current_start = work_start\n        \n        # Process each busy slot\n        for busy in busy_slots:\n            busy_start = int(busy[0].split(':')[0]) * 60 + int(busy[0].split(':')[1])\n            busy_end = int(busy[1].split(':')[0]) * 60 + int(busy[1].split(':')[1])\n            \n            if current_start < busy_start:\n                participant_free.append((current_start, busy_start))\n            current_start = max(current_start, busy_end)\n        \n        # Add the remaining time after the last busy slot\n        if current_start < work_end:\n            participant_free.append((current_start, work_end))\n        \n        free_slots.append(participant_free)\n    \n    # Find the intersection of all free slots\n    common_free = free_slots[0]\n    for participant in free_slots[1:]:\n        new_common = []\n        i = j = 0\n        while i < len(common_free) and j < len(participant):\n            start = max(common_free[i][0], participant[j][0])\n            end = min(common_free[i][1], participant[j][1])\n            if start < end:\n                new_common.append((start, end))\n            if common_free[i][1] < participant[j][1]:\n                i += 1\n            else:\n                j += 1\n        common_free = new_common\n    \n    # Find the first slot that can accommodate the meeting\n    for slot in common_free:\n        if slot[1] - slot[0] >= duration_minutes:\n            meeting_start = slot[0]\n            meeting_end = meeting_start + duration_minutes\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = {\n    'Sara': [('09:30', '10:30')],\n    'Ethan': [('11:00', '11:30'), ('12:00', '12:30'), ('13:30', '15:00'), ('15:30', '16:00')],\n    'Stephanie': [],\n    'Hannah': [('12:30', '13:30'), ('15:30', '16:00'), ('16:30', '17:00')],\n    'Kevin': [('09:00', '15:00'), ('15:30', '16:00'), ('16:30', '17:00')],\n    'Susan': [('10:00', '10:30'), ('11:00', '13:30'), ('14:30', '16:00'), ('16:30', '17:00')],\n    'Bryan': [('09:00', '09:30'), ('10:00', '10:30'), ('11:30', '12:00'), ('13:30', '15:30'), ('16:30', '17:00')]\n}\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules))\n```",
            "count": "calendar_scheduling_example_454"
        },
        {
            "final_program_time": "{16:00:16:01}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_start, work_end):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes  # Add back 540 to start from 9:00\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Initialize the availability list\n    availability = [True] * (work_end_min - work_start_min)\n    \n    for person in participants_schedules:\n        person_availability = [True] * (work_end_min - work_start_min)\n        for busy in person:\n            start_min = max(time_to_minutes(busy[0]), work_start_min)\n            end_min = min(time_to_minutes(busy[1]), work_end_min)\n            for i in range(start_min, end_min):\n                if i - work_start_min >= 0 and i - work_start_min < len(person_availability):\n                    person_availability[i - work_start_min] = False\n        # Merge with overall availability\n        for i in range(len(availability)):\n            availability[i] = availability[i] and person_availability[i]\n    \n    # Find the first available slot of duration\n    required_slots = duration // 30  # Assuming slots are 30 minutes\n    current_slots = 0\n    for i in range(len(availability)):\n        if availability[i]:\n            current_slots += 1\n            if current_slots >= required_slots:\n                start = i - required_slots + 1\n                end = i + 1\n                start_time = minutes_to_time(start + work_start_min)\n                end_time = minutes_to_time(end + work_start_min)\n                return f\"{start_time}:{end_time}\"\n        else:\n            current_slots = 0\n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [(\"9:30\", \"10:00\"), (\"12:00\", \"12:30\"), (\"14:00\", \"14:30\"), (\"15:30\", \"16:00\")],  # Ryan\n    [],  # Jerry\n    [(\"9:00\", \"9:30\"), (\"14:30\", \"15:00\")],  # Raymond\n    [(\"9:00\", \"10:00\"), (\"10:30\", \"11:00\"), (\"12:00\", \"12:30\"), (\"15:00\", \"15:30\"), (\"16:30\", \"17:00\")],  # Eugene\n    [(\"9:30\", \"12:30\"), (\"13:00\", \"15:30\"), (\"16:30\", \"17:00\")],  # Justin\n    [(\"9:00\", \"9:30\"), (\"10:00\", \"12:00\"), (\"12:30\", \"13:00\"), (\"15:00\", \"16:00\")],  # Gerald\n    [(\"9:00\", \"10:00\"), (\"11:30\", \"13:00\"), (\"13:30\", \"14:00\"), (\"15:00\", \"15:30\"), (\"16:30\", \"17:00\")],  # Eric\n]\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, 30, \"9:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_455"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    start, end = work_hours\n    # Convert time strings to minutes for easier calculation\n    start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n    end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n    \n    # Initialize a list to mark busy times\n    timeline = [False] * (end_min - start_min)\n    \n    # Mark busy times for each participant\n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            busy_start_min = int(busy_start.split(':')[0]) * 60 + int(busy_start.split(':')[1])\n            busy_end_min = int(busy_end.split(':')[0]) * 60 + int(busy_end.split(':')[1])\n            # Only consider times within work hours\n            busy_start_min = max(busy_start_min, start_min)\n            busy_end_min = min(busy_end_min, end_min)\n            for i in range(busy_start_min - start_min, busy_end_min - start_min):\n                if i < len(timeline):\n                    timeline[i] = True\n    \n    # Find a free slot of the required duration\n    required_slots = duration\n    current_free = 0\n    for i in range(len(timeline)):\n        if not timeline[i]:\n            current_free += 1\n            if current_free >= required_slots:\n                slot_start = i - current_free + 1 + start_min\n                slot_end = slot_start + required_slots\n                # Convert back to HH:MM format\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_hh = slot_end // 60\n                end_mm = slot_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n        else:\n            current_free = 0\n    return \"No available slot found\"\n\n# Define participants' schedules in HH:MM format\nparticipants_schedules = [\n    [(\"09:30\", \"10:30\"), (\"12:00\", \"12:30\"), (\"14:00\", \"14:30\")],  # Margaret\n    [(\"09:30\", \"10:00\"), (\"13:30\", \"14:00\")],  # Justin\n    [(\"10:00\", \"10:30\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"14:00\", \"14:30\")],  # Noah\n    [(\"09:30\", \"10:30\"), (\"11:00\", \"11:30\"), (\"13:00\", \"13:30\"), (\"14:00\", \"15:00\")],  # Madison\n    [(\"09:30\", \"10:00\"), (\"11:00\", \"12:00\"), (\"12:30\", \"13:30\"), (\"14:00\", \"14:30\"), (\"15:00\", \"15:30\"), (\"16:00\", \"16:30\")],  # Carl\n    [(\"09:00\", \"10:30\"), (\"11:30\", \"14:30\"), (\"15:00\", \"16:30\")],  # Denise\n    [(\"09:30\", \"10:00\"), (\"10:30\", \"11:00\"), (\"11:30\", \"14:00\"), (\"14:30\", \"15:30\"), (\"16:00\", \"16:30\")],  # Mason\n]\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\n# Work hours (9:00 to 17:00)\nwork_hours = (\"09:00\", \"17:00\")\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, duration, work_hours))\n```",
            "count": "calendar_scheduling_example_456"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert each participant's busy slots to minutes\n    andrea_busy = [(9*60 + 30, 10*60 + 30), (13*60 + 30, 14*60 + 30)]\n    ruth_busy = [(12*60 + 30, 13*60 + 0), (15*60 + 0, 15*60 + 30)]\n    steven_busy = [(10*60 + 0, 10*60 + 30), (11*60 + 0, 11*60 + 30), \n                   (12*60 + 0, 12*60 + 30), (13*60 + 30, 14*60 + 0), \n                   (15*60 + 0, 16*60 + 0)]\n    grace_busy = []\n    kyle_busy = [(9*60 + 0, 9*60 + 30), (10*60 + 30, 12*60 + 0), \n                 (12*60 + 30, 13*60 + 0), (13*60 + 30, 15*60 + 0), \n                 (15*60 + 30, 16*60 + 0), (16*60 + 30, 17*60 + 0)]\n    elijah_busy = [(9*60 + 0, 11*60 + 0), (11*60 + 30, 13*60 + 0), \n                   (13*60 + 30, 14*60 + 0), (15*60 + 30, 16*60 + 0), \n                   (16*60 + 30, 17*60 + 0)]\n    lori_busy = [(9*60 + 0, 9*60 + 30), (10*60 + 0, 11*60 + 30), \n                 (12*60 + 0, 13*60 + 30), (14*60 + 0, 16*60 + 0), \n                 (16*60 + 30, 17*60 + 0)]\n\n    # Combine all busy slots\n    all_busy = andrea_busy + ruth_busy + steven_busy + grace_busy + kyle_busy + elijah_busy + lori_busy\n\n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check each free slot for a 30-minute window\n    meeting_duration = 30\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Found a suitable slot\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_457"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Define each participant's busy times in minutes (start, end)\n    busy_times = {\n        'Wayne': [],\n        'Melissa': [(10 * 60, 11 * 60), (12 * 60 + 30, 14 * 60), (15 * 60, 15 * 60 + 30)],\n        'Catherine': [],\n        'Gregory': [(12 * 60 + 30, 13 * 60), (15 * 60 + 30, 16 * 60)],\n        'Victoria': [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 11 * 60 + 30), (13 * 60, 14 * 60), \n                     (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60 + 30)],\n        'Thomas': [(10 * 60, 12 * 60), (12 * 60 + 30, 13 * 60), (14 * 60 + 30, 16 * 60)],\n        'Jennifer': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (11 * 60, 13 * 60), \n                     (13 * 60 + 30, 14 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n    }\n\n    # Wayne's preference: avoid before 14:00\n    wayne_preference_start = 14 * 60\n\n    # Generate all busy intervals\n    all_busy = []\n    for person, intervals in busy_times.items():\n        for interval in intervals:\n            all_busy.append(interval)\n\n    # Add Wayne's preference as a busy interval if before 14:00\n    all_busy.append((work_start, wayne_preference_start))\n\n    # Sort all busy intervals by start time\n    all_busy.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append([start, end])\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1][1] = max(last_end, end)\n            else:\n                merged.append([start, end])\n\n    # Find free slots between merged busy intervals and work hours\n    free_slots = []\n    previous_end = work_start\n    for start, end in merged:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check each free slot for 30-minute availability\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Found a suitable slot\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            def to_time_str(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{to_time_str(meeting_start)}:{to_time_str(meeting_end)}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_458"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:9:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - work_hours_start_min\n    \n    work_hours_start_min = work_hours_start * 60\n    work_hours_end_min = work_hours_end * 60\n    duration = duration_minutes\n    \n    # Initialize a list to track busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by checking gaps between busy intervals\n    free_intervals = []\n    prev_end = 0\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    # Check the interval after the last busy interval until end of work hours\n    if prev_end < (work_hours_end_min - work_hours_start_min):\n        free_intervals.append((prev_end, work_hours_end_min - work_hours_start_min))\n    \n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start + work_hours_start_min\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Define work hours and meeting duration\nwork_hours_start = 9 * 60  # 9:00 in minutes\nwork_hours_end = 17 * 60    # 17:00 in minutes\nduration = 30               # 30 minutes\n\n# Define participants' schedules in HH:MM:HH:MM format\nparticipants_schedules = [\n    [\"10:30:11:00\", \"12:00:12:30\", \"14:00:14:30\", \"15:00:15:30\", \"16:00:17:00\"],  # Marie\n    [\"11:00:11:30\", \"14:00:15:30\"],  # Roger\n    [\"10:00:10:30\", \"15:30:16:00\"],  # John\n    [\"13:30:14:00\", \"16:30:17:00\"],  # Peter\n    [\"09:30:15:30\", \"16:00:17:00\"],  # Ruth\n    [\"10:30:11:00\", \"12:00:13:00\", \"14:30:17:00\"],  # James\n    [\"09:30:11:00\", \"11:30:12:00\", \"12:30:15:00\", \"15:30:17:00\"],  # Victoria\n]\n\n# Find a meeting time\nmeeting_time = find_meeting_time(participants_schedules, 9, 17, 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_459"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all times to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the available slots as the entire work day\n    available_slots = [(work_start, work_end)]\n    \n    # Process each participant's busy times\n    for busy_times in participants_busy_times:\n        new_available_slots = []\n        for slot in available_slots:\n            slot_start, slot_end = slot\n            # Subtract each busy time from the current slot\n            for busy_start, busy_end in busy_times:\n                busy_start_min = time_to_minutes(busy_start)\n                busy_end_min = time_to_minutes(busy_end)\n                # If the busy time overlaps with the slot, split the slot\n                if busy_start_min < slot_end and busy_end_min > slot_start:\n                    if busy_start_min > slot_start:\n                        new_available_slots.append((slot_start, busy_start_min))\n                    if busy_end_min < slot_end:\n                        new_available_slots.append((busy_end_min, slot_end))\n                    break\n            else:\n                new_available_slots.append((slot_start, slot_end))\n        available_slots = new_available_slots\n    \n    # Find the first available slot that can fit the meeting\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_minutes:\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            meeting_start = minutes_to_time(slot_start)\n            meeting_end = minutes_to_time(slot_start + duration_minutes)\n            return f\"{meeting_start}:{meeting_end}\"\n    return \"No suitable time found\"\n\n# Define the participants' busy times\nparticipants_busy_times = [\n    # Katherine\n    [(\"12:00\", \"12:30\"), (\"13:00\", \"14:00\"), (\"14:30\", \"15:00\")],\n    # Douglas\n    [(\"09:00\", \"09:30\"), (\"13:00\", \"13:30\")],\n    # Ann\n    [(\"14:30\", \"15:30\")],\n    # Pamela\n    [(\"10:00\", \"11:00\")],\n    # Gloria\n    [(\"09:00\", \"12:30\"), (\"13:00\", \"15:30\"), (\"16:00\", \"17:00\")],\n    # Donna\n    [(\"09:00\", \"09:30\"), (\"10:30\", \"11:00\"), (\"12:30\", \"13:00\"), (\"13:30\", \"15:00\"), (\"16:00\", \"17:00\")],\n    # Christopher\n    [(\"09:30\", \"11:00\"), (\"11:30\", \"15:30\"), (\"16:30\", \"17:00\")]\n]\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_busy_times, \"09:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_460"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:9:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability of all participants\n    for start, end in free_intervals:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"09:30:10:30\", \"14:30:15:00\", \"16:30:17:00\"],  # Justin\n    [],                                              # Nancy\n    [\"09:30:10:00\", \"12:00:12:30\", \"14:00:14:30\", \"15:30:16:00\"],  # Willie\n    [\"09:30:10:00\", \"12:30:13:00\", \"13:30:14:00\", \"16:30:17:00\"],  # Alan\n    [\"10:00:10:30\", \"11:00:12:30\", \"13:00:14:00\", \"14:30:15:30\", \"16:00:17:00\"],  # Brian\n    [\"09:30:11:00\", \"11:30:12:00\", \"13:30:16:30\"],  # Lori\n    [\"10:30:11:30\", \"12:00:12:30\", \"13:30:14:00\", \"14:30:16:00\", \"16:30:17:00\"],  # Isabella\n]\n\n# Define work hours and meeting duration\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 30  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_461"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    meeting_duration_min = meeting_duration\n\n    # Collect all busy intervals for all participants\n    all_busy_intervals = []\n    for busy_times in participants_busy_times.values():\n        for busy in busy_times:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            all_busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged_busy = []\n    for start, end in all_busy_intervals:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n\n    # Find free intervals by inverting the busy intervals\n    free_intervals = []\n    previous_end = work_start\n    for start, end in merged_busy:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_intervals.append((previous_end, work_end))\n\n    # Find the earliest free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= meeting_duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return None\n\n# Define participants' busy times\nparticipants_busy_times = {\n    \"Justin\": [\"11:30 to 12:00\", \"13:00 to 13:30\"],\n    \"Diane\": [\"9:30 to 10:30\", \"11:30 to 12:00\", \"12:30 to 13:30\", \"14:30 to 15:30\", \"16:00 to 16:30\"],\n    \"Bryan\": [\"9:00 to 10:30\", \"12:00 to 12:30\", \"13:00 to 14:30\", \"15:00 to 15:30\", \"16:00 to 17:00\"],\n    \"Beverly\": [\"9:30 to 10:30\", \"11:30 to 12:30\", \"13:00 to 13:30\", \"14:00 to 14:30\", \"16:00 to 17:00\"]\n}\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 30  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_462"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:30:15:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert work hours to minutes since midnight for easier calculation\n    start_time = work_hours_start * 60\n    end_time = work_hours_end * 60\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    all_busy_intervals = []\n    \n    # Collect all busy intervals from each participant\n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            all_busy_intervals.append((busy_start * 60, busy_end * 60))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_intervals = []\n    for start, end in all_busy_intervals:\n        if not merged_intervals:\n            merged_intervals.append((start, end))\n        else:\n            last_start, last_end = merged_intervals[-1]\n            if start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_intervals[-1] = (new_start, new_end)\n            else:\n                merged_intervals.append((start, end))\n    \n    # Find free intervals between work hours and merged busy intervals\n    free_intervals = []\n    previous_end = start_time\n    \n    for start, end in merged_intervals:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the interval after the last busy interval\n    if previous_end < end_time:\n        free_intervals.append((previous_end, end_time))\n    \n    # Find the first free interval that can accommodate the meeting duration\n    duration = duration_minutes\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Convert back to hours and minutes\n            start_hour = meeting_start // 60\n            start_minute = meeting_start % 60\n            end_hour = meeting_end // 60\n            end_minute = meeting_end % 60\n            return f\"{start_hour:02d}:{start_minute:02d}:{end_hour:02d}:{end_minute:02d}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules in hours (converted to float for simplicity)\nparticipants_schedules = [\n    [(10.5, 11.5), (12.5, 14.0), (15.0, 15.5)],  # Joyce\n    [(9.0, 9.5), (16.0, 16.5)],  # Diana\n    [(9.0, 9.5), (12.0, 12.5), (13.0, 13.5), (14.0, 14.5)],  # Emma\n    [(10.0, 10.5), (16.5, 17.0)],  # Gregory\n    [(9.0, 9.5), (10.0, 10.5), (11.0, 14.0)],  # Tyler\n    [(9.0, 11.0), (11.5, 12.0), (12.5, 14.0), (15.5, 16.5)],  # Jacob\n    [(9.0, 9.5), (10.0, 11.5), (12.0, 14.5), (15.0, 16.0), (16.5, 17.0)]  # Bruce\n]\n\n# Work hours from 9:00 to 17:00 (5:00 PM)\nwork_hours_start = 9.0\nwork_hours_end = 17.0\nmeeting_duration = 30  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_463"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration_minutes):\n    # Convert work hours to minutes since midnight\n    work_start = int(work_hours[0].split(':')[0]) * 60 + int(work_hours[0].split(':')[1])\n    work_end = int(work_hours[1].split(':')[0]) * 60 + int(work_hours[1].split(':')[1])\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for interval in schedule:\n            start_time = interval[0]\n            end_time = interval[1]\n            start_min = int(start_time.split(':')[0]) * 60 + int(start_time.split(':')[1])\n            end_min = int(end_time.split(':')[0]) * 60 + int(end_time.split(':')[1])\n            all_busy_intervals.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in all_busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability of duration_minutes\n    for interval in free_intervals:\n        start, end = interval\n        if end - start >= duration_minutes:\n            # Convert start time back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_time = start + duration_minutes\n            end_hh = end_time // 60\n            end_mm = end_time % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [(\"10:30\", \"11:30\")],  # Rachel\n    [(\"10:30\", \"11:00\"), (\"12:00\", \"12:30\")],  # Henry\n    [(\"11:30\", \"12:00\"), (\"12:30\", \"14:30\"), (\"15:30\", \"16:00\")],  # Jesse\n    [(\"10:30\", \"12:00\"), (\"16:00\", \"16:30\")],  # Albert\n    [(\"09:00\", \"09:30\"), (\"10:30\", \"12:30\"), (\"13:30\", \"14:00\"), (\"15:00\", \"16:00\")],  # Ashley\n    [(\"09:00\", \"10:00\"), (\"10:30\", \"11:30\"), (\"12:30\", \"15:00\"), (\"15:30\", \"17:00\")],  # Jonathan\n    [(\"09:00\", \"09:30\"), (\"10:30\", \"17:00\")]  # Walter\n]\n\n# Define work hours and meeting duration\nwork_hours = (\"09:00\", \"17:00\")\nduration_minutes = 30\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration_minutes))\n```",
            "count": "calendar_scheduling_example_464"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define each participant's busy times in minutes (start, end)\n    busy_times = {\n        'Gregory': [(14 * 60, 17 * 60)],\n        'John': [],\n        'Roger': [],\n        'Roy': [(10 * 60 + 30, 11 * 60), (14 * 60 + 30, 15 * 60)],\n        'Adam': [(9 * 60, 12 * 60 + 30), (13 * 60 + 30, 17 * 60)],\n        'Judith': [(9 * 60, 10 * 60 + 30), (12 * 60, 13 * 60), (13 * 60 + 30, 14 * 60 + 30), (15 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Robert': [(9 * 60, 13 * 60), (13 * 60 + 30, 15 * 60), (15 * 60 + 30, 17 * 60)],\n    }\n\n    # Combine all busy times and sort them\n    all_busy = []\n    for person in busy_times:\n        for start, end in busy_times[person]:\n            all_busy.append((start, end))\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    prev_end = work_start\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_465"
        },
        {
            "final_program_time": "{16:00:16:01}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_start, work_end):\n    # Convert time strings to minutes since 9:00 (work_start)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work_start is 9:00\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Initialize a list to mark busy times\n    timeline = [0] * (work_end_min - work_start_min)\n    \n    # Mark busy intervals for each participant\n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            start = max(time_to_minutes(busy_start) - work_start_min, 0)\n            end = min(time_to_minutes(busy_end) - work_start_min, len(timeline))\n            for i in range(start, end):\n                timeline[i] += 1\n    \n    # Find the first interval where all are free (timeline[i] == 0) for duration\n    required_slots = duration // 30  # Assuming slots are 30 minutes each\n    current_free = 0\n    \n    for i in range(len(timeline)):\n        if timeline[i] == 0:\n            current_free += 1\n            if current_free >= required_slots:\n                start_time = i - required_slots + 1\n                start_hh = work_start_min + start_time\n                end_hh = start_hh + required_slots\n                # Convert back to HH:MM format\n                start_str = f\"{start_hh // 60 + 9}:{start_hh % 60:02d}\"\n                end_str = f\"{end_hh // 60 + 9}:{end_hh % 60:02d}\"\n                return f\"{start_str}:{end_str}\"\n        else:\n            current_free = 0\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules in HH:MM format\nparticipants_schedules = [\n    [(\"9:30\", \"10:00\"), (\"12:30\", \"13:00\"), (\"14:00\", \"15:00\")],  # Kyle\n    [],  # Danielle\n    [(\"10:00\", \"10:30\"), (\"12:00\", \"12:30\")],  # Kelly\n    [],  # Carol\n    [(\"9:00\", \"10:00\"), (\"10:30\", \"11:30\"), (\"12:00\", \"13:00\"), \n     (\"13:30\", \"14:00\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:00\"), \n     (\"16:30\", \"17:00\")],  # Angela\n    [(\"9:30\", \"10:00\"), (\"11:30\", \"13:00\"), (\"13:30\", \"15:30\")],  # Carolyn\n    [(\"9:00\", \"15:30\"), (\"16:30\", \"17:00\")],  # Gary\n]\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_start = \"9:00\"\nwork_end = \"17:00\"\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_start, work_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_466"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:30:16:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert time strings to minutes since start of day for easier handling\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start, work_end = map(time_to_minutes, work_hours.split(' to '))\n    duration_min = duration * 60\n\n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n\n    # For each participant, subtract their busy times from the free slots\n    for participant in participants_schedules.values():\n        for busy_start, busy_end in participant:\n            busy_start_min = time_to_minutes(busy_start)\n            busy_end_min = time_to_minutes(busy_end)\n            new_free_slots = []\n            for slot_start, slot_end in free_slots:\n                if busy_end_min <= slot_start or busy_start_min >= slot_end:\n                    # No overlap, keep the slot as is\n                    new_free_slots.append((slot_start, slot_end))\n                else:\n                    # Overlap, split the slot\n                    if slot_start < busy_start_min:\n                        new_free_slots.append((slot_start, busy_start_min))\n                    if busy_end_min < slot_end:\n                        new_free_slots.append((busy_end_min, slot_end))\n            free_slots = new_free_slots\n\n    # Find the first slot that can fit the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_end = slot_start + duration_min\n            return f\"{minutes_to_time(slot_start)}:{minutes_to_time(meeting_end)}\"\n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"Nicole\": [(\"9:00\", \"9:30\"), (\"11:00\", \"11:30\"), (\"12:30\", \"13:00\"), (\"14:30\", \"15:00\")],\n    \"Wayne\": [(\"10:30\", \"11:00\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"14:30\", \"15:30\"), (\"16:00\", \"16:30\")],\n    \"Gerald\": [(\"9:30\", \"10:00\"), (\"10:30\", \"11:00\")],\n    \"Christian\": [],\n    \"Harold\": [(\"9:00\", \"10:00\"), (\"10:30\", \"14:00\"), (\"14:30\", \"15:30\"), (\"16:30\", \"17:00\")],\n    \"Larry\": [(\"9:00\", \"12:00\"), (\"12:30\", \"13:00\"), (\"13:30\", \"14:00\"), (\"14:30\", \"15:30\"), (\"16:00\", \"17:00\")],\n    \"Jason\": [(\"9:30\", \"10:00\"), (\"10:30\", \"11:00\"), (\"12:00\", \"12:30\"), (\"13:30\", \"15:30\"), (\"16:30\", \"17:00\")]\n}\n\n# Find a 30-minute meeting time between 9:00 to 17:00\nmeeting_time = find_meeting_time(participants_schedules, 0.5, \"9:00 to 17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_467"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:30:16:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    meeting_duration_min = meeting_duration * 60\n    \n    # Collect all busy intervals for all participants\n    all_busy_intervals = []\n    for busy_times in participants_busy_times:\n        for interval in busy_times:\n            start, end = map(time_to_minutes, interval.split(':'))\n            all_busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_intervals = []\n    for start, end in all_busy_intervals:\n        if not merged_intervals:\n            merged_intervals.append([start, end])\n        else:\n            last_start, last_end = merged_intervals[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                merged_intervals[-1][1] = max(end, last_end)\n            else:\n                merged_intervals.append([start, end])\n    \n    # Find available slots by checking gaps between merged intervals and work hours\n    available_slots = []\n    previous_end = work_start\n    \n    for start, end in merged_intervals:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy interval until work_end\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define work hours and meeting duration\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 30  # minutes\n\n# Define each participant's busy times\nparticipants_busy_times = [\n    [\"09:30:10:00\", \"10:30:11:00\", \"16:00:17:00\"],  # Stephen\n    [],                                              # Jacqueline\n    [],                                              # Logan\n    [\"09:30:10:00\", \"15:00:15:30\"],                 # Larry\n    [\"09:30:12:00\", \"13:00:13:30\", \"14:00:14:30\", \"15:00:15:30\"],  # Jean\n    [\"09:00:12:30\", \"13:30:15:00\"],                 # Adam\n    [\"09:00:12:00\", \"12:30:15:30\", \"16:00:17:00\"],  # Eugene\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_468"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals\n    busy_intervals = []\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability\n    duration = duration_minutes\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Jack\n    [\"09:30:10:00\", \"13:30:14:00\"],  # Jacob\n    [\"09:00:09:30\", \"10:00:10:30\", \"11:30:12:00\", \"14:00:14:30\", \"15:00:15:30\", \"16:00:16:30\"],  # Edward\n    [],  # Sean\n    [\"10:00:10:30\", \"11:00:11:30\", \"12:00:12:30\", \"13:00:14:30\", \"15:30:16:30\"],  # Lori\n    [\"09:00:11:00\", \"12:00:12:30\", \"14:00:14:30\", \"15:00:15:30\", \"16:30:17:00\"],  # Billy\n    [\"10:00:12:30\", \"13:30:14:00\", \"14:30:16:30\"],  # Willie\n]\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, \"09:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_469"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define each participant's busy times in minutes (start, end)\n    busy_times = {\n        'Jordan': [(9*60, 9*60+30), (11*60, 11*60+30), (12*60+30, 13*60), (13*60+30, 14*60)],\n        'Madison': [(10*60, 11*60), (11*60+30, 12*60), (14*60+30, 15*60+30), (16*60+30, 17*60)],\n        'Kimberly': [(11*60+30, 12*60), (16*60+30, 17*60)],\n        'Carol': [(9*60, 9*60+30), (10*60+30, 12*60), (13*60+30, 14*60), (16*60, 16*60+30)],\n        'Nathan': [(10*60, 14*60), (14*60+30, 15*60+30), (16*60, 17*60)],\n        'Walter': [(9*60, 9*60+30), (10*60, 10*60+30), (11*60, 11*60+30), (12*60, 12*60+30), (13*60+30, 14*60), (14*60+30, 16*60)],\n        'Aaron': [(9*60, 9*60+30), (10*60, 10*60+30), (11*60, 12*60), (13*60+30, 14*60), (15*60+30, 17*60)],\n    }\n    \n    # Carol's preference: not after 10:00, so before 10:00\n    carol_preference_end = 10 * 60\n    \n    # Collect all busy times\n    all_busy = []\n    for person in busy_times:\n        all_busy.extend(busy_times[person])\n    \n    # Add Carol's preference as a \"busy\" time after 10:00\n    all_busy.append((carol_preference_end, work_end))\n    \n    # Sort busy times by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check if there's any time left after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Filter free slots that are at least 30 minutes and before Carol's preference\n    meeting_duration = 30\n    valid_slots = []\n    for start, end in free_slots:\n        if end <= carol_preference_end and (end - start) >= meeting_duration:\n            valid_slots.append((start, end))\n    \n    # If there's a valid slot before 10:00, return the first one\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n    else:\n        return \"No valid time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_470"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each person's busy slots to minutes\n    busy_slots = {\n        'Willie': [],\n        'Scott': [(9*60, 9*60+30), (10*60, 10*60+30), (15*60+30, 16*60), (16*60+30, 17*60)],\n        'Jordan': [(9*60, 9*60+30), (10*60, 10*60+30), (12*60, 12*60+30), (16*60+30, 17*60)],\n        'Austin': [(11*60+30, 13*60), (13*60+30, 14*60), (14*60+30, 15*60), (15*60+30, 16*60)],\n        'Kimberly': [(9*60, 9*60+30), (10*60+30, 11*60), (12*60+30, 14*60+30), (15*60, 16*60)],\n        'Teresa': [(9*60, 9*60+30), (10*60, 11*60+30), (12*60, 13*60), (15*60, 15*60+30), (16*60+30, 17*60)],\n        'Dylan': [(9*60+30, 10*60), (10*60+30, 12*60), (13*60, 15*60), (15*60+30, 16*60), (16*60+30, 17*60)],\n    }\n    \n    # Collect all busy slots\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by merging busy slots\n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Check for a free slot of at least 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = (start + meeting_duration) // 60\n            end_mm = (start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_471"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define each person's busy times in minutes (start, end)\n    busy_times = {\n        'Roy': [(16 * 60, 17 * 60)],\n        'Thomas': [(11 * 60 + 30, 12 * 60), (14 * 60 + 30, 15 * 60)],\n        'John': [(10 * 60 + 30, 11 * 60), (12 * 60, 12 * 60 + 30), \n                 (13 * 60 + 30, 14 * 60 + 30), (15 * 60, 15 * 60 + 30), \n                 (16 * 60 + 30, 17 * 60)],\n        'Amy': [(9 * 60, 9 * 60 + 30), (13 * 60 + 30, 14 * 60), \n                (14 * 60 + 30, 15 * 60), (16 * 60 + 30, 17 * 60)],\n        'Mason': [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 11 * 60), \n                  (11 * 60 + 30, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), \n                  (14 * 60, 14 * 60 + 30), (15 * 60 + 30, 16 * 60), \n                  (16 * 60 + 30, 17 * 60)],\n        'Zachary': [(10 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60), \n                    (12 * 60 + 30, 14 * 60), (15 * 60, 16 * 60), \n                    (16 * 60 + 30, 17 * 60)],\n        'Jacqueline': [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 11 * 60), \n                       (11 * 60 + 30, 12 * 60 + 30), (13 * 60 + 30, 16 * 60 + 30)]\n    }\n    \n    # Collect all busy intervals\n    all_busy = []\n    for person in busy_times:\n        all_busy.extend(busy_times[person])\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check for a 30-minute slot in free intervals\n    meeting_duration = 30\n    for start, end in free_intervals:\n        if end - start >= meeting_duration:\n            # Convert start time back to HH:MM format\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_472"
        },
        {
            "final_program_time": "{69:00:69:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours\n    start_min = time_to_minutes(start_work)\n    end_min = time_to_minutes(end_work)\n    \n    # Initialize the availability list\n    availability = [True] * (end_min - start_min)\n    \n    # Mark busy times for each participant\n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            busy_start_min = time_to_minutes(busy_start) - start_min\n            busy_end_min = time_to_minutes(busy_end) - start_min\n            for i in range(busy_start_min, busy_end_min):\n                if 0 <= i < len(availability):\n                    availability[i] = False\n    \n    # Find the first available slot of duration\n    required_slots = duration // 30  # assuming 30-minute slots for simplicity\n    current_slots = 0\n    for i in range(len(availability)):\n        if availability[i]:\n            current_slots += 1\n            if current_slots >= required_slots:\n                start_time = i - required_slots + 1\n                meeting_start = start_min + start_time * 30\n                meeting_end = meeting_start + duration\n                return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n        else:\n            current_slots = 0\n    \n    return \"No available time slot found\"\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 30  # minutes\n\n# Define each participant's busy times\nparticipants_schedules = [\n    [(\"9:00\", \"9:30\"), (\"11:30\", \"12:00\")],  # Gregory\n    [(\"9:00\", \"9:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"13:30\"), (\"15:00\", \"16:00\"), (\"16:30\", \"17:00\")],  # Jonathan\n    [(\"10:00\", \"10:30\"), (\"13:30\", \"14:00\")],  # Barbara\n    [(\"10:00\", \"11:00\"), (\"12:30\", \"14:30\")],  # Jesse\n    [(\"9:30\", \"11:00\"), (\"11:30\", \"12:30\"), (\"13:00\", \"15:30\"), (\"16:00\", \"17:00\")],  # Alan\n    [(\"9:00\", \"10:30\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:30\"), (\"14:00\", \"17:00\")],  # Nicole\n    [(\"9:00\", \"10:30\"), (\"12:00\", \"13:30\"), (\"15:00\", \"15:30\"), (\"16:00\", \"16:30\")],  # Catherine\n]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_473"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert work hours to minutes since midnight for easier calculation\n    work_start = work_hours_start * 60\n    work_end = work_hours_end * 60\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    # Collect all busy intervals from each participant's schedule\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start_h, start_m = busy[0], busy[1]\n            end_h, end_m = busy[2], busy[3]\n            start = start_h * 60 + start_m\n            end = end_h * 60 + end_m\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append(interval)\n    \n    # Find available slots by checking gaps between merged busy intervals\n    available_slots = []\n    previous_end = work_start\n    for interval in merged:\n        current_start, current_end = interval\n        if current_start > previous_end:\n            available_slots.append((previous_end, current_start))\n        previous_end = max(previous_end, current_end)\n    # Check the slot after the last busy interval\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Find the first available slot that can accommodate the meeting duration\n    for slot in available_slots:\n        start, end = slot\n        if end - start >= duration_minutes:\n            # Convert start time back to HH:MM format\n            meeting_start = start // 60\n            meeting_start_min = start % 60\n            meeting_end = (start + duration_minutes) // 60\n            meeting_end_min = (start + duration_minutes) % 60\n            return f\"{meeting_start:02d}:{meeting_start_min:02d}:{meeting_end:02d}:{meeting_end_min:02d}\"\n    return None\n\n# Define work hours and meeting duration\nwork_hours_start = 9  # 9:00\nwork_hours_end = 17    # 17:00\nduration_minutes = 30   # 30 minutes\n\n# Define each participant's busy times in HH:MM format (converted to tuples)\nparticipants_schedules = [\n    [],  # Russell is free\n    [(12, 0, 12, 30), (16, 0, 16, 30)],  # Christina\n    [(9, 0, 9, 30), (12, 30, 13, 0)],     # Ethan\n    [],                                   # Brian is free\n    [(9, 0, 12, 0), (12, 30, 14, 0), (15, 0, 15, 30)],  # Peter\n    [(9, 0, 10, 0), (10, 30, 14, 30), (16, 0, 17, 0)],  # Isabella\n    [(9, 30, 11, 30), (12, 0, 12, 30), (13, 30, 14, 0), (15, 0, 17, 0)],  # Dylan\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_474"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy times to minutes since midnight\n    busy_slots = {\n        'Brittany': [(10 * 60, 10 * 60 + 30), (12 * 60, 12 * 60 + 30), (14 * 60 + 30, 15 * 60 + 30)],\n        'Debra': [(9 * 60 + 30, 10 * 60), (11 * 60 + 30, 12 * 60)],\n        'Amber': [(11 * 60, 11 * 60 + 30), (13 * 60, 13 * 60 + 30)],\n        'Theresa': [(14 * 60, 14 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n        'Gloria': [(10 * 60, 13 * 60), (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 16 * 60)],\n        'Amanda': [(9 * 60, 10 * 60 + 30), (11 * 60, 14 * 60), (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Stephanie': [(9 * 60, 9 * 60 + 30), (10 * 60, 11 * 60 + 30), (12 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30), (15 * 60, 16 * 60)],\n    }\n\n    # Combine all busy slots into one list\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n\n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check the time after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can fit the meeting\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_475"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy times in minutes since midnight\n    busy_times = {\n        'Kathleen': [(14 * 60 + 30, 15 * 60 + 30)],\n        'Carolyn': [(12 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30)],\n        'Cheryl': [(9 * 60, 9 * 60 + 30), (10 * 60, 11 * 60 + 30), (12 * 60 + 30, 13 * 60 + 30), (14 * 60, 17 * 60)],\n        'Virginia': [(9 * 60 + 30, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Angela': [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60, 16 * 60 + 30)],\n    }\n    \n    # Roger's preference: not before 12:30\n    roger_preference_start = 12 * 60 + 30\n    \n    # Combine all busy times and sort them\n    all_busy = []\n    for person in busy_times:\n        for start, end in busy_times[person]:\n            all_busy.append((start, end))\n    \n    # Add Roger's preference as a busy time before 12:30\n    all_busy.append((work_start, roger_preference_start))\n    \n    # Sort all busy intervals\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Find the first available 30-minute slot\n    meeting_duration = 30\n    previous_end = work_start\n    \n    for start, end in merged_busy:\n        if start - previous_end >= meeting_duration:\n            # Found a slot\n            meeting_start = previous_end\n            meeting_end = meeting_start + meeting_duration\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n        previous_end = max(previous_end, end)\n    \n    # Check after the last busy interval\n    if work_end - previous_end >= meeting_duration:\n        meeting_start = previous_end\n        meeting_end = meeting_start + meeting_duration\n        return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No available time slot found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_476"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start, end = work_hours\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        h = minutes // 60\n        m = minutes % 60\n        return f\"{h:02d}:{m:02d}\"\n    \n    start_min = time_to_minutes(start)\n    end_min = time_to_minutes(end)\n    \n    # Initialize a list to mark busy intervals\n    timeline = []\n    for person, schedules in participants_schedules.items():\n        for interval in schedules:\n            s, e = map(time_to_minutes, interval.split(' to '))\n            timeline.append((s, e))\n    \n    # Sort all busy intervals\n    timeline.sort()\n    \n    # Find the earliest available slot\n    current_time = start_min\n    for s, e in timeline:\n        if s > current_time:\n            if s - current_time >= duration:\n                return f\"{minutes_to_time(current_time)}:{minutes_to_time(current_time + duration)}\"\n            current_time = e\n        else:\n            if e > current_time:\n                current_time = e\n    # Check after the last busy interval\n    if end_min - current_time >= duration:\n        return f\"{minutes_to_time(current_time)}:{minutes_to_time(current_time + duration)}\"\n    return \"No available slot\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    'Julia': [],\n    'Bryan': ['10:00 to 10:30', '11:00 to 12:00', '13:30 to 14:00', '14:30 to 15:00', '15:30 to 16:00'],\n    'Betty': [],\n    'Arthur': ['9:30 to 10:00', '12:00 to 12:30'],\n    'Megan': ['9:30 to 12:00', '12:30 to 13:00', '14:00 to 15:00', '15:30 to 16:30'],\n    'Kevin': ['9:00 to 9:30', '10:00 to 11:30', '13:00 to 13:30', '14:00 to 15:30'],\n    'Alice': ['9:00 to 15:30', '16:00 to 16:30']\n}\n\n# Work hours and meeting duration\nwork_hours = ('9:00', '17:00')\nduration = 30  # minutes\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_477"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_start=9 * 60, work_end=17 * 60):\n    # Convert work hours to minutes since midnight\n    work_start_min = work_start\n    work_end_min = work_end\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for schedule in participants_schedules:\n        all_busy_intervals.extend(schedule)\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_intervals = []\n    for interval in all_busy_intervals:\n        if not merged_intervals:\n            merged_intervals.append(interval)\n        else:\n            last_start, last_end = merged_intervals[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged_intervals[-1] = (new_start, new_end)\n            else:\n                merged_intervals.append(interval)\n    \n    # Find free intervals by looking at gaps between busy intervals\n    free_intervals = []\n    previous_end = work_start_min\n    \n    for interval in merged_intervals:\n        current_start, current_end = interval\n        if current_start > previous_end:\n            free_intervals.append((previous_end, current_start))\n        previous_end = max(previous_end, current_end)\n    \n    # Check the time after the last busy interval until work_end\n    if previous_end < work_end_min:\n        free_intervals.append((previous_end, work_end_min))\n    \n    # Find the first free interval that can accommodate the meeting duration\n    for interval in free_intervals:\n        start, end = interval\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules in minutes since midnight\nparticipants_schedules = [\n    # Kimberly is free the entire day\n    [],\n    # Deborah: 12:00-13:00, 14:30-15:30\n    [(12 * 60, 13 * 60), (14 * 60 + 30, 15 * 60 + 30)],\n    # Samuel: 9:00-9:30, 10:00-10:30, 11:30-12:30, 15:30-16:30\n    [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60 + 30), (15 * 60 + 30, 16 * 60 + 30)],\n    # Lisa: 9:30-10:00, 11:30-12:00, 12:30-13:30, 15:30-16:30\n    [(9 * 60 + 30, 10 * 60), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60 + 30), (15 * 60 + 30, 16 * 60 + 30)],\n    # Vincent: 9:30-10:30, 11:00-12:00, 12:30-13:00, 14:00-15:30, 16:00-17:00\n    [(9 * 60 + 30, 10 * 60 + 30), (11 * 60, 12 * 60), (12 * 60 + 30, 13 * 60), (14 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n    # Julia: 9:00-9:30, 11:00-14:00, 15:00-15:30\n    [(9 * 60, 9 * 60 + 30), (11 * 60, 14 * 60), (15 * 60, 15 * 60 + 30)],\n    # Judith: 9:00-9:30, 10:00-10:30, 11:00-12:00, 12:30-14:00, 14:30-17:00\n    [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (11 * 60, 12 * 60), (12 * 60 + 30, 14 * 60), (14 * 60 + 30, 17 * 60)],\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_478"
        },
        {
            "final_program_time": "{9:30:10:30}",
            "expected_time": "{9:30:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = work_hours\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Collect all busy times for all participants\n    all_busy_times = []\n    for busy_times in participants_busy_times.values():\n        for busy_start, busy_end in busy_times:\n            all_busy_times.append((time_to_minutes(busy_start), time_to_minutes(busy_end)))\n    \n    # Sort all busy times by start time\n    all_busy_times.sort()\n    \n    # Merge overlapping or adjacent busy times\n    merged_busy = []\n    for start, end in all_busy_times:\n        if not merged_busy:\n            merged_busy.append([start, end])\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                merged_busy[-1][1] = max(end, last_end)\n            else:\n                merged_busy.append([start, end])\n    \n    # Find available slots by checking gaps between busy times and work hours\n    available_slots = []\n    prev_end = work_start_min\n    for start, end in merged_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        available_slots.append((prev_end, work_end_min))\n    \n    # Check each available slot for duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration_hours = 1\n\n# Define each participant's busy times\nparticipants_busy_times = {\n    \"Evelyn\": [],\n    \"Joshua\": [(\"11:00\", \"12:30\"), (\"13:30\", \"14:30\"), (\"16:30\", \"17:00\")],\n    \"Kevin\": [],\n    \"Gerald\": [],\n    \"Jerry\": [(\"9:00\", \"9:30\"), (\"10:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"13:30\", \"14:00\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:00\")],\n    \"Jesse\": [(\"9:00\", \"9:30\"), (\"10:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:30\")],\n    \"Kenneth\": [(\"10:30\", \"12:30\"), (\"13:30\", \"14:00\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:00\"), (\"16:30\", \"17:00\")],\n}\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy_times, work_hours, duration_hours))\n```",
            "count": "calendar_scheduling_example_479"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals during work hours\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability across all participants\n    possible_slots = []\n    for interval in free_intervals:\n        start, end = interval\n        duration = end - start\n        if duration >= meeting_duration:\n            possible_slots.append((start, start + meeting_duration))\n    \n    # The first suitable slot is chosen\n    if possible_slots:\n        start, end = possible_slots[0]\n        return f\"{minutes_to_time(start)}:{minutes_to_time(end)}\"\n    else:\n        return \"No suitable time found\"\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 30  # minutes\n\n# Define each participant's busy times\nparticipants_schedules = [\n    [\"11:00 to 12:00\", \"14:00 to 14:30\", \"16:30 to 17:00\"],  # Betty\n    [],  # Roy\n    [\"9:30 to 10:00\", \"11:00 to 12:00\", \"14:00 to 14:30\", \"15:30 to 16:30\"],  # Douglas\n    [\"12:00 to 12:30\", \"13:00 to 14:00\", \"16:00 to 16:30\"],  # Kimberly\n    [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:00 to 12:30\", \"13:00 to 13:30\", \"14:00 to 14:30\", \"15:30 to 17:00\"],  # Ashley\n    [\"9:00 to 11:00\", \"11:30 to 12:30\", \"13:30 to 14:30\", \"16:00 to 17:00\"],  # Isabella\n    [\"9:00 to 9:30\", \"10:00 to 10:30\", \"12:30 to 14:30\", \"15:00 to 17:00\"],  # Carl\n]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_480"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since 9:00 (work_hours_start)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - work_hours_start) * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = work_hours_start + (minutes // 60)\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        person_busy = []\n        for busy_block in schedule:\n            start, end = busy_block.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            person_busy.append((start_min, end_min))\n        busy_intervals.append(person_busy)\n    \n    # Find the earliest and latest possible times in minutes\n    earliest = 0\n    latest = (work_hours_end - work_hours_start) * 60\n    \n    # Generate all possible busy intervals combined\n    all_busy = []\n    for person in busy_intervals:\n        for interval in person:\n            all_busy.append(interval)\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots\n    available = []\n    prev_end = earliest\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < latest:\n        available.append((prev_end, latest))\n    \n    # Check each available slot for duration\n    for slot in available:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            return (minutes_to_time(meeting_start), minutes_to_time(meeting_end))\n    \n    return None\n\n# Define work hours and duration\nwork_hours_start = 9\nwork_hours_end = 17\nduration_minutes = 30\n\n# Define each participant's busy times\nparticipants_schedules = [\n    [\"11:30 to 13:00\", \"13:30 to 14:00\"],  # Andrew\n    [\"12:00 to 12:30\", \"13:30 to 14:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"],  # Keith\n    [\"9:30 to 10:00\", \"12:30 to 13:00\", \"13:30 to 14:00\", \"14:30 to 15:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"],  # Pamela\n    [\"9:00 to 9:30\", \"11:00 to 12:30\", \"14:30 to 15:30\"],  # Carol\n    [\"9:00 to 13:00\", \"14:00 to 14:30\", \"15:00 to 16:00\", \"16:30 to 17:00\"],  # Barbara\n    [\"9:00 to 9:30\", \"10:00 to 10:30\", \"12:30 to 16:00\", \"16:30 to 17:00\"],  # Ronald\n    [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:00 to 11:30\", \"12:00 to 12:30\", \"13:00 to 16:00\"],  # Diana\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nif meeting_time:\n    print(f\"{meeting_time[0]}:{meeting_time[1]}\")\nelse:\n    print(\"No available time slot found.\")\n```",
            "count": "calendar_scheduling_example_481"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy times in minutes (start, end)\n    busy_times = {\n        'Frank': [(12 * 60, 12 * 60 + 30), (14 * 60, 14 * 60 + 30)],\n        'Michael': [],\n        'Jeremy': [(10 * 60 + 30, 11 * 60), (13 * 60, 13 * 60 + 30), \n                   (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60)],\n        'Charles': [(10 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60)],\n        'Scott': [(9 * 60, 13 * 60), (13 * 60 + 30, 16 * 60 + 30)],\n        'Kelly': [(9 * 60, 9 * 60 + 30), (10 * 60, 14 * 60 + 30), \n                  (15 * 60, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Julie': [(9 * 60 + 30, 10 * 60), (11 * 60, 13 * 60 + 30), \n                  (14 * 60, 14 * 60 + 30), (15 * 60, 16 * 60 + 30)]\n    }\n    \n    # Collect all busy intervals\n    all_busy = []\n    for person in busy_times:\n        all_busy.extend(busy_times[person])\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for a 30-minute slot\n    meeting_duration = 30\n    for start, end in free_intervals:\n        if end - start >= meeting_duration:\n            # Convert minutes back to HH:MM format\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_482"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all times to minutes since start of day for easier calculation\n    start_min = work_hours_start * 60\n    end_min = work_hours_end * 60\n    duration = duration_minutes\n\n    # Initialize a list to keep track of busy intervals for all participants\n    all_busy = []\n\n    # Collect all busy intervals\n    for busy_intervals in participants_busy.values():\n        for start, end in busy_intervals:\n            all_busy.append((start * 60, end * 60))\n\n    # Sort all busy intervals by start time\n    all_busy.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n\n    # Find the earliest available slot\n    prev_end = start_min\n    for start, end in merged_busy:\n        if start - prev_end >= duration:\n            # Found a suitable slot\n            meeting_start = prev_end\n            meeting_end = meeting_start + duration\n            return (meeting_start, meeting_end)\n        prev_end = max(prev_end, end)\n\n    # Check the slot after the last busy interval\n    if end_min - prev_end >= duration:\n        meeting_start = prev_end\n        meeting_end = meeting_start + duration\n        return (meeting_start, meeting_end)\n\n    # No slot found (though the problem states there is one)\n    return None\n\n# Define work hours and meeting duration\nwork_hours_start = 9  # 9:00\nwork_hours_end = 17    # 17:00\nduration_minutes = 30  # 30 minutes\n\n# Define each participant's busy times in their local time\nparticipants_busy = {\n    'Nicholas': [(9, 9.5), (11, 11.5), (12.5, 13), (15.5, 16)],\n    'Sara': [(10, 10.5), (11, 11.5)],\n    'Helen': [],\n    'Brian': [],\n    'Nancy': [(9, 10), (11, 14), (15, 17)],\n    'Kelly': [(10, 11.5), (12, 12.5), (13.5, 14), (14.5, 15.5), (16.5, 17)],\n    'Judy': [(9, 11.5), (12, 12.5), (13, 13.5), (14.5, 17)],\n}\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours_start, work_hours_end, duration_minutes)\n\n# Format the output as HH:MM:HH:MM\nif meeting_time:\n    start_min, end_min = meeting_time\n    start_hh = int(start_min // 60)\n    start_mm = int(start_min % 60)\n    end_hh = int(end_min // 60)\n    end_mm = int(end_min % 60)\n    print(f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_483"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"12:00 to 12:30\", \"14:00 to 14:30\", \"15:30 to 16:30\"],  # Jean\n    [],  # Susan\n    [],  # Beverly\n    [\"9:30 to 11:00\", \"12:30 to 13:00\", \"15:00 to 15:30\", \"16:30 to 17:00\"],  # Denise\n    [\"9:00 to 12:00\", \"14:30 to 16:30\"],  # Jeffrey\n    [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:00 to 13:00\", \"13:30 to 14:30\"],  # Mary\n    [\"9:00 to 10:00\", \"10:30 to 13:00\", \"13:30 to 15:00\", \"15:30 to 16:30\"],  # Joseph\n]\n\n# Find a meeting time\nmeeting_time = find_meeting_time(participants_schedules, \"9:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_484"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:13:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    start_hour, end_hour = work_hours\n    # Convert work hours to minutes for easier calculation\n    start_time = start_hour * 60\n    end_time = end_hour * 60\n    duration_min = duration * 60\n    \n    # Initialize a list to keep track of busy times for all participants\n    all_busy_times = []\n    \n    for person, schedules in participants_schedules.items():\n        for busy_start, busy_end in schedules:\n            # Convert each busy time to minutes\n            busy_start_min = busy_start[0] * 60 + busy_start[1]\n            busy_end_min = busy_end[0] * 60 + busy_end[1]\n            all_busy_times.append((busy_start_min, busy_end_min))\n    \n    # Sort all busy times by start time\n    all_busy_times.sort()\n    \n    # Find the earliest available slot\n    previous_end = start_time\n    for busy_start, busy_end in all_busy_times:\n        if busy_start > previous_end:\n            # Check if the gap is enough for the meeting\n            if busy_start - previous_end >= duration_min:\n                # Convert back to HH:MM format\n                start_slot = divmod(previous_end, 60)\n                end_slot = divmod(previous_end + duration_min, 60)\n                return f\"{start_slot[0]:02d}:{start_slot[1]:02d}:{end_slot[0]:02d}:{end_slot[1]:02d}\"\n        previous_end = max(previous_end, busy_end)\n    \n    # Check the time after the last busy slot until end of work hours\n    if end_time - previous_end >= duration_min:\n        start_slot = divmod(previous_end, 60)\n        end_slot = divmod(previous_end + duration_min, 60)\n        return f\"{start_slot[0]:02d}:{start_slot[1]:02d}:{end_slot[0]:02d}:{end_slot[1]:02d}\"\n    \n    return \"No available slot found\"\n\n# Define the participants' schedules in HH:MM format converted to tuples of (hour, minute)\nparticipants_schedules = {\n    \"Roy\": [((11, 0), (11, 30)), ((15, 30), (16, 0))],\n    \"Kayla\": [((10, 30), (11, 0)), ((12, 0), (13, 0)), ((13, 30), (14, 0)), ((14, 30), (15, 0)), ((15, 30), (16, 0))],\n    \"Alexis\": [],\n    \"Eugene\": [((11, 30), (12, 0)), ((12, 30), (13, 0))],\n    \"Matthew\": [((9, 0), (10, 0)), ((11, 0), (12, 30)), ((14, 0), (14, 30)), ((15, 0), (16, 0))],\n    \"Alice\": [((9, 0), (10, 30)), ((11, 0), (13, 0)), ((13, 30), (14, 30)), ((15, 0), (16, 30))],\n    \"Frank\": [((9, 0), (10, 0)), ((11, 30), (12, 0)), ((13, 30), (15, 0)), ((15, 30), (16, 0)), ((16, 30), (17, 0))],\n}\n\n# Meeting duration in hours\nduration = 0.5\n# Work hours in 24-hour format\nwork_hours = (9, 17)\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_485"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:30:15:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_start, work_end, duration):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Collect all busy intervals\n    all_busy_intervals = []\n    for busy_times in participants_busy_times.values():\n        for interval in busy_times:\n            start, end = interval.split(' to ')\n            all_busy_intervals.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort intervals by start time\n    all_busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged_intervals = []\n    for start, end in all_busy_intervals:\n        if not merged_intervals:\n            merged_intervals.append([start, end])\n        else:\n            last_start, last_end = merged_intervals[-1]\n            if start <= last_end:\n                merged_intervals[-1][1] = max(end, last_end)\n            else:\n                merged_intervals.append([start, end])\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start_min\n    for start, end in merged_intervals:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        available_slots.append((prev_end, work_end_min))\n    \n    # Find the first available slot that fits the duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' busy times\nparticipants_busy_times = {\n    \"Logan\": [\"9:30 to 10:00\", \"11:30 to 12:00\"],\n    \"Kimberly\": [\"14:00 to 14:30\", \"16:00 to 16:30\"],\n    \"Angela\": [\"10:00 to 10:30\", \"13:00 to 13:30\", \"14:00 to 14:30\", \"15:30 to 16:00\"],\n    \"Matthew\": [],\n    \"Dylan\": [\"9:30 to 12:00\", \"13:00 to 14:00\", \"15:30 to 16:00\"],\n    \"Marilyn\": [\"9:00 to 11:00\", \"11:30 to 14:30\", \"15:00 to 17:00\"],\n    \"Grace\": [\"9:00 to 9:30\", \"10:00 to 11:00\", \"11:30 to 12:30\", \"13:00 to 14:00\", \"15:30 to 17:00\"]\n}\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_busy_times, \"9:00\", \"17:00\", 0.5)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_486"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    busy_slots = {\n        'Albert': [],\n        'Rebecca': [(13 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30)],\n        'Ronald': [(10 * 60 + 30, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (15 * 60, 15 * 60 + 30)],\n        'Pamela': [(13 * 60 + 30, 14 * 60), (16 * 60, 16 * 60 + 30)],\n        'Noah': [(9 * 60 + 30, 11 * 60), (11 * 60 + 30, 12 * 60 + 30), (13 * 60, 13 * 60 + 30),\n                 (14 * 60, 14 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Diana': [(9 * 60, 13 * 60), (13 * 60 + 30, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Jacqueline': [(9 * 60 + 30, 12 * 60), (13 * 60, 15 * 60), (16 * 60, 16 * 60 + 30)],\n    }\n\n    # Collect all busy slots\n    all_busy = []\n    for person_slots in busy_slots.values():\n        all_busy.extend(person_slots)\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the time after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_487"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:30:11:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_start=\"09:00\", work_end=\"17:00\"):\n    # Convert time string to minutes since midnight\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start_min, work_end_min)]\n    \n    # Process each participant's schedule to find common free slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_slots.append((start, end))\n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Merge overlapping or adjacent busy slots\n        merged_busy = []\n        for start, end in busy_slots:\n            if not merged_busy:\n                merged_busy.append((start, end))\n            else:\n                last_start, last_end = merged_busy[-1]\n                if start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = last_start\n                    new_end = max(last_end, end)\n                    merged_busy[-1] = (new_start, new_end)\n                else:\n                    merged_busy.append((start, end))\n        \n        # Subtract busy slots from current free slots\n        new_free_slots = []\n        for free_start, free_end in free_slots:\n            current_start = free_start\n            for busy_start, busy_end in merged_busy:\n                if busy_start > current_start:\n                    # Add the free slot before the busy slot\n                    new_free_slots.append((current_start, busy_start))\n                current_start = max(current_start, busy_end)\n            if current_start < free_end:\n                new_free_slots.append((current_start, free_end))\n        free_slots = new_free_slots\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [],  # Samuel is free the entire day\n    [\"09:00:10:00\", \"13:30:14:00\", \"16:30:17:00\"],  # Maria\n    [\"09:00:09:30\", \"16:00:16:30\"],  # Bryan\n    [\"10:00:10:30\", \"11:00:12:00\", \"14:00:14:30\", \"15:00:15:30\", \"16:30:17:00\"],  # Kyle\n    [\"09:00:10:30\", \"11:00:11:30\", \"12:00:15:00\", \"15:30:16:00\", \"16:30:17:00\"],  # Christina\n    [\"09:00:09:30\", \"10:00:10:30\", \"11:00:11:30\", \"12:00:15:00\", \"15:30:17:00\"],  # Virginia\n    [\"09:00:10:30\", \"11:30:17:00\"],  # Ann\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_488"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert each participant's busy slots to minutes\n    busy_slots = {\n        'Cynthia': [(11*60 + 30, 12*60), (12*60 + 30, 13*60), (14*60, 14*60 + 30), (15*60, 15*60 + 30)],\n        'Carol': [(9*60, 10*60)],\n        'Billy': [(9*60, 9*60 + 30), (10*60, 10*60 + 30)],\n        'Albert': [(9*60 + 30, 10*60), (11*60 + 30, 13*60), (14*60, 15*60 + 30), (16*60 + 30, 17*60)],\n        'Doris': [(9*60, 11*60 + 30), (12*60, 13*60), (13*60 + 30, 14*60), (14*60 + 30, 15*60), (16*60, 16*60 + 30)],\n        'Keith': [(10*60, 10*60 + 30), (11*60, 12*60), (12*60 + 30, 14*60), (15*60, 15*60 + 30), (16*60, 16*60 + 30)],\n    }\n\n    # Jean is free all day, so no busy slots\n\n    # Collect all busy slots from all participants except Jean\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n\n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the time after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_489"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:00:15:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert time strings to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    \n    # Collect all busy intervals\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find the earliest available slot\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available_start = prev_end\n            available_end = start\n            if available_end - available_start >= duration:\n                return f\"{minutes_to_time(available_start)}:{minutes_to_time(available_start + duration)}\"\n        prev_end = max(prev_end, end)\n    \n    # Check after the last busy interval\n    if work_end - prev_end >= duration:\n        return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + duration)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"09:00:09:30\", \"12:00:12:30\", \"13:30:14:00\", \"14:30:15:00\"],  # Nancy\n    [],  # Julie\n    [\"11:30:12:00\", \"13:00:13:30\"],  # Randy\n    [\"12:00:12:30\", \"16:30:17:00\"],  # Anthony\n    [\"09:00:09:30\", \"10:00:11:00\", \"12:00:13:00\", \"13:30:14:00\", \"15:30:16:30\"],  # Alan\n    [\"09:00:09:30\", \"10:00:11:00\", \"11:30:14:30\", \"15:30:17:00\"],  # Denise\n    [\"09:00:10:00\", \"11:00:12:30\", \"13:30:14:30\", \"16:30:17:00\"],  # Jacob\n]\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_490"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_start=9*60, work_end=17*60):\n    # Convert all schedules to minutes since midnight for easier comparison\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start_h, start_m = map(int, interval.split(':')[:2])\n            end_h, end_m = map(int, interval.split(':')[2:4])\n            start = start_h * 60 + start_m\n            end = end_h * 60 + end_m\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                new_end = max(last_end, current_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append(interval)\n    \n    # Find available slots between work hours and busy intervals\n    available_slots = []\n    prev_end = work_start\n    for interval in merged:\n        start, end = interval\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            start_h = meeting_start // 60\n            start_m = meeting_start % 60\n            end_h = meeting_end // 60\n            end_m = meeting_end % 60\n            return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    return \"No available time slot found\"\n\n# Define participants' schedules in HH:MM:HH:MM format\nparticipants_schedules = [\n    [\"12:00:13:00\", \"14:00:14:30\", \"15:00:15:30\"],  # Patricia\n    [\"11:30:12:00\", \"14:00:15:00\", \"16:00:16:30\"],  # Nathan\n    [\"12:30:13:00\", \"14:30:15:00\", \"16:00:17:00\"],  # James\n    [\"09:00:09:30\", \"10:00:10:30\", \"12:30:13:00\", \"14:00:14:30\", \"16:00:17:00\"],  # Pamela\n    [\"09:00:13:00\", \"13:30:16:00\", \"16:30:17:00\"],  # Raymond\n    [\"09:00:09:30\", \"10:00:12:30\", \"14:30:15:00\", \"15:30:16:00\"],  # Cheryl\n    [\"09:00:11:00\", \"11:30:12:00\", \"12:30:13:00\", \"14:30:15:00\", \"15:30:17:00\"],  # Michelle\n]\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules))\n```",
            "count": "calendar_scheduling_example_491"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:11:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    start_work, end_work = work_hours\n    start_work_min = time_to_minutes(start_work)\n    end_work_min = time_to_minutes(end_work)\n    duration_min = duration * 60\n\n    # Collect all busy intervals for all participants\n    all_busy_intervals = []\n    for busy_times in participants_busy_times.values():\n        for interval in busy_times:\n            start, end = interval\n            all_busy_intervals.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged_intervals = []\n    for start, end in all_busy_intervals:\n        if not merged_intervals:\n            merged_intervals.append([start, end])\n        else:\n            last_start, last_end = merged_intervals[-1]\n            if start <= last_end:\n                merged_intervals[-1][1] = max(end, last_end)\n            else:\n                merged_intervals.append([start, end])\n\n    # Find available slots by checking gaps between merged intervals and work hours\n    available_slots = []\n    prev_end = start_work_min\n    for start, end in merged_intervals:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < end_work_min:\n        available_slots.append((prev_end, end_work_min))\n\n    # Find the first available slot that can fit the meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No available time slot found\"\n\n# Define the participants' busy times\nparticipants_busy_times = {\n    \"David\": [],\n    \"Julie\": [(\"11:30\", \"12:00\"), (\"14:30\", \"15:00\")],\n    \"Natalie\": [(\"13:30\", \"14:30\")],\n    \"Michelle\": [],\n    \"Brittany\": [(\"9:00\", \"10:30\"), (\"11:30\", \"12:30\"), (\"13:00\", \"13:30\"), (\"14:00\", \"17:00\")],\n    \"Richard\": [(\"9:00\", \"11:00\"), (\"11:30\", \"13:00\"), (\"13:30\", \"17:00\")],\n    \"Christine\": [(\"9:00\", \"10:30\"), (\"12:00\", \"14:30\"), (\"15:00\", \"15:30\"), (\"16:30\", \"17:00\")],\n}\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nmeeting_duration = 0.5  # in hours\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_492"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration_minutes=30, work_hours=('09:00', '17:00')):\n    # Convert work hours to minutes since midnight\n    start_work, end_work = work_hours\n    work_start = int(start_work.split(':')[0]) * 60 + int(start_work.split(':')[1])\n    work_end = int(end_work.split(':')[0]) * 60 + int(end_work.split(':')[1])\n    \n    # Initialize the free slots for the day\n    free_slots = []\n    current_start = work_start\n    \n    # Generate all possible busy slots from all participants\n    busy_slots = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = busy\n            start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n            end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n            busy_slots.append((start_min, end_min))\n    \n    # Sort busy slots by start time\n    busy_slots.sort()\n    \n    # Merge overlapping or adjacent busy slots\n    merged_busy = []\n    for start, end in busy_slots:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Generate free slots by finding gaps between busy slots and work hours\n    free_slots = []\n    prev_end = work_start\n    for start, end in merged_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Find the first free slot that can accommodate the meeting duration\n    for start, end in free_slots:\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [],  # Tyler\n    [],  # Kelly\n    [(\"11:00\", \"11:30\"), (\"14:30\", \"15:00\")],  # Stephanie\n    [],  # Hannah\n    [(\"09:00\", \"09:30\"), (\"10:00\", \"12:00\"), (\"12:30\", \"13:00\"), (\"14:00\", \"17:00\")],  # Joe\n    [(\"09:00\", \"10:30\"), (\"11:30\", \"12:00\"), (\"13:00\", \"14:00\"), (\"14:30\", \"15:30\"), (\"16:00\", \"17:00\")],  # Diana\n    [(\"09:00\", \"10:00\"), (\"10:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"13:30\", \"14:00\"), (\"14:30\", \"15:30\"), (\"16:00\", \"16:30\")],  # Deborah\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_493"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert work hours to minutes for easier calculation\n    start_time = work_hours_start * 60\n    end_time = work_hours_end * 60\n    \n    # Initialize a list to keep track of busy intervals in minutes\n    busy_intervals = []\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            busy_start_min = busy_start[0] * 60 + busy_start[1]\n            busy_end_min = busy_end[0] * 60 + busy_end[1]\n            busy_intervals.append((busy_start_min, busy_end_min))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append(interval)\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    previous_end = start_time\n    \n    for interval in merged:\n        current_start, current_end = interval\n        if current_start > previous_end:\n            available_slots.append((previous_end, current_start))\n        previous_end = max(previous_end, current_end)\n    \n    # Check the time after the last busy interval until end of work hours\n    if previous_end < end_time:\n        available_slots.append((previous_end, end_time))\n    \n    # Find the first available slot that can fit the meeting duration\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules in HH:MM converted to tuples of (HH, MM)\nparticipants_schedules = [\n    [((10, 30), (11, 00)), ((11, 30), (12, 00))],  # Denise\n    [((14, 00), (14, 30)), ((16, 30), (17, 00))],  # Roy\n    [],                                             # Roger\n    [((10, 00), (11, 00)), ((14, 00), (14, 30)), ((16, 00), (16, 30))],  # Debra\n    [((9, 00), (9, 30)), ((10, 00), (11, 30)), ((12, 00), (12, 30)), \n     ((13, 00), (13, 30)), ((14, 30), (15, 00)), ((16, 30), (17, 00))],  # David\n    [((9, 00), (9, 30)), ((10, 00), (10, 30)), ((11, 00), (11, 30)), \n     ((12, 30), (13, 30)), ((14, 00), (15, 00)), ((15, 30), (17, 00))],  # Danielle\n    [((9, 00), (11, 00)), ((11, 30), (14, 30)), ((16, 00), (17, 00))],   # Brian\n]\n\n# Work hours and meeting duration\nwork_hours_start = 9\nwork_hours_end = 17\nduration_minutes = 30\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes))\n```",
            "count": "calendar_scheduling_example_494"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:30:10:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    start_work, end_work = work_hours.split(' to ')\n    start_work_min = time_to_minutes(start_work)\n    end_work_min = time_to_minutes(end_work)\n\n    # Initialize a list to mark busy intervals\n    timeline = [False] * (end_work_min - start_work_min)\n\n    # Mark busy intervals for each participant\n    for person, schedules in participants_schedules.items():\n        for schedule in schedules:\n            start, end = schedule.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            # Clamp to work hours\n            start_min = max(start_min, start_work_min)\n            end_min = min(end_min, end_work_min)\n            for i in range(start_min - start_work_min, end_min - start_work_min):\n                if i >= 0 and i < len(timeline):\n                    timeline[i] = True\n\n    # Find a free slot of duration\n    duration_min = duration * 60  # Convert hours to minutes\n    current_start = None\n    consecutive_free = 0\n\n    for i, busy in enumerate(timeline):\n        if not busy:\n            if current_start is None:\n                current_start = i\n            consecutive_free += 1\n            if consecutive_free >= duration_min:\n                start_time = minutes_to_time(current_start + start_work_min)\n                end_time = minutes_to_time(current_start + start_work_min + duration_min)\n                return f\"{start_time}:{end_time}\"\n        else:\n            current_start = None\n            consecutive_free = 0\n\n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"Jordan\": [\"10:00 to 11:00\", \"11:30 to 12:00\", \"13:00 to 13:30\", \"14:30 to 15:00\", \"16:00 to 16:30\"],\n    \"Ralph\": [\"12:30 to 13:00\", \"14:00 to 14:30\"],\n    \"Kathryn\": [],\n    \"Isabella\": [\"12:30 to 13:00\", \"14:00 to 14:30\", \"15:30 to 16:30\"],\n    \"Roger\": [\"9:00 to 9:30\", \"10:00 to 11:00\", \"12:30 to 17:00\"],\n    \"Henry\": [\"9:00 to 9:30\", \"10:00 to 13:00\", \"13:30 to 15:00\", \"15:30 to 16:30\"],\n    \"Anthony\": [\"9:00 to 9:30\", \"10:30 to 13:00\", \"13:30 to 14:00\", \"15:00 to 16:30\"]\n}\n\nwork_hours = \"9:00 to 17:00\"\nduration = 0.5  # half an hour\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_495"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time slots to minutes since start of the day for easier calculation\n    start_min = work_hours_start * 60\n    end_min = work_hours_end * 60\n    duration = duration_minutes\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for block in schedule:\n            start_h, start_m, end_h, end_m = block\n            start = start_h * 60 + start_m\n            end = end_h * 60 + end_m\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by checking gaps between busy intervals\n    free_intervals = []\n    prev_end = start_min\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    # Check the time after the last busy interval\n    if prev_end < end_min:\n        free_intervals.append((prev_end, end_min))\n    \n    # Now find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_h = meeting_start // 60\n            start_m = meeting_start % 60\n            end_h = meeting_end // 60\n            end_m = meeting_end % 60\n            return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules in HH:MM:HH:MM format converted to tuples\nparticipants_schedules = [\n    [(12, 30, 13, 00), (15, 00, 15, 30)],  # Zachary\n    [(9, 00, 10, 00), (12, 00, 12, 30), (13, 30, 14, 00)],  # Amanda\n    [],  # Keith\n    [(9, 30, 10, 30), (12, 30, 13, 00), (16, 00, 16, 30)],  # Ruth\n    [(10, 00, 11, 00), (11, 30, 12, 00), (13, 30, 14, 00), (15, 00, 17, 00)],  # Noah\n    [(9, 00, 14, 30), (15, 30, 17, 00)],  # Sean\n    [(9, 00, 11, 00), (13, 00, 14, 30), (16, 30, 17, 00)],  # Sara\n]\n\n# Work hours and meeting duration\nwork_hours_start = 9\nwork_hours_end = 17\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_496"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert each participant's busy slots to minutes\n    busy_slots = {\n        'Robert': [],\n        'Kyle': [(9*60 + 30, 10*60), (11*60 + 30, 12*60), (14*60, 15*60)],\n        'Russell': [(9*60, 9*60 + 30), (10*60 + 30, 11*60), (12*60, 12*60 + 30), (16*60, 16*60 + 30)],\n        'Juan': [(11*60 + 30, 12*60), (13*60, 14*60), (14*60 + 30, 15*60)],\n        'Beverly': [(9*60, 10*60), (10*60 + 30, 11*60 + 30), (13*60, 14*60 + 30), (15*60, 15*60 + 30)],\n        'Bryan': [(9*60, 9*60 + 30), (10*60 + 30, 11*60 + 30), (12*60, 12*60 + 30), (13*60, 17*60)],\n        'Margaret': [(9*60, 10*60), (10*60 + 30, 12*60), (12*60 + 30, 17*60)]\n    }\n\n    # Collect all busy slots\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n\n    # Merge overlapping or adjacent busy slots\n    all_busy.sort()\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find free slots between work hours, considering merged busy slots\n    free_slots = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n\n    # Check each free slot for the first 30-minute availability\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert start time back to HH:MM format\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_497"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours, duration):\n    # Convert all time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start, work_end = map(time_to_minutes, work_hours.split(' to '))\n    \n    # Initialize the free slots for the day (work hours)\n    free_slots = [work_start, work_end]\n    \n    # Collect all busy times and convert to minutes\n    busy_periods = []\n    for busy_times in participants_busy_times.values():\n        for busy in busy_times:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_periods.append((start, end))\n    \n    # Sort busy periods by start time\n    busy_periods.sort()\n    \n    # Merge overlapping or adjacent busy periods\n    merged_busy = []\n    for start, end in busy_periods:\n        if not merged_busy:\n            merged_busy.append([start, end])\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                merged_busy[-1][1] = max(end, last_end)\n            else:\n                merged_busy.append([start, end])\n    \n    # Find free slots between busy periods and work hours\n    free_slots = []\n    prev_end = work_start\n    for start, end in merged_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Check each free slot for availability of duration\n    for start, end in free_slots:\n        if end - start >= duration:\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            \n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' busy times\nparticipants_busy_times = {\n    \"Diana\": [],\n    \"Richard\": [\"11:00 to 11:30\", \"14:30 to 15:00\"],\n    \"Judith\": [\"9:00 to 9:30\", \"15:00 to 15:30\"],\n    \"Ryan\": [\"13:00 to 13:30\", \"16:30 to 17:00\"],\n    \"Alexis\": [\"9:00 to 10:00\", \"10:30 to 11:00\", \"12:00 to 13:00\", \"13:30 to 15:00\", \"16:00 to 17:00\"],\n    \"Donna\": [\"9:00 to 9:30\", \"11:30 to 13:30\", \"14:30 to 15:00\", \"16:00 to 17:00\"],\n    \"Jason\": [\"9:00 to 12:30\", \"13:00 to 14:00\", \"14:30 to 15:00\"],\n}\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nduration_minutes = 30  # meeting duration in minutes\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_498"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define all participants' busy times in minutes (start, end)\n    busy_times = {\n        'Patrick': [(12 * 60 + 30, 13 * 60), (14 * 60 + 30, 15 * 60)],\n        'Joyce': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60), (15 * 60, 15 * 60 + 30)],\n        'Peter': [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 11 * 60 + 30), (12 * 60, 13 * 60 + 30), (16 * 60, 17 * 60)],\n        'Hannah': [(9 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Joseph': [(9 * 60 + 30, 10 * 60), (12 * 60, 13 * 60), (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60 + 30), (16 * 60, 17 * 60)],\n    }\n\n    # Samuel's preference: avoid after 15:00\n    samuel_preference_end = 15 * 60\n\n    # Collect all busy intervals\n    all_busy = []\n    for person in busy_times:\n        all_busy.extend(busy_times[person])\n\n    # Add Samuel's preference as a busy time after 15:00\n    all_busy.append((samuel_preference_end, work_end))\n\n    # Sort all busy intervals by start time\n    all_busy.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find available slots (gaps between busy intervals)\n    available = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n\n    # Check for a 30-minute slot\n    meeting_duration = 30\n    for start, end in available:\n        if end - start >= meeting_duration:\n            # Convert start time to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_time = start + meeting_duration\n            end_hh = end_time // 60\n            end_mm = end_time % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No available slot found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_499"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define busy slots in minutes since midnight\n    rachel_busy = [\n        (12 * 60, 12 * 60 + 30),    # 12:00-12:30\n        (14 * 60, 14 * 60 + 30),    # 14:00-14:30\n        (15 * 60 + 30, 16 * 60),    # 15:30-16:00\n        (16 * 60 + 30, 17 * 60)     # 16:30-17:00\n    ]\n    wayne_busy = [\n        (9 * 60, 9 * 60 + 30),      # 9:00-9:30\n        (10 * 60, 10 * 60 + 30),     # 10:00-10:30\n        (11 * 60, 14 * 60 + 30),     # 11:00-14:30\n        (15 * 60, 15 * 60 + 30),     # 15:00-15:30\n        (16 * 60, 17 * 60)           # 16:00-17:00\n    ]\n\n    # Rachel's preference: not before 13:00\n    preference_start = 13 * 60\n\n    # Meeting duration in minutes\n    duration = 30\n\n    # Generate available slots for Rachel and Wayne\n    def get_available_slots(busy_slots, start, end):\n        slots = []\n        prev_end = start\n        for busy_start, busy_end in sorted(busy_slots):\n            if busy_start > prev_end:\n                slots.append((prev_end, busy_start))\n            prev_end = max(prev_end, busy_end)\n        if prev_end < end:\n            slots.append((prev_end, end))\n        return slots\n\n    rachel_available = get_available_slots(rachel_busy, work_start, work_end)\n    wayne_available = get_available_slots(wayne_busy, work_start, work_end)\n\n    # Find overlapping slots that meet Rachel's preference\n    for r_start, r_end in rachel_available:\n        for w_start, w_end in wayne_available:\n            start = max(r_start, w_start, preference_start)\n            end = min(r_end, w_end)\n            if end - start >= duration:\n                # Convert minutes back to HH:MM format\n                start_hh = start // 60\n                start_mm = start % 60\n                end_hh = (start + duration) // 60\n                end_mm = (start + duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_500"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(carol_busy, mark_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # 9:00 is 540 minutes\n    \n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes  # Convert back to absolute minutes\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    work_start, work_end = work_hours.split(' to ')\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Parse busy slots\n    def parse_busy_slots(busy_slots):\n        slots = []\n        for slot in busy_slots:\n            start, end = slot.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            slots.append((start_min, end_min))\n        return slots\n    \n    carol_slots = parse_busy_slots(carol_busy)\n    mark_slots = parse_busy_slots(mark_busy)\n    \n    # Generate available slots for Carol and Mark\n    def get_available_slots(busy_slots, work_start_min, work_end_min):\n        available = []\n        prev_end = work_start_min\n        for start, end in sorted(busy_slots):\n            if start > prev_end:\n                available.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end_min:\n            available.append((prev_end, work_end_min))\n        return available\n    \n    carol_available = get_available_slots(carol_slots, work_start_min, work_end_min)\n    mark_available = get_available_slots(mark_slots, work_start_min, work_end_min)\n    \n    # Find overlapping available slots\n    for carol_start, carol_end in carol_available:\n        for mark_start, mark_end in mark_available:\n            start = max(carol_start, mark_start)\n            end = min(carol_end, mark_end)\n            if end - start >= duration:\n                meeting_end = start + duration\n                return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Input data\ncarol_busy = [\"10:00 to 11:00\", \"14:30 to 15:00\", \"15:30 to 17:00\"]\nmark_busy = [\"9:30 to 10:00\", \"10:30 to 17:00\"]\nwork_hours = \"9:00 to 17:00\"\nduration = 30  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(carol_busy, mark_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_501"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define busy slots in minutes\n    jack_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    charlotte_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 13 * 60 + 30),\n        (14 * 60, 16 * 60)\n    ]\n\n    # Combine and sort all busy slots for both participants\n    all_busy = jack_busy + charlotte_busy\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Filter free slots that are at least 30 minutes and meet Jack's preference (before 12:30)\n    meeting_duration = 30\n    valid_slots = []\n    for start, end in free_slots:\n        if end - start >= meeting_duration and start < 12 * 60 + 30:\n            valid_slots.append((start, end))\n\n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Format the output as HH:MM:HH:MM\n        return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    else:\n        return \"No valid slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_502"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for a slot that fits the duration\n    for start, end in free_intervals:\n        if end - start >= duration * 60:\n            meeting_start = start\n            meeting_end = meeting_start + duration * 60\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define the participants' schedules\nann_schedule = [\n    \"9:30 to 10:00\",\n    \"13:00 to 14:00\",\n    \"15:00 to 16:00\",\n    \"16:30 to 17:00\"\n]\n\nkathleen_schedule = [\n    \"10:00 to 10:30\",\n    \"11:00 to 11:30\",\n    \"13:00 to 14:30\",\n    \"15:00 to 16:00\",\n    \"16:30 to 17:00\"\n]\n\nparticipants_schedules = [ann_schedule, kathleen_schedule]\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration = 1  # in hours\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration))\n```",
            "count": "calendar_scheduling_example_503"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define busy intervals in minutes since midnight\n    alexis_busy = [\n        (11 * 60, 11 * 60 + 30),   # 11:00-11:30\n        (12 * 60, 12 * 60 + 30),   # 12:00-12:30\n        (14 * 60 + 30, 15 * 60),   # 14:30-15:00\n        (16 * 60 + 30, 17 * 60)    # 16:30-17:00\n    ]\n    \n    logan_busy = [\n        (9 * 60, 9 * 60 + 30),     # 9:00-9:30\n        (11 * 60 + 30, 12 * 60 + 30),  # 11:30-12:30\n        (13 * 60, 14 * 60 + 30),   # 13:00-14:30\n        (15 * 60, 17 * 60)          # 15:00-17:00\n    ]\n    \n    # Alexis prefers no meetings before 11:30\n    preferred_start = 11 * 60 + 30  # 11:30 in minutes\n    \n    # Meeting duration in minutes\n    duration = 30\n    \n    # Combine all busy times and sort\n    all_busy = alexis_busy + logan_busy\n    all_busy.sort()\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Filter slots that are after preferred start and have enough duration\n    valid_slots = []\n    for slot_start, slot_end in available_slots:\n        if slot_start >= preferred_start and (slot_end - slot_start) >= duration:\n            valid_slots.append((slot_start, slot_end))\n    \n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_504"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Vincent's busy times in minutes (9:00-10:30, 12:00-15:00, 15:30-17:00)\n    vincent_busy = [(9 * 60, 10 * 60 + 30), (12 * 60, 15 * 60), (15 * 60 + 30, 17 * 60)]\n    \n    # Vincent prefers no meetings after 12:30 (12:30 in minutes)\n    preference_cutoff = 12 * 60 + 30\n    \n    # Meeting duration in minutes\n    meeting_duration = 30\n    \n    # Find all free slots for Vincent before preference cutoff\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in vincent_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the remaining time after last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Filter slots that are before preference cutoff and can fit the meeting\n    possible_slots = []\n    for start, end in free_slots:\n        if start >= preference_cutoff:\n            continue\n        if end - start >= meeting_duration:\n            possible_slots.append((start, end))\n    \n    # Select the earliest possible slot\n    if possible_slots:\n        meeting_start = possible_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Format the output as HH:MM:HH:MM\n        return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    else:\n        return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_505"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(evelyn_schedule, jason_schedule, work_hours, duration):\n    # Parse work hours\n    work_start, work_end = work_hours.split(\" to \")\n    work_start = int(work_start.split(':')[0])\n    work_end = int(work_end.split(':')[0])\n    \n    # Initialize available time slots\n    available_slots = []\n    \n    # Generate all possible slots within work hours\n    for hour in range(work_start, work_end):\n        for minute in [0, 30]:\n            start_time = f\"{hour:02d}:{minute:02d}\"\n            end_hour = hour + (minute + duration) // 60\n            end_minute = (minute + duration) % 60\n            end_time = f\"{end_hour:02d}:{end_minute:02d}\"\n            \n            # Check if the slot is within work hours\n            if end_hour < work_end or (end_hour == work_end and end_minute == 0):\n                available_slots.append((start_time, end_time))\n    \n    # Check each slot against participants' schedules\n    for slot in available_slots:\n        start, end = slot\n        start_h, start_m = map(int, start.split(':'))\n        end_h, end_m = map(int, end.split(':'))\n        \n        # Check Jason's schedule\n        jason_conflict = False\n        for busy_start, busy_end in jason_schedule:\n            busy_start_h, busy_start_m = map(int, busy_start.split(':'))\n            busy_end_h, busy_end_m = map(int, busy_end.split(':'))\n            \n            # Check if slot overlaps with Jason's busy time\n            if not (end_h < busy_start_h or (end_h == busy_start_h and end_m <= busy_start_m) or\n                    start_h > busy_end_h or (start_h == busy_end_h and start_m >= busy_end_m)):\n                jason_conflict = True\n                break\n        \n        # If no conflicts, return the slot\n        if not jason_conflict:\n            return f\"{start}:{end}\"\n    \n    return \"No available time slot found\"\n\n# Define participants' schedules and constraints\nevelyn_schedule = []  # Evelyn has no meetings\njason_schedule = [\n    (\"09:00\", \"09:30\"),\n    (\"10:00\", \"11:30\"),\n    (\"12:30\", \"14:30\"),\n    (\"15:00\", \"17:00\")\n]\nwork_hours = \"9:00 to 17:00\"\nduration = 60  # minutes\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(evelyn_schedule, jason_schedule, work_hours, duration)\nprint(meeting_time.replace(':', ''))\n```",
            "count": "calendar_scheduling_example_506"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert schedules to minutes since midnight\n    patricia_busy = [\n        (11 * 60 + 30, 12 * 60),    # 11:30-12:00\n        (12 * 60 + 30, 13 * 60)     # 12:30-13:00\n    ]\n    \n    harold_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),  # 9:30-10:30\n        (11 * 60 + 30, 12 * 60),       # 11:30-12:00\n        (12 * 60 + 30, 13 * 60),       # 12:30-13:00\n        (13 * 60 + 30, 15 * 60 + 30),  # 13:30-15:30\n        (16 * 60, 17 * 60)             # 16:00-17:00\n    ]\n    \n    # Harold's preference: not after 14:00 (so latest end time is 14:00)\n    preference_end = 14 * 60\n    \n    # Combine and sort all busy intervals\n    all_busy = patricia_busy + harold_busy\n    all_busy.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Check for a 30-minute slot that ends by 14:00 (Harold's preference)\n    meeting_duration = 30\n    for slot_start, slot_end in free_slots:\n        latest_start = min(slot_end - meeting_duration, preference_end - meeting_duration)\n        if latest_start >= slot_start:\n            actual_start = max(slot_start, latest_start)\n            return f\"{actual_start // 60:02d}:{actual_start % 60:02d}:{actual_start // 60:02d}:{(actual_start + meeting_duration) % 60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_507"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(peter_schedule, randy_schedule, work_hours, duration):\n    # Parse work hours\n    work_start, work_end = work_hours.split(\" to \")\n    work_start = int(work_start.split(':')[0]) + int(work_start.split(':')[1]) / 60\n    work_end = int(work_end.split(':')[0]) + int(work_end.split(':')[1]) / 60\n\n    # Parse Randy's busy slots\n    randy_busy = []\n    for slot in randy_schedule.split('; '):\n        if not slot:\n            continue\n        start, end = slot.split(' to ')\n        start_time = int(start.split(':')[0]) + int(start.split(':')[1]) / 60\n        end_time = int(end.split(':')[0]) + int(end.split(':')[1]) / 60\n        randy_busy.append((start_time, end_time))\n\n    # Find available slots for Randy\n    randy_available = []\n    prev_end = work_start\n    for start, end in sorted(randy_busy):\n        if start > prev_end:\n            randy_available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        randy_available.append((prev_end, work_end))\n\n    # Find first available slot that fits the duration\n    for start, end in randy_available:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Format the time as HH:MM\n            start_hour = int(meeting_start)\n            start_minute = int((meeting_start - start_hour) * 60)\n            end_hour = int(meeting_end)\n            end_minute = int((meeting_end - end_hour) * 60)\n            return f\"{start_hour:02d}:{start_minute:02d}:{end_hour:02d}:{end_minute:02d}\"\n    return \"No available time slot found\"\n\n# Given data\npeter_schedule = \"wide open the entire day\"\nrandy_schedule = \"9:00 to 12:30, 13:30 to 17:00\"\nwork_hours = \"9:00 to 17:00\"\nduration = 1.0  # 1 hour\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(peter_schedule, randy_schedule, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_508"
        },
        {
            "final_program_time": "{9:30:10:30}",
            "expected_time": "{9:30:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(wayne_busy, laura_busy, work_start, work_end, duration):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Parse busy intervals for Wayne and Laura\n    def parse_busy_intervals(busy_list):\n        intervals = []\n        for interval in busy_list:\n            start, end = interval.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            intervals.append((start_min, end_min))\n        return intervals\n    \n    wayne_intervals = parse_busy_intervals(wayne_busy)\n    laura_intervals = parse_busy_intervals(laura_busy)\n    \n    # Combine and sort all busy intervals\n    all_busy = wayne_intervals + laura_intervals\n    all_busy.sort()\n    \n    # Find free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    prev_end = work_start_min\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n    \n    # Check each free interval for sufficient duration\n    duration_min = duration * 60\n    for start, end in free_intervals:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define inputs\nwayne_busy = [\"11:00 to 12:00\", \"13:00 to 13:30\", \"15:00 to 15:30\"]\nlaura_busy = [\"9:00 to 9:30\", \"10:30 to 17:00\"]\nwork_start = \"9:00\"\nwork_end = \"17:00\"\nduration = 1  # in hours\n\n# Find and print the meeting time\nprint(find_meeting_time(wayne_busy, laura_busy, work_start, work_end, duration))\n```",
            "count": "calendar_scheduling_example_509"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' schedules and constraints in minutes\n    nicole_busy = [\n        (11 * 60, 11 * 60 + 30),  # 11:00-11:30\n        (12 * 60, 13 * 60),        # 12:00-13:00\n        (15 * 60 + 30, 16 * 60)    # 15:30-16:00\n    ]\n    arthur_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),  # 9:30-10:30\n        (11 * 60, 12 * 60),           # 11:00-12:00\n        (13 * 60 + 30, 15 * 60),      # 13:30-15:00\n        (16 * 60 + 30, 17 * 60)       # 16:30-17:00\n    ]\n    \n    # Nicole's preference: not before 16:00\n    nicole_preference_start = 16 * 60\n    \n    # Meeting duration in minutes\n    meeting_duration = 30\n    \n    # Generate all possible slots within work hours, checking constraints\n    for start in range(work_start, work_end - meeting_duration + 1):\n        end = start + meeting_duration\n        # Check if slot is after Nicole's preference\n        if start < nicole_preference_start:\n            continue\n        # Check if slot is free for Nicole\n        nicole_free = True\n        for busy_start, busy_end in nicole_busy:\n            if not (end <= busy_start or start >= busy_end):\n                nicole_free = False\n                break\n        if not nicole_free:\n            continue\n        # Check if slot is free for Arthur\n        arthur_free = True\n        for busy_start, busy_end in arthur_busy:\n            if not (end <= busy_start or start >= busy_end):\n                arthur_free = False\n                break\n        if not arthur_free:\n            continue\n        # If all checks passed, return the slot\n        return f\"{start // 60:02d}:{start % 60:02d}:{end // 60:02d}:{end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_510"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert blocked times to minutes since midnight\n    barbara_blocked = [\n        (13 * 60 + 30, 14 * 60 + 30),  # 13:30-14:30\n        (15 * 60, 15 * 60 + 30),        # 15:00-15:30\n        (16 * 60, 16 * 60 + 30)         # 16:00-16:30\n    ]\n    \n    scott_blocked = [\n        (9 * 60, 9 * 60 + 30),          # 9:00-9:30\n        (11 * 60 + 30, 12 * 60),        # 11:30-12:00\n        (12 * 60 + 30, 14 * 60 + 30),   # 12:30-14:30\n        (15 * 60, 16 * 60)              # 15:00-16:00\n    ]\n    \n    # Scott cannot meet after 11:30, so adjust work_end for Scott\n    scott_work_end = 11 * 60 + 30\n    \n    # The actual end time is the minimum of work_end and scott_work_end\n    effective_end = min(work_end, scott_work_end)\n    \n    # Merge and sort all blocked times for both participants\n    all_blocked = barbara_blocked + scott_blocked\n    all_blocked.sort()\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in all_blocked:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    # Check after the last blocked time\n    if prev_end < effective_end:\n        available_slots.append((prev_end, effective_end))\n    \n    # Find the first available slot that can fit 30 minutes\n    meeting_duration = 30\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_511"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:00:16:30}",
            "type_error": "IndexError",
            "full_response": "```python\ndef find_meeting_time(paul_busy, nicholas_busy, work_hours, duration, nicholas_constraint):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 9:00 (0 minutes)\n    \n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes  # Add 540 to convert back to HH:MM\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    work_start, work_end = map(time_to_minutes, work_hours.split(' to '))\n    \n    # Parse Paul's busy intervals\n    paul_intervals = []\n    for interval in paul_busy:\n        start, end = map(time_to_minutes, interval.split(' to '))\n        paul_intervals.append((start, end))\n    \n    # Parse Nicholas's busy intervals\n    nicholas_intervals = []\n    for interval in nicholas_busy:\n        start, end = map(time_to_minutes, interval.split(' to '))\n        nicholas_intervals.append((start, end))\n    \n    # Parse Nicholas's constraint\n    constraint_start = time_to_minutes(nicholas_constraint.split(' before ')[1].replace('.', ''))\n    \n    # Combine and sort all busy intervals for both participants\n    all_busy = paul_intervals + nicholas_intervals\n    all_busy.sort()\n    \n    # Find free intervals by merging busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1] = (last_start, max(end, last_end))\n            else:\n                merged.append((start, end))\n    \n    # Check the time before first busy interval\n    if merged and work_start < merged[0][0]:\n        candidate_start = max(work_start, constraint_start)\n        candidate_end = candidate_start + duration\n        if candidate_end <= merged[0][0]:\n            return f\"{minutes_to_time(candidate_start)}:{minutes_to_time(candidate_end)}\"\n    \n    # Check the time between busy intervals\n    for i in range(len(merged) - 1):\n        current_end = merged[i][1]\n        next_start = merged[i+1][0]\n        candidate_start = max(current_end, constraint_start)\n        candidate_end = candidate_start + duration\n        if candidate_end <= next_start:\n            return f\"{minutes_to_time(candidate_start)}:{minutes_to_time(candidate_end)}\"\n    \n    # Check the time after last busy interval\n    if merged and merged[-1][1] < work_end:\n        candidate_start = max(merged[-1][1], constraint_start)\n        candidate_end = candidate_start + duration\n        if candidate_end <= work_end:\n            return f\"{minutes_to_time(candidate_start)}:{minutes_to_time(candidate_end)}\"\n    \n    # If no slot found (though problem states there is one)\n    return \"No suitable time found\"\n\n# Input data\npaul_busy = [\n    \"9:00 to 10:30\",\n    \"11:00 to 11:30\",\n    \"13:30 to 14:00\",\n    \"15:00 to 15:30\"\n]\n\nnicholas_busy = [\n    \"9:30 to 11:00\",\n    \"11:30 to 14:00\",\n    \"14:30 to 15:00\",\n    \"15:30 to 16:00\"\n]\n\nwork_hours = \"9:00 to 17:00\"\nduration = 30  # minutes\nnicholas_constraint = \"before 15:00\"\n\n# Find meeting time\nmeeting_time = find_meeting_time(paul_busy, nicholas_busy, work_hours, duration, nicholas_constraint)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_512"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(pamela_free, mark_busy, mark_constraint_start, duration_minutes=30):\n    # Parse the constraint: Mark cannot meet before 15:30\n    constraint_hour, constraint_minute = map(int, mark_constraint_start.split(':'))\n    constraint_start = constraint_hour * 60 + constraint_minute\n    \n    # Convert Mark's busy times to minutes since 9:00 (work start)\n    mark_busy_minutes = []\n    for slot in mark_busy:\n        start, end = slot.split(' to ')\n        start_h, start_m = map(int, start.split(':'))\n        end_h, end_m = map(int, end.split(':'))\n        start_total = start_h * 60 + start_m - 540  # 9:00 is 540 minutes\n        end_total = end_h * 60 + end_m - 540\n        mark_busy_minutes.append((start_total, end_total))\n    \n    # Generate all possible 30-minute slots in the workday (9:00-17:00 is 480 minutes)\n    possible_slots = []\n    for start in range(0, 480 - duration_minutes + 1, 15):  # check every 15 minutes\n        end = start + duration_minutes\n        # Check if the slot is after Mark's constraint\n        slot_start_time = 540 + start  # in absolute minutes\n        if slot_start_time < constraint_start:\n            continue\n        # Check if the slot overlaps with any of Mark's busy times\n        overlap = False\n        for busy_start, busy_end in mark_busy_minutes:\n            if not (end <= busy_start or start >= busy_end):\n                overlap = True\n                break\n        if not overlap:\n            possible_slots.append((start, end))\n    \n    if not possible_slots:\n        return None\n    \n    # Select the earliest possible slot\n    chosen_slot = possible_slots[0]\n    start_min, end_min = chosen_slot\n    \n    # Convert back to HH:MM format\n    start_h = 9 + (start_min // 60)\n    start_m = start_min % 60\n    end_h = 9 + (end_min // 60)\n    end_m = end_min % 60\n    \n    return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n\n# Define inputs\npamela_free = True  # Pamela has no meetings all day\nmark_busy = [\n    \"9:00 to 9:30\",\n    \"10:00 to 10:30\",\n    \"11:00 to 11:30\",\n    \"12:00 to 12:30\",\n    \"14:00 to 14:30\",\n    \"15:00 to 15:30\",\n    \"16:00 to 17:00\"\n]\nmark_constraint_start = \"15:30\"  # Mark cannot meet before 15:30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(pamela_free, mark_busy, mark_constraint_start)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_513"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert busy slots to minutes\n    martha_busy = [\n        (12 * 60, 12 * 60 + 30),   # 12:00-12:30\n        (14 * 60 + 30, 15 * 60)     # 14:30-15:00\n    ]\n    \n    nathan_busy = [\n        (9 * 60, 10 * 60 + 30),     # 9:00-10:30\n        (11 * 60, 11 * 60 + 30),    # 11:00-11:30\n        (12 * 60, 13 * 60),         # 12:00-13:00\n        (13 * 60 + 30, 14 * 60),    # 13:30-14:00\n        (15 * 60 + 30, 16 * 60)     # 15:30-16:00\n    ]\n    \n    # Nathan's preference: avoid after 11:00 (but we'll still check before 11:00 first)\n    preferred_end = 11 * 60\n    \n    # Check slots before 11:00 first\n    for start in range(work_start, preferred_end - 30, 5):  # Check in 5-minute increments\n        end = start + 30\n        if (not any(s <= start < e or s < end <= e for s, e in martha_busy) and\n            not any(s <= start < e or s < end <= e for s, e in nathan_busy)):\n            # Format the time as HH:MM:HH:MM\n            return f\"{start // 60:02d}:{start % 60:02d}:{end // 60:02d}:{end % 60:02d}\"\n    \n    # If no slot before 11:00, check the rest of the day\n    for start in range(work_start, work_end - 30, 5):\n        end = start + 30\n        if (not any(s <= start < e or s < end <= e for s, e in martha_busy) and\n            not any(s <= start < e or s < end <= e for s, e in nathan_busy)):\n            # Format the time as HH:MM:HH:MM\n            return f\"{start // 60:02d}:{start % 60:02d}:{end // 60:02d}:{end % 60:02d}\"\n    \n    return \"No time found\"  # Should not happen as per the problem statement\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_514"
        },
        {
            "final_program_time": "{16:00:17:00}",
            "expected_time": "{16:00:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert busy slots to minutes\n    randy_busy = [\n        (10 * 60, 10 * 60 + 30),  # 10:00-10:30\n        (15 * 60, 15 * 60 + 30)    # 15:00-15:30\n    ]\n    \n    dylan_busy = [\n        (9 * 60, 10 * 60 + 30),    # 9:00-10:30\n        (11 * 60, 11 * 60 + 30),   # 11:00-11:30\n        (12 * 60 + 30, 13 * 60),   # 12:30-13:00\n        (14 * 60 + 30, 16 * 60)    # 14:30-16:00\n    ]\n    \n    # Dylan prefers no meetings before 16:00, so we start checking from 16:00\n    start_time = 16 * 60\n    meeting_duration = 60\n    \n    # Check if the preferred time (16:00-17:00) works for both\n    if start_time + meeting_duration <= work_end:\n        # Check Randy's availability\n        randy_available = True\n        for busy_start, busy_end in randy_busy:\n            if not (start_time >= busy_end or start_time + meeting_duration <= busy_start):\n                randy_available = False\n                break\n        # Check Dylan's availability\n        dylan_available = True\n        for busy_start, busy_end in dylan_busy:\n            if not (start_time >= busy_end or start_time + meeting_duration <= busy_start):\n                dylan_available = False\n                break\n        if randy_available and dylan_available:\n            return f\"{start_time // 60:02d}:{start_time % 60:02d}:{(start_time + meeting_duration) // 60:02d}:{(start_time + meeting_duration) % 60:02d}\"\n    \n    # If preferred time doesn't work, check other slots (though in this case it should)\n    # This is a fallback (not needed here as the task states a solution exists)\n    for time in range(work_start, work_end - meeting_duration + 1, 15):\n        # Check Randy's availability\n        randy_available = True\n        for busy_start, busy_end in randy_busy:\n            if not (time >= busy_end or time + meeting_duration <= busy_start):\n                randy_available = False\n                break\n        if not randy_available:\n            continue\n        # Check Dylan's availability\n        dylan_available = True\n        for busy_start, busy_end in dylan_busy:\n            if not (time >= busy_end or time + meeting_duration <= busy_start):\n                dylan_available = False\n                break\n        if dylan_available and time >= 16 * 60:  # Respect Dylan's preference\n            return f\"{time // 60:02d}:{time % 60:02d}:{(time + meeting_duration) // 60:02d}:{(time + meeting_duration) % 60:02d}\"\n    \n    return \"No time found\"  # Should not happen as per the task\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_515"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(schedules, work_hours, duration):\n    # Parse work hours\n    work_start, work_end = work_hours.split(\" to \")\n    work_start_min = convert_time_to_minutes(work_start)\n    work_end_min = convert_time_to_minutes(work_end)\n    \n    # Parse and merge all busy intervals\n    busy_intervals = []\n    for person, calendar in schedules.items():\n        for meeting in calendar:\n            start, end = meeting.split(\" to \")\n            start_min = convert_time_to_minutes(start)\n            end_min = convert_time_to_minutes(end)\n            busy_intervals.append((start_min, end_min))\n    \n    # Sort busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals during work hours\n    free_intervals = []\n    prev_end = work_start_min\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n    \n    # Find the first free interval that can accommodate the meeting\n    duration_min = duration * 60\n    for start, end in free_intervals:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return (meeting_start, meeting_end)\n    \n    return None\n\ndef convert_time_to_minutes(time_str):\n    hours, minutes = map(int, time_str.split(':'))\n    return hours * 60 + minutes\n\ndef format_minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Define the schedules and constraints\nschedules = {\n    \"Sophia\": [],\n    \"Jesse\": [\"9:00 to 11:30\", \"12:00 to 14:30\", \"15:30 to 16:00\", \"16:30 to 17:00\"]\n}\nwork_hours = \"9:00 to 17:00\"\nduration = 1  # in hours\n\n# Find the meeting time\nmeeting_time = find_meeting_time(schedules, work_hours, duration)\n\n# Format the output\nif meeting_time:\n    start, end = meeting_time\n    start_time = format_minutes_to_time(start)\n    end_time = format_minutes_to_time(end)\n    print(f\"{start_time}:{end_time}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_516"
        },
        {
            "final_program_time": "{16:00:17:00}",
            "expected_time": "{16:00:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Define Carol's constraints (no meetings but can't meet before 14:30)\n    carol_free = [(14 * 60 + 30, work_end)]  # 14:30 to 17:00\n\n    # Define Frank's meetings in minutes\n    frank_meetings = [\n        (9 * 60, 10 * 60),    # 9:00-10:00\n        (11 * 60 + 30, 12 * 60),  # 11:30-12:00\n        (12 * 60 + 30, 13 * 60),  # 12:30-13:00\n        (13 * 60 + 30, 14 * 60),  # 13:30-14:00\n        (14 * 60 + 30, 16 * 60)   # 14:30-16:00\n    ]\n    # Calculate Frank's free time\n    frank_free = []\n    prev_end = work_start\n    for start, end in sorted(frank_meetings):\n        if start > prev_end:\n            frank_free.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        frank_free.append((prev_end, work_end))\n\n    # Find overlapping free time between Carol and Frank (1 hour)\n    meeting_duration = 60\n    for c_start, c_end in carol_free:\n        for f_start, f_end in frank_free:\n            overlap_start = max(c_start, f_start)\n            overlap_end = min(c_end, f_end)\n            if overlap_end - overlap_start >= meeting_duration:\n                # Return the first available slot\n                return f\"{minutes_to_time(overlap_start)}:{minutes_to_time(overlap_start + meeting_duration)}\"\n    return \"No meeting time found\"\n\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Run the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_517"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(schedule1, schedule2, work_hours, duration):\n    # Combine and sort all busy intervals from both schedules\n    busy_intervals = schedule1 + schedule2\n    busy_intervals.sort()\n    \n    # Initialize the start of the available time to the start of work hours\n    available_start = work_hours[0]\n    \n    # Iterate through each busy interval to find gaps\n    for start, end in busy_intervals:\n        if start > available_start:\n            # Check if the gap is long enough for the meeting\n            if (start - available_start) >= duration:\n                return (available_start, available_start + duration)\n        # Update the available_start to the end of the current busy interval\n        if end > available_start:\n            available_start = end\n    \n    # Check the gap between the last busy interval and the end of work hours\n    if (work_hours[1] - available_start) >= duration:\n        return (available_start, available_start + duration)\n    \n    return None\n\n# Define the work hours and meeting duration\nwork_hours = (9.0, 17.0)\nduration = 0.5  # half an hour\n\n# Define Susan's and Diane's schedules\nsusan_schedule = []  # Susan's calendar is wide open\ndiane_schedule = [\n    (9.0, 10.0),\n    (12.0, 14.0),\n    (15.0, 15.5),\n    (16.5, 17.0)\n]\n\n# Find the earliest available meeting time\nmeeting_time = find_meeting_time(susan_schedule, diane_schedule, work_hours, duration)\n\n# Format the output as HH:MM:HH:MM\ndef float_to_time(time_float):\n    hours = int(time_float)\n    minutes = int((time_float - hours) * 60)\n    return f\"{hours:02d}:{minutes:02d}\"\n\nif meeting_time:\n    start_time = float_to_time(meeting_time[0])\n    end_time = float_to_time(meeting_time[1])\n    print(f\"{start_time}:{end_time}\")\nelse:\n    print(\"No available time found.\")\n```",
            "count": "calendar_scheduling_example_518"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(logan_busy, alice_busy, work_start, work_end, duration):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Generate busy slots in minutes for Logan and Alice\n    def parse_busy_slots(busy_slots):\n        slots = []\n        for slot in busy_slots:\n            start, end = slot.split(' to ')\n            slots.append((time_to_minutes(start), time_to_minutes(end)))\n        return slots\n    \n    logan_slots = parse_busy_slots(logan_busy)\n    alice_slots = parse_busy_slots(alice_busy)\n    \n    # Combine and sort all busy slots\n    all_busy = logan_slots + alice_slots\n    all_busy.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = work_start_min\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        free_slots.append((prev_end, work_end_min))\n    \n    # Find the first suitable free slot\n    for start, end in free_slots:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define constraints\nlogan_busy = [\"9:30 to 10:30\"]\nalice_busy = [\"10:00 to 10:30\", \"11:00 to 11:30\", \"12:00 to 12:30\", \"13:00 to 14:00\", \"15:00 to 16:30\"]\nwork_start = \"9:00\"\nwork_end = \"17:00\"\nduration = 1  # in hours\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(logan_busy, alice_busy, work_start, work_end, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_519"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_work, end_work = work_hours\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work_min = time_to_minutes(start_work)\n    end_work_min = time_to_minutes(end_work)\n    duration_min = duration * 60\n    \n    # Collect all busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = busy\n            all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by merging all busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find the first available slot before the first busy interval\n    prev_end = start_work_min\n    for start, end in merged:\n        if start - prev_end >= duration_min:\n            return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + duration_min)}\"\n        prev_end = max(prev_end, end)\n    \n    # Check after the last busy interval\n    if end_work_min - prev_end >= duration_min:\n        return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + duration_min)}\"\n    \n    return None\n\n# Define the participants' schedules and constraints\npatricia_schedule = [\n    (\"09:00\", \"09:30\"),\n    (\"10:00\", \"10:30\"),\n    (\"13:00\", \"14:00\"),\n    (\"14:30\", \"15:00\"),\n    (\"15:30\", \"16:00\")\n]\n\naustin_schedule = [\n    (\"09:30\", \"10:00\"),\n    (\"10:30\", \"12:00\"),\n    (\"13:00\", \"14:00\"),\n    (\"14:30\", \"15:30\"),\n    (\"16:00\", \"17:00\")\n]\n\nparticipants_schedules = [patricia_schedule, austin_schedule]\nwork_hours = (\"09:00\", \"17:00\")\nduration = 1  # hour\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_520"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n    \n    # Elijah's busy times in minutes since midnight\n    elijah_busy = [\n        (12 * 60, 14 * 60),    # 12:00 to 14:00\n        (14 * 60 + 30, 15 * 60 + 30),  # 14:30 to 15:30\n        (16 * 60, 17 * 60)     # 16:00 to 17:00\n    ]\n    \n    # Elijah cannot meet after 14:30 (14:30 in minutes)\n    elijah_cutoff = 14 * 60 + 30\n    \n    # Find available slots for Elijah before the cutoff\n    available_slots = []\n    previous_end = work_start\n    \n    for start, end in sorted(elijah_busy):\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the time after the last busy slot\n    if previous_end < elijah_cutoff:\n        available_slots.append((previous_end, elijah_cutoff))\n    \n    # Find the first available slot that fits the meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No available time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_521"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert schedules to minutes\n    jeremy_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 12 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    denise_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 16 * 60)\n    ]\n    \n    # Denise's preference: not before 12:30\n    preference_start = 12 * 60 + 30  # 12:30 in minutes\n    \n    # Find all possible 30-minute slots\n    possible_slots = []\n    \n    for start in range(preference_start, work_end - 30):\n        end = start + 30\n        conflict = False\n        \n        # Check Jeremy's schedule\n        for busy_start, busy_end in jeremy_busy:\n            if not (end <= busy_start or start >= busy_end):\n                conflict = True\n                break\n        if conflict:\n            continue\n        \n        # Check Denise's schedule\n        for busy_start, busy_end in denise_busy:\n            if not (end <= busy_start or start >= busy_end):\n                conflict = True\n                break\n        if conflict:\n            continue\n        \n        possible_slots.append((start, end))\n    \n    if not possible_slots:\n        return None\n    \n    # Select the first available slot\n    meeting_start, meeting_end = possible_slots[0]\n    \n    # Convert back to HH:MM format\n    def format_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n    \n    return f\"{format_time(meeting_start)}:{format_time(meeting_end)}\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_522"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours_start, work_hours_end, duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy_slots in participants_busy.values():\n        for slot in busy_slots:\n            start, end = map(time_to_minutes, slot.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Find the first free interval that can accommodate the meeting\n    for interval in free_intervals:\n        start, end = interval\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return (minutes_to_time(meeting_start), minutes_to_time(meeting_end))\n    \n    return None\n\n# Define the participants' busy schedules\nparticipants_busy = {\n    'Ryan': [\n        '9:00 to 9:30',\n        '11:30 to 12:00',\n        '14:30 to 15:00',\n        '16:00 to 16:30'\n    ],\n    'Kenneth': [\n        '9:30 to 10:30',\n        '11:00 to 12:00',\n        '12:30 to 13:00',\n        '13:30 to 14:00',\n        '14:30 to 16:30'\n    ]\n}\n\n# Define work hours and meeting duration\nwork_hours_start = '9:00'\nwork_hours_end = '17:00'\nduration_minutes = 30  # half an hour\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours_start, work_hours_end, duration_minutes)\n\n# Output the result in the required format\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{start}:{end}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_523"
        },
        {
            "final_program_time": "{11:00:12:00}",
            "expected_time": "{11:00:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Katherine's schedule: free all day\n    katherine_free = [(work_start, work_end)]\n\n    # Logan's schedule and constraints\n    logan_busy = [\n        (9 * 60, 9 * 60 + 30),   # 9:00-9:30\n        (10 * 60 + 30, 11 * 60), # 10:30-11:00\n        (13 * 60 + 30, 14 * 60), # 13:30-14:00\n        (14 * 60 + 30, 17 * 60)  # 14:30-17:00\n    ]\n    logan_constraint_start = 10 * 60 + 30  # Not before 10:30\n\n    # Find Logan's free slots within work hours and constraints\n    logan_free = []\n    previous_end = work_start\n    for start, end in sorted(logan_busy):\n        if start > previous_end and previous_end >= logan_constraint_start:\n            logan_free.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if work_end > previous_end and previous_end >= logan_constraint_start:\n        logan_free.append((previous_end, work_end))\n\n    # Find overlapping free slots of 60 minutes\n    meeting_duration = 60\n    for k_start, k_end in katherine_free:\n        for l_start, l_end in logan_free:\n            start = max(k_start, l_start)\n            end = min(k_end, l_end)\n            if end - start >= meeting_duration:\n                # Return the first suitable slot found\n                return f\"{start//60:02d}:{start%60:02d}:{(start+meeting_duration)//60:02d}:{(start+meeting_duration)%60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_524"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define blocked times in minutes\n    james_blocked = [\n        (9 * 60 + 30, 10 * 60),   # 9:30-10:00\n        (10 * 60 + 30, 11 * 60)    # 10:30-11:00\n    ]\n    lawrence_blocked = [\n        (10 * 60, 11 * 60),        # 10:00-11:00\n        (12 * 60, 13 * 60),        # 12:00-13:00\n        (14 * 60, 15 * 60),        # 14:00-15:00\n        (16 * 60, 17 * 60)         # 16:00-17:00\n    ]\n    \n    # James cannot meet after 14:30\n    james_limit = 14 * 60 + 30\n    \n    # Meeting duration in minutes\n    meeting_duration = 30\n    \n    # Generate all possible slots\n    possible_slots = []\n    current_time = work_start\n    \n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        # Check if the slot is within James' limit\n        if slot_end > james_limit:\n            current_time += 1\n            continue\n        # Check if the slot is free for both\n        james_free = True\n        for start, end in james_blocked:\n            if not (slot_end <= start or current_time >= end):\n                james_free = False\n                break\n        lawrence_free = True\n        for start, end in lawrence_blocked:\n            if not (slot_end <= start or current_time >= end):\n                lawrence_free = False\n                break\n        if james_free and lawrence_free:\n            possible_slots.append((current_time, slot_end))\n        current_time += 1\n    \n    # Select the first available slot\n    if possible_slots:\n        start, end = possible_slots[0]\n        # Convert minutes back to HH:MM format\n        start_hh = start // 60\n        start_mm = start % 60\n        end_hh = end // 60\n        end_mm = end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_525"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define busy intervals in minutes since midnight\n    harold_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    \n    nicholas_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 13 * 60 + 30),\n        (14 * 60, 14 * 60 + 30),\n        (15 * 60, 17 * 60)\n    ]\n    \n    nicholas_preference_end = 14 * 60 + 30  # 14:30\n    \n    # Combine and sort all busy intervals\n    all_busy = harold_busy + nicholas_busy\n    all_busy.sort()\n    \n    # Find free intervals by checking gaps between busy intervals\n    free_intervals = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_intervals.append((previous_end, work_end))\n    \n    # Check each free interval for a 30-minute slot that fits Nicholas's preference\n    meeting_duration = 30\n    proposed_time = None\n    \n    for start, end in free_intervals:\n        if end > nicholas_preference_end:\n            end = min(end, nicholas_preference_end)\n        if end - start >= meeting_duration:\n            proposed_time = (start, start + meeting_duration)\n            break\n    \n    # Format the proposed time\n    if proposed_time:\n        start_h = proposed_time[0] // 60\n        start_m = proposed_time[0] % 60\n        end_h = proposed_time[1] // 60\n        end_m = proposed_time[1] % 60\n        return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    else:\n        return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_526"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define Megan's meetings and preferences\n    megan_meetings = [\n        (9 * 60, 9 * 60 + 30),   # 9:00-9:30\n        (10 * 60, 14 * 60),      # 10:00-14:00\n        (14 * 60 + 30, 17 * 60)  # 14:30-17:00\n    ]\n    megan_no_meet_after = 11 * 60  # 11:00\n    \n    # Wayne is free all day\n    wayne_meetings = []\n    \n    # Find all possible 30-minute slots\n    possible_slots = []\n    current_time = work_start\n    \n    while current_time + 30 <= work_end:\n        slot_start = current_time\n        slot_end = current_time + 30\n        \n        # Check if the slot is free for both\n        wayne_free = True\n        for meeting in wayne_meetings:\n            if not (slot_end <= meeting[0] or slot_start >= meeting[1]):\n                wayne_free = False\n                break\n        \n        megan_free = True\n        for meeting in megan_meetings:\n            if not (slot_end <= meeting[0] or slot_start >= meeting[1]):\n                megan_free = False\n                break\n        \n        # Check Megan's preference (not after 11:00)\n        if slot_start >= megan_no_meet_after:\n            megan_free = False\n        \n        if wayne_free and megan_free:\n            possible_slots.append((slot_start, slot_end))\n        \n        current_time += 30  # Check next slot\n    \n    if possible_slots:\n        # Select the first available slot\n        best_slot = possible_slots[0]\n        start_h = best_slot[0] // 60\n        start_m = best_slot[0] % 60\n        end_h = best_slot[1] // 60\n        end_m = best_slot[1] % 60\n        \n        return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    else:\n        return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_527"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Harold's meetings in minutes\n    harold_meetings = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    \n    # Edward's meetings in minutes (including blocked times and preference to avoid after 14:30)\n    edward_meetings = [\n        (9 * 60, 11 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 14 * 60 + 30),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n    edward_preference_end = 14 * 60 + 30  # Prefers no meetings after 14:30\n    \n    # Combine all busy times for both participants\n    busy_times = harold_meetings + edward_meetings\n    busy_times.sort()  # Sort by start time\n    \n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in busy_times:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last meeting until work_end\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Filter free slots that are at least 30 minutes and meet Edward's preference\n    meeting_duration = 30\n    valid_slots = []\n    \n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Check if the slot starts before Edward's preference end time\n            if start < edward_preference_end:\n                valid_slots.append((start, end))\n    \n    # Select the earliest valid slot\n    if valid_slots:\n        start, end = valid_slots[0]\n        # Format the time as HH:MM:HH:MM\n        start_hh = start // 60\n        start_mm = start % 60\n        end_hh = (start + meeting_duration) // 60\n        end_mm = (start + meeting_duration) % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No valid slot found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_528"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participant_schedules, work_hours, duration, constraints):\n    # Parse work hours\n    work_start, work_end = work_hours.split(\" to \")\n    work_start = int(work_start.split(':')[0]) * 60 + int(work_start.split(':')[1])\n    work_end = int(work_end.split(':')[0]) * 60 + int(work_end.split(':')[1])\n    \n    # Initialize busy intervals for all participants\n    busy_intervals = []\n    for schedule in participant_schedules:\n        intervals = []\n        for meeting in schedule['meetings']:\n            start, end = meeting.split(\" to \")\n            start_time = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n            end_time = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n            intervals.append((start_time, end_time))\n        busy_intervals.append(intervals)\n    \n    # Merge and sort busy intervals for each participant\n    merged_intervals = []\n    for intervals in busy_intervals:\n        if not intervals:\n            merged_intervals.append([])\n            continue\n        intervals.sort()\n        merged = [intervals[0]]\n        for current in intervals[1:]:\n            last = merged[-1]\n            if current[0] <= last[1]:\n                merged[-1] = (last[0], max(last[1], current[1]))\n            else:\n                merged.append(current)\n        merged_intervals.append(merged)\n    \n    # Find common free slots\n    all_free_slots = []\n    for i, intervals in enumerate(merged_intervals):\n        free_slots = []\n        prev_end = work_start\n        for start, end in intervals:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        all_free_slots.append(free_slots)\n    \n    # Find overlapping free slots\n    common_free_slots = []\n    for slot in all_free_slots[0]:\n        for other_slots in all_free_slots[1:]:\n            for other_slot in other_slots:\n                overlap_start = max(slot[0], other_slot[0])\n                overlap_end = min(slot[1], other_slot[1])\n                if overlap_start < overlap_end:\n                    common_free_slots.append((overlap_start, overlap_end))\n    \n    # Apply constraints\n    filtered_slots = []\n    for start, end in common_free_slots:\n        valid = True\n        for constraint in constraints:\n            if constraint['participant'] == 'Anthony' and 'after' in constraint:\n                constraint_time = int(constraint['after'].split(':')[0]) * 60 + int(constraint['after'].split(':')[1])\n                if start >= constraint_time:\n                    valid = False\n                    break\n        if valid and (end - start) >= duration:\n            filtered_slots.append((start, end))\n    \n    # Find the earliest possible slot\n    if filtered_slots:\n        filtered_slots.sort()\n        for start, end in filtered_slots:\n            if (end - start) >= duration:\n                meeting_end = start + duration\n                return f\"{start//60:02d}:{start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n    return \"No available slot found\"\n\n# Define the problem\nparticipant_schedules = [\n    {\n        'name': 'Anthony',\n        'meetings': [\n            '9:00 to 10:00',\n            '12:30 to 13:00',\n            '13:30 to 14:00',\n            '15:30 to 16:30'\n        ]\n    },\n    {\n        'name': 'Joshua',\n        'meetings': [\n            '9:00 to 9:30',\n            '11:00 to 12:30',\n            '13:00 to 14:00',\n            '15:30 to 16:30'\n        ]\n    }\n]\n\nwork_hours = \"9:00 to 17:00\"\nduration = 30  # minutes\nconstraints = [\n    {'participant': 'Anthony', 'after': '15:30'}\n]\n\n# Find and print the meeting time\nprint(find_meeting_time(participant_schedules, work_hours, duration, constraints))\n```",
            "count": "calendar_scheduling_example_529"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{10:00:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participant_busy_times, work_start, work_end, duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Combine all busy times and sort them\n    all_busy = []\n    for busy_times in participant_busy_times.values():\n        for start, end in busy_times:\n            all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    all_busy.sort()\n    \n    # Find the earliest available slot\n    prev_end = work_start_min\n    for start, end in all_busy:\n        if start > prev_end and start - prev_end >= duration_min:\n            return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + duration_min)}\"\n        prev_end = max(prev_end, end)\n    \n    # Check after the last busy time\n    if work_end_min - prev_end >= duration_min:\n        return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + duration_min)}\"\n    \n    return \"No available time slot found\"\n\n# Define the participants' busy times\nparticipant_busy_times = {\n    \"Ann\": [],\n    \"Christopher\": [\n        (\"09:00\", \"10:00\"),\n        (\"11:00\", \"11:30\"),\n        (\"12:00\", \"12:30\"),\n        (\"13:00\", \"13:30\"),\n        (\"14:00\", \"14:30\"),\n        (\"15:00\", \"15:30\"),\n        (\"16:30\", \"17:00\")\n    ]\n}\n\n# Define work hours and meeting duration\nwork_start = \"09:00\"\nwork_end = \"17:00\"\nduration = 1  # in hours\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participant_busy_times, work_start, work_end, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_530"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(ruth_schedule, kayla_schedule, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Combine and sort all busy intervals for Kayla (Ruth is free all day)\n    busy_intervals = []\n    for interval in kayla_schedule:\n        start, end = interval.split(' to ')\n        busy_intervals.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort intervals by start time\n    busy_intervals.sort()\n    \n    # Find free intervals for Kayla\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval to see if it can fit the meeting\n    duration_min = duration * 60\n    for start, end in free_intervals:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define schedules and constraints\nruth_schedule = []  # Ruth has no meetings\nkayla_schedule = [\"9:00 to 9:30\", \"10:00 to 11:30\", \"13:00 to 17:00\"]\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 1  # in hours\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(ruth_schedule, kayla_schedule, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_531"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Helen's busy times in minutes (start, end)\n    helen_busy = [\n        (9 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    \n    # Helen's preference: not after 13:30\n    preference_cutoff = 13 * 60 + 30\n    \n    # Theresa is free all day, so we only need to consider Helen's schedule\n    # Find all possible 30-minute slots in Helen's free time\n    free_slots = []\n    previous_end = work_start\n    \n    for busy_start, busy_end in helen_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = busy_end\n    \n    # Check after last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Filter slots that are at least 30 minutes and meet Helen's preference\n    possible_slots = []\n    for slot_start, slot_end in free_slots:\n        slot_duration = slot_end - slot_start\n        if slot_duration >= 30 and slot_start + 30 <= preference_cutoff:\n            possible_slots.append((slot_start, slot_start + 30))\n    \n    # Select the earliest possible slot\n    if possible_slots:\n        meeting_start, meeting_end = possible_slots[0]\n    else:\n        # If no preferred slots, check all free slots (though problem states a solution exists)\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= 30:\n                meeting_start, meeting_end = slot_start, slot_start + 30\n                break\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n    \n    start_time = minutes_to_time(meeting_start)\n    end_time = minutes_to_time(meeting_end)\n    \n    return f\"{start_time}:{end_time}\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_532"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert blocked times to minutes since midnight\n    alexis_blocked = [\n        (10 * 60 + 30, 11 * 60),    # 10:30-11:00\n        (13 * 60 + 30, 14 * 60)     # 13:30-14:00\n    ]\n    dorothy_blocked = [\n        (9 * 60 + 30, 10 * 60),     # 9:30-10:00\n        (10 * 60 + 30, 11 * 60 + 30),  # 10:30-11:30\n        (12 * 60 + 30, 13 * 60 + 30),  # 12:30-13:30\n        (14 * 60, 15 * 60 + 30),    # 14:00-15:30\n        (16 * 60, 17 * 60)          # 16:00-17:00\n    ]\n\n    # Combine all blocked times for both participants\n    all_blocked = alexis_blocked + dorothy_blocked\n    # Sort blocked times by start time\n    all_blocked.sort()\n\n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n\n    for start, end in all_blocked:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n\n    # Check after last blocked time\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Find first available slot that can fit 1 hour (60 minutes)\n    for slot in available_slots:\n        start, end = slot\n        if end - start >= 60:\n            meeting_start = start\n            meeting_end = meeting_start + 60\n            # Convert back to HH:MM format\n            start_h = meeting_start // 60\n            start_m = meeting_start % 60\n            end_h = meeting_end // 60\n            end_m = meeting_end % 60\n            return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n\n    return \"No available time found\"\n\n# Execute and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_533"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(busy_slots, work_hours, duration):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = map(time_to_minutes, work_hours)\n    busy_slots_min = []\n    for slot in busy_slots:\n        start, end = map(time_to_minutes, slot)\n        busy_slots_min.append((start, end))\n    \n    # Sort busy slots by start time\n    busy_slots_min.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = work_start\n    for start, end in busy_slots_min:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Find the earliest free slot that can fit the meeting\n    for slot in free_slots:\n        start, end = slot\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return (minutes_to_time(meeting_start), minutes_to_time(meeting_end))\n    \n    return None\n\n# Define the constraints\nwork_hours = (\"9:00\", \"17:00\")\nrobert_busy = [(\"9:00\", \"11:30\"), (\"12:00\", \"14:00\"), (\"14:30\", \"15:30\"), (\"16:00\", \"16:30\")]\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(robert_busy, work_hours, duration_minutes)\n\n# Output the result\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{start}:{end}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_534"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:9:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(daniel_schedule, donna_schedule, work_hours_start, work_hours_end, duration):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration_min = duration * 60\n    \n    # Combine and sort all busy intervals for Daniel and Donna\n    all_busy = []\n    for start, end in daniel_schedule:\n        all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    for start, end in donna_schedule:\n        all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort the busy intervals by start time\n    all_busy.sort()\n    \n    # Find the earliest available slot\n    prev_end = work_start\n    for start, end in all_busy:\n        if start > prev_end and start - prev_end >= duration_min:\n            return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + duration_min)}\"\n        prev_end = max(prev_end, end)\n    \n    # Check after the last busy interval\n    if work_end - prev_end >= duration_min:\n        return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + duration_min)}\"\n    \n    return None\n\n# Define the schedules and constraints\ndaniel_schedule = [\n    (\"10:00\", \"10:30\"),\n    (\"11:00\", \"11:30\")\n]\n\ndonna_schedule = [\n    (\"10:30\", \"11:00\"),\n    (\"11:30\", \"12:00\"),\n    (\"12:30\", \"13:30\"),\n    (\"14:00\", \"14:30\"),\n    (\"15:00\", \"16:00\"),\n    (\"16:30\", \"17:00\")\n]\n\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nduration = 0.5  # half an hour\n\n# Find the meeting time\nmeeting_time = find_meeting_time(daniel_schedule, donna_schedule, work_hours_start, work_hours_end, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_535"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' schedules and constraints in minutes\n    logan_busy = [\n        (10 * 60 + 30, 11 * 60),      # 10:30-11:00\n        (11 * 60 + 30, 12 * 60),      # 11:30-12:00\n        (12 * 60 + 30, 13 * 60),      # 12:30-13:00\n        (13 * 60 + 30, 14 * 60),      # 13:30-14:00\n        (14 * 60 + 30, 15 * 60),      # 14:30-15:00\n        (15 * 60 + 30, 16 * 60)       # 15:30-16:00\n    ]\n    \n    paul_busy = [\n        (9 * 60, 10 * 60 + 30),      # 9:00-10:30\n        (11 * 60, 11 * 60 + 30),      # 11:00-11:30\n        (12 * 60, 13 * 60 + 30),      # 12:00-13:30\n        (15 * 60 + 30, 17 * 60)       # 15:30-17:00\n    ]\n    \n    # Paul cannot meet before 15:00\n    paul_constraint = 15 * 60\n    \n    # Meeting duration in minutes\n    meeting_duration = 30\n    \n    # Combine and sort all busy intervals\n    all_busy = logan_busy + paul_busy\n    all_busy.sort()\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Filter slots that meet duration and Paul's constraint\n    valid_slots = []\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration:\n            actual_start = max(slot_start, paul_constraint)\n            if actual_start + meeting_duration <= slot_end:\n                valid_slots.append((actual_start, actual_start + meeting_duration))\n    \n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start, meeting_end = valid_slots[0]\n        # Convert minutes back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available time slot found.\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_536"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:30:10:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(judith_busy, terry_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n    \n    def minutes_to_time(minutes):\n        hh = (minutes + 540) // 60\n        mm = (minutes + 540) % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    start_work, end_work = map(time_to_minutes, work_hours.split(':'))\n    total_slots = end_work - start_work\n    \n    # Parse busy slots\n    def parse_busy_slots(busy_list):\n        slots = []\n        for slot in busy_list:\n            start, end = map(time_to_minutes, slot.split(' to '))\n            slots.append((start, end))\n        return slots\n    \n    judith_slots = parse_busy_slots(judith_busy)\n    terry_slots = parse_busy_slots(terry_busy)\n    \n    # Merge and sort all busy slots\n    all_busy = judith_slots + terry_slots\n    all_busy.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = start_work\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < end_work:\n        free_slots.append((prev_end, end_work))\n    \n    # Find the earliest slot that fits the duration\n    for start, end in free_slots:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define inputs\njudith_busy = [\"11:30 to 12:00\", \"14:00 to 14:30\"]\nterry_busy = [\"9:00 to 9:30\", \"11:00 to 12:30\", \"13:00 to 13:30\", \"14:30 to 16:00\"]\nwork_hours = \"9:00:17:00\"\nduration = 60  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(judith_busy, terry_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_537"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Kenneth's busy times in minutes (11:00-11:30, 12:00-12:30)\n    kenneth_busy = [(11 * 60, 11 * 60 + 30), (12 * 60, 12 * 60 + 30)]\n    \n    # Barbara's busy times in minutes (9:00-11:30, 12:30-17:00)\n    barbara_busy = [(9 * 60, 11 * 60 + 30), (12 * 60 + 30, 17 * 60)]\n    \n    # Combine and sort all busy times for both participants\n    all_busy = kenneth_busy + barbara_busy\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy times\n    previous_end = work_start\n    free_slots = []\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the time after the last busy slot until work_end\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can accommodate 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_538"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define busy intervals in minutes\n    andrea_busy = [\n        (10 * 60, 10 * 60 + 30),  # 10:00-10:30\n        (11 * 60 + 30, 12 * 60)    # 11:30-12:00\n    ]\n    abigail_busy = [\n        (9 * 60, 12 * 60),         # 9:00-12:00\n        (12 * 60 + 30, 14 * 60),    # 12:30-14:00\n        (14 * 60 + 30, 15 * 60 + 30),  # 14:30-15:30\n        (16 * 60 + 30, 17 * 60)     # 16:30-17:00\n    ]\n\n    # Andrea's preference: not after 12:30 (12*60 + 30)\n    preference_end = 12 * 60 + 30\n\n    # Meeting duration in minutes\n    duration = 30\n\n    # Find all possible slots in work hours\n    possible_slots = []\n    current_time = work_start\n\n    while current_time + duration <= work_end:\n        slot_end = current_time + duration\n        # Check if the slot is within Andrea's preference\n        if slot_end <= preference_end:\n            # Check if the slot is free for both\n            andrea_free = True\n            for start, end in andrea_busy:\n                if not (slot_end <= start or current_time >= end):\n                    andrea_free = False\n                    break\n            abigail_free = True\n            for start, end in abigail_busy:\n                if not (slot_end <= start or current_time >= end):\n                    abigail_free = False\n                    break\n            if andrea_free and abigail_free:\n                possible_slots.append((current_time, slot_end))\n        current_time += 15  # Check every 15 minutes for a slot\n\n    if possible_slots:\n        # Select the first available slot\n        start, end = possible_slots[0]\n        # Convert minutes back to HH:MM format\n        start_hh = start // 60\n        start_mm = start % 60\n        end_hh = end // 60\n        end_mm = end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_539"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(daniel_busy, christopher_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 (9:00)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes  # Add back 540 to get actual time\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    work_start, work_end = work_hours.split(' to ')\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Parse busy intervals for Daniel\n    daniel_busy_min = []\n    for interval in daniel_busy:\n        start, end = interval.split(' to ')\n        daniel_busy_min.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Parse busy intervals for Christopher\n    christopher_busy_min = []\n    for interval in christopher_busy:\n        start, end = interval.split(' to ')\n        christopher_busy_min.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Merge and sort busy intervals for both participants\n    all_busy = daniel_busy_min + christopher_busy_min\n    all_busy.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = work_start_min\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        free_slots.append((prev_end, work_end_min))\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot in free_slots:\n        start, end = slot\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define inputs\ndaniel_busy = [\n    \"9:30 to 10:00\",\n    \"11:00 to 11:30\",\n    \"13:00 to 14:00\",\n    \"15:00 to 15:30\",\n    \"16:30 to 17:00\"\n]\n\nchristopher_busy = [\n    \"9:30 to 11:00\",\n    \"11:30 to 12:30\",\n    \"13:30 to 14:00\",\n    \"15:00 to 15:30\",\n    \"16:00 to 16:30\"\n]\n\nwork_hours = \"9:00 to 17:00\"\nduration = 60  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(daniel_busy, christopher_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_540"
        },
        {
            "final_program_time": "{16:00:17:00}",
            "expected_time": "{16:00:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Find the first free interval that can accommodate the meeting\n    duration_minutes = duration * 60\n    for start, end in free_intervals:\n        if end - start >= duration_minutes:\n            meeting_end = start + duration_minutes\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nkayla_schedule = [\"10:00 to 10:30\", \"14:30 to 16:00\"]\nrebecca_schedule = [\"9:00 to 13:00\", \"13:30 to 15:00\", \"15:30 to 16:00\"]\nparticipants_schedules = [kayla_schedule, rebecca_schedule]\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration = 1  # hours\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration))\n```",
            "count": "calendar_scheduling_example_541"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Generate all busy intervals for each participant\n    all_busy_intervals = []\n    for busy_times in participants_busy_times:\n        for interval in busy_times:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            all_busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_intervals = []\n    for start, end in all_busy_intervals:\n        if not merged_intervals:\n            merged_intervals.append([start, end])\n        else:\n            last_start, last_end = merged_intervals[-1]\n            if start <= last_end:\n                merged_intervals[-1][1] = max(end, last_end)\n            else:\n                merged_intervals.append([start, end])\n    \n    # Find available slots by checking gaps between merged intervals and work hours\n    available_slots = []\n    previous_end = work_start\n    for start, end in merged_intervals:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Check each available slot for sufficient duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define the participants' busy times\njean_busy = [\n    \"09:30 to 10:00\",\n    \"10:30 to 11:00\",\n    \"12:30 to 13:30\"\n]\n\namanda_busy = [\n    \"09:00 to 10:30\",\n    \"11:30 to 12:30\",\n    \"13:00 to 14:00\",\n    \"15:30 to 17:00\"\n]\n\n# Parameters\nparticipants_busy_times = [jean_busy, amanda_busy]\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 60  # 1 hour\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration_minutes))\n```",
            "count": "calendar_scheduling_example_542"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:30:14:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(work_start, work_end, duration, schedules):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Combine all busy intervals and sort them\n    all_busy = []\n    for person_schedule in schedules:\n        for busy in person_schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            all_busy.append((start, end))\n    \n    # Sort busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots\n    available = []\n    prev_end = work_start_min\n    \n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        available.append((prev_end, work_end_min))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define work hours, duration, and schedules\nwork_start = \"09:00\"\nwork_end = \"17:00\"\nduration = 1  # in hours\n\njames_schedule = [\n    \"11:30:12:00\",\n    \"14:30:15:00\"\n]\n\njohn_schedule = [\n    \"09:30:11:00\",\n    \"11:30:12:00\",\n    \"12:30:13:30\",\n    \"14:30:16:30\"\n]\n\nschedules = [james_schedule, john_schedule]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(work_start, work_end, duration, schedules)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_543"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Albert's busy times in minutes (start, end)\n    albert_busy = [\n        (9 * 60, 10 * 60),    # 9:00-10:00\n        (10 * 60 + 30, 12 * 60),  # 10:30-12:00\n        (15 * 60, 16 * 60 + 30),  # 15:00-16:30\n    ]\n    # Albert cannot meet after 11:00\n    albert_cutoff = 11 * 60\n\n    # Deborah is free all day, so only Albert's schedule matters\n    potential_slots = []\n\n    # Check before first busy slot\n    if albert_busy[0][0] > work_start:\n        potential_slots.append((work_start, albert_busy[0][0]))\n\n    # Check between busy slots\n    for i in range(1, len(albert_busy)):\n        prev_end = albert_busy[i-1][1]\n        curr_start = albert_busy[i][0]\n        if curr_start > prev_end:\n            potential_slots.append((prev_end, curr_start))\n\n    # Check after last busy slot but before work_end and Albert's cutoff\n    last_busy_end = albert_busy[-1][1]\n    latest_possible = min(work_end, albert_cutoff)\n    if latest_possible > last_busy_end:\n        potential_slots.append((last_busy_end, latest_possible))\n\n    # Find the first slot that can fit 30 minutes\n    meeting_duration = 30\n    for slot in potential_slots:\n        start, end = slot\n        if end - start >= meeting_duration:\n            # Return the first 30-minute window in this slot\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_544"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert busy slots to minutes\n    christine_busy = [\n        (12 * 60, 12 * 60 + 30),  # 12:00-12:30\n        (13 * 60, 13 * 60 + 30)    # 13:00-13:30\n    ]\n    richard_busy = [\n        (9 * 60, 12 * 60),          # 9:00-12:00\n        (13 * 60, 13 * 60 + 30),    # 13:00-13:30\n        (14 * 60, 14 * 60 + 30),    # 14:00-14:30\n        (15 * 60 + 30, 16 * 60),    # 15:30-16:00\n        (16 * 60 + 30, 17 * 60)     # 16:30-17:00\n    ]\n\n    # Combine and sort all busy slots\n    all_busy = christine_busy + richard_busy\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate 1 hour (60 minutes)\n    for start, end in free_slots:\n        if end - start >= 60:\n            meeting_start = start\n            meeting_end = meeting_start + 60\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_545"
        },
        {
            "final_program_time": "{9:30:10:30}",
            "expected_time": "{9:30:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Ruth's meetings in minutes since start of day\n    ruth_meetings = [\n        (9 * 60, 9 * 60 + 30),    # 9:00-9:30\n        (10 * 60 + 30, 12 * 60 + 30),  # 10:30-12:30\n        (13 * 60, 14 * 60 + 30),  # 13:00-14:30\n        (15 * 60 + 30, 16 * 60),   # 15:30-16:00\n        (16 * 60 + 30, 17 * 60)    # 16:30-17:00\n    ]\n\n    # Lauren's constraints: no meetings after 11:30 (11:30 in minutes)\n    lauren_max_time = 11 * 60 + 30\n\n    # Find available slots for Ruth (outside her meetings)\n    ruth_busy = sorted(ruth_meetings)\n    available_slots = []\n    previous_end = work_start\n\n    for start, end in ruth_busy:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n\n    # Check each available slot against Lauren's constraints and meeting duration (60 minutes)\n    meeting_duration = 60\n    for slot_start, slot_end in available_slots:\n        # Adjust slot_start to ensure the meeting fits and respects Lauren's constraint\n        latest_possible_start = min(slot_end - meeting_duration, lauren_max_time - meeting_duration)\n        if latest_possible_start >= slot_start:\n            actual_start = max(slot_start, latest_possible_start)\n            actual_end = actual_start + meeting_duration\n            if actual_end <= lauren_max_time and actual_end <= slot_end:\n                # Format the time as HH:MM:HH:MM\n                start_hh = actual_start // 60\n                start_mm = actual_start % 60\n                end_hh = actual_end // 60\n                end_mm = actual_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_546"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(duration, work_start, work_end, schedules):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Generate busy slots in minutes\n    busy_slots = []\n    for slot in schedules:\n        start, end = map(time_to_minutes, slot.split(' to '))\n        busy_slots.append((start, end))\n    \n    # Sort busy slots by start time\n    busy_slots.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = work_start_min\n    \n    for start, end in busy_slots:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        free_slots.append((prev_end, work_end_min))\n    \n    # Check for a free slot that can fit the duration\n    duration_min = duration * 60\n    for start, end in free_slots:\n        if end - start >= duration_min:\n            meeting_end = start + duration_min\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                h = minutes // 60\n                m = minutes % 60\n                return f\"{h:02d}:{m:02d}\"\n            \n            start_time = minutes_to_time(start)\n            end_time = minutes_to_time(meeting_end)\n            return f\"{start_time}:{end_time}\"\n    \n    return \"No suitable time found\"\n\n# Define the constraints\nduration = 1  # 1 hour\nwork_start = \"9:00\"\nwork_end = \"17:00\"\n# Jacob's busy slots\nschedules = [\n    \"9:00 to 10:30\",\n    \"11:30 to 12:00\",\n    \"12:30 to 13:00\",\n    \"13:30 to 15:00\",\n    \"15:30 to 16:00\",\n    \"16:30 to 17:00\"\n]\n\n# Find and print the meeting time\nprint(find_meeting_time(duration, work_start, work_end, schedules))\n```",
            "count": "calendar_scheduling_example_547"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define Judy's free time (entire day)\n    judy_free = [(work_start, work_end)]\n    \n    # Define Nicole's busy times (in minutes)\n    nicole_busy = [\n        (9 * 60, 10 * 60),    # 9:00-10:00\n        (10 * 60 + 30, 16 * 60 + 30)  # 10:30-16:30\n    ]\n    \n    # Nicole's preference: not before 16:00\n    preference_start = 16 * 60\n    \n    # Find Nicole's free times (inverse of busy times within work hours)\n    nicole_free = []\n    previous_end = work_start\n    \n    for start, end in sorted(nicole_busy):\n        if start > previous_end:\n            nicole_free.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        nicole_free.append((previous_end, work_end))\n    \n    # Filter Nicole's free times based on preference (not before 16:00)\n    nicole_free_preferred = []\n    for start, end in nicole_free:\n        if start >= preference_start:\n            nicole_free_preferred.append((start, end))\n        elif end > preference_start:\n            nicole_free_preferred.append((preference_start, end))\n    \n    # Find overlapping free times between Judy and Nicole (preferred)\n    meeting_duration = 30  # minutes\n    \n    for nicole_start, nicole_end in nicole_free_preferred:\n        # Judy is free all day, so overlap is Nicole's free time\n        start = nicole_start\n        end = nicole_end\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    # If no preferred time found, check all free times (though problem states solution exists)\n    for nicole_start, nicole_end in nicole_free:\n        start = nicole_start\n        end = nicole_end\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No time found\"  # Should not reach here per problem statement\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_548"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert busy slots to minutes\n    carl_busy = [\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    russell_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n\n    # Carl's preference: not after 10:30\n    carl_preference_end = 10 * 60 + 30\n\n    # Find all possible 30-minute slots\n    possible_slots = []\n    current_time = work_start\n    meeting_duration = 30\n\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        # Check if the slot is free for both and meets Carl's preference\n        carl_free = all(not (start <= current_time < end or start < slot_end <= end) for start, end in carl_busy)\n        russell_free = all(not (start <= current_time < end or start < slot_end <= end) for start, end in russell_busy)\n        if carl_free and russell_free and slot_end <= carl_preference_end:\n            possible_slots.append((current_time, slot_end))\n        current_time += 1  # Check every minute\n\n    if possible_slots:\n        # Return the first valid slot in HH:MM format\n        start, end = possible_slots[0]\n        return f\"{start // 60:02d}:{start % 60:02d}:{end // 60:02d}:{end % 60:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_549"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:11:30}",
            "type_error": "NoCodeGenerated",
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Deborah's busy times in minutes since midnight\n    deborah_busy = [\n        (9 * 60, 11 * 60),\n        (11 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n\n    # Deborah's preference to avoid meetings after 14:00\n    preference_cutoff = 14 * 60\n\n    # Generate available slots for Deborah\n    available_slots = []\n    prev_end = work_start\n\n    for start, end in deborah_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = end\n\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Filter slots based on Deborah's preference (before 14:00)\n    preferred_slots = []\n    for start, end in available_slots:\n        if end <= preference_cutoff:\n            preferred_slots.append((start, end))\n        elif start < preference_cutoff:\n            preferred_slots.append((start, preference_cutoff))\n\n    # Find the first available slot that fits 30 minutes\n    meeting_duration = 30\n    for start, end in preferred_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    # If no preferred slot found, check other available slots (though problem states a solution exists)\n    for start, end in available_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No available time found\"\n\nprint(find_meeting_time())\n'''\n```",
            "count": "calendar_scheduling_example_550"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define busy slots in minutes since midnight\n    daniel_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60 + 30, 16 * 60)\n    ]\n    anna_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 12 * 60),\n        (12 * 60 + 30, 17 * 60)\n    ]\n\n    # Daniel's preference: not after 10:00\n    daniel_preference_end = 10 * 60\n\n    # Find all possible 30-minute slots\n    possible_slots = []\n    current_time = work_start\n\n    while current_time + 30 <= work_end:\n        slot_end = current_time + 30\n        # Check if the slot is before Daniel's preference\n        if slot_end <= daniel_preference_end:\n            # Check if both are free\n            daniel_free = True\n            for start, end in daniel_busy:\n                if not (slot_end <= start or current_time >= end):\n                    daniel_free = False\n                    break\n            anna_free = True\n            for start, end in anna_busy:\n                if not (slot_end <= start or current_time >= end):\n                    anna_free = False\n                    break\n            if daniel_free and anna_free:\n                possible_slots.append((current_time, slot_end))\n        current_time += 30\n\n    # Select the earliest possible slot\n    if possible_slots:\n        meeting_start, meeting_end = possible_slots[0]\n        # Convert minutes back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_551"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 14 * 60   # 14:00 in minutes (Margaret can't meet after 14:00)\n    \n    # Margaret's busy slots in minutes\n    margaret_busy = [\n        (9 * 60, 9 * 60 + 30),   # 9:00-9:30\n        (10 * 60, 10 * 60 + 30), # 10:00-10:30\n        (12 * 60, 14 * 60 + 30), # 12:00-14:30 (but truncated to 14:00 due to constraint)\n    ]\n    \n    # Brian is free all day, so only Margaret's schedule matters\n    \n    # Generate available slots by finding gaps in Margaret's schedule\n    available_slots = []\n    previous_end = work_start\n    \n    for start, end in sorted(margaret_busy):\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the time after the last busy slot\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Find the first available 30-minute slot\n    meeting_duration = 30\n    for start, end in available_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No available time slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_552"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:9:30}",
            "type_error": "NameError",
            "full_response": "```python\ndef find_meeting_time(eric_busy, henry_busy, henry_preference, duration, work_hours):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m - 540  # Subtract 540 to start from 9:00 (0 minutes)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        h = total_minutes // 60\n        m = total_minutes % 60\n        return f\"{h:02d}:{m:02d}\"\n    \n    # Parse work hours\n    work_start, work_end = map(time_to_minutes, work_hours.split(':'))\n    \n    # Generate Eric's free slots\n    eric_free = []\n    prev_end = work_start\n    for start, end in sorted(eric_busy):\n        eric_free.append((prev_end, start))\n        prev_end = end\n    eric_free.append((prev_end, work_end))\n    \n    # Generate Henry's free slots\n    henry_free = []\n    prev_end = work_start\n    for start, end in sorted(henry_busy):\n        henry_free.append((prev_end, start))\n        prev_end = end\n    henry_free.append((prev_end, work_end))\n    \n    # Find overlapping slots that meet duration and Henry's preference\n    for e_start, e_end in eric_free:\n        for h_start, h_end in henry_free:\n            start = max(e_start, h_start)\n            end = min(e_end, h_end)\n            if end - start >= duration:\n                # Check Henry's preference (before 10:00 is 60 minutes)\n                meeting_end = start + duration\n                if meeting_end <= 60:  # 10:00 is 60 minutes from 9:00\n                    return (start, meeting_end)\n    \n    # If no preferred slot found, find any slot\n    for e_start, e_end in eric_free:\n        for h_start, h_end in henry_free:\n            start = max(e_start, h_start)\n            end = min(e_end, h_end)\n            if end - start >= duration:\n                return (start, start + duration)\n    \n    return None\n\n# Input data\neric_busy = [(time_to_minutes('12:00'), time_to_minutes('13:00')), \n             (time_to_minutes('14:00'), time_to_minutes('15:00'))]\nhenry_busy = [(time_to_minutes('9:30'), time_to_minutes('10:00')), \n              (time_to_minutes('10:30'), time_to_minutes('11:00')), \n              (time_to_minutes('11:30'), time_to_minutes('12:30')), \n              (time_to_minutes('13:00'), time_to_minutes('13:30')), \n              (time_to_minutes('14:30'), time_to_minutes('15:00')), \n              (time_to_minutes('16:00'), time_to_minutes('17:00'))]\nhenry_preference = True  # Prefers before 10:00\nduration = 30  # minutes\nwork_hours = \"9:00:17:00\"\n\n# Find meeting time\nmeeting_slot = find_meeting_time(eric_busy, henry_busy, henry_preference, duration, work_hours)\n\nif meeting_slot:\n    start, end = meeting_slot\n    start_time = minutes_to_time(start)\n    end_time = minutes_to_time(end)\n    print(f\"{start_time}:{end_time}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_553"
        },
        {
            "final_program_time": "{9:30:10:30}",
            "expected_time": "{9:30:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(theresa_busy, frances_busy, work_start, work_end, duration):\n    # Convert all time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Generate all busy slots for Theresa and Frances\n    theresa_slots = [(time_to_minutes(start), time_to_minutes(end)) for start, end in theresa_busy]\n    frances_slots = [(time_to_minutes(start), time_to_minutes(end)) for start, end in frances_busy]\n    \n    # Combine and sort all busy slots\n    all_busy = theresa_slots + frances_slots\n    all_busy.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = work_start_min\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        free_slots.append((prev_end, work_end_min))\n    \n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define the busy slots\ntheresa_busy = [(\"10:30\", \"11:00\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:30\"), (\"15:00\", \"15:30\"), (\"16:30\", \"17:00\")]\nfrances_busy = [(\"09:00\", \"09:30\"), (\"10:30\", \"15:00\"), (\"15:30\", \"16:30\")]\n\n# Define work hours and duration\nwork_start = \"09:00\"\nwork_end = \"17:00\"\nduration = 1  # in hours\n\n# Find and print the meeting time\nprint(find_meeting_time(theresa_busy, frances_busy, work_start, work_end, duration))\n```",
            "count": "calendar_scheduling_example_554"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Evelyn's constraints: available all day but doesn't want to meet after 13:00\n    evelyn_start = work_start\n    evelyn_end = 13 * 60  # 13:00 in minutes\n    \n    # Randy's blocked times in minutes\n    randy_blocked = [\n        (9 * 60, 10 * 60 + 30),  # 9:00-10:30\n        (11 * 60, 15 * 60 + 30),  # 11:00-15:30\n        (16 * 60, 17 * 60)        # 16:00-17:00\n    ]\n    \n    # Meeting duration in minutes\n    duration = 30\n    \n    # Find available slots for Randy (inverse of blocked times)\n    randy_available = []\n    prev_end = work_start\n    \n    for start, end in sorted(randy_blocked):\n        if start > prev_end:\n            randy_available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        randy_available.append((prev_end, work_end))\n    \n    # Find overlapping slots between Evelyn and Randy\n    for r_start, r_end in randy_available:\n        # The slot must start and end within Evelyn's availability\n        slot_start = max(r_start, evelyn_start)\n        slot_end = min(r_end, evelyn_end)\n        \n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_555"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(eric_busy, deborah_busy, deborah_preference, duration, work_hours):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 9:00 (0 minutes)\n    \n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    work_start, work_end = map(time_to_minutes, work_hours.split(' to '))\n    work_end -= duration  # No meeting can start after this time\n    \n    # Parse Deborah's preference\n    pref_start, pref_end = map(time_to_minutes, deborah_preference.split(' to '))\n    \n    # Combine and sort all busy intervals for Eric and Deborah\n    all_busy = []\n    for start, end in eric_busy:\n        all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    for start, end in deborah_busy:\n        all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    all_busy.sort()\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    for start, end in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Filter slots that fit the duration and are within Deborah's preference\n    valid_slots = []\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            # Check if the slot is entirely before Deborah's preference cutoff\n            if slot_start < pref_start:\n                valid_slots.append((slot_start, slot_end))\n    \n    # If no slots before preference, look at all slots\n    if not valid_slots:\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= duration:\n                valid_slots.append((slot_start, slot_end))\n    \n    # Select the earliest possible slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + duration\n        return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    else:\n        return \"No available time slot found.\"\n\n# Input data\neric_busy = [\n    (\"9:00\", \"10:00\"),\n    (\"11:30\", \"12:00\"),\n    (\"12:30\", \"14:00\")\n]\ndeborah_busy = [\n    (\"9:00\", \"10:30\"),\n    (\"11:00\", \"11:30\"),\n    (\"12:00\", \"12:30\"),\n    (\"13:30\", \"14:30\"),\n    (\"15:00\", \"15:30\")\n]\ndeborah_preference = \"9:00 to 15:00\"  # Avoid after 15:00\nduration = 30  # minutes\nwork_hours = \"9:00 to 17:00\"\n\n# Find and print the meeting time\nprint(find_meeting_time(eric_busy, deborah_busy, deborah_preference, duration, work_hours))\n```",
            "count": "calendar_scheduling_example_556"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(william_busy, natalie_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work_hours start at 9:00\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = 9 + minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work = time_to_minutes(work_hours[0])\n    end_work = time_to_minutes(work_hours[1])\n    duration_min = duration * 60\n    \n    # Generate all busy slots in minutes for both participants\n    william_busy_min = [(time_to_minutes(start), time_to_minutes(end)) for start, end in william_busy]\n    natalie_busy_min = [(time_to_minutes(start), time_to_minutes(end)) for start, end in natalie_busy]\n    \n    # Combine and sort all busy slots\n    all_busy = william_busy_min + natalie_busy_min\n    all_busy.sort()\n    \n    # Find available slots\n    available_slots = []\n    prev_end = start_work\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < end_work:\n        available_slots.append((prev_end, end_work))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define busy slots and parameters\nwilliam_busy = [(\"10:00\", \"10:30\"), (\"12:00\", \"13:00\"), (\"16:00\", \"16:30\")]\nnatalie_busy = [(\"09:00\", \"09:30\"), (\"10:00\", \"10:30\"), (\"12:00\", \"13:30\"), (\"14:00\", \"14:30\"), (\"15:00\", \"17:00\")]\nwork_hours = (\"09:00\", \"17:00\")\nduration = 1  # in hours\n\n# Find and print the meeting time\nprint(find_meeting_time(william_busy, natalie_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_557"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define Douglas's busy times in minutes (start, end)\n    douglas_busy = [\n        (9 * 60, 12 * 60),\n        (12 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    \n    # Anthony's constraint: not before 14:00\n    anthony_constraint = 14 * 60\n    \n    # Meeting duration in minutes\n    duration = 30\n    \n    # Find Douglas's free slots within work hours\n    douglas_free = []\n    prev_end = work_start\n    \n    for start, end in sorted(douglas_busy):\n        if start > prev_end:\n            douglas_free.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        douglas_free.append((prev_end, work_end))\n    \n    # Find slots that fit the meeting duration and Anthony's constraint\n    possible_slots = []\n    for start, end in douglas_free:\n        slot_start = max(start, anthony_constraint)\n        if slot_start + duration <= end:\n            possible_slots.append((slot_start, slot_start + duration))\n    \n    # Select the earliest possible slot\n    if possible_slots:\n        meeting_start, meeting_end = possible_slots[0]\n        # Convert minutes back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No suitable time found.\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_558"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(larry_busy, james_busy, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m - 540  # Subtract 540 to make 9:00 as 0\n    \n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes  # Add back 540 to convert to 24-hour format\n        h = total_minutes // 60\n        m = total_minutes % 60\n        return f\"{h:02d}:{m:02d}\"\n    \n    # Parse busy slots for Larry and James\n    def parse_busy_slots(busy_slots):\n        slots = []\n        for slot in busy_slots:\n            start, end = slot.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            slots.append((start_min, end_min))\n        return slots\n    \n    larry_slots = parse_busy_slots(larry_busy)\n    james_slots = parse_busy_slots(james_busy)\n    \n    # Combine and sort all busy slots\n    all_busy = larry_slots + james_slots\n    all_busy.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = 0\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    # Check after last busy slot\n    work_end_min = time_to_minutes(work_hours_end)\n    if prev_end < work_end_min:\n        free_slots.append((prev_end, work_end_min))\n    \n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= duration:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Input data\nlarry_busy = [\"11:00 to 12:30\", \"13:00 to 13:30\", \"14:30 to 15:30\"]\njames_busy = [\"10:00 to 10:30\", \"11:30 to 12:30\", \"13:30 to 14:00\", \"14:30 to 15:30\", \"16:00 to 17:00\"]\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration = 60  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(larry_busy, james_busy, work_hours_start, work_hours_end, duration))\n```",
            "count": "calendar_scheduling_example_559"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:00:13:00}",
            "type_error": "NoCodeGenerated",
            "full_response": "```python\ndef find_meeting_time(participant_busy_times, work_hours, duration):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = work_hours\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Generate all busy intervals in minutes\n    busy_intervals = []\n    for busy_slots in participant_busy_times.values():\n        for slot in busy_slots:\n            start, end = map(time_to_minutes, slot.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = work_start_min\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        free_slots.append((prev_end, work_end_min))\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return (minutes_to_time(meeting_start), minutes_to_time(meeting_end))\n    \n    return None\n\n# Define the problem parameters\nwork_hours = (\"9:00\", \"17:00\")\nparticipant_busy_times = {\n    \"Marilyn\": [],\n    \"Benjamin\": [\"9:00:10:00\", \"10:30:12:00\", \"13:30:14:30\", \"15:00:16:00\", \"16:30:17:00\"],\n}\nmeeting_duration = 1  # in hours\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participant_busy_times, work_hours, meeting_duration)\n\n# Output the result in the required format\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{start}:{end}\")\nelse:\n    print(\"No suitable time found.\")\n'''\n```",
            "count": "calendar_scheduling_example_560"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Define busy intervals in minutes since midnight\n    scott_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    jack_busy = [\n        (9 * 60, 15 * 60),\n        (15 * 60 + 30, 16 * 60 + 30)\n    ]\n    jack_constraint = 16 * 60  # Can't meet before 16:00\n\n    # Combine and sort all busy intervals\n    all_busy = scott_busy + jack_busy\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy intervals\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check after last busy interval\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Filter slots that meet duration (30 minutes) and Jack's constraint\n    meeting_duration = 30\n    valid_slots = []\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration and slot_start >= jack_constraint:\n            valid_slots.append((slot_start, slot_end))\n\n    # Select the earliest valid slot\n    if valid_slots:\n        chosen_start = valid_slots[0][0]\n        chosen_end = chosen_start + meeting_duration\n        # Format as HH:MM:HH:MM\n        return f\"{chosen_start // 60:02d}:{chosen_start % 60:02d}:{chosen_end // 60:02d}:{chosen_end % 60:02d}\"\n    else:\n        return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_561"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:00:10:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participant_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration_min = duration * 60\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participant_schedules.values():\n        for interval in schedule:\n            start = time_to_minutes(interval[0])\n            end = time_to_minutes(interval[1])\n            busy_intervals.append((start, end))\n    \n    # Sort the busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find available slots by merging busy intervals\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found.\"\n\n# Define the participants' schedules\nparticipant_schedules = {\n    \"Robert\": [(\"9:00\", \"9:30\"), (\"10:30\", \"12:00\")],\n    \"Bruce\": [(\"9:00\", \"10:00\"), (\"11:00\", \"17:00\")],\n}\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration = 0.5  # half an hour\n\n# Find and print the meeting time\nprint(find_meeting_time(participant_schedules, work_hours_start, work_hours_end, duration))\n```",
            "count": "calendar_scheduling_example_562"
        },
        {
            "final_program_time": "{16:00:17:00}",
            "expected_time": "{16:00:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert schedules to minutes since midnight\n    andrew_busy = [\n        (12 * 60 + 30, 13 * 60),      # 12:30-13:00\n        (13 * 60 + 30, 15 * 60)       # 13:30-15:00\n    ]\n    \n    alexis_busy = [\n        (10 * 60 + 30, 11 * 60),      # 10:30-11:00\n        (12 * 60, 14 * 60),           # 12:00-14:00\n        (14 * 60 + 30, 16 * 60)       # 14:30-16:00\n    ]\n    \n    # Alexis's preference: not before 13:30\n    alexis_preference_start = 13 * 60 + 30\n    \n    # Meeting duration in minutes\n    duration = 60\n    \n    # Generate all possible slots within work hours, considering Alexis's preference\n    possible_slots = []\n    current_start = max(work_start, alexis_preference_start)\n    \n    while current_start + duration <= work_end:\n        # Check if the slot is free for both\n        andrew_free = all(not (start <= current_start < end or start < current_start + duration <= end) \n                          for start, end in andrew_busy)\n        alexis_free = all(not (start <= current_start < end or start < current_start + duration <= end) \n                          for start, end in alexis_busy)\n        \n        if andrew_free and alexis_free:\n            possible_slots.append((current_start, current_start + duration))\n        \n        current_start += 30  # Check in 30-minute increments\n    \n    if not possible_slots:\n        return None\n    \n    # Select the earliest possible slot\n    meeting_start, meeting_end = possible_slots[0]\n    \n    # Convert back to HH:MM format\n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n    \n    return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_563"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' schedules and preferences\n    abigail_blocked = [\n        (10 * 60, 10 * 60 + 30),  # 10:00-10:30\n        (16 * 60 + 30, 17 * 60)    # 16:30-17:00\n    ]\n    matthew_blocked = [\n        (9 * 60, 10 * 60),         # 9:00-10:00\n        (10 * 60 + 30, 11 * 60 + 30),  # 10:30-11:30\n        (13 * 60, 14 * 60),        # 13:00-14:00\n        (15 * 60 + 30, 16 * 60 + 30)   # 15:30-16:30\n    ]\n    abigail_preference_end = 13 * 60 + 30  # 13:30\n    \n    # Combine all blocked times and sort\n    all_blocked = []\n    for start, end in abigail_blocked:\n        all_blocked.append((start, end, 'Abigail'))\n    for start, end in matthew_blocked:\n        all_blocked.append((start, end, 'Matthew'))\n    all_blocked.sort()\n    \n    # Find available slots\n    available_slots = []\n    previous_end = work_start\n    \n    for start, end, _ in all_blocked:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Filter slots based on duration (30 minutes) and Abigail's preference\n    meeting_duration = 30\n    valid_slots = []\n    for start, end in available_slots:\n        if end - start >= meeting_duration:\n            # Check if the slot starts before Abigail's preference end time\n            if start + meeting_duration <= abigail_preference_end:\n                valid_slots.append((start, end))\n    \n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Format the output as HH:MM:HH:MM\n        return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    else:\n        return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_564"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Convert busy intervals to minutes\n    joe_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60 + 30)\n    ]\n    elijah_busy = [\n        (9 * 60, 13 * 60),\n        (13 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Joe's preference: not after 13:30 (13 * 60 + 30)\n    max_preferred_time = 13 * 60 + 30\n    \n    # Find all busy intervals combined for both participants\n    all_busy = joe_busy + elijah_busy\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Check the available slots before the max preferred time\n    available_slots = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Filter slots that are at least 30 minutes and before max preferred time\n    possible_slots = []\n    for slot in available_slots:\n        start, end = slot\n        if end <= max_preferred_time and (end - start) >= 30:\n            possible_slots.append(slot)\n    \n    # Select the earliest possible slot\n    if possible_slots:\n        meeting_start = possible_slots[0][0]\n        meeting_end = meeting_start + 30\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_565"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participant_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy_intervals = []\n    \n    for schedule in participant_schedules:\n        for busy_start, busy_end in schedule:\n            all_busy_intervals.append((time_to_minutes(busy_start), time_to_minutes(busy_end)))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots outside merged busy intervals and within work hours\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define the schedules and constraints\nroy_schedule = [\n    (\"09:00\", \"10:30\"),\n    (\"11:30\", \"12:30\"),\n    (\"16:00\", \"16:30\")\n]\n\ndebra_schedule = [\n    (\"09:00\", \"09:30\"),\n    (\"10:00\", \"15:30\"),\n    (\"16:00\", \"17:00\")\n]\n\nparticipant_schedules = [roy_schedule, debra_schedule]\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\n# Find and print the meeting time\nprint(find_meeting_time(participant_schedules, work_hours_start, work_hours_end, duration_minutes))\n```",
            "count": "calendar_scheduling_example_566"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert busy slots to minutes\n    brandon_busy = [\n        (10 * 60, 11 * 60),      # 10:00-11:00\n        (12 * 60 + 30, 13 * 60),  # 12:30-13:00\n        (13 * 60 + 30, 14 * 60 + 30),  # 13:30-14:30\n        (15 * 60, 15 * 60 + 30)   # 15:00-15:30\n    ]\n    virginia_busy = [\n        (9 * 60, 10 * 60 + 30),   # 9:00-10:30\n        (11 * 60, 11 * 60 + 30),  # 11:00-11:30\n        (12 * 60 + 30, 13 * 60),   # 12:30-13:00\n        (13 * 60 + 30, 14 * 60),  # 13:30-14:00\n        (14 * 60 + 30, 16 * 60 + 30)  # 14:30-16:30\n    ]\n\n    # Virginia prefers no meetings after 13:00, so prioritize before 13:00\n    preferred_end = 13 * 60\n\n    # Find all possible 30-minute slots in work hours\n    possible_slots = []\n    for start in range(work_start, work_end - 30 + 1):\n        end = start + 30\n        # Check if the slot is free for both\n        brandon_free = all(not (start < busy_end and end > busy_start) for busy_start, busy_end in brandon_busy)\n        virginia_free = all(not (start < busy_end and end > busy_start) for busy_start, busy_end in virginia_busy)\n        if brandon_free and virginia_free:\n            possible_slots.append((start, end))\n\n    # Prioritize slots before 13:00\n    for slot in possible_slots:\n        if slot[1] <= preferred_end:\n            return f\"{slot[0]//60:02d}:{slot[0]%60:02d}:{slot[1]//60:02d}:{slot[1]%60:02d}\"\n\n    # If no preferred slot, return the first available\n    if possible_slots:\n        slot = possible_slots[0]\n        return f\"{slot[0]//60:02d}:{slot[0]%60:02d}:{slot[1]//60:02d}:{slot[1]%60:02d}\"\n\n    return \"No available slot\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_567"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define busy intervals in minutes since midnight\n    julia_busy = [\n        (15 * 60, 15 * 60 + 30),  # 15:00-15:30\n        (16 * 60, 16 * 60 + 30)   # 16:00-16:30\n    ]\n    pamela_busy = [\n        (11 * 60, 13 * 60 + 30),  # 11:00-13:30\n        (14 * 60 + 30, 15 * 60 + 30),  # 14:30-15:30\n        (16 * 60, 16 * 60 + 30)   # 16:00-16:30\n    ]\n\n    # Julia's preference: not after 12:30\n    julia_preference_end = 12 * 60 + 30  # 12:30 in minutes\n\n    # Combine all busy times and sort\n    all_busy = julia_busy + pamela_busy\n    all_busy.sort()\n\n    # Find free slots\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check each free slot for 30-minute availability and Julia's preference\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= 30:\n            # Check if the slot starts before Julia's preference end time\n            if slot_start + 30 <= julia_preference_end:\n                # Convert back to HH:MM format\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_hh = (slot_start + 30) // 60\n                end_mm = (slot_start + 30) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_568"
        },
        {
            "final_program_time": "{16:00:17:00}",
            "expected_time": "{16:00:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define busy intervals in minutes\n    julie_busy = [\n        (9 * 60, 9 * 60 + 30),    # 9:00-9:30\n        (12 * 60, 12 * 60 + 30),  # 12:00-12:30\n        (13 * 60 + 30, 14 * 60),  # 13:30-14:00\n        (15 * 60, 15 * 60 + 30)   # 15:00-15:30\n    ]\n    catherine_busy = [\n        (9 * 60, 10 * 60 + 30),  # 9:00-10:30\n        (13 * 60 + 30, 16 * 60)   # 13:30-16:00\n    ]\n    \n    # Julie's preference: not before 13:30\n    preferred_start = 13 * 60 + 30  # 13:30 in minutes\n    \n    # Combine and sort all busy intervals\n    all_busy = julie_busy + catherine_busy\n    all_busy.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Check for a slot that is at least 60 minutes and meets Julie's preference\n    for slot_start, slot_end in free_slots:\n        slot_start = max(slot_start, preferred_start)\n        if slot_end - slot_start >= 60:\n            meeting_start = slot_start\n            meeting_end = meeting_start + 60\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_569"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define Sophia's busy times in minutes since midnight\n    sophia_busy = [\n        (9 * 60 + 30, 12 * 60),      # 9:30 to 12:00\n        (12 * 60 + 30, 13 * 60),     # 12:30 to 13:00\n        (14 * 60 + 30, 16 * 60 + 30) # 14:30 to 16:30\n    ]\n\n    # Donna's constraint: avoid after 10:30\n    donna_constraint = 10 * 60 + 30  # 10:30 in minutes\n\n    # Meeting duration in minutes\n    duration = 30\n\n    # Find all possible slots for Sophia\n    sophia_free = []\n    prev_end = work_start\n    for start, end in sorted(sophia_busy):\n        if start > prev_end:\n            sophia_free.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        sophia_free.append((prev_end, work_end))\n\n    # Filter slots that fit duration and Donna's constraint\n    valid_slots = []\n    for start, end in sophia_free:\n        if end - start >= duration:\n            slot_start = max(start, work_start)\n            slot_end = min(end, work_end)\n            if slot_end - slot_start >= duration:\n                # Check Donna's constraint (must start before 10:30)\n                if slot_start + duration <= donna_constraint:\n                    valid_slots.append((slot_start, slot_start + duration))\n\n    if valid_slots:\n        # Select the earliest possible slot\n        best_slot = valid_slots[0]\n        # Convert minutes back to HH:MM format\n        start_h = best_slot[0] // 60\n        start_m = best_slot[0] % 60\n        end_h = (best_slot[0] + duration) // 60\n        end_m = (best_slot[0] + duration) % 60\n        return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    else:\n        return \"No valid slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_570"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert busy times to minutes since midnight\n    joseph_busy = [\n        (9 * 60, 9 * 60 + 30),   # 9:00-9:30\n        (12 * 60, 12 * 60 + 30)  # 12:00-12:30\n    ]\n    lori_busy = [\n        (9 * 60, 11 * 60),      # 9:00-11:00\n        (11 * 60 + 30, 12 * 60 + 30),  # 11:30-12:30\n        (13 * 60, 17 * 60)       # 13:00-17:00\n    ]\n    lori_max_time = 12 * 60 + 30  # Lori doesn't want to meet after 12:30\n\n    # Generate all possible slots for Joseph and Lori\n    def get_available_slots(busy_slots, max_time=None):\n        slots = []\n        prev_end = work_start\n        for start, end in sorted(busy_slots):\n            if start > prev_end:\n                slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if max_time is not None and prev_end < max_time:\n            slots.append((prev_end, max_time))\n        elif max_time is None and prev_end < work_end:\n            slots.append((prev_end, work_end))\n        return slots\n\n    joseph_slots = get_available_slots(joseph_busy)\n    lori_slots = get_available_slots(lori_busy, lori_max_time)\n\n    # Find overlapping slots\n    for js_start, js_end in joseph_slots:\n        for ls_start, ls_end in lori_slots:\n            start = max(js_start, ls_start)\n            end = min(js_end, ls_end)\n            if end - start >= meeting_duration:\n                # Convert back to HH:MM format\n                start_hh = start // 60\n                start_mm = start % 60\n                end_hh = (start + meeting_duration) // 60\n                end_mm = (start + meeting_duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_571"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define busy intervals in minutes since midnight\n    robert_busy = [\n        (10 * 60 + 30, 11 * 60),      # 10:30-11:00\n        (15 * 60, 15 * 60 + 30)        # 15:00-15:30\n    ]\n    frances_busy = [\n        (9 * 60, 9 * 60 + 30),         # 9:00-9:30\n        (11 * 60, 11 * 60 + 30),       # 11:00-11:30\n        (13 * 60, 14 * 60 + 30),       # 13:00-14:30\n        (15 * 60 + 30, 17 * 60)        # 15:30-17:00\n    ]\n    frances_preference_start = 11 * 60  # Frances doesn't want to meet before 11:00\n\n    # Combine and sort all busy intervals\n    all_busy = robert_busy + frances_busy\n    all_busy.sort()\n\n    # Find available slots\n    available_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    if work_end > previous_end:\n        available_slots.append((previous_end, work_end))\n\n    # Filter slots based on Frances' preference and duration (60 minutes)\n    meeting_duration = 60\n    valid_slots = []\n    for slot_start, slot_end in available_slots:\n        adjusted_start = max(slot_start, frances_preference_start)\n        if adjusted_start + meeting_duration <= slot_end:\n            valid_slots.append((adjusted_start, adjusted_start + meeting_duration))\n\n    # Select the first valid slot\n    if valid_slots:\n        meeting_start, meeting_end = valid_slots[0]\n        # Convert minutes back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_572"
        },
        {
            "final_program_time": "{11:00:12:00}",
            "expected_time": "{11:00:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(diana_schedule, alexis_schedule, work_hours, duration):\n    # Parse work hours\n    work_start, work_end = [int(time.split(':')[0]) for time in work_hours.split(' to ')]\n    \n    # Generate all possible slots within work hours\n    slots = []\n    for hour in range(work_start, work_end):\n        for minute in [0, 30]:\n            if hour == work_end - 1 and minute == 30:\n                continue  # Skip slots that exceed work hours\n            slots.append((hour, minute))\n    \n    # Check each slot for availability\n    for hour, minute in slots:\n        start_time = f\"{hour:02d}:{minute:02d}\"\n        end_hour = hour + duration // 60\n        end_minute = minute + duration % 60\n        if end_minute >= 60:\n            end_hour += 1\n            end_minute -= 60\n        end_time = f\"{end_hour:02d}:{end_minute:02d}\"\n        \n        # Check if the slot is free for both\n        diana_free = True  # Diana has no meetings\n        alexis_free = True\n        \n        # Check Alexis's schedule\n        for meeting in alexis_schedule:\n            m_start, m_end = meeting.split(' to ')\n            m_start_h, m_start_m = map(int, m_start.split(':'))\n            m_end_h, m_end_m = map(int, m_end.split(':'))\n            \n            # Convert times to minutes for easier comparison\n            slot_start = hour * 60 + minute\n            slot_end = end_hour * 60 + end_minute\n            meeting_start = m_start_h * 60 + m_start_m\n            meeting_end = m_end_h * 60 + m_end_m\n            \n            if not (slot_end <= meeting_start or slot_start >= meeting_end):\n                alexis_free = False\n                break\n        \n        if diana_free and alexis_free:\n            return f\"{start_time}:{end_time}\"\n    \n    return \"No available slot found\"\n\n# Given data\ndiana_schedule = []\nalexis_schedule = [\"9:00 to 11:00\", \"12:00 to 14:30\", \"15:00 to 16:30\"]\nwork_hours = \"9:00 to 17:00\"\nduration = 60  # minutes\n\n# Find meeting time\nmeeting_time = find_meeting_time(diana_schedule, alexis_schedule, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_573"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Martha's busy slots in minutes\n    martha_busy = [\n        (9 * 60 + 30, 11 * 60),    # 9:30-11:00\n        (11 * 60 + 30, 13 * 60 + 30),  # 11:30-13:30\n        (15 * 60, 15 * 60 + 30),    # 15:00-15:30\n        (16 * 60, 17 * 60)          # 16:00-17:00\n    ]\n\n    # Martha cannot meet after 11:00, so adjust work_end to 11:00\n    work_end = min(work_end, 11 * 60)\n\n    # Find all free slots for Martha within work hours\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in sorted(martha_busy):\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_574"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define Stephanie's busy times in minutes since 9:00\n    stephanie_busy = [\n        (11 * 60, 11 * 60 + 30),  # 11:00-11:30\n        (16 * 60 + 30, 17 * 60)   # 16:30-17:00\n    ]\n    \n    # Define Samuel's busy times in minutes since 9:00\n    samuel_busy = [\n        (9 * 60, 10 * 60),        # 9:00-10:00\n        (10 * 60 + 30, 11 * 60),  # 10:30-11:00\n        (11 * 60 + 30, 12 * 60 + 30),  # 11:30-12:30\n        (13 * 60, 13 * 60 + 30),  # 13:00-13:30\n        (14 * 60, 15 * 60 + 30),  # 14:00-15:30\n        (16 * 60 + 30, 17 * 60)   # 16:30-17:00\n    ]\n    \n    # Stephanie's preference: not after 13:00\n    preference_end = 13 * 60\n    \n    # Combine and sort all busy times for both participants\n    all_busy = stephanie_busy + samuel_busy\n    all_busy.sort()\n    \n    # Find available slots before preference_end\n    current_time = work_start\n    available_slots = []\n    \n    for start, end in all_busy:\n        if start > current_time:\n            available_slots.append((current_time, start))\n        current_time = max(current_time, end)\n    \n    if current_time < preference_end:\n        available_slots.append((current_time, preference_end))\n    \n    # Check for a 30-minute slot in the available slots\n    meeting_duration = 30\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    # If no slot found (though the problem states there is one)\n    return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_575"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert schedules to minutes since start of day\n    dennis_busy = [\n        (10 * 60 + 30, 11 * 60),    # 10:30-11:00\n        (12 * 60, 12 * 60 + 30),     # 12:00-12:30\n        (14 * 60 + 30, 15 * 60 + 30) # 14:30-15:30\n    ]\n    \n    roy_busy = [\n        (9 * 60, 9 * 60 + 30),       # 9:00-9:30\n        (10 * 60, 11 * 60),          # 10:00-11:00\n        (11 * 60 + 30, 12 * 60 + 30),# 11:30-12:30\n        (13 * 60, 15 * 60),          # 13:00-15:00\n        (15 * 60 + 30, 17 * 60)      # 15:30-17:00\n    ]\n    \n    roy_no_meet_after = 12 * 60  # Roy doesn't want to meet after 12:00\n    \n    meeting_duration = 30  # minutes\n    \n    # Generate all possible slots within work hours\n    possible_slots = []\n    current_time = work_start\n    \n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 15  # Check every 15 minutes for efficiency\n    \n    # Check each slot against constraints\n    for slot in possible_slots:\n        start, end = slot\n        \n        # Check Roy's \"no meet after 12:00\" constraint\n        if start >= roy_no_meet_after:\n            continue\n        \n        # Check Dennis's availability\n        dennis_available = True\n        for busy_start, busy_end in dennis_busy:\n            if not (end <= busy_start or start >= busy_end):\n                dennis_available = False\n                break\n        \n        if not dennis_available:\n            continue\n        \n        # Check Roy's availability\n        roy_available = True\n        for busy_start, busy_end in roy_busy:\n            if not (end <= busy_start or start >= busy_end):\n                roy_available = False\n                break\n        \n        if roy_available:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = end // 60\n            end_mm = end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Execute and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_576"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert busy intervals to minutes\n    virginia_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60 + 30, 16 * 60 + 30)\n    ]\n    billy_busy = [\n        (9 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 13 * 60),\n        (15 * 60, 16 * 60)\n    ]\n\n    # Combine and sort all busy intervals\n    all_busy = virginia_busy + billy_busy\n    all_busy.sort()\n\n    # Find free intervals\n    free_intervals = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    if work_end > previous_end:\n        free_intervals.append((previous_end, work_end))\n\n    # Find the first free interval that can accommodate the meeting (60 minutes)\n    meeting_duration = 60\n    for start, end in free_intervals:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_577"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:30:14:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(bobby_schedule, doris_schedule, work_hours, duration, preference):\n    # Parse work hours\n    work_start, work_end = map(lambda x: int(x.replace(':', '')), work_hours.split(' to '))\n    \n    # Generate all possible 30-minute slots in work hours\n    slots = []\n    current = work_start\n    while current + duration * 100 <= work_end:\n        slot_end = current + duration * 100\n        slots.append((current, slot_end))\n        # Increment by 30 minutes (50 in 24-hour time format)\n        current += 30 if (current % 100) == 0 else 70\n    \n    # Filter slots based on Bobby's preference (not before 13:00)\n    preferred_slots = [slot for slot in slots if slot[0] >= 1300]\n    \n    # Check each preferred slot against both schedules\n    for slot in preferred_slots:\n        slot_start, slot_end = slot\n        bobby_free = True\n        for meeting in bobby_schedule:\n            m_start, m_end = map(lambda x: int(x.replace(':', '')), meeting.split(' to '))\n            if not (slot_end <= m_start or slot_start >= m_end):\n                bobby_free = False\n                break\n        if not bobby_free:\n            continue\n        \n        doris_free = True\n        for meeting in doris_schedule:\n            m_start, m_end = map(lambda x: int(x.replace(':', '')), meeting.split(' to '))\n            if not (slot_end <= m_start or slot_start >= m_end):\n                doris_free = False\n                break\n        if doris_free:\n            # Format the time as HH:MM:HH:MM\n            return f\"{slot_start // 100:02d}:{slot_start % 100:02d}:{slot_end // 100:02d}:{slot_end % 100:02d}\"\n    \n    # If no preferred slot found, check all slots (though problem states a solution exists)\n    for slot in slots:\n        slot_start, slot_end = slot\n        bobby_free = True\n        for meeting in bobby_schedule:\n            m_start, m_end = map(lambda x: int(x.replace(':', '')), meeting.split(' to '))\n            if not (slot_end <= m_start or slot_start >= m_end):\n                bobby_free = False\n                break\n        if not bobby_free:\n            continue\n        \n        doris_free = True\n        for meeting in doris_schedule:\n            m_start, m_end = map(lambda x: int(x.replace(':', '')), meeting.split(' to '))\n            if not (slot_end <= m_start or slot_start >= m_end):\n                doris_free = False\n                break\n        if doris_free:\n            return f\"{slot_start // 100:02d}:{slot_start % 100:02d}:{slot_end // 100:02d}:{slot_end % 100:02d}\"\n    \n    return \"No suitable time found\"\n\n# Given data\nbobby_schedule = [\"9:00 to 10:00\", \"10:30 to 12:00\", \"14:30 to 15:00\"]\ndoris_schedule = [\"10:30 to 11:00\", \"11:30 to 12:30\", \"13:00 to 13:30\", \"15:00 to 17:00\"]\nwork_hours = \"9:00 to 17:00\"\nduration = 0.5  # half an hour\npreference = \"after 13:00\"\n\n# Find and print the meeting time\nprint(find_meeting_time(bobby_schedule, doris_schedule, work_hours, duration, preference))\n```",
            "count": "calendar_scheduling_example_578"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' schedules and constraints\n    christine_busy = [\n        (11 * 60, 11 * 60 + 30),  # 11:00-11:30\n        (15 * 60, 15 * 60 + 30)    # 15:00-15:30\n    ]\n    helen_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),  # 9:30-10:30\n        (11 * 60, 11 * 60 + 30),      # 11:00-11:30\n        (12 * 60, 12 * 60 + 30),       # 12:00-12:30\n        (13 * 60 + 30, 16 * 60),       # 13:30-16:00\n        (16 * 60 + 30, 17 * 60)        # 16:30-17:00\n    ]\n    helen_no_meet_after = 15 * 60  # 15:00\n\n    # Combine and sort all busy intervals\n    all_busy = christine_busy + helen_busy\n    all_busy.sort()\n\n    # Find free slots\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check for a 30-minute slot that fits all constraints\n    meeting_duration = 30\n    for start, end in free_slots:\n        # Adjust end time based on Helen's constraint\n        adjusted_end = min(end, helen_no_meet_after)\n        if adjusted_end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_579"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Jose's busy times in minutes (10:00-11:00, 12:00-14:00, 15:00-16:00)\n    jose_busy = [\n        (10 * 60, 11 * 60),\n        (12 * 60, 14 * 60),\n        (15 * 60, 16 * 60)\n    ]\n    \n    # Jose cannot meet after 10:30 (which is 10:30 = 10*60 + 30)\n    jose_cutoff = 10 * 60 + 30\n    \n    # Adam is free all day, so only need to consider Jose's schedule\n    # Find all free slots for Jose within work hours and before 10:30\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in jose_busy:\n        if previous_end < start:\n            free_slots.append((previous_end, start))\n        previous_end = end\n    \n    # Check the time after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Filter slots that are before 10:30 and have at least 60 minutes\n    meeting_duration = 60\n    valid_slots = []\n    for start, end in free_slots:\n        # Adjust end time if it exceeds the cutoff\n        effective_end = min(end, jose_cutoff)\n        if effective_end - start >= meeting_duration:\n            valid_slots.append((start, effective_end))\n    \n    # Select the earliest possible slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Format the output as HH:MM:HH:MM\n        return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    else:\n        return \"No valid time slot found.\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_580"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_start, work_end, duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Collect all busy intervals for all participants\n    all_busy_intervals = []\n    for busy_times in participants_busy_times.values():\n        for interval in busy_times:\n            start, end = interval.split(' to ')\n            all_busy_intervals.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals_sorted = sorted(all_busy_intervals, key=lambda x: x[0])\n    \n    # Find free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    previous_end = work_start_min\n    \n    for start, end in all_busy_intervals_sorted:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end_min:\n        free_intervals.append((previous_end, work_end_min))\n    \n    # Find the first free interval that can accommodate the meeting duration\n    for start, end in free_intervals:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' busy times\nparticipants_busy_times = {\n    \"Ronald\": [\"9:30 to 10:30\", \"13:00 to 13:30\", \"15:30 to 16:00\"],\n    \"Ann\": [\"9:30 to 10:00\", \"11:00 to 12:30\", \"13:30 to 14:30\", \"15:30 to 16:30\"]\n}\n\n# Define work hours and meeting duration\nwork_start = \"9:00\"\nwork_end = \"17:00\"\nduration = 1  # in hours\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_start, work_end, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_581"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:30:17:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration, constraints):\n    # Parse work hours\n    work_start, work_end = work_hours.split(\" to \")\n    work_start = int(work_start.split(\":\")[0]) * 60 + int(work_start.split(\":\")[1])\n    work_end = int(work_end.split(\":\")[0]) * 60 + int(work_end.split(\":\")[1])\n    \n    # Initialize available slots as the entire work day\n    available_slots = [(work_start, work_end)]\n    \n    # Apply constraints\n    for constraint in constraints:\n        if constraint[\"participant\"] == \"Ann\" and constraint[\"condition\"] == \"before\":\n            constraint_time = int(constraint[\"time\"].split(\":\")[0]) * 60 + int(constraint[\"time\"].split(\":\")[1])\n            available_slots = [(max(slot[0], constraint_time), slot[1]) for slot in available_slots]\n    \n    # Process each participant's schedule to find common free times\n    for participant, schedules in participants_schedules.items():\n        busy_slots = []\n        for schedule in schedules:\n            start, end = schedule.split(\" to \")\n            start_time = int(start.split(\":\")[0]) * 60 + int(start.split(\":\")[1])\n            end_time = int(end.split(\":\")[0]) * 60 + int(end.split(\":\")[1])\n            busy_slots.append((start_time, end_time))\n        \n        # Sort busy slots\n        busy_slots.sort()\n        \n        # Subtract busy slots from available slots\n        new_available_slots = []\n        for slot in available_slots:\n            current_start = slot[0]\n            for busy_start, busy_end in busy_slots:\n                if busy_start > current_start and busy_start < slot[1]:\n                    new_available_slots.append((current_start, busy_start))\n                    current_start = busy_end\n                elif busy_start <= current_start and busy_end > current_start:\n                    current_start = busy_end\n            if current_start < slot[1]:\n                new_available_slots.append((current_start, slot[1]))\n        available_slots = new_available_slots\n    \n    # Find the first available slot that can fit the duration\n    duration_minutes = int(duration.split(\" \")[0]) * 30 if \"half\" in duration else int(duration.split(\" \")[0]) * 60\n    for slot in available_slots:\n        if slot[1] - slot[0] >= duration_minutes:\n            # Format the time as HH:MM:HH:MM\n            start_hh = slot[0] // 60\n            start_mm = slot[0] % 60\n            end_hh = (slot[0] + duration_minutes) // 60\n            end_mm = (slot[0] + duration_minutes) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No available slot found\"\n\n# Define the problem\nparticipants_schedules = {\n    \"Olivia\": [\"9:30 to 10:00\", \"10:30 to 11:00\", \"13:00 to 14:00\", \"15:30 to 16:30\"],\n    \"Ann\": [\"9:00 to 9:30\", \"11:00 to 13:00\", \"13:30 to 14:30\", \"15:00 to 15:30\"]\n}\nwork_hours = \"9:00 to 17:00\"\nduration = \"half an hour\"\nconstraints = [\n    {\"participant\": \"Ann\", \"condition\": \"before\", \"time\": \"15:00\"}\n]\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration, constraints))\n```",
            "count": "calendar_scheduling_example_582"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(lisa_busy, anthony_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n    \n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Parse busy slots\n    def parse_busy_slots(busy_slots):\n        slots = []\n        for slot in busy_slots:\n            start, end = slot.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            slots.append((start_min, end_min))\n        return slots\n    \n    lisa_slots = parse_busy_slots(lisa_busy)\n    anthony_slots = parse_busy_slots(anthony_busy)\n    \n    # Combine and sort all busy slots\n    all_busy = lisa_slots + anthony_slots\n    all_busy.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Find the earliest slot that fits the duration\n    for start, end in free_slots:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Input data\nlisa_busy = [\"9:00 to 9:30\", \"10:30 to 11:00\", \"14:00 to 16:00\"]\nanthony_busy = [\"9:00 to 9:30\", \"11:00 to 11:30\", \"12:30 to 13:30\", \"14:00 to 15:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"]\nwork_hours = \"9:00 to 17:00\"\nduration = 30  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(lisa_busy, anthony_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_583"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:00:13:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participant_schedules, duration, work_start, work_end):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participant_schedules:\n        for busy_start, busy_end in schedule:\n            busy_start_min = time_to_minutes(busy_start)\n            busy_end_min = time_to_minutes(busy_end)\n            busy_intervals.append((busy_start_min, busy_end_min))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start_min\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n    \n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define the participants' schedules\nemma_schedule = []  # Emma's calendar is wide open\nhenry_schedule = [(\"9:00\", \"13:00\"), (\"14:00\", \"17:00\")]\n\nparticipant_schedules = [emma_schedule, henry_schedule]\nduration = 0.5  # half an hour\nwork_start = \"9:00\"\nwork_end = \"17:00\"\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participant_schedules, duration, work_start, work_end)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_584"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participant_schedules, work_hours, duration):\n    # Parse work hours\n    work_start, work_end = work_hours.split(\" to \")\n    work_start = int(work_start.split(\":\")[0]) * 60 + int(work_start.split(\":\")[1])\n    work_end = int(work_end.split(\":\")[0]) * 60 + int(work_end.split(\":\")[1])\n\n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participant_schedules.values():\n        for meeting in schedule:\n            start, end = meeting.split(\" to \")\n            start_min = int(start.split(\":\")[0]) * 60 + int(start.split(\":\")[1])\n            end_min = int(end.split(\":\")[0]) * 60 + int(end.split(\":\")[1])\n            busy_intervals.append((start_min, end_min))\n\n    # Sort busy intervals by start time\n    busy_intervals.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                new_interval = (last_start, max(last_end, current_end))\n                merged[-1] = new_interval\n            else:\n                merged.append(interval)\n\n    # Find available slots\n    available_slots = []\n    previous_end = work_start\n    for interval in merged:\n        current_start, current_end = interval\n        if current_start > previous_end:\n            available_slots.append((previous_end, current_start))\n        previous_end = max(previous_end, current_end)\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n\n    # Find first available slot that can fit the meeting\n    duration_min = duration * 60\n    for slot in available_slots:\n        start, end = slot\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = start + duration_min\n            # Format the time as HH:MM\n            start_hour = meeting_start // 60\n            start_min = meeting_start % 60\n            end_hour = meeting_end // 60\n            end_min = meeting_end % 60\n            return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n    return None\n\n# Define participant schedules\nparticipant_schedules = {\n    \"Adam\": [\"9:00 to 10:30\", \"16:00 to 16:30\"],\n    \"Frank\": [\"9:30 to 10:00\", \"10:30 to 11:30\", \"12:00 to 13:30\", \"14:00 to 14:30\", \"15:30 to 16:00\"],\n}\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nduration = 1  # in hours\n\n# Find meeting time\nmeeting_time = find_meeting_time(participant_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_585"
        },
        {
            "final_program_time": "{15:00:16:00}",
            "expected_time": "{15:00:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Ralph's busy times in minutes (start, end)\n    ralph_busy = [\n        (9 * 60, 9 * 60 + 30),    # 9:00-9:30\n        (10 * 60, 11 * 60 + 30),   # 10:00-11:30\n        (12 * 60 + 30, 15 * 60),   # 12:30-15:00\n        (16 * 60, 16 * 60 + 30)    # 16:00-16:30\n    ]\n\n    # Brandon cannot meet before 15:00\n    brandon_constraint = 15 * 60  # 15:00 in minutes\n\n    # Combine all constraints (Ralph's busy times + Brandon's constraint)\n    constraints = ralph_busy + [(0, brandon_constraint)]\n\n    # Sort constraints by start time\n    constraints.sort()\n\n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n\n    for start, end in constraints:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Check for a slot that can fit the 1-hour meeting\n    meeting_duration = 60  # 1 hour\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Return the first available slot that fits\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Format as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No available time slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_586"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:9:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(zachary_busy, nicole_busy, work_hours, duration):\n    # Convert all time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # 9:00 is 0 minutes\n    \n    # Convert minutes back to time string\n    def minutes_to_time(m):\n        hh = 9 + m // 60\n        mm = m % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work = time_to_minutes(work_hours[0])\n    end_work = time_to_minutes(work_hours[1])\n    duration_min = duration * 60\n    \n    # Generate busy slots in minutes for Zachary and Nicole\n    def parse_busy_slots(busy_slots):\n        slots = []\n        for slot in busy_slots:\n            start, end = map(time_to_minutes, slot.split(' to '))\n            slots.append((start, end))\n        return slots\n    \n    zachary_slots = parse_busy_slots(zachary_busy)\n    nicole_slots = parse_busy_slots(nicole_busy)\n    \n    # Combine and sort all busy slots\n    all_busy = zachary_slots + nicole_slots\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    prev_end = start_work\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < end_work:\n        free_slots.append((prev_end, end_work))\n    \n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return (minutes_to_time(meeting_start), minutes_to_time(meeting_end))\n    \n    return None\n\n# Input data\nzachary_busy = [\n    \"9:30 to 10:00\",\n    \"11:00 to 11:30\",\n    \"13:30 to 14:30\",\n    \"15:00 to 15:30\",\n    \"16:00 to 16:30\"\n]\n\nnicole_busy = [\n    \"9:30 to 15:00\",\n    \"15:30 to 17:00\"\n]\n\nwork_hours = (\"9:00\", \"17:00\")\nduration = 0.5  # half an hour\n\n# Find meeting time\nmeeting_time = find_meeting_time(zachary_busy, nicole_busy, work_hours, duration)\n\n# Output the result in HH:MM:HH:MM format\nif meeting_time:\n    print(f\"{meeting_time[0]}:{meeting_time[1]}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_587"
        },
        {
            "final_program_time": "{15:30:16:30}",
            "expected_time": "{15:30:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(kimberly_busy, eric_busy, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Offset by 9:00 (540 minutes)\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes  # Add back the 9:00 offset\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    # Parse work hours\n    work_start, work_end = map(time_to_minutes, work_hours.split(' to '))\n    work_end -= duration  # Last possible start time\n\n    # Parse busy slots\n    def parse_busy_slots(busy_slots):\n        slots = []\n        for slot in busy_slots:\n            start, end = map(time_to_minutes, slot.split(' to '))\n            slots.append((start, end))\n        return slots\n\n    kimberly_slots = parse_busy_slots(kimberly_busy)\n    eric_slots = parse_busy_slots(eric_busy)\n\n    # Combine and sort all busy slots\n    all_busy = kimberly_slots + eric_slots\n    all_busy.sort()\n\n    # Find the earliest available slot\n    current_start = work_start\n    for start, end in all_busy:\n        if start > current_start and start - current_start >= duration:\n            return f\"{minutes_to_time(current_start)}:{minutes_to_time(current_start + duration)}\"\n        current_start = max(current_start, end)\n    \n    # Check after last busy slot\n    if current_start <= work_end:\n        return f\"{minutes_to_time(current_start)}:{minutes_to_time(current_start + duration)}\"\n    \n    return \"No available slot\"\n\n# Input data\nkimberly_busy = [\n    \"9:00 to 9:30\",\n    \"13:30 to 14:00\",\n    \"15:00 to 15:30\",\n    \"16:30 to 17:00\"\n]\n\neric_busy = [\n    \"9:00 to 9:30\",\n    \"10:00 to 12:30\",\n    \"13:00 to 15:30\",\n    \"16:30 to 17:00\"\n]\n\nwork_hours = \"9:00 to 17:00\"\nduration = 60  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(kimberly_busy, eric_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_588"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define Laura's busy times in minutes since midnight\n    laura_busy = [\n        (11 * 60 + 30, 12 * 60 + 30),  # 11:30 - 12:30\n        (14 * 60 + 30, 15 * 60),        # 14:30 - 15:00\n        (16 * 60, 16 * 60 + 30)         # 16:00 - 16:30\n    ]\n\n    # Define Paul's busy times in minutes since midnight\n    paul_busy = [\n        (9 * 60 + 30, 10 * 60),         # 9:30 - 10:00\n        (11 * 60, 14 * 60 + 30),        # 11:00 - 14:30\n        (15 * 60, 17 * 60)              # 15:00 - 17:00\n    ]\n\n    # Paul's constraint: does not want to meet after 9:30 (so only before 9:30)\n    paul_constraint = 9 * 60 + 30  # 9:30\n\n    # Meeting duration in minutes\n    meeting_duration = 30\n\n    # Combine all busy times and sort them\n    all_busy = laura_busy + paul_busy\n    all_busy.sort()\n\n    # Find potential slots before Paul's constraint (9:30)\n    potential_start = work_start\n    potential_end = paul_constraint\n\n    # Check if there's a slot before 9:30\n    if potential_end - potential_start >= meeting_duration:\n        # Check if the slot is free for both\n        slot_free = True\n        for busy_start, busy_end in all_busy:\n            if busy_start < potential_end and busy_end > potential_start:\n                slot_free = False\n                break\n        if slot_free:\n            # Format the time as HH:MM:HH:MM\n            start_hh = potential_start // 60\n            start_mm = potential_start % 60\n            end_hh = (potential_start + meeting_duration) // 60\n            end_mm = (potential_start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    # If no slot found before 9:30, return None (though the task says a solution exists)\n    return None\n\n# Run the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_589"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(megan_schedule, emily_schedule, work_hours, duration):\n    # Parse work hours\n    work_start, work_end = [int(time.replace(':', '')) for time in work_hours.split(' to ')]\n    \n    # Convert schedules to minutes since 9:00 (540 minutes)\n    def parse_time(time_str):\n        hours, minutes = map(int, time_str.split(':'))\n        return hours * 60 + minutes\n    \n    # Generate busy slots in minutes\n    def get_busy_slots(schedule):\n        busy_slots = []\n        for slot in schedule:\n            start, end = map(parse_time, slot.split(' to '))\n            busy_slots.append((start, end))\n        return busy_slots\n    \n    megan_busy = get_busy_slots(megan_schedule)\n    emily_busy = get_busy_slots(emily_schedule)\n    \n    # Combine and sort all busy slots\n    all_busy = megan_busy + emily_busy\n    all_busy.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = parse_time('9:00')\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    # Check after last busy slot\n    if prev_end < parse_time('17:00'):\n        free_slots.append((prev_end, parse_time('17:00')))\n    \n    # Find first slot that fits the duration\n    for start, end in free_slots:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def format_time(minutes):\n                hours = minutes // 60\n                mins = minutes % 60\n                return f\"{hours:02d}:{mins:02d}\"\n            return f\"{format_time(meeting_start)}:{format_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Input data\nmegan_schedule = [\"9:30 to 10:00\", \"11:30 to 12:00\"]\nemily_schedule = [\"9:00 to 10:30\", \"11:00 to 12:00\", \"12:30 to 13:00\", \"13:30 to 14:30\", \"15:30 to 16:30\"]\nwork_hours = \"9:00 to 17:00\"\nduration = 60  # minutes\n\n# Find and print meeting time\nprint(find_meeting_time(megan_schedule, emily_schedule, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_590"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Kenneth's schedule (in minutes since midnight)\n    kenneth_busy = [\n        (9 * 60, 9 * 60 + 30),   # 9:00-9:30\n        (11 * 60, 11 * 60 + 30),  # 11:00-11:30\n        (15 * 60, 15 * 60 + 30),  # 15:00-15:30\n        (16 * 60 + 30, 17 * 60)   # 16:30-17:00\n    ]\n    # Kenneth doesn't want to meet before 13:00\n    kenneth_no_meet_before = 13 * 60  # 13:00 in minutes\n\n    # Melissa's schedule (in minutes since midnight)\n    melissa_busy = [\n        (10 * 60 + 30, 13 * 60),      # 10:30-13:00\n        (14 * 60, 14 * 60 + 30),      # 14:00-14:30\n        (15 * 60 + 30, 16 * 60 + 30)  # 15:30-16:30\n    ]\n\n    # Combine all busy times and sort\n    all_busy = []\n    for start, end in kenneth_busy:\n        all_busy.append((start, end, 'Kenneth'))\n    for start, end in melissa_busy:\n        all_busy.append((start, end, 'Melissa'))\n    all_busy.sort()\n\n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n\n    for start, end, _ in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Filter slots based on Kenneth's preference (not before 13:00)\n    filtered_slots = []\n    for start, end in available_slots:\n        if start >= kenneth_no_meet_before:\n            filtered_slots.append((start, end))\n        elif end > kenneth_no_meet_before:\n            filtered_slots.append((kenneth_no_meet_before, end))\n\n    # Find first slot that can fit the meeting\n    for start, end in filtered_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No available time slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_591"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:11:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours\n    start_work_min = time_to_minutes(start_work)\n    end_work_min = time_to_minutes(end_work)\n    duration_min = duration * 60\n    \n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy_intervals in participants_busy.values():\n        for interval in busy_intervals:\n            start, end = interval\n            all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by checking gaps between busy intervals and work hours\n    free_intervals = []\n    prev_end = start_work_min\n    \n    for busy_start, busy_end in all_busy:\n        if busy_start > prev_end:\n            free_intervals.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n    \n    if prev_end < end_work_min:\n        free_intervals.append((prev_end, end_work_min))\n    \n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define the participants' busy times and work hours\nparticipants_busy = {\n    \"Katherine\": [(\"10:00\", \"11:00\")],\n    \"Alexander\": [(\"09:00\", \"11:00\"), (\"12:00\", \"17:00\")],\n}\n\nwork_hours = (\"09:00\", \"17:00\")\nmeeting_duration = 0.5  # in hours\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_592"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Elijah's busy times and constraints (in minutes)\n    elijah_busy = [(9 * 60, 10 * 60)]  # 9:00-10:00\n    elijah_no_meet_after = 15 * 60      # 15:00\n\n    # Beverly's busy times (in minutes)\n    beverly_busy = [\n        (9 * 60, 12.5 * 60),    # 9:00-12:30\n        (13.5 * 60, 15.5 * 60), # 13:30-15:30\n        (16.5 * 60, 17 * 60)    # 16:30-17:00\n    ]\n\n    # Combine all busy intervals for both participants\n    all_busy = elijah_busy + beverly_busy\n    all_busy.sort()  # Sort by start time\n\n    # Find free slots by checking gaps between busy intervals\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Add the slot after the last busy interval if any\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check each free slot for availability and Elijah's constraint\n    for slot_start, slot_end in free_slots:\n        # Adjust slot_end to respect Elijah's no-meet-after constraint\n        effective_end = min(slot_end, elijah_no_meet_after)\n        if effective_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{int(meeting_start // 60):02d}:{int(meeting_start % 60):02d}:{int(meeting_end // 60):02d}:{int(meeting_end % 60):02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_593"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Generate all busy intervals for each participant\n    busy_intervals = []\n    for participant in participants_busy_times:\n        for interval in participant:\n            start, end = interval.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            busy_intervals.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the earliest available slot that fits the duration\n    duration = duration_minutes\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return (f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\")\n    \n    return None\n\n# Define the participants' busy times\nadam_busy = [\n    \"9:30 to 10:00\",\n    \"12:30 to 13:00\",\n    \"14:30 to 15:00\",\n    \"16:30 to 17:00\"\n]\n\nroy_busy = [\n    \"10:00 to 11:00\",\n    \"11:30 to 13:00\",\n    \"13:30 to 14:30\",\n    \"16:30 to 17:00\"\n]\n\nparticipants_busy_times = [adam_busy, roy_busy]\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_594"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Christina's busy slots in minutes\n    christina_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n\n    # Elizabeth's busy slots in minutes\n    elizabeth_busy = [\n        (9 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 15 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n\n    # Combine all busy slots for both participants\n    all_busy = christina_busy + elizabeth_busy\n    all_busy.sort()  # Sort by start time\n\n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check the slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the earliest free slot that can fit 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = (start + meeting_duration) // 60\n            end_mm = (start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_595"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Deborah's schedule and constraints\n    deborah_busy = [\n        (9 * 60, 10 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (15 * 60, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    deborah_no_meet_after = 12 * 60  # No meetings after 12:00\n    \n    # Theresa's schedule\n    theresa_busy = [\n        (9 * 60, 11 * 60),\n        (11 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 17 * 60)\n    ]\n    \n    # Generate available slots for Deborah (before 12:00)\n    deborah_available = []\n    prev_end = work_start\n    for start, end in sorted(deborah_busy):\n        if start > prev_end and prev_end < deborah_no_meet_after:\n            deborah_available.append((prev_end, min(start, deborah_no_meet_after)))\n        prev_end = max(prev_end, end)\n    if prev_end < deborah_no_meet_after:\n        deborah_available.append((prev_end, deborah_no_meet_after))\n    \n    # Generate available slots for Theresa\n    theresa_available = []\n    prev_end = work_start\n    for start, end in sorted(theresa_busy):\n        if start > prev_end:\n            theresa_available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        theresa_available.append((prev_end, work_end))\n    \n    # Find overlapping slots of at least 30 minutes\n    meeting_duration = 30\n    for deb_start, deb_end in deborah_available:\n        for the_start, the_end in theresa_available:\n            start = max(deb_start, the_start)\n            end = min(deb_end, the_end)\n            if end - start >= meeting_duration:\n                # Return the first available slot\n                return f\"{start//60:02d}:{start%60:02d}:{(start+meeting_duration)//60:02d}:{(start+meeting_duration)%60:02d}\"\n    \n    return \"No meeting time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_596"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:30:14:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participant_busy_slots, work_hours_start, work_hours_end, meeting_duration):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    meeting_duration_min = meeting_duration * 60\n    \n    # Generate all busy slots for all participants in minutes\n    all_busy_slots = []\n    for busy_slots in participant_busy_slots:\n        for slot in busy_slots:\n            start, end = map(time_to_minutes, slot.split(':'))\n            all_busy_slots.append((start, end))\n    \n    # Sort all busy slots by start time\n    all_busy_slots.sort()\n    \n    # Find available slots by checking gaps between busy slots and work hours\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy_slots:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    # Check the slot after the last busy slot\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define the participants' busy slots\nroy_busy = [\"11:00:11:30\", \"12:00:12:30\", \"15:00:15:30\", \"16:30:17:00\"]\nmelissa_busy = [\"9:00:13:30\", \"14:00:15:00\", \"15:30:17:00\"]\n\n# Combine all participants' busy slots\nall_busy_slots = [roy_busy, melissa_busy]\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 0.5  # in hours\n\n# Find the meeting time\nmeeting_time = find_meeting_time(all_busy_slots, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_597"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define Sara's busy slots in minutes\n    sara_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (13 * 60, 14 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Define Randy's busy slots in minutes\n    randy_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60, 17 * 60)\n    ]\n    \n    # Sara's preference to avoid meetings after 11:00\n    sara_preference_end = 11 * 60\n    \n    # Meeting duration in minutes\n    meeting_duration = 30\n    \n    # Generate all possible slots within work hours\n    possible_slots = []\n    current_time = work_start\n    \n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 15  # Check every 15 minutes for efficiency\n    \n    # Filter slots that don't conflict with Sara's or Randy's schedule and respect Sara's preference\n    valid_slots = []\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        \n        # Check Sara's busy slots\n        sara_conflict = False\n        for busy_start, busy_end in sara_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                sara_conflict = True\n                break\n        \n        # Check Randy's busy slots\n        randy_conflict = False\n        for busy_start, busy_end in randy_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                randy_conflict = True\n                break\n        \n        # Check Sara's preference\n        sara_preference_ok = slot_start < sara_preference_end\n        \n        if not sara_conflict and not randy_conflict and sara_preference_ok:\n            valid_slots.append(slot)\n    \n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start, meeting_end = valid_slots[0]\n        # Format the output as HH:MM:HH:MM\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        print(f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\")\n    else:\n        print(\"No valid meeting time found.\")\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_598"
        },
        {
            "final_program_time": "{11:00:12:00}",
            "expected_time": "{11:00:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert busy intervals to minutes\n    judith_busy = [\n        (12 * 60, 14 * 60 + 30),  # 12:00-14:30\n        (15 * 60 + 30, 16 * 60)   # 15:30-16:00\n    ]\n    mason_busy = [\n        (9 * 60 + 30, 11 * 60),    # 9:30-11:00\n        (12 * 60 + 30, 13 * 60 + 30),  # 12:30-13:30\n        (14 * 60, 14 * 60 + 30),   # 14:00-14:30\n        (15 * 60, 15 * 60 + 30),   # 15:00-15:30\n        (16 * 60 + 30, 17 * 60)    # 16:30-17:00\n    ]\n    \n    # Combine and sort all busy intervals\n    all_busy = judith_busy + mason_busy\n    all_busy.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Find the first free slot that can accommodate the meeting (1 hour)\n    meeting_duration = 60\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_599"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_earliest_meeting_time(bruce_schedule, jessica_schedule, work_hours, duration_minutes=30):\n    # Convert work hours to minutes since midnight for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Function to parse schedule into blocked times in minutes\n    def parse_schedule(schedule):\n        blocked = []\n        for day, intervals in schedule.items():\n            for interval in intervals:\n                start_h, start_m = interval[0], interval[1]\n                end_h, end_m = interval[2], interval[3]\n                start = start_h * 60 + start_m\n                end = end_h * 60 + end_m\n                blocked.append((start, end))\n        return blocked\n    \n    # Parse both schedules\n    bruce_blocked = parse_schedule(bruce_schedule)\n    jessica_blocked = parse_schedule(jessica_schedule)\n    \n    # Combine and sort all blocked times\n    all_blocked = bruce_blocked + jessica_blocked\n    all_blocked.sort()\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in all_blocked:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Check for a slot that can fit the meeting\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            start_h = meeting_start // 60\n            start_m = meeting_start % 60\n            end_h = meeting_end // 60\n            end_m = meeting_end % 60\n            return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    \n    return None\n\n# Define schedules\nbruce_schedule = {\n    \"Monday\": [\n        (9, 30, 10, 0),\n        (11, 0, 11, 30),\n        (12, 0, 12, 30),\n        (13, 30, 14, 0),\n        (14, 30, 15, 0),\n        (16, 0, 16, 30)\n    ],\n    \"Tuesday\": [\n        (12, 0, 12, 30),\n        (13, 30, 14, 0)\n    ]\n}\n\njessica_schedule = {\n    \"Monday\": [\n        (9, 0, 17, 0)\n    ],\n    \"Tuesday\": [\n        (9, 30, 12, 30),\n        (13, 0, 17, 0)\n    ]\n}\n\n# Work hours: 9:00 to 17:00 (9*60 to 17*60 in minutes)\nwork_hours = (9, 17)\n\n# Find earliest meeting time on Monday or Tuesday\n# Check Monday first\nmonday_time = find_earliest_meeting_time(\n    {\"Monday\": bruce_schedule[\"Monday\"]},\n    {\"Monday\": jessica_schedule[\"Monday\"]},\n    work_hours\n)\n\nif monday_time:\n    print(monday_time)\nelse:\n    # Check Tuesday\n    tuesday_time = find_earliest_meeting_time(\n        {\"Tuesday\": bruce_schedule[\"Tuesday\"]},\n        {\"Tuesday\": jessica_schedule[\"Tuesday\"]},\n        work_hours\n    )\n    print(tuesday_time)\n```",
            "count": "calendar_scheduling_example_600"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to check\n    days = ['Monday', 'Tuesday']\n\n    # Mark's blocked times in minutes since midnight\n    mark_blocked = {\n        'Monday': [\n            (9 * 60, 9 * 60 + 30),    # 9:00-9:30\n            (10 * 60, 10 * 60 + 30),   # 10:00-10:30\n            (12 * 60 + 30, 13 * 60),  # 12:30-13:00\n            (16 * 60, 16 * 60 + 30),  # 16:00-16:30\n        ],\n        'Tuesday': [\n            (9 * 60, 10 * 60),        # 9:00-10:00\n            (12 * 60, 12 * 60 + 30),  # 12:00-12:30\n            (14 * 60, 14 * 60 + 30),  # 14:00-14:30\n        ]\n    }\n\n    # Marie's blocked times in minutes since midnight\n    marie_blocked = {\n        'Monday': [\n            (9 * 60 + 30, 11 * 60 + 30),  # 9:30-11:30\n            (12 * 60, 17 * 60),           # 12:00-17:00\n        ],\n        'Tuesday': [\n            (9 * 60, 17 * 60),            # 9:00-17:00\n        ]\n    }\n\n    # Iterate through each day\n    for day in days:\n        # Collect all blocked times for both participants\n        all_blocked = mark_blocked.get(day, []) + marie_blocked.get(day, [])\n        all_blocked.sort()\n\n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n\n        for start, end in all_blocked:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n\n        # Check after last blocked time\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n\n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= meeting_duration:\n                # Convert to HH:MM format\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_time = slot_start + meeting_duration\n                end_hh = end_time // 60\n                end_mm = end_time % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_601"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check (Monday and Tuesday)\n    days = ['Monday', 'Tuesday']\n    \n    # Define Anna's and Cheryl's schedules in minutes since midnight\n    # Format: {day: [(start1, end1), (start2, end2), ...]}\n    anna_schedule = {\n        'Monday': [\n            (9 * 60, 9 * 60 + 30),\n            (10 * 60, 11 * 60 + 30),\n            (12 * 60, 12 * 60 + 30),\n            (13 * 60, 13 * 60 + 30),\n            (14 * 60, 15 * 60),\n            (15 * 60 + 30, 16 * 60 + 30)\n        ],\n        'Tuesday': [\n            (9 * 60, 9 * 60 + 30),\n            (10 * 60, 10 * 60 + 30),\n            (12 * 60, 12 * 60 + 30),\n            (14 * 60 + 30, 15 * 60)\n        ]\n    }\n    \n    cheryl_schedule = {\n        'Monday': [\n            (9 * 60, 12 * 60 + 30),\n            (13 * 60, 16 * 60 + 30)\n        ],\n        'Tuesday': [\n            (9 * 60, 10 * 60),\n            (11 * 60, 13 * 60),\n            (13 * 60 + 30, 15 * 60 + 30),\n            (16 * 60, 17 * 60)\n        ]\n    }\n    \n    meeting_duration = 30  # minutes\n    \n    # Prefer Tuesday due to Cheryl's preference to avoid Monday\n    preferred_days = ['Tuesday', 'Monday']\n    \n    for day in preferred_days:\n        # Collect all busy intervals for both participants\n        busy_intervals = []\n        if day in anna_schedule:\n            busy_intervals.extend(anna_schedule[day])\n        if day in cheryl_schedule:\n            busy_intervals.extend(cheryl_schedule[day])\n        \n        # Sort busy intervals by start time\n        busy_intervals.sort()\n        \n        # Find free slots by checking gaps between busy intervals and work hours\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in busy_intervals:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy interval\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= meeting_duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_602"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to check (Monday and Tuesday)\n    days = ['Monday', 'Tuesday']\n    \n    # Define Anna's and Margaret's schedules in minutes\n    anna_schedule = {\n        'Monday': [\n            (9 * 60, 9 * 60 + 30),    # 9:00-9:30\n            (11 * 60, 12 * 60),        # 11:00-12:00\n            (14 * 60, 14 * 60 + 30),   # 14:00-14:30\n            (15 * 60, 15 * 60 + 30),   # 15:00-15:30\n        ],\n        'Tuesday': [\n            (9 * 60, 10 * 60),         # 9:00-10:00\n            (12 * 60 + 30, 13 * 60 + 30),  # 12:30-13:30\n            (16 * 60 + 30, 17 * 60),   # 16:30-17:00\n        ],\n    }\n    \n    margaret_schedule = {\n        'Monday': [\n            (9 * 60, 14 * 60),        # 9:00-14:00\n            (14 * 60 + 30, 17 * 60),   # 14:30-17:00\n        ],\n        'Tuesday': [\n            (9 * 60, 10 * 60 + 30),    # 9:00-10:30\n            (11 * 60 + 30, 12 * 60),   # 11:30-12:00\n            (12 * 60 + 30, 14 * 60 + 30),  # 12:30-14:30\n            (15 * 60 + 30, 17 * 60),    # 15:30-17:00\n        ],\n    }\n    \n    # Anna's preference: not before 14:30 on Tuesday\n    anna_preference = {\n        'Tuesday': 14 * 60 + 30  # 14:30\n    }\n    \n    meeting_duration = 60  # 1 hour\n    \n    # Iterate through each day\n    for day in days:\n        # Get busy slots for both participants\n        anna_busy = anna_schedule.get(day, [])\n        margaret_busy = margaret_schedule.get(day, [])\n        \n        # Combine and sort all busy slots\n        all_busy = anna_busy + margaret_busy\n        all_busy.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            potential_start = slot_start\n            potential_end = potential_start + meeting_duration\n            \n            # Ensure the slot can fit the meeting\n            if potential_end <= slot_end:\n                # Check Anna's preference for Tuesday\n                if day == 'Tuesday' and potential_start < anna_preference['Tuesday']:\n                    continue\n                \n                # Check if both are free\n                anna_free = True\n                for start, end in anna_busy:\n                    if not (potential_end <= start or potential_start >= end):\n                        anna_free = False\n                        break\n                \n                margaret_free = True\n                for start, end in margaret_busy:\n                    if not (potential_end <= start or potential_start >= end):\n                        margaret_free = False\n                        break\n                \n                if anna_free and margaret_free:\n                    # Convert minutes back to HH:MM format\n                    start_hh = potential_start // 60\n                    start_mm = potential_start % 60\n                    end_hh = potential_end // 60\n                    end_mm = potential_end % 60\n                    \n                    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_603"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to check\n    days = ['Monday', 'Tuesday']\n\n    # Define busy slots for each person in minutes since midnight\n    stephanie_busy = {\n        'Monday': [\n            (9 * 60 + 30, 10 * 60),    # 9:30-10:00\n            (12 * 60, 12 * 60 + 30),   # 12:00-12:30\n            (14 * 60, 15 * 60)         # 14:00-15:00\n        ],\n        'Tuesday': []\n    }\n\n    billy_busy = {\n        'Monday': [\n            (9 * 60, 17 * 60)  # 9:00-17:00 (entire day)\n        ],\n        'Tuesday': [\n            (9 * 60 + 30, 12 * 60 + 30),  # 9:30-12:30\n            (13 * 60, 17 * 60)             # 13:00-17:00\n        ]\n    }\n\n    # Billy's preference: not before 11:30 on Tuesday\n    billy_preference_start = 11 * 60 + 30  # 11:30 in minutes\n\n    # Iterate through each day\n    for day in days:\n        if day == 'Monday':\n            # Check Monday\n            # Stephanie's available slots on Monday (outside her busy times)\n            steph_available = []\n            prev_end = work_start\n            for start, end in sorted(stephanie_busy['Monday']):\n                if start > prev_end:\n                    steph_available.append((prev_end, start))\n                prev_end = end\n            if work_end > prev_end:\n                steph_available.append((prev_end, work_end))\n\n            # Billy is entirely busy on Monday, so no overlap possible\n            continue\n        elif day == 'Tuesday':\n            # Check Tuesday\n            # Stephanie's available slots on Tuesday (entire day, no busy times)\n            steph_available = [(work_start, work_end)]\n\n            # Billy's available slots on Tuesday (outside his busy times and considering preference)\n            billy_available = []\n            prev_end = work_start\n            for start, end in sorted(billy_busy['Tuesday']):\n                if start > prev_end:\n                    billy_available.append((prev_end, start))\n                prev_end = end\n            if work_end > prev_end:\n                billy_available.append((prev_end, work_end))\n\n            # Filter Billy's available slots based on preference (not before 11:30)\n            billy_available_preferred = []\n            for start, end in billy_available:\n                if start < billy_preference_start:\n                    if end > billy_preference_start:\n                        start = billy_preference_start\n                    else:\n                        continue\n                billy_available_preferred.append((start, end))\n\n            # Find overlapping slots between Stephanie and Billy (preferred)\n            for steph_start, steph_end in steph_available:\n                for billy_start, billy_end in billy_available_preferred:\n                    overlap_start = max(steph_start, billy_start)\n                    overlap_end = min(steph_end, billy_end)\n                    if overlap_end - overlap_start >= meeting_duration:\n                        # Found a suitable slot\n                        start_time = overlap_start\n                        end_time = start_time + meeting_duration\n                        # Format the output as HH:MM:HH:MM\n                        return f\"{start_time // 60:02d}:{start_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_604"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check (Monday and Tuesday)\n    days = ['Monday', 'Tuesday']\n    \n    # Define busy slots for Jesse and Kenneth in minutes since midnight\n    jesse_busy = {\n        'Monday': [(13 * 60, 13 * 60 + 30), (15 * 60 + 30, 16 * 60)],\n        'Tuesday': [(9 * 60, 9 * 60 + 30), (13 * 60, 13 * 60 + 30), \n                    (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)]\n    }\n    \n    kenneth_busy = {\n        'Monday': [(9 * 60, 10 * 60), (11 * 60 + 30, 14 * 60), \n                   (15 * 60, 15 * 60 + 30)],\n        'Tuesday': [(9 * 60, 12 * 60 + 30), (13 * 60, 14 * 60), \n                    (16 * 60, 16 * 60 + 30)]\n    }\n    \n    # Preferences\n    jesse_prefers_monday = True  # Jesse prefers to avoid Tuesday\n    kenneth_avoid_monday_after_12 = True  # Kenneth avoids Monday after 12:00\n    \n    # Iterate through days in order (Monday first)\n    for day in days:\n        if day == 'Monday' and jesse_prefers_monday:\n            pass  # Monday is preferred\n        elif day == 'Tuesday' and jesse_prefers_monday:\n            continue  # Skip Tuesday if Jesse prefers Monday\n        \n        # Get busy slots for the day\n        jesse_day_busy = jesse_busy.get(day, [])\n        kenneth_day_busy = kenneth_busy.get(day, [])\n        \n        # Combine and sort all busy slots\n        all_busy = jesse_day_busy + kenneth_day_busy\n        all_busy.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for 30-minute availability\n        for start, end in free_slots:\n            duration_needed = 30\n            if end - start >= duration_needed:\n                # Check Kenneth's Monday after 12:00 constraint\n                if day == 'Monday' and kenneth_avoid_monday_after_12:\n                    if start >= 12 * 60:\n                        continue  # Skip this slot\n                \n                # Found a valid slot\n                meeting_start = start\n                meeting_end = meeting_start + duration_needed\n                \n                # Convert back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                \n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_605"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check (Monday is 0, Tuesday is 1)\n    days = [\"Monday\", \"Tuesday\"]\n    \n    # Define busy slots for Amy and Denise in minutes since midnight\n    amy_busy = {\n        \"Monday\": [\n            (10 * 60, 11 * 60),    # 10:00-11:00\n            (12 * 60, 12 * 60 + 30), # 12:00-12:30\n            (15 * 60 + 30, 17 * 60)  # 15:30-17:00\n        ],\n        \"Tuesday\": [\n            (9 * 60, 10 * 60),       # 9:00-10:00\n            (11 * 60 + 30, 12 * 60), # 11:30-12:00\n            (13 * 60 + 30, 14 * 60), # 13:30-14:00\n            (15 * 60 + 30, 16 * 60), # 15:30-16:00\n            (16 * 60 + 30, 17 * 60)  # 16:30-17:00\n        ]\n    }\n    \n    denise_busy = {\n        \"Monday\": [\n            (9 * 60, 9 * 60 + 30),   # 9:00-9:30\n            (10 * 60, 17 * 60)       # 10:00-17:00\n        ],\n        \"Tuesday\": [\n            (9 * 60, 10 * 60 + 30), # 9:00-10:30\n            (12 * 60 + 30, 16 * 60), # 12:30-16:00\n            (16 * 60 + 30, 17 * 60)  # 16:30-17:00\n        ]\n    }\n    \n    # Duration of the meeting in minutes\n    duration = 30\n    \n    # Denise doesn't want to meet on Tuesday, so only check Monday\n    day = \"Monday\"\n    \n    # Collect all busy slots for the day\n    busy_slots = []\n    busy_slots.extend(amy_busy[day])\n    busy_slots.extend(denise_busy[day])\n    \n    # Sort busy slots by start time\n    busy_slots.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    prev_end = work_start\n    free_slots = []\n    for start, end in busy_slots:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    # Check the slot after the last busy slot\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_606"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Albert's blocked times on Tuesday (in minutes since midnight)\n    albert_tuesday_blocked = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Denise's blocked times on Monday (in minutes since midnight)\n    denise_monday_blocked = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 11 * 60 + 30),\n        (12 * 60, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Albert cannot meet on Monday after 11:00\n    albert_monday_blocked_after = 11 * 60\n    \n    # Check Monday first (Albert can only meet before 11:00)\n    monday_start = work_start\n    monday_end = albert_monday_blocked_after\n    duration = 30\n    \n    # Find available slots on Monday\n    # Albert is free before 11:00, so we check Denise's Monday blocks\n    # Generate Denise's Monday busy times before 11:00\n    denise_monday_before_11 = [(start, end) for start, end in denise_monday_blocked if end <= monday_end]\n    \n    # Find gaps in Denise's schedule on Monday before 11:00\n    denise_monday_free = []\n    prev_end = monday_start\n    for start, end in sorted(denise_monday_before_11):\n        if start > prev_end:\n            denise_monday_free.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if monday_end > prev_end:\n        denise_monday_free.append((prev_end, monday_end))\n    \n    # Check for a 30-minute slot in Denise's free times on Monday\n    for start, end in denise_monday_free:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    # If Monday doesn't work, check Tuesday\n    # Albert's and Denise's blocked times on Tuesday\n    albert_tuesday_blocked = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    denise_tuesday_blocked = [\n        (9 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 16 * 60 + 30)\n    ]\n    \n    # Combine and sort all blocked times for Tuesday\n    all_tuesday_blocked = albert_tuesday_blocked + denise_tuesday_blocked\n    all_tuesday_blocked.sort()\n    \n    # Find free slots on Tuesday\n    prev_end = work_start\n    tuesday_free = []\n    for start, end in all_tuesday_blocked:\n        if start > prev_end:\n            tuesday_free.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if work_end > prev_end:\n        tuesday_free.append((prev_end, work_end))\n    \n    # Check for a 30-minute slot in the free times\n    for start, end in tuesday_free:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_607"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define Doris's busy times in minutes since midnight\n    doris_busy = {\n        'Monday': [(9 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 11 * 60), (11 * 60 + 30, 17 * 60)]\n    }\n    \n    # Jessica prefers to avoid Monday, so prioritize Tuesday\n    days = ['Tuesday', 'Monday']\n    \n    meeting_duration = 30  # minutes\n    \n    for day in days:\n        # Get Doris's busy times for the day\n        busy_times = doris_busy.get(day, [])\n        \n        # Generate free slots for Doris\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in sorted(busy_times):\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for availability\n        for start, end in free_slots:\n            slot_duration = end - start\n            if slot_duration >= meeting_duration:\n                meeting_start = start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_608"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert schedules to minutes since midnight for easier comparison\n    emily_schedule = {\n        \"Monday\": [\n            (10 * 60 + 30, 11 * 60),    # 10:30-11:00\n            (11 * 60 + 30, 12 * 60),    # 11:30-12:00\n            (13 * 60 + 30, 14 * 60),    # 13:30-14:00\n            (14 * 60 + 30, 15 * 60),    # 14:30-15:00\n            (16 * 60, 17 * 60)          # 16:00-17:00\n        ],\n        \"Tuesday\": [\n            (9 * 60 + 30, 10 * 60),     # 9:30-10:00\n            (11 * 60, 12 * 60),         # 11:00-12:00\n            (16 * 60 + 30, 17 * 60)     # 16:30-17:00\n        ]\n    }\n    \n    zachary_schedule = {\n        \"Monday\": [\n            (9 * 60, 11 * 60),          # 9:00-11:00\n            (11 * 60 + 30, 14 * 60 + 30), # 11:30-14:30\n            (15 * 60, 17 * 60)          # 15:00-17:00\n        ],\n        \"Tuesday\": [\n            (9 * 60, 13 * 60),          # 9:00-13:00\n            (13 * 60 + 30, 14 * 60 + 30), # 13:30-14:30\n            (15 * 60, 15 * 60 + 30),    # 15:00-15:30\n            (16 * 60, 16 * 60 + 30)      # 16:00-16:30\n        ]\n    }\n    \n    # Check Monday first (Zachary's preference)\n    day = \"Monday\"\n    emily_busy = emily_schedule[day]\n    zachary_busy = zachary_schedule[day]\n    \n    # Combine and sort all busy intervals\n    all_busy = emily_busy + zachary_busy\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy intervals\n    prev_end = work_start\n    free_slots = []\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Check for a 30-minute slot\n    for start, end in free_slots:\n        if end - start >= 30:\n            # Found a suitable slot\n            meeting_start = start\n            meeting_end = meeting_start + 30\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    # If Monday doesn't work, check Tuesday (though Zachary prefers not to)\n    day = \"Tuesday\"\n    emily_busy = emily_schedule[day]\n    zachary_busy = zachary_schedule[day]\n    \n    all_busy = emily_busy + zachary_busy\n    all_busy.sort()\n    \n    prev_end = work_start\n    free_slots = []\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    for start, end in free_slots:\n        if end - start >= 30:\n            meeting_start = start\n            meeting_end = meeting_start + 30\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_609"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check (Monday is 0, Tuesday is 1)\n    days = [\"Monday\", \"Tuesday\"]\n    \n    # Patrick's busy slots in minutes since midnight\n    patrick_busy = {\n        \"Monday\": [(11 * 60, 11 * 60 + 30), (15 * 60, 16 * 60)],\n        \"Tuesday\": [(9 * 60 + 30, 10 * 60), (11 * 60, 11 * 60 + 30), (12 * 60 + 30, 13 * 60), (16 * 60, 17 * 60)]\n    }\n    \n    # Richard's busy slots in minutes since midnight\n    richard_busy = {\n        \"Monday\": [(9 * 60, 10 * 60), (11 * 60, 11 * 60 + 30), (12 * 60 + 30, 14 * 60), (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        \"Tuesday\": [(9 * 60, 9 * 60 + 30), (10 * 60, 11 * 60), (11 * 60 + 30, 13 * 60 + 30), (14 * 60, 15 * 60), (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)]\n    }\n    \n    meeting_duration = 30  # minutes\n    \n    # Patrick cannot meet on Monday, so only check Tuesday\n    day = \"Tuesday\"\n    \n    # Richard prefers not to meet after 14:00 on Tuesday, so adjust work_end\n    adjusted_work_end = 14 * 60\n    \n    # Collect all busy slots for both participants on Tuesday\n    busy_slots = patrick_busy[day] + richard_busy[day]\n    busy_slots.sort()  # Sort by start time\n    \n    # Find free slots\n    previous_end = work_start\n    free_slots = []\n    \n    for start, end in busy_slots:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the remaining time after the last busy slot\n    if previous_end < adjusted_work_end:\n        free_slots.append((previous_end, adjusted_work_end))\n    \n    # Find the first free slot that can accommodate the meeting\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_610"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday']\n    \n    # Define Ann's constraints and blocked times\n    ann_blocked = {\n        'Monday': [(13 * 60 + 30, 14 * 60 + 30)],  # 13:30-14:30\n        'Tuesday': [(9 * 60, 9 * 60 + 30), (15 * 60 + 30, 16 * 60)]  # 9:00-9:30, 15:30-16:00\n    }\n    ann_no_monday_after_11 = True\n    \n    # Define Joshua's blocked times\n    joshua_blocked = {\n        'Monday': [(10 * 60, 11 * 60), (11 * 60 + 30, 12 * 60 + 30), (14 * 60, 16 * 60)],  # 10:00-11:00, 11:30-12:30, 14:00-16:00\n        'Tuesday': [(9 * 60 + 30, 10 * 60 + 30), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 14 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)]  # 9:30-10:30, 11:30-12:00, 12:30-14:30, 15:00-15:30, 16:00-17:00\n    }\n    joshua_no_tuesday = True\n    \n    meeting_duration = 30  # minutes\n    \n    # Iterate through each day\n    for day in days:\n        if day == 'Monday' and ann_no_monday_after_11:\n            # Ann doesn't want to meet on Monday after 11:00, so adjust work_end for Monday\n            day_work_end = 11 * 60\n        else:\n            day_work_end = work_end\n        \n        if day == 'Tuesday' and joshua_no_tuesday:\n            continue  # Skip Tuesday if Joshua doesn't want to meet\n        \n        # Combine all blocked times for the day\n        blocked_times = []\n        \n        # Add Ann's blocked times\n        if day in ann_blocked:\n            blocked_times.extend(ann_blocked[day])\n        \n        # Add Joshua's blocked times\n        if day in joshua_blocked:\n            blocked_times.extend(joshua_blocked[day])\n        \n        # Sort blocked times by start time\n        blocked_times.sort()\n        \n        # Find available slots\n        available_slots = []\n        prev_end = work_start\n        \n        for start, end in blocked_times:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after last blocked time\n        if prev_end < day_work_end:\n            available_slots.append((prev_end, day_work_end))\n        \n        # Check each available slot for a meeting duration\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= meeting_duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_611"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday']\n    \n    # Define busy slots for Joshua and Diane in minutes since midnight\n    joshua_busy = {\n        'Monday': [(11 * 60 + 30, 12 * 60)],  # 11:30-12:00\n        'Tuesday': [\n            (9 * 60, 9 * 60 + 30),    # 9:00-9:30\n            (14 * 60, 14 * 60 + 30),  # 14:00-14:30\n            (16 * 60, 16 * 60 + 30)   # 16:00-16:30\n        ]\n    }\n    \n    diane_busy = {\n        'Monday': [\n            (9 * 60 + 30, 10 * 60 + 30),  # 9:30-10:30\n            (11 * 60, 14 * 60),           # 11:00-14:00\n            (15 * 60, 16 * 60 + 30)       # 15:00-16:30\n        ],\n        'Tuesday': [\n            (9 * 60, 10 * 60),            # 9:00-10:00\n            (10 * 60 + 30, 11 * 60),      # 10:30-11:00\n            (11 * 60 + 30, 12 * 60),     # 11:30-12:00\n            (13 * 60, 14 * 60 + 30),      # 13:00-14:30\n            (15 * 60 + 30, 16 * 60 + 30) # 15:30-16:30\n        ]\n    }\n    \n    # Check each day for the earliest available 30-minute slot\n    for day in days:\n        # Combine and sort all busy slots for both participants\n        busy_slots = joshua_busy.get(day, []) + diane_busy.get(day, [])\n        busy_slots.sort()\n        \n        # Merge overlapping or adjacent busy slots\n        merged_busy = []\n        for start, end in busy_slots:\n            if not merged_busy:\n                merged_busy.append((start, end))\n            else:\n                last_start, last_end = merged_busy[-1]\n                if start <= last_end:\n                    new_end = max(end, last_end)\n                    merged_busy[-1] = (last_start, new_end)\n                else:\n                    merged_busy.append((start, end))\n        \n        # Check the time before the first busy slot\n        if not merged_busy:\n            # No busy slots, the entire day is free\n            return f\"{minutes_to_time(work_start)}:{minutes_to_time(work_start + 30)}\"\n        \n        first_start, first_end = merged_busy[0]\n        if work_start < first_start:\n            available_start = work_start\n            available_end = first_start\n            if available_end - available_start >= 30:\n                return f\"{minutes_to_time(available_start)}:{minutes_to_time(available_start + 30)}\"\n        \n        # Check between busy slots\n        for i in range(1, len(merged_busy)):\n            prev_end = merged_busy[i-1][1]\n            curr_start = merged_busy[i][0]\n            if curr_start - prev_end >= 30:\n                return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + 30)}\"\n        \n        # Check after the last busy slot\n        last_start, last_end = merged_busy[-1]\n        if last_end < work_end:\n            available_start = last_end\n            available_end = work_end\n            if available_end - available_start >= 30:\n                return f\"{minutes_to_time(available_start)}:{minutes_to_time(available_start + 30)}\"\n    \n    return \"No time found\"  # Shouldn't happen as per the problem statement\n\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_612"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Define the days to check\n    days = ['Monday', 'Tuesday']\n\n    # Define schedules for each person for each day\n    schedules = {\n        'Sharon': {\n            'Monday': [(10 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60), (13 * 60, 15 * 60)],\n            'Tuesday': [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60), (14 * 60, 14 * 60 + 30), (16 * 60, 17 * 60)]\n        },\n        'Logan': {\n            'Monday': [(9 * 60, 9 * 60 + 30), (10 * 60, 12 * 60), (12 * 60 + 30, 14 * 60 + 30), (15 * 60 + 30, 17 * 60)],\n            'Tuesday': [(9 * 60, 14 * 60 + 30), (15 * 60 + 30, 17 * 60)]\n        }\n    }\n\n    # Iterate through each day\n    for day in days:\n        # Collect all busy intervals for both participants\n        busy_intervals = []\n        for person in schedules:\n            busy_intervals.extend(schedules[person][day])\n        \n        # Sort the busy intervals by start time\n        busy_intervals.sort()\n\n        # Find free intervals by checking gaps between busy intervals\n        free_intervals = []\n        prev_end = work_start\n\n        for start, end in busy_intervals:\n            if start > prev_end:\n                free_intervals.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check the interval after the last busy interval\n        if prev_end < work_end:\n            free_intervals.append((prev_end, work_end))\n\n        # Check each free interval for availability\n        for start, end in free_intervals:\n            if end - start >= meeting_duration:\n                # Convert minutes back to HH:MM format\n                start_hh = start // 60\n                start_mm = start % 60\n                end_hh = (start + meeting_duration) // 60\n                end_mm = (start + meeting_duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_613"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define the days to check\n    days = ['Monday', 'Tuesday']\n    \n    # Define blocked times for each person in minutes since midnight\n    ralph_blocked = {\n        'Monday': [\n            (9 * 60, 9 * 60 + 30),    # 9:00-9:30\n            (10 * 60 + 30, 11 * 60),   # 10:30-11:00\n            (11 * 60 + 30, 12 * 60),   # 11:30-12:00\n            (13 * 60, 13 * 60 + 30),  # 13:00-13:30\n            (14 * 60 + 30, 15 * 60),   # 14:30-15:00\n            (16 * 60, 17 * 60)         # 16:00-17:00\n        ],\n        'Tuesday': [\n            (10 * 60, 11 * 60),       # 10:00-11:00\n            (13 * 60 + 30, 15 * 60)    # 13:30-15:00\n        ]\n    }\n    \n    patricia_blocked = {\n        'Monday': [\n            (9 * 60, 11 * 60 + 30),   # 9:00-11:30\n            (12 * 60, 14 * 60),       # 12:00-14:00\n            (14 * 60 + 30, 16 * 60)   # 14:30-16:00\n        ],\n        'Tuesday': [\n            (10 * 60 + 30, 12 * 60),  # 10:30-12:00\n            (13 * 60 + 30, 15 * 60),   # 13:30-15:00\n            (16 * 60, 17 * 60)         # 16:00-17:00\n        ]\n    }\n    \n    # Function to find available slots for a person on a given day\n    def get_available_slots(blocked, day):\n        slots = []\n        blocked_times = blocked.get(day, [])\n        blocked_times.sort()  # Ensure blocked times are in order\n        \n        prev_end = work_start\n        for start, end in blocked_times:\n            if start > prev_end:\n                slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            slots.append((prev_end, work_end))\n        return slots\n    \n    # Check each day for overlapping available slots\n    for day in days:\n        ralph_slots = get_available_slots(ralph_blocked, day)\n        patricia_slots = get_available_slots(patricia_blocked, day)\n        \n        # Find overlapping slots between Ralph and Patricia\n        for r_start, r_end in ralph_slots:\n            for p_start, p_end in patricia_slots:\n                overlap_start = max(r_start, p_start)\n                overlap_end = min(r_end, p_end)\n                if overlap_end - overlap_start >= 30:  # Meeting duration is 30 minutes\n                    # Convert minutes back to HH:MM format\n                    start_hh = overlap_start // 60\n                    start_mm = overlap_start % 60\n                    end_hh = (overlap_start + 30) // 60\n                    end_mm = (overlap_start + 30) % 60\n                    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_614"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define blocked times for Raymond and Gerald on Monday and Tuesday\n    # Format: (day, start, end) where day is 0 for Monday, 1 for Tuesday\n    raymond_blocked = [\n        (0, 9 * 60, 10 * 60),    # Monday 9:00-10:00\n        (0, 12 * 60, 12 * 60 + 30),  # Monday 12:00-12:30\n        (0, 13 * 60 + 30, 14 * 60 + 30),  # Monday 13:30-14:30\n        (0, 16 * 60, 16 * 60 + 30),  # Monday 16:00-16:30\n        (1, 9 * 60, 10 * 60 + 30),  # Tuesday 9:00-10:30\n        (1, 13 * 60 + 30, 14 * 60 + 30),  # Tuesday 13:30-14:30\n        (1, 16 * 60, 16 * 60 + 30),  # Tuesday 16:00-16:30\n    ]\n    \n    gerald_blocked = [\n        (0, 9 * 60, 10 * 60 + 30),  # Monday 9:00-10:30\n        (0, 11 * 60, 14 * 60),      # Monday 11:00-14:00\n        (0, 14 * 60 + 30, 15 * 60), # Monday 14:30-15:00\n        (0, 15 * 60 + 30, 17 * 60), # Monday 15:30-17:00\n        (1, 9 * 60, 10 * 60 + 30), # Tuesday 9:00-10:30\n        (1, 11 * 60, 13 * 60),     # Tuesday 11:00-13:00\n        (1, 13 * 60 + 30, 14 * 60 + 30),  # Tuesday 13:30-14:30\n        (1, 15 * 60, 17 * 60),      # Tuesday 15:00-17:00\n    ]\n\n    # Prefer Monday (day 0) over Tuesday (day 1) due to Raymond's preference\n    days_to_check = [0, 1]\n\n    for day in days_to_check:\n        # Generate all possible slots for the day\n        slots = []\n        current_time = work_start\n        while current_time + meeting_duration <= work_end:\n            slots.append((current_time, current_time + meeting_duration))\n            current_time += 1  # Check every minute for availability\n\n        # Check each slot for availability\n        for slot_start, slot_end in slots:\n            # Check Raymond's availability\n            raymond_available = True\n            for blocked_day, blocked_start, blocked_end in raymond_blocked:\n                if blocked_day == day and not (slot_end <= blocked_start or slot_start >= blocked_end):\n                    raymond_available = False\n                    break\n            \n            if not raymond_available:\n                continue\n\n            # Check Gerald's availability\n            gerald_available = True\n            for blocked_day, blocked_start, blocked_end in gerald_blocked:\n                if blocked_day == day and not (slot_end <= blocked_start or slot_start >= blocked_end):\n                    gerald_available = False\n                    break\n            \n            if gerald_available:\n                # Convert minutes back to HH:MM format\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_hh = slot_end // 60\n                end_mm = slot_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No available time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_615"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to check (Monday=0, Tuesday=1)\n    days = [0, 1]  # Monday and Tuesday\n    \n    # Define busy slots for Emily and Sandra in minutes since midnight\n    # Format: {day: [(start1, end1), (start2, end2), ...]}\n    emily_busy = {\n        0: [(12 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60), (16 * 60 + 30, 17 * 60)],\n        1: [(9 * 60 + 30, 10 * 60), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60 + 30), (15 * 60 + 30, 16 * 60)]\n    }\n    \n    sandra_busy = {\n        0: [(9 * 60, 11 * 60), (11 * 60 + 30, 17 * 60)],\n        1: [(9 * 60 + 30, 10 * 60 + 30), (11 * 60, 13 * 60), (13 * 60 + 30, 14 * 60), (15 * 60, 16 * 60)]\n    }\n    \n    meeting_duration = 30  # minutes\n    \n    # Prefer Monday (day 0) over Tuesday (day 1) due to Emily's preference\n    for day in sorted(days):\n        # Get all busy slots for both participants on this day\n        combined_busy = emily_busy.get(day, []) + sandra_busy.get(day, [])\n        combined_busy.sort()\n        \n        # Find free slots by checking gaps between busy slots and work hours\n        prev_end = work_start\n        free_slots = []\n        \n        for start, end in combined_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy slot\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            available_start = slot_start\n            available_end = slot_end\n            \n            if available_end - available_start >= meeting_duration:\n                # Found a suitable slot\n                meeting_start = available_start\n                meeting_end = meeting_start + meeting_duration\n                \n                # Convert back to HH:MM format\n                def format_time(minutes):\n                    hours = minutes // 60\n                    mins = minutes % 60\n                    return f\"{hours:02d}:{mins:02d}\"\n                \n                return f\"{format_time(meeting_start)}:{format_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_616"
        },
        {
            "final_program_time": "{15:00:16:00}",
            "expected_time": "{15:00:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Define blocked times for each participant on each day in minutes since midnight\n    stephen_blocked = {\n        'Monday': [(12 * 60 + 30, 13 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n        'Tuesday': [(11 * 60, 11 * 60 + 30), (13 * 60 + 30, 14 * 60), (16 * 60, 16 * 60 + 30)]\n    }\n    robert_blocked = {\n        'Monday': [(9 * 60, 10 * 60 + 30), (11 * 60, 12 * 60), (12 * 60 + 30, 15 * 60), (16 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60, 11 * 60 + 30), (12 * 60, 13 * 60 + 30), (14 * 60, 15 * 60 + 30)]\n    }\n\n    days = ['Monday', 'Tuesday']\n\n    for day in days:\n        # Collect all blocked times for both participants on this day\n        all_blocked = stephen_blocked.get(day, []) + robert_blocked.get(day, [])\n        all_blocked.sort()\n\n        # Merge overlapping or adjacent blocked times\n        merged_blocked = []\n        for start, end in all_blocked:\n            if not merged_blocked:\n                merged_blocked.append((start, end))\n            else:\n                last_start, last_end = merged_blocked[-1]\n                if start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged_blocked[-1] = (new_start, new_end)\n                else:\n                    merged_blocked.append((start, end))\n\n        # Check the available slots\n        prev_end = work_start\n        for start, end in merged_blocked:\n            if start - prev_end >= meeting_duration:\n                # Found a suitable slot\n                meeting_start = prev_end\n                meeting_end = meeting_start + meeting_duration\n                # Convert back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n            prev_end = max(prev_end, end)\n\n        # Check after the last blocked time\n        if work_end - prev_end >= meeting_duration:\n            meeting_start = prev_end\n            meeting_end = meeting_start + meeting_duration\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_617"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check (Monday and Tuesday)\n    days = ['Monday', 'Tuesday']\n    \n    # Define participants' schedules and constraints\n    maria_constraints = {\n        'Monday': {'unavailable_after': 15 * 60},  # 15:00 in minutes\n        'Tuesday': {}\n    }\n    \n    danielle_schedule = {\n        'Monday': [\n            (9 * 60 + 30, 10 * 60),    # 9:30-10:00\n            (11 * 60, 12 * 60),         # 11:00-12:00\n            (13 * 60, 13 * 60 + 30),    # 13:00-13:30\n            (14 * 60 + 30, 15 * 60),    # 14:30-15:00\n            (15 * 60 + 30, 16 * 60),    # 15:30-16:00\n            (16 * 60 + 30, 17 * 60)     # 16:30-17:00\n        ],\n        'Tuesday': [\n            (9 * 60, 11 * 60),          # 9:00-11:00\n            (11 * 60 + 30, 17 * 60)     # 11:30-17:00\n        ]\n    }\n    \n    meeting_duration = 30  # minutes\n    \n    # Check Monday first (since Danielle prefers to avoid Tuesday)\n    day = 'Monday'\n    \n    # Get Danielle's busy times on Monday\n    danielle_busy = danielle_schedule[day]\n    \n    # Generate available slots for Danielle on Monday\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in sorted(danielle_busy):\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Filter slots based on Maria's constraints (unavailable after 15:00 on Monday)\n    maria_unavailable_after = maria_constraints[day].get('unavailable_after', work_end)\n    filtered_slots = []\n    \n    for start, end in available_slots:\n        if start >= maria_unavailable_after:\n            continue\n        new_end = min(end, maria_unavailable_after)\n        if new_end - start >= meeting_duration:\n            filtered_slots.append((start, new_end))\n    \n    # Find the first suitable slot\n    for start, end in filtered_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    # If no slot on Monday, check Tuesday (though Danielle prefers to avoid)\n    day = 'Tuesday'\n    \n    # Get Danielle's busy times on Tuesday\n    danielle_busy = danielle_schedule[day]\n    \n    # Generate available slots for Danielle on Tuesday\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in sorted(danielle_busy):\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # No constraints for Maria on Tuesday\n    # Find the first suitable slot\n    for start, end in available_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_618"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check (Monday and Tuesday)\n    days = ['Monday', 'Tuesday']\n    \n    # Define busy times for Sarah and Terry in minutes since midnight\n    sarah_busy = {\n        'Monday': [(9*60, 10*60), (11.5*60, 12*60), (14.5*60, 15.5*60)],\n        'Tuesday': [(9*60, 9.5*60), (11.5*60, 12*60), (15*60, 15.5*60)]\n    }\n    \n    terry_busy = {\n        'Monday': [(10*60, 10.5*60), (11.5*60, 14*60), (16*60, 17*60)],\n        'Tuesday': [(9*60, 9.5*60), (10*60, 12.5*60), (13*60, 17*60)]\n    }\n    \n    # Duration of the meeting in minutes\n    duration = 30\n    \n    # Sarah prefers to avoid Monday, so check Tuesday first\n    preferred_day_order = ['Tuesday', 'Monday']\n    \n    for day in preferred_day_order:\n        # Collect all busy intervals for the day\n        busy_intervals = sarah_busy[day] + terry_busy[day]\n        busy_intervals.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in busy_intervals:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= duration:\n                # Found a suitable slot\n                meeting_start = slot_start\n                meeting_end = meeting_start + duration\n                \n                # Convert back to HH:MM format\n                def minutes_to_time(minutes):\n                    hours = int(minutes // 60)\n                    mins = int(minutes % 60)\n                    return f\"{hours:02d}:{mins:02d}\"\n                \n                start_time = minutes_to_time(meeting_start)\n                end_time = minutes_to_time(meeting_end)\n                return f\"{start_time}:{end_time}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_619"
        },
        {
            "final_program_time": "{12:30:13:30}",
            "expected_time": "{12:30:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to consider (Monday is 0, Tuesday is 1)\n    days = [0]  # Only Monday, as Maria doesn't want Tuesday\n    \n    # Christopher's blocked times on Monday (in minutes since midnight)\n    christopher_blocked = [\n        (16 * 60, 16 * 60 + 30)  # Monday 16:00-16:30\n    ]\n    \n    # Maria's meetings on Monday (in minutes since midnight)\n    maria_meetings = [\n        (9 * 60, 9 * 60 + 30),    # 9:00-9:30\n        (10 * 60, 10 * 60 + 30),   # 10:00-10:30\n        (11 * 60, 11 * 60 + 30),   # 11:00-11:30\n        (12 * 60, 12 * 60 + 30),   # 12:00-12:30\n        (14 * 60, 14 * 60 + 30),   # 14:00-14:30\n        (15 * 60, 15 * 60 + 30),   # 15:00-15:30\n        (16 * 60 + 30, 17 * 60)    # 16:30-17:00\n    ]\n    \n    # Combine all busy times for Monday (Christopher and Maria)\n    busy_times = christopher_blocked + maria_meetings\n    busy_times.sort()  # Sort by start time\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in busy_times:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    # Check the slot after the last meeting\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit a 1-hour meeting\n    meeting_duration = 60\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert minutes back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available slot found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_620"
        },
        {
            "final_program_time": "{11:00:12:00}",
            "expected_time": "{11:00:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define days to check\n    days = ['Monday', 'Tuesday']\n\n    # Define busy slots for Harold and Bobby in minutes since midnight\n    harold_busy = {\n        'Monday': [(10 * 60 + 30, 11 * 60), (13 * 60 + 30, 14 * 60), (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60 + 30, 10 * 60), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60), (14 * 60, 15 * 60 + 30)]\n    }\n    bobby_busy = {\n        'Monday': [(9 * 60 + 30, 11 * 60), (12 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30), (15 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60 + 30, 10 * 60), (12 * 60 + 30, 13 * 60), (14 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)]\n    }\n\n    meeting_duration = 60  # 1 hour in minutes\n\n    for day in days:\n        # Combine and sort all busy slots for both participants\n        all_busy = harold_busy[day] + bobby_busy[day]\n        all_busy.sort()\n\n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n\n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n\n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            available_start = slot_start\n            available_end = slot_end\n\n            if available_end - available_start >= meeting_duration:\n                # Convert back to HH:MM format\n                start_hh = available_start // 60\n                start_mm = available_start % 60\n                end_hh = (available_start + meeting_duration) // 60\n                end_mm = (available_start + meeting_duration) % 60\n\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_621"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{10:00:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday']\n    \n    # Define busy intervals for each person in minutes since midnight\n    alexander_busy = {\n        'Monday': [(9 * 60 + 30, 10 * 60), (11 * 60 + 30, 12 * 60), (16 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60, 9 * 60 + 30), (11 * 60, 12 * 60), (14 * 60 + 30, 15 * 60), (16 * 60 + 30, 17 * 60)]\n    }\n    \n    marilyn_busy = {\n        'Monday': [(9 * 60, 10 * 60), (11 * 60, 12 * 60), (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60, 9 * 60 + 30), (10 * 60, 13 * 60 + 30), (14 * 60, 15 * 60), (15 * 60 + 30, 17 * 60)]\n    }\n    \n    meeting_duration = 60  # 1 hour in minutes\n    \n    for day in days:\n        # Collect all busy intervals for the day\n        busy_intervals = []\n        busy_intervals.extend(alexander_busy.get(day, []))\n        busy_intervals.extend(marilyn_busy.get(day, []))\n        \n        # Sort intervals by start time\n        busy_intervals.sort()\n        \n        # Find free slots\n        previous_end = work_start\n        free_slots = []\n        \n        for start, end in busy_intervals:\n            if start > previous_end:\n                free_slots.append((previous_end, start))\n            previous_end = max(previous_end, end)\n        \n        # Check after last busy interval\n        if previous_end < work_end:\n            free_slots.append((previous_end, work_end))\n        \n        # Check for a suitable slot\n        for start, end in free_slots:\n            if end - start >= meeting_duration:\n                meeting_start = start\n                meeting_end = meeting_start + meeting_duration\n                # Convert back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_622"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Melissa's busy times in minutes since midnight for Monday and Tuesday\n    melissa_busy = {\n        'Monday': [\n            (9 * 60, 9 * 60 + 30),    # 9:00-9:30\n            (12 * 60, 12 * 60 + 30),   # 12:00-12:30\n            (14 * 60, 14 * 60 + 30),   # 14:00-14:30\n            (16 * 60, 16 * 60 + 30),   # 16:00-16:30\n        ],\n        'Tuesday': [\n            (9 * 60, 9 * 60 + 30),    # 9:00-9:30\n            (10 * 60, 10 * 60 + 30),   # 10:00-10:30\n            (11 * 60, 11 * 60 + 30),   # 11:00-11:30\n            (12 * 60 + 30, 14 * 60 + 30),  # 12:30-14:30\n            (15 * 60 + 30, 16 * 60),   # 15:30-16:00\n        ]\n    }\n\n    # James's busy times in minutes since midnight for Monday and Tuesday\n    james_busy = {\n        'Monday': [\n            (9 * 60 + 30, 11 * 60 + 30),  # 9:30-11:30\n            (12 * 60, 14 * 60),           # 12:00-14:00\n            (14 * 60 + 30, 15 * 60 + 30), # 14:30-15:30\n            (16 * 60, 16 * 60 + 30),      # 16:00-16:30\n        ],\n        'Tuesday': [\n            (9 * 60 + 30, 10 * 60),       # 9:30-10:00\n            (10 * 60 + 30, 13 * 60),      # 10:30-13:00\n            (13 * 60 + 30, 17 * 60),     # 13:30-17:00\n        ]\n    }\n\n    days = ['Monday', 'Tuesday']\n\n    for day in days:\n        # Collect all busy intervals for both participants on the current day\n        busy_intervals = melissa_busy.get(day, []) + james_busy.get(day, [])\n        busy_intervals.sort()\n\n        # Merge overlapping or adjacent intervals\n        merged = []\n        for start, end in busy_intervals:\n            if not merged:\n                merged.append((start, end))\n            else:\n                last_start, last_end = merged[-1]\n                if start <= last_end:\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged[-1] = (new_start, new_end)\n                else:\n                    merged.append((start, end))\n\n        # Check the time before the first busy interval\n        if len(merged) > 0:\n            first_start, first_end = merged[0]\n            if first_start - work_start >= meeting_duration:\n                meeting_start = work_start\n                meeting_end = meeting_start + meeting_duration\n                # Check Melissa's preference for Monday after 16:30\n                if day == 'Monday' and meeting_start >= 16 * 60 + 30:\n                    continue\n                return f\"{day}: {meeting_start//60:02d}:{meeting_start%60:02d}-{meeting_end//60:02d}:{meeting_end%60:02d}\"\n\n        # Check the time between busy intervals\n        for i in range(len(merged) - 1):\n            current_end = merged[i][1]\n            next_start = merged[i + 1][0]\n            if next_start - current_end >= meeting_duration:\n                meeting_start = current_end\n                meeting_end = meeting_start + meeting_duration\n                # Check Melissa's preference for Monday after 16:30\n                if day == 'Monday' and meeting_start >= 16 * 60 + 30:\n                    continue\n                return f\"{day}: {meeting_start//60:02d}:{meeting_start%60:02d}-{meeting_end//60:02d}:{meeting_end%60:02d}\"\n\n        # Check the time after the last busy interval\n        if len(merged) > 0:\n            last_start, last_end = merged[-1]\n            if work_end - last_end >= meeting_duration:\n                meeting_start = last_end\n                meeting_end = meeting_start + meeting_duration\n                # Check Melissa's preference for Monday after 16:30\n                if day == 'Monday' and meeting_start >= 16 * 60 + 30:\n                    continue\n                return f\"{day}: {meeting_start//60:02d}:{meeting_start%60:02d}-{meeting_end//60:02d}:{meeting_end%60:02d}\"\n        else:\n            # No busy intervals, any time works\n            meeting_start = work_start\n            meeting_end = meeting_start + meeting_duration\n            # Check Melissa's preference for Monday after 16:30\n            if day == 'Monday' and meeting_start >= 16 * 60 + 30:\n                continue\n            return f\"{day}: {meeting_start//60:02d}:{meeting_start%60:02d}-{meeting_end//60:02d}:{meeting_end%60:02d}\"\n\n    return \"No suitable time found.\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_623"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to consider\n    days = ['Monday', 'Tuesday']\n\n    # Define busy slots for James and Frank in minutes since midnight\n    james_busy = {\n        'Monday': [\n            (9 * 60, 9 * 60 + 30),    # 9:00-9:30\n            (11 * 60 + 30, 12 * 60),   # 11:30-12:00\n            (14 * 60, 14 * 60 + 30),   # 14:00-14:30\n            (15 * 60 + 30, 16 * 60),   # 15:30-16:00\n            (16 * 60 + 30, 17 * 60)   # 16:30-17:00\n        ],\n        'Tuesday': [\n            (11 * 60 + 30, 12 * 60),  # 11:30-12:00\n            (14 * 60, 14 * 60 + 30),   # 14:00-14:30\n            (16 * 60, 16 * 60 + 30)    # 16:00-16:30\n        ]\n    }\n\n    frank_busy = {\n        'Monday': [\n            (9 * 60, 9 * 60 + 30),     # 9:00-9:30\n            (10 * 60, 17 * 60)         # 10:00-17:00\n        ],\n        'Tuesday': [\n            (9 * 60 + 30, 10 * 60 + 30),  # 9:30-10:30\n            (11 * 60 + 30, 12 * 60 + 30), # 11:30-12:30\n            (13 * 60 + 30, 14 * 60 + 30), # 13:30-14:30\n            (15 * 60, 15 * 60 + 30),      # 15:00-15:30\n            (16 * 60, 17 * 60)            # 16:00-17:00\n        ]\n    }\n\n    # Frank prefers not to meet on Tuesday, so prioritize Monday\n    preferred_days = ['Monday', 'Tuesday']\n\n    for day in preferred_days:\n        # Collect all busy slots for the day\n        busy_slots = james_busy.get(day, []) + frank_busy.get(day, [])\n        busy_slots.sort()\n\n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n\n        for start, end in busy_slots:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n\n        # Check each free slot for availability\n        for start, end in free_slots:\n            slot_duration = end - start\n            if slot_duration >= meeting_duration:\n                meeting_start = start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_624"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Harold's blocked times in minutes since midnight for Monday and Tuesday\n    harold_blocked = {\n        'Monday': [(9 * 60, 10 * 60), (10 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 11 * 60 + 30),\n                    (12 * 60 + 30, 13 * 60 + 30), (14 * 60 + 30, 15 * 60 + 30),\n                    (16 * 60, 17 * 60)]\n    }\n\n    # Harold's preferences\n    avoid_monday = True\n    avoid_tuesday_before_1430 = True\n\n    # Check Tuesday first (since Harold prefers to avoid Monday)\n    day = 'Tuesday'\n    available_slots = []\n\n    # Generate all possible 30-minute slots on Tuesday within work hours\n    for start in range(work_start, work_end - meeting_duration + 1, 15):  # check every 15 minutes\n        end = start + meeting_duration\n        slot_ok = True\n\n        # Check if slot is in Harold's blocked times\n        for block_start, block_end in harold_blocked[day]:\n            if not (end <= block_start or start >= block_end):\n                slot_ok = False\n                break\n\n        # Check Harold's preference to avoid before 14:30\n        if avoid_tuesday_before_1430 and end <= 14 * 60 + 30:\n            slot_ok = False\n\n        if slot_ok:\n            available_slots.append((start, end))\n\n    # If no slots on Tuesday, check Monday (even though Harold prefers to avoid)\n    if not available_slots:\n        day = 'Monday'\n        for start in range(work_start, work_end - meeting_duration + 1, 15):\n            end = start + meeting_duration\n            slot_ok = True\n\n            for block_start, block_end in harold_blocked[day]:\n                if not (end <= block_start or start >= block_end):\n                    slot_ok = False\n                    break\n\n            if slot_ok:\n                available_slots.append((start, end))\n\n    # Select the first available slot\n    if available_slots:\n        start, end = available_slots[0]\n        # Convert minutes back to HH:MM format\n        start_hh = start // 60\n        start_mm = start % 60\n        end_hh = end // 60\n        end_mm = end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_625"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define the days to check\n    days = ['Monday', 'Tuesday']\n    \n    # Define participants' schedules as lists of busy intervals in minutes since midnight\n    patricia_schedule = {\n        'Monday': [\n            (10 * 60, 10 * 60 + 30),    # 10:00-10:30\n            (11 * 60 + 30, 12 * 60),     # 11:30-12:00\n            (13 * 60, 13 * 60 + 30),     # 13:00-13:30\n            (14 * 60 + 30, 15 * 60 + 30), # 14:30-15:30\n            (16 * 60, 16 * 60 + 30),     # 16:00-16:30\n        ],\n        'Tuesday': [\n            (10 * 60, 10 * 60 + 30),     # 10:00-10:30\n            (11 * 60, 12 * 60),          # 11:00-12:00\n            (14 * 60, 16 * 60),          # 14:00-16:00\n            (16 * 60 + 30, 17 * 60),     # 16:30-17:00\n        ]\n    }\n    \n    jesse_schedule = {\n        'Monday': [\n            (9 * 60, 17 * 60)            # 9:00-17:00 (entire day blocked)\n        ],\n        'Tuesday': [\n            (11 * 60, 11 * 60 + 30),     # 11:00-11:30\n            (12 * 60, 12 * 60 + 30),     # 12:00-12:30\n            (13 * 60, 14 * 60),          # 13:00-14:00\n            (14 * 60 + 30, 15 * 60),     # 14:30-15:00\n            (15 * 60 + 30, 17 * 60),     # 15:30-17:00\n        ]\n    }\n    \n    # Meeting duration in minutes\n    meeting_duration = 60\n    \n    # Iterate through each day to find a suitable time\n    for day in days:\n        # Combine and sort all busy intervals for both participants\n        busy_intervals = patricia_schedule.get(day, []) + jesse_schedule.get(day, [])\n        busy_intervals.sort()\n        \n        # Find free slots by checking gaps between busy intervals\n        previous_end = work_start\n        free_slots = []\n        \n        for start, end in busy_intervals:\n            if start > previous_end:\n                free_slots.append((previous_end, start))\n            previous_end = max(previous_end, end)\n        \n        # Check the slot after the last busy interval\n        if previous_end < work_end:\n            free_slots.append((previous_end, work_end))\n        \n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            available_start = slot_start\n            available_end = slot_end\n            \n            if available_end - available_start >= meeting_duration:\n                # Convert start time back to HH:MM format\n                start_hh = available_start // 60\n                start_mm = available_start % 60\n                end_time = available_start + meeting_duration\n                end_hh = end_time // 60\n                end_mm = end_time % 60\n                \n                # Format the output as HH:MM:HH:MM\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_626"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Define days to check\n    days = ['Monday', 'Tuesday']\n\n    # Define participants' schedules in minutes since midnight\n    schedules = {\n        'Shirley': {\n            'Monday': [\n                (10 * 60 + 30, 12 * 60),    # 10:30-12:00\n                (14 * 60 + 30, 16 * 60)      # 14:30-16:00\n            ],\n            'Tuesday': [\n                (9 * 60 + 30, 10 * 60 + 30),  # 9:30-10:30\n                (11 * 60 + 30, 12 * 60),      # 11:30-12:00\n                (13 * 60 + 30, 14 * 60),      # 13:30-14:00\n                (14 * 60 + 30, 15 * 60),      # 14:30-15:00\n                (16 * 60, 16 * 60 + 30)      # 16:00-16:30\n            ]\n        },\n        'Adam': {\n            'Monday': [\n                (9 * 60 + 30, 11 * 60 + 30),  # 9:30-11:30\n                (14 * 60, 16 * 60),           # 14:00-16:00\n                (16 * 60 + 30, 17 * 60)        # 16:30-17:00\n            ],\n            'Tuesday': [\n                (9 * 60, 9 * 60 + 30),        # 9:00-9:30\n                (10 * 60, 12 * 60),            # 10:00-12:00\n                (12 * 60 + 30, 13 * 60),       # 12:30-13:00\n                (14 * 60, 16 * 60 + 30)        # 14:00-16:30\n            ]\n        }\n    }\n\n    # Adam cannot meet on Monday after 10:00, so add that constraint\n    adam_monday_constraint = (10 * 60, 24 * 60)  # After 10:00 on Monday\n\n    meeting_duration = 30  # minutes\n\n    for day in days:\n        # Collect all busy intervals for the day\n        busy_intervals = []\n        \n        # Add Shirley's busy intervals\n        for interval in schedules['Shirley'][day]:\n            busy_intervals.append(interval)\n        \n        # Add Adam's busy intervals\n        for interval in schedules['Adam'][day]:\n            busy_intervals.append(interval)\n        \n        # Add Adam's Monday constraint if applicable\n        if day == 'Monday':\n            busy_intervals.append(adam_monday_constraint)\n        \n        # Sort intervals by start time\n        busy_intervals.sort()\n        \n        # Find free slots by checking gaps between busy intervals\n        prev_end = work_start\n        for start, end in busy_intervals:\n            if start > prev_end:\n                # Found a free slot\n                free_start = prev_end\n                free_end = start\n                if free_end - free_start >= meeting_duration:\n                    # Convert back to HH:MM format\n                    start_hh = free_start // 60\n                    start_mm = free_start % 60\n                    end_hh = (free_start + meeting_duration) // 60\n                    end_mm = (free_start + meeting_duration) % 60\n                    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy interval\n        if work_end - prev_end >= meeting_duration:\n            start_hh = prev_end // 60\n            start_mm = prev_end % 60\n            end_hh = (prev_end + meeting_duration) // 60\n            end_mm = (prev_end + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_627"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday']\n    \n    # Define busy times for each person in minutes since midnight\n    samantha_busy = {\n        'Tuesday': [\n            (12 * 60, 12 * 60 + 30),  # 12:00-12:30\n            (16 * 60, 16 * 60 + 30)    # 16:00-16:30\n        ]\n    }\n    \n    joyce_busy = {\n        'Monday': [\n            (10 * 60, 11 * 60),       # 10:00-11:00\n            (11 * 60 + 30, 12 * 60 + 30),  # 11:30-12:30\n            (13 * 60, 16 * 60),        # 13:00-16:00\n            (16 * 60 + 30, 17 * 60)    # 16:30-17:00\n        ],\n        'Tuesday': [\n            (9 * 60, 11 * 60),         # 9:00-11:00\n            (11 * 60 + 30, 17 * 60)     # 11:30-17:00\n        ]\n    }\n    \n    # Check each day for available slots\n    for day in days:\n        # Collect all busy intervals for the day\n        busy_intervals = []\n        \n        # Add Samantha's busy times\n        if day in samantha_busy:\n            busy_intervals.extend(samantha_busy[day])\n        \n        # Add Joyce's busy times\n        if day in joyce_busy:\n            busy_intervals.extend(joyce_busy[day])\n        \n        # Sort busy intervals by start time\n        busy_intervals.sort()\n        \n        # Find available slots\n        prev_end = work_start\n        available_slots = []\n        \n        for start, end in busy_intervals:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy interval\n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n        \n        # Check for a 1-hour slot\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= 60:\n                # Found a suitable slot\n                meeting_start = slot_start\n                meeting_end = meeting_start + 60\n                \n                # Convert back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                \n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_628"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Margaret's constraints (in minutes, converted from HH:MM)\n    margaret_unavailable = {\n        \"Monday\": [\n            (10 * 60 + 30, 11 * 60),     # 10:30-11:00\n            (11 * 60 + 30, 12 * 60),     # 11:30-12:00\n            (13 * 60, 13 * 60 + 30),     # 13:00-13:30\n            (15 * 60, 17 * 60),          # 15:00-17:00\n        ],\n        \"Tuesday\": [\n            (12 * 60, 12 * 60 + 30),     # 12:00-12:30\n        ]\n    }\n    \n    # Alexis's constraints (in minutes, converted from HH:MM)\n    alexis_unavailable = {\n        \"Monday\": [\n            (9 * 60 + 30, 11 * 60 + 30),  # 9:30-11:30\n            (12 * 60 + 30, 13 * 60),       # 12:30-13:00\n            (14 * 60, 17 * 60),            # 14:00-17:00\n        ],\n        \"Tuesday\": [\n            (9 * 60, 9 * 60 + 30),         # 9:00-9:30\n            (10 * 60, 10 * 60 + 30),        # 10:00-10:30\n            (14 * 60, 16 * 60 + 30),       # 14:00-16:30\n        ]\n    }\n    \n    # Margaret's preferences: not Monday, and Tuesday before 14:30\n    preferred_day = \"Tuesday\"\n    margaret_preferred_time = (work_start, 14 * 60 + 30)  # 9:00 to 14:30 on Tuesday\n    \n    # Check Tuesday first (preferred day)\n    day = preferred_day\n    # Generate all possible 30-minute slots within work hours on Tuesday\n    slots = []\n    current_time = work_start\n    while current_time + 30 <= work_end:\n        slots.append((current_time, current_time + 30))\n        current_time += 30\n    \n    # Filter slots based on Margaret's preferences (Tuesday before 14:30)\n    slots = [slot for slot in slots if slot[1] <= margaret_preferred_time[1]]\n    \n    # Check each slot for availability\n    for slot in slots:\n        start, end = slot\n        # Check Margaret's availability\n        margaret_available = True\n        for busy_start, busy_end in margaret_unavailable.get(day, []):\n            if not (end <= busy_start or start >= busy_end):\n                margaret_available = False\n                break\n        if not margaret_available:\n            continue\n        \n        # Check Alexis's availability\n        alexis_available = True\n        for busy_start, busy_end in alexis_unavailable.get(day, []):\n            if not (end <= busy_start or start >= busy_end):\n                alexis_available = False\n                break\n        if not alexis_available:\n            continue\n        \n        # If both are available, return this slot\n        return f\"{start//60:02d}:{start%60:02d}:{end//60:02d}:{end%60:02d}\"\n    \n    # If no slot found on Tuesday (though problem states a solution exists), check Monday\n    day = \"Monday\"\n    slots = []\n    current_time = work_start\n    while current_time + 30 <= work_end:\n        slots.append((current_time, current_time + 30))\n        current_time += 30\n    \n    for slot in slots:\n        start, end = slot\n        # Check Margaret's availability\n        margaret_available = True\n        for busy_start, busy_end in margaret_unavailable.get(day, []):\n            if not (end <= busy_start or start >= busy_end):\n                margaret_available = False\n                break\n        if not margaret_available:\n            continue\n        \n        # Check Alexis's availability\n        alexis_available = True\n        for busy_start, busy_end in alexis_unavailable.get(day, []):\n            if not (end <= busy_start or start >= busy_end):\n                alexis_available = False\n                break\n        if not alexis_available:\n            continue\n        \n        # If both are available, return this slot\n        return f\"{start//60:02d}:{start%60:02d}:{end//60:02d}:{end%60:02d}\"\n    \n    return \"No time found\"  # Should not reach here per problem statement\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_629"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Charles's constraints: Not on Monday, not after 15:30 on Tuesday\n    # Since Charles has no meetings, we only need to consider his day and time constraints\n    \n    # Cheryl's blocked times on Tuesday (in minutes since midnight)\n    cheryl_blocked_tuesday = [\n        (9 * 60 + 30, 10 * 60),    # 9:30-10:00\n        (10 * 60 + 30, 11 * 60),    # 10:30-11:00\n        (11 * 60 + 30, 13 * 60),    # 11:30-13:00\n        (13 * 60 + 30, 14 * 60),    # 13:30-14:00\n        (15 * 60, 15 * 60 + 30),    # 15:00-15:30\n        (16 * 60, 17 * 60)          # 16:00-17:00\n    ]\n    \n    # Meeting duration in minutes\n    meeting_duration = 30\n    \n    # Iterate through possible times on Tuesday (since Charles doesn't want Monday)\n    # Check available slots between Cheryl's blocked times\n    for i in range(len(cheryl_blocked_tuesday) + 1):\n        if i == 0:\n            start = work_start\n            end = cheryl_blocked_tuesday[i][0]\n        elif i == len(cheryl_blocked_tuesday):\n            start = cheryl_blocked_tuesday[i-1][1]\n            end = work_end\n        else:\n            start = cheryl_blocked_tuesday[i-1][1]\n            end = cheryl_blocked_tuesday[i][0]\n        \n        # Check if the slot is long enough and before Charles's cutoff (15:30)\n        if (end - start) >= meeting_duration and start + meeting_duration <= 15 * 60 + 30:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    # If no slot found (though the problem states there is one)\n    return \"No time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_630"
        },
        {
            "final_program_time": "{15:00:16:00}",
            "expected_time": "{15:00:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday']\n    \n    # Define Eric's busy times in minutes since midnight for each day\n    eric_busy = {\n        'Monday': [\n            (9 * 60, 12 * 60 + 30),  # 9:00-12:30\n            (13 * 60, 15 * 60),       # 13:00-15:00\n            (16 * 60, 17 * 60)        # 16:00-17:00\n        ],\n        'Tuesday': [\n            (9 * 60 + 30, 11 * 60 + 30),  # 9:30-11:30\n            (12 * 60, 13 * 60),           # 12:00-13:00\n            (13 * 60 + 30, 14 * 60),       # 13:30-14:00\n            (14 * 60 + 30, 16 * 60 + 30)    # 14:30-16:30\n        ]\n    }\n    \n    # Judith is free all day, so only Eric's schedule matters\n    meeting_duration = 60  # 1 hour\n    \n    for day in days:\n        # Start checking from work_start\n        current_time = work_start\n        \n        # Get Eric's busy slots for the day\n        busy_slots = eric_busy.get(day, [])\n        \n        # Iterate through busy slots to find gaps\n        for start, end in busy_slots:\n            if current_time < start:\n                # Check if there's enough time before the next busy slot\n                if start - current_time >= meeting_duration:\n                    # Found a suitable time\n                    return f\"{int(current_time // 60):02d}:{int(current_time % 60):02d}:{int((current_time + meeting_duration) // 60):02d}:{int((current_time + meeting_duration) % 60):02d}\"\n            # Update current_time to the end of this busy slot\n            current_time = max(current_time, end)\n        \n        # Check after the last busy slot\n        if current_time + meeting_duration <= work_end:\n            return f\"{int(current_time // 60):02d}:{int(current_time % 60):02d}:{int((current_time + meeting_duration) // 60):02d}:{int((current_time + meeting_duration) % 60):02d}\"\n    \n    # If no time found (though the problem states there is one)\n    return \"No time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_631"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Alexis's constraints\n    alexis_monday_unavailable = [\n        (9 * 60, 10 * 60),    # 9:00-10:00\n        (12 * 60, 12 * 60 + 30),  # 12:00-12:30\n        (13 * 60, 14 * 60)     # 13:00-14:00\n    ]\n    alexis_tuesday_unavailable = [\n        (10 * 60 + 30, 11 * 60),  # 10:30-11:00\n        (12 * 60, 13 * 60),        # 12:00-13:00\n        (14 * 60, 15 * 60)         # 14:00-15:00\n    ]\n    # Alexis's preferences: not Monday, and Tuesday before 13:30\n    alexis_preferred_days = ['Tuesday']\n    alexis_max_time = 13 * 60 + 30  # 13:30\n\n    # Roy's constraints\n    roy_monday_unavailable = [\n        (9 * 60 + 30, 10 * 60 + 30),  # 9:30-10:30\n        (11 * 60, 12 * 60),           # 11:00-12:00\n        (12 * 60 + 30, 14 * 60),      # 12:30-14:00\n        (15 * 60, 15 * 60 + 30),      # 15:00-15:30\n        (16 * 60, 17 * 60)            # 16:00-17:00\n    ]\n    roy_tuesday_unavailable = [\n        (9 * 60, 9 * 60 + 30),        # 9:00-9:30\n        (10 * 60, 16 * 60),           # 10:00-16:00\n        (16 * 60 + 30, 17 * 60)       # 16:30-17:00\n    ]\n\n    # Meeting duration in minutes\n    meeting_duration = 30\n\n    # Check Tuesday first (Alexis's preference)\n    day = 'Tuesday'\n    alexis_unavailable = alexis_tuesday_unavailable\n    roy_unavailable = roy_tuesday_unavailable\n\n    # Generate available slots for Alexis on Tuesday before 13:30\n    alexis_available = []\n    prev_end = work_start\n    for start, end in sorted(alexis_unavailable):\n        if start > prev_end:\n            alexis_available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < alexis_max_time:\n        alexis_available.append((prev_end, alexis_max_time))\n    elif prev_end < work_end:\n        alexis_available.append((prev_end, work_end))\n\n    # Generate available slots for Roy on Tuesday\n    roy_available = []\n    prev_end = work_start\n    for start, end in sorted(roy_unavailable):\n        if start > prev_end:\n            roy_available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        roy_available.append((prev_end, work_end))\n\n    # Find overlapping slots\n    for a_start, a_end in alexis_available:\n        for r_start, r_end in roy_available:\n            overlap_start = max(a_start, r_start)\n            overlap_end = min(a_end, r_end)\n            if overlap_end - overlap_start >= meeting_duration:\n                # Found a suitable time\n                meeting_start = overlap_start\n                meeting_end = meeting_start + meeting_duration\n                # Format as HH:MM:HH:MM\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    # If no time on Tuesday, check Monday (though Alexis prefers not to)\n    day = 'Monday'\n    alexis_unavailable = alexis_monday_unavailable\n    roy_unavailable = roy_monday_unavailable\n\n    # Generate available slots for Alexis on Monday\n    alexis_available = []\n    prev_end = work_start\n    for start, end in sorted(alexis_unavailable):\n        if start > prev_end:\n            alexis_available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        alexis_available.append((prev_end, work_end))\n\n    # Generate available slots for Roy on Monday\n    roy_available = []\n    prev_end = work_start\n    for start, end in sorted(roy_unavailable):\n        if start > prev_end:\n            roy_available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        roy_available.append((prev_end, work_end))\n\n    # Find overlapping slots\n    for a_start, a_end in alexis_available:\n        for r_start, r_end in roy_available:\n            overlap_start = max(a_start, r_start)\n            overlap_end = min(a_end, r_end)\n            if overlap_end - overlap_start >= meeting_duration:\n                # Found a suitable time\n                meeting_start = overlap_start\n                meeting_end = meeting_start + meeting_duration\n                # Format as HH:MM:HH:MM\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_632"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Define busy slots for Lisa and Carolyn in minutes since midnight\n    # Monday\n    lisa_busy_monday = []\n    carolyn_busy_monday = [\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    # Carolyn prefers not to meet on Monday after 12:30\n    monday_cutoff = 12 * 60 + 30\n\n    # Tuesday\n    lisa_busy_tuesday = [\n        (10 * 60, 10 * 60 + 30),\n        (13 * 60 + 30, 14 * 60)\n    ]\n    carolyn_busy_tuesday = [\n        (9 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 16 * 60 + 30)\n    ]\n\n    # Check Monday\n    def find_slot(busy_slots, day_cutoff=None):\n        slots = []\n        # Merge and sort busy slots\n        merged = sorted(busy_slots, key=lambda x: x[0])\n        # Find free slots\n        prev_end = work_start\n        for start, end in merged:\n            if start > prev_end:\n                slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            slots.append((prev_end, work_end))\n        # Filter slots by duration and cutoff\n        valid_slots = []\n        for start, end in slots:\n            if end - start >= meeting_duration:\n                if day_cutoff is None or start + meeting_duration <= day_cutoff:\n                    valid_slots.append((start, end))\n        return valid_slots\n\n    # Check Monday for Lisa and Carolyn\n    monday_lisa_slots = find_slot(lisa_busy_monday)\n    monday_carolyn_slots = find_slot(carolyn_busy_monday, monday_cutoff)\n    # Find overlapping slots\n    monday_common_slots = []\n    for l_start, l_end in monday_lisa_slots:\n        for c_start, c_end in monday_carolyn_slots:\n            start = max(l_start, c_start)\n            end = min(l_end, c_end)\n            if end - start >= meeting_duration:\n                monday_common_slots.append((start, start + meeting_duration))\n\n    if monday_common_slots:\n        start, end = monday_common_slots[0]\n        return f\"{start // 60:02d}:{start % 60:02d}:{end // 60:02d}:{end % 60:02d}\"\n\n    # Check Tuesday for Lisa and Carolyn\n    tuesday_lisa_slots = find_slot(lisa_busy_tuesday)\n    tuesday_carolyn_slots = find_slot(carolyn_busy_tuesday)\n    # Find overlapping slots\n    tuesday_common_slots = []\n    for l_start, l_end in tuesday_lisa_slots:\n        for c_start, c_end in tuesday_carolyn_slots:\n            start = max(l_start, c_start)\n            end = min(l_end, c_end)\n            if end - start >= meeting_duration:\n                tuesday_common_slots.append((start, start + meeting_duration))\n\n    if tuesday_common_slots:\n        start, end = tuesday_common_slots[0]\n        return f\"{start // 60:02d}:{start % 60:02d}:{end // 60:02d}:{end % 60:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_633"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to check\n    days = ['Monday', 'Tuesday']\n\n    # Jesse's constraints\n    jesse_busy = {\n        'Monday': [(16 * 60, 16 * 60 + 30)],\n        'Tuesday': [(14 * 60, 14 * 60 + 30)]\n    }\n    jesse_no_meet_after = {\n        'Tuesday': 10 * 60  # 10:00\n    }\n\n    # Emily's constraints\n    emily_busy = {\n        'Monday': [(9 * 60, 14 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60 + 30, 15 * 60), (15 * 60 + 30, 17 * 60)]\n    }\n    emily_no_meet_days = ['Monday']\n\n    # Iterate through each day\n    for day in days:\n        if day in emily_no_meet_days:\n            continue  # Skip days Emily can't meet\n\n        # Combine busy times for both participants\n        busy_times = []\n        if day in jesse_busy:\n            busy_times.extend(jesse_busy[day])\n        if day in emily_busy:\n            busy_times.extend(emily_busy[day])\n        busy_times.sort()\n\n        # Find free slots\n        previous_end = work_start\n        free_slots = []\n        for start, end in busy_times:\n            if start > previous_end:\n                free_slots.append((previous_end, start))\n            previous_end = max(previous_end, end)\n        if previous_end < work_end:\n            free_slots.append((previous_end, work_end))\n\n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            # Check if slot is long enough\n            if slot_end - slot_start >= meeting_duration:\n                # Apply Jesse's no-meet-after constraint for Tuesday\n                if day == 'Tuesday' and jesse_no_meet_after.get('Tuesday', 24 * 60) < slot_start + meeting_duration:\n                    continue\n                # Found a valid slot\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                # Format the output\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No meeting time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_634"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define days to consider\n    days = ['Monday', 'Tuesday']\n\n    # Define blocked times in minutes since midnight for each person and day\n    russell_blocked = {\n        'Monday': [(11 * 60, 12 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Tuesday': [(9 * 60 + 30, 10 * 60), (13 * 60, 14 * 60)],\n    }\n\n    amy_blocked = {\n        'Monday': [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 11 * 60 + 30), \n                   (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 15 * 60)],\n        'Tuesday': [(9 * 60 + 30, 10 * 60 + 30), (11 * 60 + 30, 13 * 60),\n                    (13 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)],\n    }\n\n    # Russell cannot meet on Tuesday, so remove Tuesday\n    days_to_check = ['Monday']\n\n    # Amy prefers not to meet on Monday after 13:30, so adjust work_end for Monday\n    adjusted_work_end_monday = 13 * 60 + 30\n\n    # Duration of the meeting in minutes\n    duration = 30\n\n    # Iterate through possible days and times to find a slot\n    for day in days_to_check:\n        # Adjust work end time for Monday based on Amy's preference\n        current_work_end = adjusted_work_end_monday if day == 'Monday' else work_end\n\n        # Collect all blocked times for both participants on this day\n        all_blocked = russell_blocked.get(day, []) + amy_blocked.get(day, [])\n        all_blocked.sort()\n\n        # Check the time before the first blocked period\n        if len(all_blocked) > 0:\n            first_block_start = all_blocked[0][0]\n            if first_block_start - work_start >= duration:\n                start_time = work_start\n                end_time = start_time + duration\n                return f\"{start_time//60:02d}:{start_time%60:02d}:{end_time//60:02d}:{end_time%60:02d}\"\n\n        # Check between blocked periods\n        for i in range(len(all_blocked) - 1):\n            current_block_end = all_blocked[i][1]\n            next_block_start = all_blocked[i+1][0]\n            if next_block_start - current_block_end >= duration:\n                start_time = current_block_end\n                end_time = start_time + duration\n                return f\"{start_time//60:02d}:{start_time%60:02d}:{end_time//60:02d}:{end_time%60:02d}\"\n\n        # Check the time after the last blocked period\n        if len(all_blocked) > 0:\n            last_block_end = all_blocked[-1][1]\n            if current_work_end - last_block_end >= duration:\n                start_time = last_block_end\n                end_time = start_time + duration\n                return f\"{start_time//60:02d}:{start_time%60:02d}:{end_time//60:02d}:{end_time%60:02d}\"\n        else:\n            # No blocked times, any time works\n            start_time = work_start\n            end_time = start_time + duration\n            return f\"{start_time//60:02d}:{start_time%60:02d}:{end_time//60:02d}:{end_time%60:02d}\"\n\n    # If no time found (though problem states there is a solution)\n    return \"No time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_635"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Madison's unavailable times on Tuesday (in minutes since midnight)\n    madison_unavailable = [\n        (9 * 60, 9 * 60 + 30),    # 9:00-9:30\n        (10 * 60 + 30, 11 * 60),   # 10:30-11:00\n        (12 * 60, 12 * 60 + 30),   # 12:00-12:30\n        (13 * 60 + 30, 14 * 60 + 30),  # 13:30-14:30\n        (16 * 60 + 30, 17 * 60)    # 16:30-17:00\n    ]\n    \n    # Lauren's unavailable times on Tuesday (in minutes since midnight)\n    lauren_unavailable = [\n        (9 * 60, 9 * 60 + 30),     # 9:00-9:30\n        (10 * 60, 10 * 60 + 30),   # 10:00-10:30\n        (12 * 60, 13 * 60 + 30),   # 12:00-13:30\n        (14 * 60 + 30, 15 * 60),   # 14:30-15:00\n        (16 * 60 + 30, 17 * 60)    # 16:30-17:00\n    ]\n    \n    # Lauren's preference: avoid meetings after 10:30 on Tuesday\n    # So we only consider times before 10:30 or after 15:00 (since 10:30-15:00 is blocked)\n    # But after 15:00, Lauren has 15:00-16:30 free (but 16:30-17:00 is blocked)\n    \n    # Possible slots to check (before 10:30 or after 15:00)\n    possible_slots = [\n        (9 * 60 + 30, 10 * 60),    # 9:30-10:00\n        (10 * 60 + 30, 11 * 60),   # 10:30-11:00 (but Lauren prefers to avoid)\n        (15 * 60, 16 * 60 + 30)    # 15:00-16:30\n    ]\n    \n    # Check possible slots\n    for slot in possible_slots:\n        start, end = slot\n        duration = 30  # minutes\n        \n        # Check if slot is long enough\n        if end - start >= duration:\n            # Check Madison's availability\n            madison_available = True\n            for busy_start, busy_end in madison_unavailable:\n                if not (end <= busy_start or start >= busy_end):\n                    madison_available = False\n                    break\n            \n            # Check Lauren's availability\n            lauren_available = True\n            for busy_start, busy_end in lauren_unavailable:\n                if not (end <= busy_start or start >= busy_end):\n                    lauren_available = False\n                    break\n            \n            if madison_available and lauren_available:\n                # Found a valid slot\n                meeting_start = start\n                meeting_end = start + duration\n                # Convert to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_636"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define the days to consider\n    days = ['Monday', 'Tuesday']\n    \n    # Define Cheryl's and Janice's schedules in minutes since midnight\n    cheryl_schedule = {\n        'Monday': [\n            (9 * 60, 10 * 60 + 30),   # 9:00-10:30\n            (11 * 60, 11 * 60 + 30),  # 11:00-11:30\n            (14 * 60, 14 * 60 + 30), # 14:00-14:30\n            (16 * 60, 16 * 60 + 30)   # 16:00-16:30\n        ],\n        'Tuesday': [\n            (9 * 60, 10 * 60),        # 9:00-10:00\n            (12 * 60 + 30, 13 * 60), # 12:30-13:00\n            (13 * 60 + 30, 14 * 60),  # 13:30-14:00\n            (15 * 60, 17 * 60)        # 15:00-17:00\n        ]\n    }\n    \n    janice_schedule = {\n        'Monday': [\n            (9 * 60, 11 * 60 + 30),  # 9:00-11:30\n            (12 * 60, 14 * 60),       # 12:00-14:00\n            (14 * 60 + 30, 17 * 60)   # 14:30-17:00\n        ],\n        'Tuesday': [\n            (9 * 60, 13 * 60 + 30),  # 9:00-13:30\n            (14 * 60, 14 * 60 + 30), # 14:00-14:30\n            (15 * 60, 17 * 60)       # 15:00-17:00\n        ]\n    }\n    \n    meeting_duration = 30  # minutes\n    \n    # Prefer Monday (Cheryl's preference)\n    for day in days:\n        if day == 'Tuesday':\n            continue  # Skip Tuesday as Cheryl prefers not to meet then\n        \n        # Combine and sort all busy times for both participants\n        busy_times = cheryl_schedule[day] + janice_schedule[day]\n        busy_times.sort()\n        \n        # Find available slots\n        available_slots = []\n        prev_end = work_start\n        \n        for start, end in busy_times:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n        \n        # Check for a slot that fits the meeting duration\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= meeting_duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                # Convert back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    # If no slot found on Monday, check Tuesday (though Cheryl prefers not to)\n    day = 'Tuesday'\n    busy_times = cheryl_schedule[day] + janice_schedule[day]\n    busy_times.sort()\n    \n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in busy_times:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_637"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday']\n    \n    # Define blocked times for Jason and Deborah in minutes since midnight\n    blocked = {\n        'Jason': {\n            'Monday': [(9 * 60 + 30, 10 * 60 + 30), (11 * 60, 12 * 60), (12 * 60 + 30, 13 * 60),\n                       (13 * 60 + 30, 14 * 60), (15 * 60, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n            'Tuesday': [(11 * 60 + 30, 12 * 60), (13 * 60 + 30, 14 * 60)]\n        },\n        'Deborah': {\n            'Monday': [(9 * 60, 17 * 60)],  # All day blocked\n            'Tuesday': [(9 * 60, 11 * 60), (11 * 60 + 30, 13 * 60 + 30), (14 * 60, 17 * 60)]\n        }\n    }\n    \n    # Iterate through each day\n    for day in days:\n        # Check if Deborah is entirely blocked on the day (like Monday)\n        if day == 'Monday' and blocked['Deborah'][day] == [(9 * 60, 17 * 60)]:\n            continue  # Skip Monday for Deborah\n        \n        # Get all blocked times for both participants on this day\n        jason_blocked = blocked['Jason'][day]\n        deborah_blocked = blocked['Deborah'][day]\n        \n        # Combine and sort all blocked intervals\n        all_blocked = jason_blocked + deborah_blocked\n        all_blocked.sort()\n        \n        # Find free slots by checking gaps between blocked intervals\n        prev_end = work_start\n        for start, end in all_blocked:\n            if start > prev_end:\n                # Found a free slot\n                free_start = prev_end\n                free_end = start\n                if free_end - free_start >= 30:  # Meeting duration is 30 minutes\n                    # Convert back to HH:MM format\n                    start_hh = free_start // 60\n                    start_mm = free_start % 60\n                    end_hh = (free_start + 30) // 60\n                    end_mm = (free_start + 30) % 60\n                    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after the last blocked interval\n        if prev_end < work_end and work_end - prev_end >= 30:\n            start_hh = prev_end // 60\n            start_mm = prev_end % 60\n            end_hh = (prev_end + 30) // 60\n            end_mm = (prev_end + 30) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No time found\"  # Should not happen as per the problem statement\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_638"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Michelle's busy times in minutes since midnight\n    michelle_busy = {\n        'Monday': [(15 * 60 + 30, 16 * 60 + 30)],  # 15:30-16:30\n        'Tuesday': [(12 * 60 + 30, 13 * 60 + 30)]  # 12:30-13:30\n    }\n\n    # Amber's busy times in minutes since midnight\n    amber_busy = {\n        'Monday': [\n            (10 * 60, 12 * 60 + 30),  # 10:00-12:30\n            (13 * 60, 13 * 60 + 30),   # 13:00-13:30\n            (15 * 60, 15 * 60 + 30),   # 15:00-15:30\n            (16 * 60 + 30, 17 * 60)    # 16:30-17:00\n        ],\n        'Tuesday': [\n            (9 * 60, 10 * 60 + 30),    # 9:00-10:30\n            (12 * 60 + 30, 15 * 60)     # 12:30-15:00\n        ]\n    }\n\n    days = ['Monday', 'Tuesday']\n\n    for day in days:\n        # Collect all busy intervals for both participants\n        busy_intervals = michelle_busy.get(day, []) + amber_busy.get(day, [])\n        busy_intervals.sort()\n\n        # Find free slots\n        prev_end = work_start\n        free_slots = []\n\n        for start, end in busy_intervals:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n\n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            available_start = slot_start\n            available_end = slot_end\n\n            if available_end - available_start >= meeting_duration:\n                meeting_start = available_start\n                meeting_end = meeting_start + meeting_duration\n\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_639"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(bobby_busy, michael_busy, work_hours, duration, days):\n    for day in days:\n        # Initialize available time as the full work hours\n        available_start, available_end = work_hours\n        \n        # Get busy times for the current day\n        bobby_day = [slot for slot in bobby_busy if slot[0] == day]\n        michael_day = [slot for slot in michael_busy if slot[0] == day]\n        \n        # Combine and sort all busy slots for the day\n        busy_slots = []\n        for slot in bobby_day:\n            busy_slots.append((slot[1], slot[2]))\n        for slot in michael_day:\n            busy_slots.append((slot[1], slot[2]))\n        busy_slots.sort()\n        \n        # Find available slots between busy times\n        current_time = available_start\n        for start, end in busy_slots:\n            if start > current_time:\n                # Check if the slot is long enough\n                if (start - current_time) >= duration:\n                    return f\"{day}:{current_time}:{current_time + duration}\"\n                else:\n                    current_time = end\n            else:\n                if end > current_time:\n                    current_time = end\n        # Check after last busy slot\n        if (available_end - current_time) >= duration:\n            return f\"{day}:{current_time}:{current_time + duration}\"\n    return \"No available time found.\"\n\n# Define work hours and meeting duration\nwork_hours = (9 * 60, 17 * 60)  # 9:00 to 17:00 in minutes\nduration = 30  # minutes\n\n# Define busy times in (day, start, end) format, times in minutes since midnight\nbobby_busy = [\n    (\"Monday\", 14 * 60 + 30, 15 * 60),\n    (\"Tuesday\", 9 * 60, 11 * 60 + 30),\n    (\"Tuesday\", 12 * 60, 12 * 60 + 30),\n    (\"Tuesday\", 13 * 60, 15 * 60),\n    (\"Tuesday\", 15 * 60 + 30, 17 * 60)\n]\n\nmichael_busy = [\n    (\"Monday\", 9 * 60, 10 * 60),\n    (\"Monday\", 10 * 60 + 30, 13 * 60 + 30),\n    (\"Monday\", 14 * 60, 15 * 60),\n    (\"Monday\", 15 * 60 + 30, 17 * 60),\n    (\"Tuesday\", 9 * 60, 10 * 60 + 30),\n    (\"Tuesday\", 11 * 60, 11 * 60 + 30),\n    (\"Tuesday\", 12 * 60, 14 * 60),\n    (\"Tuesday\", 15 * 60, 16 * 60),\n    (\"Tuesday\", 16 * 60 + 30, 17 * 60)\n]\n\n# Days to check\ndays = [\"Monday\", \"Tuesday\"]\n\n# Find the earliest meeting time\nresult = find_meeting_time(bobby_busy, michael_busy, work_hours, duration, days)\nprint(result)\n```",
            "count": "calendar_scheduling_example_640"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday']\n    meeting_duration = 60  # minutes\n\n    # Gary's busy times in minutes since start of day\n    gary_busy = {\n        'Monday': [(9 * 60, 14 * 60 + 30), (16 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 11 * 60), (11 * 60 + 30, 14 * 60), (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)]\n    }\n\n    # Mason is free all day, so only Gary's schedule matters\n    for day in days:\n        busy_times = gary_busy.get(day, [])\n        free_slots = []\n        prev_end = work_start\n\n        # Calculate free slots between busy times\n        for start, end in sorted(busy_times):\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy slot\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n\n        # Find the earliest suitable slot\n        for start, end in free_slots:\n            if end - start >= meeting_duration:\n                meeting_start = start\n                meeting_end = meeting_start + meeting_duration\n                # Convert back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_641"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Christopher's schedule (in minutes since midnight)\n    christopher_busy = {\n        \"Monday\": [\n            (9 * 60, 9 * 60 + 30),    # 9:00-9:30\n            (10 * 60 + 30, 11 * 60),   # 10:30-11:00\n            (14 * 60, 14 * 60 + 30),   # 14:00-14:30\n        ],\n        \"Tuesday\": [\n            (13 * 60 + 30, 14 * 60),   # 13:30-14:00\n        ]\n    }\n\n    # Jean's schedule (in minutes since midnight)\n    jean_busy = {\n        \"Monday\": [\n            (9 * 60, 10 * 60),         # 9:00-10:00\n            (10 * 60 + 30, 11 * 60),   # 10:30-11:00\n            (11 * 60 + 30, 12 * 60 + 30),  # 11:30-12:30\n            (13 * 60 + 30, 15 * 60),   # 13:30-15:00\n            (15 * 60 + 30, 16 * 60),   # 15:30-16:00\n        ],\n        \"Tuesday\": [\n            (9 * 60, 10 * 60),         # 9:00-10:00\n            (10 * 60 + 30, 12 * 60),   # 10:30-12:00\n            (13 * 60, 17 * 60),        # 13:00-17:00\n        ]\n    }\n\n    # Days to check (preference for Tuesday)\n    days = [\"Tuesday\", \"Monday\"]\n\n    for day in days:\n        # Get busy times for both participants on this day\n        busy_times = christopher_busy.get(day, []) + jean_busy.get(day, [])\n        busy_times.sort()\n\n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n\n        for start, end in busy_times:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n\n        # Check for a suitable slot\n        for start, end in free_slots:\n            available_duration = end - start\n            if available_duration >= meeting_duration:\n                meeting_start = start\n                meeting_end = meeting_start + meeting_duration\n                # Format as HH:MM:HH:MM\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_642"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Paul's blocked times in minutes since midnight for Monday and Tuesday\n    paul_monday = [\n        (10 * 60 + 30, 11 * 60),    # 10:30-11:00\n        (12 * 60, 13 * 60),          # 12:00-13:00\n        (14 * 60, 15 * 60),          # 14:00-15:00\n        (16 * 60, 17 * 60)           # 16:00-17:00\n    ]\n    paul_tuesday = [\n        (11 * 60 + 30, 12 * 60),    # 11:30-12:00\n        (12 * 60 + 30, 13 * 60),     # 12:30-13:00\n        (13 * 60 + 30, 14 * 60 + 30),# 13:30-14:30\n        (15 * 60 + 30, 16 * 60)      # 15:30-16:00\n    ]\n\n    # Sophia's blocked times in minutes since midnight for Monday and Tuesday\n    sophia_monday = [\n        (9 * 60, 17 * 60)  # 9:00-17:00 (entire day)\n    ]\n    sophia_tuesday = [\n        (9 * 60, 9 * 60 + 30),  # 9:00-9:30\n        (10 * 60, 14 * 60),      # 10:00-14:00\n        (14 * 60 + 30, 17 * 60)  # 14:30-17:00\n    ]\n\n    # Combine blocked times for each day\n    days = {\n        'Monday': {\n            'Paul': paul_monday,\n            'Sophia': sophia_monday\n        },\n        'Tuesday': {\n            'Paul': paul_tuesday,\n            'Sophia': sophia_tuesday\n        }\n    }\n\n    # Iterate through each day to find a suitable time\n    for day, schedules in days.items():\n        # Get all blocked times for the day\n        blocked_times = []\n        for person, blocks in schedules.items():\n            blocked_times.extend(blocks)\n        \n        # Sort blocked times by start time\n        blocked_times.sort()\n\n        # Find free slots by checking gaps between blocked times\n        prev_end = work_start\n        free_slots = []\n        for start, end in blocked_times:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        # Check after last blocked time\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n\n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= meeting_duration:\n                # Convert back to HH:MM format\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_hh = (slot_start + meeting_duration) // 60\n                end_mm = (slot_start + meeting_duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_643"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(emily_schedule, mark_schedule, work_hours, duration):\n    from datetime import datetime, timedelta\n\n    # Parse work hours\n    start_work, end_work = [datetime.strptime(time, \"%H:%M\") for time in work_hours.split(\" to \")]\n\n    # Function to parse schedule into busy slots\n    def parse_schedule(schedule):\n        busy_slots = []\n        for day_slots in schedule:\n            day = day_slots[0]\n            for slot in day_slots[1:]:\n                start, end = [datetime.strptime(time, \"%H:%M\") for time in slot.split(\" to \")]\n                busy_slots.append((start.time(), end.time()))\n        return busy_slots\n\n    # Parse Emily's and Mark's schedules\n    emily_busy = parse_schedule(emily_schedule)\n    mark_busy = parse_schedule(mark_schedule)\n\n    # Combine and sort all busy slots\n    all_busy = emily_busy + mark_busy\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    prev_end = start_work.time()\n\n    for busy_start, busy_end in all_busy:\n        if busy_start > prev_end:\n            free_slots.append((prev_end, busy_start))\n        if busy_end > prev_end:\n            prev_end = busy_end\n\n    # Check after last busy slot\n    if prev_end < end_work.time():\n        free_slots.append((prev_end, end_work.time()))\n\n    # Find the first free slot that can accommodate the meeting\n    for slot in free_slots:\n        start, end = slot\n        slot_duration = (datetime.combine(datetime.today(), end) - datetime.combine(datetime.today(), start)).seconds / 3600\n        if slot_duration >= duration:\n            meeting_end = (datetime.combine(datetime.today(), start) + timedelta(hours=duration)).time()\n            return f\"{start.strftime('%H:%M')}:{meeting_end.strftime('%H:%M')}\"\n\n    return \"No suitable time found\"\n\n# Define schedules\nemily_schedule = [\n    [\"Monday\", \"9:00 to 9:30\", \"10:00 to 11:00\", \"12:00 to 13:00\", \"13:30 to 14:30\", \"16:00 to 16:30\"],\n    [\"Tuesday\", \"9:00 to 9:30\", \"11:00 to 11:30\", \"12:00 to 13:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"]\n]\n\nmark_schedule = [\n    [\"Monday\", \"9:00 to 10:00\", \"10:30 to 11:00\", \"12:00 to 12:30\", \"13:00 to 16:30\"],\n    [\"Tuesday\", \"9:30 to 10:00\", \"10:30 to 11:30\", \"12:00 to 13:30\", \"14:00 to 16:00\", \"16:30 to 17:00\"]\n]\n\n# Find meeting time\nmeeting_time = find_meeting_time(emily_schedule, mark_schedule, \"9:00 to 17:00\", 1)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_644"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{10:00:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday']\n    \n    # Define participants' busy times in minutes since midnight\n    kyle_busy = {\n        'Tuesday': [(11 * 60, 11 * 60 + 30), (14 * 60, 14 * 60 + 30)]\n    }\n    sharon_busy = {\n        'Monday': [(9 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 10 * 60), (11 * 60, 12 * 60), (12 * 60 + 30, 13 * 60 + 30), (14 * 60, 17 * 60)]\n    }\n    \n    # Check each day for available slots\n    for day in days:\n        # Collect all busy intervals for the day\n        busy_intervals = []\n        \n        # Add Kyle's busy times\n        if day in kyle_busy:\n            busy_intervals.extend(kyle_busy[day])\n        \n        # Add Sharon's busy times\n        if day in sharon_busy:\n            busy_intervals.extend(sharon_busy[day])\n        \n        # Sort busy intervals by start time\n        busy_intervals.sort()\n        \n        # Find free slots by checking gaps between busy intervals\n        previous_end = work_start\n        for start, end in busy_intervals:\n            if start > previous_end:\n                # Found a free slot\n                free_start = previous_end\n                free_end = start\n                if free_end - free_start >= 60:  # Meeting duration is 1 hour\n                    # Convert back to HH:MM format\n                    start_hh = free_start // 60\n                    start_mm = free_start % 60\n                    end_hh = (free_start + 60) // 60\n                    end_mm = (free_start + 60) % 60\n                    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n            previous_end = max(previous_end, end)\n        \n        # Check after last busy interval\n        if work_end - previous_end >= 60:\n            start_hh = previous_end // 60\n            start_mm = previous_end % 60\n            end_hh = (previous_end + 60) // 60\n            end_mm = (previous_end + 60) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_645"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Define days to check\n    days = ['Monday', 'Tuesday']\n\n    # Define schedules for each participant\n    stephen_schedule = {\n        'Monday': [(9 * 60 + 30, 10 * 60), (11 * 60, 11 * 60 + 30), (14 * 60, 14 * 60 + 30), (15 * 60, 15 * 60 + 30)],\n        'Tuesday': [(10 * 60 + 30, 11 * 60), (12 * 60, 12 * 60 + 30), (14 * 60 + 30, 16 * 60 + 30)]\n    }\n\n    alexis_schedule = {\n        'Monday': [(9 * 60, 12 * 60), (12 * 60 + 30, 13 * 60), (14 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)]\n    }\n\n    # Check each day for available slots\n    for day in days:\n        # Collect all busy intervals for both participants\n        busy_intervals = stephen_schedule.get(day, []) + alexis_schedule.get(day, [])\n        busy_intervals.sort()\n\n        # Merge overlapping or adjacent intervals\n        merged = []\n        for start, end in busy_intervals:\n            if not merged:\n                merged.append((start, end))\n            else:\n                last_start, last_end = merged[-1]\n                if start <= last_end:\n                    merged[-1] = (last_start, max(end, last_end))\n                else:\n                    merged.append((start, end))\n\n        # Check available slots before first meeting, between meetings, and after last meeting\n        prev_end = work_start\n        for start, end in merged:\n            if start - prev_end >= 60:  # 1 hour available\n                meeting_start = prev_end\n                meeting_end = meeting_start + 60\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n            prev_end = max(prev_end, end)\n\n        # Check after last meeting\n        if work_end - prev_end >= 60:\n            meeting_start = prev_end\n            meeting_end = meeting_start + 60\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No available time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_646"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday']\n    \n    # Natalie's constraints in minutes since start of day\n    natalie_busy = {\n        'Monday': [(16 * 60, 16 * 60 + 30)],\n        'Tuesday': [\n            (9 * 60, 9 * 60 + 30),\n            (10 * 60, 12 * 60),\n            (12 * 60 + 30, 13 * 60),\n            (15 * 60, 15 * 60 + 30)\n        ]\n    }\n    \n    # Frances's constraints in minutes since start of day\n    frances_busy = {\n        'Monday': [\n            (9 * 60, 10 * 60 + 30),\n            (11 * 60, 11 * 60 + 30),\n            (13 * 60, 13 * 60 + 30),\n            (14 * 60 + 30, 17 * 60)\n        ],\n        'Tuesday': [\n            (9 * 60, 10 * 60),\n            (12 * 60, 13 * 60),\n            (13 * 60 + 30, 14 * 60),\n            (14 * 60 + 30, 16 * 60)\n        ]\n    }\n    \n    # Preferences\n    natalie_prefers_not_tuesday = True\n    frances_no_monday_after_1330 = True\n    \n    meeting_duration = 60  # minutes\n    \n    # Check Monday first (Natalie prefers not Tuesday)\n    for day in days:\n        if day == 'Tuesday' and natalie_prefers_not_tuesday:\n            continue  # Skip Tuesday if Natalie prefers not to meet then\n        \n        # Combine and sort all busy intervals for both participants\n        busy_intervals = []\n        if day in natalie_busy:\n            busy_intervals.extend(natalie_busy[day])\n        if day in frances_busy:\n            busy_intervals.extend(frances_busy[day])\n        \n        # Add additional constraints based on preferences\n        if day == 'Monday' and frances_no_monday_after_1330:\n            busy_intervals.append((13 * 60 + 30, 17 * 60))\n        \n        # Sort intervals by start time\n        busy_intervals.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in busy_intervals:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            available_start = slot_start\n            available_end = slot_end\n            \n            if available_end - available_start >= meeting_duration:\n                # Convert back to HH:MM format\n                start_hh = available_start // 60\n                start_mm = available_start % 60\n                end_hh = (available_start + meeting_duration) // 60\n                end_mm = (available_start + meeting_duration) % 60\n                \n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_647"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday']\n    \n    # Define schedules for each person for each day\n    benjamin_schedule = {\n        'Monday': [(9 * 60 + 30, 10 * 60), (14 * 60, 14 * 60 + 30), (15 * 60 + 30, 16 * 60)],\n        'Tuesday': [(9 * 60 + 30, 11 * 60)]\n    }\n    \n    joe_schedule = {\n        'Monday': [(10 * 60, 10 * 60 + 30), (12 * 60, 13 * 60), (14 * 60 + 30, 15 * 60), (16 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 9 * 60 + 30), (10 * 60, 12 * 60), (13 * 60, 14 * 60 + 30), (15 * 60 + 30, 16 * 60 + 30)]\n    }\n    \n    meeting_duration = 30  # minutes\n    \n    # Iterate through each day to find the earliest available slot\n    for day in days:\n        # Collect all busy intervals for both participants\n        busy_intervals = benjamin_schedule.get(day, []) + joe_schedule.get(day, [])\n        # Sort the busy intervals by start time\n        busy_intervals.sort()\n        \n        # Check the time before the first busy interval\n        prev_end = work_start\n        for start, end in busy_intervals:\n            if start > prev_end:\n                available_start = prev_end\n                available_end = start\n                if available_end - available_start >= meeting_duration:\n                    # Found a suitable slot\n                    return f\"{minutes_to_time(available_start)}:{minutes_to_time(available_start + meeting_duration)}\"\n            prev_end = max(prev_end, end)\n        \n        # Check the time after the last busy interval\n        if work_end - prev_end >= meeting_duration:\n            return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + meeting_duration)}\"\n    \n    return \"No available time found\"\n\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_648"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday']\n    \n    # Define schedules for Jose and Bryan\n    schedules = {\n        'Jose': {\n            'Monday': [(9 * 60, 9 * 60 + 30), (15 * 60 + 30, 16 * 60)],\n            'Tuesday': [(10 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60), (15 * 60, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)]\n        },\n        'Bryan': {\n            'Monday': [(9 * 60 + 30, 10 * 60 + 30), (11 * 60, 12 * 60), (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60 + 30), (15 * 60 + 30, 16 * 60)],\n            'Tuesday': [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60), (16 * 60, 16 * 60 + 30)]\n        }\n    }\n    \n    # Check each day for the earliest available slot\n    for day in days:\n        # Collect all busy times for both participants\n        busy_times = schedules['Jose'][day] + schedules['Bryan'][day]\n        busy_times.sort()\n        \n        # Merge overlapping or adjacent busy times\n        merged = []\n        for start, end in busy_times:\n            if not merged:\n                merged.append((start, end))\n            else:\n                last_start, last_end = merged[-1]\n                if start <= last_end:\n                    merged[-1] = (last_start, max(end, last_end))\n                else:\n                    merged.append((start, end))\n        \n        # Check the available slots before the first busy time, between busy times, and after the last busy time\n        prev_end = work_start\n        for start, end in merged:\n            if start - prev_end >= 60:  # 1 hour available\n                # Found a slot\n                start_time = prev_end\n                end_time = start_time + 60\n                return f\"{start_time // 60:02d}:{start_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after the last busy time\n        if work_end - prev_end >= 60:\n            start_time = prev_end\n            end_time = start_time + 60\n            return f\"{start_time // 60:02d}:{start_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n    \n    return \"No time found\"  # Shouldn't happen as per the problem statement\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_649"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Define blocked times for Sean and Carol on Monday and Tuesday in minutes\n    # Format: (day, start, end), where day is 0 for Monday, 1 for Tuesday\n    sean_blocked = [\n        # Monday\n        (0, 9.5 * 60, 10 * 60),\n        (0, 11 * 60, 12 * 60),\n        (0, 12.5 * 60, 13.5 * 60),\n        (0, 14 * 60, 15 * 60),\n        (0, 15.5 * 60, 16 * 60),\n        (0, 16.5 * 60, 17 * 60),\n        # Tuesday\n        (1, 10 * 60, 10.5 * 60),\n        (1, 11 * 60, 11.5 * 60),\n        (1, 13.5 * 60, 14 * 60),\n        (1, 15 * 60, 15.5 * 60),\n        (1, 16 * 60, 16.5 * 60),\n    ]\n\n    carol_blocked = [\n        # Monday\n        (0, 9 * 60, 12.5 * 60),\n        (0, 13 * 60, 17 * 60),\n        # Tuesday\n        (1, 9 * 60, 9.5 * 60),\n        (1, 11 * 60, 11.5 * 60),\n        (1, 12.5 * 60, 14.5 * 60),\n        (1, 15.5 * 60, 17 * 60),\n    ]\n\n    # Check each day\n    for day in [0, 1]:\n        # Generate all blocked times for Sean and Carol on this day\n        day_sean_blocked = [ (start, end) for (d, start, end) in sean_blocked if d == day ]\n        day_carol_blocked = [ (start, end) for (d, start, end) in carol_blocked if d == day ]\n\n        # Merge and sort all blocked intervals for both participants\n        all_blocked = day_sean_blocked + day_carol_blocked\n        all_blocked.sort()\n\n        # Find free slots by checking gaps between blocked intervals\n        prev_end = work_start\n        for (start, end) in all_blocked:\n            if start > prev_end:\n                # Found a free slot\n                free_start = prev_end\n                free_end = start\n                if free_end - free_start >= meeting_duration:\n                    # Convert minutes back to HH:MM format\n                    start_hh = int(free_start // 60)\n                    start_mm = int(free_start % 60)\n                    end_hh = int((free_start + meeting_duration) // 60)\n                    end_mm = int((free_start + meeting_duration) % 60)\n                    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n            prev_end = max(prev_end, end)\n\n        # Check after last blocked interval\n        if work_end - prev_end >= meeting_duration:\n            start_hh = int(prev_end // 60)\n            start_mm = int(prev_end % 60)\n            end_hh = int((prev_end + meeting_duration) // 60)\n            end_mm = int((prev_end + meeting_duration) % 60)\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_650"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday']\n    \n    # Arthur's constraints (in minutes, converted from HH:MM)\n    arthur_busy = {\n        'Monday': [(14 * 60, 14 * 60 + 30)],\n        'Tuesday': [(12 * 60, 13 * 60), (15 * 60 + 30, 16 * 60)]\n    }\n    \n    # Thomas's constraints (in minutes, converted from HH:MM)\n    thomas_busy = {\n        'Monday': [(10 * 60, 12 * 60), (12 * 60 + 30, 13 * 60), \n                   (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 17 * 60)],\n        'Tuesday': [(10 * 60, 12 * 60), (13 * 60, 15 * 60), (15 * 60 + 30, 17 * 60)]\n    }\n    \n    meeting_duration = 60  # minutes\n    \n    # Arthur doesn't want to meet on Tuesday, so only consider Monday\n    day = 'Monday'\n    \n    # Combine busy times for both participants on Monday\n    combined_busy = arthur_busy[day] + thomas_busy[day]\n    combined_busy.sort()  # Sort by start time\n    \n    # Find free slots by checking gaps between busy times\n    previous_end = work_start\n    for busy_start, busy_end in combined_busy:\n        if busy_start > previous_end:\n            # Check if the gap is enough for the meeting\n            if busy_start - previous_end >= meeting_duration:\n                # Found a suitable slot\n                start_time = previous_end\n                end_time = start_time + meeting_duration\n                # Convert back to HH:MM format\n                start_hh = start_time // 60\n                start_mm = start_time % 60\n                end_hh = end_time // 60\n                end_mm = end_time % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n        previous_end = max(previous_end, busy_end)\n    \n    # Check after the last busy time\n    if work_end - previous_end >= meeting_duration:\n        start_time = previous_end\n        end_time = start_time + meeting_duration\n        start_hh = start_time // 60\n        start_mm = start_time % 60\n        end_hh = end_time // 60\n        end_mm = end_time % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_651"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to check\n    days = ['Monday', 'Tuesday']\n\n    # Jesse's busy times in minutes since start of day\n    jesse_busy = {\n        'Monday': [\n            (13 * 60 + 30, 14 * 60),\n            (14 * 60 + 30, 15 * 60)\n        ],\n        'Tuesday': [\n            (9 * 60, 9 * 60 + 30),\n            (13 * 60, 13 * 60 + 30),\n            (14 * 60, 15 * 60)\n        ]\n    }\n\n    # Lawrence's busy times in minutes since start of day\n    lawrence_busy = {\n        'Monday': [\n            (9 * 60, 17 * 60)  # Entire day busy\n        ],\n        'Tuesday': [\n            (9 * 60 + 30, 10 * 60 + 30),\n            (11 * 60 + 30, 12 * 60 + 30),\n            (13 * 60, 13 * 60 + 30),\n            (14 * 60 + 30, 15 * 60),\n            (15 * 60 + 30, 16 * 60 + 30)\n        ]\n    }\n\n    # Lawrence cannot meet on Tuesday after 16:30\n    lawrence_constraint = {\n        'Tuesday': 16 * 60 + 30\n    }\n\n    # Iterate through each day\n    for day in days:\n        if day == 'Monday' and day in lawrence_busy and lawrence_busy[day][0][0] == work_start and lawrence_busy[day][0][1] == work_end:\n            continue  # Lawrence is busy all day Monday\n\n        # Combine and sort all busy slots for both participants\n        busy_slots = []\n        if day in jesse_busy:\n            busy_slots.extend(jesse_busy[day])\n        if day in lawrence_busy:\n            busy_slots.extend(lawrence_busy[day])\n        busy_slots.sort()\n\n        # Find free slots\n        prev_end = work_start\n        free_slots = []\n        for start, end in busy_slots:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n\n        # Apply Lawrence's constraint for Tuesday\n        if day == 'Tuesday':\n            constraint_time = lawrence_constraint['Tuesday']\n            new_free_slots = []\n            for start, end in free_slots:\n                if end <= constraint_time:\n                    new_free_slots.append((start, min(end, constraint_time)))\n                elif start < constraint_time:\n                    new_free_slots.append((start, constraint_time))\n            free_slots = new_free_slots\n\n        # Check for a suitable slot\n        for start, end in free_slots:\n            if end - start >= meeting_duration:\n                meeting_start = start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                start_hour = meeting_start // 60\n                start_min = meeting_start % 60\n                end_hour = meeting_end // 60\n                end_min = meeting_end % 60\n                return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_652"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday']\n    \n    # Samuel's schedule: {day: [(start1, end1), (start2, end2), ...]}\n    samuel_schedule = {\n        'Monday': [\n            (10 * 60 + 30, 11 * 60 + 30),\n            (13 * 60 + 30, 14 * 60),\n            (14 * 60 + 30, 15 * 60),\n            (16 * 60, 17 * 60)\n        ],\n        'Tuesday': [\n            (9 * 60, 9 * 60 + 30),\n            (10 * 60 + 30, 11 * 60),\n            (12 * 60, 13 * 60),\n            (14 * 60, 14 * 60 + 30),\n            (15 * 60 + 30, 16 * 60)\n        ]\n    }\n    \n    # Pamela's schedule\n    pamela_schedule = {\n        'Monday': [\n            (9 * 60, 14 * 60 + 30),\n            (15 * 60, 17 * 60)\n        ],\n        'Tuesday': [\n            (9 * 60, 11 * 60),\n            (11 * 60 + 30, 17 * 60)\n        ]\n    }\n    \n    # Check each day for available slots\n    for day in days:\n        # Collect all busy intervals for both participants\n        busy_intervals = []\n        \n        # Add Samuel's busy times\n        for interval in samuel_schedule.get(day, []):\n            busy_intervals.append(interval)\n        \n        # Add Pamela's busy times\n        for interval in pamela_schedule.get(day, []):\n            busy_intervals.append(interval)\n        \n        # Sort busy intervals by start time\n        busy_intervals.sort()\n        \n        # Find free slots by checking gaps between busy intervals\n        prev_end = work_start\n        for start, end in busy_intervals:\n            if start > prev_end:\n                # Found a free slot\n                free_start = prev_end\n                free_end = start\n                if free_end - free_start >= 30:  # Meeting duration is 30 mins\n                    # Convert back to HH:MM format\n                    start_hh = free_start // 60\n                    start_mm = free_start % 60\n                    end_hh = (free_start + 30) // 60\n                    end_mm = (free_start + 30) % 60\n                    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy interval\n        if work_end - prev_end >= 30:\n            start_hh = prev_end // 60\n            start_mm = prev_end % 60\n            end_hh = (prev_end + 30) // 60\n            end_mm = (prev_end + 30) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_653"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday']\n    \n    # Define busy times for Lisa and Janet in minutes since midnight\n    lisa_busy = {\n        'Monday': [(12 * 60 + 30, 13 * 60)],\n        'Tuesday': [(10 * 60, 10 * 60 + 30)]\n    }\n    \n    janet_busy = {\n        'Monday': [\n            (9 * 60 + 30, 10 * 60 + 30),\n            (11 * 60, 11 * 60 + 30),\n            (12 * 60 + 30, 14 * 60),\n            (14 * 60 + 30, 15 * 60)\n        ],\n        'Tuesday': [\n            (9 * 60, 10 * 60),\n            (10 * 60 + 30, 11 * 60 + 30),\n            (12 * 60 + 30, 15 * 60 + 30),\n            (16 * 60, 16 * 60 + 30)\n        ]\n    }\n    \n    # Lisa's preference: avoid Monday after 15:00\n    lisa_preference = {\n        'Monday': (work_start, 15 * 60),\n        'Tuesday': (work_start, work_end)\n    }\n    \n    # Janet's preference: avoid Tuesday\n    janet_preference = ['Monday']\n    \n    # Check possible days in order of preference\n    preferred_days = ['Monday', 'Tuesday']\n    # Prioritize Monday due to Janet's preference\n    if 'Monday' in janet_preference:\n        preferred_days = ['Monday', 'Tuesday']\n    else:\n        preferred_days = ['Tuesday', 'Monday']\n    \n    for day in preferred_days:\n        # Get Lisa's available time based on preference\n        day_start = max(work_start, lisa_preference[day][0])\n        day_end = min(work_end, lisa_preference[day][1])\n        \n        # Generate all possible 30-minute slots in the day\n        for start in range(day_start, day_end - 30 + 1, 5):  # Check every 5 minutes for efficiency\n            end = start + 30\n            # Check if Lisa is available\n            lisa_available = True\n            for busy_start, busy_end in lisa_busy.get(day, []):\n                if not (end <= busy_start or start >= busy_end):\n                    lisa_available = False\n                    break\n            if not lisa_available:\n                continue\n            \n            # Check if Janet is available\n            janet_available = True\n            for busy_start, busy_end in janet_busy.get(day, []):\n                if not (end <= busy_start or start >= busy_end):\n                    janet_available = False\n                    break\n            if not janet_available:\n                continue\n            \n            # If both are available, return the time\n            start_time = f\"{start // 60:02d}:{start % 60:02d}\"\n            end_time = f\"{end // 60:02d}:{end % 60:02d}\"\n            return f\"{start_time}:{end_time}\"\n    \n    return \"No time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_654"
        },
        {
            "final_program_time": "{15:30:16:30}",
            "expected_time": "{15:30:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Katherine's blocked times on Tuesday in minutes\n    katherine_tuesday_blocks = [\n        (12 * 60 + 30, 14 * 60 + 30),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60 + 30, 17 * 60)\n    ]\n\n    # Andrew's blocked times on Monday and Tuesday in minutes\n    andrew_monday_blocks = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    andrew_tuesday_blocks = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 11 * 60 + 30),\n        (12 * 60, 14 * 60)\n    ]\n\n    # Since Andrew prefers to avoid more meetings on Monday, prioritize Tuesday\n    days = [\"Tuesday\", \"Monday\"]\n\n    for day in days:\n        if day == \"Monday\":\n            # Get all blocked times for Monday\n            blocked_times = []\n            # Merge Katherine's and Andrew's blocks (Katherine has no blocks on Monday)\n            blocked_times.extend(andrew_monday_blocks)\n            # Sort blocked times by start time\n            blocked_times.sort()\n            # Find available slots on Monday\n            available_slots = []\n            prev_end = work_start\n            for start, end in blocked_times:\n                if start > prev_end:\n                    available_slots.append((prev_end, start))\n                prev_end = max(prev_end, end)\n            if work_end > prev_end:\n                available_slots.append((prev_end, work_end))\n            # Check for a slot that fits the meeting duration\n            for slot in available_slots:\n                start, end = slot\n                if end - start >= meeting_duration:\n                    meeting_start = start\n                    meeting_end = meeting_start + meeting_duration\n                    # Format the time as HH:MM:HH:MM\n                    return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n        elif day == \"Tuesday\":\n            # Get all blocked times for Tuesday\n            blocked_times = []\n            # Merge Katherine's and Andrew's blocks\n            blocked_times.extend(katherine_tuesday_blocks)\n            blocked_times.extend(andrew_tuesday_blocks)\n            # Sort blocked times by start time\n            blocked_times.sort()\n            # Find available slots on Tuesday\n            available_slots = []\n            prev_end = work_start\n            for start, end in blocked_times:\n                if start > prev_end:\n                    available_slots.append((prev_end, start))\n                prev_end = max(prev_end, end)\n            if work_end > prev_end:\n                available_slots.append((prev_end, work_end))\n            # Check for a slot that fits the meeting duration\n            for slot in available_slots:\n                start, end = slot\n                if end - start >= meeting_duration:\n                    meeting_start = start\n                    meeting_end = meeting_start + meeting_duration\n                    # Format the time as HH:MM:HH:MM\n                    return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No available time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_655"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Roy's blocked times on Tuesday (Monday is excluded)\n    roy_tuesday_blocked = [\n        (9 * 60 + 30, 10 * 60),      # 9:30-10:00\n        (10 * 60 + 30, 12 * 60),      # 10:30-12:00\n        (12 * 60 + 30, 13 * 60),     # 12:30-13:00\n        (13 * 60 + 30, 14 * 60 + 30), # 13:30-14:30\n        (15 * 60 + 30, 16 * 60)       # 15:30-16:00\n    ]\n    \n    # Nancy's blocked times on Tuesday (before 13:30 is excluded)\n    nancy_tuesday_blocked = [\n        (14 * 60, 14 * 60 + 30),  # 14:00-14:30\n        (15 * 60, 17 * 60)        # 15:00-17:00\n    ]\n    \n    # Combine and sort all blocked times for Tuesday\n    all_blocked = roy_tuesday_blocked + nancy_tuesday_blocked\n    all_blocked.sort()\n    \n    # Merge overlapping or adjacent blocked times\n    merged_blocked = []\n    for start, end in all_blocked:\n        if not merged_blocked:\n            merged_blocked.append((start, end))\n        else:\n            last_start, last_end = merged_blocked[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_blocked[-1] = (new_start, new_end)\n            else:\n                merged_blocked.append((start, end))\n    \n    # Check available slots between work hours and blocked times\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged_blocked:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available 30-minute slot\n    meeting_duration = 30\n    for start, end in available_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No available slot found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_656"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to check (Monday and Tuesday)\n    days = ['Monday', 'Tuesday']\n    \n    # Define blocked times for Charles and Jose in minutes since midnight\n    blocked = {\n        'Charles': {\n            'Monday': [\n                (10 * 60, 11 * 60),    # 10:00-11:00\n                (12 * 60, 12 * 60 + 30),  # 12:00-12:30\n                (13 * 60 + 30, 14 * 60),   # 13:30-14:00\n                (15 * 60, 15 * 60 + 30),   # 15:00-15:30\n                (16 * 60, 17 * 60)         # 16:00-17:00\n            ],\n            'Tuesday': [\n                (12 * 60, 12 * 60 + 30),  # 12:00-12:30\n                (13 * 60, 14 * 60),        # 13:00-14:00\n                (14 * 60 + 30, 15 * 60),   # 14:30-15:00\n                (16 * 60 + 30, 17 * 60)   # 16:30-17:00\n            ]\n        },\n        'Jose': {\n            'Monday': [\n                (9 * 60, 17 * 60)  # 9:00-17:00 (entire day blocked)\n            ],\n            'Tuesday': [\n                (9 * 60, 10 * 60),        # 9:00-10:00\n                (11 * 60, 11 * 60 + 30),  # 11:00-11:30\n                (12 * 60, 15 * 60 + 30)  # 12:00-15:30\n            ]\n        }\n    }\n    \n    # Meeting duration in minutes\n    duration = 30\n    \n    # Charles prefers to avoid Tuesday after 13:30 (13:30 = 13*60 + 30)\n    tuesday_avoid_time = 13 * 60 + 30\n    \n    # Iterate through each day to find a suitable time\n    for day in days:\n        if day == 'Monday':\n            # Check Charles's and Jose's availability on Monday\n            charles_blocks = blocked['Charles']['Monday']\n            jose_blocks = blocked['Jose']['Monday']\n            \n            # Jose's entire day is blocked on Monday, so no available time\n            continue\n        elif day == 'Tuesday':\n            # Check Charles's and Jose's availability on Tuesday\n            charles_blocks = blocked['Charles']['Tuesday']\n            jose_blocks = blocked['Jose']['Tuesday']\n            \n            # Combine and sort all blocked times for both participants\n            all_blocks = charles_blocks + jose_blocks\n            all_blocks.sort()\n            \n            # Find available slots\n            prev_end = work_start\n            available_slots = []\n            for start, end in all_blocks:\n                if start > prev_end:\n                    available_slots.append((prev_end, start))\n                prev_end = max(prev_end, end)\n            if prev_end < work_end:\n                available_slots.append((prev_end, work_end))\n            \n            # Check each available slot for a 30-minute window\n            for slot_start, slot_end in available_slots:\n                # Ensure the slot is at least 30 minutes\n                if slot_end - slot_start >= duration:\n                    # Check if the slot is before Charles's preferred avoid time on Tuesday\n                    meeting_start = slot_start\n                    meeting_end = meeting_start + duration\n                    if meeting_end <= tuesday_avoid_time:\n                        # Format the time as HH:MM:HH:MM\n                        return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n                    else:\n                        # Check if the slot starts early enough to fit before avoid time\n                        if slot_start <= tuesday_avoid_time - duration:\n                            meeting_start = tuesday_avoid_time - duration\n                            meeting_end = tuesday_avoid_time\n                            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n            \n            # If no slot before avoid time, check after (though Charles prefers to avoid)\n            for slot_start, slot_end in available_slots:\n                if slot_end - slot_start >= duration:\n                    meeting_start = slot_start\n                    meeting_end = meeting_start + duration\n                    # Format the time as HH:MM:HH:MM\n                    return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    # Fallback (shouldn't reach here as per problem statement)\n    return \"No time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_657"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to check\n    days = ['Monday', 'Tuesday']\n\n    # Shirley's blocked times in minutes since midnight\n    shirley_blocked = {\n        'Monday': [\n            (10 * 60 + 30, 11 * 60),    # 10:30-11:00\n            (12 * 60, 12 * 60 + 30),    # 12:00-12:30\n            (16 * 60, 16 * 60 + 30),    # 16:00-16:30\n        ],\n        'Tuesday': [\n            (9 * 60 + 30, 10 * 60),     # 9:30-10:00\n        ]\n    }\n\n    # Albert's busy times in minutes since midnight\n    albert_busy = {\n        'Monday': [\n            (9 * 60, 17 * 60),          # 9:00-17:00 (entire day)\n        ],\n        'Tuesday': [\n            (9 * 60 + 30, 11 * 60),     # 9:30-11:00\n            (11 * 60 + 30, 12 * 60 + 30),  # 11:30-12:30\n            (13 * 60, 16 * 60),        # 13:00-16:00\n            (16 * 60 + 30, 17 * 60),    # 16:30-17:00\n        ]\n    }\n\n    # Shirley's preference: not after 10:30 on Tuesday\n    shirley_preference = {\n        'Tuesday': (work_start, 10 * 60 + 30)\n    }\n\n    # Iterate through each day\n    for day in days:\n        if day == 'Monday':\n            # Albert is busy all day on Monday\n            continue\n\n        # Get Shirley's available slots on Tuesday\n        shirley_slots = []\n        prev_end = work_start\n        for block in sorted(shirley_blocked.get(day, [])):\n            start, end = block\n            if start > prev_end:\n                shirley_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            shirley_slots.append((prev_end, work_end))\n\n        # Apply Shirley's preference for Tuesday\n        if day in shirley_preference:\n            pref_start, pref_end = shirley_preference[day]\n            shirley_slots = [(max(slot_start, pref_start), min(slot_end, pref_end)) \n                            for slot_start, slot_end in shirley_slots \n                            if slot_start < pref_end and slot_end > pref_start]\n\n        # Get Albert's available slots on Tuesday\n        albert_slots = []\n        prev_end = work_start\n        for block in sorted(albert_busy.get(day, [])):\n            start, end = block\n            if start > prev_end:\n                albert_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            albert_slots.append((prev_end, work_end))\n\n        # Find overlapping slots\n        for s_slot in shirley_slots:\n            for a_slot in albert_slots:\n                overlap_start = max(s_slot[0], a_slot[0])\n                overlap_end = min(s_slot[1], a_slot[1])\n                if overlap_end - overlap_start >= meeting_duration:\n                    # Found a suitable time\n                    start_time = overlap_start\n                    end_time = start_time + meeting_duration\n                    # Format as HH:MM:HH:MM\n                    return f\"{start_time // 60:02d}:{start_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_658"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Barbara's busy times on Tuesday in minutes\n    barbara_busy_tuesday = [\n        (10 * 60, 10 * 60 + 30),    # 10:00-10:30\n        (15 * 60 + 30, 16 * 60),    # 15:30-16:00\n        (16 * 60 + 30, 17 * 60)     # 16:30-17:00\n    ]\n    \n    # Jose's busy times on Tuesday in minutes\n    jose_busy_tuesday = [\n        (9 * 60 + 30, 12 * 60),     # 9:30-12:00\n        (13 * 60, 17 * 60)          # 13:00-17:00\n    ]\n    \n    # Combine and sort all busy intervals for Tuesday\n    all_busy = barbara_busy_tuesday + jose_busy_tuesday\n    all_busy.sort()\n    \n    # Find free intervals on Tuesday\n    free_intervals = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_intervals.append((previous_end, work_end))\n    \n    # Check for a 1-hour (60-minute) slot in the free intervals\n    meeting_duration = 60\n    for start, end in free_intervals:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_659"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define the days to consider\n    days = ['Monday', 'Tuesday']\n    \n    # Diana's constraints: can't meet on Tuesday, so only Monday\n    diana_available_days = ['Monday']\n    \n    # Samantha's meetings and constraints\n    samantha_meetings = {\n        'Monday': [\n            (9 * 60 + 30, 10 * 60 + 30),  # 9:30-10:30\n            (11 * 60 + 30, 12 * 60 + 30),  # 11:30-12:30\n            (13 * 60, 15 * 60),            # 13:00-15:00\n            (15 * 60 + 30, 16 * 60)        # 15:30-16:00\n        ],\n        'Tuesday': [\n            (9 * 60, 9 * 60 + 30),         # 9:00-9:30\n            (10 * 60, 10 * 60 + 30),       # 10:00-10:30\n            (11 * 60, 11 * 60 + 30),       # 11:00-11:30\n            (13 * 60, 13 * 60 + 30),      # 13:00-13:30\n            (14 * 60 + 30, 17 * 60)        # 14:30-17:00\n        ]\n    }\n    \n    # Samantha doesn't want to meet on Monday after 14:30\n    samantha_monday_cutoff = 14 * 60 + 30  # 14:30\n    \n    # Iterate over possible days (only Monday for Diana)\n    for day in diana_available_days:\n        if day == 'Monday':\n            # Get Samantha's meetings on Monday\n            meetings = samantha_meetings[day]\n            # Add the cutoff as a pseudo-meeting\n            meetings.append((samantha_monday_cutoff, work_end))\n            # Sort meetings by start time\n            meetings.sort()\n            \n            # Find available slots\n            prev_end = work_start\n            available_slots = []\n            for meeting in meetings:\n                start, end = meeting\n                if start > prev_end:\n                    available_slots.append((prev_end, start))\n                prev_end = max(prev_end, end)\n            \n            # Check for a 1-hour slot\n            for slot in available_slots:\n                start, end = slot\n                if end - start >= 60:  # 1 hour\n                    # Convert to HH:MM format\n                    start_hh = start // 60\n                    start_mm = start % 60\n                    end_hh = (start + 60) // 60\n                    end_mm = (start + 60) % 60\n                    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_660"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Benjamin's constraints on Monday (can't meet after 10:30)\n    benjamin_monday_end = 10 * 60 + 30  # 10:30 in minutes\n    \n    # Benjamin's meetings on Monday (14:00-15:00)\n    benjamin_monday_busy = [(14 * 60, 15 * 60)]\n    \n    # Cheryl's busy times on Monday (in minutes)\n    cheryl_monday_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60 + 30),\n        (14 * 60, 15 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    # Cheryl's busy times on Tuesday (all day)\n    cheryl_tuesday_busy = [\n        (9 * 60 + 30, 11 * 60 + 30),\n        (12 * 60, 17 * 60)\n    ]\n    \n    # Check Monday first (since Tuesday is fully blocked for Cheryl)\n    # Generate all possible 1-hour slots on Monday within work hours\n    for start in range(work_start, work_end - 60 + 1, 30):  # Check every 30 minutes\n        end = start + 60\n        # Check Benjamin's constraints (can't meet after 10:30 on Monday)\n        if end > benjamin_monday_end:\n            continue\n        # Check Benjamin's busy times\n        benjamin_available = True\n        for busy_start, busy_end in benjamin_monday_busy:\n            if not (end <= busy_start or start >= busy_end):\n                benjamin_available = False\n                break\n        if not benjamin_available:\n            continue\n        # Check Cheryl's busy times\n        cheryl_available = True\n        for busy_start, busy_end in cheryl_monday_busy:\n            if not (end <= busy_start or start >= busy_end):\n                cheryl_available = False\n                break\n        if cheryl_available:\n            # Format the time as HH:MM:HH:MM\n            return f\"{start // 60:02d}:{start % 60:02d}:{end // 60:02d}:{end % 60:02d}\"\n    \n    # No time found (though the problem states there is a solution)\n    return \"No time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_661"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(gary_schedule, david_schedule, work_hours_start, work_hours_end, days, duration_hours):\n    for day in days:\n        # Initialize available time for the day\n        available_start = work_hours_start\n        available_end = work_hours_end\n        \n        # Get blocked times for Gary and David for the day\n        gary_blocked = gary_schedule.get(day, [])\n        david_blocked = david_schedule.get(day, [])\n        \n        # Combine and sort all blocked times\n        all_blocked = sorted(gary_blocked + david_blocked, key=lambda x: x[0])\n        \n        # Iterate through blocked times to find available slots\n        current_time = available_start\n        for block_start, block_end in all_blocked:\n            if block_start > current_time:\n                # Check if the slot is long enough\n                if (block_start - current_time) >= duration_hours:\n                    return f\"{day} {current_time:02d}:00:{current_time + duration_hours:02d}:00\"\n            current_time = max(current_time, block_end)\n        \n        # Check the remaining time after the last block\n        if (available_end - current_time) >= duration_hours:\n            return f\"{day} {current_time:02d}:00:{current_time + duration_hours:02d}:00\"\n    \n    return \"No suitable time found\"\n\n# Define work hours and meeting duration\nwork_hours_start = 9\nwork_hours_end = 17\nduration_hours = 1\ndays = ['Monday', 'Tuesday']\n\n# Define blocked schedules\ngary_schedule = {\n    'Monday': [(9.5, 10), (11, 13), (14, 14.5), (16.5, 17)],\n    'Tuesday': [(9, 9.5), (10.5, 11), (14.5, 16)]\n}\n\ndavid_schedule = {\n    'Monday': [(9, 9.5), (10, 13), (14.5, 16.5)],\n    'Tuesday': [(9, 9.5), (10, 10.5), (11, 12.5), (13, 14.5), (15, 16), (16.5, 17)]\n}\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(gary_schedule, david_schedule, work_hours_start, work_hours_end, days, duration_hours)\nprint(meeting_time.split()[-1].replace('.', ':'))\n```",
            "count": "calendar_scheduling_example_662"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define the days to consider\n    days = ['Monday', 'Tuesday']\n    \n    # Jordan's constraints: Not Monday, not Tuesday after 12:00\n    # Since Jordan has no meetings, their available times are:\n    # Tuesday 9:00 to 12:00\n    \n    # Amber's meetings on Tuesday:\n    amber_tuesday_meetings = [\n        (10 * 60 + 30, 11 * 60 + 30),  # 10:30-11:30\n        (12 * 60, 12 * 60 + 30),        # 12:00-12:30\n        (13 * 60 + 30, 14 * 60),        # 13:30-14:00\n        (14 * 60 + 30, 15 * 60),        # 14:30-15:00\n        (15 * 60 + 30, 16 * 60),        # 15:30-16:00\n        (16 * 60 + 30, 17 * 60)         # 16:30-17:00\n    ]\n    \n    # Jordan's available time on Tuesday: 9:00-12:00\n    # Amber's available time on Tuesday is between meetings in the 9:00-12:00 window\n    # Amber's Tuesday meetings in this window: 10:30-11:30, 12:00-12:30\n    # So Amber's free slots on Tuesday 9:00-12:00 are:\n    # 9:00-10:30 and 11:30-12:00\n    \n    # Check 9:00-10:30 (duration 90 minutes, enough for 30 minutes)\n    if 30 <= (10 * 60 + 30) - (9 * 60):\n        return \"09:00:09:30\"\n    \n    # Check 11:30-12:00 (duration 30 minutes, exact match)\n    if 30 <= (12 * 60) - (11 * 60 + 30):\n        return \"11:30:12:00\"\n    \n    # If no slot found (though the problem states a solution exists)\n    return \"No time found\"\n\n# Output the proposed time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_663"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Define busy intervals in minutes since midnight for each day and participant\n    roger_busy = {\n        'Monday': [(11 * 60, 11 * 60 + 30), (12 * 60 + 30, 13 * 60 + 30)],\n        'Tuesday': [(12 * 60 + 30, 13 * 60)]\n    }\n    \n    logan_busy = {\n        'Monday': [(9 * 60, 9 * 60 + 30), (10 * 60, 13 * 60), (13 * 60 + 30, 16 * 60)],\n        'Tuesday': [(9 * 60, 14 * 60), (15 * 60, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)]\n    }\n\n    # Days to consider, prioritizing Tuesday due to Roger's preference\n    days = ['Tuesday', 'Monday']\n\n    for day in days:\n        # Collect all busy intervals for the day\n        busy_intervals = []\n        busy_intervals.extend(roger_busy.get(day, []))\n        busy_intervals.extend(logan_busy.get(day, []))\n        \n        # Sort busy intervals by start time\n        busy_intervals.sort()\n\n        # Find free slots\n        prev_end = work_start\n        free_slots = []\n        for start, end in busy_intervals:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n\n        # Check for a suitable slot\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= meeting_duration:\n                # Found a suitable slot\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_664"
        },
        {
            "final_program_time": "{15:00:16:00}",
            "expected_time": "{15:00:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Sophia's blocked times on Monday in minutes (since Laura can't meet on Tuesday)\n    sophia_blocked_monday = [\n        (9 * 60, 10 * 60 + 30),   # 9:00-10:30\n        (11 * 60 + 30, 12 * 60),  # 11:30-12:00\n        (12 * 60 + 30, 14 * 60),  # 12:30-14:00\n        (16 * 60 + 30, 17 * 60)   # 16:30-17:00\n    ]\n\n    # Laura's blocked times on Monday in minutes\n    laura_blocked_monday = [\n        (9 * 60 + 30, 12 * 60),   # 9:30-12:00\n        (12 * 60 + 30, 15 * 60),  # 12:30-15:00\n        (16 * 60 + 30, 17 * 60)   # 16:30-17:00\n    ]\n\n    # Combine and sort all blocked times for Monday\n    all_blocked = sophia_blocked_monday + laura_blocked_monday\n    all_blocked.sort()\n\n    # Find free slots on Monday\n    free_slots = []\n    prev_end = work_start\n\n    for start, end in all_blocked:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n\n    if work_end > prev_end:\n        free_slots.append((prev_end, work_end))\n\n    # Check each free slot for availability\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No available time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_665"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to consider\n    days = ['Monday', 'Tuesday']\n\n    # Define busy slots for each person in minutes since midnight\n    matthew_busy = {\n        'Monday': [(9 * 60, 9 * 60 + 30), (14 * 60, 15 * 60), (16 * 60 + 30, 17 * 60)],\n        'Tuesday': [(12 * 60 + 30, 13 * 60 + 30), (14 * 60, 14 * 60 + 30), (15 * 60 + 30, 16 * 60)]\n    }\n\n    jennifer_busy = {\n        'Monday': [(10 * 60 + 30, 11 * 60 + 30), (12 * 60 + 30, 14 * 60), (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 9 * 60 + 30), (11 * 60 + 30, 12 * 60), (13 * 60, 13 * 60 + 30), (14 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)]\n    }\n\n    # Apply preferences\n    # Matthew would rather not meet on Monday\n    preferred_days = ['Tuesday']\n    \n    # Jennifer cannot meet on Tuesday before 13:00\n    jennifer_tuesday_before_13 = (9 * 60, 13 * 60)\n    jennifer_busy['Tuesday'].append(jennifer_tuesday_before_13)\n\n    # Check available slots on preferred day (Tuesday)\n    day = 'Tuesday'\n    available_slots = []\n\n    # Generate all possible slots within work hours\n    for start in range(work_start, work_end - meeting_duration + 1, 15):  # check every 15 minutes\n        end = start + meeting_duration\n        slot_ok = True\n\n        # Check Matthew's availability\n        for busy_start, busy_end in matthew_busy[day]:\n            if not (end <= busy_start or start >= busy_end):\n                slot_ok = False\n                break\n\n        # Check Jennifer's availability\n        if slot_ok:\n            for busy_start, busy_end in jennifer_busy[day]:\n                if not (end <= busy_start or start >= busy_end):\n                    slot_ok = False\n                    break\n\n        if slot_ok:\n            available_slots.append((start, end))\n\n    if available_slots:\n        # Pick the first available slot\n        start, end = available_slots[0]\n        # Format as HH:MM:HH:MM\n        start_time = f\"{start // 60:02d}:{start % 60:02d}\"\n        end_time = f\"{end // 60:02d}:{end % 60:02d}\"\n        return f\"{start_time}:{end_time}\"\n    else:\n        return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_666"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Define days to check\n    days = ['Monday', 'Tuesday']\n\n    # Define busy times in minutes since midnight\n    busy_times = {\n        'Willie': {\n            'Monday': [(15 * 60 + 30, 16 * 60)],  # 15:30-16:00\n            'Tuesday': [(12 * 60, 12 * 60 + 30)]  # 12:00-12:30\n        },\n        'Mark': {\n            'Monday': [\n                (9 * 60 + 30, 10 * 60),    # 9:30-10:00\n                (11 * 60, 13 * 60),        # 11:00-13:00\n                (13 * 60 + 30, 14 * 60),   # 13:30-14:00\n                (15 * 60, 17 * 60)        # 15:00-17:00\n            ],\n            'Tuesday': [\n                (9 * 60, 11 * 60),         # 9:00-11:00\n                (11 * 60 + 30, 12 * 60),   # 11:30-12:00\n                (12 * 60 + 30, 15 * 60 + 30),  # 12:30-15:30\n                (16 * 60, 16 * 60 + 30)    # 16:00-16:30\n            ]\n        }\n    }\n\n    meeting_duration = 30  # minutes\n\n    for day in days:\n        # Combine all busy times for both participants on this day\n        all_busy = busy_times['Willie'].get(day, []) + busy_times['Mark'].get(day, [])\n        all_busy.sort()\n\n        # Check available slots\n        prev_end = work_start\n        for start, end in all_busy:\n            if start > prev_end and (start - prev_end) >= meeting_duration:\n                # Found a suitable slot\n                return f\"{prev_end // 60:02d}:{prev_end % 60:02d}:{(prev_end + meeting_duration) // 60:02d}:{(prev_end + meeting_duration) % 60:02d}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy time\n        if work_end - prev_end >= meeting_duration:\n            return f\"{prev_end // 60:02d}:{prev_end % 60:02d}:{(prev_end + meeting_duration) // 60:02d}:{(prev_end + meeting_duration) % 60:02d}\"\n\n    return \"No time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_667"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday']\n    \n    # Define participants' blocked times in minutes since midnight\n    blocked_times = {\n        'Beverly': {\n            'Monday': [(14 * 60, 14 * 60 + 30), (15 * 60 + 30, 16 * 60)],\n            'Tuesday': [(10 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60)]\n        },\n        'Joshua': {\n            'Monday': [\n                (9 * 60, 10 * 60),\n                (10 * 60 + 30, 11 * 60),\n                (11 * 60 + 30, 12 * 60),\n                (13 * 60, 14 * 60),\n                (14 * 60 + 30, 15 * 60),\n                (15 * 60 + 30, 16 * 60)\n            ],\n            'Tuesday': [\n                (9 * 60, 14 * 60),\n                (14 * 60 + 30, 15 * 60 + 30),\n                (16 * 60, 17 * 60)\n            ]\n        }\n    }\n    \n    # Beverly's preference: not after 13:00 on Monday\n    beverly_preference = {\n        'Monday': (13 * 60, work_end)\n    }\n    \n    # Check each day for available slots\n    for day in days:\n        # Collect all blocked times for both participants on this day\n        all_blocked = []\n        for person in blocked_times:\n            if day in blocked_times[person]:\n                all_blocked.extend(blocked_times[person][day])\n        \n        # Add Beverly's preference as a blocked time on Monday\n        if day == 'Monday':\n            all_blocked.append(beverly_preference['Monday'])\n        \n        # Sort blocked times by start time\n        all_blocked.sort()\n        \n        # Find available slots\n        available_slots = []\n        prev_end = work_start\n        \n        for start, end in all_blocked:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n        \n        # Check for a 1-hour slot\n        for start, end in available_slots:\n            if end - start >= 60:\n                meeting_start = start\n                meeting_end = meeting_start + 60\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_668"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Jean's busy times in minutes (Monday is fully free)\n    jean_busy_tuesday = [\n        (11 * 60 + 30, 12 * 60),      # 11:30-12:00\n        (16 * 60, 16 * 60 + 30)       # 16:00-16:30\n    ]\n\n    # Doris's busy times in minutes\n    doris_busy_monday = [\n        (9 * 60, 11 * 60 + 30),       # 9:00-11:30\n        (12 * 60, 12 * 60 + 30),      # 12:00-12:30\n        (13 * 60 + 30, 16 * 60),       # 13:30-16:00\n        (16 * 60 + 30, 17 * 60)       # 16:30-17:00\n    ]\n    doris_busy_tuesday = [\n        (9 * 60, 17 * 60)             # 9:00-17:00 (entire day)\n    ]\n\n    # Doris prefers not to meet on Monday after 14:00\n    doris_preferred_end_monday = 14 * 60  # 14:00\n\n    # Check Monday first (Doris's preference)\n    free_slots_monday = []\n    # Generate time slots for Monday\n    previous_end = work_start\n    for start, end in sorted(doris_busy_monday):\n        if start > previous_end:\n            free_slots_monday.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if work_end > previous_end:\n        free_slots_monday.append((previous_end, work_end))\n\n    # Filter slots that are >= meeting_duration and before 14:00\n    possible_slots_monday = []\n    for start, end in free_slots_monday:\n        if end <= doris_preferred_end_monday and (end - start) >= meeting_duration:\n            possible_slots_monday.append((start, end))\n        elif start < doris_preferred_end_monday:\n            adjusted_end = min(end, doris_preferred_end_monday)\n            if (adjusted_end - start) >= meeting_duration:\n                possible_slots_monday.append((start, adjusted_end))\n\n    # Jean is free all day on Monday, so any slot in possible_slots_monday works\n    if possible_slots_monday:\n        chosen_start = possible_slots_monday[0][0]\n        chosen_end = chosen_start + meeting_duration\n        # Format as HH:MM:HH:MM\n        return f\"{chosen_start // 60:02d}:{chosen_start % 60:02d}:{chosen_end // 60:02d}:{chosen_end % 60:02d}\"\n\n    # If no Monday slot, check Tuesday (though Doris is fully busy)\n    # But according to the task, a solution exists, so Monday must have a slot\n    return \"No time found\"  # Should not reach here\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_669"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert blocked times to minutes since midnight for easier comparison\n    # Monday blocked times for Jack\n    jack_monday_blocked = [\n        (9 * 60 + 30, 10 * 60),      # 9:30-10:00\n        (12 * 60 + 30, 13 * 60 + 30), # 12:30-13:30\n        (14 * 60, 15 * 60),           # 14:00-15:00\n        (16 * 60, 16 * 60 + 30),      # 16:00-16:30\n    ]\n    \n    # Tuesday blocked times for Jack (but Jack doesn't want to meet on Tuesday)\n    \n    # Monday blocked times for Juan\n    juan_monday_blocked = [\n        (10 * 60 + 30, 12 * 60),      # 10:30-12:00\n        (13 * 60, 13 * 60 + 30),      # 13:00-13:30\n        (14 * 60 + 30, 15 * 60),      # 14:30-15:00\n        (15 * 60 + 30, 16 * 60),      # 15:30-16:00\n        (16 * 60 + 30, 17 * 60),      # 16:30-17:00\n    ]\n    \n    # Juan cannot meet on Monday after 13:00, so we adjust his Monday blocked times\n    juan_monday_blocked_adjusted = []\n    for start, end in juan_monday_blocked:\n        if start >= 13 * 60:\n            juan_monday_blocked_adjusted.append((13 * 60, 17 * 60))  # Block entire afternoon\n            break\n        else:\n            juan_monday_blocked_adjusted.append((start, end))\n    \n    # Combine all blocked times for Monday (Jack and Juan)\n    all_blocked = []\n    for block in jack_monday_blocked:\n        all_blocked.append(block)\n    for block in juan_monday_blocked_adjusted:\n        all_blocked.append(block)\n    \n    # Sort blocked times by start time\n    all_blocked.sort()\n    \n    # Find available slots on Monday\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in all_blocked:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Check for a 30-minute slot\n    meeting_duration = 30\n    for start, end in available_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_670"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{10:00:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday']\n    \n    # Define participants' busy times in minutes since midnight\n    anthony_busy = {\n        'Monday': [(12 * 60, 12 * 60 + 30), (13 * 60 + 30, 14 * 60)],\n        'Tuesday': [(10 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60), (13 * 60, 13 * 60 + 30), (16 * 60 + 30, 17 * 60)]\n    }\n    \n    jacob_busy = {\n        'Monday': [(9 * 60, 10 * 60), (11 * 60, 12 * 60), (12 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Tuesday': [(10 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60), (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)]\n    }\n    \n    # Anthony cannot meet on Tuesday\n    available_days = ['Monday']\n    \n    meeting_duration = 60  # 1 hour in minutes\n    \n    for day in available_days:\n        # Collect all busy intervals for both participants on this day\n        busy_intervals = anthony_busy.get(day, []) + jacob_busy.get(day, [])\n        busy_intervals.sort()\n        \n        # Merge overlapping or adjacent intervals\n        merged = []\n        for start, end in busy_intervals:\n            if not merged:\n                merged.append((start, end))\n            else:\n                last_start, last_end = merged[-1]\n                if start <= last_end:\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged[-1] = (new_start, new_end)\n                else:\n                    merged.append((start, end))\n        \n        # Check available slots before first busy interval, between intervals, and after last\n        prev_end = work_start\n        for start, end in merged:\n            if start > prev_end:\n                available_start = prev_end\n                available_end = start\n                if available_end - available_start >= meeting_duration:\n                    # Found a suitable slot\n                    meeting_start = available_start\n                    meeting_end = meeting_start + meeting_duration\n                    return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy interval\n        if work_end - prev_end >= meeting_duration:\n            meeting_start = prev_end\n            meeting_end = meeting_start + meeting_duration\n            return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_671"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday']\n    \n    # Define busy intervals in minutes since midnight\n    harold_busy = {\n        'Monday': [\n            (9 * 60 + 30, 10 * 60),      # 9:30-10:00\n            (12 * 60, 12 * 60 + 30),      # 12:00-12:30\n            (13 * 60 + 30, 14 * 60),     # 13:30-14:00\n            (14 * 60 + 30, 15 * 60 + 30)  # 14:30-15:30\n        ],\n        'Tuesday': [\n            (10 * 60 + 30, 11 * 60),     # 10:30-11:00\n            (11 * 60 + 30, 12 * 60),      # 11:30-12:00\n            (12 * 60 + 30, 13 * 60),     # 12:30-13:00\n            (14 * 60 + 30, 15 * 60),      # 14:30-15:00\n            (15 * 60 + 30, 16 * 60)       # 15:30-16:00\n        ]\n    }\n    \n    donna_busy = {\n        'Monday': [\n            (9 * 60, 11 * 60),            # 9:00-11:00\n            (12 * 60 + 30, 16 * 60)       # 12:30-16:00\n        ],\n        'Tuesday': [\n            (9 * 60, 10 * 60 + 30),       # 9:00-10:30\n            (12 * 60, 17 * 60)             # 12:00-17:00\n        ]\n    }\n    \n    # Harold's constraints: not after 12:30 on Monday\n    harold_constraints = {\n        'Monday': (None, 12 * 60 + 30),\n        'Tuesday': (None, None)\n    }\n    \n    # Donna's constraints: avoid Tuesday if possible\n    donna_preference = 'Monday'\n    \n    # Meeting duration in minutes\n    meeting_duration = 30\n    \n    # Check Monday first (Donna's preference)\n    for day in days:\n        if day == 'Tuesday' and donna_preference == 'Monday':\n            continue  # Skip Tuesday if Donna prefers Monday\n        \n        # Get constraints for the day\n        harold_max_time = harold_constraints[day][1] if harold_constraints[day][1] else work_end\n        \n        # Combine busy intervals for both participants\n        combined_busy = harold_busy[day] + donna_busy[day]\n        combined_busy.sort()  # Sort by start time\n        \n        # Find free slots\n        prev_end = work_start\n        free_slots = []\n        \n        for start, end in combined_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy interval\n        if prev_end < harold_max_time:\n            free_slots.append((prev_end, harold_max_time))\n        \n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            available_start = max(slot_start, work_start)\n            available_end = min(slot_end, harold_max_time)\n            \n            if available_end - available_start >= meeting_duration:\n                # Found a suitable time\n                meeting_start = available_start\n                meeting_end = meeting_start + meeting_duration\n                \n                # Convert back to HH:MM format\n                def format_time(minutes):\n                    hours = minutes // 60\n                    mins = minutes % 60\n                    return f\"{hours:02d}:{mins:02d}\"\n                \n                return f\"{format_time(meeting_start)}:{format_time(meeting_end)}\"\n    \n    # If Monday didn't work, check Tuesday\n    for day in ['Tuesday']:\n        # Get constraints for the day\n        harold_max_time = harold_constraints[day][1] if harold_constraints[day][1] else work_end\n        \n        # Combine busy intervals for both participants\n        combined_busy = harold_busy[day] + donna_busy[day]\n        combined_busy.sort()  # Sort by start time\n        \n        # Find free slots\n        prev_end = work_start\n        free_slots = []\n        \n        for start, end in combined_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy interval\n        if prev_end < harold_max_time:\n            free_slots.append((prev_end, harold_max_time))\n        \n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            available_start = max(slot_start, work_start)\n            available_end = min(slot_end, harold_max_time)\n            \n            if available_end - available_start >= meeting_duration:\n                # Found a suitable time\n                meeting_start = available_start\n                meeting_end = meeting_start + meeting_duration\n                \n                # Convert back to HH:MM format\n                def format_time(minutes):\n                    hours = minutes // 60\n                    mins = minutes % 60\n                    return f\"{hours:02d}:{mins:02d}\"\n                \n                return f\"{format_time(meeting_start)}:{format_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_672"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours for Tuesday (since Patricia doesn't want Monday)\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # James's busy times on Tuesday in minutes since midnight\n    james_busy = [\n        (10 * 60, 11 * 60 + 30),  # 10:00-11:30\n        (15 * 60, 15 * 60 + 30)    # 15:00-15:30\n    ]\n\n    # Patricia's busy times on Tuesday in minutes since midnight\n    patricia_busy = [\n        (9 * 60, 11 * 60),         # 9:00-11:00\n        (11 * 60 + 30, 12 * 60 + 30),  # 11:30-12:30\n        (13 * 60, 14 * 60 + 30),   # 13:00-14:30\n        (15 * 60, 16 * 60 + 30)    # 15:00-16:30\n    ]\n\n    # Combine and sort all busy intervals\n    all_busy = james_busy + patricia_busy\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy intervals\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check the time after the last busy interval until work_end\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that is at least 30 minutes and meets Patricia's constraint (before 16:30)\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration and end <= 16 * 60 + 30:\n            # Convert start time back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = (start + meeting_duration) // 60\n            end_mm = (start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_673"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Elizabeth's busy times on Tuesday (in minutes since midnight)\n    elizabeth_busy_tuesday = [\n        (10 * 60 + 30, 11 * 60),  # 10:30-11:00\n        (15 * 60 + 30, 16 * 60)    # 15:30-16:00\n    ]\n    \n    # Mason's busy times on Tuesday (in minutes since midnight)\n    mason_busy_tuesday = [\n        (9 * 60, 16 * 60 + 30)  # 9:00-16:30\n    ]\n    \n    # Combine and sort all busy intervals for Tuesday\n    busy_intervals = elizabeth_busy_tuesday + mason_busy_tuesday\n    busy_intervals.sort()\n    \n    # Find free intervals on Tuesday\n    free_intervals = []\n    previous_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_intervals.append((previous_end, work_end))\n    \n    # Check for a 30-minute slot in the free intervals\n    meeting_duration = 30\n    for start, end in free_intervals:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_674"
        },
        {
            "final_program_time": "{12:30:13:30}",
            "expected_time": "{12:30:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Larry's busy times on Tuesday in minutes (since Monday is not possible)\n    larry_busy_tuesday = [\n        (9 * 60, 11 * 60 + 30),   # 9:00-11:30\n        (12 * 60, 12 * 60 + 30),   # 12:00-12:30\n        (14 * 60 + 30, 15 * 60),   # 14:30-15:00\n        (15 * 60 + 30, 16 * 60),   # 15:30-16:00\n    ]\n    \n    # Larry cannot meet after 15:30 on Tuesday, so adjust work_end\n    tuesday_work_end = 15 * 60 + 30  # 15:30\n    \n    # Generate available slots for Tuesday\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in sorted(larry_busy_tuesday):\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    # Check the slot after the last busy time\n    if prev_end < tuesday_work_end:\n        available_slots.append((prev_end, tuesday_work_end))\n    \n    # Find the first available 1-hour (60-minute) slot\n    meeting_duration = 60\n    for start, end in available_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time found\"\n\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_675"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{10:00:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(emily_schedule, lawrence_schedule, work_hours, duration_hours, days):\n    for day in days:\n        emily_busy = emily_schedule.get(day, [])\n        lawrence_busy = lawrence_schedule.get(day, [])\n        \n        # Combine and sort all busy intervals for the day\n        all_busy = emily_busy + lawrence_busy\n        all_busy.sort()\n        \n        # Find free intervals\n        free_intervals = []\n        start_work = work_hours[0]\n        end_work = work_hours[1]\n        \n        prev_end = start_work\n        for busy_start, busy_end in all_busy:\n            if busy_start > prev_end:\n                free_intervals.append((prev_end, busy_start))\n            prev_end = max(prev_end, busy_end)\n        if prev_end < end_work:\n            free_intervals.append((prev_end, end_work))\n        \n        # Check if any free interval can accommodate the meeting\n        for interval in free_intervals:\n            start, end = interval\n            available_duration = (end - start).total_seconds() / 3600\n            if available_duration >= duration_hours:\n                meeting_start = start\n                meeting_end = start + timedelta(hours=duration_hours)\n                return f\"{meeting_start.strftime('%H:%M')}:{meeting_end.strftime('%H:%M')}\"\n    return None\n\n# Define schedules\nfrom datetime import datetime, timedelta\n\nemily_schedule = {\n    'Monday': [\n        (datetime.strptime('10:00', '%H:%M'), datetime.strptime('10:30', '%H:%M')),\n        (datetime.strptime('12:30', '%H:%M'), datetime.strptime('14:30', '%H:%M'))\n    ],\n    'Tuesday': [\n        (datetime.strptime('14:00', '%H:%M'), datetime.strptime('15:00', '%H:%M')),\n        (datetime.strptime('15:30', '%H:%M'), datetime.strptime('16:00', '%H:%M'))\n    ]\n}\n\nlawrence_schedule = {\n    'Monday': [\n        (datetime.strptime('9:00', '%H:%M'), datetime.strptime('17:00', '%H:%M'))\n    ],\n    'Tuesday': [\n        (datetime.strptime('9:00', '%H:%M'), datetime.strptime('10:00', '%H:%M')),\n        (datetime.strptime('11:00', '%H:%M'), datetime.strptime('12:00', '%H:%M')),\n        (datetime.strptime('12:30', '%H:%M'), datetime.strptime('13:30', '%H:%M')),\n        (datetime.strptime('14:00', '%H:%M'), datetime.strptime('17:00', '%H:%M'))\n    ]\n}\n\n# Define work hours and meeting duration\nwork_hours = (datetime.strptime('9:00', '%H:%M'), datetime.strptime('17:00', '%H:%M'))\nduration_hours = 1\ndays = ['Monday', 'Tuesday']\n\n# Find meeting time\nmeeting_time = find_meeting_time(emily_schedule, lawrence_schedule, work_hours, duration_hours, days)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_676"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Define days to check\n    days = ['Monday', 'Tuesday']\n\n    # Define Lisa's and Lauren's schedules and constraints\n    lisa_schedule = {\n        'Monday': [\n            (11 * 60, 11 * 60 + 30),    # 11:00-11:30\n            (13 * 60 + 30, 14 * 60),     # 13:30-14:00\n            (15 * 60, 15 * 60 + 30),     # 15:00-15:30\n            (16 * 60, 16 * 60 + 30)      # 16:00-16:30\n        ],\n        'Tuesday': [\n            (10 * 60 + 30, 11 * 60),     # 10:30-11:00\n            (15 * 60, 15 * 60 + 30)      # 15:00-15:30\n        ]\n    }\n    lisa_constraints = {\n        'Tuesday': (15 * 60 + 30, work_end)  # No meetings after 15:30 on Tuesday\n    }\n\n    lauren_schedule = {\n        'Monday': [\n            (9 * 60 + 30, 10 * 60),      # 9:30-10:00\n            (10 * 60 + 30, 13 * 60 + 30), # 10:30-13:30\n            (15 * 60, 16 * 60 + 30)      # 15:00-16:30\n        ],\n        'Tuesday': [\n            (9 * 60 + 30, 10 * 60),      # 9:30-10:00\n            (10 * 60 + 30, 11 * 60 + 30), # 10:30-11:30\n            (13 * 60 + 30, 14 * 60 + 30), # 13:30-14:30\n            (16 * 60 + 30, 17 * 60)       # 16:30-17:00\n        ]\n    }\n    lauren_constraints = {\n        'Monday': (0, work_end)  # Cannot meet on Monday (entire day blocked)\n    }\n\n    # Iterate through each day to find a suitable time\n    for day in days:\n        if day in lauren_constraints and lauren_constraints[day] == (0, work_end):\n            continue  # Skip Monday for Lauren\n\n        # Combine and sort all busy times for both participants\n        busy_times = []\n        if day in lisa_schedule:\n            busy_times.extend(lisa_schedule[day])\n        if day in lauren_schedule:\n            busy_times.extend(lauren_schedule[day])\n        busy_times.sort()\n\n        # Add constraints as busy times\n        if day in lisa_constraints:\n            busy_times.append(lisa_constraints[day])\n        if day in lauren_constraints and lauren_constraints[day] != (0, work_end):\n            busy_times.append(lauren_constraints[day])\n\n        # Merge overlapping busy times\n        merged_busy = []\n        for start, end in sorted(busy_times):\n            if not merged_busy:\n                merged_busy.append([start, end])\n            else:\n                last_start, last_end = merged_busy[-1]\n                if start <= last_end:\n                    merged_busy[-1][1] = max(end, last_end)\n                else:\n                    merged_busy.append([start, end])\n\n        # Check available slots between busy times\n        prev_end = work_start\n        for start, end in merged_busy:\n            if start - prev_end >= meeting_duration:\n                # Found a suitable slot\n                meeting_start = prev_end\n                meeting_end = meeting_start + meeting_duration\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n            prev_end = max(prev_end, end)\n\n        # Check after last busy time\n        if work_end - prev_end >= meeting_duration:\n            meeting_start = prev_end\n            meeting_end = meeting_start + meeting_duration\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_677"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday']\n    \n    # Define busy slots for each person in minutes since midnight\n    russell_busy = {\n        'Monday': [(10 * 60 + 30, 11 * 60)],  # 10:30-11:00\n        'Tuesday': [(13 * 60, 13 * 60 + 30)]  # 13:00-13:30\n    }\n    \n    alexander_busy = {\n        'Monday': [\n            (9 * 60, 11 * 60 + 30),  # 9:00-11:30\n            (12 * 60, 14 * 60 + 30),  # 12:00-14:30\n            (15 * 60, 17 * 60)        # 15:00-17:00\n        ],\n        'Tuesday': [\n            (9 * 60, 10 * 60),        # 9:00-10:00\n            (13 * 60, 14 * 60),       # 13:00-14:00\n            (15 * 60, 15 * 60 + 30),  # 15:00-15:30\n            (16 * 60, 16 * 60 + 30)  # 16:00-16:30\n        ]\n    }\n    \n    # Russell's preference: not before 13:30 on Tuesday\n    russell_preference = {\n        'Tuesday': (13 * 60 + 30, work_end)\n    }\n    \n    meeting_duration = 60  # 1 hour\n    \n    # Iterate through each day to find a suitable slot\n    for day in days:\n        # Get busy slots for both participants\n        busy_slots = russell_busy.get(day, []) + alexander_busy.get(day, [])\n        busy_slots.sort()  # Sort by start time\n        \n        # Apply Russell's preference if it's Tuesday\n        if day == 'Tuesday':\n            pref_start, pref_end = russell_preference['Tuesday']\n            current_start = max(work_start, pref_start)\n        else:\n            current_start = work_start\n        \n        current_end = work_end\n        \n        # Merge overlapping or adjacent busy slots\n        merged_slots = []\n        for start, end in busy_slots:\n            if not merged_slots:\n                merged_slots.append((start, end))\n            else:\n                last_start, last_end = merged_slots[-1]\n                if start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged_slots[-1] = (new_start, new_end)\n                else:\n                    merged_slots.append((start, end))\n        \n        # Check the time before the first busy slot\n        if merged_slots:\n            first_start, first_end = merged_slots[0]\n            available_start = current_start\n            available_end = first_start\n            if available_end - available_start >= meeting_duration:\n                # Found a suitable slot\n                meeting_start = available_start\n                meeting_end = meeting_start + meeting_duration\n                return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n        \n        # Check the time between busy slots\n        for i in range(1, len(merged_slots)):\n            prev_end = merged_slots[i-1][1]\n            curr_start = merged_slots[i][0]\n            if curr_start - prev_end >= meeting_duration:\n                meeting_start = prev_end\n                meeting_end = meeting_start + meeting_duration\n                return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n        \n        # Check the time after the last busy slot\n        if merged_slots:\n            last_start, last_end = merged_slots[-1]\n            available_start = last_end\n            available_end = current_end\n            if available_end - available_start >= meeting_duration:\n                meeting_start = available_start\n                meeting_end = meeting_start + meeting_duration\n                return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n        else:\n            # No busy slots, entire day is available\n            meeting_start = current_start\n            meeting_end = meeting_start + meeting_duration\n            return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_678"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday']\n    \n    # Define participants' schedules in minutes since midnight\n    adam_schedule = {\n        'Monday': [(15 * 60 + 30, 16 * 60 + 30)],  # 15:30-16:30\n        'Tuesday': []\n    }\n    \n    martha_schedule = {\n        'Monday': [\n            (9 * 60 + 30, 11 * 60),      # 9:30-11:00\n            (11 * 60 + 30, 14 * 60),      # 11:30-14:00\n            (14 * 60 + 30, 16 * 60)       # 14:30-16:00\n        ],\n        'Tuesday': [\n            (9 * 60, 9 * 60 + 30),        # 9:00-9:30\n            (10 * 60, 10 * 60 + 30),      # 10:00-10:30\n            (11 * 60, 14 * 60),           # 11:00-14:00\n            (15 * 60, 15 * 60 + 30),      # 15:00-15:30\n            (16 * 60, 17 * 60)           # 16:00-17:00\n        ]\n    }\n    \n    # Preferences\n    adam_preference = {'Monday': False, 'Tuesday': True}\n    martha_preference = {'Tuesday': (15 * 60, None)}  # Prefer after 15:00 on Tuesday\n    \n    meeting_duration = 30  # minutes\n    \n    # Iterate through days in order of preference (Tuesday first due to Adam's preference)\n    preferred_days_order = ['Tuesday', 'Monday']\n    \n    for day in preferred_days_order:\n        if not adam_preference[day]:\n            continue\n        \n        # Get busy times for both participants on this day\n        adam_busy = adam_schedule[day]\n        martha_busy = martha_schedule[day]\n        \n        # Combine and sort all busy intervals\n        all_busy = adam_busy + martha_busy\n        all_busy.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_hours_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_hours_end:\n            free_slots.append((prev_end, work_hours_end))\n        \n        # Check each free slot for availability and preferences\n        for slot_start, slot_end in free_slots:\n            slot_duration = slot_end - slot_start\n            if slot_duration >= meeting_duration:\n                potential_start = slot_start\n                potential_end = potential_start + meeting_duration\n                \n                # Check Martha's preference for Tuesday\n                if day == 'Tuesday' and martha_preference['Tuesday']:\n                    preferred_start, _ = martha_preference['Tuesday']\n                    if potential_start < preferred_start:\n                        continue\n                \n                # Found a suitable time\n                start_time = f\"{potential_start // 60:02d}:{potential_start % 60:02d}\"\n                end_time = f\"{potential_end // 60:02d}:{potential_end % 60:02d}\"\n                return f\"{start_time}:{end_time}\"\n    \n    # If no time found in preferred days, check Monday (even though Adam prefers not to)\n    day = 'Monday'\n    adam_busy = adam_schedule[day]\n    martha_busy = martha_schedule[day]\n    all_busy = adam_busy + martha_busy\n    all_busy.sort()\n    \n    prev_end = work_hours_start\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_hours_end:\n        free_slots.append((prev_end, work_hours_end))\n    \n    for slot_start, slot_end in free_slots:\n        slot_duration = slot_end - slot_start\n        if slot_duration >= meeting_duration:\n            potential_start = slot_start\n            potential_end = potential_start + meeting_duration\n            start_time = f\"{potential_start // 60:02d}:{potential_start % 60:02d}\"\n            end_time = f\"{potential_end // 60:02d}:{potential_end % 60:02d}\"\n            return f\"{start_time}:{end_time}\"\n    \n    return \"No suitable time found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_679"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{10:00:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(bobby_busy, jason_busy, work_hours, days, duration_hours):\n    for day in days:\n        # Initialize available time as the full work day\n        available_start = work_hours[0]\n        available_end = work_hours[1]\n        \n        # Get busy times for the current day for both participants\n        bobby_day = [slot for slot in bobby_busy if slot[0] == day]\n        jason_day = [slot for slot in jason_busy if slot[0] == day]\n        \n        # Combine and sort all busy slots for the day\n        busy_slots = []\n        for slot in bobby_day:\n            busy_slots.append((slot[1], slot[2]))\n        for slot in jason_day:\n            busy_slots.append((slot[1], slot[2]))\n        busy_slots.sort()\n        \n        # Find available slots by checking gaps between busy slots\n        current_time = available_start\n        for start, end in busy_slots:\n            if start > current_time:\n                # Check if the gap is enough for the meeting\n                if (start - current_time) >= duration_hours:\n                    return (day, current_time, current_time + duration_hours)\n            current_time = max(current_time, end)\n        \n        # Check the remaining time after the last busy slot\n        if (available_end - current_time) >= duration_hours:\n            return (day, current_time, current_time + duration_hours)\n    \n    return None\n\n# Define work hours (9:00 to 17:00 in 24-hour format)\nwork_hours = (9.0, 17.0)\ndays = ['Monday', 'Tuesday']\nduration_hours = 1.0\n\n# Define busy slots for Bobby and Jason\nbobby_busy = [\n    ('Monday', 9.5, 10.0),  # 9:30 to 10:00\n    ('Monday', 13.5, 14.5),  # 13:30 to 14:30\n    ('Tuesday', 9.0, 9.5),   # 9:00 to 9:30\n]\n\njason_busy = [\n    ('Monday', 9.0, 10.0),   # 9:00 to 10:00\n    ('Monday', 11.0, 12.5),  # 11:00 to 12:30\n    ('Monday', 13.0, 13.5),  # 13:00 to 13:30\n    ('Monday', 14.0, 17.0),  # 14:00 to 17:00\n    ('Tuesday', 9.0, 14.5),  # 9:00 to 14:30\n    ('Tuesday', 15.0, 16.0), # 15:00 to 16:00\n    ('Tuesday', 16.5, 17.0), # 16:30 to 17:00\n]\n\n# Find a meeting time\nmeeting_time = find_meeting_time(bobby_busy, jason_busy, work_hours, days, duration_hours)\n\nif meeting_time:\n    day, start, end = meeting_time\n    # Convert decimal hours to HH:MM format\n    start_hh = int(start)\n    start_mm = int((start - start_hh) * 60)\n    end_hh = int(end)\n    end_mm = int((end - end_hh) * 60)\n    print(f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_680"
        },
        {
            "final_program_time": "{16:00:17:00}",
            "expected_time": "{16:00:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Albert's busy times on Monday and Tuesday in minutes since midnight\n    albert_busy = {\n        'Monday': [(12 * 60 + 30, 13 * 60)],  # 12:30-13:00\n        'Tuesday': [(11 * 60, 12 * 60), (13 * 60, 13 * 60 + 30)]  # 11:00-12:00, 13:00-13:30\n    }\n\n    # George's busy times on Monday and Tuesday in minutes since midnight\n    george_busy = {\n        'Monday': [\n            (10 * 60 + 30, 12 * 60 + 30),  # 10:30-12:30\n            (13 * 60, 13 * 60 + 30),        # 13:00-13:30\n            (14 * 60 + 30, 15 * 60 + 30),   # 14:30-15:30\n            (16 * 60, 16 * 60 + 30)        # 16:00-16:30\n        ],\n        'Tuesday': [\n            (9 * 60, 10 * 60),              # 9:00-10:00\n            (11 * 60, 14 * 60 + 30),       # 11:00-14:30\n            (15 * 60 + 30, 16 * 60)         # 15:30-16:00\n        ]\n    }\n\n    # Constraints: Albert cannot meet on Monday, George doesn't want to meet before 16:00 on Tuesday\n    possible_days = ['Tuesday']  # Monday is excluded due to Albert's constraint\n\n    for day in possible_days:\n        # Get busy times for both participants on this day\n        busy_times = []\n        if day == 'Monday':\n            busy_times.extend(albert_busy['Monday'])\n            busy_times.extend(george_busy['Monday'])\n        elif day == 'Tuesday':\n            busy_times.extend(albert_busy['Tuesday'])\n            busy_times.extend(george_busy['Tuesday'])\n            # Apply George's constraint: no meeting before 16:00 on Tuesday\n            work_start = 16 * 60\n\n        # Sort busy times by start time\n        busy_times.sort()\n\n        # Find free slots\n        prev_end = work_start\n        free_slots = []\n        for start, end in busy_times:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n\n        # Check for a slot that can fit the meeting\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= meeting_duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_681"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Amanda's and Nathan's busy slots in minutes since midnight\n    # Since Nathan cannot meet on Monday, we only consider Tuesday\n    day = \"Tuesday\"\n\n    # Amanda's busy slots on Tuesday\n    amanda_busy = [\n        (9 * 60, 9 * 60 + 30),   # 9:00-9:30\n        (10 * 60, 10 * 60 + 30),  # 10:00-10:30\n        (11 * 60 + 30, 12 * 60),  # 11:30-12:00\n        (13 * 60 + 30, 14 * 60 + 30),  # 13:30-14:30\n        (15 * 60 + 30, 16 * 60),  # 15:30-16:00\n        (16 * 60 + 30, 17 * 60)   # 16:30-17:00\n    ]\n\n    # Nathan's busy slots on Tuesday\n    nathan_busy = [\n        (9 * 60, 10 * 60 + 30),  # 9:00-10:30\n        (11 * 60, 13 * 60),       # 11:00-13:00\n        (13 * 60 + 30, 14 * 60),  # 13:30-14:00\n        (14 * 60 + 30, 15 * 60 + 30),  # 14:30-15:30\n        (16 * 60, 16 * 60 + 30)   # 16:00-16:30\n    ]\n\n    # Amanda doesn't want to meet on Tuesday after 11:00, so we adjust work_end\n    adjusted_work_end = 11 * 60  # 11:00\n\n    # Combine all busy slots\n    all_busy = amanda_busy + nathan_busy\n    all_busy.sort()  # Sort by start time\n\n    # Find free slots\n    free_slots = []\n    prev_end = work_start\n\n    for busy_start, busy_end in all_busy:\n        if busy_start > prev_end:\n            free_slots.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n\n    if prev_end < adjusted_work_end:\n        free_slots.append((prev_end, adjusted_work_end))\n\n    # Check for a slot that can fit the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_682"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30       # minutes\n    \n    # Gary's constraints: doesn't want to meet on Monday\n    # So we only consider Tuesday\n    \n    # Judith's constraints: free all week, but prefers to avoid Tuesday after 15:30\n    # Gary's busy times on Tuesday:\n    gary_busy_tuesday = [\n        (9 * 60, 12 * 60 + 30),   # 9:00-12:30\n        (13 * 60, 14 * 60),        # 13:00-14:00\n        (14 * 60 + 30, 16 * 60),   # 14:30-16:00\n        (16 * 60 + 30, 17 * 60)    # 16:30-17:00\n    ]\n    \n    # Judith's preference: avoid Tuesday after 15:30\n    # So we consider up to 15:30 on Tuesday\n    \n    # Generate available slots for Tuesday\n    available_slots = []\n    previous_end = work_hours_start\n    \n    for busy_start, busy_end in sorted(gary_busy_tuesday):\n        if busy_start > previous_end:\n            available_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    # Check after last busy slot\n    if previous_end < min(work_hours_end, 15 * 60 + 30):\n        available_slots.append((previous_end, min(work_hours_end, 15 * 60 + 30)))\n    \n    # Find the first available slot that fits the meeting duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Format as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Execute and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_683"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Benjamin's constraints (only Tuesday, as he doesn't want Monday)\n    benjamin_busy = [\n        (14 * 60 + 30, 15 * 60)  # Tuesday 14:30-15:00\n    ]\n    \n    # Mark's constraints (only Tuesday, since Monday is excluded)\n    mark_busy = [\n        (9 * 60, 14 * 60),       # Tuesday 9:00-14:00\n        (15 * 60, 17 * 60)        # Tuesday 15:00-17:00\n    ]\n    \n    # Combine all busy times and sort\n    all_busy = benjamin_busy + mark_busy\n    all_busy.sort()\n    \n    # Find free slots on Tuesday\n    previous_end = work_start\n    for start, end in all_busy:\n        if start > previous_end:\n            # Check if the slot is at least 30 minutes\n            if start - previous_end >= 30:\n                # Found a suitable slot\n                meeting_start = previous_end\n                meeting_end = meeting_start + 30\n                # Convert back to HH:MM format\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n        previous_end = max(previous_end, end)\n    \n    # Check after the last busy slot\n    if work_end - previous_end >= 30:\n        meeting_start = previous_end\n        meeting_end = meeting_start + 30\n        return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_684"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Billy's constraints on Monday\n    billy_monday_busy = [\n        (12 * 60, 12 * 60 + 30),  # 12:00-12:30\n        (13 * 60, 13 * 60 + 30),   # 13:00-13:30\n    ]\n    billy_monday_available_start = 10 * 60 + 30  # 10:30\n\n    # Grace's constraints on Monday\n    grace_monday_busy = [\n        (9 * 60 + 30, 14 * 60 + 30),  # 9:30-14:30\n        (15 * 60, 17 * 60),            # 15:00-17:00\n    ]\n\n    # Grace's constraints on Tuesday (avoid if possible)\n    grace_tuesday_busy = [\n        (9 * 60, 10 * 60 + 30),    # 9:00-10:30\n        (11 * 60, 11 * 60 + 30),   # 11:00-11:30\n        (12 * 60, 12 * 60 + 30),   # 12:00-12:30\n        (13 * 60, 13 * 60 + 30),   # 13:00-13:30\n        (14 * 60, 16 * 60),        # 14:00-16:00\n    ]\n\n    # Check Monday first (Grace prefers to avoid Tuesday)\n    # Billy's available slots on Monday after 10:30\n    billy_monday_free = []\n    start = max(work_start, billy_monday_available_start)\n    for busy_start, busy_end in sorted(billy_monday_busy):\n        if start < busy_start:\n            billy_monday_free.append((start, busy_start))\n        start = max(start, busy_end)\n    if start < work_end:\n        billy_monday_free.append((start, work_end))\n\n    # Grace's available slots on Monday\n    grace_monday_free = []\n    start = work_start\n    for busy_start, busy_end in sorted(grace_monday_busy):\n        if start < busy_start:\n            grace_monday_free.append((start, busy_start))\n        start = max(start, busy_end)\n    if start < work_end:\n        grace_monday_free.append((start, work_end))\n\n    # Find overlapping slots on Monday\n    for b_start, b_end in billy_monday_free:\n        for g_start, g_end in grace_monday_free:\n            overlap_start = max(b_start, g_start)\n            overlap_end = min(b_end, g_end)\n            if overlap_end - overlap_start >= meeting_duration:\n                # Found a slot on Monday\n                meeting_start = overlap_start\n                meeting_end = meeting_start + meeting_duration\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    # If no slot on Monday, check Tuesday (though Grace prefers to avoid)\n    billy_tuesday_free = [(work_start, work_end)]  # No meetings on Tuesday\n\n    grace_tuesday_free = []\n    start = work_start\n    for busy_start, busy_end in sorted(grace_tuesday_busy):\n        if start < busy_start:\n            grace_tuesday_free.append((start, busy_start))\n        start = max(start, busy_end)\n    if start < work_end:\n        grace_tuesday_free.append((start, work_end))\n\n    # Find overlapping slots on Tuesday\n    for b_start, b_end in billy_tuesday_free:\n        for g_start, g_end in grace_tuesday_free:\n            overlap_start = max(b_start, g_start)\n            overlap_end = min(b_end, g_end)\n            if overlap_end - overlap_start >= meeting_duration:\n                meeting_start = overlap_start\n                meeting_end = meeting_start + meeting_duration\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No meeting time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_685"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday']\n    \n    # Define Ethan's busy times in minutes since midnight\n    ethan_busy = {\n        'Monday': [(15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Tuesday': [(12 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), \n                    (14 * 60, 14 * 60 + 30), (15 * 60 + 30, 16 * 60)]\n    }\n    \n    # Define Julia's busy times in minutes since midnight\n    julia_busy = {\n        'Monday': [(9 * 60, 11 * 60), (11 * 60 + 30, 14 * 60 + 30), \n                    (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 10 * 60), (10 * 60 + 30, 12 * 60 + 30), \n                     (13 * 60, 13 * 60 + 30), (14 * 60, 17 * 60)]\n    }\n    \n    # Ethan's constraint: Not before 13:00 on Monday\n    ethan_constraints = {\n        'Monday': (13 * 60, None)\n    }\n    \n    meeting_duration = 30  # minutes\n    \n    # Iterate through each day\n    for day in days:\n        # Get Ethan's and Julia's busy times for the day\n        e_busy = ethan_busy.get(day, [])\n        j_busy = julia_busy.get(day, [])\n        \n        # Combine and sort all busy slots\n        all_busy = e_busy + j_busy\n        all_busy.sort()\n        \n        # Determine the start time based on Ethan's constraints\n        day_start = work_start\n        if day in ethan_constraints:\n            constraint_start, _ = ethan_constraints[day]\n            day_start = max(day_start, constraint_start)\n        \n        # Check the time before the first busy slot\n        if all_busy:\n            first_busy_start, _ = all_busy[0]\n            if first_busy_start - day_start >= meeting_duration:\n                start_time = day_start\n                end_time = start_time + meeting_duration\n                if end_time <= work_end:\n                    return f\"{format_time(start_time)}:{format_time(end_time)}\"\n        \n        # Check between busy slots\n        for i in range(len(all_busy) - 1):\n            _, current_end = all_busy[i]\n            next_start, _ = all_busy[i + 1]\n            if next_start - current_end >= meeting_duration:\n                start_time = current_end\n                end_time = start_time + meeting_duration\n                if end_time <= work_end:\n                    return f\"{format_time(start_time)}:{format_time(end_time)}\"\n        \n        # Check the time after the last busy slot\n        if all_busy:\n            _, last_busy_end = all_busy[-1]\n            if work_end - last_busy_end >= meeting_duration:\n                start_time = last_busy_end\n                end_time = start_time + meeting_duration\n                if end_time <= work_end:\n                    return f\"{format_time(start_time)}:{format_time(end_time)}\"\n        else:\n            # No busy slots at all\n            start_time = day_start\n            end_time = start_time + meeting_duration\n            if end_time <= work_end:\n                return f\"{format_time(start_time)}:{format_time(end_time)}\"\n    \n    return \"No suitable time found\"\n\ndef format_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Find and print the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_686"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to check\n    days = ['Monday', 'Tuesday']\n\n    # Jerry's schedule: {day: list of busy intervals in minutes}\n    jerry_busy = {\n        'Tuesday': [\n            (9 * 60, 9 * 60 + 30),   # 9:00-9:30\n            (10 * 60, 10 * 60 + 30),  # 10:00-10:30\n            (12 * 60, 12 * 60 + 30),  # 12:00-12:30\n            (16 * 60, 16 * 60 + 30)  # 16:00-16:30\n        ]\n    }\n\n    # Edward's schedule: {day: list of busy intervals in minutes}\n    edward_busy = {\n        'Monday': [\n            (9 * 60 + 30, 10 * 60),      # 9:30-10:00\n            (10 * 60 + 30, 12 * 60),      # 10:30-12:00\n            (12 * 60 + 30, 14 * 60),     # 12:30-14:00\n            (14 * 60 + 30, 17 * 60)       # 14:30-17:00\n        ],\n        'Tuesday': [\n            (9 * 60, 17 * 60)  # 9:00-17:00 (entire day)\n        ]\n    }\n\n    # Check each day in order\n    for day in days:\n        # Get busy intervals for both participants\n        jerry_intervals = jerry_busy.get(day, [])\n        edward_intervals = edward_busy.get(day, [])\n\n        # Combine and sort all busy intervals\n        all_busy = jerry_intervals + edward_intervals\n        all_busy.sort()\n\n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n\n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n\n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            available_start = slot_start\n            available_end = slot_end\n\n            # Check if the slot can fit the meeting\n            if available_end - available_start >= meeting_duration:\n                # Convert back to HH:MM format\n                start_hh = available_start // 60\n                start_mm = available_start % 60\n                end_hh = (available_start + meeting_duration) // 60\n                end_mm = (available_start + meeting_duration) % 60\n\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_687"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:30:10:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration, days_preferred):\n    for day in days_preferred:\n        start_work, end_work = work_hours\n        current_time = start_work\n        \n        while current_time + duration <= end_work:\n            slot_end = current_time + duration\n            slot_ok = True\n            \n            for person, busy_slots in participants_busy.items():\n                if day not in busy_slots:\n                    continue\n                for busy_start, busy_end in busy_slots[day]:\n                    if not (slot_end <= busy_start or current_time >= busy_end):\n                        slot_ok = False\n                        break\n                if not slot_ok:\n                    break\n            \n            if slot_ok:\n                return f\"{day}:{current_time:02d}:{slot_end:02d}\"\n            \n            current_time += 0.5  # Assuming slots are in 30-minute increments\n        \n    return \"No suitable time found\"\n\n# Define participants' busy times\nedward_busy = {\n    \"Monday\": [(13.0, 13.5), (14.5, 15.0)],\n    \"Tuesday\": [(9.5, 10.0), (11.0, 12.0), (15.0, 15.5)]\n}\n\nangela_busy = {\n    \"Monday\": [(9.0, 9.5), (10.0, 10.5), (11.0, 12.5), (13.0, 15.0), (15.5, 16.0)],\n    \"Tuesday\": [(10.0, 10.5), (11.0, 11.5), (13.0, 13.5), (14.0, 14.5), (15.0, 17.0)]\n}\n\nparticipants_busy = {\n    \"Edward\": edward_busy,\n    \"Angela\": angela_busy\n}\n\n# Define meeting constraints\nwork_hours = (9.0, 17.0)\nduration = 0.5  # 30 minutes\ndays_preferred = [\"Monday\", \"Tuesday\"]\n\n# Find the earliest meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration, days_preferred)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_688"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday']\n    \n    # Define busy slots for each person in minutes since midnight\n    hannah_busy = {\n        'Monday': [\n            (9 * 60 + 30, 10 * 60 + 30),\n            (11 * 60 + 30, 12 * 60 + 30),\n            (13 * 60 + 30, 14 * 60),\n            (15 * 60, 15 * 60 + 30),\n            (16 * 60, 17 * 60)\n        ],\n        'Tuesday': [\n            (11 * 60, 11 * 60 + 30),\n            (12 * 60 + 30, 14 * 60),\n            (15 * 60, 15 * 60 + 30),\n            (16 * 60 + 30, 17 * 60)\n        ]\n    }\n    \n    steven_busy = {\n        'Monday': [\n            (9 * 60 + 30, 12 * 60 + 30),\n            (13 * 60, 14 * 60 + 30),\n            (15 * 60, 17 * 60)\n        ],\n        'Tuesday': [\n            (9 * 60, 10 * 60 + 30),\n            (11 * 60, 12 * 60),\n            (12 * 60 + 30, 13 * 60),\n            (13 * 60 + 30, 14 * 60),\n            (15 * 60 + 30, 16 * 60),\n            (16 * 60 + 30, 17 * 60)\n        ]\n    }\n    \n    # Check each day for available slots\n    for day in days:\n        # Combine and sort all busy slots for the day\n        busy_slots = hannah_busy[day] + steven_busy[day]\n        busy_slots.sort()\n        \n        # Merge overlapping or adjacent busy slots\n        merged_slots = []\n        for start, end in busy_slots:\n            if not merged_slots:\n                merged_slots.append([start, end])\n            else:\n                last_start, last_end = merged_slots[-1]\n                if start <= last_end:\n                    merged_slots[-1][1] = max(end, last_end)\n                else:\n                    merged_slots.append([start, end])\n        \n        # Find available slots between work hours\n        available_slots = []\n        prev_end = work_start\n        for start, end in merged_slots:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n        \n        # Check each available slot for a 60-minute window\n        for start, end in available_slots:\n            if end - start >= 60:\n                meeting_start = start\n                meeting_end = meeting_start + 60\n                # Format the time as HH:MM:HH:MM\n                start_hour = meeting_start // 60\n                start_min = meeting_start % 60\n                end_hour = meeting_end // 60\n                end_min = meeting_end % 60\n                return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_689"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Define blocked times for Doris and Carol on Monday and Tuesday\n    doris_blocked = {\n        'Monday': [(10 * 60 + 30, 11 * 60), (12 * 60 + 30, 13 * 60), (14 * 60, 14 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n        'Tuesday': [(11 * 60, 11 * 60 + 30), (16 * 60 + 30, 17 * 60)]\n    }\n    carol_blocked = {\n        'Monday': [(10 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60 + 30), (13 * 60 + 30, 14 * 60 + 30), (15 * 60 + 30, 16 * 60 + 30)],\n        'Tuesday': [(9 * 60, 10 * 60), (11 * 60, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60, 15 * 60), (15 * 60 + 30, 16 * 60 + 30)]\n    }\n\n    days = ['Monday', 'Tuesday']\n\n    for day in days:\n        # Collect all blocked times for both participants on the current day\n        all_blocked = doris_blocked.get(day, []) + carol_blocked.get(day, [])\n        # Sort blocked times by start time\n        all_blocked.sort()\n\n        # Check the time before the first blocked period\n        if len(all_blocked) > 0:\n            first_block_start = all_blocked[0][0]\n            if first_block_start - work_start >= meeting_duration:\n                # Meeting can be scheduled at the start of the day\n                start_time = work_start\n                end_time = start_time + meeting_duration\n                return f\"{start_time // 60:02d}:{start_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n\n        # Check the time between blocked periods\n        for i in range(len(all_blocked) - 1):\n            current_end = all_blocked[i][1]\n            next_start = all_blocked[i + 1][0]\n            if next_start - current_end >= meeting_duration:\n                start_time = current_end\n                end_time = start_time + meeting_duration\n                return f\"{start_time // 60:02d}:{start_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n\n        # Check the time after the last blocked period\n        if len(all_blocked) > 0:\n            last_block_end = all_blocked[-1][1]\n            if work_end - last_block_end >= meeting_duration:\n                start_time = last_block_end\n                end_time = start_time + meeting_duration\n                return f\"{start_time // 60:02d}:{start_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n        else:\n            # No blocked times on this day, schedule at the start of the day\n            start_time = work_start\n            end_time = start_time + meeting_duration\n            return f\"{start_time // 60:02d}:{start_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n\n    return \"No available time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_690"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday']\n    \n    # Define busy intervals in minutes since midnight\n    busy = {\n        'Joe': {\n            'Monday': [(9.5 * 60, 10.5 * 60), (11 * 60, 12.5 * 60), (13.5 * 60, 14 * 60)],\n            'Tuesday': [(14 * 60, 14.5 * 60), (16 * 60, 16.5 * 60)]\n        },\n        'Walter': {\n            'Monday': [(9 * 60, 9.5 * 60), (10 * 60, 12.5 * 60), (14 * 60, 15.5 * 60), (16 * 60, 17 * 60)],\n            'Tuesday': [(9.5 * 60, 10 * 60), (10.5 * 60, 14 * 60), (14.5 * 60, 17 * 60)]\n        }\n    }\n    \n    # Define preferences\n    joe_no_monday_after = 15.5 * 60  # 15:30\n    walter_avoid_tuesday = True\n    \n    meeting_duration = 30  # minutes\n    \n    # Iterate through each day to find a suitable time\n    for day in days:\n        if walter_avoid_tuesday and day == 'Tuesday':\n            continue  # Skip Tuesday if Walter prefers to avoid it\n        \n        # Combine and sort all busy intervals for both participants\n        all_busy = []\n        for person in ['Joe', 'Walter']:\n            if day in busy[person]:\n                all_busy.extend(busy[person][day])\n        \n        # Sort intervals by start time\n        all_busy.sort()\n        \n        # Check available slots\n        prev_end = work_start\n        for interval in all_busy:\n            start, end = interval\n            if start > prev_end:\n                # Check if the slot is long enough and meets Joe's preference for Monday\n                if (end - start) >= meeting_duration:\n                    slot_start = prev_end\n                    slot_end = slot_start + meeting_duration\n                    if day == 'Monday' and slot_end > joe_no_monday_after:\n                        continue  # Skip if it's Monday and after 15:30\n                    if slot_end <= work_end:\n                        # Convert back to HH:MM format\n                        def minutes_to_time(minutes):\n                            return f\"{int(minutes // 60):02d}:{int(minutes % 60):02d}\"\n                        return f\"{minutes_to_time(slot_start)}:{minutes_to_time(slot_end)}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after the last busy interval\n        if prev_end + meeting_duration <= work_end:\n            if day == 'Monday' and (prev_end + meeting_duration) > joe_no_monday_after:\n                continue  # Skip if it's Monday and after 15:30\n            def minutes_to_time(minutes):\n                return f\"{int(minutes // 60):02d}:{int(minutes % 60):02d}\"\n            return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + meeting_duration)}\"\n    \n    # If no time found (though the problem states there is a solution)\n    return \"No time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_691"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n    \n    # Charlotte's busy times on Tuesday (in minutes since midnight)\n    charlotte_busy_tuesday = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (13 * 60 + 30, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    \n    # Find available slots on Tuesday (Charlotte prefers not Monday)\n    available_slots = []\n    \n    # Check before first meeting\n    if charlotte_busy_tuesday[0][0] > work_start:\n        available_slots.append((work_start, charlotte_busy_tuesday[0][0]))\n    \n    # Check between meetings\n    for i in range(1, len(charlotte_busy_tuesday)):\n        prev_end = charlotte_busy_tuesday[i-1][1]\n        current_start = charlotte_busy_tuesday[i][0]\n        if current_start > prev_end:\n            available_slots.append((prev_end, current_start))\n    \n    # Check after last meeting\n    if charlotte_busy_tuesday[-1][1] < work_end:\n        available_slots.append((charlotte_busy_tuesday[-1][1], work_end))\n    \n    # Find the earliest available slot that fits the meeting\n    for slot in available_slots:\n        start, end = slot\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return None\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_692"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday']\n    \n    # Keith's constraints: free entire week but can't meet Monday before 12:00\n    # Kenneth's schedule:\n    # Monday: 9:00-11:00, 11:30-16:30\n    # Tuesday: 9:00-17:00 (entire day busy)\n    \n    # Check Monday first (since Tuesday Kenneth is entirely busy)\n    day = 'Monday'\n    \n    # Kenneth's busy slots on Monday in minutes\n    kenneth_busy = [\n        (9 * 60, 11 * 60),\n        (11 * 60 + 30, 16 * 60 + 30)\n    ]\n    \n    # Keith's constraint: can't meet before 12:00 on Monday\n    keith_constraint_start = 12 * 60\n    \n    # Potential slots are between Kenneth's busy times and within work hours\n    potential_slots = []\n    \n    # Check before first meeting (but must be after Keith's constraint)\n    slot_start = max(work_start, keith_constraint_start)\n    slot_end = kenneth_busy[0][0]\n    if slot_start < slot_end:\n        potential_slots.append((slot_start, slot_end))\n    \n    # Check between meetings\n    slot_start = kenneth_busy[0][1]\n    slot_end = kenneth_busy[1][0]\n    if slot_start < slot_end:\n        potential_slots.append((slot_start, slot_end))\n    \n    # Check after last meeting (but within work hours)\n    slot_start = kenneth_busy[1][1]\n    slot_end = work_end\n    if slot_start < slot_end:\n        potential_slots.append((slot_start, slot_end))\n    \n    # Find the first slot that can fit 30 minutes\n    meeting_duration = 30\n    for slot in potential_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= meeting_duration:\n            # Return the first available slot\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Format as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    # If no slot found on Monday, check Tuesday (though Kenneth is entirely busy)\n    # But per problem statement, a solution exists, so this shouldn't be reached\n    return \"No time found\"\n\n# Output the proposed time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_693"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert schedules to minutes for easier comparison\n    # Patrick's busy times\n    patrick_busy = {\n        'Monday': [\n            (10 * 60, 10 * 60 + 30),\n            (12 * 60, 14 * 60),\n            (14 * 60 + 30, 15 * 60 + 30),\n            (16 * 60, 17 * 60)\n        ],\n        'Tuesday': [\n            (9 * 60, 9 * 60 + 30),\n            (10 * 60 + 30, 11 * 60),\n            (14 * 60 + 30, 15 * 60)\n        ]\n    }\n    \n    # Lawrence's busy times\n    lawrence_busy = {\n        'Monday': [\n            (9 * 60, 13 * 60),\n            (13 * 60 + 30, 16 * 60),\n            (16 * 60 + 30, 17 * 60)\n        ],\n        'Tuesday': [\n            (9 * 60, 10 * 60),\n            (10 * 60 + 30, 12 * 60 + 30),\n            (13 * 60, 15 * 60 + 30),\n            (16 * 60 + 30, 17 * 60)\n        ]\n    }\n    \n    # Patrick cannot meet on Tuesday before 15:30\n    patrick_no_meet_before = 15 * 60 + 30  # 15:30\n    \n    days = ['Monday', 'Tuesday']\n    meeting_duration = 30\n    \n    for day in days:\n        # Combine and sort all busy times for both participants\n        combined_busy = []\n        \n        # Add Patrick's busy times\n        if day in patrick_busy:\n            combined_busy.extend(patrick_busy[day])\n        \n        # Add Lawrence's busy times\n        if day in lawrence_busy:\n            combined_busy.extend(lawrence_busy[day])\n        \n        # Sort by start time\n        combined_busy.sort()\n        \n        # Find free slots\n        prev_end = work_hours_start\n        free_slots = []\n        \n        for start, end in combined_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy slot\n        if prev_end < work_hours_end:\n            free_slots.append((prev_end, work_hours_end))\n        \n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            # Adjust for Patrick's constraint on Tuesday\n            if day == 'Tuesday' and slot_start < patrick_no_meet_before:\n                slot_start = max(slot_start, patrick_no_meet_before)\n                if slot_start >= slot_end:\n                    continue\n            \n            available_start = slot_start\n            available_end = slot_end\n            \n            if available_end - available_start >= meeting_duration:\n                # Convert back to HH:MM format\n                start_hh = available_start // 60\n                start_mm = available_start % 60\n                end_hh = (available_start + meeting_duration) // 60\n                end_mm = (available_start + meeting_duration) % 60\n                \n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_694"
        },
        {
            "final_program_time": "{15:30:16:30}",
            "expected_time": "{15:30:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday']\n    \n    # Peter's schedule: completely free\n    peter_schedule = {day: [] for day in days}\n    \n    # Samantha's schedule and preferences\n    samantha_schedule = {\n        'Monday': [(10 * 60, 10 * 60 + 30), (13 * 60, 15 * 60 + 30)],\n        'Tuesday': [(9 * 60, 11 * 60), (12 * 60, 12 * 60 + 30), \n                    (13 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30),\n                    (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)]\n    }\n    samantha_preferences = {\n        'Monday': {'avoid_before': 15 * 60}  # Avoid before 15:00 on Monday\n    }\n    \n    meeting_duration = 60  # 1 hour in minutes\n    \n    # Iterate through each day to find a suitable time\n    for day in days:\n        # Get Samantha's busy slots for the day\n        busy_slots = samantha_schedule.get(day, [])\n        # Add preference constraints (avoid before certain time)\n        avoid_before = samantha_preferences.get(day, {}).get('avoid_before', work_start)\n        \n        # Generate available slots for Samantha\n        available_slots = []\n        prev_end = work_start\n        for start, end in sorted(busy_slots):\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n        \n        # Filter available slots based on preferences and duration\n        valid_slots = []\n        for start, end in available_slots:\n            # Adjust start time if it's before the avoid_before time\n            current_start = max(start, avoid_before)\n            if current_start + meeting_duration <= end:\n                valid_slots.append((current_start, end))\n        \n        # Check if there's a valid slot in this day\n        for start, end in valid_slots:\n            if end - start >= meeting_duration:\n                meeting_start = start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_695"
        },
        {
            "final_program_time": "{15:30:16:30}",
            "expected_time": "{15:30:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, days, duration):\n    \"\"\"\n    Find a meeting time that fits all participants' schedules.\n    \n    Args:\n        participants_schedules: List of dicts, each representing a participant's busy times.\n        work_hours: Tuple (start, end) representing work hours in HH:MM format.\n        days: List of days to consider.\n        duration: Duration of the meeting in minutes.\n    \n    Returns:\n        A string in the format HH:MM:HH:MM representing the proposed meeting time, or None if no time is found.\n    \"\"\"\n    # Convert work hours to minutes since midnight for easier calculation\n    work_start = int(work_hours[0].split(':')[0]) * 60 + int(work_hours[0].split(':')[1])\n    work_end = int(work_hours[1].split(':')[0]) * 60 + int(work_hours[1].split(':')[1])\n    \n    # Iterate through each day\n    for day in days:\n        # Initialize the available slots as the entire work day\n        available_slots = [(work_start, work_end)]\n        \n        # Apply each participant's schedule to narrow down available slots\n        for schedule in participants_schedules:\n            day_schedule = schedule.get(day, [])\n            new_available_slots = []\n            \n            for busy_start, busy_end in day_schedule:\n                busy_start_min = int(busy_start.split(':')[0]) * 60 + int(busy_start.split(':')[1])\n                busy_end_min = int(busy_end.split(':')[0]) * 60 + int(busy_end.split(':')[1])\n                \n                for slot_start, slot_end in available_slots:\n                    if busy_end_min <= slot_start or busy_start_min >= slot_end:\n                        # No overlap, keep the slot as is\n                        new_available_slots.append((slot_start, slot_end))\n                    else:\n                        # Overlap, split the slot\n                        if slot_start < busy_start_min:\n                            new_available_slots.append((slot_start, busy_start_min))\n                        if busy_end_min < slot_end:\n                            new_available_slots.append((busy_end_min, slot_end))\n                \n                available_slots = new_available_slots\n                new_available_slots = []\n        \n        # Check if any remaining slot can fit the meeting\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= duration:\n                # Convert start time back to HH:MM format\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_time = slot_start + duration\n                end_hh = end_time // 60\n                end_mm = end_time % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return None\n\n# Define the participants' schedules\nroy_schedule = {\n    \"Monday\": [(\"9:30\", \"10:00\"), (\"14:30\", \"15:30\"), (\"16:00\", \"16:30\")],\n    \"Tuesday\": [(\"9:00\", \"9:30\"), (\"13:00\", \"13:30\")],\n}\n\nanna_schedule = {\n    \"Monday\": [(\"9:00\", \"9:30\"), (\"10:00\", \"11:30\"), (\"12:00\", \"12:30\"), \n               (\"13:00\", \"13:30\"), (\"14:00\", \"15:00\"), (\"15:30\", \"16:30\")],\n    \"Tuesday\": [(\"9:00\", \"15:30\"), (\"16:30\", \"17:00\")],\n}\n\n# Define meeting constraints\nwork_hours = (\"9:00\", \"17:00\")\ndays = [\"Monday\", \"Tuesday\"]\nduration = 60  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time([roy_schedule, anna_schedule], work_hours, days, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_696"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define busy slots for Tyler and Marie in minutes since midnight\n    # Monday\n    tyler_busy_monday = [(9 * 60 + 30, 10 * 60)]  # 9:30-10:00\n    marie_busy_monday = [\n        (9 * 60, 10 * 60),       # 9:00-10:00\n        (11 * 60, 11 * 60 + 30), # 11:00-11:30\n        (12 * 60 + 30, 14 * 60), # 12:30-14:00\n        (14 * 60 + 30, 15 * 60), # 14:30-15:00\n        (16 * 60 + 30, 17 * 60)  # 16:30-17:00\n    ]\n    # Marie cannot meet on Monday after 13:00\n    marie_no_meet_after_monday = 13 * 60  # 13:00\n\n    # Tuesday\n    tyler_busy_tuesday = [(14 * 60 + 30, 16 * 60)]  # 14:30-16:00\n    marie_busy_tuesday = [\n        (9 * 60 + 30, 10 * 60 + 30),     # 9:30-10:30\n        (11 * 60, 12 * 60 + 30),         # 11:00-12:30\n        (13 * 60, 15 * 60),              # 13:00-15:00\n        (15 * 60 + 30, 17 * 60)          # 15:30-17:00\n    ]\n\n    # Check Monday\n    def find_slot(busy_slots, no_meet_after=None):\n        slots = []\n        # Start from work_start\n        current_start = work_start\n        for start, end in sorted(busy_slots):\n            if current_start < start:\n                slots.append((current_start, start))\n            current_start = max(current_start, end)\n        if current_start < work_end:\n            slots.append((current_start, work_end))\n        \n        # Filter slots based on duration and no_meet_after\n        valid_slots = []\n        for start, end in slots:\n            if no_meet_after is not None:\n                end = min(end, no_meet_after)\n            if end - start >= meeting_duration:\n                valid_slots.append((start, end))\n        return valid_slots\n\n    # Monday slots\n    tyler_monday_slots = find_slot(tyler_busy_monday)\n    marie_monday_slots = find_slot(marie_busy_monday, marie_no_meet_after_monday)\n    \n    # Find overlapping slots on Monday\n    for t_start, t_end in tyler_monday_slots:\n        for m_start, m_end in marie_monday_slots:\n            start = max(t_start, m_start)\n            end = min(t_end, m_end)\n            if end - start >= meeting_duration:\n                return f\"{minutes_to_time(start)}:{minutes_to_time(start + meeting_duration)}\"\n    \n    # Tuesday slots\n    tyler_tuesday_slots = find_slot(tyler_busy_tuesday)\n    marie_tuesday_slots = find_slot(marie_busy_tuesday)\n    \n    # Find overlapping slots on Tuesday\n    for t_start, t_end in tyler_tuesday_slots:\n        for m_start, m_end in marie_tuesday_slots:\n            start = max(t_start, m_start)\n            end = min(t_end, m_end)\n            if end - start >= meeting_duration:\n                return f\"{minutes_to_time(start)}:{minutes_to_time(start + meeting_duration)}\"\n    \n    return \"No suitable time found\"\n\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_697"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Convert busy slots to minutes for easier calculation\n    ashley_busy = {\n        'Monday': [(9 * 60, 10 * 60 + 30), (12 * 60, 12 * 60 + 30), (13 * 60 + 30, 15 * 60)],\n        'Tuesday': [(13 * 60 + 30, 14 * 60)]\n    }\n    \n    kenneth_busy = {\n        'Monday': [(9 * 60 + 30, 10 * 60 + 30), (11 * 60, 11 * 60 + 30), \n                   (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60 + 30, 11 * 60), (11 * 60 + 30, 12 * 60 + 30), \n                     (13 * 60, 13 * 60 + 30), (14 * 60, 15 * 60), (16 * 60, 17 * 60)]\n    }\n    \n    # Preferred day is Monday\n    days = ['Monday', 'Tuesday']\n    \n    for day in days:\n        if day == 'Tuesday' and 'Ashley would rather not meet on Tuesday':\n            continue  # Skip Tuesday as per Ashley's preference\n        \n        # Collect all busy slots for both participants on this day\n        busy_slots = ashley_busy.get(day, []) + kenneth_busy.get(day, [])\n        busy_slots.sort()  # Sort by start time\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in busy_slots:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for 30-minute availability\n        for slot in free_slots:\n            start, end = slot\n            duration_needed = 30  # minutes\n            if end - start >= duration_needed:\n                meeting_start = start\n                meeting_end = meeting_start + duration_needed\n                # Convert back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_698"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Anna's busy times in minutes since midnight\n    anna_busy = {\n        'Monday': [(15 * 60, 15 * 60 + 30)],  # 15:00-15:30\n        'Tuesday': [(11 * 60 + 30, 12 * 60)],   # 11:30-12:00\n    }\n\n    # Mary's busy times in minutes since midnight\n    mary_busy = {\n        'Monday': [\n            (9 * 60 + 30, 12 * 60),    # 9:30-12:00\n            (13 * 60, 14 * 60 + 30),   # 13:00-14:30\n            (15 * 60 + 30, 16 * 60),   # 15:30-16:00\n            (16 * 60 + 30, 17 * 60),   # 16:30-17:00\n        ],\n        'Tuesday': [\n            (9 * 60, 11 * 60 + 30),    # 9:00-11:30\n            (12 * 60, 13 * 60),        # 12:00-13:00\n            (13 * 60 + 30, 14 * 60),   # 13:30-14:00\n            (14 * 60 + 30, 15 * 60 + 30),  # 14:30-15:30\n            (16 * 60, 17 * 60),        # 16:00-17:00\n        ],\n    }\n\n    # Anna cannot meet on Monday, so only consider Tuesday\n    day = 'Tuesday'\n\n    # Generate all possible slots for Tuesday\n    slots = []\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slots.append((current_time, current_time + meeting_duration))\n        current_time += meeting_duration\n\n    # Filter slots based on Anna's and Mary's availability and Mary's preference\n    for slot_start, slot_end in slots:\n        # Check Anna's availability\n        anna_available = True\n        for busy_start, busy_end in anna_busy.get(day, []):\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                anna_available = False\n                break\n        if not anna_available:\n            continue\n\n        # Check Mary's availability\n        mary_available = True\n        for busy_start, busy_end in mary_busy.get(day, []):\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                mary_available = False\n                break\n        if not mary_available:\n            continue\n\n        # Mary's preference: avoid before 15:30\n        if slot_start < 15 * 60 + 30:\n            continue\n\n        # If all conditions are met, return the slot\n        return f\"{slot_start // 60:02d}:{slot_start % 60:02d}:{slot_end // 60:02d}:{slot_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_699"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to consider (Monday only, as per Melissa's preference)\n    days = ['Monday']\n    \n    # Melissa's schedule on Monday (in minutes)\n    melissa_busy = [\n        (9 * 60, 9 * 60 + 30),    # 9:00-9:30\n        (10 * 60 + 30, 11 * 60 + 30),  # 10:30-11:30\n        (13 * 60 + 30, 14 * 60),       # 13:30-14:00\n        (14 * 60 + 30, 15 * 60)        # 14:30-15:00\n    ]\n    \n    # Ruth's schedule on Monday (in minutes)\n    ruth_busy = [\n        (9 * 60 + 30, 11 * 60),       # 9:30-11:00\n        (12 * 60, 14 * 60 + 30),      # 12:00-14:30\n        (15 * 60, 17 * 60)            # 15:00-17:00\n    ]\n    \n    # Combine and sort all busy intervals\n    all_busy = melissa_busy + ruth_busy\n    all_busy.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Check for a 30-minute slot\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_700"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Days to consider: Monday (0), Tuesday (1), Wednesday (2)\n    days = [0, 1, 2]\n\n    # Albert's busy times in minutes since midnight for each day\n    albert_busy = {\n        0: [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 11 * 60), (11 * 60 + 30, 13 * 60), (16 * 60, 16 * 60 + 30)],\n        2: [(9 * 60, 10 * 60), (15 * 60 + 30, 16 * 60 + 30)]\n    }\n\n    # Patricia's busy times in minutes since midnight for each day\n    patricia_busy = {\n        0: [(9 * 60, 17 * 60)],\n        1: [(9 * 60, 14 * 60 + 30), (16 * 60, 17 * 60)],\n        2: [(9 * 60, 14 * 60 + 30), (15 * 60, 17 * 60)]\n    }\n\n    # Patricia doesn't want to meet on Wednesday (day 2)\n    available_days = [0, 1]\n\n    for day in available_days:\n        # Collect all busy intervals for both participants on this day\n        busy_intervals = []\n        if day in albert_busy:\n            busy_intervals.extend(albert_busy[day])\n        if day in patricia_busy:\n            busy_intervals.extend(patricia_busy[day])\n\n        # Sort busy intervals by start time\n        busy_intervals.sort()\n\n        # Check the time before the first busy interval\n        if busy_intervals:\n            first_start = busy_intervals[0][0]\n            if first_start - work_start >= meeting_duration:\n                return f\"{minutes_to_time(work_start)}:{minutes_to_time(work_start + meeting_duration)}\"\n\n        # Check gaps between busy intervals\n        for i in range(len(busy_intervals) - 1):\n            current_end = busy_intervals[i][1]\n            next_start = busy_intervals[i + 1][0]\n            if next_start - current_end >= meeting_duration:\n                return f\"{minutes_to_time(current_end)}:{minutes_to_time(current_end + meeting_duration)}\"\n\n        # Check the time after the last busy interval\n        if busy_intervals:\n            last_end = busy_intervals[-1][1]\n            if work_end - last_end >= meeting_duration:\n                return f\"{minutes_to_time(last_end)}:{minutes_to_time(last_end + meeting_duration)}\"\n        else:\n            # No busy intervals, any time works\n            return f\"{minutes_to_time(work_start)}:{minutes_to_time(work_start + meeting_duration)}\"\n\n    # If no time found on Monday or Tuesday, check Wednesday despite Patricia's preference (though problem states solution exists)\n    day = 2\n    busy_intervals = []\n    if day in albert_busy:\n        busy_intervals.extend(albert_busy[day])\n    if day in patricia_busy:\n        busy_intervals.extend(patricia_busy[day])\n    busy_intervals.sort()\n\n    # Check gaps on Wednesday\n    for i in range(len(busy_intervals) - 1):\n        current_end = busy_intervals[i][1]\n        next_start = busy_intervals[i + 1][0]\n        if next_start - current_end >= meeting_duration:\n            return f\"{minutes_to_time(current_end)}:{minutes_to_time(current_end + meeting_duration)}\"\n\n    # Check after last busy interval on Wednesday\n    if busy_intervals:\n        last_end = busy_intervals[-1][1]\n        if work_end - last_end >= meeting_duration:\n            return f\"{minutes_to_time(last_end)}:{minutes_to_time(last_end + meeting_duration)}\"\n    else:\n        return f\"{minutes_to_time(work_start)}:{minutes_to_time(work_start + meeting_duration)}\"\n\n    return \"No time found\"  # Shouldn't reach here per problem statement\n\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_701"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to consider\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Robert's schedule: day -> list of busy intervals in minutes\n    robert_schedule = {\n        'Monday': [(11 * 60, 11 * 60 + 30), (14 * 60, 14 * 60 + 30), (15 * 60 + 30, 16 * 60)],\n        'Tuesday': [(10 * 60 + 30, 11 * 60), (15 * 60, 15 * 60 + 30)],\n        'Wednesday': [(10 * 60, 11 * 60), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60), \n                      (13 * 60 + 30, 14 * 60), (15 * 60, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)]\n    }\n    \n    # Ralph's schedule: day -> list of busy intervals in minutes\n    ralph_schedule = {\n        'Monday': [(10 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30), (15 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (11 * 60, 11 * 60 + 30), \n                    (12 * 60, 13 * 60), (14 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Wednesday': [(10 * 60 + 30, 11 * 60), (11 * 60 + 30, 12 * 60), (13 * 60, 14 * 60 + 30), \n                      (16 * 60 + 30, 17 * 60)]\n    }\n    \n    # Robert prefers to avoid Monday, so we check Tuesday and Wednesday first\n    preferred_days = ['Tuesday', 'Wednesday', 'Monday']\n    \n    for day in preferred_days:\n        # Collect all busy intervals for both participants\n        busy_intervals = robert_schedule.get(day, []) + ralph_schedule.get(day, [])\n        busy_intervals.sort()\n        \n        # Merge overlapping or adjacent intervals\n        merged = []\n        for start, end in busy_intervals:\n            if not merged:\n                merged.append([start, end])\n            else:\n                last_start, last_end = merged[-1]\n                if start <= last_end:\n                    merged[-1][1] = max(end, last_end)\n                else:\n                    merged.append([start, end])\n        \n        # Check the available slots\n        prev_end = work_start\n        for start, end in merged:\n            if start > prev_end:\n                available_start = prev_end\n                available_end = start\n                if available_end - available_start >= 30:  # Meeting duration is 30 minutes\n                    # Format the time as HH:MM:HH:MM\n                    start_str = f\"{available_start // 60:02d}:{available_start % 60:02d}\"\n                    end_str = f\"{(available_start + 30) // 60:02d}:{(available_start + 30) % 60:02d}\"\n                    return f\"{start_str}:{end_str}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after the last busy interval\n        if work_end - prev_end >= 30:\n            start_str = f\"{prev_end // 60:02d}:{prev_end % 60:02d}\"\n            end_str = f\"{(prev_end + 30) // 60:02d}:{(prev_end + 30) % 60:02d}\"\n            return f\"{start_str}:{end_str}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_702"
        },
        {
            "final_program_time": "{9:30:10:30}",
            "expected_time": "{9:30:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Stephanie's schedule: {day: [(start1, end1), (start2, end2), ...]}\n    stephanie_schedule = {\n        'Monday': [(9.5 * 60, 10 * 60), (10.5 * 60, 11 * 60), (11.5 * 60, 12 * 60), (14 * 60, 14.5 * 60)],\n        'Tuesday': [(12 * 60, 13 * 60)],\n        'Wednesday': [(9 * 60, 10 * 60), (13 * 60, 14 * 60)]\n    }\n\n    # Betty's schedule: {day: [(start1, end1), (start2, end2), ...]}\n    betty_schedule = {\n        'Monday': [(9 * 60, 10 * 60), (11 * 60, 11.5 * 60), (14.5 * 60, 15 * 60), (15.5 * 60, 16 * 60)],\n        'Tuesday': [(9 * 60, 9.5 * 60), (11.5 * 60, 12 * 60), (12.5 * 60, 14.5 * 60), (15.5 * 60, 16 * 60)],\n        'Wednesday': [(10 * 60, 11.5 * 60), (12 * 60, 14 * 60), (14.5 * 60, 17 * 60)]\n    }\n\n    # Constraints\n    stephanie_avoid_days = ['Monday']  # Stephanie wants to avoid Monday\n    betty_no_tuesday_after = 12.5 * 60  # Betty can't meet on Tuesday after 12:30\n\n    # Iterate through each day to find a suitable time\n    for day in days:\n        if day in stephanie_avoid_days:\n            continue  # Skip Monday for Stephanie's preference\n\n        # Combine and sort all busy times for both participants on this day\n        busy_times = []\n        # Add Stephanie's meetings\n        for meeting in stephanie_schedule.get(day, []):\n            busy_times.append(meeting)\n        # Add Betty's meetings\n        for meeting in betty_schedule.get(day, []):\n            busy_times.append(meeting)\n        # Also add Betty's Tuesday constraint if the day is Tuesday\n        if day == 'Tuesday':\n            busy_times.append((betty_no_tuesday_after, work_end))\n\n        # Sort all busy times by start time\n        busy_times.sort()\n\n        # Find the earliest available slot\n        previous_end = work_start\n        for meeting in busy_times:\n            start, end = meeting\n            if start > previous_end and (start - previous_end) >= meeting_duration:\n                # Found a suitable slot\n                meeting_start = previous_end\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                return f\"{int(meeting_start // 60):02d}:{int(meeting_start % 60):02d}:{int(meeting_end // 60):02d}:{int(meeting_end % 60):02d}\"\n            previous_end = max(previous_end, end)\n\n        # Check the time after the last meeting until work_end\n        if (work_end - previous_end) >= meeting_duration:\n            meeting_start = previous_end\n            meeting_end = meeting_start + meeting_duration\n            return f\"{int(meeting_start // 60):02d}:{int(meeting_start % 60):02d}:{int(meeting_end // 60):02d}:{int(meeting_end % 60):02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_703"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Samuel's busy times in minutes since midnight for each day\n    samuel_busy = {\n        'Monday': [\n            (10 * 60 + 30, 11 * 60),    # 10:30-11:00\n            (12 * 60, 12 * 60 + 30),     # 12:00-12:30\n            (13 * 60, 15 * 60),          # 13:00-15:00\n            (15 * 60 + 30, 16 * 60 + 30) # 15:30-16:30\n        ],\n        'Tuesday': [\n            (9 * 60, 12 * 60),          # 9:00-12:00\n            (14 * 60, 15 * 60 + 30),     # 14:00-15:30\n            (16 * 60 + 30, 17 * 60)      # 16:30-17:00\n        ],\n        'Wednesday': [\n            (10 * 60 + 30, 11 * 60),     # 10:30-11:00\n            (11 * 60 + 30, 12 * 60),     # 11:30-12:00\n            (12 * 60 + 30, 13 * 60),     # 12:30-13:00\n            (14 * 60, 14 * 60 + 30),     # 14:00-14:30\n            (15 * 60, 16 * 60)           # 15:00-16:00\n        ]\n    }\n    \n    # Preferred days in order (Monday first, then Wednesday, Tuesday last)\n    days_order = ['Monday', 'Wednesday', 'Tuesday']\n    \n    # Duration in minutes\n    duration = 30\n    \n    for day in days_order:\n        if day == 'Wednesday' and 'Wednesday' in days_order[:2]:\n            continue  # Skip Wednesday if Larry prefers not to meet then\n        \n        if day == 'Tuesday' and 'Tuesday' in days_order[:2]:\n            continue  # Skip Tuesday if Samuel prefers to avoid it\n        \n        busy_times = samuel_busy[day]\n        free_slots = []\n        \n        # Check before first meeting\n        if busy_times and busy_times[0][0] > work_start:\n            free_slots.append((work_start, busy_times[0][0]))\n        \n        # Check between meetings\n        for i in range(1, len(busy_times)):\n            prev_end = busy_times[i-1][1]\n            curr_start = busy_times[i][0]\n            if curr_start > prev_end:\n                free_slots.append((prev_end, curr_start))\n        \n        # Check after last meeting\n        if busy_times and busy_times[-1][1] < work_end:\n            free_slots.append((busy_times[-1][1], work_end))\n        \n        # If no meetings, the whole day is free\n        if not busy_times:\n            free_slots.append((work_start, work_end))\n        \n        # Find the first suitable slot\n        for slot in free_slots:\n            start, end = slot\n            if end - start >= duration:\n                # Convert back to HH:MM format\n                start_hh = start // 60\n                start_mm = start % 60\n                end_hh = (start + duration) // 60\n                end_mm = (start + duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_704"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Jeffrey's busy times in minutes since midnight for each day\n    jeffrey_busy = {\n        'Monday': [\n            (9 * 60 + 30, 12 * 60),    # 9:30-12:00\n            (12 * 60 + 30, 13 * 60),    # 12:30-13:00\n            (14 * 60, 14 * 60 + 30),    # 14:00-14:30\n            (16 * 60 + 30, 17 * 60)     # 16:30-17:00\n        ],\n        'Tuesday': [\n            (9 * 60 + 30, 10 * 60 + 30), # 9:30-10:30\n            (11 * 60 + 30, 12 * 60),     # 11:30-12:00\n            (12 * 60 + 30, 13 * 60),     # 12:30-13:00\n            (13 * 60 + 30, 15 * 60 + 30), # 13:30-15:30\n            (16 * 60, 16 * 60 + 30)      # 16:00-16:30\n        ],\n        'Wednesday': [\n            (9 * 60, 11 * 60 + 30),     # 9:00-11:30\n            (12 * 60, 17 * 60)           # 12:00-17:00\n        ]\n    }\n    \n    # Scott is free all week, so only Jeffrey's schedule matters\n    meeting_duration = 60  # 1 hour\n    \n    for day in days:\n        # Start checking from the beginning of the work day\n        current_time = work_start\n        \n        # Get Jeffrey's busy slots for the day\n        busy_slots = jeffrey_busy.get(day, [])\n        \n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        for slot in busy_slots:\n            slot_start, slot_end = slot\n            # If there's enough time between current_time and slot_start\n            if current_time + meeting_duration <= slot_start:\n                # Found a valid slot\n                start_h = current_time // 60\n                start_m = current_time % 60\n                end_h = (current_time + meeting_duration) // 60\n                end_m = (current_time + meeting_duration) % 60\n                return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n            # Update current_time to the end of this busy slot if it's later\n            if slot_end > current_time:\n                current_time = slot_end\n        # Check after the last busy slot\n        if current_time + meeting_duration <= work_end:\n            start_h = current_time // 60\n            start_m = current_time % 60\n            end_h = (current_time + meeting_duration) // 60\n            end_m = (current_time + meeting_duration) % 60\n            return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_705"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Gregory's schedule: list of (start, end) in minutes for each day\n    gregory_schedule = {\n        'Monday': [(15.5 * 60, 16.5 * 60)],\n        'Tuesday': [(9 * 60, 9.5 * 60), (11.5 * 60, 12 * 60), (14 * 60, 14.5 * 60), (15 * 60, 16 * 60), (16.5 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 9.5 * 60), (10 * 60, 11 * 60), (11.5 * 60, 13 * 60), (13.5 * 60, 14.5 * 60)]\n    }\n    \n    # Patricia's schedule: list of (start, end) in minutes for each day\n    patricia_schedule = {\n        'Monday': [(9 * 60, 9.5 * 60), (10 * 60, 10.5 * 60), (11.5 * 60, 15 * 60)],\n        'Tuesday': [(9 * 60, 10.5 * 60), (11 * 60, 11.5 * 60), (12 * 60, 14.5 * 60), (15 * 60, 15.5 * 60), (16.5 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 9.5 * 60), (10 * 60, 12.5 * 60), (13.5 * 60, 16 * 60), (16.5 * 60, 17 * 60)]\n    }\n    \n    # Function to find available slots for a person on a given day\n    def get_available_slots(schedule, day):\n        busy_slots = schedule.get(day, [])\n        busy_slots.sort()  # Ensure slots are in order\n        \n        # Start with the full work day as available\n        available = [(work_start, work_end)]\n        \n        # Subtract busy slots from available time\n        for busy_start, busy_end in busy_slots:\n            new_available = []\n            for avail_start, avail_end in available:\n                if busy_start >= avail_end or busy_end <= avail_start:\n                    # No overlap, keep the available slot\n                    new_available.append((avail_start, avail_end))\n                else:\n                    # Overlap, split the available slot\n                    if avail_start < busy_start:\n                        new_available.append((avail_start, busy_start))\n                    if avail_end > busy_end:\n                        new_available.append((busy_end, avail_end))\n            available = new_available\n        \n        return available\n    \n    # Check each day for a common available slot of 1 hour (60 minutes)\n    for day in days:\n        gregory_available = get_available_slots(gregory_schedule, day)\n        patricia_available = get_available_slots(patricia_schedule, day)\n        \n        # Find overlapping slots between Gregory and Patricia\n        for g_start, g_end in gregory_available:\n            for p_start, p_end in patricia_available:\n                # Find the overlap between the two slots\n                overlap_start = max(g_start, p_start)\n                overlap_end = min(g_end, p_end)\n                \n                # Check if the overlap is at least 60 minutes\n                if overlap_end - overlap_start >= 60:\n                    # Return the first found slot\n                    start_time = int(overlap_start)\n                    end_time = start_time + 60\n                    \n                    # Convert minutes back to HH:MM format\n                    def minutes_to_time(minutes):\n                        hours = minutes // 60\n                        mins = minutes % 60\n                        return f\"{int(hours):02d}:{int(mins):02d}\"\n                    \n                    start_str = minutes_to_time(start_time)\n                    end_str = minutes_to_time(end_time)\n                    return f\"{start_str}:{end_str}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_706"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to consider (Monday=0, Tuesday=1, Wednesday=2)\n    days = [0, 1, 2]\n    \n    # Ryan cannot meet on Wednesday (2), so remove it\n    days = [0, 1]\n    \n    # Ryan's busy times in minutes since midnight for each day\n    ryan_busy = {\n        0: [(9*60 + 30, 10*60), (11*60, 12*60), (13*60, 13*60 + 30), (15*60 + 30, 16*60)],\n        1: [(11*60 + 30, 12*60 + 30), (15*60 + 30, 16*60)],\n        2: [(12*60, 13*60), (15*60 + 30, 16*60), (16*60 + 30, 17*60)]\n    }\n    \n    # Adam's busy times in minutes since midnight for each day\n    adam_busy = {\n        0: [(9*60, 10*60 + 30), (11*60, 13*60 + 30), (14*60, 16*60), (16*60 + 30, 17*60)],\n        1: [(9*60, 10*60), (10*60 + 30, 15*60 + 30), (16*60, 17*60)],\n        2: [(9*60, 9*60 + 30), (10*60, 11*60), (11*60 + 30, 14*60 + 30), (15*60, 15*60 + 30), (16*60, 16*60 + 30)]\n    }\n    \n    # Adam wants to avoid Monday before 14:30\n    adam_busy[0].append((work_start, 14*60 + 30))\n    \n    meeting_duration = 30\n    \n    for day in days:\n        # Combine and sort busy times for Ryan and Adam\n        busy_times = ryan_busy.get(day, []) + adam_busy.get(day, [])\n        busy_times.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in busy_times:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check for a suitable slot\n        for start, end in free_slots:\n            if end - start >= meeting_duration:\n                meeting_start = start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_707"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    meeting_duration = 30  # minutes\n    \n    # Define busy slots for each participant per day in minutes since midnight\n    billy_busy = {\n        'Monday': [(16 * 60, 16 * 60 + 30)],\n        'Tuesday': [(15 * 60, 15 * 60 + 30)],\n        'Wednesday': []\n    }\n    \n    jean_busy = {\n        'Monday': [(9 * 60, 12 * 60 + 30), (13 * 60 + 30, 15 * 60), (15 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60 + 30, 17 * 60)]\n    }\n    \n    # Jean's preference: not on Monday after 13:30 (so before 13:30)\n    jean_preference = {\n        'Monday': (9 * 60, 13 * 60 + 30),\n        'Tuesday': (0, 0),  # Not available at all on Tuesday\n        'Wednesday': (9 * 60 + 30, 17 * 60)\n    }\n    \n    # Iterate through each day to find a suitable time\n    for day in days:\n        # Get busy slots for both participants\n        billy_slots = billy_busy[day]\n        jean_slots = jean_busy[day]\n        \n        # Combine and sort all busy slots\n        all_busy = billy_slots + jean_slots\n        all_busy.sort()\n        \n        # Check Jean's preference for the day\n        pref_start, pref_end = jean_preference[day]\n        if pref_start == pref_end == 0:\n            continue  # Jean is not available this day\n        \n        # Determine the effective work hours considering Jean's preference\n        day_start = max(work_hours_start, pref_start)\n        day_end = min(work_hours_end, pref_end)\n        \n        # Find free slots\n        prev_end = day_start\n        for start, end in all_busy:\n            if start > prev_end:\n                # Check if there's enough time for the meeting\n                if start - prev_end >= meeting_duration:\n                    # Found a slot\n                    meeting_start = prev_end\n                    meeting_end = meeting_start + meeting_duration\n                    # Format the time as HH:MM:HH:MM\n                    return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after the last busy slot\n        if day_end - prev_end >= meeting_duration:\n            meeting_start = prev_end\n            meeting_end = meeting_start + meeting_duration\n            return f\"{meeting_start // 60:02d}:{meeting_end // 60:02d}:{meeting_start % 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_708"
        },
        {
            "final_program_time": "{12:30:13:30}",
            "expected_time": "{15:00:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Define days to check (Monday is 0, Tuesday is 1, Wednesday is 2)\n    days = [1, 2]  # Monday is excluded as Jerry can't meet then\n\n    # Henry's schedule: {day: [(start1, end1), (start2, end2), ...]}\n    henry_schedule = {\n        1: [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 11 * 60), (11 * 60 + 30, 12 * 60),\n            (14 * 60, 14 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        2: [(11 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60),\n            (16 * 60, 16 * 60 + 30)]\n    }\n\n    # Jerry's schedule: {day: [(start1, end1), (start2, end2), ...]}\n    jerry_schedule = {\n        1: [(9 * 60, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (13 * 60 + 30, 15 * 60 + 30),\n            (16 * 60 + 30, 17 * 60)],\n        2: [(9 * 60, 10 * 60), (10 * 60 + 30, 12 * 60), (12 * 60 + 30, 14 * 60 + 30),\n            (15 * 60, 17 * 60)]\n    }\n\n    meeting_duration = 60  # 1 hour in minutes\n\n    for day in days:\n        # Collect all busy times for both participants on this day\n        busy_times = []\n        \n        # Add Henry's meetings\n        if day in henry_schedule:\n            busy_times.extend(henry_schedule[day])\n        \n        # Add Jerry's meetings\n        if day in jerry_schedule:\n            busy_times.extend(jerry_schedule[day])\n        \n        # Sort busy times by start time\n        busy_times.sort()\n        \n        # Find free slots\n        previous_end = work_start\n        free_slots = []\n        \n        for start, end in busy_times:\n            if start > previous_end:\n                free_slots.append((previous_end, start))\n            previous_end = max(previous_end, end)\n        \n        # Check after last meeting\n        if previous_end < work_end:\n            free_slots.append((previous_end, work_end))\n        \n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            available_start = slot_start\n            available_end = slot_end\n            \n            # Check if the slot can fit the meeting\n            if available_end - available_start >= meeting_duration:\n                # Found a suitable time\n                meeting_start = available_start\n                meeting_end = meeting_start + meeting_duration\n                \n                # Convert back to HH:MM format\n                def minutes_to_time(minutes):\n                    hours = minutes // 60\n                    mins = minutes % 60\n                    return f\"{hours:02d}:{mins:02d}\"\n                \n                day_name = [\"Monday\", \"Tuesday\", \"Wednesday\"][day]\n                start_time = minutes_to_time(meeting_start)\n                end_time = minutes_to_time(meeting_end)\n                return f\"{start_time}:{end_time}\"\n    \n    return \"No suitable time found\"\n\n# Execute and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_709"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    meeting_duration = 30  # minutes\n    \n    # Define busy times for each participant in minutes since midnight\n    # Format: {day: [(start1, end1), (start2, end2), ...]}\n    cheryl_busy = {\n        'Monday': [(9*60, 9*60 + 30), (11*60 + 30, 13*60), (15*60 + 30, 16*60)],\n        'Tuesday': [(15*60, 15*60 + 30)],\n        'Wednesday': []  # Cheryl can't meet on Wednesday, so treat as fully busy\n    }\n    \n    kyle_busy = {\n        'Monday': [(9*60, 17*60)],  # Entire day\n        'Tuesday': [(9*60 + 30, 17*60)],\n        'Wednesday': [(9*60, 9*60 + 30), (10*60, 13*60), (13*60 + 30, 14*60), (14*60 + 30, 17*60)]\n    }\n    \n    # Iterate through each day (excluding Wednesday for Cheryl)\n    for day in ['Monday', 'Tuesday']:\n        # Collect all busy intervals for both participants\n        busy_intervals = cheryl_busy[day] + kyle_busy[day]\n        busy_intervals.sort()  # Sort by start time\n        \n        # Merge overlapping or adjacent intervals\n        merged = []\n        for start, end in busy_intervals:\n            if not merged:\n                merged.append((start, end))\n            else:\n                last_start, last_end = merged[-1]\n                if start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged[-1] = (new_start, new_end)\n                else:\n                    merged.append((start, end))\n        \n        # Find the first available slot\n        prev_end = work_start\n        for start, end in merged:\n            if start - prev_end >= meeting_duration:\n                # Found a slot\n                meeting_start = prev_end\n                meeting_end = meeting_start + meeting_duration\n                # Convert back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy interval\n        if work_end - prev_end >= meeting_duration:\n            meeting_start = prev_end\n            meeting_end = meeting_start + meeting_duration\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    # If no slot found (though problem states there is one)\n    return \"No time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_710"
        },
        {
            "final_program_time": "{9:30:10:30}",
            "expected_time": "{9:30:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define busy slots for each person in minutes since midnight\n    mason_busy = {\n        'Monday': [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 11 * 60)],\n        'Tuesday': [(9 * 60 + 30, 10 * 60), (14 * 60, 14 * 60 + 30)],\n        'Wednesday': [(14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60)]\n    }\n    \n    nicole_busy = {\n        'Monday': [(9 * 60, 17 * 60)],  # Entire day blocked\n        'Tuesday': [(9 * 60, 17 * 60)],  # Entire day blocked\n        'Wednesday': [(9 * 60, 9 * 60 + 30), (11 * 60, 14 * 60 + 30), (15 * 60, 16 * 60)]\n    }\n    \n    meeting_duration = 60  # 1 hour in minutes\n    \n    # Iterate through each day to find the earliest available slot\n    for day in days:\n        # Check if Nicole is completely busy on this day\n        if day in nicole_busy and any(start == work_start and end == work_end for start, end in nicole_busy[day]):\n            continue\n        \n        # Collect all busy times for both participants on this day\n        busy_times = []\n        if day in mason_busy:\n            busy_times.extend(mason_busy[day])\n        if day in nicole_busy:\n            busy_times.extend(nicole_busy[day])\n        \n        # Sort busy times by start time\n        busy_times.sort()\n        \n        # Check the time before the first busy slot\n        prev_end = work_start\n        for start, end in busy_times:\n            if start > prev_end:\n                available_start = prev_end\n                available_end = start\n                if available_end - available_start >= meeting_duration:\n                    # Found a suitable slot\n                    meeting_start = available_start\n                    meeting_end = meeting_start + meeting_duration\n                    return (f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:\"\n                            f\"{meeting_end // 60:02d}:{meeting_end % 60:02d}\")\n            prev_end = max(prev_end, end)\n        \n        # Check the time after the last busy slot\n        if prev_end < work_end and work_end - prev_end >= meeting_duration:\n            meeting_start = prev_end\n            meeting_end = meeting_start + meeting_duration\n            return (f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:\"\n                    f\"{meeting_end // 60:02d}:{meeting_end % 60:02d}\")\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_711"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define blocked times for Gerald and Adam in minutes since midnight\n    gerald_blocked = {\n        'Monday': [(10 * 60, 10 * 60 + 30), (12 * 60, 12 * 60 + 30), (14 * 60 + 30, 15 * 60), (16 * 60 + 30, 17 * 60)],\n        'Tuesday': [(12 * 60, 12 * 60 + 30), (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60 + 30)],\n        'Wednesday': [(9 * 60, 9 * 60 + 30), (11 * 60 + 30, 12 * 60)]\n    }\n    \n    adam_blocked = {\n        'Monday': [(9 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 10 * 60 + 30), (11 * 60, 15 * 60), (16 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 13 * 60), (14 * 60 + 30, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)]\n    }\n    \n    # Adam cannot meet on Wednesday after 14:30, so adjust his Wednesday blocked times\n    adam_blocked['Wednesday'] = [(9 * 60, 13 * 60), (14 * 60 + 30, 17 * 60)]\n    \n    # Meeting duration in minutes\n    meeting_duration = 60\n    \n    # Iterate through each day to find a suitable time slot\n    for day in days:\n        # Combine and sort all blocked times for both participants\n        all_blocked = gerald_blocked.get(day, []) + adam_blocked.get(day, [])\n        all_blocked.sort()\n        \n        # Merge overlapping or adjacent blocked intervals\n        merged_blocked = []\n        for start, end in all_blocked:\n            if not merged_blocked:\n                merged_blocked.append((start, end))\n            else:\n                last_start, last_end = merged_blocked[-1]\n                if start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged_blocked[-1] = (new_start, new_end)\n                else:\n                    merged_blocked.append((start, end))\n        \n        # Check the available slots before the first blocked time, between blocked times, and after last blocked time\n        prev_end = work_start\n        for start, end in merged_blocked:\n            if start > prev_end:\n                available_start = prev_end\n                available_end = start\n                if available_end - available_start >= meeting_duration:\n                    # Found a suitable slot\n                    meeting_start = available_start\n                    meeting_end = meeting_start + meeting_duration\n                    return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after the last blocked time\n        if work_end - prev_end >= meeting_duration:\n            meeting_start = prev_end\n            meeting_end = meeting_start + meeting_duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_712"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to consider (Monday, Tuesday, Wednesday)\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Martha's constraints: cannot meet on Tuesday or Wednesday\n    available_days = ['Monday']\n    \n    # Martha's meetings on Monday (in minutes)\n    martha_meetings = [\n        (11 * 60 + 30, 12 * 60 + 0)\n    ]\n    \n    # Carol's meetings on Monday (in minutes)\n    carol_meetings = [\n        (9 * 60 + 30, 12 * 60 + 0),\n        (12 * 60 + 30, 13 * 60 + 0),\n        (13 * 60 + 30, 15 * 60 + 0),\n        (15 * 60 + 30, 17 * 60 + 0)\n    ]\n    \n    # Combine and sort all meetings for both participants on Monday\n    all_meetings = martha_meetings + carol_meetings\n    all_meetings.sort()\n    \n    # Check the available slots before the first meeting, between meetings, and after the last meeting\n    previous_end = work_start\n    available_slots = []\n    \n    for meeting in all_meetings:\n        start, end = meeting\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Find the first available slot that can fit a 30-minute meeting\n    meeting_duration = 30\n    for slot in available_slots:\n        start, end = slot\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available slot found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_713"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday']\n\n    # Zachary's busy times in minutes since start of day\n    zachary_busy = {\n        'Monday': [(12 * 60, 12 * 60 + 30), (14 * 60 + 30, 15 * 60)],\n        'Tuesday': [(9 * 60 + 30, 10 * 60), (11 * 60 + 30, 12 * 60), (15 * 60 + 30, 16 * 60)],\n        'Wednesday': [(11 * 60 + 30, 12 * 60)]\n    }\n\n    # Debra's busy times in minutes since start of day\n    debra_busy = {\n        'Monday': [(9 * 60 + 30, 11 * 60), (11 * 60 + 30, 12 * 60), (13 * 60, 13 * 60 + 30), (14 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 14 * 60 + 30), (15 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 10 * 60), (11 * 60, 13 * 60 + 30), (14 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)]\n    }\n\n    # Zachary cannot meet on Monday after 12:30\n    zachary_busy['Monday'].append((12 * 60 + 30, 24 * 60))\n\n    # Debra prefers not to meet on Tuesday, so we'll try Wednesday first, then Monday\n    preferred_days = ['Wednesday', 'Monday']\n\n    for day in preferred_days:\n        # Combine and sort all busy intervals for both participants\n        all_busy = zachary_busy.get(day, []) + debra_busy.get(day, [])\n        all_busy.sort()\n\n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n\n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n\n        # Check for a suitable slot\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= meeting_duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    # If no slot found in preferred days, try Tuesday (though Debra prefers not)\n    day = 'Tuesday'\n    all_busy = zachary_busy.get(day, []) + debra_busy.get(day, [])\n    all_busy.sort()\n\n    free_slots = []\n    prev_end = work_start\n\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_714"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{10:00:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Tuesday', 'Wednesday']  # Monday is excluded as per Jennifer's constraint\n    \n    # Denise's schedule in minutes since midnight for each day\n    denise_schedule = {\n        'Monday': [(9 * 60, 9 * 60 + 30), (10 * 60, 11 * 60), (11 * 60 + 30, 12 * 60), (13 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60 + 30, 10 * 60), (11 * 60, 11 * 60 + 30), (13 * 60 + 30, 14 * 60), (15 * 60, 16 * 60 + 30)],\n        'Wednesday': [(9 * 60 + 30, 11 * 60), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60), (14 * 60 + 30, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)]\n    }\n    \n    # Jennifer's schedule is wide open except Monday, so only Denise's schedule matters\n    \n    meeting_duration = 60  # 1 hour\n    \n    # Iterate through each day in order\n    for day in days:\n        # Get Denise's busy times for the day\n        busy_times = denise_schedule[day]\n        # Start checking from the beginning of the work day\n        current_time = work_start\n        \n        # Iterate through busy times to find gaps\n        for busy_start, busy_end in busy_times:\n            if busy_start > current_time:\n                # Found a gap before this busy time\n                gap_start = current_time\n                gap_end = busy_start\n                if gap_end - gap_start >= meeting_duration:\n                    # Found a suitable gap\n                    meeting_start = gap_start\n                    meeting_end = meeting_start + meeting_duration\n                    # Format the time as HH:MM:HH:MM\n                    return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n            # Update current_time to the end of this busy period\n            current_time = max(current_time, busy_end)\n        \n        # Check after the last busy time\n        if work_end - current_time >= meeting_duration:\n            meeting_start = current_time\n            meeting_end = meeting_start + meeting_duration\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    # If no time found (though the problem states there is a solution)\n    return \"No time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_715"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Debra's constraints (in minutes, converted from HH:MM)\n    debra_busy = {\n        'Tuesday': [(10 * 60 + 30, 11 * 60), (13 * 60, 13 * 60 + 30)],\n        'Wednesday': [(9 * 60 + 30, 10 * 60), (11 * 60 + 30, 12 * 60)]\n    }\n    \n    # Keith's constraints (in minutes, converted from HH:MM)\n    keith_busy = {\n        'Monday': [(9 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 11 * 60 + 30), (12 * 60, 13 * 60), (13 * 60 + 30, 17 * 60)],\n        'Wednesday': [(9 * 60, 9 * 60 + 30), (10 * 60, 13 * 60), (13 * 60 + 30, 14 * 60), \n                     (14 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)]\n    }\n    \n    # Days to consider (Debra doesn't want Wednesday)\n    days = ['Monday', 'Tuesday']\n    \n    for day in days:\n        # Collect all busy intervals for both participants on the current day\n        busy_intervals = []\n        if day in debra_busy:\n            busy_intervals.extend(debra_busy[day])\n        if day in keith_busy:\n            busy_intervals.extend(keith_busy[day])\n        \n        # Sort busy intervals by start time\n        busy_intervals.sort()\n        \n        # Find free slots by checking gaps between busy intervals\n        prev_end = work_start\n        for start, end in busy_intervals:\n            if start > prev_end:\n                # Check if the gap is enough for the meeting\n                if start - prev_end >= meeting_duration:\n                    # Format the time as HH:MM:HH:MM\n                    start_time = f\"{prev_end // 60:02d}:{prev_end % 60:02d}\"\n                    end_time = f\"{(prev_end + meeting_duration) // 60:02d}:{(prev_end + meeting_duration) % 60:02d}\"\n                    return f\"{start_time}:{end_time}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after the last busy interval\n        if work_end - prev_end >= meeting_duration:\n            start_time = f\"{prev_end // 60:02d}:{prev_end % 60:02d}\"\n            end_time = f\"{(prev_end + meeting_duration) // 60:02d}:{(prev_end + meeting_duration) % 60:02d}\"\n            return f\"{start_time}:{end_time}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_716"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday']\n\n    # Define blocked times for each person in minutes since midnight\n    evelyn_blocked = {\n        'Monday': [(9*60, 10*60), (11*60, 11*60+30), (12*60+30, 14*60+30), (15*60, 15*60+30), (16*60, 17*60)],\n        'Tuesday': [(9*60+30, 10*60), (12*60+30, 13*60), (14*60, 15*60), (15*60+30, 16*60)],\n        'Wednesday': [(9*60, 9*60+30), (11*60+30, 12*60), (14*60, 14*60+30)]\n    }\n\n    julia_blocked = {\n        'Monday': [(9*60, 10*60), (10*60+30, 15*60), (15*60+30, 17*60)],\n        'Tuesday': [(9*60, 15*60+30), (16*60, 17*60)],\n        'Wednesday': [(9*60, 13*60), (13*60+30, 17*60)]\n    }\n\n    # Iterate through each day to find the earliest available slot\n    for day in days:\n        # Collect all blocked times for both participants\n        all_blocked = evelyn_blocked.get(day, []) + julia_blocked.get(day, [])\n        all_blocked.sort()\n\n        # Check the time before the first blocked period\n        if len(all_blocked) > 0:\n            first_block_start = all_blocked[0][0]\n            if first_block_start - work_start >= meeting_duration:\n                start_time = work_start\n                end_time = start_time + meeting_duration\n                return f\"{format_time(start_time)}:{format_time(end_time)}\"\n\n        # Check gaps between blocked periods\n        for i in range(len(all_blocked) - 1):\n            current_end = all_blocked[i][1]\n            next_start = all_blocked[i+1][0]\n            if next_start - current_end >= meeting_duration:\n                start_time = current_end\n                end_time = start_time + meeting_duration\n                return f\"{format_time(start_time)}:{format_time(end_time)}\"\n\n        # Check the time after the last blocked period\n        if len(all_blocked) > 0:\n            last_block_end = all_blocked[-1][1]\n            if work_end - last_block_end >= meeting_duration:\n                start_time = last_block_end\n                end_time = start_time + meeting_duration\n                return f\"{format_time(start_time)}:{format_time(end_time)}\"\n        else:\n            # No blocked times, schedule at work_start\n            start_time = work_start\n            end_time = start_time + meeting_duration\n            return f\"{format_time(start_time)}:{format_time(end_time)}\"\n\n    return \"No time found\"\n\ndef format_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_717"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Days to check: Monday (0), Tuesday (1), Wednesday (2)\n    days = [0, 1, 2]\n    \n    # Jesse's busy times in minutes since midnight for each day\n    jesse_busy = {\n        0: [(10*60 + 30, 11*60), (11*60 + 30, 12*60 + 30), (15*60 + 30, 16*60)],\n        1: [(13*60, 13*60 + 30), (15*60 + 30, 16*60)],\n        2: [(10*60, 10*60 + 30), (13*60, 13*60 + 30), (14*60, 14*60 + 30), (16*60 + 30, 17*60)]\n    }\n    \n    # Martha's busy times in minutes since midnight for each day\n    martha_busy = {\n        0: [(9*60 + 30, 11*60), (12*60, 12*60 + 30), (14*60 + 30, 15*60)],\n        1: [(9*60, 10*60 + 30), (11*60 + 30, 12*60 + 30), (13*60, 14*60 + 30), (15*60, 17*60)],\n        2: [(9*60, 9*60 + 30), (10*60 + 30, 12*60), (13*60, 15*60 + 30), (16*60, 17*60)]\n    }\n    \n    # Check each day in order\n    for day in days:\n        # Get both participants' busy times for the day\n        busy_times = jesse_busy.get(day, []) + martha_busy.get(day, [])\n        busy_times.sort()\n        \n        # Find all free slots in the day\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in busy_times:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for a 30-minute window\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= 30:\n                meeting_start = slot_start\n                meeting_end = meeting_start + 30\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_718"
        },
        {
            "final_program_time": "{11:00:12:00}",
            "expected_time": "{11:00:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Define Teresa's schedule in minutes since midnight\n    teresa_schedule = {\n        'Monday': [(9 * 60, 11 * 60), (12 * 60, 14.5 * 60), (15 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 12 * 60), (12.5 * 60, 14 * 60), (14.5 * 60, 16.5 * 60)]\n    }\n\n    # Iterate through each day to find a suitable time\n    for day in days:\n        # Get Teresa's busy times for the day\n        busy_times = teresa_schedule.get(day, [])\n        # Generate free slots by finding gaps between busy times\n        free_slots = []\n        prev_end = work_start\n        for start, end in sorted(busy_times):\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = end\n        # Check the slot after the last busy time\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n\n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= meeting_duration:\n                # Found a suitable slot\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                # Convert minutes back to HH:MM format\n                start_hh = int(meeting_start // 60)\n                start_mm = int(meeting_start % 60)\n                end_hh = int(meeting_end // 60)\n                end_mm = int(meeting_end % 60)\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_719"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to consider (Monday, Tuesday, Wednesday)\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Mary's constraints: free all week but doesn't want to meet on Tuesday\n    mary_available_days = ['Monday', 'Wednesday']\n    \n    # Catherine's blocked times in minutes since midnight\n    catherine_blocked = {\n        'Monday': [\n            (10 * 60, 10 * 60 + 30),    # 10:00-10:30\n            (11 * 60, 11 * 60 + 30),    # 11:00-11:30\n            (12 * 60 + 30, 13 * 60),    # 12:30-13:00\n            (13 * 60 + 30, 14 * 60),    # 13:30-14:00\n            (15 * 60, 17 * 60)          # 15:00-17:00\n        ],\n        'Tuesday': [\n            (9 * 60 + 30, 10 * 60 + 30),  # 9:30-10:30\n            (11 * 60 + 30, 12 * 60 + 30),  # 11:30-12:30\n            (13 * 60, 14 * 60),            # 13:00-14:00\n            (15 * 60, 15 * 60 + 30)        # 15:00-15:30\n        ],\n        'Wednesday': [\n            (9 * 60 + 30, 12 * 60 + 30),  # 9:30-12:30\n            (14 * 60, 15 * 60),           # 14:00-15:00\n            (15 * 60 + 30, 17 * 60)       # 15:30-17:00\n        ]\n    }\n    \n    meeting_duration = 30  # minutes\n    \n    # Iterate through available days for Mary (Monday, Wednesday)\n    for day in mary_available_days:\n        # Get Catherine's blocked times for the day\n        blocked_times = catherine_blocked.get(day, [])\n        \n        # Sort blocked times by start time\n        blocked_times.sort()\n        \n        # Check available slots before first blocked time\n        if len(blocked_times) == 0:\n            # Entire day is free\n            start_time = work_start\n            end_time = start_time + meeting_duration\n            if end_time <= work_end:\n                return f\"{start_time//60:02d}:{start_time%60:02d}:{end_time//60:02d}:{end_time%60:02d}\"\n        \n        # Check before first blocked time\n        first_block_start = blocked_times[0][0]\n        if work_start + meeting_duration <= first_block_start:\n            start_time = work_start\n            end_time = start_time + meeting_duration\n            return f\"{start_time//60:02d}:{start_time%60:02d}:{end_time//60:02d}:{end_time%60:02d}\"\n        \n        # Check between blocked times\n        for i in range(len(blocked_times) - 1):\n            current_block_end = blocked_times[i][1]\n            next_block_start = blocked_times[i+1][0]\n            if current_block_end + meeting_duration <= next_block_start:\n                start_time = current_block_end\n                end_time = start_time + meeting_duration\n                return f\"{start_time//60:02d}:{start_time%60:02d}:{end_time//60:02d}:{end_time%60:02d}\"\n        \n        # Check after last blocked time\n        last_block_end = blocked_times[-1][1]\n        if last_block_end + meeting_duration <= work_end:\n            start_time = last_block_end\n            end_time = start_time + meeting_duration\n            return f\"{start_time//60:02d}:{start_time%60:02d}:{end_time//60:02d}:{end_time%60:02d}\"\n    \n    return \"No available time found\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_720"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Days to consider: Monday (0), Tuesday (1), Wednesday (2)\n    days = [0, 1, 2]\n    \n    # Jessica's busy times in minutes since midnight for each day\n    jessica_busy = {\n        0: [(9*60 + 30, 10*60), (11*60 + 30, 12*60 + 30)],  # Monday\n        1: [(9*60 + 30, 10*60), (11*60, 11*60 + 30), (12*60, 14*60 + 30), (15*60 + 30, 16*60)],  # Tuesday\n        2: [(12*60, 12*60 + 30), (13*60 + 30, 14*60 + 30)]  # Wednesday\n    }\n    \n    # Carol's busy times in minutes since midnight for each day\n    carol_busy = {\n        0: [(9*60, 11*60 + 30), (12*60, 13*60 + 30), (14*60, 14*60 + 30), (15*60, 16*60 + 30)],  # Monday\n        1: [(9*60 + 30, 10*60), (11*60 + 30, 12*60 + 30), (14*60, 14*60 + 30), (15*60, 15*60 + 30), (16*60, 16*60 + 30)],  # Tuesday\n        2: [(9*60 + 30, 10*60 + 30), (12*60, 15*60), (15*60 + 30, 16*60), (16*60 + 30, 17*60)]  # Wednesday\n    }\n    \n    # Carol cannot meet on Tuesday, so remove Tuesday from consideration\n    days.remove(1)\n    \n    meeting_duration = 60  # 1 hour\n    \n    for day in days:\n        # Combine and sort all busy intervals for both participants\n        all_busy = jessica_busy.get(day, []) + carol_busy.get(day, [])\n        all_busy.sort()\n        \n        # Find free slots\n        prev_end = work_start\n        free_slots = []\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            available_start = slot_start\n            available_end = slot_end\n            \n            if available_end - available_start >= meeting_duration:\n                # Convert back to HH:MM format\n                meeting_start = available_start\n                meeting_end = meeting_start + meeting_duration\n                \n                # Format as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                \n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_721"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    meeting_duration = 60  # minutes\n    \n    # Elijah's busy times in minutes since midnight for each day\n    elijah_busy = {\n        'Monday': [(13 * 60, 13 * 60 + 30)],\n        'Tuesday': [(14 * 60 + 30, 15 * 60)],\n        'Wednesday': [(10 * 60 + 30, 11 * 60), (13 * 60, 13 * 60 + 30)]\n    }\n    \n    # Zachary's busy times in minutes since midnight for each day\n    zachary_busy = {\n        'Monday': [\n            (9 * 60, 12 * 60),\n            (13 * 60 + 30, 14 * 60 + 30),\n            (15 * 60, 16 * 60),\n            (16 * 60 + 30, 17 * 60)\n        ],\n        'Tuesday': [\n            (9 * 60, 9 * 60 + 30),\n            (10 * 60, 11 * 60),\n            (12 * 60, 14 * 60 + 30),\n            (15 * 60, 16 * 60),\n            (16 * 60 + 30, 17 * 60)\n        ],\n        'Wednesday': [\n            (10 * 60 + 30, 15 * 60),\n            (16 * 60, 16 * 60 + 30)\n        ]\n    }\n    \n    # Iterate through days in order, prioritizing Monday, then Wednesday (avoid Tuesday)\n    preferred_days = ['Monday', 'Wednesday', 'Tuesday']\n    \n    for day in preferred_days:\n        # Combine and sort all busy intervals for both participants on this day\n        all_busy = elijah_busy.get(day, []) + zachary_busy.get(day, [])\n        all_busy.sort()\n        \n        # Find available slots\n        available_slots = []\n        prev_end = work_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy interval\n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n        \n        # Check each available slot for enough time\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= meeting_duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_722"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Arthur's schedule: {day: [(start, end), ...]}\n    arthur_schedule = {\n        'Monday': [(11 * 60, 11 * 60 + 30), (13 * 60 + 30, 14 * 60), (15 * 60, 15 * 60 + 30)],\n        'Tuesday': [(13 * 60, 13 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Wednesday': [(10 * 60, 10 * 60 + 30), (11 * 60, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (14 * 60, 14 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n    }\n    \n    # Michael's schedule: {day: [(start, end), ...]}\n    michael_schedule = {\n        'Monday': [(9 * 60, 12 * 60), (12 * 60 + 30, 13 * 60), (14 * 60, 14 * 60 + 30), (15 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60 + 30, 11 * 60 + 30), (12 * 60, 13 * 60 + 30), (14 * 60, 15 * 60 + 30)],\n        'Wednesday': [(10 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30)],\n    }\n    \n    # Arthur cannot meet on Tuesday\n    days_to_check = [day for day in days if day != 'Tuesday']\n    \n    for day in days_to_check:\n        # Collect all busy times for both participants\n        busy_times = []\n        busy_times.extend(arthur_schedule.get(day, []))\n        busy_times.extend(michael_schedule.get(day, []))\n        \n        # Sort busy times by start time\n        busy_times.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in busy_times:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after last meeting\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for 30-minute availability\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= 30:\n                meeting_start = slot_start\n                meeting_end = meeting_start + 30\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_723"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday']\n\n    # Tyler's busy times in minutes since midnight\n    tyler_busy = {\n        'Monday': [],\n        'Tuesday': [(9 * 60, 9 * 60 + 30), (14 * 60 + 30, 15 * 60)],\n        'Wednesday': [(10 * 60 + 30, 11 * 60), (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60), (16 * 60 + 30, 17 * 60)]\n    }\n\n    # Ruth's busy times in minutes since midnight\n    ruth_busy = {\n        'Monday': [(9 * 60, 10 * 60), (10 * 60 + 30, 12 * 60), (12 * 60 + 30, 14 * 60 + 30), (15 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 17 * 60)]\n    }\n\n    # Tyler's preference to avoid Monday before 16:00\n    tyler_preference = {\n        'Monday': (work_start, 16 * 60)\n    }\n\n    # Iterate through each day\n    for day in days:\n        # Check if Ruth is entirely busy on this day (like Tuesday and Wednesday)\n        if day in ruth_busy and any(start == work_start and end == work_end for start, end in ruth_busy[day]):\n            continue\n\n        # Generate all possible time slots for the day\n        current_time = work_start\n        while current_time + meeting_duration <= work_end:\n            slot_start = current_time\n            slot_end = current_time + meeting_duration\n\n            # Check Tyler's availability\n            tyler_available = True\n            for busy_start, busy_end in tyler_busy.get(day, []):\n                if not (slot_end <= busy_start or slot_start >= busy_end):\n                    tyler_available = False\n                    break\n            if not tyler_available:\n                current_time += 15  # Move to next possible slot (15-minute increment)\n                continue\n\n            # Check Ruth's availability\n            ruth_available = True\n            for busy_start, busy_end in ruth_busy.get(day, []):\n                if not (slot_end <= busy_start or slot_start >= busy_end):\n                    ruth_available = False\n                    break\n            if not ruth_available:\n                current_time += 15\n                continue\n\n            # Check Tyler's preference for Monday\n            if day == 'Monday':\n                pref_start, pref_end = tyler_preference['Monday']\n                if slot_start < pref_end:\n                    current_time += 15\n                    continue\n\n            # If all checks passed, return the slot\n            return f\"{int(slot_start // 60):02d}:{int(slot_start % 60):02d}:{int(slot_end // 60):02d}:{int(slot_end % 60):02d}\"\n\n            current_time += 15\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_724"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define schedules for Brittany and Bruce\n    brittany_schedule = {\n        'Monday': [(9*60, 10*60), (10*60 + 30, 11*60 + 30), (14*60 + 30, 15*60), (16*60, 17*60)],\n        'Tuesday': [(9*60, 9*60 + 30), (12*60, 12*60 + 30), (13*60, 13*60 + 30), (14*60 + 30, 15*60 + 30), (16*60 + 30, 17*60)],\n        'Wednesday': [(9*60, 9*60 + 30), (10*60 + 30, 11*60 + 30), (13*60 + 30, 14*60), (16*60, 16*60 + 30)]\n    }\n    \n    bruce_schedule = {\n        'Monday': [(9*60 + 30, 10*60), (10*60 + 30, 11*60 + 30), (12*60 + 30, 15*60), (15*60 + 30, 17*60)],\n        'Tuesday': [(10*60, 10*60 + 30), (11*60 + 30, 12*60), (14*60 + 30, 17*60)],\n        'Wednesday': [(12*60 + 30, 13*60), (13*60 + 30, 14*60 + 30), (15*60, 16*60 + 30)]\n    }\n    \n    # Iterate through each day to find the earliest available slot\n    for day in days:\n        # Get busy slots for both participants\n        brittany_busy = brittany_schedule.get(day, [])\n        bruce_busy = bruce_schedule.get(day, [])\n        \n        # Combine and sort all busy slots\n        all_busy = brittany_busy + bruce_busy\n        all_busy.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for a 30-minute window\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= 30:\n                meeting_start = slot_start\n                meeting_end = meeting_start + 30\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_725"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to consider\n    days = ['Monday', 'Tuesday', 'Wednesday']\n\n    # Define blocked times for Frank and Judy in minutes since start of day\n    frank_blocked = {\n        'Tuesday': [(9 * 60 + 30, 10 * 60), (16 * 60 + 30, 17 * 60)],\n        'Wednesday': [(9 * 60, 10 * 60 + 30), (15 * 60, 15 * 60 + 30)]\n    }\n\n    judy_blocked = {\n        'Monday': [(9 * 60, 14 * 60 + 30), (15 * 60, 16 * 60 + 30)],\n        'Tuesday': [(10 * 60, 10 * 60 + 30), (11 * 60 + 30, 13 * 60),\n                    (14 * 60, 14 * 60 + 30), (15 * 60, 15 * 60 + 30),\n                    (16 * 60 + 30, 17 * 60)],\n        'Wednesday': [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 12 * 60),\n                      (16 * 60, 16 * 60 + 30)]\n    }\n\n    # Judy prefers not to meet on Monday, so we check Tuesday and Wednesday first\n    preferred_days = ['Tuesday', 'Wednesday', 'Monday']\n\n    for day in preferred_days:\n        # Get blocked times for both participants on this day\n        frank_blocks = frank_blocked.get(day, [])\n        judy_blocks = judy_blocked.get(day, [])\n\n        # Combine and sort all blocked times\n        all_blocks = frank_blocks + judy_blocks\n        all_blocks.sort()\n\n        # Check available slots\n        prev_end = work_start\n        for block_start, block_end in all_blocks:\n            if block_start > prev_end:\n                # Found a potential slot\n                slot_start = prev_end\n                slot_end = block_start\n                if slot_end - slot_start >= meeting_duration:\n                    # Return the earliest possible time on the preferred day\n                    meeting_start = slot_start\n                    meeting_end = meeting_start + meeting_duration\n                    return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n            prev_end = max(prev_end, block_end)\n\n        # Check after last block\n        if work_end - prev_end >= meeting_duration:\n            meeting_start = prev_end\n            meeting_end = meeting_start + meeting_duration\n            return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n\n    return \"No time found\"  # Shouldn't happen as per problem statement\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_726"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to consider\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define George's blocked times in minutes since midnight\n    george_blocked = {\n        'Monday': [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 11 * 60)],\n        'Tuesday': [(9 * 60, 10 * 60), (13 * 60, 14 * 60), (15 * 60, 15 * 60 + 30)],\n        'Wednesday': [(10 * 60, 11 * 60), (12 * 60, 12 * 60 + 30), (14 * 60 + 30, 15 * 60), (16 * 60, 16 * 60 + 30)]\n    }\n    \n    # Define Jose's blocked times in minutes since midnight\n    jose_blocked = {\n        'Monday': [(9 * 60, 10 * 60 + 30), (11 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60), (16 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 10 * 60), (11 * 60, 12 * 60), (12 * 60 + 30, 13 * 60), (15 * 60, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n        'Wednesday': [(10 * 60, 11 * 60), (12 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 17 * 60)]\n    }\n    \n    # George's preferences: not Monday, Tuesday after 15:00, Wednesday\n    preferred_days = ['Wednesday', 'Tuesday']\n    \n    # Check each day in preferred order\n    for day in preferred_days:\n        # Get blocked times for both participants\n        g_blocked = george_blocked.get(day, [])\n        j_blocked = jose_blocked.get(day, [])\n        \n        # Combine and sort all blocked times\n        all_blocked = g_blocked + j_blocked\n        all_blocked.sort()\n        \n        # Find available slots\n        available_slots = []\n        prev_end = work_start\n        \n        for start, end in all_blocked:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n        \n        # Check for a 30-minute slot\n        for start, end in available_slots:\n            if end - start >= 30:\n                # Check George's preference for Tuesday after 15:00\n                if day == 'Tuesday':\n                    if start >= 15 * 60:\n                        return f\"{start//60:02d}:{start%60:02d}:{start//60:02d}:{(start+30)%60:02d}\"\n                else:\n                    return f\"{start//60:02d}:{start%60:02d}:{start//60:02d}:{(start+30)%60:02d}\"\n    \n    # If no preferred day works, check Monday (though George prefers not to)\n    day = 'Monday'\n    g_blocked = george_blocked.get(day, [])\n    j_blocked = jose_blocked.get(day, [])\n    all_blocked = g_blocked + j_blocked\n    all_blocked.sort()\n    \n    prev_end = work_start\n    for start, end in all_blocked:\n        if start > prev_end:\n            if start - prev_end >= 30:\n                return f\"{prev_end//60:02d}:{prev_end%60:02d}:{prev_end//60:02d}:{(prev_end+30)%60:02d}\"\n        prev_end = max(prev_end, end)\n    \n    if work_end - prev_end >= 30:\n        return f\"{prev_end//60:02d}:{prev_end%60:02d}:{prev_end//60:02d}:{(prev_end+30)%60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_727"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define busy slots for each person in minutes since midnight\n    abigail_busy = {\n        'Monday': [(9*60, 10*60), (11*60, 12*60), (12*60 + 30, 13*60), (14*60 + 30, 15*60)],\n        'Tuesday': [(12*60 + 30, 13*60)],\n        'Wednesday': [(14*60, 14*60 + 30)]\n    }\n    \n    albert_busy = {\n        'Monday': [(9*60, 9*60 + 30), (10*60, 11*60), (12*60, 14*60 + 30), (15*60, 15*60 + 30), (16*60 + 30, 17*60)],\n        'Tuesday': [(10*60 + 30, 12*60), (12*60 + 30, 13*60), (14*60, 15*60), (16*60 + 30, 17*60)],\n        'Wednesday': [(9*60 + 30, 10*60 + 30), (12*60, 13*60 + 30), (14*60 + 30, 15*60 + 30)]\n    }\n    \n    # Apply preferences: Abigail doesn't want Monday, Albert can't do Tuesday\n    preferred_days = [day for day in days if day != 'Monday' and day != 'Tuesday']\n    \n    # Iterate through each day to find the earliest available slot\n    for day in preferred_days:\n        # Combine and sort all busy slots for both participants\n        combined_busy = abigail_busy.get(day, []) + albert_busy.get(day, [])\n        combined_busy.sort()\n        \n        # Check the time before the first busy slot\n        prev_end = work_start\n        for start, end in combined_busy:\n            if start > prev_end:\n                # Check if the gap is at least 30 minutes\n                if start - prev_end >= 30:\n                    return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + 30)}\"\n            prev_end = max(prev_end, end)\n        \n        # Check the time after the last busy slot\n        if work_end - prev_end >= 30:\n            return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + 30)}\"\n    \n    # If no slot found in preferred days, check Monday (even though Abigail doesn't prefer it)\n    day = 'Monday'\n    combined_busy = abigail_busy.get(day, []) + albert_busy.get(day, [])\n    combined_busy.sort()\n    \n    prev_end = work_start\n    for start, end in combined_busy:\n        if start > prev_end:\n            if start - prev_end >= 30:\n                return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + 30)}\"\n        prev_end = max(prev_end, end)\n    \n    if work_end - prev_end >= 30:\n        return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + 30)}\"\n    \n    return \"No suitable time found\"\n\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_728"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    meeting_duration = 60  # minutes\n    \n    # Define Dennis's busy times in minutes since midnight for each day\n    dennis_busy = {\n        'Monday': [(9 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 11 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 9 * 60 + 30), (10 * 60, 17 * 60)]\n    }\n    \n    # Iterate through each day to find a suitable time\n    for day in days:\n        if day not in dennis_busy:\n            # Dennis is free all day (not the case here, but general)\n            return f\"{day}: {work_start//60:02d}:{work_start%60:02d}:{(work_start + meeting_duration)//60:02d}:{(work_start + meeting_duration)%60:02d}\"\n        \n        # Get Dennis's busy slots for the day\n        busy_slots = dennis_busy[day]\n        # Sort the busy slots by start time\n        busy_slots.sort()\n        \n        # Check the time before the first busy slot\n        prev_end = work_start\n        for slot in busy_slots:\n            slot_start, slot_end = slot\n            if slot_start - prev_end >= meeting_duration:\n                # Found a suitable time\n                start_time = prev_end\n                end_time = start_time + meeting_duration\n                return f\"{day}: {start_time//60:02d}:{start_time%60:02d}:{end_time//60:02d}:{end_time%60:02d}\"\n            prev_end = max(prev_end, slot_end)\n        \n        # Check the time after the last busy slot\n        if work_end - prev_end >= meeting_duration:\n            start_time = prev_end\n            end_time = start_time + meeting_duration\n            return f\"{day}: {start_time//60:02d}:{start_time%60:02d}:{end_time//60:02d}:{end_time%60:02d}\"\n    \n    return \"No suitable time found.\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_729"
        },
        {
            "final_program_time": "{16:00:17:00}",
            "expected_time": "{16:00:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to consider (Monday, Tuesday)\n    days = ['Monday', 'Tuesday']\n    \n    # Define busy slots for Grace and Dennis in minutes\n    grace_busy = {\n        'Monday': [(9 * 60, 9 * 60 + 30)],\n        'Tuesday': [],\n        'Wednesday': [(16 * 60, 16 * 60 + 30)]\n    }\n    \n    dennis_busy = {\n        'Monday': [\n            (9 * 60, 11 * 60),\n            (11 * 60 + 30, 12 * 60),\n            (12 * 60 + 30, 13 * 60),\n            (13 * 60 + 30, 15 * 60 + 30),\n            (16 * 60, 17 * 60)\n        ],\n        'Tuesday': [\n            (9 * 60, 10 * 60 + 30),\n            (11 * 60, 11 * 60 + 30),\n            (12 * 60, 14 * 60),\n            (14 * 60 + 30, 16 * 60)\n        ],\n        'Wednesday': [\n            (9 * 60, 10 * 60),\n            (10 * 60 + 30, 12 * 60 + 30),\n            (14 * 60, 16 * 60),\n            (16 * 60 + 30, 17 * 60)\n        ]\n    }\n    \n    # Grace doesn't want to meet on Wednesday, so we skip it\n    meeting_duration = 60  # 1 hour\n    \n    for day in days:\n        # Combine busy slots for both participants\n        combined_busy = grace_busy[day] + dennis_busy[day]\n        combined_busy.sort()  # Sort by start time\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in combined_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check for a slot that can fit the meeting\n        for start, end in free_slots:\n            if end - start >= meeting_duration:\n                meeting_start = start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_730"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:12:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participant_busy_times, work_hours, meeting_duration, days):\n    # Convert work hours and busy times to minutes for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    meeting_duration_min = meeting_duration * 60\n\n    # Iterate through each day to find the earliest available slot\n    for day in days:\n        # Get busy times for the current day\n        busy_times_day = []\n        for person in participant_busy_times:\n            if day in person:\n                busy_times_day.extend(person[day])\n        \n        # Sort all busy times for the day\n        busy_times_day.sort()\n\n        # Check available slots before the first busy time, between busy times, and after last busy time\n        previous_end = work_start\n        for busy_start, busy_end in busy_times_day:\n            busy_start_min = busy_start[0] * 60 + busy_start[1]\n            busy_end_min = busy_end[0] * 60 + busy_end[1]\n            \n            # Check if there's enough time between previous_end and busy_start_min\n            if busy_start_min - previous_end >= meeting_duration_min:\n                # Found a slot\n                start_hour = previous_end // 60\n                start_min = previous_end % 60\n                end_hour = (previous_end + meeting_duration_min) // 60\n                end_min = (previous_end + meeting_duration_min) % 60\n                return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n            \n            # Update previous_end to the end of this busy time\n            previous_end = max(previous_end, busy_end_min)\n        \n        # Check after the last busy time\n        if work_end - previous_end >= meeting_duration_min:\n            start_hour = previous_end // 60\n            start_min = previous_end % 60\n            end_hour = (previous_end + meeting_duration_min) // 60\n            end_min = (previous_end + meeting_duration_min) % 60\n            return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n    \n    return \"No available time slot found\"\n\n# Define the problem constraints\nparticipant_busy_times = [\n    {\n        \"Monday\": [(9, 0, 11, 0), (14, 0, 16, 0)],\n        \"Tuesday\": [(9, 0, 10, 30), (11, 30, 12, 0), (14, 0, 14, 30), (16, 0, 16, 30)],\n        \"Wednesday\": [(9, 0, 14, 0), (15, 0, 17, 0)]\n    }\n]\n\nwork_hours = (9, 17)  # 9:00 to 17:00\nmeeting_duration = 1  # 1 hour\ndays_to_check = [\"Monday\", \"Tuesday\", \"Wednesday\"]\n\n# Find the earliest meeting time\nmeeting_time = find_meeting_time(participant_busy_times, work_hours, meeting_duration, days_to_check)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_731"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(christine_busy, jose_busy, work_hours, days, duration):\n    for day in days:\n        # Convert work hours to minutes for the day\n        start_work = work_hours[0] * 60\n        end_work = work_hours[1] * 60\n        \n        # Generate all possible slots for the day\n        possible_slots = []\n        current_time = start_work\n        \n        while current_time + duration <= end_work:\n            slot_end = current_time + duration\n            possible_slots.append((current_time, slot_end))\n            current_time += 30  # Assuming 30-minute increments for efficiency\n        \n        # Filter slots where both are free\n        for slot in possible_slots:\n            slot_start, slot_end = slot\n            christine_free = True\n            jose_free = True\n            \n            # Check Christine's schedule\n            for busy in christine_busy.get(day, []):\n                busy_start = busy[0] * 60\n                busy_end = busy[1] * 60\n                if not (slot_end <= busy_start or slot_start >= busy_end):\n                    christine_free = False\n                    break\n            \n            # Check Jose's schedule\n            for busy in jose_busy.get(day, []):\n                busy_start = busy[0] * 60\n                busy_end = busy[1] * 60\n                if not (slot_end <= busy_start or slot_start >= busy_end):\n                    jose_free = False\n                    break\n            \n            if christine_free and jose_free:\n                # Convert back to HH:MM format\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_hh = slot_end // 60\n                end_mm = slot_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Define the busy schedules\nchristine_busy = {\n    'Monday': [(15, 15.5), (16, 16.5)],\n    'Tuesday': [(9.5, 10)],\n    'Wednesday': [(12, 12.5), (13.5, 14), (15.5, 16)]\n}\n\njose_busy = {\n    'Monday': [(9, 10.5), (11, 11.5), (12.5, 14.5), (15, 17)],\n    'Tuesday': [(9.5, 13.5), (14, 16), (16.5, 17)],\n    'Wednesday': [(10, 10.5), (11, 13.5), (14, 14.5), (15, 15.5), (16.5, 17)]\n}\n\n# Define the parameters\nwork_hours = (9, 17)  # 9:00 to 17:00\ndays = ['Monday', 'Tuesday', 'Wednesday']\nduration = 30  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(christine_busy, jose_busy, work_hours, days, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_732"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to consider\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define blocked times for George and Carl in minutes since start of day\n    george_blocked = {\n        'Monday': [(10*60, 10*60+30), (12*60, 13*60), (13*60+30, 14*60+30), (15*60, 16*60+30)],\n        'Tuesday': [(10*60, 10*60+30), (13*60+30, 14*60+30)],\n        'Wednesday': [(9*60, 9*60+30), (10*60, 11*60), (13*60+30, 15*60), (15*60+30, 16*60)]\n    }\n    \n    carl_blocked = {\n        'Monday': [(10*60+30, 11*60), (11*60+30, 12*60), (13*60, 14*60), (16*60+30, 17*60)],\n        'Tuesday': [(9*60, 9*60+30), (10*60, 10*60+30), (11*60, 12*60+30), (13*60+30, 14*60+30), (15*60+30, 17*60)],\n        'Wednesday': [(9*60+30, 10*60+30), (11*60, 13*60+30), (14*60, 14*60+30), (16*60+30, 17*60)]\n    }\n    \n    # Additional constraints\n    george_no_monday_after_1230 = True\n    carl_avoid_tuesday = True\n    carl_avoid_wednesday = True\n    \n    # Iterate through each day to find a suitable time\n    for day in days:\n        if day == 'Monday' and george_no_monday_after_1230:\n            # George doesn't want to meet on Monday after 12:30\n            day_end = 12 * 60 + 30\n        else:\n            day_end = work_end\n        \n        if day == 'Tuesday' and carl_avoid_tuesday:\n            continue\n        if day == 'Wednesday' and carl_avoid_wednesday:\n            continue\n        \n        # Combine and sort all blocked times for both participants\n        all_blocked = george_blocked.get(day, []) + carl_blocked.get(day, [])\n        all_blocked_sorted = sorted(all_blocked, key=lambda x: x[0])\n        \n        # Find available slots\n        available_slots = []\n        prev_end = work_start\n        \n        for start, end in all_blocked_sorted:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < day_end:\n            available_slots.append((prev_end, day_end))\n        \n        # Check each available slot for 30-minute duration\n        for slot in available_slots:\n            slot_start, slot_end = slot\n            if slot_end - slot_start >= 30:\n                meeting_start = slot_start\n                meeting_end = meeting_start + 30\n                # Convert back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_733"
        },
        {
            "final_program_time": "{16:00:17:00}",
            "expected_time": "{16:00:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Define days to consider (Monday, Tuesday, Wednesday)\n    days = ['Monday', 'Tuesday', 'Wednesday']\n\n    # Define busy times for Nancy and Tyler in minutes since midnight\n    nancy_busy = {\n        'Monday': [(10 * 60, 10 * 60 + 30), (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60 + 30)],\n        'Tuesday': [(10 * 60 + 30, 11 * 60), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60)],\n        'Wednesday': [(9 * 60 + 30, 10 * 60), (11 * 60 + 30, 12 * 60), (14 * 60, 14 * 60 + 30), (16 * 60, 17 * 60)]\n    }\n\n    tyler_busy = {\n        'Monday': [(9 * 60 + 30, 13 * 60), (14 * 60, 15 * 60), (15 * 60 + 30, 16 * 60)],\n        'Tuesday': [(12 * 60, 13 * 60), (13 * 60 + 30, 14 * 60), (15 * 60, 15 * 60 + 30)],\n        'Wednesday': [(9 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 14 * 60), (14 * 60 + 30, 17 * 60)]\n    }\n\n    # Tyler's preference: not Tuesday or Wednesday, so prioritize Monday\n    preferred_days = ['Monday', 'Tuesday', 'Wednesday']  # Default order\n    if \"Tyler would rather not meet on Tuesday. Wednesday.\":\n        preferred_days = ['Monday']\n\n    for day in preferred_days:\n        # Combine and sort all busy intervals for both participants\n        busy_intervals = nancy_busy.get(day, []) + tyler_busy.get(day, [])\n        busy_intervals.sort()\n\n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n\n        for start, end in busy_intervals:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n\n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            available_start = slot_start\n            available_end = slot_end\n\n            if available_end - available_start >= meeting_duration:\n                # Convert back to HH:MM format\n                start_hh = available_start // 60\n                start_mm = available_start % 60\n                end_hh = (available_start + meeting_duration) // 60\n                end_mm = (available_start + meeting_duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    # If no slot found in preferred days, check other days (shouldn't happen per problem statement)\n    for day in ['Tuesday', 'Wednesday']:\n        busy_intervals = nancy_busy.get(day, []) + tyler_busy.get(day, [])\n        busy_intervals.sort()\n\n        free_slots = []\n        prev_end = work_start\n\n        for start, end in busy_intervals:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n\n        for slot_start, slot_end in free_slots:\n            available_start = slot_start\n            available_end = slot_end\n\n            if available_end - available_start >= meeting_duration:\n                start_hh = available_start // 60\n                start_mm = available_start % 60\n                end_hh = (available_start + meeting_duration) // 60\n                end_mm = (available_start + meeting_duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No time found\"  # Shouldn't happen per problem statement\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_734"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define blocked times for Ronald and Amber in minutes since start of day\n    ronald_blocked = {\n        'Monday': [(10*60 + 30, 11*60), (12*60, 12*60 + 30), (15*60 + 30, 16*60)],\n        'Tuesday': [(9*60, 9*60 + 30), (12*60, 12*60 + 30), (15*60 + 30, 16*60 + 30)],\n        'Wednesday': [(9*60 + 30, 10*60 + 30), (11*60, 12*60), (12*60 + 30, 13*60), (13*60 + 30, 14*60), (16*60 + 30, 17*60)]\n    }\n    \n    amber_blocked = {\n        'Monday': [(9*60, 9*60 + 30), (10*60, 10*60 + 30), (11*60 + 30, 12*60), (12*60 + 30, 14*60), (14*60 + 30, 15*60), (15*60 + 30, 17*60)],\n        'Tuesday': [(9*60, 9*60 + 30), (10*60, 11*60 + 30), (12*60, 12*60 + 30), (13*60 + 30, 15*60 + 30), (16*60 + 30, 17*60)],\n        'Wednesday': [(9*60, 9*60 + 30), (10*60, 10*60 + 30), (11*60, 13*60 + 30), (15*60, 15*60 + 30)]\n    }\n    \n    # Check each day in order\n    for day in days:\n        # Collect all blocked times for both participants\n        blocked = ronald_blocked[day] + amber_blocked[day]\n        blocked.sort()  # Sort by start time\n        \n        # Find available slots\n        available_slots = []\n        prev_end = work_start\n        \n        for start, end in blocked:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after last blocked time\n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n        \n        # Check each available slot for a 30-minute window\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= 30:\n                meeting_start = slot_start\n                meeting_end = meeting_start + 30\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_735"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    meeting_duration = 30  # minutes\n    \n    # Define schedules for Wayne and Janet\n    wayne_schedule = {\n        'Monday': [(10.5 * 60, 11 * 60), (13 * 60, 14 * 60)],\n        'Tuesday': [(9.5 * 60, 10 * 60), (13.5 * 60, 14 * 60), (14.5 * 60, 15 * 60), (15.5 * 60, 16 * 60), (16.5 * 60, 17 * 60)],\n        'Wednesday': [(10 * 60, 10.5 * 60), (13.5 * 60, 14 * 60)]\n    }\n    \n    janet_schedule = {\n        'Monday': [(9 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 14.5 * 60), (15 * 60, 16 * 60), (16.5 * 60, 17 * 60)],\n        'Wednesday': [(9.5 * 60, 15 * 60), (15.5 * 60, 17 * 60)]\n    }\n    \n    # Iterate through each day, prioritizing Tuesday and Monday over Wednesday\n    preferred_days = ['Tuesday', 'Monday', 'Wednesday']\n    \n    for day in preferred_days:\n        # Get busy times for both participants\n        wayne_busy = wayne_schedule.get(day, [])\n        janet_busy = janet_schedule.get(day, [])\n        \n        # Combine and sort all busy intervals\n        all_busy = wayne_busy + janet_busy\n        all_busy.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check for a suitable slot\n        for start, end in free_slots:\n            slot_duration = end - start\n            if slot_duration >= meeting_duration:\n                # Found a suitable slot\n                meeting_start = start\n                meeting_end = meeting_start + meeting_duration\n                \n                # Convert back to HH:MM format\n                def to_time_str(minutes):\n                    hh = int(minutes // 60)\n                    mm = int(minutes % 60)\n                    return f\"{hh:02d}:{mm:02d}\"\n                \n                return f\"{to_time_str(meeting_start)}:{to_time_str(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_736"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to consider (Monday=0, Tuesday=1, Wednesday=2)\n    days = [1, 2]  # Lisa doesn't want Monday\n    \n    # Lisa's busy times in minutes since midnight for Tuesday and Wednesday\n    lisa_busy = {\n        1: [  # Tuesday\n            (9 * 60 + 30, 10 * 60),      # 9:30-10:00\n            (12 * 60 + 30, 13 * 60 + 30), # 12:30-13:30\n            (14 * 60 + 30, 16 * 60),      # 14:30-16:00\n            (16 * 60 + 30, 17 * 60)       # 16:30-17:00\n        ],\n        2: [  # Wednesday\n            (10 * 60 + 30, 11 * 60),      # 10:30-11:00\n            (11 * 60 + 30, 12 * 60 + 30), # 11:30-12:30\n            (14 * 60 + 30, 15 * 60 + 30), # 14:30-15:30\n            (16 * 60, 17 * 60)            # 16:00-17:00\n        ]\n    }\n    \n    # Jerry's busy times in minutes since midnight for Tuesday and Wednesday\n    jerry_busy = {\n        1: [  # Tuesday (fully busy)\n            (9 * 60, 17 * 60)  # 9:00-17:00\n        ],\n        2: [  # Wednesday\n            (9 * 60, 13 * 60),             # 9:00-13:00\n            (13 * 60 + 30, 14 * 60),       # 13:30-14:00\n            (14 * 60 + 30, 16 * 60),       # 14:30-16:00\n            (16 * 60 + 30, 17 * 60)        # 16:30-17:00\n        ]\n    }\n    \n    # Check Wednesday (since Tuesday is fully booked for Jerry)\n    day = 2  # Wednesday\n    \n    # Lisa's additional constraint: not before 13:30 on Wednesday\n    start_time = max(work_start, 13 * 60 + 30)  # 13:30\n    \n    # Generate all possible 30-minute slots\n    for slot_start in range(start_time, work_end - 30, 5):  # Check in 5-minute increments\n        slot_end = slot_start + 30\n        \n        # Check if slot is free for Lisa\n        lisa_free = True\n        for busy_start, busy_end in lisa_busy[day]:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                lisa_free = False\n                break\n        \n        # Check if slot is free for Jerry\n        jerry_free = True\n        for busy_start, busy_end in jerry_busy[day]:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                jerry_free = False\n                break\n        \n        if lisa_free and jerry_free:\n            # Convert minutes back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No time found\"\n\n# Execute and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_737"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    meeting_duration = 30  # minutes\n    \n    # Define busy slots for Sara and Pamela in minutes since midnight\n    sara_busy = {\n        'Monday': [(9*60, 10*60), (11*60, 11*60 + 30), (13*60, 14*60 + 30), (15*60 + 30, 16*60)],\n        'Tuesday': [(9*60 + 30, 10*60), (10*60 + 30, 11*60), (11*60 + 30, 12*60), (14*60, 14*60 + 30), (16*60, 16*60 + 30)],\n        'Wednesday': [(9*60 + 30, 10*60), (12*60, 12*60 + 30), (14*60, 14*60 + 30), (15*60 + 30, 17*60)]\n    }\n    \n    pamela_busy = {\n        'Monday': [(9*60, 13*60), (14*60 + 30, 15*60 + 30), (16*60 + 30, 17*60)],\n        'Tuesday': [(9*60, 9*60 + 30), (10*60, 10*60 + 30), (11*60 + 30, 13*60), (13*60 + 30, 14*60), (16*60, 16*60 + 30)],\n        'Wednesday': [(9*60, 11*60), (12*60, 14*60), (16*60, 17*60)]\n    }\n    \n    # Preferences: Sara avoids Wednesday before 14:00, Pamela avoids Monday and Tuesday\n    preferred_days = ['Wednesday']  # Sara's preference overrides Pamela's avoidance\n    \n    # Check Wednesday first due to Sara's preference\n    for day in preferred_days:\n        # Generate all possible slots for the day\n        slots = []\n        current_start = work_start\n        sara_day_busy = sara_busy.get(day, [])\n        pamela_day_busy = pamela_busy.get(day, [])\n        \n        # Merge and sort all busy slots\n        all_busy = sara_day_busy + pamela_day_busy\n        all_busy.sort()\n        \n        # Find free slots\n        for busy_start, busy_end in all_busy:\n            if busy_start > current_start:\n                slots.append((current_start, busy_start))\n            current_start = max(current_start, busy_end)\n        if current_start < work_end:\n            slots.append((current_start, work_end))\n        \n        # Check each slot for availability\n        for slot_start, slot_end in slots:\n            if slot_end - slot_start >= meeting_duration:\n                # Sara's preference: avoid Wednesday before 14:00\n                if day == 'Wednesday' and slot_start < 14 * 60:\n                    continue\n                # Found a valid slot\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                # Format as HH:MM:HH:MM\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    # If preferred day doesn't work, check other days\n    for day in days:\n        if day in preferred_days:\n            continue  # already checked\n        if day == 'Monday' or day == 'Tuesday':  # Pamela's avoidance\n            continue\n        \n        # Generate all possible slots for the day\n        slots = []\n        current_start = work_start\n        sara_day_busy = sara_busy.get(day, [])\n        pamela_day_busy = pamela_busy.get(day, [])\n        \n        # Merge and sort all busy slots\n        all_busy = sara_day_busy + pamela_day_busy\n        all_busy.sort()\n        \n        # Find free slots\n        for busy_start, busy_end in all_busy:\n            if busy_start > current_start:\n                slots.append((current_start, busy_start))\n            current_start = max(current_start, busy_end)\n        if current_start < work_end:\n            slots.append((current_start, work_end))\n        \n        # Check each slot for availability\n        for slot_start, slot_end in slots:\n            if slot_end - slot_start >= meeting_duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                # Format as HH:MM:HH:MM\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    # If no slot found (though problem states there is one)\n    return \"No time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_738"
        },
        {
            "final_program_time": "{16:00:17:00}",
            "expected_time": "{16:00:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define constraints and busy times for each participant\n    jordan_busy = {\n        'Wednesday': [(10 * 60 + 30, 11 * 60), (12 * 60, 12 * 60 + 30)]\n    }\n    jordan_no_meet_days = ['Tuesday']\n    \n    bobby_busy = {\n        'Monday': [(9 * 60 + 30, 10 * 60), (11 * 60 + 30, 12 * 60),\n                   (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60),\n                   (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60 + 30, 12 * 60 + 30), (13 * 60, 14 * 60),\n                    (15 * 60, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Wednesday': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30),\n                      (12 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30),\n                      (14 * 60, 16 * 60)]\n    }\n    bobby_no_meet_days = ['Monday']\n    bobby_no_meet_before = 12 * 60  # 12:00 on Wednesday\n    \n    meeting_duration = 60  # 1 hour\n    \n    # Iterate through each day to find a suitable time\n    for day in days:\n        if day in jordan_no_meet_days or day in bobby_no_meet_days:\n            continue\n        \n        # Combine busy times for both participants on this day\n        busy_times = []\n        if day in jordan_busy:\n            busy_times.extend(jordan_busy[day])\n        if day in bobby_busy:\n            busy_times.extend(bobby_busy[day])\n        \n        # Sort busy times by start time\n        busy_times.sort()\n        \n        # Find the next available slot\n        current_time = work_hours_start\n        if day == 'Wednesday':\n            current_time = max(current_time, bobby_no_meet_before)\n        \n        for busy_start, busy_end in busy_times:\n            if current_time + meeting_duration <= busy_start:\n                # Found a slot\n                start_h = current_time // 60\n                start_m = current_time % 60\n                end_h = (current_time + meeting_duration) // 60\n                end_m = (current_time + meeting_duration) % 60\n                return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n            current_time = max(current_time, busy_end)\n        \n        # Check after the last busy time\n        if current_time + meeting_duration <= work_hours_end:\n            start_h = current_time // 60\n            start_m = current_time % 60\n            end_h = (current_time + meeting_duration) // 60\n            end_m = (current_time + meeting_duration) % 60\n            return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_739"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    meeting_duration = 30  # minutes\n    \n    # Define blocked times for each participant per day in minutes since midnight\n    blocked_times = {\n        'Willie': {\n            'Monday': [(15 * 60, 15 * 60 + 30)],  # 15:00-15:30\n            'Wednesday': [(9 * 60, 9 * 60 + 30)],   # 9:00-9:30\n        },\n        'Dorothy': {\n            'Monday': [\n                (9 * 60, 9 * 60 + 30),    # 9:00-9:30\n                (11 * 60, 12 * 60),       # 11:00-12:00\n                (12 * 60 + 30, 15 * 60),  # 12:30-15:00\n                (15 * 60 + 30, 17 * 60),  # 15:30-17:00\n            ],\n            'Tuesday': [(9 * 60, 17 * 60)],  # 9:00-17:00 (entire day)\n            'Wednesday': [\n                (9 * 60, 16 * 60),        # 9:00-16:00\n                (16 * 60 + 30, 17 * 60),  # 16:30-17:00\n            ],\n        }\n    }\n    \n    # Dorothy prefers to avoid more meetings on Monday\n    preferred_days = ['Tuesday', 'Wednesday']\n    \n    # Iterate through preferred days first\n    for day in preferred_days + ['Monday']:\n        if day not in days:\n            continue\n        \n        # Collect all blocked times for both participants on this day\n        willie_blocks = blocked_times['Willie'].get(day, [])\n        dorothy_blocks = blocked_times['Dorothy'].get(day, [])\n        all_blocks = willie_blocks + dorothy_blocks\n        all_blocks.sort()  # Sort by start time\n        \n        # Find available slots\n        available_slots = []\n        prev_end = work_start\n        \n        for block_start, block_end in all_blocks:\n            if block_start > prev_end:\n                available_slots.append((prev_end, block_start))\n            prev_end = max(prev_end, block_end)\n        \n        # Check after last block\n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n        \n        # Check each available slot for sufficient duration\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= meeting_duration:\n                # Found a suitable slot\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                \n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                \n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_740"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define the participants' busy times in minutes since midnight\n    donna_busy = {\n        'Monday': [(10 * 60, 10 * 60 + 30), (11 * 60, 11 * 60 + 30), \n                   (12 * 60 + 30, 13 * 60), (16 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 9 * 60 + 30), (13 * 60 + 30, 14 * 60), \n                    (14 * 60 + 30, 16 * 60)],\n        'Wednesday': [(11 * 60, 11 * 60 + 30), (12 * 60, 14 * 60), \n                      (16 * 60, 16 * 60 + 30)]\n    }\n    \n    cynthia_busy = {\n        'Monday': [(9 * 60, 12 * 60), (12 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60, 9 * 60 + 30), (10 * 60, 12 * 60 + 30), \n                    (14 * 60, 14 * 60 + 30), (15 * 60, 16 * 60)],\n        'Wednesday': [(10 * 60, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), \n                      (13 * 60, 13 * 60 + 30), (16 * 60, 16 * 60 + 30)]\n    }\n    \n    # Preferences: Donna doesn't want Tuesday, Cynthia doesn't want Monday\n    preferred_days = ['Wednesday', 'Monday', 'Tuesday']  # Ordered by preference (Wednesday first)\n    \n    meeting_duration = 30  # minutes\n    \n    for day in preferred_days:\n        if day == 'Tuesday' and 'Tuesday' in preferred_days:\n            continue  # Skip Tuesday as Donna doesn't want it\n        if day == 'Monday' and 'Monday' in preferred_days:\n            continue  # Skip Monday as Cynthia doesn't want it\n        \n        # Combine busy times for both participants on this day\n        busy_times = donna_busy.get(day, []) + cynthia_busy.get(day, [])\n        busy_times.sort()  # Sort by start time\n        \n        # Find free slots\n        prev_end = work_start\n        free_slots = []\n        \n        for start, end in busy_times:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            available_start = slot_start\n            available_end = slot_end\n            \n            if available_end - available_start >= meeting_duration:\n                # Convert back to HH:MM format\n                start_hh = available_start // 60\n                start_mm = available_start % 60\n                end_hh = (available_start + meeting_duration) // 60\n                end_mm = (available_start + meeting_duration) % 60\n                \n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Adjusting the preferred_days to exclude Monday and Tuesday based on preferences\ndef find_meeting_time_adjusted():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Only consider Wednesday based on preferences\n    day = 'Wednesday'\n    \n    # Define the participants' busy times in minutes since midnight\n    donna_busy = {\n        'Wednesday': [(11 * 60, 11 * 60 + 30), (12 * 60, 14 * 60), \n                      (16 * 60, 16 * 60 + 30)]\n    }\n    \n    cynthia_busy = {\n        'Wednesday': [(10 * 60, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), \n                      (13 * 60, 13 * 60 + 30), (16 * 60, 16 * 60 + 30)]\n    }\n    \n    meeting_duration = 30  # minutes\n    \n    # Combine busy times for both participants on this day\n    busy_times = donna_busy.get(day, []) + cynthia_busy.get(day, [])\n    busy_times.sort()  # Sort by start time\n    \n    # Find free slots\n    prev_end = work_start\n    free_slots = []\n    \n    for start, end in busy_times:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Check each free slot for availability\n    for slot_start, slot_end in free_slots:\n        available_start = slot_start\n        available_end = slot_end\n        \n        if available_end - available_start >= meeting_duration:\n            # Convert back to HH:MM format\n            start_hh = available_start // 60\n            start_mm = available_start % 60\n            end_hh = (available_start + meeting_duration) // 60\n            end_mm = (available_start + meeting_duration) % 60\n            \n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# The correct approach is to only consider Wednesday due to preferences\nprint(find_meeting_time_adjusted())\n```",
            "count": "calendar_scheduling_example_741"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define busy slots for Philip and Randy in minutes since midnight\n    philip_busy = {\n        'Monday': [(9*60, 9*60 + 30), (12*60, 12*60 + 30), (13*60, 14*60), (15*60, 15*60 + 30), (16*60, 16*60 + 30)],\n        'Tuesday': [(11*60 + 30, 13*60), (14*60, 15*60)],\n        'Wednesday': [(9*60, 9*60 + 30), (10*60, 10*60 + 30), (11*60, 11*60 + 30), (12*60 + 30, 13*60), (14*60, 14*60 + 30), (15*60, 15*60 + 30), (16*60, 16*60 + 30)]\n    }\n    \n    randy_busy = {\n        'Monday': [(9*60, 14*60), (14*60 + 30, 17*60)],\n        'Tuesday': [(9*60, 14*60), (14*60 + 30, 17*60)],\n        'Wednesday': [(10*60, 17*60)]\n    }\n    \n    # Check each day in order\n    for day in days:\n        # Collect all busy slots for both participants\n        busy_slots = philip_busy.get(day, []) + randy_busy.get(day, [])\n        busy_slots.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in busy_slots:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for 30-minute availability\n        for slot in free_slots:\n            start, end = slot\n            duration_needed = 30\n            if end - start >= duration_needed:\n                meeting_start = start\n                meeting_end = meeting_start + duration_needed\n                # Convert back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_742"
        },
        {
            "final_program_time": "{9:30:10:30}",
            "expected_time": "{9:30:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday']\n\n    # Define busy times for each participant per day in minutes since midnight\n    timothy_busy = {\n        'Monday': [(16 * 60 + 30, 17 * 60)],\n        'Wednesday': [(13 * 60 + 30, 14 * 60)]\n    }\n\n    paul_busy = {\n        'Monday': [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60, 12 * 60 + 30), (13 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 12 * 60), (12 * 60 + 30, 17 * 60)]\n    }\n\n    # Iterate through each day\n    for day in days:\n        # Combine and sort all busy intervals for the day\n        busy_intervals = []\n        \n        # Add Timothy's busy intervals\n        if day in timothy_busy:\n            busy_intervals.extend(timothy_busy[day])\n        \n        # Add Paul's busy intervals\n        if day in paul_busy:\n            busy_intervals.extend(paul_busy[day])\n        \n        # Sort busy intervals by start time\n        busy_intervals.sort()\n\n        # Find free slots by checking gaps between busy intervals\n        previous_end = work_start\n        free_slots = []\n\n        for start, end in busy_intervals:\n            if start > previous_end:\n                free_slots.append((previous_end, start))\n            previous_end = max(previous_end, end)\n        \n        # Check the slot after the last busy interval\n        if previous_end < work_end:\n            free_slots.append((previous_end, work_end))\n\n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            available_start = slot_start\n            available_end = slot_end - meeting_duration\n\n            if available_start <= available_end:\n                # Found a suitable time\n                meeting_start = available_start\n                meeting_end = meeting_start + meeting_duration\n\n                # Convert back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_743"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check (Monday=0, Tuesday=1, Wednesday=2)\n    days = [0, 1, 2]\n    \n    # Anthony's constraints: cannot meet on Tuesday (remove day 1)\n    days.remove(1)\n    \n    # Anthony's schedule: {day: [(start, end), ...]}\n    anthony_schedule = {\n        0: [(10*60, 10*60+30), (11*60, 11*60+30), (12*60, 12*60+30), (13*60, 14*60)],\n        2: [(9*60+30, 10*60+30), (13*60, 13*60+30), (15*60, 15*60+30)]\n    }\n    \n    # Gerald's schedule: {day: [(start, end), ...]}\n    gerald_schedule = {\n        0: [(9*60, 13*60), (13*60+30, 14*60+30)],\n        2: [(9*60, 9*60+30), (10*60, 17*60)]\n    }\n    \n    meeting_duration = 30\n    \n    # Iterate through each day\n    for day in days:\n        # Get both schedules for the day\n        anthony_busy = anthony_schedule.get(day, [])\n        gerald_busy = gerald_schedule.get(day, [])\n        \n        # Combine and sort all busy times\n        all_busy = anthony_busy + gerald_busy\n        all_busy.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= meeting_duration:\n                # Convert back to HH:MM format\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_hh = (slot_start + meeting_duration) // 60\n                end_mm = (slot_start + meeting_duration) % 60\n                \n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_744"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to consider based on constraints\n    days = {\n        \"Monday\": {\"Matthew\": [(9*60, 9*60+30), (10*60+30, 11*60+30), (13*60+30, 14*60), (15*60, 15*60+30), (16*60, 16*60+30)],\n                  \"Randy\": [(9*60, 9*60+30), (11*60, 12*60), (12*60+30, 14*60), (14*60+30, 15*60), (16*60+30, 17*60)]},\n        \"Tuesday\": {\"Matthew\": [(10*60+30, 11*60+30)],\n                   \"Randy\": [(9*60+30, 10*60+30), (11*60, 11*60+30), (12*60+30, 13*60), (13*60+30, 14*60+30), (15*60+30, 17*60)]},\n        \"Wednesday\": {\"Matthew\": [(9*60, 9*60+30), (10*60, 11*60), (11*60+30, 12*60), (13*60, 14*60), (15*60, 15*60+30), (16*60, 16*60+30)],\n                     \"Randy\": [(9*60, 10*60+30), (11*60+30, 12*60), (12*60+30, 14*60), (14*60+30, 16*60+30)]}\n    }\n    \n    # Apply constraints: Matthew prefers not Wednesday, Randy cannot meet Monday\n    days.pop(\"Monday\")\n    days.pop(\"Wednesday\")\n    \n    # Only Tuesday remains\n    day = \"Tuesday\"\n    matthew_busy = days[day][\"Matthew\"]\n    randy_busy = days[day][\"Randy\"]\n    \n    # Combine and sort all busy intervals\n    all_busy = matthew_busy + randy_busy\n    all_busy.sort()\n    \n    # Find free intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Find the first 30-minute slot\n    meeting_duration = 30\n    for start, end in free_intervals:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_745"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{10:00:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Jeffrey's unavailable times for Tuesday and Wednesday (in minutes since midnight)\n    jeffrey_unavailable = {\n        'Tuesday': [\n            (9 * 60, 10 * 60),    # 9:00-10:00\n            (11 * 60, 11 * 60 + 30),  # 11:00-11:30\n            (13 * 60 + 30, 15 * 60 + 30),  # 13:30-15:30\n            (16 * 60 + 30, 17 * 60)  # 16:30-17:00\n        ],\n        'Wednesday': [\n            (9 * 60, 9 * 60 + 30),  # 9:00-9:30\n            (10 * 60, 11 * 60 + 30),  # 10:00-11:30\n            (12 * 60, 13 * 60 + 30),  # 12:00-13:30\n            (14 * 60, 15 * 60),       # 14:00-15:00\n            (15 * 60 + 30, 16 * 60),  # 15:30-16:00\n            (16 * 60 + 30, 17 * 60)  # 16:30-17:00\n        ]\n    }\n    \n    # Days to check (excluding Monday per Jeffrey's preference)\n    days = ['Tuesday', 'Wednesday']\n    \n    # Meeting duration in minutes\n    meeting_duration = 60\n    \n    for day in days:\n        # Get Jeffrey's unavailable times for the day\n        unavailable_times = jeffrey_unavailable[day]\n        \n        # Start checking from the beginning of the workday\n        current_time = work_start\n        \n        for block in unavailable_times:\n            block_start, block_end = block\n            \n            # Check if there's enough time before the next block\n            if current_time + meeting_duration <= block_start:\n                # Format the time as HH:MM:HH:MM\n                start_hh = current_time // 60\n                start_mm = current_time % 60\n                end_time = current_time + meeting_duration\n                end_hh = end_time // 60\n                end_mm = end_time % 60\n                \n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n            \n            # Move current_time to the end of this block\n            current_time = block_end\n        \n        # Check after the last block\n        if current_time + meeting_duration <= work_end:\n            start_hh = current_time // 60\n            start_mm = current_time % 60\n            end_time = current_time + meeting_duration\n            end_hh = end_time // 60\n            end_mm = end_time % 60\n            \n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_746"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define busy times for Megan and Jacqueline in minutes since midnight\n    megan_busy = {\n        'Wednesday': [(10 * 60, 10 * 60 + 30), (12 * 60, 12 * 60 + 30)]\n    }\n    \n    jacqueline_busy = {\n        'Monday': [(9 * 60, 11 * 60), (11 * 60 + 30, 14 * 60 + 30), \n                   (15 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Tuesday': [(10 * 60, 12 * 60), (12 * 60 + 30, 16 * 60), \n                    (16 * 60 + 30, 17 * 60)],\n        'Wednesday': [(9 * 60, 10 * 60), (11 * 60, 12 * 60), \n                      (13 * 60 + 30, 15 * 60)]\n    }\n    \n    # Check each day in order\n    for day in days:\n        # Collect all busy intervals for the day\n        busy_intervals = []\n        \n        # Add Megan's busy intervals\n        if day in megan_busy:\n            busy_intervals.extend(megan_busy[day])\n        \n        # Add Jacqueline's busy intervals\n        if day in jacqueline_busy:\n            busy_intervals.extend(jacqueline_busy[day])\n        \n        # Sort busy intervals by start time\n        busy_intervals.sort()\n        \n        # Find free slots\n        previous_end = work_start\n        free_slots = []\n        \n        for start, end in busy_intervals:\n            if start > previous_end:\n                free_slots.append((previous_end, start))\n            previous_end = max(previous_end, end)\n        \n        # Check after last busy interval\n        if previous_end < work_end:\n            free_slots.append((previous_end, work_end))\n        \n        # Check each free slot for 30-minute availability\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= 30:\n                # Found the earliest available slot\n                meeting_start = slot_start\n                meeting_end = meeting_start + 30\n                \n                # Convert back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                \n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_747"
        },
        {
            "final_program_time": "{11:00:12:00}",
            "expected_time": "{11:00:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to consider\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define Robert's busy times in minutes since midnight\n    robert_busy = {\n        'Monday': [(10*60, 11*60), (11*60 + 30, 12*60), (14*60 + 30, 16*60)],\n        'Tuesday': [(9*60, 9*60 + 30), (10*60, 13*60), (13*60 + 30, 14*60 + 30), (15*60, 16*60), (16*60 + 30, 17*60)],\n        'Wednesday': [(10*60 + 30, 11*60), (12*60, 12*60 + 30), (13*60 + 30, 14*60), (15*60, 15*60 + 30)]\n    }\n    \n    # Define Bruce's busy times in minutes since midnight\n    bruce_busy = {\n        'Monday': [(11*60, 11*60 + 30), (12*60, 12*60 + 30), (13*60, 14*60), (14*60 + 30, 15*60 + 30), (16*60, 16*60 + 30)],\n        'Tuesday': [(9*60, 10*60 + 30), (11*60, 12*60 + 30), (13*60, 14*60), (14*60 + 30, 15*60), (16*60, 17*60)],\n        'Wednesday': [(9*60, 10*60 + 30), (12*60, 12*60 + 30), (13*60, 13*60 + 30), (15*60, 16*60), (16*60 + 30, 17*60)]\n    }\n    \n    # Bruce's preferences: avoid Monday and Wednesday after 14:00\n    preferred_days = ['Tuesday']\n    \n    # Check preferred days first\n    for day in preferred_days:\n        # Get both schedules for the day\n        r_busy = robert_busy.get(day, [])\n        b_busy = bruce_busy.get(day, [])\n        \n        # Merge and sort all busy times\n        all_busy = r_busy + b_busy\n        all_busy.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if work_end > prev_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check for a 1-hour slot\n        for start, end in free_slots:\n            if end - start >= 60:\n                meeting_start = start\n                meeting_end = start + 60\n                # Format the time as HH:MM:HH:MM\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    # If no slot in preferred days, check other days except Monday and Wednesday after 14:00\n    for day in days:\n        if day in preferred_days:\n            continue\n        if day == 'Monday':\n            continue  # Bruce wants to avoid Monday\n        if day == 'Wednesday':\n            # Adjust work_end to 14:00 for Wednesday\n            day_work_end = 14 * 60\n        else:\n            day_work_end = work_end\n        \n        # Get both schedules for the day\n        r_busy = robert_busy.get(day, [])\n        b_busy = bruce_busy.get(day, [])\n        \n        # Merge and sort all busy times\n        all_busy = r_busy + b_busy\n        all_busy.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if day_work_end > prev_end:\n            free_slots.append((prev_end, day_work_end))\n        \n        # Check for a 1-hour slot\n        for start, end in free_slots:\n            if end - start >= 60:\n                meeting_start = start\n                meeting_end = start + 60\n                # Format the time as HH:MM:HH:MM\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_748"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Scott's schedule: completely free\n    scott_free = {day: [(work_start, work_end)] for day in days}\n    \n    # Anthony's schedule and constraints\n    anthony_meetings = {\n        'Monday': [(9 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60 + 30), (15 * 60, 16 * 60 + 30)],\n        'Tuesday': [(9 * 60, 11 * 60), (11 * 60 + 30, 14 * 60), (14 * 60 + 30, 17 * 60)],\n        'Wednesday': [(9 * 60, 11 * 60), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60), (14 * 60 + 30, 16 * 60 + 30)]\n    }\n    anthony_constraints = {\n        'Monday': False,  # Cannot meet on Monday\n        'Tuesday': lambda start: start >= 14 * 60,  # Only after 14:00 on Tuesday\n        'Wednesday': True  # Can meet on Wednesday\n    }\n    \n    meeting_duration = 30  # minutes\n    \n    # Iterate through each day to find a suitable time\n    for day in days:\n        if not anthony_constraints[day]:\n            continue\n        \n        # Get Scott's and Anthony's free slots for the day\n        scott_slots = scott_free[day]\n        anthony_busy = anthony_meetings[day]\n        \n        # Generate Anthony's free slots by inverting busy slots\n        anthony_free = []\n        prev_end = work_start\n        for start, end in sorted(anthony_busy):\n            if start > prev_end:\n                anthony_free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            anthony_free.append((prev_end, work_end))\n        \n        # Apply Anthony's constraints for the day\n        if day == 'Tuesday':\n            anthony_free = [(start, end) for start, end in anthony_free if anthony_constraints[day](start)]\n        \n        # Find overlapping slots between Scott and Anthony\n        for scott_start, scott_end in scott_slots:\n            for anthony_start, anthony_end in anthony_free:\n                overlap_start = max(scott_start, anthony_start)\n                overlap_end = min(scott_end, anthony_end)\n                if overlap_end - overlap_start >= meeting_duration:\n                    # Found a suitable slot\n                    return f\"{minutes_to_time(overlap_start)}:{minutes_to_time(overlap_start + meeting_duration)}\"\n    \n    return \"No suitable time found\"\n\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Execute and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_749"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define busy slots for each person per day in minutes since midnight\n    timothy_busy = {\n        'Monday': [(15 * 60 + 30, 16 * 60)],\n        'Tuesday': [(14 * 60 + 30, 15 * 60 + 30)],\n        'Wednesday': [\n            (10 * 60, 11 * 60),\n            (12 * 60 + 30, 13 * 60),\n            (14 * 60 + 30, 15 * 60),\n            (16 * 60, 16 * 60 + 30)\n        ]\n    }\n    \n    mark_busy = {\n        'Monday': [\n            (9 * 60, 9 * 60 + 30),\n            (10 * 60 + 30, 14 * 60),\n            (14 * 60 + 30, 15 * 60),\n            (16 * 60 + 30, 17 * 60)\n        ],\n        'Tuesday': [\n            (9 * 60, 10 * 60 + 30),\n            (11 * 60, 12 * 60),\n            (12 * 60 + 30, 17 * 60)\n        ],\n        'Wednesday': [\n            (9 * 60, 12 * 60 + 30),\n            (13 * 60, 13 * 60 + 30),\n            (14 * 60, 16 * 60)\n        ]\n    }\n    \n    # Define preferences\n    timothy_no_tuesday_before_11 = True\n    mark_avoid_monday = True\n    mark_avoid_wednesday = True\n    \n    # Iterate through each day to find a suitable slot\n    for day in days:\n        if (day == 'Monday' and mark_avoid_monday) or (day == 'Wednesday' and mark_avoid_wednesday):\n            continue\n        \n        # Combine and sort all busy slots for the day\n        combined_busy = []\n        if day in timothy_busy:\n            combined_busy.extend(timothy_busy[day])\n        if day in mark_busy:\n            combined_busy.extend(mark_busy[day])\n        \n        # Sort busy slots by start time\n        combined_busy.sort()\n        \n        # Check the time before the first busy slot\n        prev_end = work_start\n        for start, end in combined_busy:\n            if start > prev_end:\n                # Check if the slot is at least 30 minutes\n                if start - prev_end >= 30:\n                    # Check Timothy's Tuesday preference\n                    if day == 'Tuesday' and timothy_no_tuesday_before_11 and prev_end < 11 * 60:\n                        prev_end = end\n                        continue\n                    # Found a suitable slot\n                    slot_start = prev_end\n                    slot_end = slot_start + 30\n                    return f\"{int(slot_start // 60):02d}:{int(slot_start % 60):02d}:{int(slot_end // 60):02d}:{int(slot_end % 60):02d}\"\n            prev_end = max(prev_end, end)\n        \n        # Check the time after the last busy slot\n        if work_end - prev_end >= 30:\n            # Check Timothy's Tuesday preference\n            if day == 'Tuesday' and timothy_no_tuesday_before_11 and prev_end < 11 * 60:\n                continue\n            # Found a suitable slot\n            slot_start = prev_end\n            slot_end = slot_start + 30\n            return f\"{int(slot_start // 60):02d}:{int(slot_start % 60):02d}:{int(slot_end // 60):02d}:{int(slot_end % 60):02d}\"\n    \n    # If no slot found (though the problem states there is one)\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_750"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to consider (Tuesday only, based on Edward's preference)\n    days = ['Tuesday']\n    \n    # Define busy slots for each participant on Tuesday in minutes since midnight\n    edward_busy = [\n        (10 * 60, 11 * 60),    # 10:00-11:00\n        (15 * 60, 15 * 30)      # 15:00-15:30\n    ]\n    \n    charlotte_busy = [\n        (9 * 60, 11 * 60),      # 9:00-11:00\n        (11 * 60 + 30, 15 * 60 + 30),  # 11:30-15:30\n        (16 * 60, 17 * 60)       # 16:00-17:00\n    ]\n    \n    # Combine and sort all busy slots for Tuesday\n    all_busy = edward_busy + charlotte_busy\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    # Check if there's time after the last busy slot\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Find the earliest 30-minute slot\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_751"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define busy slots for James and Diane in minutes since midnight\n    james_busy = {\n        'Monday': [(9*60 + 30, 11*60 + 30), (12*60, 12*60 + 30), (13*60, 14*60), (14*60 + 30, 15*60), (16*60, 16*60 + 30)],\n        'Tuesday': [(10*60, 10*60 + 30), (12*60, 13*60), (14*60, 14*60 + 30), (15*60, 15*60 + 30), (16*60, 16*60 + 30)],\n        'Wednesday': [(9*60 + 30, 10*60 + 30), (12*60, 12*60 + 30), (13*60 + 30, 14*60), (14*60 + 30, 15*60)]\n    }\n    \n    diane_busy = {\n        'Monday': [(10*60, 11*60), (11*60 + 30, 12*60), (13*60, 13*60 + 30), (14*60, 16*60 + 30)],\n        'Tuesday': [(10*60 + 30, 11*60), (11*60 + 30, 13*60), (13*60 + 30, 14*60), (14*60 + 30, 15*60), (15*60 + 30, 16*60)],\n        'Wednesday': [(9*60, 10*60 + 30), (11*60, 11*60 + 30), (12*60, 15*60), (15*60 + 30, 16*60 + 30)]\n    }\n    \n    meeting_duration = 60  # 1 hour in minutes\n    \n    for day in days:\n        # Combine and sort all busy slots for both participants\n        all_busy = james_busy.get(day, []) + diane_busy.get(day, [])\n        all_busy.sort()\n        \n        # Find free slots by checking gaps between busy slots\n        prev_end = work_start\n        for start, end in all_busy:\n            if start > prev_end:\n                # Check if the gap is enough for the meeting\n                if start - prev_end >= meeting_duration:\n                    # Found a suitable slot\n                    meeting_start = prev_end\n                    meeting_end = meeting_start + meeting_duration\n                    return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after the last busy slot\n        if work_end - prev_end >= meeting_duration:\n            meeting_start = prev_end\n            meeting_end = meeting_start + meeting_duration\n            return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_752"
        },
        {
            "final_program_time": "{12:30:13:30}",
            "expected_time": "{12:30:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define schedules for Laura and Megan in minutes since midnight\n    laura_schedule = {\n        'Monday': [(10 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60), (16 * 60 + 30, 17 * 60)],\n        'Tuesday': [(12 * 60 + 30, 13 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n        'Wednesday': [(12 * 60, 12 * 60 + 30), (15 * 60 + 30, 16 * 60)]\n    }\n    \n    megan_schedule = {\n        'Monday': [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 12 * 60 + 30), (13 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60, 12 * 60), (12 * 60 + 30, 17 * 60)],\n        'Wednesday': [(9 * 60, 16 * 60 + 30)]\n    }\n    \n    # Duration in minutes\n    duration = 60\n    \n    # Iterate through each day\n    for day in days:\n        # Combine and sort all busy intervals for both participants\n        busy_intervals = laura_schedule.get(day, []) + megan_schedule.get(day, [])\n        busy_intervals.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in busy_intervals:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy interval\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= duration:\n                # Convert minutes back to HH:MM format\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_hh = (slot_start + duration) // 60\n                end_mm = (slot_start + duration) % 60\n                \n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Execute and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_753"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Natalie's schedule: list of (day, start, end) in minutes\n    natalie_meetings = [\n        ('Monday', 9 * 60, 9 * 60 + 30),\n        ('Monday', 14 * 60 + 30, 17 * 60),\n        ('Tuesday', 9 * 60 + 30, 10 * 60 + 30),\n        ('Tuesday', 12 * 60, 13 * 60),\n        ('Tuesday', 14 * 60, 17 * 60),\n        ('Wednesday', 15 * 60 + 30, 16 * 60 + 30)\n    ]\n    \n    # Dylan's schedule: list of (day, start, end) in minutes\n    dylan_meetings = [\n        ('Monday', 9 * 60, 11 * 60 + 30),\n        ('Monday', 12 * 60, 17 * 60),\n        ('Tuesday', 9 * 60, 17 * 60),\n        ('Wednesday', 9 * 60, 14 * 60 + 30),\n        ('Wednesday', 15 * 60, 17 * 60)\n    ]\n    \n    # Dylan doesn't want to meet on Wednesday\n    excluded_days = ['Wednesday']\n    \n    # Meeting duration in minutes\n    duration = 30\n    \n    # Iterate through each day\n    for day in days:\n        if day in excluded_days:\n            continue\n        \n        # Collect all busy times for both participants on this day\n        busy_times = []\n        \n        # Add Natalie's meetings for the day\n        for meeting in natalie_meetings:\n            if meeting[0] == day:\n                busy_times.append((meeting[1], meeting[2]))\n        \n        # Add Dylan's meetings for the day\n        for meeting in dylan_meetings:\n            if meeting[0] == day:\n                busy_times.append((meeting[1], meeting[2]))\n        \n        # Sort busy times by start time\n        busy_times.sort()\n        \n        # Find the first available slot\n        prev_end = work_start\n        for start, end in busy_times:\n            if start > prev_end and (start - prev_end) >= duration:\n                # Found a slot\n                slot_start = prev_end\n                slot_end = slot_start + duration\n                return f\"{int(slot_start // 60):02d}:{int(slot_start % 60):02d}:{int(slot_end // 60):02d}:{int(slot_end % 60):02d}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after the last meeting\n        if work_end - prev_end >= duration:\n            slot_start = prev_end\n            slot_end = slot_start + duration\n            return f\"{int(slot_start // 60):02d}:{int(slot_start % 60):02d}:{int(slot_end // 60):02d}:{int(slot_end % 60):02d}\"\n    \n    return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_754"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    meeting_duration = 30  # minutes\n    \n    # Define busy slots for Gary and Jerry in minutes since midnight\n    gary_busy = {\n        'Monday': [(9*60 + 30, 10*60), (12*60, 12*60 + 30), (13*60, 13*60 + 30), (14*60 + 30, 15*60)],\n        'Tuesday': [(10*60 + 30, 11*60 + 30), (12*60 + 30, 13*60)],\n        'Wednesday': [(9*60, 9*60 + 30), (12*60 + 30, 13*60 + 30), (14*60, 14*60 + 30), (15*60, 15*60 + 30)]\n    }\n    \n    jerry_busy = {\n        'Monday': [(9*60, 11*60), (11*60 + 30, 12*60), (14*60, 15*60 + 30), (16*60, 16*60 + 30)],\n        'Tuesday': [(9*60, 10*60), (10*60 + 30, 17*60)],\n        'Wednesday': [(9*60 + 30, 10*60), (10*60 + 30, 11*60), (11*60 + 30, 12*60), (12*60 + 30, 13*60), \n                     (14*60, 14*60 + 30), (15*60, 16*60), (16*60 + 30, 17*60)]\n    }\n    \n    # Jerry prefers to avoid Monday and Wednesday, so prioritize Tuesday\n    preferred_days = ['Tuesday', 'Monday', 'Wednesday']\n    \n    for day in preferred_days:\n        # Combine and sort all busy slots for both participants\n        all_busy = gary_busy.get(day, []) + jerry_busy.get(day, [])\n        all_busy.sort()\n        \n        # Find free slots\n        prev_end = work_start\n        free_slots = []\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= meeting_duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_755"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    meeting_duration = 30  # minutes\n    \n    # Define busy slots for Bryan and Doris in minutes since midnight\n    bryan_busy = {\n        'Monday': [(13 * 60, 13 * 60 + 30)],\n        'Wednesday': [(9 * 60, 9 * 60 + 30), (11 * 60 + 30, 12 * 60), (16 * 60, 16 * 60 + 30)]\n    }\n    \n    doris_busy = {\n        'Monday': [(9 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 10 * 60 + 30), (11 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Wednesday': [(9 * 60, 17 * 60)]\n    }\n    \n    # Additional constraint: Doris can't meet on Tuesday after 12:00\n    # So on Tuesday, Doris is effectively busy from 12:00 onwards\n    \n    # Iterate through each day to find a suitable time\n    for day in days:\n        if day == 'Tuesday':\n            # On Tuesday, Doris is busy after 12:00, so we only consider before 12:00\n            doris_additional_busy = (12 * 60, work_end)\n            doris_busy_tuesday = doris_busy.get('Tuesday', []) + [doris_additional_busy]\n            doris_busy['Tuesday'] = doris_busy_tuesday\n        \n        # Get busy slots for both participants on this day\n        bryan_slots = bryan_busy.get(day, [])\n        doris_slots = doris_busy.get(day, [])\n        \n        # Merge and sort all busy slots\n        all_busy = bryan_slots + doris_slots\n        all_busy.sort()\n        \n        # Find free slots by checking gaps between busy slots\n        prev_end = work_start\n        for start, end in all_busy:\n            if start > prev_end:\n                # Found a free slot from prev_end to start\n                free_slot_start = prev_end\n                free_slot_end = start\n                if free_slot_end - free_slot_start >= meeting_duration:\n                    # Convert back to HH:MM format\n                    start_hh = free_slot_start // 60\n                    start_mm = free_slot_start % 60\n                    end_hh = (free_slot_start + meeting_duration) // 60\n                    end_mm = (free_slot_start + meeting_duration) % 60\n                    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after the last busy slot\n        if work_end - prev_end >= meeting_duration:\n            start_hh = prev_end // 60\n            start_mm = prev_end % 60\n            end_hh = (prev_end + meeting_duration) // 60\n            end_mm = (prev_end + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_756"
        },
        {
            "final_program_time": "{11:00:12:00}",
            "expected_time": "{11:00:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Define days to consider\n    days = ['Monday', 'Tuesday', 'Wednesday']\n\n    # Define Noah's and Justin's schedules and preferences\n    noah_schedule = {\n        'Monday': [(9.5 * 60, 10 * 60), (15 * 60, 15.5 * 60), (16 * 60, 16.5 * 60)],\n        'Tuesday': [(9.5 * 60, 10.5 * 60), (16 * 60, 16.5 * 60)],\n        'Wednesday': [(9 * 60, 9.5 * 60), (12 * 60, 12.5 * 60)]\n    }\n    justin_schedule = {\n        'Monday': [(9.5 * 60, 11.5 * 60), (12.5 * 60, 13.5 * 60), (15 * 60, 16 * 60), (16.5 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 13.5 * 60), (14 * 60, 17 * 60)],\n        'Wednesday': [(10 * 60, 11 * 60), (12 * 60, 14.5 * 60), (15 * 60, 15.5 * 60)]\n    }\n\n    # Noah's preference: avoid Wednesday after 13:00\n    noah_preference = {\n        'Wednesday': (13 * 60, work_end)\n    }\n\n    # Justin's preference: avoid Monday\n    justin_preference = ['Monday']\n\n    # Iterate through each day to find a suitable time\n    for day in days:\n        if day in justin_preference:\n            continue  # Skip Monday as per Justin's preference\n\n        # Combine and sort all busy times for both participants\n        busy_times = []\n        if day in noah_schedule:\n            busy_times.extend(noah_schedule[day])\n        if day in justin_schedule:\n            busy_times.extend(justin_schedule[day])\n        busy_times.sort()\n\n        # Add Noah's preference as a busy time if applicable\n        if day in noah_preference:\n            start_avoid, end_avoid = noah_preference[day]\n            busy_times.append((start_avoid, end_avoid))\n            busy_times.sort()\n\n        # Find available slots\n        available_slots = []\n        prev_end = work_start\n\n        for start, end in busy_times:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n\n        if work_end > prev_end:\n            available_slots.append((prev_end, work_end))\n\n        # Check each available slot for meeting duration\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= meeting_duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                start_hh = int(meeting_start // 60)\n                start_mm = int(meeting_start % 60)\n                end_hh = int(meeting_end // 60)\n                end_mm = int(meeting_end % 60)\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_757"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(debra_busy, maria_busy, work_hours, days, duration):\n    from datetime import datetime, timedelta\n\n    # Parse work hours\n    start_work, end_work = [datetime.strptime(h, '%H:%M') for h in work_hours.split(' to ')]\n    work_duration = end_work - start_work\n\n    # Iterate through each day\n    for day in days:\n        # Initialize free slots for the day\n        day_start = start_work\n        day_end = end_work\n\n        # Get busy slots for Debra and Maria for the current day\n        debra_day = [slot for slot in debra_busy if slot[0] == day]\n        maria_day = [slot for slot in maria_busy if slot[0] == day]\n\n        # Combine and sort all busy slots\n        all_busy = debra_day + maria_day\n        all_busy_sorted = sorted(all_busy, key=lambda x: datetime.strptime(x[1], '%H:%M'))\n\n        # Find free slots\n        current_time = day_start\n        free_slots = []\n        for busy in all_busy_sorted:\n            busy_start = datetime.strptime(busy[1], '%H:%M')\n            busy_end = datetime.strptime(busy[2], '%H:%M')\n            if current_time < busy_start:\n                free_slots.append((current_time, busy_start))\n            current_time = max(current_time, busy_end)\n        if current_time < day_end:\n            free_slots.append((current_time, day_end))\n\n        # Check each free slot for sufficient duration\n        for slot in free_slots:\n            slot_duration = slot[1] - slot[0]\n            if slot_duration >= timedelta(hours=duration):\n                return f\"{slot[0].strftime('%H:%M')}:{slot[1].strftime('%H:%M')}\"\n\n    return \"No suitable time found\"\n\n# Define constraints\nwork_hours = \"9:00 to 17:00\"\ndays = [\"Monday\", \"Tuesday\", \"Wednesday\"]\nduration = 1  # hours\n\n# Define busy slots for Debra and Maria\ndebra_busy = [\n    (\"Monday\", \"9:00\", \"9:30\"),\n    (\"Monday\", \"10:00\", \"11:00\"),\n    (\"Monday\", \"12:00\", \"12:30\"),\n    (\"Monday\", \"13:30\", \"14:00\"),\n    (\"Monday\", \"15:00\", \"15:30\"),\n    (\"Tuesday\", \"13:00\", \"14:30\"),\n    (\"Tuesday\", \"15:30\", \"16:00\"),\n    (\"Wednesday\", \"11:00\", \"11:30\"),\n    (\"Wednesday\", \"12:00\", \"12:30\"),\n    (\"Wednesday\", \"13:30\", \"14:00\"),\n    (\"Wednesday\", \"15:00\", \"15:30\")\n]\n\nmaria_busy = [\n    (\"Monday\", \"9:30\", \"12:00\"),\n    (\"Monday\", \"12:30\", \"14:00\"),\n    (\"Monday\", \"14:30\", \"17:00\"),\n    (\"Tuesday\", \"9:00\", \"10:00\"),\n    (\"Tuesday\", \"10:30\", \"11:30\"),\n    (\"Tuesday\", \"12:30\", \"13:00\"),\n    (\"Tuesday\", \"13:30\", \"17:00\"),\n    (\"Wednesday\", \"9:30\", \"11:30\"),\n    (\"Wednesday\", \"12:00\", \"13:00\"),\n    (\"Wednesday\", \"13:30\", \"17:00\")\n]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(debra_busy, maria_busy, work_hours, days, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_758"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define schedules for Kathryn and Jason in minutes since midnight\n    kathryn_schedule = {\n        'Monday': [(14 * 60, 14 * 60 + 30)],\n        'Tuesday': [(16 * 60, 16 * 60 + 30)],\n        'Wednesday': [\n            (9 * 60, 10 * 60),\n            (12 * 60, 12 * 60 + 30),\n            (13 * 60, 14 * 60),\n            (16 * 60 + 30, 17 * 60)\n        ]\n    }\n    \n    jason_schedule = {\n        'Monday': [(9 * 60, 17 * 60)],\n        'Tuesday': [\n            (9 * 60 + 30, 10 * 60 + 30),\n            (11 * 60, 12 * 60),\n            (12 * 60 + 30, 17 * 60)\n        ],\n        'Wednesday': [\n            (10 * 60, 10 * 60 + 30),\n            (11 * 60, 12 * 60),\n            (13 * 60, 13 * 60 + 30),\n            (14 * 60 + 30, 16 * 60)\n        ]\n    }\n    \n    # Duration in minutes\n    duration = 30\n    \n    # Check days in order, respecting Jason's preference to not meet on Wednesday\n    preferred_days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    for day in preferred_days:\n        if day == 'Wednesday' and 'Wednesday' in preferred_days[:-1]:\n            continue  # Skip Wednesday if preferred days are Monday and Tuesday\n        \n        # Get busy times for both participants\n        kathryn_busy = kathryn_schedule.get(day, [])\n        jason_busy = jason_schedule.get(day, [])\n        \n        # Combine and sort all busy intervals\n        all_busy = sorted(kathryn_busy + jason_busy, key=lambda x: x[0])\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + duration\n                \n                # Convert back to HH:MM format\n                def to_time_str(minutes):\n                    hh = minutes // 60\n                    mm = minutes % 60\n                    return f\"{hh:02d}:{mm:02d}\"\n                \n                return f\"{to_time_str(meeting_start)}:{to_time_str(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_759"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define busy slots for Jennifer and Christine in minutes since midnight\n    jennifer_busy = {\n        'Monday': [(12 * 60 + 30, 13 * 60), (14 * 60 + 30, 15 * 60), (16 * 60, 16 * 60 + 30)],\n        'Tuesday': [(12 * 60 + 30, 13 * 60)],\n        'Wednesday': [(12 * 60 + 30, 13 * 60), (15 * 60 + 30, 16 * 60)]\n    }\n    \n    christine_busy = {\n        'Monday': [(10 * 60, 11 * 60), (12 * 60, 14 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Tuesday': [(10 * 60, 10 * 60 + 30), (11 * 60, 11 * 60 + 30), (12 * 60, 13 * 60), \n                    (13 * 60 + 30, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Wednesday': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (11 * 60 + 30, 13 * 60 + 30),\n                      (14 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)]\n    }\n    \n    # Iterate through each day to find the earliest available slot\n    for day in days:\n        # Collect all busy slots for both participants\n        busy_slots = jennifer_busy.get(day, []) + christine_busy.get(day, [])\n        busy_slots.sort()\n        \n        # Check available slots between work hours\n        prev_end = work_start\n        for start, end in busy_slots:\n            if start > prev_end:\n                # Found a gap, check if it's at least 30 minutes\n                if start - prev_end >= 30:\n                    # Format the time as HH:MM:HH:MM\n                    start_time = f\"{prev_end // 60:02d}:{prev_end % 60:02d}\"\n                    end_time = f\"{(prev_end + 30) // 60:02d}:{(prev_end + 30) % 60:02d}\"\n                    return f\"{start_time}:{end_time}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after the last busy slot\n        if work_end - prev_end >= 30:\n            start_time = f\"{prev_end // 60:02d}:{prev_end % 60:02d}\"\n            end_time = f\"{(prev_end + 30) // 60:02d}:{(prev_end + 30) % 60:02d}\"\n            return f\"{start_time}:{end_time}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_760"
        },
        {
            "final_program_time": "{15:30:16:30}",
            "expected_time": "{15:30:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    meeting_duration = 60  # minutes\n    \n    # Define busy times for each participant per day in minutes since midnight\n    kathleen_busy = {\n        'Monday': [(12 * 60 + 30, 13 * 60 + 30)],\n        'Tuesday': [(10 * 60 + 30, 11 * 60), (16 * 60 + 30, 17 * 60)],\n        'Wednesday': []\n    }\n    \n    albert_busy = {\n        'Monday': [(9 * 60, 17 * 60)],\n        'Tuesday': [\n            (9 * 60 + 30, 11 * 60),\n            (11 * 60 + 30, 12 * 60),\n            (12 * 60 + 30, 13 * 60),\n            (13 * 60 + 30, 14 * 60),\n            (14 * 60 + 30, 15 * 60),\n            (15 * 60 + 30, 16 * 60 + 30)\n        ],\n        'Wednesday': [\n            (9 * 60, 10 * 60),\n            (11 * 60, 11 * 60 + 30),\n            (12 * 60, 14 * 60),\n            (15 * 60, 15 * 60 + 30),\n            (16 * 60 + 30, 17 * 60)\n        ]\n    }\n    \n    # Albert cannot meet on Wednesday before 15:00\n    albert_busy['Wednesday'].append((0, 15 * 60))\n    \n    # Function to find available slots for a given day and person's busy times\n    def get_available_slots(busy_times, day_start, day_end):\n        busy_times_sorted = sorted(busy_times, key=lambda x: x[0])\n        available = []\n        prev_end = day_start\n        \n        for start, end in busy_times_sorted:\n            if start > prev_end:\n                available.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < day_end:\n            available.append((prev_end, day_end))\n        \n        return available\n    \n    # Check each day for overlapping available slots\n    for day in days:\n        # Get available slots for Kathleen and Albert\n        k_slots = get_available_slots(kathleen_busy[day], work_start, work_end)\n        a_slots = get_available_slots(albert_busy[day], work_start, work_end)\n        \n        # Find overlapping slots with enough duration\n        for k_start, k_end in k_slots:\n            for a_start, a_end in a_slots:\n                overlap_start = max(k_start, a_start)\n                overlap_end = min(k_end, a_end)\n                if overlap_end - overlap_start >= meeting_duration:\n                    # Convert minutes back to HH:MM format\n                    start_hh = overlap_start // 60\n                    start_mm = overlap_start % 60\n                    end_hh = (overlap_start + meeting_duration) // 60\n                    end_mm = (overlap_start + meeting_duration) % 60\n                    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_761"
        },
        {
            "final_program_time": "{12:30:13:30}",
            "expected_time": "{12:30:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday']\n\n    # Define schedules for Jacob and Randy in minutes since midnight\n    jacob_schedule = {\n        'Monday': [(10 * 60, 10 * 60 + 30), (11 * 60, 11 * 60 + 30), (14 * 60, 14 * 60 + 30),\n                   (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Tuesday': [(12 * 60, 14 * 60), (15 * 60, 15 * 60 + 30)],\n        'Wednesday': [(11 * 60, 11 * 60 + 30), (14 * 60 + 30, 15 * 60)]\n    }\n\n    randy_schedule = {\n        'Monday': [(9 * 60, 9 * 60 + 30), (11 * 60, 12 * 60 + 30), (13 * 60, 14 * 60),\n                   (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60, 13 * 60 + 30), (14 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 12 * 60 + 30), (14 * 60, 15 * 60),\n                      (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)]\n    }\n\n    # Check each day for available slots\n    for day in days:\n        # Collect all busy times for both participants\n        busy_times = jacob_schedule.get(day, []) + randy_schedule.get(day, [])\n        busy_times.sort()\n\n        # Initialize available slots\n        available_slots = []\n        prev_end = work_start\n\n        # Find gaps between busy times\n        for start, end in busy_times:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n\n        # Check after last busy time\n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n\n        # Check each available slot for a 60-minute window\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= 60:\n                meeting_start = slot_start\n                meeting_end = meeting_start + 60\n                # Convert back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_762"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_earliest_meeting_time(duration, days, work_hours, schedules):\n    # Parse work hours\n    work_start, work_end = map(int, work_hours.split(':'))\n\n    # Iterate through each day in order\n    for day in days:\n        # Get the busy slots for the current day for Scott (Danielle is free all day)\n        busy_slots = schedules['Scott'].get(day, [])\n        \n        # Convert busy slots to minutes since start of day for easier comparison\n        busy_in_minutes = []\n        for slot in busy_slots:\n            start, end = slot.split(' to ')\n            start_h, start_m = map(int, start.split(':'))\n            end_h, end_m = map(int, end.split(':'))\n            busy_in_minutes.append((start_h * 60 + start_m, end_h * 60 + end_m))\n        \n        # Sort busy slots by start time\n        busy_in_minutes.sort()\n        \n        # Check the time before the first busy slot\n        if busy_in_minutes:\n            first_busy_start, _ = busy_in_minutes[0]\n            available_start = work_start * 60\n            available_end = first_busy_start\n            if available_end - available_start >= duration:\n                return day, f\"{available_start // 60:02d}:{available_start % 60:02d}\", f\"{(available_start + duration) // 60:02d}:{(available_start + duration) % 60:02d}\"\n        \n        # Check the time between busy slots\n        for i in range(len(busy_in_minutes) - 1):\n            _, current_end = busy_in_minutes[i]\n            next_start, _ = busy_in_minutes[i + 1]\n            if next_start - current_end >= duration:\n                return day, f\"{current_end // 60:02d}:{current_end % 60:02d}\", f\"{(current_end + duration) // 60:02d}:{(current_end + duration) % 60:02d}\"\n        \n        # Check the time after the last busy slot\n        if busy_in_minutes:\n            _, last_busy_end = busy_in_minutes[-1]\n            available_start = last_busy_end\n            available_end = work_end * 60\n            if available_end - available_start >= duration:\n                return day, f\"{available_start // 60:02d}:{available_start % 60:02d}\", f\"{(available_start + duration) // 60:02d}:{(available_start + duration) % 60:02d}\"\n        else:\n            # No busy slots all day\n            available_start = work_start * 60\n            available_end = work_end * 60\n            if available_end - available_start >= duration:\n                return day, f\"{work_start:02d}:00\", f\"{(work_start * 60 + duration) // 60:02d}:{(work_start * 60 + duration) % 60:02d}\"\n    \n    return None\n\n# Define the problem parameters\nduration = 30  # minutes\ndays = ['Monday', 'Tuesday', 'Wednesday']\nwork_hours = '9:17'  # Assuming work hours are 9:00 to 17:00 (but typo in original, assuming 17:00)\n\n# Define the schedules\nschedules = {\n    'Scott': {\n        'Monday': ['9:30 to 10:00', '10:30 to 11:00', '11:30 to 13:00', '13:30 to 15:30', '16:00 to 17:00'],\n        'Tuesday': ['9:00 to 9:30', '10:00 to 11:00', '11:30 to 12:30', '13:00 to 13:30', '14:30 to 15:30', '16:00 to 17:00'],\n        'Wednesday': ['9:00 to 10:00', '12:00 to 12:30', '14:00 to 14:30', '15:00 to 16:00', '16:30 to 17:00']\n    },\n    'Danielle': {}  # No meetings\n}\n\n# Find the earliest meeting time\nresult = find_earliest_meeting_time(duration, days, work_hours, schedules)\nif result:\n    day, start_time, end_time = result\n    print(f\"{start_time}:{end_time}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_763"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define days to consider (Monday, Tuesday)\n    days = [\"Monday\", \"Tuesday\"]\n\n    # Define busy slots for each participant per day in minutes\n    busy_slots = {\n        \"Monday\": {\n            \"Diana\": [(11 * 60, 11 * 60 + 30), (12 * 60, 12 * 60 + 30)],\n            \"Denise\": [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60), (12 * 60 + 30, 14 * 60), (14 * 60 + 30, 16 * 60)],\n        },\n        \"Tuesday\": {\n            \"Diana\": [(9 * 60, 10 * 60 + 30), (12 * 60, 13 * 60), (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60 + 30)],\n            \"Denise\": [(9 * 60, 17 * 60)],  # Denise is busy all day Tuesday\n        },\n    }\n\n    # Iterate through each day\n    for day in days:\n        # Collect all busy slots for the day\n        all_busy = []\n        for person in busy_slots[day]:\n            all_busy.extend(busy_slots[day][person])\n        \n        # Sort busy slots by start time\n        all_busy.sort()\n\n        # Find free slots by checking gaps between busy slots\n        free_slots = []\n        previous_end = work_start\n\n        for start, end in all_busy:\n            if start > previous_end:\n                free_slots.append((previous_end, start))\n            previous_end = max(previous_end, end)\n        \n        # Check after last busy slot\n        if previous_end < work_end:\n            free_slots.append((previous_end, work_end))\n\n        # Check each free slot for a 30-minute window\n        for start, end in free_slots:\n            if end - start >= 30:\n                # Convert start time back to HH:MM format\n                meeting_start = start\n                meeting_end = meeting_start + 30\n                # Format as HH:MM:HH:MM\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_764"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday']\n\n    # Define busy times for Joshua and Joyce in minutes since midnight\n    joshua_busy = {\n        'Monday': [(15 * 60, 15 * 60 + 30)],\n        'Tuesday': [(11 * 60 + 30, 12 * 60), (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60)],\n        'Wednesday': []\n    }\n\n    joyce_busy = {\n        'Monday': [(9 * 60, 9 * 60 + 30), (10 * 60, 11 * 60), (11 * 60 + 30, 12 * 60 + 30),\n                   (13 * 60, 15 * 60), (15 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 9 * 60 + 30), (10 * 60, 11 * 60), (12 * 60 + 30, 15 * 60 + 30),\n                     (16 * 60, 16 * 60 + 30)]\n    }\n\n    # Joyce's preference: not before 12:00 on Monday\n    joyce_preference = {\n        'Monday': 12 * 60,\n        'Tuesday': 0,\n        'Wednesday': 0\n    }\n\n    meeting_duration = 30  # minutes\n\n    # Iterate through each day to find a suitable time\n    for day in days:\n        # Get busy times for both participants\n        busy_times = joshua_busy[day] + joyce_busy[day]\n        busy_times.sort()  # Sort by start time\n\n        # Initialize the previous end time to work start\n        prev_end = max(work_start, joyce_preference[day])\n\n        # Check gaps between busy times\n        for busy_start, busy_end in busy_times:\n            if busy_start > prev_end:\n                gap = busy_start - prev_end\n                if gap >= meeting_duration:\n                    # Found a suitable time\n                    start_time = prev_end\n                    end_time = start_time + meeting_duration\n                    # Format the time as HH:MM:HH:MM\n                    return f\"{start_time // 60:02d}:{start_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n            prev_end = max(prev_end, busy_end)\n\n        # Check the gap after the last busy time\n        if work_end - prev_end >= meeting_duration:\n            start_time = prev_end\n            end_time = start_time + meeting_duration\n            return f\"{start_time // 60:02d}:{start_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_765"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_earliest_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration, days):\n    # Convert work hours to minutes since midnight for easier calculation\n    work_start = work_hours_start.hour * 60 + work_hours_start.minute\n    work_end = work_hours_end.hour * 60 + work_hours_end.minute\n    \n    # Iterate through each day in order\n    for day in days:\n        # Collect all busy times for the current day for all participants\n        busy_intervals = []\n        for person in participants_busy_times:\n            if day in person:\n                for interval in person[day]:\n                    start_time = datetime.strptime(interval[0], \"%H:%M\")\n                    end_time = datetime.strptime(interval[1], \"%H:%M\")\n                    start_min = start_time.hour * 60 + start_time.minute\n                    end_min = end_time.hour * 60 + end_time.minute\n                    busy_intervals.append((start_min, end_min))\n        \n        # Sort busy intervals by start time\n        busy_intervals.sort()\n        \n        # Check the time before the first busy interval\n        if len(busy_intervals) == 0:\n            # No busy intervals, the whole day is free\n            proposed_start = work_start\n            proposed_end = proposed_start + meeting_duration\n            if proposed_end <= work_end:\n                return format_time(day, proposed_start, proposed_end)\n        else:\n            first_start, first_end = busy_intervals[0]\n            if work_start + meeting_duration <= first_start:\n                proposed_start = work_start\n                proposed_end = proposed_start + meeting_duration\n                return format_time(day, proposed_start, proposed_end)\n        \n        # Check gaps between busy intervals\n        for i in range(len(busy_intervals) - 1):\n            current_end = busy_intervals[i][1]\n            next_start = busy_intervals[i+1][0]\n            if current_end + meeting_duration <= next_start:\n                proposed_start = current_end\n                proposed_end = proposed_start + meeting_duration\n                if proposed_end <= work_end:\n                    return format_time(day, proposed_start, proposed_end)\n        \n        # Check the time after the last busy interval\n        last_start, last_end = busy_intervals[-1]\n        if last_end + meeting_duration <= work_end:\n            proposed_start = last_end\n            proposed_end = proposed_start + meeting_duration\n            return format_time(day, proposed_start, proposed_end)\n    \n    return None\n\ndef format_time(day, start_min, end_min):\n    start_hour = start_min // 60\n    start_min = start_min % 60\n    end_hour = end_min // 60\n    end_min = end_min % 60\n    return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n\n# Define the participants' busy times\ngrace_busy = {\n    \"Tuesday\": [(\"13:00\", \"13:30\")],\n    \"Wednesday\": [(\"14:30\", \"15:00\")]\n}\n\ndebra_busy = {\n    \"Monday\": [(\"9:00\", \"10:00\"), (\"11:30\", \"12:00\"), (\"15:00\", \"16:00\"), (\"16:30\", \"17:00\")],\n    \"Tuesday\": [(\"9:00\", \"11:00\"), (\"11:30\", \"14:00\"), (\"14:30\", \"15:00\"), (\"15:30\", \"17:00\")],\n    \"Wednesday\": [(\"10:00\", \"15:00\"), (\"15:30\", \"17:00\")]\n}\n\n# Define meeting parameters\nwork_hours_start = datetime.strptime(\"9:00\", \"%H:%M\")\nwork_hours_end = datetime.strptime(\"17:00\", \"%H:%M\")\nmeeting_duration = 30  # minutes\ndays = [\"Monday\", \"Tuesday\", \"Wednesday\"]\n\n# Find the earliest meeting time\nresult = find_earliest_meeting_time([grace_busy, debra_busy], work_hours_start, work_hours_end, meeting_duration, days)\nprint(result)\n```",
            "count": "calendar_scheduling_example_766"
        },
        {
            "final_program_time": "{15:30:16:30}",
            "expected_time": "{15:30:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Define blocked times for Martha and Beverly for each day in minutes since midnight\n    blocked_times = {\n        \"Monday\": {\n            \"Martha\": [(16 * 60, 17 * 60)],\n            \"Beverly\": [(9 * 60, 13 * 60 + 30), (14 * 60, 17 * 60)],\n        },\n        \"Tuesday\": {\n            \"Martha\": [(15 * 60, 15 * 60 + 30)],\n            \"Beverly\": [(9 * 60, 17 * 60)],\n        },\n        \"Wednesday\": {\n            \"Martha\": [(10 * 60, 11 * 60), (14 * 60, 14 * 60 + 30)],\n            \"Beverly\": [(9 * 60 + 30, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n        },\n    }\n\n    # Check each day for available slots\n    for day in [\"Monday\", \"Tuesday\", \"Wednesday\"]:\n        martha_blocked = blocked_times[day][\"Martha\"]\n        beverly_blocked = blocked_times[day][\"Beverly\"]\n\n        # Combine and sort all blocked intervals for the day\n        all_blocked = martha_blocked + beverly_blocked\n        all_blocked.sort()\n\n        # Merge overlapping or adjacent intervals\n        merged_blocked = []\n        for start, end in all_blocked:\n            if not merged_blocked:\n                merged_blocked.append([start, end])\n            else:\n                last_start, last_end = merged_blocked[-1]\n                if start <= last_end:\n                    merged_blocked[-1][1] = max(last_end, end)\n                else:\n                    merged_blocked.append([start, end])\n\n        # Check available slots before the first blocked interval, between intervals, and after the last\n        prev_end = work_start\n        for start, end in merged_blocked:\n            if start > prev_end:\n                available_start = prev_end\n                available_end = start\n                if available_end - available_start >= meeting_duration:\n                    # Found a suitable slot\n                    meeting_start = available_start\n                    meeting_end = meeting_start + meeting_duration\n                    return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n            prev_end = max(prev_end, end)\n\n        # Check after the last blocked interval\n        if work_end - prev_end >= meeting_duration:\n            meeting_start = prev_end\n            meeting_end = meeting_start + meeting_duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No suitable time found\"\n\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_767"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define the busy slots for each person in minutes since midnight\n    denise_busy = {\n        'Monday': [(13 * 60, 14 * 60), (15 * 60 + 30, 16 * 60)],\n        'Tuesday': [(12 * 60, 12 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Wednesday': [(9 * 60 + 30, 10 * 60), (11 * 60, 11 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60 + 30)]\n    }\n    \n    keith_busy = {\n        'Monday': [(9 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60 + 30), (14 * 60, 14 * 60 + 30), (15 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60, 17 * 60)],\n        'Wednesday': [(10 * 60 + 30, 11 * 60 + 30), (12 * 60, 13 * 60), (13 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60)]\n    }\n    \n    # Additional constraints\n    denise_no_wed_after_1130 = True\n    keith_no_monday = True\n    \n    meeting_duration = 30  # minutes\n    \n    # Iterate through each day to find a suitable time\n    for day in days:\n        if day == 'Monday' and keith_no_monday:\n            continue\n        if day == 'Wednesday' and denise_no_wed_after_1130:\n            # Adjust work hours end for Denise on Wednesday\n            denise_work_end = 11 * 60 + 30\n        else:\n            denise_work_end = work_hours_end\n        \n        # Combine busy slots for both participants\n        busy_slots = []\n        if day in denise_busy:\n            busy_slots.extend(denise_busy[day])\n        if day in keith_busy:\n            busy_slots.extend(keith_busy[day])\n        \n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Find the earliest available slot\n        prev_end = work_hours_start\n        for start, end in busy_slots:\n            if start > prev_end:\n                available_start = prev_end\n                available_end = start\n                if available_end - available_start >= meeting_duration:\n                    # Ensure the slot is within Denise's adjusted work hours on Wednesday\n                    if day == 'Wednesday' and denise_no_wed_after_1130:\n                        if available_start + meeting_duration <= denise_work_end:\n                            return f\"{int(available_start // 60):02d}:{int(available_start % 60):02d}:{int((available_start + meeting_duration) // 60):02d}:{int((available_start + meeting_duration) % 60):02d}\"\n                    else:\n                        return f\"{int(available_start // 60):02d}:{int(available_start % 60):02d}:{int((available_start + meeting_duration) // 60):02d}:{int((available_start + meeting_duration) % 60):02d}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after the last busy slot\n        if prev_end < denise_work_end and prev_end + meeting_duration <= denise_work_end:\n            return f\"{int(prev_end // 60):02d}:{int(prev_end % 60):02d}:{int((prev_end + meeting_duration) // 60):02d}:{int((prev_end + meeting_duration) % 60):02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_768"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define participants' schedules and constraints\n    diana_constraints = {\n        'Monday': {'unavailable_after': 13 * 60},  # 13:00 in minutes\n        'Tuesday': {},\n        'Wednesday': {}\n    }\n    \n    william_schedule = {\n        'Monday': [\n            {'start': 9 * 60, 'end': 11 * 60 + 30},    # 9:00-11:30\n            {'start': 12 * 60, 'end': 14 * 60 + 30},   # 12:00-14:30\n            {'start': 15 * 60, 'end': 17 * 60}        # 15:00-17:00\n        ],\n        'Tuesday': [\n            {'start': 9 * 60, 'end': 17 * 60}          # 9:00-17:00 (entire day)\n        ],\n        'Wednesday': [\n            {'start': 9 * 60, 'end': 17 * 60}          # 9:00-17:00 (entire day)\n        ]\n    }\n    \n    meeting_duration = 30  # minutes\n    \n    # Iterate through each day to find a suitable time\n    for day in days:\n        # Check Diana's constraints for the day\n        diana_unavailable_after = diana_constraints[day].get('unavailable_after', work_end)\n        day_end = min(diana_unavailable_after, work_end)\n        \n        # Get William's busy slots for the day\n        william_busy = william_schedule[day]\n        \n        # Find available slots for William (gaps between meetings)\n        william_available = []\n        prev_end = work_start\n        for meeting in william_busy:\n            if meeting['start'] > prev_end:\n                william_available.append({'start': prev_end, 'end': meeting['start']})\n            prev_end = meeting['end']\n        if prev_end < work_end:\n            william_available.append({'start': prev_end, 'end': work_end})\n        \n        # Check for overlapping availability between Diana and William\n        for slot in william_available:\n            slot_start = max(slot['start'], work_start)\n            slot_end = min(slot['end'], day_end)\n            \n            if slot_end - slot_start >= meeting_duration:\n                # Found a suitable slot\n                start_time = slot_start\n                end_time = start_time + meeting_duration\n                \n                # Format the time as HH:MM:HH:MM\n                start_hh = start_time // 60\n                start_mm = start_time % 60\n                end_hh = end_time // 60\n                end_mm = end_time % 60\n                \n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_769"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define busy slots for Arthur and Eric in minutes since midnight\n    arthur_busy = {\n        'Monday': [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 11 * 60 + 30), (13 * 60, 14 * 60)],\n        'Tuesday': [(9 * 60, 12 * 60 + 30), (13 * 60, 14 * 60), (15 * 60 + 30, 17 * 60)],\n        'Wednesday': [(10 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60), (14 * 60, 14 * 60 + 30)]\n    }\n    \n    eric_busy = {\n        'Monday': [(9 * 60, 9 * 60 + 30), (10 * 60, 13 * 60), (13 * 60 + 30, 14 * 60), (15 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 12 * 60 + 30), (13 * 60, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n        'Wednesday': [(9 * 60 + 30, 11 * 60), (11 * 60 + 30, 16 * 60 + 30)]\n    }\n    \n    # Check each day for available slots\n    for day in days:\n        # Combine and sort all busy slots for both participants\n        all_busy = sorted(arthur_busy.get(day, []) + eric_busy.get(day, []))\n        \n        # Find free slots\n        prev_end = work_start\n        free_slots = []\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check for a 1-hour slot\n        for start, end in free_slots:\n            if end - start >= 60:\n                meeting_start = start\n                meeting_end = meeting_start + 60\n                # Format the time as HH:MM:HH:MM\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_770"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    meeting_duration = 30  # minutes\n    \n    # Define participants' schedules and constraints\n    ann_schedule = {\n        'Monday': [(12 * 60, 13 * 60), (15.5 * 60, 16.5 * 60)],\n        'Tuesday': [(9 * 60, 9.5 * 60), (10.5 * 60, 11.5 * 60), (13 * 60, 15 * 60)],\n        'Wednesday': [(10.5 * 60, 11.5 * 60), (13 * 60, 13.5 * 60), (14 * 60, 14.5 * 60), (16 * 60, 16.5 * 60)]\n    }\n    \n    susan_schedule = {\n        'Monday': [(10 * 60, 10.5 * 60), (11 * 60, 12 * 60), (12.5 * 60, 13 * 60), \n                   (13.5 * 60, 14 * 60), (15 * 60, 16 * 60), (16.5 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 10.5 * 60), (11 * 60, 11.5 * 60), (12 * 60, 12.5 * 60), \n                    (13 * 60, 13.5 * 60), (14 * 60, 14.5 * 60), (15 * 60, 16 * 60)],\n        'Wednesday': [(9 * 60, 10 * 60), (10.5 * 60, 13.5 * 60), (14 * 60, 15 * 60), (16 * 60, 16.5 * 60)]\n    }\n    \n    # Apply constraints: Ann can't meet on Tuesday after 12:30, Susan doesn't want Monday\n    ann_schedule['Tuesday'].append((12.5 * 60, work_end))  # Block after 12:30 on Tuesday\n    days_to_check = [day for day in days if day != 'Monday']  # Exclude Monday per Susan's preference\n    \n    for day in days_to_check:\n        # Collect all busy times for both participants on this day\n        busy_times = ann_schedule.get(day, []) + susan_schedule.get(day, [])\n        busy_times.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in busy_times:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= meeting_duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                # Convert to HH:MM format\n                start_hh = int(meeting_start // 60)\n                start_mm = int(meeting_start % 60)\n                end_hh = int(meeting_end // 60)\n                end_mm = int(meeting_end % 60)\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_771"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    meeting_duration = 30  # minutes\n\n    # Define existing schedules and preferences\n    walter_schedule = {\n        'Monday': [(9 * 60 + 30, 10 * 60)],  # 9:30-10:00\n        'Tuesday': [(10 * 60, 10 * 60 + 30), (12 * 60, 12 * 60 + 30)],  # 10:00-10:30, 12:00-12:30\n        'Wednesday': [(10 * 60, 10 * 60 + 30)]  # 10:00-10:30\n    }\n    eugene_schedule = {\n        'Monday': [(9 * 60 + 30, 13 * 60 + 30), (14 * 60, 17 * 60)],  # 9:30-13:30, 14:00-17:00\n        'Tuesday': [(9 * 60, 17 * 60)],  # 9:00-17:00 (entire day busy)\n        'Wednesday': [(9 * 60, 10 * 60 + 30), (11 * 60, 16 * 60 + 30)]  # 9:00-10:30, 11:00-16:30\n    }\n    walter_preferences = {\n        'Monday': (12 * 60, work_end)  # Prefers after 12:00 on Monday\n    }\n\n    for day in days:\n        # Get busy intervals for both participants\n        walter_busy = walter_schedule.get(day, [])\n        eugene_busy = eugene_schedule.get(day, [])\n\n        # Combine and sort all busy intervals\n        all_busy = sorted(walter_busy + eugene_busy, key=lambda x: x[0])\n\n        # Generate free intervals\n        free_intervals = []\n        prev_end = work_start\n\n        for start, end in all_busy:\n            if start > prev_end:\n                free_intervals.append((prev_end, start))\n            prev_end = max(prev_end, end)\n\n        if prev_end < work_end:\n            free_intervals.append((prev_end, work_end))\n\n        # Check Walter's preferences for the day\n        preferred_start = walter_preferences.get(day, (work_start, work_end))[0]\n\n        # Find first suitable free interval\n        for start, end in free_intervals:\n            # Adjust start if preference applies\n            current_start = max(start, preferred_start)\n            if current_start + meeting_duration <= end:\n                # Convert minutes back to HH:MM format\n                meeting_start = current_start\n                meeting_end = meeting_start + meeting_duration\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_772"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = [\"Monday\", \"Tuesday\", \"Wednesday\"]\n    \n    # Roy's busy times in minutes since midnight for each day\n    roy_busy = {\n        \"Monday\": [(10 * 60, 11 * 60 + 30), (12 * 60, 13 * 60), \n                   (14 * 60, 14 * 60 + 30), (15 * 60, 17 * 60)],\n        \"Tuesday\": [(10 * 60 + 30, 11 * 60 + 30), (12 * 60, 14 * 60 + 30), \n                    (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        \"Wednesday\": [(9 * 60 + 30, 11 * 60 + 30), (12 * 60 + 30, 14 * 60), \n                      (14 * 60 + 30, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)]\n    }\n    \n    # Patrick is free all the time, so only Roy's schedule matters\n    meeting_duration = 60  # 1 hour\n    \n    for day in days:\n        # Start checking from the beginning of the work day\n        current_time = work_start\n        \n        # Get Roy's busy slots for the day\n        busy_slots = roy_busy[day]\n        \n        # Iterate through the busy slots to find gaps\n        for start, end in busy_slots:\n            if current_time < start:\n                # Check if there's enough time before the next busy slot\n                if start - current_time >= meeting_duration:\n                    # Convert times back to HH:MM format\n                    start_time = f\"{current_time // 60:02d}:{current_time % 60:02d}\"\n                    end_time = f\"{(current_time + meeting_duration) // 60:02d}:{(current_time + meeting_duration) % 60:02d}\"\n                    return f\"{start_time}:{end_time}\"\n            # Update current_time to the end of the current busy slot\n            current_time = max(current_time, end)\n        \n        # Check the time after the last busy slot\n        if work_end - current_time >= meeting_duration:\n            start_time = f\"{current_time // 60:02d}:{current_time % 60:02d}\"\n            end_time = f\"{(current_time + meeting_duration) // 60:02d}:{(current_time + meeting_duration) % 60:02d}\"\n            return f\"{start_time}:{end_time}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_773"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define busy slots for Diana and Rachel in minutes since midnight\n    diana_busy = {\n        'Monday': [(14*60 + 30, 15*60), (15*60 + 30, 16*60)],\n        'Tuesday': [(13*60, 13*60 + 30)],\n        'Wednesday': [(9*60 + 30, 10*60), (12*60, 13*60), (14*60, 14*60 + 30), (16*60, 16*60 + 30)]\n    }\n    \n    rachel_busy = {\n        'Monday': [(9*60 + 30, 11*60 + 30), (12*60, 14*60 + 30), (15*60, 17*60)],\n        'Tuesday': [(9*60 + 30, 12*60 + 30), (13*60 + 30, 14*60), (16*60, 17*60)],\n        'Wednesday': [(10*60, 12*60 + 30), (13*60 + 30, 14*60 + 30), (16*60 + 30, 17*60)]\n    }\n    \n    # Check each day for the earliest available slot\n    for day in days:\n        # Collect all busy slots for both participants\n        busy_slots = diana_busy.get(day, []) + rachel_busy.get(day, [])\n        busy_slots.sort()\n        \n        # Merge overlapping or adjacent busy slots\n        merged_slots = []\n        for start, end in busy_slots:\n            if not merged_slots:\n                merged_slots.append((start, end))\n            else:\n                last_start, last_end = merged_slots[-1]\n                if start <= last_end:\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged_slots[-1] = (new_start, new_end)\n                else:\n                    merged_slots.append((start, end))\n        \n        # Check the time before the first busy slot\n        if not merged_slots:\n            # No busy slots, entire workday is free\n            return f\"{minutes_to_time(work_start)}:{minutes_to_time(work_start + 60)}\"\n        first_start, first_end = merged_slots[0]\n        if first_start - work_start >= 60:\n            return f\"{minutes_to_time(work_start)}:{minutes_to_time(work_start + 60)}\"\n        \n        # Check the time between busy slots\n        for i in range(len(merged_slots) - 1):\n            current_end = merged_slots[i][1]\n            next_start = merged_slots[i+1][0]\n            if next_start - current_end >= 60:\n                return f\"{minutes_to_time(current_end)}:{minutes_to_time(current_end + 60)}\"\n        \n        # Check the time after the last busy slot\n        last_start, last_end = merged_slots[-1]\n        if work_end - last_end >= 60:\n            return f\"{minutes_to_time(last_end)}:{minutes_to_time(last_end + 60)}\"\n    \n    return \"No time found\"\n\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_774"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    meeting_duration = 60  # minutes\n    \n    # Define blocked times for each participant per day in minutes since midnight\n    blocked_times = {\n        'Kathryn': {\n            'Monday': [(11 * 60, 11 * 60 + 30)],\n            'Tuesday': [(16 * 60 + 30, 17 * 60)],\n            'Wednesday': [(12 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60)]\n        },\n        'Denise': {\n            'Monday': [(9 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n            'Tuesday': [(9 * 60, 9 * 60 + 30), (10 * 60, 12 * 60), (12 * 60 + 30, 13 * 60), (14 * 60, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n            'Wednesday': [(12 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), (16 * 60, 17 * 60)]\n        }\n    }\n    \n    # Preferences: Kathryn avoids Tuesday, Denise avoids Wednesday\n    preferred_days = ['Monday', 'Wednesday']  # Tuesday is less preferred for Kathryn\n    preferred_days = ['Monday', 'Tuesday']    # Wednesday is less preferred for Denise\n    \n    # Iterate through days in order of preference (Monday first)\n    for day in ['Monday', 'Tuesday', 'Wednesday']:\n        if day == 'Tuesday':  # Kathryn prefers to avoid Tuesday\n            continue\n        if day == 'Wednesday':  # Denise prefers to avoid Wednesday\n            continue\n        \n        # Collect all blocked times for both participants on this day\n        all_blocked = []\n        for person in ['Kathryn', 'Denise']:\n            if day in blocked_times[person]:\n                all_blocked.extend(blocked_times[person][day])\n        \n        # Sort blocked times by start time\n        all_blocked.sort()\n        \n        # Find available slots\n        available_slots = []\n        prev_end = work_start\n        \n        for start, end in all_blocked:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n        \n        # Check each available slot for a meeting duration\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= meeting_duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    # If no slot found in preferred days, check other days\n    for day in ['Monday', 'Tuesday', 'Wednesday']:\n        if day == 'Tuesday':  # Skip if Kathryn prefers to avoid Tuesday\n            continue\n        if day == 'Wednesday':  # Skip if Denise prefers to avoid Wednesday\n            continue\n        \n        # Collect all blocked times for both participants on this day\n        all_blocked = []\n        for person in ['Kathryn', 'Denise']:\n            if day in blocked_times[person]:\n                all_blocked.extend(blocked_times[person][day])\n        \n        # Sort blocked times by start time\n        all_blocked.sort()\n        \n        # Find available slots\n        available_slots = []\n        prev_end = work_start\n        \n        for start, end in all_blocked:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n        \n        # Check each available slot for a meeting duration\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= meeting_duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    # If no slot found (though problem states there is one)\n    return \"No suitable time found\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_775"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    meeting_duration = 30  # minutes\n    \n    # Define John's constraints (no meetings, but prefers to avoid Monday after 14:30)\n    john_available = {\n        'Monday': [(work_start, 14 * 60 + 30)],  # 9:00 to 14:30\n        'Tuesday': [(work_start, work_end)],     # 9:00 to 17:00\n        'Wednesday': [(work_start, work_end)]     # 9:00 to 17:00\n    }\n    \n    # Define Jennifer's busy times (convert to minutes since midnight)\n    jennifer_busy = {\n        'Monday': [\n            (9 * 60, 11 * 60),      # 9:00-11:00\n            (11 * 60 + 30, 13 * 60), # 11:30-13:00\n            (13 * 60 + 30, 14 * 60 + 30), # 13:30-14:30\n            (15 * 60, 17 * 60)       # 15:00-17:00\n        ],\n        'Tuesday': [\n            (9 * 60, 11 * 60 + 30),  # 9:00-11:30\n            (12 * 60, 17 * 60)       # 12:00-17:00\n        ],\n        'Wednesday': [\n            (9 * 60, 11 * 60 + 30),  # 9:00-11:30\n            (12 * 60, 12 * 60 + 30),  # 12:00-12:30\n            (13 * 60, 14 * 60),       # 13:00-14:00\n            (14 * 60 + 30, 16 * 60),  # 14:30-16:00\n            (16 * 60 + 30, 17 * 60)   # 16:30-17:00\n        ]\n    }\n    \n    # Convert Jennifer's busy times to available slots\n    jennifer_available = {}\n    for day in days:\n        busy = jennifer_busy[day]\n        available = []\n        prev_end = work_start\n        \n        for start, end in sorted(busy):\n            if start > prev_end:\n                available.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            available.append((prev_end, work_end))\n        \n        jennifer_available[day] = available\n    \n    # Find overlapping slots between John and Jennifer\n    for day in days:\n        john_slots = john_available[day]\n        jennifer_slots = jennifer_available[day]\n        \n        for jhn_start, jhn_end in john_slots:\n            for jen_start, jen_end in jennifer_slots:\n                # Find overlap between John and Jennifer's slots\n                overlap_start = max(jhn_start, jen_start)\n                overlap_end = min(jhn_end, jen_end)\n                \n                if overlap_start < overlap_end and (overlap_end - overlap_start) >= meeting_duration:\n                    # Found a suitable slot\n                    start_time = overlap_start\n                    end_time = start_time + meeting_duration\n                    \n                    # Convert to HH:MM format\n                    def format_time(minutes):\n                        hh = minutes // 60\n                        mm = minutes % 60\n                        return f\"{hh:02d}:{mm:02d}\"\n                    \n                    return f\"{format_time(start_time)}:{format_time(end_time)}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_776"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to check (Monday, Tuesday, Wednesday)\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define Brandon's constraints (busy times in minutes since midnight)\n    brandon_busy = {\n        'Monday': [(10 * 60 + 30, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (13 * 60 + 30, 14 * 60 + 30)],\n        'Tuesday': [(10 * 60, 11 * 60 + 30), (14 * 60, 14 * 60 + 30), (15 * 60 + 30, 16 * 60 + 30)],\n        'Wednesday': [(12 * 60, 13 * 60 + 30), (14 * 60, 15 * 60)]\n    }\n    \n    # Define Olivia's constraints (busy times in minutes since midnight)\n    olivia_busy = {\n        'Monday': [(9 * 60, 12 * 60), (12 * 60 + 30, 13 * 60 + 30), (14 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 11 * 60), (12 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Wednesday': [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60 + 30), (16 * 60, 17 * 60)]\n    }\n    \n    # Brandon doesn't want to meet on Tuesday\n    days_to_check = [day for day in days if day != 'Tuesday']\n    \n    # Check each day in order\n    for day in days_to_check:\n        # Combine and sort all busy intervals for both participants\n        all_busy = brandon_busy[day] + olivia_busy[day]\n        all_busy.sort()\n        \n        # Merge overlapping or adjacent intervals\n        merged = []\n        for start, end in all_busy:\n            if not merged:\n                merged.append((start, end))\n            else:\n                last_start, last_end = merged[-1]\n                if start <= last_end:\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged[-1] = (new_start, new_end)\n                else:\n                    merged.append((start, end))\n        \n        # Check the time before the first busy interval\n        if merged:\n            first_start, first_end = merged[0]\n            if first_start - work_start >= 30:\n                meeting_start = work_start\n                meeting_end = meeting_start + 30\n                return f\"{format_time(meeting_start)}:{format_time(meeting_end)}\"\n        \n        # Check the time between busy intervals\n        for i in range(len(merged) - 1):\n            current_end = merged[i][1]\n            next_start = merged[i + 1][0]\n            if next_start - current_end >= 30:\n                meeting_start = current_end\n                meeting_end = meeting_start + 30\n                return f\"{format_time(meeting_start)}:{format_time(meeting_end)}\"\n        \n        # Check the time after the last busy interval\n        if merged:\n            last_start, last_end = merged[-1]\n            if work_end - last_end >= 30:\n                meeting_start = last_end\n                meeting_end = meeting_start + 30\n                return f\"{format_time(meeting_start)}:{format_time(meeting_end)}\"\n        else:\n            # No busy intervals, schedule at the start of the day\n            meeting_start = work_start\n            meeting_end = meeting_start + 30\n            return f\"{format_time(meeting_start)}:{format_time(meeting_end)}\"\n    \n    return \"No time found\"\n\ndef format_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Find and print the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_777"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define participants' schedules and constraints\n    susan_schedule = {\n        'Monday': [(12 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60)],\n        'Tuesday': [(11 * 60 + 30, 12 * 60)],\n        'Wednesday': [(9 * 60 + 30, 10 * 60 + 30), (14 * 60, 14 * 60 + 30), (15 * 60 + 30, 16 * 60 + 30)]\n    }\n    \n    sandra_schedule = {\n        'Monday': [(9 * 60, 13 * 60), (14 * 60, 15 * 60), (16 * 60, 16 * 60 + 30)],\n        'Tuesday': [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60 + 30), (14 * 60, 14 * 60 + 30), (16 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (13 * 60, 17 * 60)]\n    }\n    \n    # Susan's preference: not Tuesday\n    preferred_days = ['Monday', 'Wednesday']\n    \n    # Sandra's constraint: cannot meet on Monday after 16:00 (already in schedule)\n    \n    meeting_duration = 30  # minutes\n    \n    # Iterate through preferred days first\n    for day in preferred_days:\n        # Get both schedules for the day\n        susan_busy = susan_schedule.get(day, [])\n        sandra_busy = sandra_schedule.get(day, [])\n        \n        # Combine and sort all busy intervals\n        all_busy = susan_busy + sandra_busy\n        all_busy.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= meeting_duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    # If no slot found in preferred days, check Tuesday (though Susan prefers not)\n    day = 'Tuesday'\n    susan_busy = susan_schedule.get(day, [])\n    sandra_busy = sandra_schedule.get(day, [])\n    all_busy = susan_busy + sandra_busy\n    all_busy.sort()\n    \n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_778"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Austin's constraints: no meetings on Tuesday\n    days_to_consider = [day for day in days if day != 'Tuesday']\n    \n    # Define existing schedules in minutes since midnight\n    austin_schedule = {\n        'Monday': [(10 * 60 + 30, 11 * 60), (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60)],\n        'Wednesday': [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 11 * 60), (12 * 60, 12 * 60 + 30),\n                      (14 * 60, 14 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)]\n    }\n    \n    madison_schedule = {\n        'Monday': [(9 * 60, 12 * 60 + 30), (13 * 60 + 30, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Wednesday': [(10 * 60 + 30, 11 * 60), (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 15 * 60)]\n    }\n    \n    # Iterate through each day to find the earliest available slot\n    for day in days_to_consider:\n        # Collect all busy intervals for both participants\n        austin_busy = austin_schedule.get(day, [])\n        madison_busy = madison_schedule.get(day, [])\n        \n        # Combine and sort all busy intervals\n        all_busy = austin_busy + madison_busy\n        all_busy.sort()\n        \n        # Merge overlapping or adjacent intervals\n        merged_busy = []\n        for start, end in all_busy:\n            if not merged_busy:\n                merged_busy.append((start, end))\n            else:\n                last_start, last_end = merged_busy[-1]\n                if start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged_busy[-1] = (new_start, new_end)\n                else:\n                    merged_busy.append((start, end))\n        \n        # Check the available slots before the first busy interval, between intervals, and after last\n        prev_end = work_start\n        for start, end in merged_busy:\n            if start > prev_end:\n                # Found a free slot\n                free_start = prev_end\n                free_end = start\n                if free_end - free_start >= 30:  # Meeting duration is 30 minutes\n                    # Format the time as HH:MM:HH:MM\n                    return f\"{free_start // 60:02d}:{free_start % 60:02d}:{free_start // 60 + (free_start % 60 + 30) // 60:02d}:{(free_start % 60 + 30) % 60:02d}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after the last busy interval\n        if work_end - prev_end >= 30:\n            return f\"{prev_end // 60:02d}:{prev_end % 60:02d}:{prev_end // 60 + (prev_end % 60 + 30) // 60:02d}:{(prev_end % 60 + 30) % 60:02d}\"\n    \n    return \"No available time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_779"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define busy slots for each person per day in minutes since midnight\n    logan_busy = {\n        'Monday': [(14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60)],\n        'Tuesday': [(11 * 60 + 30, 12 * 60)],\n        'Wednesday': [(16 * 60, 16 * 60 + 30)]\n    }\n    \n    lori_busy = {\n        'Monday': [(9 * 60, 11 * 60 + 30), (12 * 60, 13 * 60), (13 * 60 + 30, 14 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 13 * 60), (13 * 60 + 30, 14 * 60 + 30), (15 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 12 * 60 + 30), (14 * 60, 15 * 60), (15 * 60 + 30, 17 * 60)]\n    }\n    \n    # Lori cannot meet on Monday\n    available_days = ['Tuesday', 'Wednesday']\n    \n    meeting_duration = 30  # minutes\n    \n    for day in available_days:\n        # Collect all busy slots for both participants\n        busy_slots = []\n        if day in logan_busy:\n            busy_slots.extend(logan_busy[day])\n        if day in lori_busy:\n            busy_slots.extend(lori_busy[day])\n        \n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Find free slots by checking gaps between busy slots and work hours\n        prev_end = work_start\n        free_slots = []\n        \n        for start, end in busy_slots:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy slot\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= meeting_duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_780"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define participants' busy times in minutes since midnight\n    amy_busy = {\n        'Monday': [\n            (11 * 60 + 30, 12 * 60 + 30),\n            (13 * 60 + 30, 14 * 60),\n            (14 * 60 + 30, 15 * 60),\n            (16 * 60 + 30, 17 * 60)\n        ],\n        'Tuesday': [\n            (10 * 60 + 30, 11 * 60),\n            (12 * 60 + 30, 13 * 60),\n            (13 * 60 + 30, 14 * 60),\n            (15 * 60 + 30, 17 * 60)\n        ],\n        'Wednesday': [\n            (11 * 60 + 30, 12 * 60),\n            (15 * 60, 15 * 60 + 30),\n            (16 * 60, 16 * 60 + 30)\n        ]\n    }\n    \n    kevin_busy = {\n        'Monday': [\n            (9 * 60, 11 * 60),\n            (11 * 60 + 30, 17 * 60)\n        ],\n        'Tuesday': [\n            (9 * 60, 10 * 60 + 30),\n            (11 * 60, 16 * 60 + 30)\n        ],\n        'Wednesday': [\n            (9 * 60, 9 * 60 + 30),\n            (10 * 60, 17 * 60)\n        ]\n    }\n    \n    meeting_duration = 30  # minutes\n    \n    # Prefer Tuesday or Wednesday since Amy wants to avoid Monday\n    preferred_days_order = ['Tuesday', 'Wednesday', 'Monday']\n    \n    for day in preferred_days_order:\n        # Collect all busy intervals for both participants on this day\n        busy_intervals = amy_busy.get(day, []) + kevin_busy.get(day, [])\n        busy_intervals.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in busy_intervals:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            available_start = slot_start\n            available_end = slot_end - meeting_duration\n            \n            if available_start <= available_end:\n                # Found a suitable time\n                start_time = available_start\n                end_time = start_time + meeting_duration\n                \n                # Format the time as HH:MM:HH:MM\n                start_hh = start_time // 60\n                start_mm = start_time % 60\n                end_hh = end_time // 60\n                end_mm = end_time % 60\n                \n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_781"
        },
        {
            "final_program_time": "{13:30:14:30}",
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to consider\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define Denise's busy times in minutes since midnight for each day\n    denise_busy = {\n        'Monday': [(13 * 60, 13 * 60 + 30), (15 * 60, 15 * 60 + 30)],\n        'Tuesday': [(10 * 60, 10 * 60 + 30)],\n        'Wednesday': [(11 * 60 + 30, 12 * 60)],\n    }\n    \n    # Define Deborah's busy times in minutes since midnight for each day\n    deborah_busy = {\n        'Monday': [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 12 * 60), (12 * 60 + 30, 15 * 60)],\n        'Tuesday': [(9 * 60, 13 * 60 + 30), (14 * 60 + 30, 17 * 60)],\n        'Wednesday': [(9 * 60, 10 * 60), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60 + 30), \n                     (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60)],\n    }\n    \n    # Deborah's preferences: avoid Monday and Wednesday\n    preferred_days = ['Tuesday']\n    \n    # Meeting duration in minutes\n    duration = 60\n    \n    # Iterate over preferred days first, then others\n    for day in preferred_days + [d for d in days if d not in preferred_days]:\n        # Get busy times for both participants on this day\n        busy_denise = denise_busy.get(day, [])\n        busy_deborah = deborah_busy.get(day, [])\n        \n        # Combine and sort all busy intervals\n        all_busy = busy_denise + busy_deborah\n        all_busy.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            available_start = slot_start\n            available_end = slot_end\n            \n            if available_end - available_start >= duration:\n                # Convert back to HH:MM format\n                start_hh = available_start // 60\n                start_mm = available_start % 60\n                end_hh = (available_start + duration) // 60\n                end_mm = (available_start + duration) % 60\n                \n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_782"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday']\n\n    # Danielle's schedule: {day: [(start1, end1), (start2, end2), ...]}\n    danielle_schedule = {\n        'Monday': [(11*60, 11*60+30), (12*60, 12*60+30), (15*60, 16*60)],\n        'Tuesday': [(9*60, 9*60+30), (12*60+30, 13*60), (15*60, 15*60+30), (16*60, 16*60+30)],\n        'Wednesday': [(9*60, 9*60+30), (10*60+30, 11*60+30), (12*60, 12*60+30), \n                      (13*60+30, 14*60), (14*60+30, 15*60+30), (16*60, 16*60+30)]\n    }\n\n    # Barbara's schedule\n    barbara_schedule = {\n        'Monday': [(9*60, 9*60+30), (10*60, 11*60), (11*60+30, 12*60), (12*60+30, 13*60), (15*60, 17*60)],\n        'Tuesday': [(10*60, 10*60+30), (11*60, 13*60), (13*60+30, 15*60+30), (16*60, 17*60)],\n        'Wednesday': [(10*60+30, 11*60), (11*60+30, 12*60), (12*60+30, 13*60), \n                      (13*60+30, 14*60), (15*60, 15*60+30), (16*60, 16*60+30)]\n    }\n\n    # Preferences\n    danielle_avoid_wed_before = 16 * 60 + 30  # 16:30\n    barbara_avoid_days = ['Monday', 'Tuesday']\n\n    # Iterate through days to find a suitable time\n    for day in days:\n        if day in barbara_avoid_days:\n            continue  # Barbara prefers not to meet on Monday or Tuesday\n\n        # Combine and sort all busy times for both participants\n        busy_times = []\n        # Add Danielle's meetings\n        for meeting in danielle_schedule.get(day, []):\n            busy_times.append(meeting)\n        # Add Barbara's meetings\n        for meeting in barbara_schedule.get(day, []):\n            busy_times.append(meeting)\n        # Sort by start time\n        busy_times.sort()\n\n        # Check the day's work hours for available slots\n        prev_end = work_start\n        for meeting in busy_times:\n            start, end = meeting\n            if start > prev_end:\n                # Check if the slot is long enough\n                if start - prev_end >= meeting_duration:\n                    # Check Danielle's Wednesday preference\n                    if day == 'Wednesday' and prev_end < danielle_avoid_wed_before:\n                        prev_end = end\n                        continue\n                    # Found a suitable slot\n                    slot_start = prev_end\n                    slot_end = slot_start + meeting_duration\n                    return f\"{int(slot_start//60):02d}:{int(slot_start%60):02d}:{int(slot_end//60):02d}:{int(slot_end%60):02d}\"\n            prev_end = max(prev_end, end)\n\n        # Check after the last meeting\n        if work_end - prev_end >= meeting_duration:\n            if day == 'Wednesday' and prev_end < danielle_avoid_wed_before:\n                continue\n            slot_start = prev_end\n            slot_end = slot_start + meeting_duration\n            return f\"{int(slot_start//60):02d}:{int(slot_start%60):02d}:{int(slot_end//60):02d}:{int(slot_end%60):02d}\"\n\n    return \"No suitable time found\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_783"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    meeting_duration = 60  # minutes\n    \n    # Define participants' schedules and preferences\n    judith_blocked = {\n        'Monday': [(12 * 60, 12 * 60 + 30)],  # 12:00-12:30\n        'Wednesday': [(11 * 60 + 30, 12 * 60)]  # 11:30-12:00\n    }\n    timothy_blocked = {\n        'Monday': [\n            (9 * 60 + 30, 10 * 60),       # 9:30-10:00\n            (10 * 60 + 30, 11 * 60 + 30),  # 10:30-11:30\n            (12 * 60 + 30, 14 * 60),       # 12:30-14:00\n            (15 * 60 + 30, 17 * 60)        # 15:30-17:00\n        ],\n        'Tuesday': [\n            (9 * 60 + 30, 13 * 60),        # 9:30-13:00\n            (13 * 60 + 30, 14 * 60),       # 13:30-14:00\n            (14 * 60 + 30, 17 * 60)        # 14:30-17:00\n        ],\n        'Wednesday': [\n            (9 * 60, 9 * 60 + 30),         # 9:00-9:30\n            (10 * 60 + 30, 11 * 60),       # 10:30-11:00\n            (13 * 60 + 30, 14 * 60 + 30),  # 13:30-14:30\n            (15 * 60, 15 * 60 + 30),       # 15:00-15:30\n            (16 * 60, 16 * 60 + 30)        # 16:00-16:30\n        ]\n    }\n    \n    # Judith's preferences: avoid Monday and Wednesday before 12:00\n    preferred_days = ['Tuesday', 'Wednesday']\n    \n    # Iterate through preferred days first\n    for day in preferred_days:\n        if day == 'Wednesday':\n            # On Wednesday, Judith wants to avoid before 12:00\n            start_time = max(work_start, 12 * 60)\n        else:\n            start_time = work_start\n        \n        # Generate all possible slots for the day\n        slots = []\n        current_time = start_time\n        blocked_times = []\n        \n        # Combine blocked times for both participants\n        judith_day = judith_blocked.get(day, [])\n        timothy_day = timothy_blocked.get(day, [])\n        all_blocked = sorted(judith_day + timothy_day, key=lambda x: x[0])\n        \n        # Find available slots\n        for block_start, block_end in all_blocked:\n            if current_time < block_start:\n                slots.append((current_time, block_start))\n            current_time = max(current_time, block_end)\n        if current_time < work_end:\n            slots.append((current_time, work_end))\n        \n        # Check each slot for availability\n        for slot_start, slot_end in slots:\n            if slot_end - slot_start >= meeting_duration:\n                # Found a suitable slot\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    # If no slot found in preferred days, check Monday (though Judith prefers to avoid)\n    day = 'Monday'\n    start_time = work_start\n    slots = []\n    current_time = start_time\n    blocked_times = []\n    \n    # Combine blocked times for both participants\n    judith_day = judith_blocked.get(day, [])\n    timothy_day = timothy_blocked.get(day, [])\n    all_blocked = sorted(judith_day + timothy_day, key=lambda x: x[0])\n    \n    # Find available slots\n    for block_start, block_end in all_blocked:\n        if current_time < block_start:\n            slots.append((current_time, block_start))\n        current_time = max(current_time, block_end)\n    if current_time < work_end:\n        slots.append((current_time, work_end))\n    \n    # Check each slot for availability\n    for slot_start, slot_end in slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Found a suitable slot\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_784"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(larry_schedule, philip_schedule, days, work_hours, duration):\n    start_hour, end_hour = work_hours\n    duration_minutes = duration * 30  # Since duration is given as half an hour\n    \n    for day in days:\n        # Initialize free slots for both participants for the day\n        larry_free = get_free_slots(larry_schedule.get(day, []), start_hour, end_hour)\n        philip_free = get_free_slots(philip_schedule.get(day, []), start_hour, end_hour)\n        \n        # Find overlapping free slots\n        for l_start, l_end in larry_free:\n            for p_start, p_end in philip_free:\n                # Find the overlap between the two slots\n                overlap_start = max(l_start, p_start)\n                overlap_end = min(l_end, p_end)\n                \n                if overlap_start < overlap_end and (overlap_end - overlap_start) >= duration_minutes:\n                    return f\"{day} {format_time(overlap_start)}:{format_time(overlap_start + duration_minutes)}\"\n    \n    return \"No suitable time found.\"\n\ndef get_free_slots(busy_slots, start_hour, end_hour):\n    # Convert busy slots to minutes from start of day\n    busy_minutes = []\n    for start, end in busy_slots:\n        start_min = time_to_minutes(start)\n        end_min = time_to_minutes(end)\n        busy_minutes.append((start_min, end_min))\n    \n    # Sort busy slots by start time\n    busy_minutes.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = time_to_minutes(start_hour)\n    \n    for start, end in busy_minutes:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    # Add the slot after last busy slot if any\n    if prev_end < time_to_minutes(end_hour):\n        free_slots.append((prev_end, time_to_minutes(end_hour)))\n    \n    return free_slots\n\ndef time_to_minutes(time_str):\n    hours, minutes = map(int, time_str.split(':'))\n    return hours * 60 + minutes\n\ndef format_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Define schedules\nlarry_schedule = {\n    'Monday': ['10:00-10:30', '11:30-12:00', '14:00-14:30'],\n    'Tuesday': ['9:30-10:30', '11:30-12:00', '13:30-14:00', '14:30-15:00', '16:30-17:00'],\n    'Wednesday': ['9:00-9:30', '11:00-11:30', '12:00-12:30', '13:30-16:30']\n}\n\nphilip_schedule = {\n    'Monday': ['9:30-11:30', '12:00-17:00'],\n    'Tuesday': ['9:30-10:30', '11:00-11:30', '12:00-13:30', '14:00-15:30', '16:00-16:30'],\n    'Wednesday': ['9:00-10:00', '12:00-12:30', '13:00-13:30', '15:00-15:30', '16:30-17:00']\n}\n\n# Convert schedules to consistent format\ndef parse_schedule(schedule):\n    parsed = {}\n    for day, slots in schedule.items():\n        parsed[day] = []\n        for slot in slots:\n            start, end = slot.split('-')\n            parsed[day].append((start, end))\n    return parsed\n\nlarry_parsed = parse_schedule(larry_schedule)\nphilip_parsed = parse_schedule(philip_schedule)\n\n# Parameters\ndays = ['Monday', 'Tuesday', 'Wednesday']\nwork_hours = ('9:00', '17:00')\nduration = 1  # in half-hour units (so 1 means 30 minutes)\n\n# Find meeting time\nmeeting_time = find_meeting_time(larry_parsed, philip_parsed, days, work_hours, duration)\nprint(meeting_time.split()[-1])\n```",
            "count": "calendar_scheduling_example_785"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    days = [\"Monday\", \"Tuesday\", \"Wednesday\"]\n    meeting_duration = timedelta(minutes=30)\n    \n    # Define busy slots for each participant per day\n    amy_busy = {\n        \"Monday\": [],\n        \"Tuesday\": [],\n        \"Wednesday\": [\n            (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n            (datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\"))\n        ]\n    }\n    \n    pamela_busy = {\n        \"Monday\": [\n            (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n            (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))\n        ],\n        \"Tuesday\": [\n            (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n            (datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))\n        ],\n        \"Wednesday\": [\n            (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n            (datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n            (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n            (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:00\", \"%H:%M\")),\n            (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))\n        ]\n    }\n    \n    # Pamela's preferences: avoid Monday, Tuesday, and Wednesday before 16:00\n    # So we prioritize Wednesday after 16:00\n    preferred_day = \"Wednesday\"\n    preferred_time = datetime.strptime(\"16:00\", \"%H:%M\")\n    \n    # Check preferred day and time first\n    if preferred_day in days:\n        # Generate slots after 16:00 on Wednesday\n        current_time = preferred_time\n        while current_time + meeting_duration <= work_end:\n            # Check if the slot is free for both\n            amy_free = True\n            for busy_start, busy_end in amy_busy[preferred_day]:\n                if not (current_time + meeting_duration <= busy_start or current_time >= busy_end):\n                    amy_free = False\n                    break\n            pamela_free = True\n            for busy_start, busy_end in pamela_busy[preferred_day]:\n                if not (current_time + meeting_duration <= busy_start or current_time >= busy_end):\n                    pamela_free = False\n                    break\n            if amy_free and pamela_free:\n                return f\"{current_time.strftime('%H:%M')}:{(current_time + meeting_duration).strftime('%H:%M')}\"\n            current_time += timedelta(minutes=15)  # Check in 15-minute increments\n    \n    # If preferred time doesn't work, check other days and times\n    for day in days:\n        current_time = work_start\n        while current_time + meeting_duration <= work_end:\n            # Skip if it's Monday or Tuesday (Pamela's preference)\n            if day in [\"Monday\", \"Tuesday\"]:\n                break\n            # Skip if it's Wednesday before 16:00 (Pamela's preference)\n            if day == \"Wednesday\" and current_time < datetime.strptime(\"16:00\", \"%H:%M\"):\n                current_time += timedelta(minutes=15)\n                continue\n            # Check if the slot is free for both\n            amy_free = True\n            for busy_start, busy_end in amy_busy[day]:\n                if not (current_time + meeting_duration <= busy_start or current_time >= busy_end):\n                    amy_free = False\n                    break\n            pamela_free = True\n            for busy_start, busy_end in pamela_busy[day]:\n                if not (current_time + meeting_duration <= busy_start or current_time >= busy_end):\n                    pamela_free = False\n                    break\n            if amy_free and pamela_free:\n                return f\"{current_time.strftime('%H:%M')}:{(current_time + meeting_duration).strftime('%H:%M')}\"\n            current_time += timedelta(minutes=15)\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_786"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:30:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Define busy slots for each person in minutes since midnight\n    arthur_busy = {\n        'Monday': [(9*60 + 30, 10*60), (10*60 + 30, 11*60 + 30), (12*60 + 30, 13*60), (13*60 + 30, 14*60)],\n        'Tuesday': [(10*60, 11*60 + 30), (16*60 + 30, 17*60)],\n        'Wednesday': [(9*60, 10*60), (11*60 + 30, 12*60), (13*60 + 30, 14*60), (14*60 + 30, 15*60 + 30), (16*60 + 30, 17*60)]\n    }\n\n    robert_busy = {\n        'Monday': [(9*60, 9*60 + 30), (12*60, 12*60 + 30), (14*60 + 30, 15*60), (15*60 + 30, 16*60 + 30)],\n        'Tuesday': [(9*60, 10*60 + 30), (11*60 + 30, 13*60), (13*60 + 30, 15*60 + 30), (16*60, 16*60 + 30)],\n        'Wednesday': [(9*60, 10*60 + 30), (11*60, 11*60 + 30), (12*60, 12*60 + 30), (13*60 + 30, 15*60)]\n    }\n\n    # Iterate through each day to find a suitable time\n    for day in days:\n        # Combine and sort all busy slots for both participants\n        combined_busy = arthur_busy.get(day, []) + robert_busy.get(day, [])\n        combined_busy.sort()\n\n        # Check available slots between work hours\n        prev_end = work_start\n        for start, end in combined_busy:\n            if start > prev_end:\n                available_start = prev_end\n                available_end = start\n                if available_end - available_start >= meeting_duration:\n                    # Check Robert's preference to avoid Wednesday before 14:00\n                    if day == 'Wednesday' and available_start < 14 * 60:\n                        continue\n                    # Return the first suitable time found\n                    return f\"{available_start//60:02d}:{available_start%60:02d}:{(available_start + meeting_duration)//60:02d}:{(available_start + meeting_duration)%60:02d}\"\n            prev_end = max(prev_end, end)\n\n        # Check after the last busy slot\n        if work_end - prev_end >= meeting_duration:\n            # Check Robert's preference to avoid Wednesday before 14:00\n            if day == 'Wednesday' and prev_end < 14 * 60:\n                continue\n            return f\"{prev_end//60:02d}:{prev_end%60:02d}:{(prev_end + meeting_duration)//60:02d}:{(prev_end + meeting_duration)%60:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_787"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday']\n\n    # Define the existing schedules for Kimberly and Diane\n    kimberly_schedule = {\n        'Monday': [(9.5 * 60, 10.5 * 60), (11 * 60, 11.5 * 60), (16 * 60, 16.5 * 60)],\n        'Tuesday': [(13.5 * 60, 14 * 60), (14.5 * 60, 15 * 60), (15.5 * 60, 16 * 60)],\n        'Wednesday': [(10 * 60, 10.5 * 60), (11.5 * 60, 12 * 60), (13 * 60, 14 * 60), (15 * 60, 15.5 * 60)]\n    }\n\n    diane_schedule = {\n        'Monday': [(9.5 * 60, 12 * 60), (12.5 * 60, 14.5 * 60), (15 * 60, 15.5 * 60)],\n        'Tuesday': [(9 * 60, 17 * 60)],  # Entire day blocked\n        'Wednesday': [(9 * 60, 17 * 60)]   # Entire day blocked\n    }\n\n    meeting_duration = 30  # minutes\n\n    # Iterate through each day to find the earliest available slot\n    for day in days:\n        # Get both schedules for the day\n        kimberly_busy = kimberly_schedule.get(day, [])\n        diane_busy = diane_schedule.get(day, [])\n\n        # Combine and sort all busy intervals for the day\n        all_busy = kimberly_busy + diane_busy\n        all_busy.sort()\n\n        # Check the time before the first busy interval\n        prev_end = work_start\n        for start, end in all_busy:\n            if start > prev_end:\n                available_start = prev_end\n                available_end = start\n                if available_end - available_start >= meeting_duration:\n                    # Found a suitable slot\n                    return f\"{int(available_start // 60):02d}:{int(available_start % 60):02d}:{int((available_start + meeting_duration) // 60):02d}:{int((available_start + meeting_duration) % 60):02d}\"\n            prev_end = max(prev_end, end)\n\n        # Check the time after the last busy interval\n        if prev_end < work_end:\n            available_start = prev_end\n            available_end = work_end\n            if available_end - available_start >= meeting_duration:\n                return f\"{int(available_start // 60):02d}:{int(available_start % 60):02d}:{int((available_start + meeting_duration) // 60):02d}:{int((available_start + meeting_duration) % 60):02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_788"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday']\n\n    # Brenda's schedule: list of (day, start, end) in minutes\n    brenda_blocked = [\n        ('Monday', 9 * 60 + 30, 10 * 60),\n        ('Tuesday', 9 * 60, 9 * 60 + 30),\n        ('Tuesday', 12 * 60 + 30, 13 * 60),\n        ('Wednesday', 9 * 60, 9 * 60 + 30),\n        ('Wednesday', 11 * 60, 11 * 60 + 30),\n        ('Wednesday', 12 * 60 + 30, 13 * 60),\n        ('Wednesday', 15 * 60 + 30, 16 * 60 + 30)\n    ]\n\n    # Bruce's schedule: list of (day, start, end) in minutes\n    bruce_blocked = [\n        ('Monday', 10 * 60, 10 * 60 + 30),\n        ('Monday', 11 * 60, 11 * 60 + 30),\n        ('Monday', 13 * 60, 15 * 60),\n        ('Monday', 15 * 60 + 30, 16 * 60 + 30),\n        ('Tuesday', 9 * 60, 17 * 60),\n        ('Wednesday', 9 * 60, 17 * 60)\n    ]\n\n    # Bruce's preference: not after 13:30 on Monday\n    bruce_preference = ('Monday', 13 * 60 + 30, 17 * 60)\n\n    # Iterate through each day\n    for day in days:\n        # Generate all possible slots for the day\n        slots = []\n        current_time = work_start\n        while current_time + meeting_duration <= work_end:\n            slots.append((current_time, current_time + meeting_duration))\n            current_time += meeting_duration\n\n        # Check each slot\n        for slot_start, slot_end in slots:\n            # Check if slot is within work hours\n            if slot_start < work_start or slot_end > work_end:\n                continue\n\n            # Check Brenda's availability\n            brenda_available = True\n            for blocked_day, blocked_start, blocked_end in brenda_blocked:\n                if blocked_day == day:\n                    if not (slot_end <= blocked_start or slot_start >= blocked_end):\n                        brenda_available = False\n                        break\n            if not brenda_available:\n                continue\n\n            # Check Bruce's availability\n            bruce_available = True\n            for blocked_day, blocked_start, blocked_end in bruce_blocked:\n                if blocked_day == day:\n                    if not (slot_end <= blocked_start or slot_start >= blocked_end):\n                        bruce_available = False\n                        break\n            if not bruce_available:\n                continue\n\n            # Check Bruce's preference (not after 13:30 on Monday)\n            if day == 'Monday':\n                pref_day, pref_start, pref_end = bruce_preference\n                if not (slot_end <= pref_start or slot_start >= pref_end):\n                    continue\n\n            # If all checks passed, return the slot\n            start_hour = slot_start // 60\n            start_min = slot_start % 60\n            end_hour = slot_end // 60\n            end_min = slot_end % 60\n            return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_789"
        },
        {
            "final_program_time": "{9:30:10:30}",
            "expected_time": "{9:30:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Barbara's schedule: day -> list of busy intervals in minutes\n    barbara_schedule = {\n        'Monday': [(9*60, 9*60 + 30), (10*60 + 30, 11*60 + 30), (12*60, 12*60 + 30),\n                   (13*60 + 30, 14*60 + 30), (15*60, 15*60 + 30)],\n        'Tuesday': [(9*60, 9*60 + 30), (10*60 + 30, 11*60 + 30), (12*60 + 30, 13*60),\n                    (13*60 + 30, 14*60), (15*60, 16*60)],\n        'Wednesday': [(9*60, 9*60 + 30), (10*60 + 30, 11*60), (11*60 + 30, 12*60),\n                      (12*60 + 30, 13*60), (13*60 + 30, 14*60), (16*60, 16*60 + 30)]\n    }\n    \n    # Jason's schedule: day -> list of busy intervals in minutes\n    jason_schedule = {\n        'Monday': [(10*60, 12*60), (12*60 + 30, 13*60), (13*60 + 30, 15*60 + 30),\n                   (16*60, 16*60 + 30)],\n        'Tuesday': [(9*60, 10*60 + 30), (11*60 + 30, 13*60), (13*60 + 30, 14*60),\n                    (14*60 + 30, 15*60)],\n        'Wednesday': [(11*60, 11*60 + 30), (12*60, 13*60), (13*60 + 30, 14*60 + 30),\n                      (15*60, 15*60 + 30), (16*60, 17*60)]\n    }\n    \n    meeting_duration = 60  # 1 hour in minutes\n    \n    # Iterate through days (excluding Tuesday if possible)\n    preferred_days = [day for day in days if day != 'Tuesday'] + ['Tuesday']\n    \n    for day in preferred_days:\n        # Collect all busy intervals for both participants\n        busy_intervals = barbara_schedule[day] + jason_schedule[day]\n        busy_intervals.sort()  # Sort by start time\n        \n        # Find free intervals by merging busy intervals\n        free_intervals = []\n        prev_end = work_hours_start\n        \n        for start, end in busy_intervals:\n            if start > prev_end:\n                free_intervals.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_hours_end:\n            free_intervals.append((prev_end, work_hours_end))\n        \n        # Check for a free interval that can fit the meeting\n        for start, end in free_intervals:\n            if end - start >= meeting_duration:\n                meeting_start = start\n                meeting_end = start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_790"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday']\n\n    # Nicole's busy times in minutes since start of day\n    nicole_busy = {\n        'Monday': [(9 * 60, 9 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60 + 30)],\n        'Tuesday': [(9 * 60, 9 * 60 + 30), (11 * 60 + 30, 13 * 60 + 30), (14 * 60 + 30, 15 * 60 + 30)],\n        'Wednesday': [(10 * 60, 11 * 60), (12 * 60 + 30, 15 * 60), (16 * 60, 17 * 60)]\n    }\n\n    # Ruth's busy times in minutes since start of day\n    ruth_busy = {\n        'Monday': [(9 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 10 * 60 + 30), (11 * 60, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), \n                      (13 * 60 + 30, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)]\n    }\n\n    # Ruth's preference: not after 13:30 on Wednesday\n    ruth_preference = 13 * 60 + 30\n\n    # Iterate through each day\n    for day in days:\n        if day == 'Wednesday':\n            # Adjust work_end for Wednesday based on Ruth's preference\n            current_work_end = min(work_end, ruth_preference)\n        else:\n            current_work_end = work_end\n\n        # Generate all possible slots for the day\n        slots = []\n        current_time = work_start\n        while current_time + meeting_duration <= current_work_end:\n            slots.append((current_time, current_time + meeting_duration))\n            current_time += meeting_duration\n\n        # Check each slot against Nicole and Ruth's schedules\n        for slot_start, slot_end in slots:\n            # Check Nicole's availability\n            nicole_available = True\n            for busy_start, busy_end in nicole_busy[day]:\n                if not (slot_end <= busy_start or slot_start >= busy_end):\n                    nicole_available = False\n                    break\n\n            # Check Ruth's availability\n            ruth_available = True\n            for busy_start, busy_end in ruth_busy[day]:\n                if not (slot_end <= busy_start or slot_start >= busy_end):\n                    ruth_available = False\n                    break\n\n            # If both are available, return the slot\n            if nicole_available and ruth_available:\n                # Convert minutes back to HH:MM format\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_hh = slot_end // 60\n                end_mm = slot_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_791"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{10:00:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Pamela's schedule: day -> list of (start, end) in minutes\n    pamela_schedule = {\n        'Monday': [\n            (9 * 60, 9 * 60 + 30),\n            (10 * 60, 10 * 60 + 30),\n            (12 * 60, 12 * 60 + 30),\n            (13 * 60 + 30, 14 * 60),\n            (15 * 60, 16 * 60)\n        ],\n        'Tuesday': [\n            (10 * 60, 11 * 60),\n            (13 * 60 + 30, 14 * 60),\n            (14 * 60 + 30, 15 * 60),\n            (16 * 60 + 30, 17 * 60)\n        ],\n        'Wednesday': [\n            (9 * 60, 10 * 60),\n            (11 * 60, 11 * 60 + 30),\n            (13 * 60, 14 * 60),\n            (15 * 60 + 30, 16 * 60),\n            (16 * 60 + 30, 17 * 60)\n        ]\n    }\n    \n    # Judith's schedule: day -> list of (start, end) in minutes\n    judith_schedule = {\n        'Monday': [\n            (9 * 60, 9 * 60 + 30),\n            (11 * 60, 11 * 60 + 30),\n            (12 * 60, 15 * 60 + 30),\n            (16 * 60 + 30, 17 * 60)\n        ],\n        'Tuesday': [\n            (9 * 60 + 30, 11 * 60),\n            (12 * 60, 12 * 60 + 30),\n            (15 * 60, 15 * 60 + 30)\n        ],\n        'Wednesday': [\n            (11 * 60, 13 * 60 + 30),\n            (14 * 60, 14 * 60 + 30),\n            (15 * 60, 15 * 60 + 30),\n            (16 * 60, 17 * 60)\n        ]\n    }\n    \n    # Pamela doesn't want to meet on Tuesday\n    days_to_check = [day for day in days if day != 'Tuesday']\n    \n    for day in days_to_check:\n        # Collect all busy times for both participants on this day\n        busy_times = pamela_schedule.get(day, []) + judith_schedule.get(day, [])\n        busy_times.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in busy_times:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check for a 1-hour slot\n        for start, end in free_slots:\n            if end - start >= 60:\n                meeting_start = start\n                meeting_end = meeting_start + 60\n                # Convert back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_792"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to consider\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define blocked times in minutes since midnight for each person and day\n    blocked = {\n        'Thomas': {\n            'Monday': [(9 * 60, 10 * 60 + 30), (11 * 60, 14 * 60), (14 * 60 + 30, 16 * 60 + 30)],\n            'Tuesday': [(11 * 60, 11 * 60 + 30), (14 * 60, 14 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n            'Wednesday': [(9 * 60 + 30, 10 * 60), (12 * 60, 12 * 60 + 30), (14 * 60, 15 * 60)],\n        },\n        'Stephen': {\n            'Monday': [(9 * 60, 10 * 60 + 30), (11 * 60, 12 * 60), (12 * 60 + 30, 15 * 60), (15 * 60 + 30, 17 * 60)],\n            'Tuesday': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (11 * 60, 11 * 60 + 30), (12 * 60, 17 * 60)],\n            'Wednesday': [(9 * 60, 17 * 60)],\n        },\n    }\n    \n    # Thomas's constraints: not Monday, not Tuesday before 11:00\n    preferred_days = ['Tuesday', 'Wednesday']\n    \n    meeting_duration = 30  # minutes\n    \n    # Iterate through preferred days\n    for day in preferred_days:\n        if day == 'Tuesday':\n            # On Tuesday, Thomas doesn't want to meet before 11:00\n            start_time = max(work_start, 11 * 60)\n        else:\n            start_time = work_start\n        \n        # Generate all possible slots for the day\n        slots = []\n        current_time = start_time\n        \n        # Collect all blocked times for both participants\n        thomas_blocked = blocked['Thomas'][day]\n        stephen_blocked = blocked['Stephen'][day]\n        all_blocked = thomas_blocked + stephen_blocked\n        all_blocked.sort()  # Sort by start time\n        \n        # Find free slots\n        for block_start, block_end in all_blocked:\n            if current_time < block_start:\n                slots.append((current_time, block_start))\n            current_time = max(current_time, block_end)\n        if current_time < work_end:\n            slots.append((current_time, work_end))\n        \n        # Check each slot for availability\n        for slot_start, slot_end in slots:\n            if slot_end - slot_start >= meeting_duration:\n                # Found a suitable slot\n                start_hour = slot_start // 60\n                start_min = slot_start % 60\n                end_hour = (slot_start + meeting_duration) // 60\n                end_min = (slot_start + meeting_duration) % 60\n                return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_793"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Jesse's blocked times in minutes (converted from HH:MM)\n    jesse_blocked = {\n        'Monday': [(11 * 60 + 30, 13 * 60), (13 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60), (13 * 60 + 30, 14 * 60), (15 * 60, 16 * 60 + 30)],\n        'Wednesday': [(9 * 60, 10 * 60), (10 * 60 + 30, 13 * 60 + 30), (14 * 60 + 30, 17 * 60)],\n    }\n\n    # Days to consider (Monday, Tuesday, Wednesday)\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Apply preferences: Denise doesn't want Monday, Jesse can't do Wednesday\n    possible_days = [day for day in days if day != 'Monday' and day != 'Wednesday']\n    # Only Tuesday remains after preferences\n    \n    for day in possible_days:\n        # Get Jesse's blocked times for the day\n        blocked = jesse_blocked.get(day, [])\n        # Sort blocked intervals\n        blocked.sort()\n        \n        # Check time before first blocked interval\n        if blocked:\n            first_block_start = blocked[0][0]\n            available_start = work_start\n            available_end = first_block_start\n            if available_end - available_start >= meeting_duration:\n                return f\"{minutes_to_time(available_start)}:{minutes_to_time(available_start + meeting_duration)}\"\n        \n        # Check times between blocked intervals\n        for i in range(len(blocked) - 1):\n            current_block_end = blocked[i][1]\n            next_block_start = blocked[i + 1][0]\n            if next_block_start - current_block_end >= meeting_duration:\n                return f\"{minutes_to_time(current_block_end)}:{minutes_to_time(current_block_end + meeting_duration)}\"\n        \n        # Check time after last blocked interval\n        if blocked:\n            last_block_end = blocked[-1][1]\n            if work_end - last_block_end >= meeting_duration:\n                return f\"{minutes_to_time(last_block_end)}:{minutes_to_time(last_block_end + meeting_duration)}\"\n        else:\n            # No blocked times, schedule at work_start\n            return f\"{minutes_to_time(work_start)}:{minutes_to_time(work_start + meeting_duration)}\"\n\n    return \"No time found\"\n\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_794"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define busy slots for Walter and Janice in minutes since midnight\n    walter_busy = {\n        'Tuesday': [(9 * 60 + 30, 11 * 60), (12 * 60, 12 * 60 + 30), (14 * 60, 14 * 60 + 30)],\n        'Wednesday': [(11 * 60 + 30, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30), (15 * 60, 15 * 60 + 30)]\n    }\n    \n    janice_busy = {\n        'Monday': [(9 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60), (16 * 60, 17 * 60)],\n        'Tuesday': [(10 * 60, 10 * 60 + 30), (11 * 60, 12 * 60), (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60 + 30)],\n        'Wednesday': [(11 * 60, 12 * 60), (13 * 60 + 30, 14 * 60 + 30), (16 * 60, 16 * 60 + 30)]\n    }\n    \n    # Check each day in order\n    for day in days:\n        # Collect all busy slots for both participants on this day\n        busy_slots = []\n        \n        # Add Walter's busy slots\n        if day in walter_busy:\n            busy_slots.extend(walter_busy[day])\n        \n        # Add Janice's busy slots\n        if day in janice_busy:\n            busy_slots.extend(janice_busy[day])\n        \n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Find available slots\n        available_slots = []\n        prev_end = work_start\n        \n        for start, end in busy_slots:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy slot\n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n        \n        # Check each available slot for a 1-hour (60-minute) window\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= 60:\n                meeting_start = slot_start\n                meeting_end = meeting_start + 60\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_795"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    meeting_duration = 60  # minutes\n\n    # Define busy slots for Michelle and Joshua in minutes since midnight\n    michelle_busy = {\n        'Monday': [(9 * 60 + 30, 10 * 60), (11 * 60 + 30, 12 * 60), (13 * 60, 14 * 60), (14 * 60 + 30, 15 * 60)],\n        'Tuesday': [(11 * 60, 11 * 60 + 30), (12 * 60, 13 * 60), (13 * 60 + 30, 14 * 60), (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Wednesday': [(13 * 60, 14 * 60), (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60)]\n    }\n    \n    joshua_busy = {\n        'Monday': [(9 * 60, 13 * 60), (13 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60, 12 * 60 + 30), (13 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 10 * 60 + 30), (11 * 60 + 30, 13 * 60 + 30), (14 * 60 + 30, 16 * 60 + 30)]\n    }\n\n    for day in days:\n        # Collect all busy slots for both participants\n        busy_slots = michelle_busy.get(day, []) + joshua_busy.get(day, [])\n        busy_slots.sort()\n\n        # Find free slots\n        prev_end = work_start\n        free_slots = []\n        for start, end in busy_slots:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n\n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            available_start = slot_start\n            available_end = slot_end\n            if available_end - available_start >= meeting_duration:\n                # Convert back to HH:MM format\n                start_hh = available_start // 60\n                start_mm = available_start % 60\n                end_hh = (available_start + meeting_duration) // 60\n                end_mm = (available_start + meeting_duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_796"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Margaret's and Tyler's blocked times in minutes for Tuesday and Wednesday\n    # Monday is excluded as Tyler can't meet on Monday\n    margaret_blocked = {\n        'Tuesday': [(11 * 60, 11 * 60 + 30), (15 * 60 + 30, 16 * 60 + 30)],\n        'Wednesday': [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 11 * 60)]\n    }\n    \n    tyler_blocked = {\n        'Tuesday': [\n            (9 * 60, 9 * 60 + 30), (10 * 60, 11 * 60), (11 * 60 + 30, 12 * 60),\n            (13 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30), (15 * 60, 15 * 60 + 30),\n            (16 * 60 + 30, 17 * 60)\n        ],\n        'Wednesday': [(10 * 60, 12 * 60 + 30), (14 * 60, 15 * 60)]\n    }\n    \n    days = ['Tuesday', 'Wednesday']\n    meeting_duration = 60  # 1 hour in minutes\n    \n    for day in days:\n        # Collect all blocked times for both participants\n        blocked = []\n        # Add Margaret's blocked times\n        blocked.extend(margaret_blocked.get(day, []))\n        # Add Tyler's blocked times\n        blocked.extend(tyler_blocked.get(day, []))\n        \n        # Sort blocked times by start time\n        blocked.sort()\n        \n        # Find available slots\n        prev_end = work_start\n        for start, end in blocked:\n            if start > prev_end:\n                available_start = prev_end\n                available_end = start\n                if available_end - available_start >= meeting_duration:\n                    # Convert back to HH:MM format\n                    start_hh = available_start // 60\n                    start_mm = available_start % 60\n                    end_hh = (available_start + meeting_duration) // 60\n                    end_mm = (available_start + meeting_duration) % 60\n                    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after last blocked time\n        if work_end - prev_end >= meeting_duration:\n            start_hh = prev_end // 60\n            start_mm = prev_end % 60\n            end_hh = (prev_end + meeting_duration) // 60\n            end_mm = (prev_end + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_797"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    meeting_duration = 30  # minutes\n\n    # Nancy's schedule: each entry is (day, start, end) in minutes from midnight\n    nancy_schedule = [\n        ('Monday', 10*60, 10*60+30),\n        ('Monday', 11*60+30, 12*60+30),\n        ('Monday', 13*60+30, 14*60),\n        ('Monday', 14*60+30, 15*60+30),\n        ('Monday', 16*60, 17*60),\n        ('Tuesday', 9*60+30, 10*60+30),\n        ('Tuesday', 11*60, 11*60+30),\n        ('Tuesday', 12*60, 12*60+30),\n        ('Tuesday', 13*60, 13*60+30),\n        ('Tuesday', 15*60+30, 16*60),\n        ('Wednesday', 10*60, 11*60+30),\n        ('Wednesday', 13*60+30, 16*60)\n    ]\n\n    # Jose's schedule\n    jose_schedule = [\n        ('Monday', 9*60, 17*60),\n        ('Tuesday', 9*60, 17*60),\n        ('Wednesday', 9*60, 9*60+30),\n        ('Wednesday', 10*60, 12*60+30),\n        ('Wednesday', 13*60+30, 14*60+30),\n        ('Wednesday', 15*60, 17*60)\n    ]\n\n    # Convert schedules to blocked times per day\n    def get_blocked_times(schedule):\n        blocked = {day: [] for day in days}\n        for day, start, end in schedule:\n            blocked[day].append((start, end))\n        # Sort each day's blocks by start time\n        for day in blocked:\n            blocked[day].sort()\n        return blocked\n\n    nancy_blocked = get_blocked_times(nancy_schedule)\n    jose_blocked = get_blocked_times(jose_schedule)\n\n    # Find available slots for each day\n    for day in days:\n        # Get all blocked times for both participants\n        all_blocked = nancy_blocked[day] + jose_blocked[day]\n        all_blocked.sort()\n\n        # Merge overlapping or adjacent blocked times\n        merged = []\n        for start, end in all_blocked:\n            if not merged:\n                merged.append((start, end))\n            else:\n                last_start, last_end = merged[-1]\n                if start <= last_end:\n                    # Overlapping or adjacent, merge\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged[-1] = (new_start, new_end)\n                else:\n                    merged.append((start, end))\n\n        # Find available slots before first block, between blocks, and after last block\n        available = []\n        prev_end = work_hours_start\n        for start, end in merged:\n            if start > prev_end:\n                available.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_hours_end:\n            available.append((prev_end, work_hours_end))\n\n        # Check each available slot for sufficient duration\n        for start, end in available:\n            if end - start >= meeting_duration:\n                # Found earliest available slot\n                meeting_start = start\n                meeting_end = meeting_start + meeting_duration\n                # Convert back to HH:MM format\n                def minutes_to_time(minutes):\n                    h = minutes // 60\n                    m = minutes % 60\n                    return f\"{h:02d}:{m:02d}\"\n                return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No available time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_798"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday']\n\n    # Albert's busy times in minutes since start of day\n    albert_busy = {\n        'Monday': [],\n        'Tuesday': [(9 * 60, 9 * 60 + 30), (12 * 60 + 30, 13 * 60)],\n        'Wednesday': [(14 * 60, 15 * 60)]\n    }\n\n    # Marie's busy times in minutes since start of day\n    marie_busy = {\n        'Monday': [(9 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60, 10 * 60), (10 * 60 + 30, 17 * 60)],\n        'Wednesday': [(9 * 60, 17 * 60)]\n    }\n\n    # Albert cannot meet on Tuesday\n    albert_busy['Tuesday'] = [(0, 24 * 60)]  # Block entire day\n\n    # Iterate through each day to find a suitable time\n    for day in days:\n        # Collect all busy intervals for both participants\n        busy_intervals = albert_busy[day] + marie_busy[day]\n        busy_intervals.sort()  # Sort by start time\n\n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n\n        for start, end in busy_intervals:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n\n        # Check after last busy interval\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n\n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= meeting_duration:\n                # Found a suitable slot\n                start_time = slot_start\n                end_time = start_time + meeting_duration\n                # Format as HH:MM:HH:MM\n                return f\"{start_time // 60:02d}:{start_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_799"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Define participants' busy times in minutes since midnight\n    joshua_busy = {\n        'Monday': [(11 * 60, 11 * 60 + 30), (13 * 60, 13 * 60 + 30), (15 * 60 + 30, 16 * 60)],\n        'Tuesday': [(12 * 60 + 30, 13 * 60 + 30)],\n        'Wednesday': [(12 * 60 + 30, 13 * 60)],\n        'Thursday': [(11 * 60 + 30, 12 * 60), (15 * 60, 15 * 60 + 30)]\n    }\n    \n    donald_busy = {\n        'Monday': [(9 * 60, 9 * 60 + 30), (10 * 60, 11 * 60 + 30), (12 * 60, 13 * 60), (13 * 60 + 30, 14 * 60), (15 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 10 * 60 + 30), (12 * 60 + 30, 14 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n        'Wednesday': [(10 * 60 + 30, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (14 * 60, 14 * 60 + 30), (15 * 60 + 30, 16 * 60)],\n        'Thursday': [(9 * 60, 9 * 60 + 30), (10 * 60, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (13 * 60, 14 * 60), (15 * 60 + 30, 17 * 60)]\n    }\n    \n    # Apply constraints\n    # Joshua doesn't want to meet on Tuesday before 13:00\n    joshua_busy['Tuesday'].append((9 * 60, 13 * 60))\n    \n    # Donald cannot meet on Monday and Thursday\n    days_to_consider = [day for day in days if day not in ['Monday', 'Thursday']]\n    \n    # Check each remaining day for available slots\n    for day in days_to_consider:\n        # Combine and sort busy times for both participants\n        busy_times = joshua_busy.get(day, []) + donald_busy.get(day, [])\n        busy_times.sort()\n        \n        # Find free slots\n        prev_end = work_hours_start\n        free_slots = []\n        \n        for start, end in busy_times:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_hours_end:\n            free_slots.append((prev_end, work_hours_end))\n        \n        # Check for a 30-minute slot\n        for start, end in free_slots:\n            if end - start >= 30:\n                meeting_start = start\n                meeting_end = meeting_start + 30\n                # Convert back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_800"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(sarah_busy, peter_busy, days, work_hours, duration):\n    # Convert work hours to minutes for easier calculation\n    work_start, work_end = work_hours\n    work_start_min = int(work_start.split(':')[0]) * 60 + int(work_start.split(':')[1])\n    work_end_min = int(work_end.split(':')[0]) * 60 + int(work_end.split(':')[1])\n    \n    # Iterate through each day\n    for day in days:\n        # Initialize free time for both participants\n        sarah_free = []\n        peter_free = []\n        \n        # Generate Sarah's free slots for the day\n        sarah_day_busy = sarah_busy.get(day, [])\n        sarah_day_busy.sort()\n        prev_end = work_start_min\n        for slot in sarah_day_busy:\n            start, end = slot\n            start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n            end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n            if start_min > prev_end:\n                sarah_free.append((prev_end, start_min))\n            prev_end = max(prev_end, end_min)\n        if prev_end < work_end_min:\n            sarah_free.append((prev_end, work_end_min))\n        \n        # Generate Peter's free slots for the day\n        peter_day_busy = peter_busy.get(day, [])\n        peter_day_busy.sort()\n        prev_end = work_start_min\n        for slot in peter_day_busy:\n            start, end = slot\n            start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n            end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n            if start_min > prev_end:\n                peter_free.append((prev_end, start_min))\n            prev_end = max(prev_end, end_min)\n        if prev_end < work_end_min:\n            peter_free.append((prev_end, work_end_min))\n        \n        # Find overlapping free slots\n        for s_slot in sarah_free:\n            for p_slot in peter_free:\n                overlap_start = max(s_slot[0], p_slot[0])\n                overlap_end = min(s_slot[1], p_slot[1])\n                if overlap_end - overlap_start >= duration:\n                    # Convert back to HH:MM format\n                    start_hh = overlap_start // 60\n                    start_mm = overlap_start % 60\n                    end_hh = (overlap_start + duration) // 60\n                    end_mm = (overlap_start + duration) % 60\n                    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No suitable time found\"\n\n# Define the busy slots for Sarah and Peter\nsarah_busy = {\n    'Monday': [('9:30', '10:00'), ('10:30', '11:00'), ('12:00', '14:00'), ('15:00', '17:00')],\n    'Tuesday': [('13:00', '13:30'), ('14:00', '14:30'), ('15:00', '15:30'), ('16:00', '17:00')],\n    'Wednesday': [('9:00', '10:30'), ('11:00', '11:30'), ('12:30', '13:00'), ('13:30', '14:30'), ('15:00', '16:00'), ('16:30', '17:00')],\n    'Thursday': [('9:00', '9:30'), ('13:00', '13:30'), ('15:00', '16:30')]\n}\n\npeter_busy = {\n    'Monday': [('9:00', '10:00'), ('11:00', '12:00'), ('13:00', '13:30'), ('14:00', '16:30')],\n    'Tuesday': [('9:00', '9:30'), ('10:30', '11:30'), ('13:00', '13:30'), ('14:00', '15:00'), ('16:30', '17:00')],\n    'Wednesday': [('10:00', '10:30'), ('11:30', '12:00'), ('13:30', '14:00'), ('14:30', '15:00'), ('16:00', '16:30')],\n    'Thursday': [('9:00', '14:00'), ('14:30', '15:00'), ('15:30', '17:00')]\n}\n\n# Define the days to check and work hours\ndays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\nwork_hours = ('9:00', '17:00')\nduration = 30  # minutes\n\n# Find the earliest meeting time\nmeeting_time = find_meeting_time(sarah_busy, peter_busy, days, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_801"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\"]\n    \n    # Define blocked times for each participant per day\n    blocked_times = {\n        \"Abigail\": {\n            \"Monday\": [\"09:00-09:30\", \"11:00-11:30\", \"15:30-16:00\"],\n            \"Wednesday\": [\"09:30-10:00\", \"10:30-11:00\"],\n            \"Thursday\": [\"09:00-09:30\", \"12:30-13:30\"],\n        },\n        \"Charlotte\": {\n            \"Monday\": [\"09:30-10:00\", \"10:30-11:00\", \"13:00-13:30\", \"15:00-17:00\"],\n            \"Tuesday\": [\"10:30-12:00\", \"12:30-13:30\", \"14:30-15:00\", \"16:30-17:00\"],\n            \"Wednesday\": [\"09:00-09:30\", \"10:00-11:30\", \"12:00-13:30\", \"14:00-15:30\", \"16:30-17:00\"],\n            \"Thursday\": [\"09:00-12:00\", \"14:00-14:30\", \"16:00-17:00\"],\n        }\n    }\n    \n    # Preferences: Abigail avoids Tuesday, Charlotte avoids Monday\n    preferred_days = [\"Wednesday\", \"Thursday\"]\n    \n    # Iterate through preferred days first, then others except Monday and Tuesday\n    for day in preferred_days + [\"Monday\", \"Tuesday\"]:\n        if day == \"Monday\" and \"Monday\" not in preferred_days:\n            continue\n        if day == \"Tuesday\" and \"Tuesday\" not in preferred_days:\n            continue\n        \n        # Collect all blocked times for the day\n        abigail_blocks = blocked_times[\"Abigail\"].get(day, [])\n        charlotte_blocks = blocked_times[\"Charlotte\"].get(day, [])\n        \n        # Convert blocked times to datetime ranges\n        blocked_ranges = []\n        for block in abigail_blocks + charlotte_blocks:\n            start, end = block.split(\"-\")\n            start_time = datetime.strptime(start, \"%H:%M\")\n            end_time = datetime.strptime(end, \"%H:%M\")\n            blocked_ranges.append((start_time, end_time))\n        \n        # Sort blocked ranges by start time\n        blocked_ranges.sort()\n        \n        # Check for available slots\n        current_time = work_start\n        for block_start, block_end in blocked_ranges:\n            if current_time < block_start:\n                # Check if there's enough time before the next block\n                available_duration = (block_start - current_time).total_seconds() / 60\n                if available_duration >= 30:\n                    # Found a suitable slot\n                    end_time = current_time + timedelta(minutes=30)\n                    return f\"{current_time.strftime('%H:%M')}:{end_time.strftime('%H:%M')}\"\n            # Update current_time to the end of the block\n            if block_end > current_time:\n                current_time = block_end\n        \n        # Check after the last block\n        if current_time + timedelta(minutes=30) <= work_end:\n            end_time = current_time + timedelta(minutes=30)\n            return f\"{current_time.strftime('%H:%M')}:{end_time.strftime('%H:%M')}\"\n    \n    return \"No suitable time found\"\n\n# Execute and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_802"
        },
        {
            "final_program_time": "{13:30:14:30}",
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to consider\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Elijah's schedule: day -> list of busy intervals in minutes\n    elijah_busy = {\n        'Monday': [(9*60, 9*60 + 30), (11*60 + 30, 12*60), (15*60 + 30, 16*60 + 30)],\n        'Tuesday': [(13*60, 13*60 + 30), (15*60 + 30, 16*60)],\n        'Wednesday': [(10*60 + 30, 11*60 + 30), (14*60, 14*60 + 30), (15*60, 15*60 + 30), (16*60, 16*60 + 30)],\n        'Thursday': [(11*60, 11*60 + 30), (13*60 + 30, 14*60), (14*60 + 30, 15*60)]\n    }\n    \n    # Gary's schedule: day -> list of busy intervals in minutes\n    gary_busy = {\n        'Monday': [(12*60, 12*60 + 30), (13*60, 13*60 + 30), (14*60 + 30, 15*60 + 30), (16*60, 16*60 + 30)],\n        'Tuesday': [(10*60 + 30, 11*60), (12*60, 13*60 + 30), (14*60, 15*60), (15*60 + 30, 17*60)],\n        'Wednesday': [(9*60 + 30, 10*60), (11*60 + 30, 15*60), (15*60 + 30, 16*60), (16*60 + 30, 17*60)],\n        'Thursday': [(9*60, 9*60 + 30), (10*60, 12*60 + 30), (14*60, 15*60 + 30), (16*60, 16*60 + 30)]\n    }\n    \n    # Constraints\n    elijah_no_tuesday = True  # Elijah cannot meet on Tuesday\n    gary_no_monday_before_1130 = True  # Gary doesn't want to meet on Monday before 11:30\n    \n    meeting_duration = 60  # 1 hour\n    \n    # Iterate through each day to find a suitable time\n    for day in days:\n        if day == 'Tuesday' and elijah_no_tuesday:\n            continue\n        \n        # Get busy intervals for both participants\n        e_busy = elijah_busy.get(day, [])\n        g_busy = gary_busy.get(day, [])\n        \n        # Combine and sort all busy intervals\n        all_busy = e_busy + g_busy\n        all_busy.sort()\n        \n        # Generate available slots\n        available_slots = []\n        prev_end = work_start\n        \n        # Handle Gary's constraint on Monday before 11:30\n        if day == 'Monday' and gary_no_monday_before_1130:\n            prev_end = max(prev_end, 11*60 + 30)\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n        \n        # Check each available slot for a duration of meeting_duration\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= meeting_duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_803"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to consider based on constraints\n    days = {\n        \"Monday\": {\"Natalie\": [(11 * 60, 11 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n                   \"Stephen\": [(9 * 60, 9 * 60 + 30), (11 * 60, 13 * 60 + 30), (14 * 60, 15 * 60), (15 * 60 + 30, 16 * 60)]},\n        \"Tuesday\": {\"Natalie\": [(10 * 60, 10 * 60 + 30), (15 * 60, 15 * 60 + 30)],\n                    \"Stephen\": [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60 + 30), (12 * 60 + 30, 14 * 60)]},\n        \"Wednesday\": {\"Natalie\": [(10 * 60, 10 * 60 + 30), (11 * 60, 11 * 60 + 30), (13 * 60 + 30, 14 * 60), (15 * 60, 15 * 60 + 30)],\n                      \"Stephen\": [(9 * 60, 9 * 60 + 30), (10 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60 + 30)]},\n        \"Thursday\": {\"Natalie\": [(11 * 60 + 30, 12 * 60), (15 * 60 + 30, 16 * 60)],\n                     \"Stephen\": [(9 * 60 + 30, 10 * 60), (13 * 60 + 30, 15 * 60), (16 * 60, 17 * 60)]}\n    }\n    \n    # Apply constraints: Natalie can't meet on Thursday, Stephen avoids Monday and Tuesday after 12:30, Wednesday is avoided\n    days_to_check = [\"Tuesday\"]  # Only Tuesday is left after constraints\n    \n    for day in days_to_check:\n        # Get busy intervals for both participants\n        natalie_busy = days[day][\"Natalie\"]\n        stephen_busy = days[day][\"Stephen\"]\n        \n        # Combine and sort all busy intervals\n        all_busy = natalie_busy + stephen_busy\n        all_busy.sort()\n        \n        # Find free intervals\n        free_intervals = []\n        prev_end = work_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_intervals.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_intervals.append((prev_end, work_end))\n        \n        # Check for a 30-minute slot\n        for start, end in free_intervals:\n            if end - start >= 30:\n                # Check if it's Tuesday after 12:30 (Stephen's constraint)\n                if day == \"Tuesday\" and start >= 12 * 60 + 30:\n                    continue\n                # Found a suitable time\n                meeting_start = start\n                meeting_end = start + 30\n                # Format the output\n                start_hour = meeting_start // 60\n                start_min = meeting_start % 60\n                end_hour = meeting_end // 60\n                end_min = meeting_end % 60\n                return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_804"
        },
        {
            "final_program_time": "{11:00:12:00}",
            "expected_time": "{11:00:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(dorothy_schedule, judith_schedule, work_hours, days, duration):\n    # Parse work hours\n    work_start, work_end = map(lambda x: int(x.split(':')[0]), work_hours.split(' to '))\n    \n    for day in days:\n        # Initialize available slots for the day\n        dorothy_available = []\n        judith_available = []\n        \n        # Get Dorothy's available slots for the day\n        dorothy_busy = dorothy_schedule.get(day, [])\n        dorothy_available = get_available_slots(dorothy_busy, work_start, work_end, duration)\n        \n        # Get Judith's available slots for the day\n        judith_busy = judith_schedule.get(day, [])\n        judith_available = get_available_slots(judith_busy, work_start, work_end, duration)\n        \n        # Find overlapping slots\n        for slot_d in dorothy_available:\n            for slot_j in judith_available:\n                start = max(slot_d[0], slot_j[0])\n                end = min(slot_d[1], slot_j[1])\n                if end - start >= duration:\n                    return f\"{start//60:02d}:{start%60:02d}:{(start+duration)//60:02d}:{(start+duration)%60:02d}\"\n    \n    return \"No suitable time found\"\n\ndef get_available_slots(busy_slots, work_start, work_end, duration):\n    # Convert busy slots to minutes\n    busy_minutes = []\n    for slot in busy_slots:\n        start, end = slot.split(' to ')\n        start_h, start_m = map(int, start.split(':'))\n        end_h, end_m = map(int, end.split(':'))\n        busy_minutes.append((start_h * 60 + start_m, end_h * 60 + end_m))\n    \n    # Sort busy slots\n    busy_minutes.sort()\n    \n    # Find available slots\n    available = []\n    prev_end = work_start * 60\n    \n    for start, end in busy_minutes:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end * 60:\n        available.append((prev_end, work_end * 60))\n    \n    # Filter slots that are long enough\n    available = [slot for slot in available if slot[1] - slot[0] >= duration]\n    \n    return available\n\n# Define schedules\ndorothy_schedule = {\n    'Monday': ['16:30 to 17:00'],\n    'Tuesday': ['10:00 to 10:30'],\n    'Thursday': ['9:00 to 9:30', '13:00 to 13:30']\n}\n\njudith_schedule = {\n    'Monday': ['9:00 to 17:00'],\n    'Tuesday': ['9:00 to 17:00'],\n    'Wednesday': ['9:00 to 11:00', '12:00 to 17:00'],\n    'Thursday': ['9:00 to 10:00', '10:30 to 14:30', '15:00 to 17:00']\n}\n\n# Define constraints\nwork_hours = '9:00 to 17:00'\ndays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\nduration = 60  # minutes\n\n# Find meeting time\nmeeting_time = find_meeting_time(dorothy_schedule, judith_schedule, work_hours, days, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_805"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:00:10:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(tyler_busy, jack_busy, work_hours, days, duration):\n    for day in days:\n        # Initialize available time for the day within work hours\n        available_start = work_hours[0]\n        available_end = work_hours[1]\n        \n        # Get busy slots for Tyler and Jack for the current day\n        tyler_day = [slot for slot in tyler_busy if slot[0] == day]\n        jack_day = [slot for slot in jack_busy if slot[0] == day]\n        \n        # Combine and sort all busy slots for the day\n        all_busy = tyler_day + jack_day\n        all_busy.sort(key=lambda x: x[1])\n        \n        # Iterate through the busy slots to find gaps\n        current_time = available_start\n        for busy_start, busy_end in all_busy:\n            if busy_start > current_time:\n                # Check if the gap is enough for the meeting\n                if busy_start - current_time >= duration:\n                    return (day, current_time, current_time + duration)\n            # Update current_time to the end of the busy slot\n            if busy_end > current_time:\n                current_time = busy_end\n        \n        # Check after the last busy slot\n        if available_end - current_time >= duration:\n            return (day, current_time, current_time + duration)\n    \n    return None\n\n# Define work hours and days\nwork_hours = (9.0, 17.0)\ndays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\nduration = 0.5  # 0.5 hours = 30 minutes\n\n# Define busy slots for Tyler and Jack\ntyler_busy = [\n    ('Monday', 11.0, 11.5), ('Monday', 13.0, 13.5), ('Monday', 15.0, 15.5),\n    ('Tuesday', 10.5, 11.0), ('Tuesday', 11.5, 12.0), ('Tuesday', 13.5, 14.0), ('Tuesday', 16.5, 17.0),\n    ('Wednesday', 9.0, 9.5), ('Wednesday', 10.0, 10.5), ('Wednesday', 13.0, 14.0),\n    ('Thursday', 11.5, 12.0), ('Thursday', 12.5, 13.0), ('Thursday', 13.5, 14.0)\n]\n\njack_busy = [\n    ('Monday', 9.0, 10.0), ('Monday', 11.0, 11.5), ('Monday', 12.0, 13.5), ('Monday', 14.0, 14.5), ('Monday', 15.0, 15.5), ('Monday', 16.0, 17.0),\n    ('Tuesday', 9.0, 9.5), ('Tuesday', 12.0, 13.5), ('Tuesday', 14.0, 14.5), ('Tuesday', 15.5, 16.0),\n    ('Wednesday', 9.0, 10.0), ('Wednesday', 10.5, 13.0), ('Wednesday', 13.5, 15.0), ('Wednesday', 15.5, 16.0),\n    ('Thursday', 9.5, 11.5), ('Thursday', 14.0, 14.5)\n]\n\n# Find the earliest meeting time\nmeeting_time = find_meeting_time(tyler_busy, jack_busy, work_hours, days, duration)\n\n# Format the output\nif meeting_time:\n    day, start, end = meeting_time\n    # Convert float hours to HH:MM format\n    start_hour = int(start)\n    start_min = int((start - start_hour) * 60)\n    end_hour = int(end)\n    end_min = int((end - end_hour) * 60)\n    print(f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\")\nelse:\n    print(\"No suitable time found\")\n```",
            "count": "calendar_scheduling_example_806"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{10:00:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to consider\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Define busy slots for Jonathan and Natalie in minutes since midnight\n    jonathan_busy = {\n        'Monday': [(13 * 60, 14 * 60), (16 * 60 + 30, 17 * 60)],\n        'Tuesday': [(10 * 60, 11 * 60), (12 * 60, 12 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Wednesday': [(11 * 60 + 30, 12 * 60), (13 * 60, 13 * 60 + 30), (15 * 60, 15 * 60 + 30)],\n        'Thursday': [(12 * 60 + 30, 13 * 60 + 30), (14 * 60, 14 * 60 + 30)]\n    }\n    \n    natalie_busy = {\n        'Monday': [(9 * 60, 10 * 60), (11 * 60, 12 * 60), (12 * 60 + 30, 13 * 60 + 30), (14 * 60, 15 * 60), (16 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 10 * 60), (10 * 60 + 30, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 10 * 60 + 30), (11 * 60, 12 * 60), (13 * 60, 15 * 60), (15 * 60 + 30, 17 * 60)],\n        'Thursday': [(10 * 60, 12 * 60), (13 * 60 + 30, 14 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)]\n    }\n    \n    # Apply preferences\n    # Jonathan doesn't want Monday after 15:00\n    jonathan_busy['Monday'].append((15 * 60, 17 * 60))\n    # Natalie doesn't want Thursday\n    days.remove('Thursday')\n    \n    meeting_duration = 60  # 1 hour\n    \n    for day in days:\n        # Collect all busy slots for both participants\n        busy_slots = jonathan_busy.get(day, []) + natalie_busy.get(day, [])\n        busy_slots.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in busy_slots:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check for a suitable slot\n        for start, end in free_slots:\n            if end - start >= meeting_duration:\n                meeting_start = start\n                meeting_end = meeting_start + meeting_duration\n                # Convert back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_807"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to consider\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n\n    # Michelle's schedule: {day: [(busy_start, busy_end), ...]}\n    michelle_schedule = {\n        'Monday': [(13.5 * 60, 14 * 60), (14.5 * 60, 15 * 60)],\n        'Tuesday': [(10.5 * 60, 12 * 60), (12.5 * 60, 13 * 60), (14.5 * 60, 15.5 * 60), (16.5 * 60, 17 * 60)],\n        'Wednesday': [(9.5 * 60, 10 * 60), (14 * 60, 14.5 * 60), (16 * 60, 16.5 * 60)],\n        'Thursday': [(10 * 60, 10.5 * 60), (11 * 60, 12 * 60), (13 * 60, 13.5 * 60), (15 * 60, 15.5 * 60), (16.5 * 60, 17 * 60)]\n    }\n\n    # Laura's schedule: {day: [(busy_start, busy_end), ...]}\n    laura_schedule = {\n        'Monday': [(9.5 * 60, 10 * 60), (10.5 * 60, 13 * 60), (14.5 * 60, 15.5 * 60), (16 * 60, 16.5 * 60)],\n        'Tuesday': [(9 * 60, 10.5 * 60), (11 * 60, 12 * 60), (12.5 * 60, 14.5 * 60), (15.5 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 11.5 * 60), (12 * 60, 13.5 * 60), (14.5 * 60, 15.5 * 60), (16 * 60, 17 * 60)],\n        'Thursday': [(9 * 60, 12.5 * 60), (13 * 60, 17 * 60)]\n    }\n\n    # Preferences\n    michelle_avoid_days = ['Tuesday', 'Thursday']\n    laura_avoid = {\n        'Monday': (14.5 * 60, 17 * 60),\n        'Wednesday': (9 * 60, 17 * 60)\n    }\n\n    # Iterate through each day\n    for day in days:\n        if day in michelle_avoid_days:\n            continue\n        if day in laura_avoid:\n            if day == 'Monday':\n                # Laura doesn't want to meet on Monday after 14:30\n                work_end_day = 14.5 * 60\n            else:\n                # Laura doesn't want to meet on Wednesday at all\n                continue\n        else:\n            work_end_day = work_end\n\n        # Get both schedules for the day\n        m_busy = michelle_schedule.get(day, [])\n        l_busy = laura_schedule.get(day, [])\n\n        # Combine and sort all busy intervals\n        all_busy = m_busy + l_busy\n        all_busy.sort()\n\n        # Find free slots\n        prev_end = work_start\n        for busy_start, busy_end in all_busy:\n            if busy_start > prev_end:\n                # Found a free slot\n                free_start = prev_end\n                free_end = busy_start\n                if free_end - free_start >= meeting_duration:\n                    # Convert to HH:MM format\n                    start_hh = int(free_start // 60)\n                    start_mm = int(free_start % 60)\n                    end_hh = int((free_start + meeting_duration) // 60)\n                    end_mm = int((free_start + meeting_duration) % 60)\n                    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n            prev_end = max(prev_end, busy_end)\n\n        # Check after last busy interval\n        if work_end_day - prev_end >= meeting_duration:\n            start_hh = int(prev_end // 60)\n            start_mm = int(prev_end % 60)\n            end_hh = int((prev_end + meeting_duration) // 60)\n            end_mm = int((prev_end + meeting_duration) % 60)\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_808"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:00}",
            "type_error": "SyntaxError",
            "full_response": "```python\n'''\nThis script schedules a meeting between Douglas and Zachary based on their availability and preferences.\n'''",
            "count": "calendar_scheduling_example_809"
        },
        {
            "final_program_time": "{11:00:12:00}",
            "expected_time": "{11:00:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Nicole's blocked times in minutes since midnight for each day\n    nicole_blocked = {\n        'Monday': [(9*60 + 30, 11*60), (12*60, 13*60), (13*60 + 30, 16*60 + 30)],\n        'Tuesday': [(9*60, 9*60 + 30), (10*60 + 30, 11*60), (11*60 + 30, 12*60 + 30), (14*60, 17*60)],\n        'Wednesday': [(9*60, 9*60 + 30), (10*60, 11*60), (11*60 + 30, 12*60), (12*60 + 30, 15*60), (15*60 + 30, 16*60 + 30)],\n        'Thursday': [(9*60, 9*60 + 30), (10*60 + 30, 11*60), (12*60, 12*60 + 30), (13*60 + 30, 14*60 + 30), (15*60, 15*60 + 30), (16*60, 17*60)]\n    }\n    \n    # Preferences\n    avoid_days_for_joe = ['Thursday']\n    avoid_days_for_nicole = ['Tuesday']\n    \n    # Iterate through each day, avoiding preferred days\n    for day in days:\n        if day in avoid_days_for_joe or day in avoid_days_for_nicole:\n            continue\n        \n        # Get Nicole's blocked times for the day\n        blocked_times = nicole_blocked.get(day, [])\n        blocked_times.sort()  # Ensure sorted\n        \n        # Find available slots\n        available_slots = []\n        prev_end = work_hours_start\n        \n        for start, end in blocked_times:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after last blocked time\n        if prev_end < work_hours_end:\n            available_slots.append((prev_end, work_hours_end))\n        \n        # Check for a 1-hour slot\n        for start, end in available_slots:\n            if end - start >= 60:\n                meeting_start = start\n                meeting_end = start + 60\n                # Format the time as HH:MM:HH:MM\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_810"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to consider\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Theresa's constraints: day -> list of busy intervals in minutes\n    theresa_busy = {\n        'Monday': [(9*60 + 30, 10*60 + 30), (13*60, 13*60 + 30)],\n        'Tuesday': [(10*60, 10*60 + 30)],\n        'Wednesday': [(12*60, 12*60 + 30), (14*60 + 30, 15*60)],\n        'Thursday': [(11*60, 12*60), (12*60 + 30, 13*60 + 30)],\n    }\n    \n    # Emily's constraints: day -> list of busy intervals in minutes\n    emily_busy = {\n        'Monday': [(9*60, 10*60), (11*60, 12*60 + 30), (13*60 + 30, 14*60), (15*60, 15*60 + 30)],\n        'Tuesday': [(10*60, 11*60), (14*60, 14*60 + 30), (15*60, 15*60 + 30), (16*60, 16*60 + 30)],\n        'Wednesday': [(9*60, 10*60), (11*60, 15*60), (15*60 + 30, 17*60)],\n        'Thursday': [(9*60, 11*60), (14*60 + 30, 16*60)],\n    }\n    \n    # Additional constraints: Theresa can't meet on Thursday, Emily can't meet on Monday or Tuesday\n    available_days = ['Wednesday']  # Only Wednesday is left after applying constraints\n    \n    for day in available_days:\n        # Collect all busy intervals for both participants on this day\n        busy_intervals = theresa_busy.get(day, []) + emily_busy.get(day, [])\n        busy_intervals.sort()  # Sort by start time\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in busy_intervals:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for 30-minute availability\n        for start, end in free_slots:\n            if end - start >= 30:\n                # Found the earliest available slot\n                meeting_start = start\n                meeting_end = meeting_start + 30\n                # Convert back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_811"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    meeting_duration = 30  # minutes\n    \n    # Define existing schedules for Mary and Alexis\n    mary_schedule = {\n        'Tuesday': [(10 * 60, 10 * 60 + 30), (15 * 60 + 30, 16 * 60)],\n        'Wednesday': [(9 * 60 + 30, 10 * 60), (15 * 60, 15 * 60 + 30)],\n        'Thursday': [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60 + 30)],\n    }\n    \n    alexis_schedule = {\n        'Monday': [(9 * 60, 10 * 60), (10 * 60 + 30, 12 * 60), (12 * 60 + 30, 16 * 60 + 30)],\n        'Tuesday': [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60 + 30), (12 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 11 * 60), (11 * 60 + 30, 17 * 60)],\n        'Thursday': [(10 * 60, 12 * 60), (14 * 60, 14 * 60 + 30), (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)],\n    }\n    \n    # Iterate through each day to find the earliest available slot\n    for day in days:\n        # Collect all busy intervals for both participants\n        mary_busy = mary_schedule.get(day, [])\n        alexis_busy = alexis_schedule.get(day, [])\n        \n        # Combine and sort all busy intervals\n        all_busy = mary_busy + alexis_busy\n        all_busy.sort()\n        \n        # Merge overlapping or adjacent intervals\n        merged_busy = []\n        for start, end in all_busy:\n            if not merged_busy:\n                merged_busy.append((start, end))\n            else:\n                last_start, last_end = merged_busy[-1]\n                if start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged_busy[-1] = (new_start, new_end)\n                else:\n                    merged_busy.append((start, end))\n        \n        # Check the time before the first busy interval\n        if merged_busy:\n            first_start, first_end = merged_busy[0]\n            if first_start > work_start:\n                available_start = work_start\n                available_end = first_start\n                if available_end - available_start >= meeting_duration:\n                    # Found a slot\n                    return f\"{minutes_to_time(available_start)}:{minutes_to_time(available_start + meeting_duration)}\"\n        \n        # Check the time between busy intervals\n        for i in range(1, len(merged_busy)):\n            prev_end = merged_busy[i-1][1]\n            curr_start = merged_busy[i][0]\n            if curr_start - prev_end >= meeting_duration:\n                available_start = prev_end\n                available_end = curr_start\n                return f\"{minutes_to_time(available_start)}:{minutes_to_time(available_start + meeting_duration)}\"\n        \n        # Check the time after the last busy interval\n        if merged_busy:\n            last_start, last_end = merged_busy[-1]\n            if last_end < work_end:\n                available_start = last_end\n                available_end = work_end\n                if available_end - available_start >= meeting_duration:\n                    return f\"{minutes_to_time(available_start)}:{minutes_to_time(available_start + meeting_duration)}\"\n        else:\n            # No busy intervals, the whole day is available\n            return f\"{minutes_to_time(work_start)}:{minutes_to_time(work_start + meeting_duration)}\"\n    \n    return \"No available time found\"\n\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Find and print the earliest meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_812"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{10:00:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_earliest_meeting_time():\n    # Define work hours and days\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Define Justin's busy times in minutes since midnight for each day\n    justin_busy = {\n        'Monday': [\n            (9 * 60 + 30, 10 * 60),\n            (11 * 60, 12 * 60),\n            (13 * 60, 14 * 60),\n            (14 * 60 + 30, 15 * 60 + 30),\n            (16 * 60, 17 * 60)\n        ],\n        'Tuesday': [\n            (9 * 60 + 30, 10 * 60),\n            (10 * 60 + 30, 11 * 60),\n            (12 * 60 + 30, 14 * 60 + 30),\n            (15 * 60, 15 * 60 + 30),\n            (16 * 60 + 30, 17 * 60)\n        ],\n        'Wednesday': [\n            (9 * 60, 9 * 60 + 30),\n            (10 * 60, 10 * 60 + 30),\n            (11 * 60, 11 * 60 + 30),\n            (12 * 60 + 30, 13 * 60),\n            (14 * 60, 15 * 60 + 30),\n            (16 * 60 + 30, 17 * 60)\n        ],\n        'Thursday': [\n            (9 * 60, 10 * 60),\n            (10 * 60 + 30, 11 * 60),\n            (12 * 60 + 30, 14 * 60),\n            (15 * 60, 15 * 60 + 30)\n        ]\n    }\n    \n    # Brenda has no meetings, so only Justin's schedule matters\n    meeting_duration = 60  # 1 hour\n    \n    for day in days:\n        # Start checking from the beginning of the work day\n        current_time = work_start\n        \n        # Get Justin's busy times for the current day\n        busy_times = justin_busy.get(day, [])\n        busy_times.sort()  # Ensure they are in order\n        \n        for busy_start, busy_end in busy_times:\n            if current_time + meeting_duration <= busy_start:\n                # Found a suitable slot\n                start_h = current_time // 60\n                start_m = current_time % 60\n                end_h = (current_time + meeting_duration) // 60\n                end_m = (current_time + meeting_duration) % 60\n                return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n            # Move current_time to the end of this busy period if it's later\n            if busy_end > current_time:\n                current_time = busy_end\n        # Check the time after the last busy period\n        if current_time + meeting_duration <= work_end:\n            start_h = current_time // 60\n            start_m = current_time % 60\n            end_h = (current_time + meeting_duration) // 60\n            end_m = (current_time + meeting_duration) % 60\n            return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_earliest_meeting_time())\n```",
            "count": "calendar_scheduling_example_813"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef parse_time(time_str):\n    return datetime.strptime(time_str, \"%H:%M\")\n\ndef time_to_str(time_obj):\n    return time_obj.strftime(\"%H:%M\")\n\ndef find_earliest_meeting_time(evelyn_busy, mark_busy, days, work_start, work_end, duration, avoid_day):\n    work_start = parse_time(work_start)\n    work_end = parse_time(work_end)\n    duration = timedelta(minutes=duration)\n    \n    for day in days:\n        if day == avoid_day:\n            continue\n        \n        evelyn_day = evelyn_busy.get(day, [])\n        mark_day = mark_busy.get(day, [])\n        \n        # Combine and sort all busy intervals for the day\n        all_busy = []\n        for start, end in evelyn_day:\n            all_busy.append((parse_time(start), parse_time(end)))\n        for start, end in mark_day:\n            all_busy.append((parse_time(start), parse_time(end)))\n        all_busy.sort()\n        \n        # Find the earliest available slot\n        current_time = work_start\n        for busy_start, busy_end in all_busy:\n            if busy_start > current_time:\n                if busy_start >= current_time + duration:\n                    return day, time_to_str(current_time), time_to_str(current_time + duration)\n                else:\n                    current_time = busy_end\n            else:\n                if current_time < busy_end:\n                    current_time = busy_end\n        if current_time + duration <= work_end:\n            return day, time_to_str(current_time), time_to_str(current_time + duration)\n    \n    return None\n\n# Define the busy schedules\nevelyn_busy = {\n    \"Monday\": [(\"09:30\", \"10:00\"), (\"12:00\", \"12:30\"), (\"13:00\", \"14:30\")],\n    \"Tuesday\": [(\"12:30\", \"13:00\"), (\"13:30\", \"14:00\"), (\"16:30\", \"17:00\")],\n    \"Wednesday\": [(\"12:00\", \"12:30\"), (\"16:30\", \"17:00\")],\n    \"Thursday\": [(\"10:30\", \"11:00\"), (\"11:30\", \"12:00\"), (\"14:00\", \"15:30\"), (\"16:30\", \"17:00\")]\n}\n\nmark_busy = {\n    \"Monday\": [(\"09:30\", \"11:00\"), (\"11:30\", \"12:30\"), (\"13:30\", \"14:30\"), (\"15:30\", \"16:00\")],\n    \"Tuesday\": [(\"09:00\", \"12:00\"), (\"12:30\", \"13:30\"), (\"14:00\", \"17:00\")],\n    \"Wednesday\": [(\"09:00\", \"09:30\"), (\"10:30\", \"13:00\"), (\"14:00\", \"17:00\")],\n    \"Thursday\": [(\"10:30\", \"12:00\"), (\"13:00\", \"13:30\"), (\"14:00\", \"14:30\"), (\"15:00\", \"15:30\"), (\"16:00\", \"17:00\")]\n}\n\n# Parameters\ndays = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\"]\nwork_start = \"09:00\"\nwork_end = \"17:00\"\nduration = 30\navoid_day = \"Wednesday\"\n\n# Find the earliest meeting time\nresult = find_earliest_meeting_time(evelyn_busy, mark_busy, days, work_start, work_end, duration, avoid_day)\n\nif result:\n    day, start_time, end_time = result\n    print(f\"{start_time}:{end_time}\")\nelse:\n    print(\"No available time found.\")\n```",
            "count": "calendar_scheduling_example_814"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to consider (Monday to Thursday)\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Define Timothy's busy slots in minutes since midnight for each day\n    timothy_busy = {\n        'Monday': [(10 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60),\n                   (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 15 * 60 + 30),\n                   (16 * 60 + 30, 17 * 60)],\n        'Tuesday': [(10 * 60, 10 * 60 + 30), (11 * 60, 13 * 60),\n                    (14 * 60, 14 * 60 + 30), (15 * 60, 15 * 60 + 30),\n                    (16 * 60, 16 * 60 + 30)],\n        'Wednesday': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30),\n                      (11 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60),\n                      (14 * 60 + 30, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Thursday': [(9 * 60, 10 * 60), (10 * 60 + 30, 12 * 60),\n                     (13 * 60, 13 * 60 + 30), (15 * 60, 16 * 60 + 30)]\n    }\n    \n    meeting_duration = 60  # 1 hour in minutes\n    \n    # Iterate through days in order, excluding Tuesday first (preference)\n    preferred_days = ['Monday', 'Wednesday', 'Thursday', 'Tuesday']\n    \n    for day in preferred_days:\n        if day == 'Tuesday':\n            continue  # Skip Tuesday as per preference\n        \n        busy_slots = timothy_busy[day]\n        free_slots = []\n        \n        # Find free slots before the first busy slot\n        if busy_slots:\n            first_busy_start = busy_slots[0][0]\n            if first_busy_start - work_start >= meeting_duration:\n                free_slots.append((work_start, first_busy_start))\n        else:\n            # Entire day is free\n            free_slots.append((work_start, work_end))\n            break\n        \n        # Find free slots between busy slots\n        for i in range(1, len(busy_slots)):\n            prev_busy_end = busy_slots[i-1][1]\n            current_busy_start = busy_slots[i][0]\n            if current_busy_start - prev_busy_end >= meeting_duration:\n                free_slots.append((prev_busy_end, current_busy_start))\n        \n        # Find free slots after the last busy slot\n        last_busy_end = busy_slots[-1][1]\n        if work_end - last_busy_end >= meeting_duration:\n            free_slots.append((last_busy_end, work_end))\n        \n        # Check if any free slot is available\n        for slot in free_slots:\n            start, end = slot\n            if end - start >= meeting_duration:\n                # Found a suitable slot, return the earliest possible time\n                meeting_start = start\n                meeting_end = meeting_start + meeting_duration\n                # Convert back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    # If no slot found in preferred days, check Tuesday (though preference is to avoid)\n    day = 'Tuesday'\n    busy_slots = timothy_busy[day]\n    free_slots = []\n    \n    # Find free slots before the first busy slot\n    if busy_slots:\n        first_busy_start = busy_slots[0][0]\n        if first_busy_start - work_start >= meeting_duration:\n            free_slots.append((work_start, first_busy_start))\n    else:\n        # Entire day is free\n        free_slots.append((work_start, work_end))\n    \n    # Find free slots between busy slots\n    for i in range(1, len(busy_slots)):\n        prev_busy_end = busy_slots[i-1][1]\n        current_busy_start = busy_slots[i][0]\n        if current_busy_start - prev_busy_end >= meeting_duration:\n            free_slots.append((prev_busy_end, current_busy_start))\n    \n    # Find free slots after the last busy slot\n    last_busy_end = busy_slots[-1][1]\n    if work_end - last_busy_end >= meeting_duration:\n        free_slots.append((last_busy_end, work_end))\n    \n    # Check if any free slot is available\n    for slot in free_slots:\n        start, end = slot\n        if end - start >= meeting_duration:\n            # Found a suitable slot, return the earliest possible time\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_815"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Define Melissa's blocked times in minutes since midnight for each day\n    melissa_blocked = {\n        'Monday': [(9*60, 9*60 + 30), (10*60 + 30, 11*60), (12*60, 12*60 + 30), (13*60, 16*60 + 30)],\n        'Tuesday': [(9*60, 9*60 + 30), (10*60, 10*60 + 30), (13*60 + 30, 14*60), (14*60 + 30, 15*60 + 30)],\n        'Wednesday': [(9*60, 9*60 + 30), (10*60, 11*60), (12*60 + 30, 13*60), (14*60, 14*60 + 30), (15*60, 15*60 + 30)],\n        'Thursday': [(11*60, 11*60 + 30), (12*60 + 30, 13*60), (15*60, 15*60 + 30)]\n    }\n    \n    # Define Diane's blocked times in minutes since midnight for each day\n    diane_blocked = {\n        'Monday': [(9*60, 10*60), (10*60 + 30, 16*60 + 30)],\n        'Tuesday': [(9*60, 17*60)],\n        'Wednesday': [(9*60, 17*60)],\n        'Thursday': [(9*60, 17*60)]\n    }\n    \n    # Diane's preference: avoid Monday before 16:00\n    diane_preference = ('Monday', 16*60)\n    \n    meeting_duration = 30  # minutes\n    \n    # Iterate through each day to find a suitable time\n    for day in days:\n        # Skip Monday before 16:00 if it's Monday\n        if day == 'Monday':\n            start_time = max(work_start, diane_preference[1])\n        else:\n            start_time = work_start\n        \n        # Generate all possible 30-minute slots in the day\n        current_time = start_time\n        while current_time + meeting_duration <= work_end:\n            slot_end = current_time + meeting_duration\n            # Check if the slot is free for both Melissa and Diane\n            melissa_free = True\n            for block_start, block_end in melissa_blocked[day]:\n                if not (slot_end <= block_start or current_time >= block_end):\n                    melissa_free = False\n                    break\n            \n            diane_free = True\n            for block_start, block_end in diane_blocked[day]:\n                if not (slot_end <= block_start or current_time >= block_end):\n                    diane_free = False\n                    break\n            \n            if melissa_free and diane_free:\n                # Convert minutes back to HH:MM format\n                start_hh = current_time // 60\n                start_mm = current_time % 60\n                end_hh = slot_end // 60\n                end_mm = slot_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n            \n            current_time += 15  # Check in 15-minute increments\n    \n    return \"No suitable time found\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_816"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n\n    # Ann's schedule: {day: [(start1, end1), (start2, end2), ...]}\n    ann_schedule = {\n        'Monday': [(10 * 60, 11 * 60), (13 * 60 + 30, 14 * 60)],\n        'Tuesday': [(10 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60), (13 * 60, 13 * 60 + 30), (15 * 60, 16 * 60)],\n        'Wednesday': [(11 * 60, 11 * 60 + 30), (12 * 60 + 30, 14 * 60), (15 * 60, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n        'Thursday': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (11 * 60, 12 * 60 + 30), (15 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)]\n    }\n\n    # Jeremy's schedule: {day: [(start1, end1), (start2, end2), ...]}\n    jeremy_schedule = {\n        'Monday': [(9 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 10 * 60), (10 * 60 + 30, 17 * 60)],\n        'Wednesday': [(9 * 60, 17 * 60)],\n        'Thursday': [(9 * 60, 12 * 60), (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 15 * 60 + 30), (16 * 60, 17 * 60)]\n    }\n\n    for day in days:\n        # Collect all busy intervals for the day for both participants\n        ann_busy = ann_schedule.get(day, [])\n        jeremy_busy = jeremy_schedule.get(day, [])\n\n        # Combine and sort all busy intervals\n        all_busy = ann_busy + jeremy_busy\n        all_busy.sort()\n\n        # Find free intervals\n        free_intervals = []\n        prev_end = work_start\n\n        for start, end in all_busy:\n            if start > prev_end:\n                free_intervals.append((prev_end, start))\n            prev_end = max(prev_end, end)\n\n        if prev_end < work_end:\n            free_intervals.append((prev_end, work_end))\n\n        # Check each free interval for availability\n        for start, end in free_intervals:\n            if end - start >= meeting_duration:\n                # Found a suitable time\n                meeting_start = start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_817"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{12:30:13:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time():\n    # Define work hours\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    meeting_duration = timedelta(hours=1)\n    \n    # Define days to check\n    days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\"]\n    \n    # Define busy slots for Charles and Betty\n    charles_busy = {\n        \"Monday\": [(\"16:30\", \"17:00\")],\n        \"Tuesday\": [(\"09:00\", \"09:30\")],\n        \"Wednesday\": [(\"12:00\", \"12:30\"), (\"14:00\", \"14:30\")],\n        \"Thursday\": [(\"10:30\", \"11:00\"), (\"15:00\", \"15:30\")]\n    }\n    \n    betty_busy = {\n        \"Monday\": [(\"09:00\", \"09:30\"), (\"10:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"14:00\", \"15:00\"), (\"15:30\", \"17:00\")],\n        \"Tuesday\": [(\"09:30\", \"10:30\"), (\"11:30\", \"12:30\"), (\"13:30\", \"14:00\"), (\"14:30\", \"15:30\")],\n        \"Wednesday\": [(\"09:00\", \"09:30\"), (\"10:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"13:30\"), (\"14:00\", \"14:30\"), (\"15:30\", \"17:00\")],\n        \"Thursday\": [(\"09:00\", \"10:30\"), (\"12:30\", \"13:30\"), (\"14:00\", \"15:30\"), (\"16:00\", \"16:30\")]\n    }\n    \n    # Preferences\n    avoid_days_for_charles = [\"Monday\"]\n    avoid_times_for_betty = {\n        \"Tuesday\": (\"13:30\", \"17:00\")\n    }\n    \n    # Iterate through each day\n    for day in days:\n        if day in avoid_days_for_charles:\n            continue\n        \n        # Get busy slots for the day\n        c_busy = [ (datetime.strptime(start, \"%H:%M\"), datetime.strptime(end, \"%H:%M\")) \n                  for start, end in charles_busy.get(day, []) ]\n        b_busy = [ (datetime.strptime(start, \"%H:%M\"), datetime.strptime(end, \"%H:%M\")) \n                  for start, end in betty_busy.get(day, []) ]\n        \n        # Combine and sort all busy slots\n        all_busy = sorted(c_busy + b_busy, key=lambda x: x[0])\n        \n        # Check Betty's preferences for the day\n        if day in avoid_times_for_betty:\n            avoid_start, avoid_end = avoid_times_for_betty[day]\n            avoid_start = datetime.strptime(avoid_start, \"%H:%M\")\n            avoid_end = datetime.strptime(avoid_end, \"%H:%M\")\n            all_busy.append((avoid_start, avoid_end))\n            all_busy.sort(key=lambda x: x[0])\n        \n        # Find available slots\n        prev_end = work_start\n        for busy_start, busy_end in all_busy:\n            if busy_start > prev_end:\n                available_start = prev_end\n                available_end = busy_start\n                if available_end - available_start >= meeting_duration:\n                    # Found a suitable slot\n                    return f\"{available_start.strftime('%H:%M')}:{ (available_start + meeting_duration).strftime('%H:%M') }\"\n            prev_end = max(prev_end, busy_end)\n        \n        # Check after last busy slot\n        if work_end - prev_end >= meeting_duration:\n            return f\"{prev_end.strftime('%H:%M')}:{ (prev_end + meeting_duration).strftime('%H:%M') }\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_818"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days\n    work_hours_start = 9\n    work_hours_end = 17\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Julie's constraints: no meetings on Thursday before 11:30, otherwise free\n    # Ruth's constraints:\n    ruth_busy = {\n        'Monday': [(9, 17)],\n        'Tuesday': [(9, 17)],\n        'Wednesday': [(9, 17)],\n        'Thursday': [(9, 11), (11.5, 14.5), (15, 17)]\n    }\n    \n    # Check each day for available slots\n    for day in days:\n        if day == 'Thursday':\n            # Julie prefers not before 11:30 on Thursday\n            available_start = 11.5\n        else:\n            available_start = work_hours_start\n        \n        ruth_busy_today = ruth_busy.get(day, [])\n        \n        # Find gaps in Ruth's schedule\n        previous_end = work_hours_start\n        for busy_start, busy_end in ruth_busy_today:\n            if busy_start > previous_end and busy_start >= available_start:\n                # Found a gap\n                potential_start = max(previous_end, available_start)\n                potential_end = potential_start + 0.5  # 30 minutes\n                if potential_end <= busy_start and potential_end <= work_hours_end:\n                    return f\"{day} {int(potential_start)}:{'00' if potential_start % 1 == 0 else '30'}:{int(potential_start + 0.5)}:{'00' if (potential_start + 0.5) % 1 == 0 else '30'}\"\n            previous_end = busy_end\n        \n        # Check after last busy slot\n        if previous_end < work_hours_end and previous_end >= available_start:\n            potential_start = max(previous_end, available_start)\n            potential_end = potential_start + 0.5\n            if potential_end <= work_hours_end:\n                return f\"{day} {int(potential_start)}:{'00' if potential_start % 1 == 0 else '30'}:{int(potential_start + 0.5)}:{'00' if (potential_start + 0.5) % 1 == 0 else '30'}\"\n    \n    return \"No suitable time found\"\n\n# Execute the function\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_819"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Days to consider\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Evelyn's schedule: {day: [(start, end), ...]}\n    evelyn_schedule = {\n        'Monday': [(10*60, 10*60+30), (11*60, 11*60+30), (13*60, 14*60), (14*60+30, 16*60), (16*60+30, 17*60)],\n        'Tuesday': [(10*60+30, 11*60), (12*60+30, 13*60), (14*60+30, 15*60+30)],\n        'Wednesday': [(10*60, 10*60+30), (13*60+30, 14*60+30), (16*60+30, 17*60)],\n        'Thursday': [(10*60, 10*60+30), (11*60+30, 12*60), (12*60+30, 13*60+30)]\n    }\n    \n    # Nancy's schedule: {day: [(start, end), ...]}\n    nancy_schedule = {\n        'Monday': [(9*60+30, 17*60)],\n        'Tuesday': [(9*60, 9*60+30), (10*60, 12*60+30), (13*60, 14*60), (14*60+30, 15*60), (15*60+30, 16*60+30)],\n        'Wednesday': [(9*60+30, 10*60), (10*60+30, 11*60), (13*60, 13*60+30), (14*60, 15*60+30), (16*60+30, 17*60)],\n        'Thursday': [(9*60+30, 10*60), (11*60, 14*60), (15*60, 15*60+30), (16*60, 16*60+30)]\n    }\n    \n    # Evelyn prefers to avoid Wednesday\n    preferred_days = ['Monday', 'Tuesday', 'Thursday']\n    \n    # Check each day in preferred order\n    for day in preferred_days:\n        # Get busy times for both participants on this day\n        busy_times = []\n        # Add Evelyn's busy times\n        for start, end in evelyn_schedule[day]:\n            busy_times.append((start, end))\n        # Add Nancy's busy times\n        for start, end in nancy_schedule[day]:\n            busy_times.append((start, end))\n        \n        # Sort busy times by start time\n        busy_times.sort()\n        \n        # Find available slots\n        available_slots = []\n        prev_end = work_start\n        for start, end in busy_times:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        # Check after last busy time\n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n        \n        # Check for a 60-minute slot\n        for start, end in available_slots:\n            if end - start >= 60:\n                # Found a suitable slot\n                meeting_start = start\n                meeting_end = start + 60\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    # If no slot found in preferred days, check Wednesday (as per note, a solution exists)\n    day = 'Wednesday'\n    busy_times = []\n    for start, end in evelyn_schedule[day]:\n        busy_times.append((start, end))\n    for start, end in nancy_schedule[day]:\n        busy_times.append((start, end))\n    \n    busy_times.sort()\n    available_slots = []\n    prev_end = work_start\n    for start, end in busy_times:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    for start, end in available_slots:\n        if end - start >= 60:\n            meeting_start = start\n            meeting_end = start + 60\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_820"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n\n    # Define busy slots for each participant per day in minutes since midnight\n    wayne_busy = {\n        'Monday': [(9 * 60 + 30, 10 * 60 + 0)],\n        'Wednesday': [(12 * 60 + 30, 13 * 60 + 0)],\n        'Thursday': [(10 * 60 + 30, 11 * 60 + 30)],\n    }\n    ronald_busy = {\n        'Monday': [(9 * 60, 12 * 60), (12 * 60 + 30, 14 * 60 + 30), (15 * 60, 16 * 60 + 30)],\n        'Tuesday': [(9 * 60 + 30, 10 * 60 + 30), (12 * 60, 13 * 60), (14 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60 + 30, 10 * 60 + 0), (10 * 60 + 30, 11 * 60 + 0), \n                     (11 * 60 + 30, 14 * 60 + 0), (14 * 60 + 30, 15 * 60 + 0), \n                     (15 * 60 + 30, 17 * 60)],\n        'Thursday': [(9 * 60, 17 * 60)],\n    }\n\n    # Apply preferences\n    # Wayne avoids Monday before 16:30\n    wayne_busy['Monday'].append((9 * 60, 16 * 60 + 30))\n    # Ronald doesn't want to meet on Wednesday\n    days.remove('Wednesday')\n\n    for day in days:\n        # Combine and sort all busy slots for the day\n        busy_slots = wayne_busy.get(day, []) + ronald_busy.get(day, [])\n        busy_slots.sort()\n\n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n\n        for start, end in busy_slots:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n\n        # Check each free slot for availability\n        for start, end in free_slots:\n            slot_duration = end - start\n            if slot_duration >= meeting_duration:\n                meeting_start = start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_821"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Define the participants' busy times in minutes since midnight\n    amy_busy = {\n        'Monday': [(10*60 + 30, 11*60), (12*60, 12*60 + 30), (13*60 + 30, 14*60), (15*60 + 30, 16*60)],\n        'Tuesday': [(11*60, 12*60)],\n        'Wednesday': [(10*60, 10*60 + 30)],\n        'Thursday': [(10*60, 10*60 + 30), (13*60, 13*60 + 30), (15*60, 15*60 + 30)]\n    }\n    \n    michelle_busy = {\n        'Monday': [(9*60, 9*60 + 30), (10*60 + 30, 12*60 + 30), (13*60, 14*60), (14*60 + 30, 17*60)],\n        'Tuesday': [(9*60, 10*60), (10*60 + 30, 11*60 + 30), (12*60 + 30, 13*60), (13*60 + 30, 14*60), (14*60 + 30, 15*60 + 30), (16*60, 16*60 + 30)],\n        'Wednesday': [(9*60, 9*60 + 30), (10*60, 10*60 + 30), (11*60, 11*60 + 30), (12*60, 12*60 + 30), (13*60, 13*60 + 30), (14*60 + 30, 15*60), (16*60, 16*60 + 30)],\n        'Thursday': [(9*60, 9*60 + 30), (10*60, 10*60 + 30), (11*60, 12*60), (13*60, 13*60 + 30), (15*60, 15*60 + 30), (16*60, 17*60)]\n    }\n    \n    # Preferences: avoid Wednesday for Amy, avoid Monday for Michelle\n    preferred_days = ['Tuesday', 'Thursday', 'Monday', 'Wednesday']\n    \n    # Iterate through preferred days in order\n    for day in preferred_days:\n        # Skip Wednesday if possible (Amy's preference)\n        if day == 'Wednesday' and 'Tuesday' in preferred_days:\n            continue\n        # Skip Monday if possible (Michelle's preference)\n        if day == 'Monday' and ('Tuesday' in preferred_days or 'Thursday' in preferred_days):\n            continue\n        \n        # Collect all busy intervals for the day for both participants\n        busy_intervals = []\n        if day in amy_busy:\n            busy_intervals.extend(amy_busy[day])\n        if day in michelle_busy:\n            busy_intervals.extend(michelle_busy[day])\n        \n        # Sort busy intervals by start time\n        busy_intervals.sort()\n        \n        # Find free slots by checking gaps between busy intervals\n        previous_end = work_hours_start\n        free_slots = []\n        \n        for start, end in busy_intervals:\n            if start > previous_end:\n                free_slots.append((previous_end, start))\n            previous_end = max(previous_end, end)\n        \n        # Check the slot after the last busy interval\n        if previous_end < work_hours_end:\n            free_slots.append((previous_end, work_hours_end))\n        \n        # Check each free slot for a 60-minute window\n        for start, end in free_slots:\n            duration_needed = 60\n            if end - start >= duration_needed:\n                meeting_start = start\n                meeting_end = meeting_start + duration_needed\n                # Format the time as HH:MM:HH:MM\n                start_hour = meeting_start // 60\n                start_min = meeting_start % 60\n                end_hour = meeting_end // 60\n                end_min = meeting_end % 60\n                return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n    \n    # If no slot found in preferred days, check remaining days (shouldn't happen per problem statement)\n    for day in days:\n        if day not in preferred_days:\n            busy_intervals = []\n            if day in amy_busy:\n                busy_intervals.extend(amy_busy[day])\n            if day in michelle_busy:\n                busy_intervals.extend(michelle_busy[day])\n            \n            busy_intervals.sort()\n            previous_end = work_hours_start\n            free_slots = []\n            \n            for start, end in busy_intervals:\n                if start > previous_end:\n                    free_slots.append((previous_end, start))\n                previous_end = max(previous_end, end)\n            \n            if previous_end < work_hours_end:\n                free_slots.append((previous_end, work_hours_end))\n            \n            for start, end in free_slots:\n                duration_needed = 60\n                if end - start >= duration_needed:\n                    meeting_start = start\n                    meeting_end = meeting_start + duration_needed\n                    start_hour = meeting_start // 60\n                    start_min = meeting_start % 60\n                    end_hour = meeting_end // 60\n                    end_min = meeting_end % 60\n                    return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n    \n    return \"No suitable time found\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_822"
        },
        {
            "final_program_time": "{12:30:13:30}",
            "expected_time": "{12:30:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Christian's busy times in minutes since midnight for each day\n    christian_busy = {\n        'Monday': [(9*60, 9*60 + 30), (10*60, 14*60 + 30), (15*60, 16*60), (16*60 + 30, 17*60)],\n        'Tuesday': [(9*60 + 30, 14*60 + 30), (15*60 + 30, 17*60)],\n        'Wednesday': [(9*60 + 30, 10*60), (10*60 + 30, 16*60 + 30)],\n        'Thursday': [(9*60, 9*60 + 30), (10*60, 10*60 + 30), (11*60, 11*60 + 30), \n                      (12*60, 12*60 + 30), (13*60 + 30, 14*60 + 30), (15*60 + 30, 17*60)]\n    }\n\n    # Preferences\n    natalie_avoid_day = 'Tuesday'\n    christian_avoid_thursday_after = 13*60 + 30  # 13:30 in minutes\n\n    # Iterate through each day to find a suitable time\n    for day in days:\n        if day == natalie_avoid_day:\n            continue  # Skip Tuesday as Natalie wants to avoid it\n\n        # Get Christian's busy times for the current day\n        busy_times = christian_busy.get(day, [])\n        busy_times.sort()  # Ensure busy times are in order\n\n        # Check available slots before the first busy time\n        prev_end = work_start\n        for start, end in busy_times:\n            if start - prev_end >= meeting_duration:\n                # Check if the slot is on Thursday after 13:30\n                if day == 'Thursday' and prev_end >= christian_avoid_thursday_after:\n                    prev_end = end\n                    continue\n                # Found a suitable slot\n                return f\"{prev_end//60:02d}:{prev_end%60:02d}:{(prev_end + meeting_duration)//60:02d}:{(prev_end + meeting_duration)%60:02d}\"\n            prev_end = max(prev_end, end)\n\n        # Check after the last busy time\n        if work_end - prev_end >= meeting_duration:\n            if day == 'Thursday' and prev_end >= christian_avoid_thursday_after:\n                continue\n            return f\"{prev_end//60:02d}:{prev_end%60:02d}:{(prev_end + meeting_duration)//60:02d}:{(prev_end + meeting_duration)%60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_823"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Define participants' schedules and constraints\n    # Kimberly's constraints: avoid Monday after 13:30 (13 * 60 + 30 = 810 minutes)\n    kimberly_constraints = {\n        'Monday': [(13 * 60 + 30, work_end)],  # After 13:30\n        'Tuesday': [(work_start, work_end)],    # Entire day (preference to avoid)\n    }\n\n    # Timothy's busy slots\n    timothy_busy = {\n        'Monday': [(9 * 60, 9 * 60 + 30), (10 * 60, 11 * 60 + 30), (12 * 60 + 30, 13 * 60 + 30),\n                   (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60 + 30, 10 * 60 + 30), (11 * 60 + 30, 13 * 60),\n                    (13 * 60 + 30, 14 * 60 + 30), (15 * 60 + 30, 16 * 60)],\n        'Wednesday': [(9 * 60, 9 * 60 + 30), (10 * 60, 11 * 60), (11 * 60 + 30, 16 * 60),\n                      (16 * 60 + 30, 17 * 60)],\n        'Thursday': [(9 * 60, 17 * 60)],\n    }\n\n    # Iterate through each day to find a suitable time\n    for day in days:\n        # Skip Tuesday as Kimberly prefers to avoid it\n        if day == 'Tuesday':\n            continue\n\n        # Combine busy slots for both participants\n        busy_slots = []\n        # Add Kimberly's constraints for the day if they exist\n        if day in kimberly_constraints:\n            busy_slots.extend(kimberly_constraints[day])\n        # Add Timothy's busy slots for the day\n        if day in timothy_busy:\n            busy_slots.extend(timothy_busy[day])\n        \n        # Sort busy slots by start time\n        busy_slots.sort()\n\n        # Find free slots by checking gaps between busy slots\n        prev_end = work_start\n        free_slots = []\n        for start, end in busy_slots:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        # Check after last busy slot\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n\n        # Check each free slot for availability of meeting duration\n        for start, end in free_slots:\n            if end - start >= meeting_duration:\n                meeting_start = start\n                meeting_end = start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_824"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Laura's busy times in minutes since midnight for each day\n    laura_busy = {\n        'Monday': [(10*60 + 30, 11*60), (12*60 + 30, 13*60), (14*60 + 30, 15*60 + 30), (16*60, 17*60)],\n        'Tuesday': [(9*60 + 30, 10*60), (11*60, 11*60 + 30), (13*60, 13*60 + 30), (14*60 + 30, 15*60), (16*60, 17*60)],\n        'Wednesday': [(11*60 + 30, 12*60), (12*60 + 30, 13*60), (15*60 + 30, 16*60 + 30)],\n        'Thursday': [(10*60 + 30, 11*60), (12*60, 13*60 + 30), (15*60, 15*60 + 30), (16*60, 16*60 + 30)]\n    }\n    \n    # Philip's busy times in minutes since midnight for each day\n    philip_busy = {\n        'Monday': [(9*60, 17*60)],\n        'Tuesday': [(9*60, 11*60), (11*60 + 30, 12*60), (13*60, 13*60 + 30), (14*60, 14*60 + 30), (15*60, 16*60 + 30)],\n        'Wednesday': [(9*60, 10*60), (11*60, 12*60), (12*60 + 30, 16*60), (16*60 + 30, 17*60)],\n        'Thursday': [(9*60, 10*60 + 30), (11*60, 12*60 + 30), (13*60, 17*60)]\n    }\n    \n    # Philip cannot meet on Wednesday\n    available_days = [day for day in days if day != 'Wednesday']\n    \n    for day in available_days:\n        # Collect all busy intervals for both participants on this day\n        busy_intervals = laura_busy[day] + philip_busy[day]\n        busy_intervals.sort()\n        \n        # Merge overlapping or adjacent intervals\n        merged = []\n        for start, end in busy_intervals:\n            if not merged:\n                merged.append([start, end])\n            else:\n                last_start, last_end = merged[-1]\n                if start <= last_end:\n                    merged[-1] = [last_start, max(end, last_end)]\n                else:\n                    merged.append([start, end])\n        \n        # Find free slots between work hours\n        prev_end = work_start\n        free_slots = []\n        for start, end in merged:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= meeting_duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_825"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\"]\n    \n    # Cheryl's preferences: avoid Wednesday and Thursday\n    preferred_days = [\"Monday\", \"Tuesday\"]\n    \n    # James's schedule: each day's busy slots in minutes\n    james_schedule = {\n        \"Monday\": [(9*60, 9*60 + 30), (10*60 + 30, 11*60), (12*60 + 30, 13*60),\n                   (14*60 + 30, 15*60 + 30), (16*60 + 30, 17*60)],\n        \"Tuesday\": [(9*60, 11*60), (11*60 + 30, 12*60), (12*60 + 30, 15*60 + 30),\n                    (16*60, 17*60)],\n        \"Wednesday\": [(10*60, 11*60), (12*60, 13*60), (13*60 + 30, 16*60)],\n        \"Thursday\": [(9*60 + 30, 11*60 + 30), (12*60, 12*60 + 30), (13*60, 13*60 + 30),\n                     (14*60, 14*60 + 30), (16*60 + 30, 17*60)]\n    }\n    \n    meeting_duration = 30  # minutes\n    \n    # Iterate over preferred days in order\n    for day in preferred_days:\n        busy_slots = james_schedule[day]\n        free_slots = []\n        \n        # Start checking from work_start\n        current_time = work_start\n        \n        for start, end in sorted(busy_slots):\n            if start > current_time:\n                free_slots.append((current_time, start))\n            current_time = max(current_time, end)\n        \n        # Check after last busy slot\n        if current_time < work_end:\n            free_slots.append((current_time, work_end))\n        \n        # Find the first suitable slot\n        for start, end in free_slots:\n            if end - start >= meeting_duration:\n                meeting_start = start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n    \n    # Fallback to other days if preferred days have no slots (though problem states solution exists)\n    for day in days:\n        if day in preferred_days:\n            continue  # already checked\n        busy_slots = james_schedule[day]\n        free_slots = []\n        current_time = work_start\n        \n        for start, end in sorted(busy_slots):\n            if start > current_time:\n                free_slots.append((current_time, start))\n            current_time = max(current_time, end)\n        \n        if current_time < work_end:\n            free_slots.append((current_time, work_end))\n        \n        for start, end in free_slots:\n            if end - start >= meeting_duration:\n                meeting_start = start\n                meeting_end = meeting_start + meeting_duration\n                return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n    \n    return \"No time found\"  # should not reach here per problem statement\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_826"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Define schedules for Angela and Patrick\n    angela_schedule = {\n        'Monday': [(13 * 60 + 30, 14 * 60)],     # 13:30-14:00\n        'Tuesday': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30)],  # 9:00-9:30, 10:00-10:30\n        'Thursday': [(15 * 60 + 30, 16 * 60)]    # 15:30-16:00\n    }\n    \n    patrick_schedule = {\n        'Monday': [(9 * 60 + 30, 10 * 60 + 30), (11 * 60, 12 * 60 + 30), (13 * 60 + 30, 14 * 60), (15 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60, 12 * 60 + 30), (13 * 60, 14 * 60), (15 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Wednesday': [(9 * 60, 11 * 60), (12 * 60, 13 * 60), (13 * 60 + 30, 17 * 60)],\n        'Thursday': [(9 * 60, 9 * 60 + 30), (10 * 60, 11 * 60), (11 * 60 + 30, 12 * 60), (13 * 60, 13 * 60 + 30), (14 * 60, 15 * 60), (15 * 60 + 30, 17 * 60)]\n    }\n    \n    # Patrick cannot meet on Monday\n    days_to_check = [day for day in days if day != 'Monday']\n    \n    # Check each day in order\n    for day in days_to_check:\n        # Get both schedules for the day\n        a_schedule = angela_schedule.get(day, [])\n        p_schedule = patrick_schedule.get(day, [])\n        \n        # Combine and sort all busy times\n        busy_times = a_schedule + p_schedule\n        busy_times.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in busy_times:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for 30-minute availability\n        for slot_start, slot_end in free_slots:\n            duration_needed = 30  # minutes\n            if slot_end - slot_start >= duration_needed:\n                meeting_start = slot_start\n                meeting_end = meeting_start + duration_needed\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_827"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Frances's schedule: {day: [(busy_start, busy_end), ...]}\n    frances_schedule = {\n        'Monday': [(10 * 60, 10 * 60 + 30)],\n        'Tuesday': [(13 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60)],\n        'Wednesday': [(10 * 60, 10 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30)],\n        'Thursday': [(11 * 60 + 30, 12 * 60), (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60), (16 * 60 + 30, 17 * 60)]\n    }\n    \n    # Christina's schedule\n    christina_schedule = {\n        'Monday': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (12 * 60 + 30, 14 * 60 + 30), (15 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (13 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 11 * 60), (13 * 60, 13 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Thursday': [(9 * 60, 10 * 60), (10 * 60 + 30, 12 * 60), (14 * 60 + 30, 15 * 60)]\n    }\n    \n    meeting_duration = 30  # minutes\n    \n    # Iterate through days in order, skipping Wednesday if possible\n    preferred_days = [day for day in days if day != 'Wednesday'] + ['Wednesday']\n    \n    for day in preferred_days:\n        # Collect all busy intervals for both participants\n        busy_intervals = []\n        busy_intervals.extend(frances_schedule.get(day, []))\n        busy_intervals.extend(christina_schedule.get(day, []))\n        \n        # Sort busy intervals by start time\n        busy_intervals.sort()\n        \n        # Find free slots\n        prev_end = work_start\n        free_slots = []\n        \n        for start, end in busy_intervals:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy interval\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            available_start = slot_start\n            available_end = slot_end\n            \n            if available_end - available_start >= meeting_duration:\n                # Found a suitable slot\n                start_hour = available_start // 60\n                start_min = available_start % 60\n                end_hour = (available_start + meeting_duration) // 60\n                end_min = (available_start + meeting_duration) % 60\n                \n                # Format as HH:MM:HH:MM\n                return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_828"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to consider\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Define Rachel's constraints (can't meet on Monday, Tuesday, Wednesday after 10:00)\n    rachel_constraints = {\n        'Monday': True,  # Can't meet at all\n        'Tuesday': True,  # Can't meet at all\n        'Wednesday': lambda time: time >= 10 * 60,  # Can't meet after 10:00\n        'Thursday': lambda time: False  # No constraints\n    }\n    \n    # Define Carolyn's preference (avoid more meetings on Thursday)\n    carolyn_preference_avoid = ['Thursday']\n    \n    # Define busy times for Rachel and Carolyn (in minutes since midnight)\n    busy = {\n        'Rachel': {\n            'Monday': [(9 * 60, 9 * 60 + 30), (11 * 60 + 30, 12 * 60 + 30), (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60), (16 * 60, 16 * 60 + 30)],\n            'Tuesday': [(11 * 60, 12 * 60), (12 * 60 + 30, 13 * 60), (16 * 60, 17 * 60)],\n            'Wednesday': [(9 * 60 + 30, 10 * 60), (12 * 60, 12 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n            'Thursday': [(10 * 60, 10 * 60 + 30), (11 * 60, 11 * 60 + 30), (14 * 60 + 30, 15 * 60), (16 * 60, 16 * 60 + 30)]\n        },\n        'Carolyn': {\n            'Monday': [(11 * 60, 14 * 60), (14 * 60 + 30, 15 * 60)],\n            'Tuesday': [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 17 * 60)],\n            'Wednesday': [(9 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 17 * 60)],\n            'Thursday': [(9 * 60, 9 * 60 + 30), (10 * 60, 13 * 60), (13 * 60 + 30, 15 * 60)]\n        }\n    }\n    \n    # Iterate through days, prioritizing non-Thursday first\n    for day in days:\n        if day in carolyn_preference_avoid:\n            continue  # Skip Thursday if possible\n        if rachel_constraints[day] is True:\n            continue  # Skip days Rachel can't meet at all\n        # Check available slots\n        for time in range(work_hours_start, work_hours_end - 30 + 1, 30):  # Check every 30 minutes\n            end_time = time + 30\n            # Check Rachel's constraints for the day\n            if rachel_constraints[day](time):\n                continue  # Skip if constraint applies\n            # Check if Rachel is free\n            rachel_busy = False\n            for start, end in busy['Rachel'][day]:\n                if not (end_time <= start or time >= end):\n                    rachel_busy = True\n                    break\n            if rachel_busy:\n                continue\n            # Check if Carolyn is free\n            carolyn_busy = False\n            for start, end in busy['Carolyn'][day]:\n                if not (end_time <= start or time >= end):\n                    carolyn_busy = True\n                    break\n            if carolyn_busy:\n                continue\n            # Found a valid time\n            return f\"{time // 60:02d}:{time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n    \n    # If no time found on non-Thursday days, check Thursday\n    day = 'Thursday'\n    if not rachel_constraints[day](0):  # Check if Rachel can meet on Thursday\n        for time in range(work_hours_start, work_hours_end - 30 + 1, 30):\n            end_time = time + 30\n            # Check Rachel's constraints for the day\n            if rachel_constraints[day](time):\n                continue\n            # Check if Rachel is free\n            rachel_busy = False\n            for start, end in busy['Rachel'][day]:\n                if not (end_time <= start or time >= end):\n                    rachel_busy = True\n                    break\n            if rachel_busy:\n                continue\n            # Check if Carolyn is free\n            carolyn_busy = False\n            for start, end in busy['Carolyn'][day]:\n                if not (end_time <= start or time >= end):\n                    carolyn_busy = True\n                    break\n            if carolyn_busy:\n                continue\n            # Found a valid time\n            return f\"{time // 60:02d}:{time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n    \n    return \"No time found\"\n\n# Output the proposed time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_829"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Define Larry's and Marilyn's schedules in minutes since midnight\n    larry_schedule = {\n        'Monday': [(9*60, 9*60 + 30), (10*60, 12*60), (13*60, 13*60 + 30), (16*60 + 30, 17*60)],\n        'Tuesday': [(9*60, 9*60 + 30), (12*60 + 30, 17*60)],\n        'Wednesday': [(9*60 + 30, 11*60), (11*60 + 30, 12*60), (13*60, 13*60 + 30), (16*60 + 30, 17*60)],\n        'Thursday': [(9*60 + 30, 10*60), (13*60 + 30, 14*60), (16*60 + 30, 17*60)]\n    }\n    \n    marilyn_schedule = {\n        'Monday': [(9*60, 10*60 + 30), (11*60 + 30, 13*60), (14*60, 14*60 + 30), (15*60, 17*60)],\n        'Tuesday': [(9*60, 11*60 + 30), (12*60, 13*60), (13*60 + 30, 14*60), (15*60, 16*60 + 30)],\n        'Wednesday': [(9*60, 12*60), (13*60, 13*60 + 30), (14*60, 14*60 + 30), (16*60, 16*60 + 30)],\n        'Thursday': [(9*60 + 30, 10*60 + 30), (12*60 + 30, 14*60 + 30), (15*60, 16*60 + 30)]\n    }\n    \n    meeting_duration = 60  # 1 hour in minutes\n    \n    # Iterate through each day to find a suitable time\n    for day in days:\n        # Get both schedules for the day\n        larry_busy = larry_schedule.get(day, [])\n        marilyn_busy = marilyn_schedule.get(day, [])\n        \n        # Combine and sort all busy intervals\n        all_busy = larry_busy + marilyn_busy\n        all_busy.sort()\n        \n        # Find free intervals by merging busy intervals\n        free_intervals = []\n        prev_end = work_hours_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_intervals.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_hours_end:\n            free_intervals.append((prev_end, work_hours_end))\n        \n        # Check each free interval for a suitable slot\n        for start, end in free_intervals:\n            available_start = start\n            available_end = end\n            \n            # Adjust for Marilyn's preference on Wednesday after 14:00\n            if day == 'Wednesday' and available_start >= 14 * 60:\n                continue\n            \n            if available_end - available_start >= meeting_duration:\n                meeting_start = available_start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_830"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to consider\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Define schedules and constraints\n    kayla_schedule = {\n        'Monday': [(16.5 * 60, 17 * 60)],\n        'Tuesday': [(10 * 60, 11 * 60), (12 * 60, 13 * 60), (16 * 60, 16.5 * 60)],\n        'Wednesday': [(9.5 * 60, 10 * 60), (11 * 60, 12.5 * 60), (15 * 60, 15.5 * 60)],\n        'Thursday': [(10 * 60, 10.5 * 60), (13 * 60, 13.5 * 60), (14.5 * 60, 15 * 60), (16 * 60, 17 * 60)]\n    }\n    \n    matthew_schedule = {\n        'Monday': [(9 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 10.5 * 60), (11 * 60, 12 * 60), (12.5 * 60, 14.5 * 60), (15.5 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 10 * 60), (10.5 * 60, 15.5 * 60), (16 * 60, 17 * 60)],\n        'Thursday': [(9 * 60, 10 * 60), (11.5 * 60, 15 * 60), (16 * 60, 16.5 * 60)]\n    }\n    \n    # Apply constraints: Kayla doesn't want Wednesday, Matthew avoids Tuesday, Thursday after 12:00\n    possible_days = []\n    for day in days:\n        if day == 'Wednesday':\n            continue  # Kayla's constraint\n        if day == 'Tuesday':\n            continue  # Matthew's constraint\n        if day == 'Thursday':\n            # Only consider before 12:00 on Thursday\n            possible_start = work_start\n            possible_end = 12 * 60\n        else:\n            possible_start = work_start\n            possible_end = work_end\n        possible_days.append((day, possible_start, possible_end))\n    \n    # Function to find available slots\n    def find_available_slots(day, start, end, duration=30):\n        # Get both schedules for the day\n        kayla_busy = kayla_schedule.get(day, [])\n        matthew_busy = matthew_schedule.get(day, [])\n        \n        # Combine and sort all busy times\n        all_busy = kayla_busy + matthew_busy\n        all_busy.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = start\n        \n        for busy_start, busy_end in all_busy:\n            if busy_start > prev_end:\n                free_slots.append((prev_end, busy_start))\n            prev_end = max(prev_end, busy_end)\n        \n        if prev_end < end:\n            free_slots.append((prev_end, end))\n        \n        # Filter slots that are at least 'duration' long\n        valid_slots = []\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= duration:\n                valid_slots.append((slot_start, slot_end))\n        \n        return valid_slots\n    \n    # Check possible days for available slots\n    for day, day_start, day_end in possible_days:\n        slots = find_available_slots(day, day_start, day_end)\n        if slots:\n            # Return the first available slot\n            slot_start, slot_end = slots[0]\n            # Convert minutes back to HH:MM format\n            start_hh = int(slot_start // 60)\n            start_mm = int(slot_start % 60)\n            end_hh = int((slot_start + 30) // 60)\n            end_mm = int((slot_start + 30) % 60)\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Execute and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_831"
        },
        {
            "final_program_time": "{15:00:16:00}",
            "expected_time": "{15:00:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to consider\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Define busy slots for Jose and Judith in minutes since midnight\n    jose_busy = {\n        'Monday': [(14 * 60 + 30, 15 * 60)],\n        'Tuesday': [(10 * 60 + 30, 11 * 60)],\n        'Thursday': [(9 * 60, 9 * 60 + 30), (13 * 60 + 30, 14 * 60)]\n    }\n    \n    judith_busy = {\n        'Monday': [(9 * 60 + 30, 10 * 60), (13 * 60, 13 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Tuesday': [(9 * 60, 9 * 60 + 30), (10 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 11 * 60 + 30), (12 * 60, 13 * 60), (13 * 60 + 30, 14 * 60), (15 * 60 + 30, 17 * 60)],\n        'Thursday': [(9 * 60, 11 * 60 + 30), (12 * 60, 13 * 60 + 30), (15 * 60, 17 * 60)]\n    }\n    \n    # Preferences\n    jose_pref = {'Wednesday': False, 'Thursday': False}\n    judith_pref = {'Monday': (15 * 60, None)}  # Only after 15:00 on Monday\n    \n    # Iterate through each day to find a suitable slot\n    for day in days:\n        # Check Jose's preference\n        if jose_pref.get(day, True) is False:\n            continue\n        \n        # Get busy slots for both participants\n        jose_slots = jose_busy.get(day, [])\n        judith_slots = judith_busy.get(day, [])\n        \n        # Combine and sort all busy slots\n        all_busy = jose_slots + judith_slots\n        all_busy.sort()\n        \n        # Check Judith's preference for Monday\n        if day == 'Monday':\n            pref_start, _ = judith_pref['Monday']\n            current_start = max(work_start, pref_start)\n        else:\n            current_start = work_start\n        \n        # Merge overlapping or adjacent busy slots\n        merged = []\n        for start, end in all_busy:\n            if not merged:\n                merged.append((start, end))\n            else:\n                last_start, last_end = merged[-1]\n                if start <= last_end:\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged[-1] = (new_start, new_end)\n                else:\n                    merged.append((start, end))\n        \n        # Check available slots\n        prev_end = current_start\n        for start, end in merged:\n            if start > prev_end:\n                available_start = prev_end\n                available_end = start\n                if available_end - available_start >= 60:  # 1 hour meeting\n                    # Format the time as HH:MM:HH:MM\n                    start_str = f\"{available_start // 60:02d}:{available_start % 60:02d}\"\n                    end_str = f\"{(available_start + 60) // 60:02d}:{(available_start + 60) % 60:02d}\"\n                    return f\"{start_str}:{end_str}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy slot\n        if work_end - prev_end >= 60:\n            start_str = f\"{prev_end // 60:02d}:{prev_end % 60:02d}\"\n            end_str = f\"{(prev_end + 60) // 60:02d}:{(prev_end + 60) % 60:02d}\"\n            return f\"{start_str}:{end_str}\"\n    \n    return \"No suitable time found\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_832"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to consider\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n\n    # Frances's schedule and constraints\n    frances_schedule = {\n        'Monday': [(11.5 * 60, 12 * 60), (13 * 60, 13.5 * 60), (14.5 * 60, 15 * 60)],\n        'Tuesday': [(9.5 * 60, 10 * 60), (10.5 * 60, 11 * 60), (12.5 * 60, 14.5 * 60), (15 * 60, 17 * 60)],\n        'Wednesday': [(10.5 * 60, 11.5 * 60), (13 * 60, 14 * 60), (14.5 * 60, 15 * 60), (15.5 * 60, 16.5 * 60)],\n        'Thursday': [(9 * 60, 10 * 60), (12.5 * 60, 13 * 60), (13.5 * 60, 14 * 60)]\n    }\n    frances_constraints = {\n        'Monday': lambda start: start + meeting_duration <= 15 * 60,  # Not after 15:00\n        'Tuesday': lambda start: False,  # Frances doesn't want to meet on Tuesday\n    }\n\n    # Hannah's schedule and constraints\n    hannah_schedule = {\n        'Monday': [(9.5 * 60, 10 * 60), (10.5 * 60, 11.5 * 60), (12 * 60, 13 * 60), (14 * 60, 16 * 60), (16.5 * 60, 17 * 60)],\n        'Tuesday': [(9.5 * 60, 10 * 60), (10.5 * 60, 11 * 60), (12 * 60, 12.5 * 60), (13 * 60, 13.5 * 60), (14.5 * 60, 16 * 60)],\n        'Wednesday': [(9 * 60, 17 * 60)],  # Entire day blocked\n        'Thursday': [(9 * 60, 10 * 60), (10.5 * 60, 17 * 60)]  # Can't meet on Thursday\n    }\n    hannah_constraints = {\n        'Thursday': lambda start: False  # Hannah can't meet on Thursday\n    }\n\n    # Iterate through each day to find a suitable time\n    for day in days:\n        # Check if day is excluded by constraints\n        if day in frances_constraints and frances_constraints[day](work_start) is False:\n            continue\n        if day in hannah_constraints and hannah_constraints[day](work_start) is False:\n            continue\n\n        # Combine both schedules for the day\n        combined_busy = []\n        if day in frances_schedule:\n            combined_busy.extend(frances_schedule[day])\n        if day in hannah_schedule:\n            combined_busy.extend(hannah_schedule[day])\n        \n        # Sort the busy intervals\n        combined_busy.sort()\n\n        # Find free slots\n        prev_end = work_start\n        for start, end in combined_busy:\n            if start > prev_end:\n                # Check if there's enough time for the meeting\n                if start - prev_end >= meeting_duration:\n                    # Check Frances's constraints for the day\n                    if day in frances_constraints and not frances_constraints[day](prev_end):\n                        prev_end = end\n                        continue\n                    # Check Hannah's constraints for the day\n                    if day in hannah_constraints and not hannah_constraints[day](prev_end):\n                        prev_end = end\n                        continue\n                    # Found a suitable time\n                    return f\"{int(prev_end // 60):02d}:{int(prev_end % 60):02d}:{int((prev_end + meeting_duration) // 60):02d}:{int((prev_end + meeting_duration) % 60):02d}\"\n            prev_end = max(prev_end, end)\n        \n        # Check the time after the last busy interval\n        if work_end - prev_end >= meeting_duration:\n            # Check Frances's constraints for the day\n            if day in frances_constraints and not frances_constraints[day](prev_end):\n                continue\n            # Check Hannah's constraints for the day\n            if day in hannah_constraints and not hannah_constraints[day](prev_end):\n                continue\n            # Found a suitable time\n            return f\"{int(prev_end // 60):02d}:{int(prev_end % 60):02d}:{int((prev_end + meeting_duration) // 60):02d}:{int((prev_end + meeting_duration) % 60):02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_833"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, days, work_hours, duration):\n    # Parse work hours\n    work_start, work_end = work_hours.split(' to ')\n    work_start = int(work_start.split(':')[0]) * 60 + int(work_start.split(':')[1])\n    work_end = int(work_end.split(':')[0]) * 60 + int(work_end.split(':')[1])\n    \n    # Iterate through each day\n    for day in days:\n        # Collect all busy intervals for the day for all participants\n        busy_intervals = []\n        for participant in participants_schedules.values():\n            if day in participant:\n                for interval in participant[day]:\n                    start, end = interval.split(' to ')\n                    start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n                    end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n                    busy_intervals.append((start_min, end_min))\n        \n        # Sort busy intervals by start time\n        busy_intervals.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        for start, end in busy_intervals:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check for a slot that can fit the meeting\n        for slot in free_slots:\n            slot_start, slot_end = slot\n            if slot_end - slot_start >= duration:\n                # Convert back to HH:MM format\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_hh = (slot_start + duration) // 60\n                end_mm = (slot_start + duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"Joseph\": {\n        \"Monday\": [\"9:00 to 9:30\", \"10:30 to 12:00\", \"12:30 to 13:30\", \"15:00 to 15:30\", \"16:30 to 17:00\"],\n        \"Tuesday\": [\"10:30 to 11:00\", \"11:30 to 13:00\", \"15:30 to 17:00\"],\n        \"Wednesday\": [\"9:00 to 10:00\", \"11:00 to 12:00\", \"12:30 to 13:00\", \"13:30 to 14:00\", \"14:30 to 15:00\", \"15:30 to 16:00\"],\n        \"Thursday\": [\"10:30 to 11:00\", \"11:30 to 12:30\", \"13:00 to 13:30\", \"15:00 to 15:30\"]\n    },\n    \"Donna\": {\n        \"Monday\": [\"9:00 to 10:30\", \"12:00 to 12:30\", \"14:00 to 15:00\", \"16:30 to 17:00\"],\n        \"Tuesday\": [\"10:30 to 11:00\", \"11:30 to 12:00\", \"12:30 to 14:00\", \"15:00 to 17:00\"],\n        \"Wednesday\": [\"9:00 to 10:30\", \"12:00 to 14:30\", \"15:30 to 16:00\", \"16:30 to 17:00\"],\n        \"Thursday\": [\"9:30 to 11:00\", \"13:00 to 14:00\", \"14:30 to 15:00\", \"16:00 to 17:00\"]\n    }\n}\n\n# Define parameters\ndays = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\"]\nwork_hours = \"9:00 to 17:00\"\nduration = 30  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, days, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_834"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to consider based on constraints\n    days = {\n        \"Monday\": {\"Virginia\": [(9*60, 10*60), (12*60, 13*60), (15*60, 15*60+30), (16*60+30, 17*60)],\n                  \"Ruth\": [(9*60, 9*60+30), (10*60, 10*60+30), (11*60, 12*60+30), (13*60+30, 14*60), (14*60+30, 17*60)]},\n        \"Tuesday\": {\"Virginia\": [(10*60+30, 11*60+30), (13*60+30, 14*60), (14*60+30, 15*60), (16*60+30, 17*60)],\n                   \"Ruth\": [(9*60, 9*60+30), (11*60+30, 13*60), (13*60+30, 15*60), (15*60+30, 16*60)]},\n        \"Wednesday\": {\"Virginia\": [(10*60+30, 11*60), (13*60+30, 14*60+30), (15*60, 15*60+30), (16*60+30, 17*60)],\n                     \"Ruth\": [(9*60, 10*60), (10*60+30, 13*60+30), (14*60, 14*60+30), (15*60, 15*60+30), (16*60, 17*60)]},\n        \"Thursday\": {\"Virginia\": [(9*60, 10*60), (10*60+30, 12*60), (13*60, 14*60), (15*60, 17*60)],\n                    \"Ruth\": [(9*60, 10*60), (10*60+30, 11*60), (12*60, 13*60+30), (14*60, 15*60), (16*60+30, 17*60)]}\n    }\n    \n    # Remove Thursday for Virginia and Monday for Ruth (preference)\n    del days[\"Thursday\"]\n    if \"Monday\" in days:\n        del days[\"Monday\"]\n    \n    # Iterate through remaining days to find the earliest available slot\n    for day in sorted(days.keys()):\n        virginia_busy = days[day][\"Virginia\"]\n        ruth_busy = days[day][\"Ruth\"]\n        \n        # Combine and sort all busy intervals for both participants\n        all_busy = virginia_busy + ruth_busy\n        all_busy.sort()\n        \n        # Find free slots by checking gaps between busy intervals\n        prev_end = work_start\n        free_slots = []\n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for a 30-minute window\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= 30:\n                meeting_start = slot_start\n                meeting_end = meeting_start + 30\n                # Convert back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_835"
        },
        {
            "final_program_time": "{15:00:16:00}",
            "expected_time": "{15:00:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Define blocked times for Melissa and Richard in minutes since midnight\n    blocked = {\n        'Melissa': {\n            'Monday': [(11*60, 11*60+30), (13*60, 13*60+30), (14*60+30, 15*60), (15*60+30, 16*60+30)],\n            'Tuesday': [(9*60+30, 10*60), (11*60+30, 12*60), (13*60, 13*60+30), (15*60, 15*60+30)],\n            'Wednesday': [(13*60+30, 14*60), (14*60+30, 15*60)],\n            'Thursday': [(9*60, 9*60+30), (10*60+30, 11*60), (13*60, 13*60+30), (15*60+30, 16*60), (16*60+30, 17*60)]\n        },\n        'Richard': {\n            'Monday': [(9*60, 10*60+30), (11*60, 12*60+30), (13*60, 13*60+30), (14*60, 15*60), (16*60, 17*60)],\n            'Tuesday': [(9*60+30, 10*60), (10*60+30, 12*60+30), (13*60+30, 14*60), (14*60+30, 15*60), (15*60+30, 17*60)],\n            'Wednesday': [(9*60, 9*60+30), (10*60, 10*60+30), (11*60, 13*60), (14*60, 15*60), (16*60, 16*60+30)],\n            'Thursday': [(9*60, 10*60), (10*60+30, 11*60), (11*60+30, 13*60), (13*60+30, 15*60), (15*60+30, 17*60)]\n        }\n    }\n    \n    # Check each day for available slots\n    for day in days:\n        # Collect all blocked times for both participants\n        melissa_blocks = blocked['Melissa'].get(day, [])\n        richard_blocks = blocked['Richard'].get(day, [])\n        all_blocks = melissa_blocks + richard_blocks\n        \n        # Sort blocks by start time\n        all_blocks.sort()\n        \n        # Find free slots by checking gaps between blocks and work hours\n        prev_end = work_start\n        for block in all_blocks:\n            start, end = block\n            if start > prev_end:\n                # Found a gap\n                gap_start = prev_end\n                gap_end = start\n                if gap_end - gap_start >= 60:  # Meeting duration is 1 hour\n                    # Convert back to HH:MM format\n                    start_hh = gap_start // 60\n                    start_mm = gap_start % 60\n                    end_hh = (gap_start + 60) // 60\n                    end_mm = (gap_start + 60) % 60\n                    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after last block\n        if work_end - prev_end >= 60:\n            start_hh = prev_end // 60\n            start_mm = prev_end % 60\n            end_hh = (prev_end + 60) // 60\n            end_mm = (prev_end + 60) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_836"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\"]\n    meeting_duration = timedelta(minutes=30)\n    \n    # Scott's schedule: day -> list of busy intervals (start, end)\n    scott_schedule = {\n        \"Monday\": [(\"09:00\", \"09:30\"), (\"15:30\", \"16:00\")],\n        \"Tuesday\": [(\"12:30\", \"13:00\"), (\"14:00\", \"14:30\")],\n        \"Wednesday\": [(\"14:30\", \"15:00\")],\n        \"Thursday\": [(\"09:00\", \"09:30\"), (\"13:30\", \"14:00\"), (\"16:00\", \"16:30\")],\n    }\n    \n    # Henry's schedule: day -> list of busy intervals (start, end)\n    henry_schedule = {\n        \"Monday\": [(\"09:00\", \"09:30\"), (\"10:00\", \"10:30\"), (\"11:00\", \"12:00\"), \n                   (\"12:30\", \"13:00\"), (\"13:30\", \"15:00\"), (\"16:00\", \"17:00\")],\n        \"Tuesday\": [(\"09:00\", \"16:30\")],\n        \"Wednesday\": [(\"09:00\", \"10:30\"), (\"11:30\", \"12:30\"), (\"13:30\", \"14:00\"), \n                      (\"14:30\", \"16:00\")],\n        \"Thursday\": [(\"10:00\", \"11:00\")],\n    }\n    \n    # Preferences and constraints\n    scott_preferences = {\n        \"Wednesday\": {\"avoid_after\": datetime.strptime(\"13:30\", \"%H:%M\")}\n    }\n    henry_constraints = {\n        \"avoid_days\": [\"Monday\", \"Tuesday\"]\n    }\n    \n    # Iterate through each day, considering constraints\n    for day in days:\n        if day in henry_constraints[\"avoid_days\"]:\n            continue\n        \n        # Get busy times for both participants on this day\n        scott_busy = scott_schedule.get(day, [])\n        henry_busy = henry_schedule.get(day, [])\n        \n        # Convert busy times to datetime objects for easier comparison\n        def parse_intervals(intervals):\n            parsed = []\n            for start, end in intervals:\n                start_time = datetime.strptime(start, \"%H:%M\")\n                end_time = datetime.strptime(end, \"%H:%M\")\n                parsed.append((start_time, end_time))\n            return parsed\n        \n        scott_busy_parsed = parse_intervals(scott_busy)\n        henry_busy_parsed = parse_intervals(henry_busy)\n        \n        # Combine and sort all busy intervals\n        all_busy = scott_busy_parsed + henry_busy_parsed\n        all_busy.sort()\n        \n        # Find available slots\n        current_time = work_start\n        available_slots = []\n        \n        for busy_start, busy_end in all_busy:\n            if busy_start > current_time:\n                available_slots.append((current_time, busy_start))\n            current_time = max(current_time, busy_end)\n        \n        if current_time < work_end:\n            available_slots.append((current_time, work_end))\n        \n        # Check each available slot for meeting duration and preferences\n        for slot_start, slot_end in available_slots:\n            slot_duration = slot_end - slot_start\n            if slot_duration >= meeting_duration:\n                # Check Scott's preference for Wednesday\n                if day == \"Wednesday\":\n                    if slot_start >= scott_preferences[\"Wednesday\"][\"avoid_after\"]:\n                        continue\n                \n                # Found a valid slot\n                meeting_end = slot_start + meeting_duration\n                return f\"{slot_start.strftime('%H:%M')}:{meeting_end.strftime('%H:%M')}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_837"
        },
        {
            "final_program_time": "{9:30:10:30}",
            "expected_time": "{9:30:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Laura's constraints: cannot meet on Monday or Tuesday\n    laura_busy = {\n        'Monday': [(14 * 60 + 30, 15 * 60)],  # 14:30-15:00\n        'Wednesday': [(12 * 60, 12 * 60 + 30)],  # 12:00-12:30\n        'Thursday': []  # No busy slots on Thursday\n    }\n    \n    # Marie's busy times\n    marie_busy = {\n        'Monday': [\n            (9 * 60, 10 * 60),  # 9:00-10:00\n            (11 * 60, 15 * 60 + 30),  # 11:00-15:30\n            (16 * 60, 17 * 60)  # 16:00-17:00\n        ],\n        'Tuesday': [\n            (9 * 60, 9 * 60 + 30),  # 9:00-9:30\n            (11 * 60 + 30, 12 * 60),  # 11:30-12:00\n            (12 * 60 + 30, 15 * 60 + 30),  # 12:30-15:30\n            (16 * 60, 16 * 60 + 30)  # 16:00-16:30\n        ],\n        'Wednesday': [\n            (9 * 60, 9 * 60 + 30),  # 9:00-9:30\n            (10 * 60 + 30, 11 * 60 + 30),  # 10:30-11:30\n            (12 * 60 + 30, 14 * 60),  # 12:30-14:00\n            (14 * 60 + 30, 15 * 60),  # 14:30-15:00\n            (15 * 60 + 30, 16 * 60 + 30)  # 15:30-16:30\n        ],\n        'Thursday': [\n            (9 * 60, 9 * 60 + 30),  # 9:00-9:30\n            (10 * 60, 11 * 60 + 30),  # 10:00-11:30\n            (12 * 60, 15 * 60 + 30),  # 12:00-15:30\n            (16 * 60, 17 * 60)  # 16:00-17:00\n        ]\n    }\n    \n    # Laura cannot meet on Monday or Tuesday, so we exclude those days\n    possible_days = ['Wednesday', 'Thursday']\n    \n    # Duration of the meeting in minutes\n    duration = 60\n    \n    for day in possible_days:\n        # Combine busy times for both participants\n        combined_busy = laura_busy.get(day, []) + marie_busy.get(day, [])\n        combined_busy.sort()  # Sort by start time\n        \n        # Find free slots\n        prev_end = work_start\n        for busy_start, busy_end in combined_busy:\n            if busy_start > prev_end:\n                # Check if the slot is long enough\n                if busy_start - prev_end >= duration:\n                    # Found a suitable slot\n                    start_time = prev_end\n                    end_time = start_time + duration\n                    return f\"{start_time//60:02d}:{start_time%60:02d}:{end_time//60:02d}:{end_time%60:02d}\"\n            prev_end = max(prev_end, busy_end)\n        \n        # Check after the last busy slot\n        if work_end - prev_end >= duration:\n            start_time = prev_end\n            end_time = start_time + duration\n            return f\"{start_time//60:02d}:{start_time%60:02d}:{end_time//60:02d}:{end_time%60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_838"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:00:11:00}",
            "type_error": "ValueError",
            "full_response": "```python\nfrom typing import List, Dict, Tuple\n\ndef parse_time(time_str: str) -> int:\n    \"\"\"Convert time string in HH:MM format to minutes since 9:00.\"\"\"\n    hh, mm = map(int, time_str.split(':'))\n    return (hh - 9) * 60 + mm\n\ndef format_time(minutes: int) -> str:\n    \"\"\"Convert minutes since 9:00 back to HH:MM format.\"\"\"\n    hh = 9 + minutes // 60\n    mm = minutes % 60\n    return f\"{hh:02d}:{mm:02d}\"\n\ndef find_available_slot(schedules: Dict[str, List[Tuple[int, int]]], duration: int, days: List[str]) -> str:\n    \"\"\"Find the earliest available slot for all participants.\"\"\"\n    work_start = parse_time(\"9:00\")\n    work_end = parse_time(\"17:00\")\n    \n    for day in days:\n        # Collect all busy intervals for the day\n        busy_intervals = []\n        for person, schedule in schedules.items():\n            for interval in schedule:\n                if interval[0] == day:\n                    start = parse_time(interval[1])\n                    end = parse_time(interval[2])\n                    busy_intervals.append((start, end))\n        \n        # Sort intervals by start time\n        busy_intervals.sort()\n        \n        # Find free slots\n        prev_end = work_start\n        for start, end in busy_intervals:\n            if start > prev_end:\n                # Check if the slot is long enough\n                if start - prev_end >= duration:\n                    slot_start = format_time(prev_end)\n                    slot_end = format_time(prev_end + duration)\n                    return f\"{day} {slot_start}:{slot_end}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy interval\n        if work_end - prev_end >= duration:\n            slot_start = format_time(prev_end)\n            slot_end = format_time(prev_end + duration)\n            return f\"{day} {slot_start}:{slot_end}\"\n    \n    return \"No available slot found\"\n\ndef main():\n    # Define schedules\n    alan_schedule = [\n        (\"Monday\", \"9:00\", \"9:30\"), (\"Monday\", \"11:00\", \"11:30\"), (\"Monday\", \"12:00\", \"12:30\"),\n        (\"Monday\", \"13:00\", \"13:30\"), (\"Monday\", \"14:00\", \"14:30\"), (\"Monday\", \"15:30\", \"16:30\"),\n        (\"Tuesday\", \"9:00\", \"10:00\"), (\"Tuesday\", \"11:30\", \"12:00\"), (\"Tuesday\", \"13:00\", \"16:00\"),\n        (\"Wednesday\", \"9:30\", \"10:00\"), (\"Wednesday\", \"15:30\", \"16:00\"), (\"Wednesday\", \"16:30\", \"17:00\"),\n        (\"Thursday\", \"9:00\", \"10:00\"), (\"Thursday\", \"11:00\", \"11:30\"), (\"Thursday\", \"12:00\", \"13:30\"),\n        (\"Thursday\", \"14:00\", \"15:30\")\n    ]\n    \n    shirley_schedule = [\n        (\"Monday\", \"9:00\", \"10:00\"), (\"Monday\", \"11:30\", \"13:30\"), (\"Monday\", \"14:00\", \"15:00\"),\n        (\"Monday\", \"16:00\", \"17:00\"), (\"Tuesday\", \"9:00\", \"10:00\"), (\"Tuesday\", \"11:00\", \"13:00\"),\n        (\"Tuesday\", \"13:30\", \"14:30\"), (\"Tuesday\", \"15:00\", \"15:30\"), (\"Tuesday\", \"16:30\", \"17:00\"),\n        (\"Wednesday\", \"10:00\", \"11:00\"), (\"Wednesday\", \"12:30\", \"13:30\"), (\"Wednesday\", \"14:00\", \"14:30\"),\n        (\"Thursday\", \"9:00\", \"10:30\"), (\"Thursday\", \"11:00\", \"11:30\"), (\"Thursday\", \"12:00\", \"14:00\"),\n        (\"Thursday\", \"14:30\", \"17:00\")\n    ]\n    \n    schedules = {\n        \"Alan\": alan_schedule,\n        \"Shirley\": shirley_schedule\n    }\n    \n    duration = 60  # 1 hour in minutes\n    days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\"]\n    \n    result = find_available_slot(schedules, duration, days)\n    day, time = result.split()\n    start, end = time.split(':')\n    print(f\"{start}:{end}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
            "count": "calendar_scheduling_example_839"
        },
        {
            "final_program_time": "{12:30:13:30}",
            "expected_time": "{12:30:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Scott's schedule: {day: list of (start, end) meetings in minutes}\n    scott_schedule = {\n        'Monday': [(9*60, 9*60+30), (11*60, 11*60+30), (12*60, 13*60+30), (15*60, 15*60+30)],\n        'Tuesday': [(10*60+30, 11*60), (11*60+30, 12*60), (12*60+30, 13*60), (13*60+30, 14*60), (14*60+30, 15*60)],\n        'Wednesday': [(9*60, 10*60), (14*60, 14*60+30), (15*60+30, 16*60+30)],\n        'Thursday': [(9*60+30, 10*60), (11*60, 12*60+30), (14*60+30, 15*60), (16*60+30, 17*60)]\n    }\n    \n    # Steven's schedule: {day: list of (start, end) blocked times in minutes}\n    steven_schedule = {\n        'Monday': [(9*60, 17*60)],\n        'Tuesday': [(9*60, 13*60), (13*60+30, 14*60+30), (15*60, 16*60+30)],\n        'Wednesday': [(9*60, 14*60+30), (15*60, 17*60)],\n        'Thursday': [(9*60+30, 12*60+30), (14*60, 15*60+30), (16*60+30, 17*60)]\n    }\n    \n    # Steven's preference: avoid Thursday after 14:00 (but his schedule already blocks it)\n    \n    # Iterate through each day to find a 1-hour slot\n    for day in days:\n        # Combine and sort all busy intervals for Scott and Steven\n        busy_intervals = []\n        \n        # Add Scott's meetings\n        if day in scott_schedule:\n            busy_intervals.extend(scott_schedule[day])\n        \n        # Add Steven's blocked times\n        if day in steven_schedule:\n            busy_intervals.extend(steven_schedule[day])\n        \n        # Sort intervals by start time\n        busy_intervals.sort()\n        \n        # Find free time between work hours\n        prev_end = work_hours_start\n        for start, end in busy_intervals:\n            if start > prev_end:\n                # Found a free slot\n                free_start = prev_end\n                free_end = start\n                if free_end - free_start >= 60:  # 1 hour available\n                    # Return the first suitable time found\n                    return f\"{free_start//60:02d}:{free_start%60:02d}:{(free_start+60)//60:02d}:{(free_start+60)%60:02d}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after last meeting\n        if prev_end < work_hours_end and work_hours_end - prev_end >= 60:\n            return f\"{prev_end//60:02d}:{prev_end%60:02d}:{(prev_end+60)//60:02d}:{(prev_end+60)%60:02d}\"\n    \n    return \"No time found\"\n\n# Execute and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_840"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    meeting_duration = 30  # minutes\n\n    # Define Susan's and Aaron's schedules\n    susan_schedule = {\n        'Monday': [(14 * 60, 14 * 60 + 30)],\n        'Tuesday': [(9 * 60 + 30, 10 * 60), (16 * 60, 16 * 60 + 30)],\n        'Wednesday': [(11 * 60, 12 * 60), (15 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Thursday': [(12 * 60, 13 * 60), (14 * 60 + 30, 15 * 60), (16 * 60 + 30, 17 * 60)],\n    }\n    aaron_schedule = {\n        'Monday': [(9 * 60, 10 * 60 + 30), (11 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 17 * 60)],\n        'Thursday': [(9 * 60, 17 * 60)],\n    }\n\n    # Iterate through each day\n    for day in days:\n        # Check Susan's preference for Monday (not after 11:00)\n        if day == 'Monday':\n            end_time = 11 * 60\n        else:\n            end_time = work_hours_end\n\n        # Generate all possible slots for the day\n        current_time = work_hours_start\n        while current_time + meeting_duration <= end_time:\n            slot_start = current_time\n            slot_end = current_time + meeting_duration\n\n            # Check Susan's availability\n            susan_available = True\n            for block in susan_schedule.get(day, []):\n                if not (slot_end <= block[0] or slot_start >= block[1]):\n                    susan_available = False\n                    break\n\n            # Check Aaron's availability\n            aaron_available = True\n            for block in aaron_schedule.get(day, []):\n                if not (slot_end <= block[0] or slot_start >= block[1]):\n                    aaron_available = False\n                    break\n\n            # If both are available, return the slot\n            if susan_available and aaron_available:\n                # Convert minutes back to HH:MM format\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_hh = slot_end // 60\n                end_mm = slot_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n            current_time += 15  # Check in 15-minute increments\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_841"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, days, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m - 540  # Subtract 540 to start from 0 (9:00)\n    \n    def minutes_to_time(minutes):\n        h = (minutes + 540) // 60\n        m = (minutes + 540) % 60\n        return f\"{h:02d}:{m:02d}\"\n    \n    # Initialize the free slots for each day\n    free_slots = {}\n    for day in days:\n        day_start = time_to_minutes(work_hours[0])\n        day_end = time_to_minutes(work_hours[1])\n        free_slots[day] = [(day_start, day_end)]\n    \n    # Process each participant's schedule\n    for participant, schedule in participants_schedules.items():\n        for day, blocks in schedule.items():\n            if day not in free_slots:\n                continue\n            # Convert blocks to minutes and sort\n            blocked_times = []\n            for block in blocks:\n                start, end = map(time_to_minutes, block.split(' to '))\n                blocked_times.append((start, end))\n            blocked_times.sort()\n            \n            # Subtract blocked times from free slots\n            current_free = free_slots[day].copy()\n            new_free = []\n            for free_start, free_end in current_free:\n                current_start = free_start\n                for block_start, block_end in blocked_times:\n                    if block_start >= free_end:\n                        break\n                    if block_end <= current_start:\n                        continue\n                    if block_start > current_start:\n                        new_free.append((current_start, block_start))\n                    current_start = max(current_start, block_end)\n                if current_start < free_end:\n                    new_free.append((current_start, free_end))\n            free_slots[day] = new_free\n    \n    # Find the earliest available slot across all days\n    for day in days:\n        for slot in free_slots[day]:\n            slot_duration = slot[1] - slot[0]\n            if slot_duration >= duration:\n                start_time = minutes_to_time(slot[0])\n                end_time = minutes_to_time(slot[0] + duration)\n                return f\"{start_time}:{end_time}\"\n    return \"No available slot found\"\n\n# Define the problem parameters\nparticipants_schedules = {\n    \"Ashley\": {\n        \"Monday\": [\"9:00 to 9:30\", \"10:00 to 11:30\", \"13:30 to 14:00\", \"15:00 to 15:30\", \"16:00 to 16:30\"],\n        \"Tuesday\": [\"9:30 to 11:00\", \"14:00 to 14:30\", \"16:30 to 17:00\"],\n        \"Wednesday\": [\"9:00 to 10:00\", \"11:00 to 12:30\", \"13:00 to 13:30\", \"14:30 to 15:00\", \"15:30 to 16:30\"],\n        \"Thursday\": [\"9:00 to 10:00\", \"12:30 to 13:30\", \"14:30 to 15:00\"]\n    },\n    \"Gloria\": {\n        \"Monday\": [\"9:00 to 17:00\"],\n        \"Tuesday\": [\"10:00 to 11:00\", \"11:30 to 12:00\", \"13:00 to 16:00\", \"16:30 to 17:00\"],\n        \"Wednesday\": [\"9:00 to 10:00\", \"11:00 to 11:30\", \"12:00 to 12:30\", \"13:30 to 16:30\"],\n        \"Thursday\": [\"9:00 to 11:00\", \"12:00 to 14:00\", \"14:30 to 16:00\", \"16:30 to 17:00\"]\n    }\n}\nwork_hours = (\"9:00\", \"17:00\")\ndays = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\"]\nduration = 60  # minutes\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, days, duration))\n```",
            "count": "calendar_scheduling_example_842"
        },
        {
            "final_program_time": "{11:00:12:00}",
            "expected_time": "{11:00:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Define busy times for each participant per day in minutes since midnight\n    cynthia_busy = {\n        'Monday': [(10 * 60, 10 * 60 + 30)],\n        'Wednesday': [(9 * 60 + 30, 10 * 60)],\n        'Thursday': [(10 * 60 + 30, 11 * 60), (12 * 60, 12 * 60 + 30)],\n        'Tuesday': []\n    }\n    \n    willie_busy = {\n        'Monday': [(9 * 60 + 30, 11 * 60), (12 * 60, 14 * 60), (16 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 11 * 60), (12 * 60 + 30, 16 * 60 + 30)],\n        'Wednesday': [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60 + 30), (12 * 60, 14 * 60 + 30), (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Thursday': [(9 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60 + 30), (13 * 60 + 30, 15 * 60 + 30)],\n    }\n    \n    # Duration of the meeting in minutes\n    duration = 60\n    \n    for day in days:\n        # Collect all busy intervals for the day\n        busy_intervals = cynthia_busy.get(day, []) + willie_busy.get(day, [])\n        busy_intervals.sort()\n        \n        # Merge overlapping or adjacent intervals\n        merged = []\n        for start, end in busy_intervals:\n            if not merged:\n                merged.append((start, end))\n            else:\n                last_start, last_end = merged[-1]\n                if start <= last_end:\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged[-1] = (new_start, new_end)\n                else:\n                    merged.append((start, end))\n        \n        # Check the time before the first busy interval\n        if not merged:\n            meeting_start = work_start\n            meeting_end = meeting_start + duration\n            if meeting_end <= work_end:\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n        \n        first_start, first_end = merged[0]\n        if work_start + duration <= first_start:\n            meeting_start = work_start\n            meeting_end = meeting_start + duration\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n        \n        # Check the time between busy intervals\n        for i in range(1, len(merged)):\n            prev_end = merged[i-1][1]\n            current_start = merged[i][0]\n            if prev_end + duration <= current_start:\n                meeting_start = prev_end\n                meeting_end = meeting_start + duration\n                if meeting_end <= work_end:\n                    return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n        \n        # Check the time after the last busy interval\n        last_start, last_end = merged[-1] if merged else (work_start, work_start)\n        if last_end + duration <= work_end:\n            meeting_start = last_end\n            meeting_end = meeting_start + duration\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No meeting time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_843"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Define blocked times for Christopher and Deborah in minutes since midnight\n    blocked = {\n        'Christopher': {\n            'Monday': [(10*60, 10*60+30), (11*60, 11*60+30), (12*60+30, 13*60), (16*60, 16*60+30)],\n            'Tuesday': [(9*60, 10*60), (10*60+30, 11*60), (11*60+30, 12*60), (12*60+30, 13*60), (13*60+30, 15*60+30), (16*60+30, 17*60)],\n            'Wednesday': [(10*60, 10*60+30), (11*60, 11*60+30), (13*60, 14*60), (14*60+30, 15*60), (15*60+30, 16*60), (16*60+30, 17*60)],\n            'Thursday': [(10*60+30, 11*60+30), (16*60, 16*60+30)],\n        },\n        'Deborah': {\n            'Monday': [(9*60, 17*60)],\n            'Tuesday': [(9*60, 10*60+30), (11*60+30, 13*60), (14*60+30, 15*60+30), (16*60, 17*60)],\n            'Wednesday': [(9*60, 11*60+30), (13*60, 13*60+30), (14*60, 15*60), (15*60+30, 16*60), (16*60+30, 17*60)],\n            'Thursday': [(9*60+30, 10*60), (10*60+30, 13*60), (13*60+30, 16*60+30)],\n        }\n    }\n    \n    # Check each day for available slots\n    for day in days:\n        # Collect all blocked intervals for both participants\n        christopher_blocks = blocked['Christopher'].get(day, [])\n        deborah_blocks = blocked['Deborah'].get(day, [])\n        all_blocks = christopher_blocks + deborah_blocks\n        \n        # Sort blocks by start time\n        all_blocks.sort()\n        \n        # Find free intervals\n        free_intervals = []\n        prev_end = work_start\n        \n        for start, end in all_blocks:\n            if start > prev_end:\n                free_intervals.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_intervals.append((prev_end, work_end))\n        \n        # Check for a 60-minute slot\n        for start, end in free_intervals:\n            if end - start >= 60:\n                meeting_start = start\n                meeting_end = meeting_start + 60\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_844"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n\n    # Anna's busy times in minutes since midnight for each day\n    anna_busy = {\n        'Monday': [(10 * 60 + 30, 11 * 60), (12 * 60 + 30, 13 * 60), (14 * 60, 14 * 60 + 30)],\n        'Tuesday': [(10 * 60 + 30, 11 * 60), (13 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Wednesday': [(10 * 60, 10 * 60 + 30), (12 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n        'Thursday': [(10 * 60 + 30, 11 * 60), (12 * 60, 13 * 60), (16 * 60, 16 * 60 + 30)]\n    }\n\n    # Christian's busy times in minutes since midnight for each day\n    christian_busy = {\n        'Monday': [(9 * 60, 13 * 60), (13 * 60 + 30, 16 * 60 + 30)],\n        'Tuesday': [(9 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 17 * 60)],\n        'Thursday': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (11 * 60 + 30, 14 * 60 + 30), (16 * 60, 17 * 60)]\n    }\n\n    for day in days:\n        # Collect all busy intervals for both participants\n        busy_intervals = []\n        # Add Anna's busy times\n        busy_intervals.extend(anna_busy.get(day, []))\n        # Add Christian's busy times\n        busy_intervals.extend(christian_busy.get(day, []))\n        # Sort all busy intervals by start time\n        busy_intervals.sort()\n\n        # Find free slots by checking gaps between busy intervals\n        prev_end = work_start\n        free_slots = []\n        for start, end in busy_intervals:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        # Check after last busy interval\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n\n        # Check each free slot for availability of meeting duration\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= meeting_duration:\n                # Found a suitable slot\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                # Convert to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_845"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Define busy slots for each participant per day in minutes since midnight\n    jesse_busy = {\n        'Monday': [(12 * 60, 12 * 60 + 30), (14 * 60 + 30, 15 * 60 + 30)],\n        'Wednesday': [(13 * 60, 13 * 60 + 30)],\n        'Thursday': [(9 * 60 + 30, 10 * 60), (11 * 60, 11 * 60 + 30), (12 * 60 + 30, 13 * 60), (14 * 60 + 30, 15 * 60)],\n    }\n    \n    raymond_busy = {\n        'Monday': [(9 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 13 * 60), (14 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 17 * 60)],\n        'Thursday': [(9 * 60, 17 * 60)],\n    }\n    \n    meeting_duration = 60  # minutes\n    \n    # Iterate through each day to find a suitable time\n    for day in days:\n        # Check if Raymond is entirely busy on this day\n        raymond_day_busy = raymond_busy.get(day, [])\n        if raymond_day_busy and (raymond_day_busy[0][0] <= work_start and raymond_day_busy[0][1] >= work_end):\n            continue  # Raymond is busy all day\n        \n        # Get Jesse's busy slots for the day\n        jesse_day_busy = jesse_busy.get(day, [])\n        \n        # Combine and sort all busy slots for the day\n        busy_slots = []\n        \n        # Add Raymond's busy slots (he's only available if not entirely busy)\n        if day in raymond_busy:\n            for slot in raymond_busy[day]:\n                busy_slots.append(slot)\n        \n        # Add Jesse's busy slots\n        if day in jesse_busy:\n            for slot in jesse_busy[day]:\n                busy_slots.append(slot)\n        \n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Find available slots by checking gaps between busy slots and work hours\n        available_slots = []\n        prev_end = work_start\n        \n        for slot in busy_slots:\n            if slot[0] > prev_end:\n                available_slots.append((prev_end, slot[0]))\n            prev_end = max(prev_end, slot[1])\n        \n        # Check after last busy slot\n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n        \n        # Check each available slot for enough duration\n        for slot in available_slots:\n            start, end = slot\n            if end - start >= meeting_duration:\n                # Found a suitable slot\n                meeting_start = start\n                meeting_end = meeting_start + meeting_duration\n                # Format as HH:MM:HH:MM\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No time found\"  # Shouldn't happen as per problem statement\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_846"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    meeting_duration = 60  # minutes\n    \n    # Define blocked times for each person in minutes since midnight\n    bradley_blocked = {\n        'Monday': [(9*60, 9*60+30), (10*60+30, 11*60), (12*60, 13*60), (14*60, 14*60+30)],\n        'Tuesday': [(9*60+30, 10*60), (11*60, 11*60+30), (13*60+30, 14*60), (16*60, 16*60+30)],\n        'Wednesday': [(11*60, 11*60+30), (12*60, 12*60+30), (13*60, 14*60), (16*60, 16*60+30)],\n        'Thursday': [(9*60, 9*60+30), (10*60, 11*60), (11*60+30, 12*60), (12*60+30, 13*60), (14*60+30, 17*60)]\n    }\n    \n    bruce_blocked = {\n        'Monday': [(9*60, 9*60+30), (10*60, 17*60)],\n        'Tuesday': [(9*60+30, 14*60), (15*60, 17*60)],\n        'Wednesday': [(10*60, 10*60+30), (12*60+30, 13*60+30), (14*60+30, 16*60), (16*60+30, 17*60)],\n        'Thursday': [(12*60+30, 14*60+30), (15*60, 15*60+30), (16*60, 17*60)]\n    }\n    \n    # Iterate through each day to find the earliest available slot\n    for day in days:\n        # Collect all blocked times for both participants\n        all_blocked = bradley_blocked.get(day, []) + bruce_blocked.get(day, [])\n        all_blocked.sort()\n        \n        # Find available slots\n        available_slots = []\n        prev_end = work_start\n        \n        for start, end in all_blocked:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n        \n        # Check each available slot for a meeting duration\n        for slot in available_slots:\n            slot_start, slot_end = slot\n            if slot_end - slot_start >= meeting_duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_847"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to consider\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Larry's constraints: doesn't want to meet on Monday or Wednesday after 13:00\n    # Kenneth's constraints: can't meet on Tuesday\n    \n    # Larry's busy times in minutes since midnight\n    larry_busy = {\n        'Monday': [(9*60+30, 10*60), (10*60+30, 11*60+30), (14*60, 14*60+30),\n                   (15*60, 15*60+30), (16*60, 16*60+30)],\n        'Tuesday': [(9*60+30, 10*60+30), (11*60, 11*60+30), (13*60, 14*60),\n                    (15*60, 16*60), (16*60+30, 17*60)],\n        'Wednesday': [(10*60, 11*60), (11*60+30, 12*60), (15*60, 15*60+30)],\n        'Thursday': [(9*60+30, 12*60+30), (13*60, 14*60), (14*60+30, 15*60),\n                     (15*60+30, 17*60)]\n    }\n    \n    # Kenneth's busy times in minutes since midnight\n    kenneth_busy = {\n        'Monday': [(9*60, 11*60+30), (12*60, 17*60)],\n        'Tuesday': [(9*60, 10*60), (12*60, 14*60), (14*60+30, 16*60+30)],\n        'Wednesday': [(9*60, 10*60), (11*60+30, 14*60), (14*60+30, 15*60+30),\n                       (16*60, 17*60)],\n        'Thursday': [(9*60, 17*60)]\n    }\n    \n    # Iterate through each day, considering constraints\n    for day in days:\n        if day == 'Monday':\n            continue  # Larry doesn't want to meet on Monday\n        if day == 'Tuesday':\n            continue  # Kenneth can't meet on Tuesday\n        \n        # Get busy times for both participants on this day\n        larry_day = larry_busy.get(day, [])\n        kenneth_day = kenneth_busy.get(day, [])\n        \n        # Combine and sort all busy intervals\n        all_busy = larry_day + kenneth_day\n        all_busy.sort()\n        \n        # Find free intervals\n        free_intervals = []\n        prev_end = work_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_intervals.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_intervals.append((prev_end, work_end))\n        \n        # Check for a 30-minute slot in free intervals\n        for start, end in free_intervals:\n            duration = end - start\n            if duration >= 30:\n                # Check Wednesday after 13:00 constraint for Larry\n                if day == 'Wednesday' and start >= 13 * 60:\n                    continue\n                meeting_start = start\n                meeting_end = start + 30\n                return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n    \n    return \"No time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_848"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    meeting_duration = 30  # minutes\n    \n    # Define busy slots for each person in minutes since midnight\n    janice_busy = {\n        'Monday': [(10 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60), (14 * 60 + 30, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n        'Tuesday': [(10 * 60 + 30, 11 * 60), (13 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n        'Wednesday': [(9 * 60 + 30, 10 * 60 + 30)],\n        'Thursday': [(9 * 60, 9 * 60 + 30), (11 * 60, 11 * 60 + 30), (16 * 60, 16 * 60 + 30)]\n    }\n    \n    sharon_busy = {\n        'Monday': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (11 * 60, 15 * 60), (15 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60 + 30, 10 * 60 + 30), (11 * 60, 12 * 60), (12 * 60 + 30, 13 * 60 + 30), (15 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Wednesday': [(9 * 60, 11 * 60), (11 * 60 + 30, 12 * 60), (13 * 60, 15 * 60), (15 * 60 + 30, 17 * 60)],\n        'Thursday': [(9 * 60, 17 * 60)]\n    }\n    \n    # Preferences: Janice avoids Tuesday after 13:30, Sharon avoids Monday and Wednesday\n    preferred_days = ['Tuesday', 'Thursday']  # Exclude Monday and Wednesday per Sharon, and Thursday is fully booked for Sharon\n    \n    # Iterate through each day to find a suitable time\n    for day in preferred_days:\n        if day == 'Thursday':\n            continue  # Sharon is busy all day on Thursday\n        \n        # Generate all possible time slots for the day\n        time_slots = []\n        current_time = work_hours_start\n        while current_time + meeting_duration <= work_hours_end:\n            time_slots.append((current_time, current_time + meeting_duration))\n            current_time += 15  # Check every 15 minutes for a slot\n        \n        # Check each time slot for availability\n        for start, end in time_slots:\n            # Check Janice's availability\n            janice_available = True\n            for busy_start, busy_end in janice_busy.get(day, []):\n                if not (end <= busy_start or start >= busy_end):\n                    janice_available = False\n                    break\n            if not janice_available:\n                continue\n            \n            # Check Sharon's availability\n            sharon_available = True\n            for busy_start, busy_end in sharon_busy.get(day, []):\n                if not (end <= busy_start or start >= busy_end):\n                    sharon_available = False\n                    break\n            if not sharon_available:\n                continue\n            \n            # Check Janice's preference to avoid Tuesday after 13:30\n            if day == 'Tuesday' and start >= 13 * 60 + 30:\n                continue\n            \n            # If all checks passed, return the time slot\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = end // 60\n            end_mm = end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    # If no slot found in preferred days, check other days (though per constraints, solution exists)\n    for day in days:\n        if day in preferred_days:\n            continue  # Already checked\n        \n        # Generate all possible time slots for the day\n        time_slots = []\n        current_time = work_hours_start\n        while current_time + meeting_duration <= work_hours_end:\n            time_slots.append((current_time, current_time + meeting_duration))\n            current_time += 15\n        \n        # Check each time slot for availability\n        for start, end in time_slots:\n            # Check Janice's availability\n            janice_available = True\n            for busy_start, busy_end in janice_busy.get(day, []):\n                if not (end <= busy_start or start >= busy_end):\n                    janice_available = False\n                    break\n            if not janice_available:\n                continue\n            \n            # Check Sharon's availability\n            sharon_available = True\n            for busy_start, busy_end in sharon_busy.get(day, []):\n                if not (end <= busy_start or start >= busy_end):\n                    sharon_available = False\n                    break\n            if not sharon_available:\n                continue\n            \n            # Return the time slot\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = end // 60\n            end_mm = end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No time slot found\"  # Should not reach here per problem statement\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_849"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to consider\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n\n    # Nicholas's schedule: {day: [(start, end), ...]}\n    nicholas_schedule = {\n        'Monday': [(9 * 60, 9 * 60 + 30), (14 * 60, 14 * 60 + 30)],\n        'Thursday': [(9 * 60 + 30, 10 * 60), (11 * 60 + 30, 12 * 60), (13 * 60, 13 * 60 + 30), (16 * 60 + 30, 17 * 60)]\n    }\n\n    # Virginia's schedule: {day: [(start, end), ...]}\n    virginia_schedule = {\n        'Monday': [(9 * 60, 10 * 60 + 30), (11 * 60, 12 * 60 + 30), (14 * 60, 16 * 60 + 30)],\n        'Tuesday': [(9 * 60, 11 * 60), (11 * 60 + 30, 17 * 60)],\n        'Wednesday': [(9 * 60, 17 * 60)],\n        'Thursday': [(9 * 60, 17 * 60)]\n    }\n\n    # Iterate through each day, avoiding Monday if possible\n    preferred_days = ['Tuesday', 'Wednesday', 'Thursday', 'Monday']\n    for day in preferred_days:\n        # Get both schedules for the day\n        nicholas_busy = nicholas_schedule.get(day, [])\n        virginia_busy = virginia_schedule.get(day, [])\n\n        # Merge and sort all busy intervals for both participants\n        all_busy = nicholas_busy + virginia_busy\n        all_busy.sort()\n\n        # Find free slots by checking gaps between busy intervals\n        prev_end = work_start\n        for start, end in all_busy:\n            if start > prev_end:\n                # Check if the gap is enough for the meeting\n                if start - prev_end >= meeting_duration:\n                    # Found a suitable slot\n                    meeting_start = prev_end\n                    meeting_end = meeting_start + meeting_duration\n                    # Format the time as HH:MM:HH:MM\n                    return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n            prev_end = max(prev_end, end)\n\n        # Check the slot after the last busy interval\n        if work_end - prev_end >= meeting_duration:\n            meeting_start = prev_end\n            meeting_end = meeting_start + meeting_duration\n            return f\"{meeting_start // 60:02d}:{meeting_end // 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_850"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to check\n    days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\"]\n    \n    # Thomas's schedule: day -> list of busy intervals in minutes\n    thomas_busy = {\n        \"Monday\": [(11 * 60, 11 * 60 + 30), (12 * 60 + 30, 13 * 60), (15 * 60, 15 * 60 + 30)],\n        \"Tuesday\": [(16 * 60 + 30, 17 * 60)],\n        \"Wednesday\": [(10 * 60, 10 * 60 + 30), (14 * 60 + 30, 15 * 60)],\n        \"Thursday\": [(15 * 60, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n    }\n    \n    # Gary's schedule: day -> list of busy intervals in minutes\n    gary_busy = {\n        \"Monday\": [(9 * 60, 17 * 60)],\n        \"Tuesday\": [(9 * 60, 10 * 60 + 30), (11 * 60, 11 * 60 + 30), (12 * 60, 17 * 60)],\n        \"Wednesday\": [(9 * 60, 17 * 60)],\n        \"Thursday\": [(9 * 60, 17 * 60)],\n    }\n    \n    # Thomas's preference: avoid Tuesday before 11:30\n    thomas_preference = (\"Tuesday\", 11 * 60 + 30)\n    \n    meeting_duration = 30  # minutes\n    \n    # Iterate through each day\n    for day in days:\n        # Skip Tuesday before 11:30 if it's Tuesday\n        if day == \"Tuesday\":\n            start_time = max(work_start, thomas_preference[1])\n        else:\n            start_time = work_start\n        \n        # Generate all possible 30-minute slots in the day\n        current_time = start_time\n        while current_time + meeting_duration <= work_end:\n            slot_start = current_time\n            slot_end = current_time + meeting_duration\n            \n            # Check if the slot is free for Thomas\n            thomas_free = True\n            for busy_start, busy_end in thomas_busy.get(day, []):\n                if not (slot_end <= busy_start or slot_start >= busy_end):\n                    thomas_free = False\n                    break\n            \n            # Check if the slot is free for Gary\n            gary_free = True\n            for busy_start, busy_end in gary_busy.get(day, []):\n                if not (slot_end <= busy_start or slot_start >= busy_end):\n                    gary_free = False\n                    break\n            \n            # If both are free, return the slot\n            if thomas_free and gary_free:\n                # Format the time as HH:MM:HH:MM\n                start_str = f\"{slot_start // 60:02d}:{slot_start % 60:02d}\"\n                end_str = f\"{slot_end // 60:02d}:{slot_end % 60:02d}\"\n                return f\"{start_str}:{end_str}\"\n            \n            current_time += 15  # Check next 15-minute interval (can be adjusted for granularity)\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_851"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to consider (Monday=0, Tuesday=1, Wednesday=2, Thursday=3)\n    days = [1, 2, 3]  # Randy doesn't want Monday\n    \n    # Randy's busy times in minutes since midnight for each day\n    randy_busy = {\n        1: [  # Tuesday\n            (10 * 60, 11 * 60 + 30),\n            (12 * 60 + 30, 13 * 60),\n            (15 * 60, 15 * 60 + 30),\n            (16 * 60, 17 * 60)\n        ],\n        2: [  # Wednesday\n            (10 * 60 + 30, 11 * 60),\n            (11 * 60 + 30, 12 * 60),\n            (13 * 60, 13 * 60 + 30),\n            (15 * 60 + 30, 16 * 60)\n        ],\n        3: [  # Thursday\n            (9 * 60 + 30, 10 * 60),\n            (10 * 60 + 30, 11 * 60),\n            (12 * 60, 13 * 60 + 30),\n            (16 * 60 + 30, 17 * 60)\n        ]\n    }\n    \n    # Maria's busy times in minutes since midnight for each day\n    maria_busy = {\n        1: [  # Tuesday - Maria is busy all day\n            (9 * 60, 17 * 60)\n        ],\n        2: [  # Wednesday\n            (9 * 60 + 30, 10 * 60),\n            (10 * 60 + 30, 12 * 60),\n            (14 * 60 + 30, 15 * 60 + 30),\n            (16 * 60, 17 * 60)\n        ],\n        3: [  # Thursday\n            (9 * 60 + 30, 10 * 60),\n            (11 * 60 + 30, 12 * 60 + 30),\n            (13 * 60 + 30, 15 * 60),\n            (16 * 60 + 30, 17 * 60)\n        ]\n    }\n    \n    # Meeting duration in minutes\n    duration = 30\n    \n    # Iterate through each day\n    for day in days:\n        # Skip Wednesday after 13:30 for Maria\n        if day == 2:\n            maria_max_time = 13 * 60 + 30\n        else:\n            maria_max_time = work_end\n        \n        # Generate all possible slots for the day\n        slots = []\n        current_time = work_start\n        while current_time + duration <= min(work_end, maria_max_time):\n            slots.append((current_time, current_time + duration))\n            current_time += 30  # Check every 30 minutes\n        \n        # Check each slot for availability\n        for slot_start, slot_end in slots:\n            # Check Randy's availability\n            randy_available = True\n            for busy_start, busy_end in randy_busy.get(day, []):\n                if not (slot_end <= busy_start or slot_start >= busy_end):\n                    randy_available = False\n                    break\n            \n            if not randy_available:\n                continue\n            \n            # Check Maria's availability\n            maria_available = True\n            for busy_start, busy_end in maria_busy.get(day, []):\n                if not (slot_end <= busy_start or slot_start >= busy_end):\n                    maria_available = False\n                    break\n            \n            if maria_available:\n                # Convert minutes back to HH:MM format\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_hh = slot_end // 60\n                end_mm = slot_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_852"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # James's schedule: {day: [(start1, end1), (start2, end2), ...]}\n    james_schedule = {\n        'Monday': [(9*60, 10*60), (11.5*60, 12*60), (13*60, 15*60), (15.5*60, 16.5*60)],\n        'Tuesday': [(13*60, 13.5*60), (14*60, 14.5*60)],\n        'Wednesday': [(9.5*60, 10.5*60), (11*60, 14*60), (15*60, 15.5*60), (16.5*60, 17*60)],\n        'Thursday': [(10*60, 10.5*60), (11*60, 12*60), (14*60, 15*60), (15.5*60, 16*60), (16.5*60, 17*60)]\n    }\n    \n    # Gabriel's schedule\n    gabriel_schedule = {\n        'Monday': [(9*60, 14.5*60), (15*60, 17*60)],\n        'Tuesday': [(9*60, 15*60), (15.5*60, 17*60)],\n        'Wednesday': [(9*60, 17*60)],\n        'Thursday': [(9.5*60, 13.5*60), (14*60, 17*60)]\n    }\n    \n    # Constraints\n    james_no_tuesday = True\n    gabriel_no_thursday_before_11 = True\n    \n    # Iterate through each day to find a suitable time\n    for day in days:\n        if day == 'Tuesday' and james_no_tuesday:\n            continue\n        \n        # Get both schedules for the day\n        james_busy = james_schedule.get(day, [])\n        gabriel_busy = gabriel_schedule.get(day, [])\n        \n        # Combine and sort all busy intervals\n        all_busy = james_busy + gabriel_busy\n        all_busy.sort()\n        \n        # Find free intervals\n        free_intervals = []\n        prev_end = work_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_intervals.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_intervals.append((prev_end, work_end))\n        \n        # Check each free interval for a 30-minute slot\n        for start, end in free_intervals:\n            duration_needed = 30\n            if end - start >= duration_needed:\n                # Check Gabriel's Thursday constraint\n                if day == 'Thursday' and gabriel_no_thursday_before_11:\n                    if start >= 11 * 60:\n                        return f\"{int(start//60):02d}:{int(start%60):02d}:{int((start + duration_needed)//60):02d}:{int((start + duration_needed)%60):02d}\"\n                else:\n                    if day != 'Thursday':\n                        return f\"{int(start//60):02d}:{int(start%60):02d}:{int((start + duration_needed)//60):02d}:{int((start + duration_needed)%60):02d}\"\n    \n    return \"No time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_853"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to consider\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Michelle's busy times in minutes since start of day\n    michelle_busy = {\n        'Monday': [(11*60, 11*60+30), (16*60, 16*60+30)],\n        'Tuesday': [(10*60, 11*60), (11*60+30, 12*60+30), (14*60, 15*60), (15*60+30, 16*60)],\n        'Wednesday': [(10*60+30, 11*60), (11*60+30, 13*60), (13*60+30, 15*60), (16*60+30, 17*60)],\n        'Thursday': [(9*60+30, 10*60+30), (12*60, 12*60+30), (13*60, 13*60+30), (15*60+30, 17*60)]\n    }\n    \n    # Sara's busy times in minutes since start of day\n    sara_busy = {\n        'Monday': [(9*60, 11*60+30), (12*60, 12*60+30), (13*60, 13*60+30), (14*60, 17*60)],\n        'Tuesday': [(10*60+30, 11*60+30), (12*60, 12*60+30), (13*60, 13*60+30), (14*60, 15*60)],\n        'Wednesday': [(9*60, 12*60+30), (13*60, 14*60+30), (15*60, 16*60)],\n        'Thursday': [(9*60, 11*60), (11*60+30, 12*60+30), (13*60+30, 14*60), (15*60, 17*60)]\n    }\n    \n    # Preferences: Michelle avoids Wednesday, Sara prefers not Monday or Tuesday\n    preferred_days_order = ['Thursday', 'Tuesday', 'Monday', 'Wednesday']\n    \n    meeting_duration = 30  # minutes\n    \n    for day in preferred_days_order:\n        # Get busy intervals for both participants\n        michelle_busy_today = michelle_busy.get(day, [])\n        sara_busy_today = sara_busy.get(day, [])\n        \n        # Combine and sort all busy intervals\n        all_busy = michelle_busy_today + sara_busy_today\n        all_busy.sort()\n        \n        # Find free slots\n        prev_end = work_start\n        free_slots = []\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy interval\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Find first suitable slot\n        for start, end in free_slots:\n            slot_duration = end - start\n            if slot_duration >= meeting_duration:\n                meeting_start = start\n                meeting_end = meeting_start + meeting_duration\n                # Format as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_854"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to consider\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n\n    # Andrea's busy times in minutes since midnight for each day\n    andrea_busy = {\n        'Monday': [(11*60 + 30, 12*60), (12*60 + 30, 13*60), (13*60 + 30, 14*60), (15*60, 16*60), (16*60 + 30, 17*60)],\n        'Tuesday': [(11*60 + 30, 12*60), (12*60 + 30, 13*60)],\n        'Wednesday': [(11*60 + 30, 12*60), (12*60 + 30, 13*60), (14*60 + 30, 17*60)],\n        'Thursday': [(10*60 + 30, 11*60), (12*60 + 30, 13*60), (16*60, 16*60 + 30)]\n    }\n\n    # Russell's busy times in minutes since midnight for each day\n    russell_busy = {\n        'Monday': [(9*60, 15*60 + 30), (16*60, 17*60)],\n        'Tuesday': [(9*60 + 30, 11*60), (11*60 + 30, 12*60), (12*60 + 30, 13*60), (14*60, 17*60)],\n        'Wednesday': [(9*60, 9*60 + 30), (10*60 + 30, 11*60), (11*60 + 30, 15*60), (15*60 + 30, 16*60), (16*60 + 30, 17*60)],\n        'Thursday': [(9*60, 10*60), (11*60 + 30, 17*60)]\n    }\n\n    # Russell's preferences: not Tuesday, not Wednesday, not Thursday after 11:00\n    # So we can only consider Monday or Thursday before 11:00\n    possible_days = ['Monday', 'Thursday']\n\n    for day in possible_days:\n        if day == 'Thursday':\n            # On Thursday, Russell is only available before 11:00\n            day_end = 11 * 60\n        else:\n            day_end = work_end\n\n        # Generate all possible time slots for the day\n        for start_time in range(work_start, day_end - meeting_duration + 1, 15):\n            end_time = start_time + meeting_duration\n            if end_time > day_end:\n                continue\n\n            # Check Andrea's availability\n            andrea_available = True\n            for busy_start, busy_end in andrea_busy[day]:\n                if not (end_time <= busy_start or start_time >= busy_end):\n                    andrea_available = False\n                    break\n            if not andrea_available:\n                continue\n\n            # Check Russell's availability\n            russell_available = True\n            for busy_start, busy_end in russell_busy[day]:\n                if not (end_time <= busy_start or start_time >= busy_end):\n                    russell_available = False\n                    break\n            if not russell_available:\n                continue\n\n            # If both are available, return this time slot\n            start_hh = start_time // 60\n            start_mm = start_time % 60\n            end_hh = end_time // 60\n            end_mm = end_time % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_855"
        },
        {
            "final_program_time": "{15:00:16:00}",
            "expected_time": "{15:00:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Define busy times for Dennis and William in minutes since midnight\n    dennis_busy = {\n        'Monday': [(9*60, 9*60+30), (10*60+30, 11*60), (11*60+30, 12*60+30),\n                   (13*60+30, 14*60+30), (15*60, 15*60+30)],\n        'Tuesday': [(10*60, 10*60+30), (11*60, 12*60), (13*60, 13*60+30),\n                    (14*60, 14*60+30), (16*60, 16*60+30)],\n        'Wednesday': [(9*60+30, 10*60), (10*60+30, 11*60), (13*60, 13*60+30),\n                      (14*60, 15*60), (16*60+30, 17*60)],\n        'Thursday': [(9*60+30, 10*60), (10*60+30, 12*60), (13*60, 14*60+30),\n                     (15*60+30, 16*60+30)]\n    }\n    \n    william_busy = {\n        'Monday': [(9*60, 17*60)],\n        'Tuesday': [(9*60, 12*60), (12*60+30, 15*60+30), (16*60, 17*60)],\n        'Wednesday': [(9*60, 11*60+30), (12*60, 12*60+30), (13*60, 15*60),\n                      (16*60, 17*60)],\n        'Thursday': [(9*60, 17*60)]\n    }\n    \n    # Iterate through each day to find a suitable time\n    for day in days:\n        # Combine and sort all busy intervals for both participants\n        all_busy = dennis_busy.get(day, []) + william_busy.get(day, [])\n        all_busy.sort()\n        \n        # Merge overlapping or adjacent intervals\n        merged = []\n        for start, end in all_busy:\n            if not merged:\n                merged.append((start, end))\n            else:\n                last_start, last_end = merged[-1]\n                if start <= last_end:\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged[-1] = (new_start, new_end)\n                else:\n                    merged.append((start, end))\n        \n        # Check the time before the first busy interval\n        if not merged:\n            # No busy intervals, the whole day is free\n            return f\"{minutes_to_time(work_start)}:{minutes_to_time(work_start + 60)}\"\n        first_start, first_end = merged[0]\n        if first_start > work_start and (first_start - work_start) >= 60:\n            return f\"{minutes_to_time(work_start)}:{minutes_to_time(work_start + 60)}\"\n        \n        # Check the time between busy intervals\n        for i in range(1, len(merged)):\n            prev_end = merged[i-1][1]\n            curr_start = merged[i][0]\n            if (curr_start - prev_end) >= 60:\n                return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + 60)}\"\n        \n        # Check the time after the last busy interval\n        last_start, last_end = merged[-1]\n        if last_end < work_end and (work_end - last_end) >= 60:\n            return f\"{minutes_to_time(last_end)}:{minutes_to_time(last_end + 60)}\"\n    \n    return \"No time found\"\n\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_856"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Define participants' schedules and constraints\n    edward_schedule = {\n        'Monday': [(9 * 60, 9 * 60 + 30), (11 * 60, 11 * 60 + 30), (14 * 60 + 30, 15 * 60)],\n        'Tuesday': [(12 * 60, 13 * 60), (16 * 60 + 30, 17 * 60)],\n        'Wednesday': [(9 * 60, 9 * 60 + 30), (14 * 60, 14 * 60 + 30)],\n        'Thursday': [(15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)]\n    }\n    \n    zachary_schedule = {\n        'Monday': [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60), (11 * 60 + 30, 12 * 60 + 30), (14 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 15 * 60), (16 * 60, 17 * 60)],\n        'Thursday': [(9 * 60, 12 * 60), (12 * 60 + 30, 14 * 60), (15 * 60, 17 * 60)]\n    }\n    \n    # Apply preferences: Edward avoids Wednesday and Thursday, Zachary can't meet on Tuesday\n    preferred_days = ['Monday', 'Tuesday']\n    \n    # Iterate through preferred days to find the earliest available slot\n    for day in preferred_days:\n        # Combine and sort all busy times for both participants\n        busy_times = []\n        if day in edward_schedule:\n            busy_times.extend(edward_schedule[day])\n        if day in zachary_schedule:\n            busy_times.extend(zachary_schedule[day])\n        busy_times.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_hours_start\n        for start, end in busy_times:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_hours_end:\n            free_slots.append((prev_end, work_hours_end))\n        \n        # Check each free slot for a 30-minute meeting\n        for start, end in free_slots:\n            duration_needed = 30\n            if end - start >= duration_needed:\n                meeting_start = start\n                meeting_end = meeting_start + duration_needed\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    # If no slot found in preferred days, check other days (though constraints say solution exists)\n    for day in days:\n        if day not in preferred_days:\n            busy_times = []\n            if day in edward_schedule:\n                busy_times.extend(edward_schedule[day])\n            if day in zachary_schedule:\n                busy_times.extend(zachary_schedule[day])\n            busy_times.sort()\n            \n            free_slots = []\n            prev_end = work_hours_start\n            for start, end in busy_times:\n                if start > prev_end:\n                    free_slots.append((prev_end, start))\n                prev_end = max(prev_end, end)\n            if prev_end < work_hours_end:\n                free_slots.append((prev_end, work_hours_end))\n            \n            for start, end in free_slots:\n                duration_needed = 30\n                if end - start >= duration_needed:\n                    meeting_start = start\n                    meeting_end = meeting_start + duration_needed\n                    start_hh = meeting_start // 60\n                    start_mm = meeting_start % 60\n                    end_hh = meeting_end // 60\n                    end_mm = meeting_end % 60\n                    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_857"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Define busy times for Carl and Margaret in minutes since midnight\n    carl_busy = {\n        'Monday': [(11 * 60, 11 * 60 + 30)],\n        'Tuesday': [(14 * 60 + 30, 15 * 60)],\n        'Wednesday': [(10 * 60, 11 * 60 + 30), (13 * 60, 13 * 60 + 30)],\n        'Thursday': [(13 * 60 + 30, 14 * 60), (16 * 60, 16 * 60 + 30)]\n    }\n    \n    margaret_busy = {\n        'Monday': [(9 * 60, 10 * 60 + 30), (11 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60 + 30, 12 * 60), (13 * 60 + 30, 14 * 60), (15 * 60 + 30, 17 * 60)],\n        'Wednesday': [(9 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60 + 30), (15 * 60, 17 * 60)],\n        'Thursday': [(10 * 60, 12 * 60), (12 * 60 + 30, 14 * 60), (14 * 60 + 30, 17 * 60)]\n    }\n\n    # Iterate through each day, avoiding Thursday if possible\n    preferred_days = ['Monday', 'Tuesday', 'Wednesday']\n    for day in preferred_days + ['Thursday']:\n        if day == 'Thursday' and day in preferred_days:\n            continue  # Skip Thursday if preferred days are available\n\n        # Combine and sort all busy intervals for the day\n        all_busy = []\n        if day in carl_busy:\n            all_busy.extend(carl_busy[day])\n        if day in margaret_busy:\n            all_busy.extend(margaret_busy[day])\n        all_busy.sort()\n\n        # Find free slots by checking gaps between busy intervals\n        prev_end = work_hours_start\n        for start, end in all_busy:\n            if start > prev_end:\n                # Check if the gap is enough for the meeting\n                if start - prev_end >= meeting_duration:\n                    # Found a suitable slot\n                    meeting_start = prev_end\n                    meeting_end = meeting_start + meeting_duration\n                    # Format the time as HH:MM:HH:MM\n                    return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n            prev_end = max(prev_end, end)\n        \n        # Check the gap after the last busy interval\n        if work_hours_end - prev_end >= meeting_duration:\n            meeting_start = prev_end\n            meeting_end = meeting_start + meeting_duration\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    # If no slot found in preferred days, check Thursday\n    day = 'Thursday'\n    all_busy = []\n    if day in carl_busy:\n        all_busy.extend(carl_busy[day])\n    if day in margaret_busy:\n        all_busy.extend(margaret_busy[day])\n    all_busy.sort()\n\n    prev_end = work_hours_start\n    for start, end in all_busy:\n        if start > prev_end:\n            if start - prev_end >= meeting_duration:\n                meeting_start = prev_end\n                meeting_end = meeting_start + meeting_duration\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n        prev_end = max(prev_end, end)\n    \n    if work_hours_end - prev_end >= meeting_duration:\n        meeting_start = prev_end\n        meeting_end = meeting_start + meeting_duration\n        return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_858"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    meeting_duration = 30  # minutes\n    \n    # Randy's schedule: day -> list of busy time slots in minutes since midnight\n    randy_schedule = {\n        'Wednesday': [(12 * 60, 12 * 60 + 30), (14 * 60 + 30, 15 * 60)],\n    }\n    \n    # George's schedule: day -> list of busy time slots in minutes since midnight\n    george_schedule = {\n        'Monday': [\n            (9 * 60 + 30, 10 * 60),\n            (11 * 60, 12 * 60),\n            (12 * 60 + 30, 13 * 60),\n            (14 * 60, 17 * 60)\n        ],\n        'Tuesday': [\n            (9 * 60, 9 * 60 + 30),\n            (10 * 60, 10 * 60 + 30),\n            (11 * 60, 14 * 60),\n            (14 * 60 + 30, 17 * 60)\n        ],\n        'Wednesday': [\n            (9 * 60, 11 * 60),\n            (12 * 60, 12 * 60 + 30),\n            (13 * 60, 15 * 60),\n            (16 * 60, 16 * 60 + 30)\n        ],\n        'Thursday': [\n            (10 * 60, 11 * 60),\n            (11 * 60 + 30, 12 * 60 + 30),\n            (13 * 60 + 30, 14 * 60),\n            (15 * 60, 15 * 60 + 30),\n            (16 * 60, 16 * 60 + 30)\n        ]\n    }\n    \n    # Preferences: Randy avoids Tuesday, George avoids Thursday\n    preferred_days = [day for day in days if day not in ['Tuesday', 'Thursday']]\n    \n    # Iterate through preferred days first, then others if needed\n    for day in preferred_days + ['Monday', 'Tuesday', 'Wednesday', 'Thursday']:\n        if day not in preferred_days and day in ['Tuesday', 'Thursday']:\n            continue  # Skip non-preferred days\n        \n        # Collect all busy slots for the day\n        busy_slots = []\n        # Add Randy's busy slots\n        if day in randy_schedule:\n            busy_slots.extend(randy_schedule[day])\n        # Add George's busy slots\n        if day in george_schedule:\n            busy_slots.extend(george_schedule[day])\n        \n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in busy_slots:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy slot\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for availability\n        for start, end in free_slots:\n            slot_duration = end - start\n            if slot_duration >= meeting_duration:\n                meeting_start = start\n                meeting_end = start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_859"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Define busy times for each participant in minutes since midnight\n    mark_busy = {\n        'Wednesday': [(14 * 60, 14 * 60 + 30)],\n        'Thursday': [(14 * 60 + 30, 15 * 60)]\n    }\n    \n    helen_busy = {\n        'Monday': [\n            (10 * 60, 10 * 60 + 30),\n            (11 * 60 + 30, 14 * 60 + 30)\n        ],\n        'Tuesday': [\n            (9 * 60, 10 * 60),\n            (10 * 60 + 30, 11 * 60),\n            (11 * 60 + 30, 12 * 60),\n            (12 * 60 + 30, 13 * 60 + 30),\n            (14 * 60 + 30, 15 * 60),\n            (16 * 60, 16 * 60 + 30)\n        ],\n        'Wednesday': [\n            (9 * 60, 9 * 60 + 30),\n            (10 * 60, 12 * 60),\n            (13 * 60 + 30, 15 * 60),\n            (15 * 60 + 30, 16 * 60)\n        ],\n        'Thursday': [\n            (10 * 60, 10 * 60 + 30),\n            (13 * 60, 14 * 60 + 30),\n            (15 * 60, 17 * 60)\n        ]\n    }\n    \n    meeting_duration = 60  # 1 hour in minutes\n    \n    # Iterate through each day to find the earliest available slot\n    for day in days:\n        # Combine and sort all busy intervals for the day for both participants\n        mark_intervals = mark_busy.get(day, [])\n        helen_intervals = helen_busy.get(day, [])\n        all_busy = mark_intervals + helen_intervals\n        all_busy.sort()\n        \n        # Merge overlapping or adjacent intervals\n        merged = []\n        for start, end in all_busy:\n            if not merged:\n                merged.append((start, end))\n            else:\n                last_start, last_end = merged[-1]\n                if start <= last_end:\n                    merged[-1] = (last_start, max(end, last_end))\n                else:\n                    merged.append((start, end))\n        \n        # Check the time before the first busy interval\n        if merged:\n            first_start, _ = merged[0]\n            if first_start - work_start >= meeting_duration:\n                # Found a slot at the start of the day\n                meeting_start = work_start\n                meeting_end = meeting_start + meeting_duration\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n        \n        # Check the time between busy intervals\n        for i in range(len(merged) - 1):\n            _, current_end = merged[i]\n            next_start, _ = merged[i + 1]\n            if next_start - current_end >= meeting_duration:\n                meeting_start = current_end\n                meeting_end = meeting_start + meeting_duration\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n        \n        # Check the time after the last busy interval\n        if merged:\n            _, last_end = merged[-1]\n            if work_end - last_end >= meeting_duration:\n                meeting_start = last_end\n                meeting_end = meeting_start + meeting_duration\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n        else:\n            # No busy intervals on this day, can meet anytime\n            meeting_start = work_start\n            meeting_end = meeting_start + meeting_duration\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_860"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef parse_time(time_str):\n    return datetime.strptime(time_str, \"%H:%M\")\n\ndef time_to_str(time_obj):\n    return time_obj.strftime(\"%H:%M\")\n\ndef find_meeting_time(participants_busy, work_hours_start, work_hours_end, meeting_duration, preferences):\n    days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\"]\n    time_slots = []\n    \n    for day in days:\n        if day in preferences.get(\"avoid_days\", []):\n            continue\n        \n        # Combine all busy slots for the day for all participants\n        day_busy = []\n        for participant in participants_busy:\n            day_busy.extend([(parse_time(start), parse_time(end)) for (d, start, end) in participant if d == day])\n        \n        # Sort busy slots by start time\n        day_busy.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = parse_time(work_hours_start)\n        \n        for busy_start, busy_end in day_busy:\n            if busy_start > prev_end:\n                free_slots.append((prev_end, busy_start))\n            prev_end = max(prev_end, busy_end)\n        \n        # Check after last busy slot\n        if prev_end < parse_time(work_hours_end):\n            free_slots.append((prev_end, parse_time(work_hours_end)))\n        \n        # Check each free slot for meeting duration\n        for slot_start, slot_end in free_slots:\n            slot_duration = (slot_end - slot_start).total_seconds() / 60\n            if slot_duration >= meeting_duration:\n                time_slots.append((day, slot_start, slot_start + timedelta(minutes=meeting_duration)))\n    \n    if not time_slots:\n        return None\n    \n    # Find the earliest possible time\n    earliest_slot = min(time_slots, key=lambda x: (days.index(x[0]), x[1]))\n    return earliest_slot\n\n# Define participants' busy times\namber_busy = [\n    (\"Monday\", \"11:00\", \"11:30\"), (\"Monday\", \"12:00\", \"13:30\"), (\"Monday\", \"14:00\", \"14:30\"),\n    (\"Tuesday\", \"10:00\", \"11:00\"), (\"Tuesday\", \"14:00\", \"14:30\"),\n    (\"Wednesday\", \"9:00\", \"9:30\"), (\"Wednesday\", \"10:00\", \"10:30\"), (\"Wednesday\", \"12:00\", \"13:00\"),\n    (\"Wednesday\", \"14:00\", \"15:30\"), (\"Wednesday\", \"16:00\", \"16:30\"),\n    (\"Thursday\", \"9:30\", \"10:30\"), (\"Thursday\", \"11:00\", \"11:30\"), (\"Thursday\", \"12:30\", \"13:00\"),\n    (\"Thursday\", \"14:00\", \"15:00\"), (\"Thursday\", \"15:30\", \"16:30\")\n]\n\nraymond_busy = [\n    (\"Monday\", \"9:00\", \"9:30\"), (\"Monday\", \"10:00\", \"10:30\"), (\"Monday\", \"11:00\", \"11:30\"), (\"Monday\", \"12:00\", \"17:00\"),\n    (\"Tuesday\", \"9:00\", \"12:00\"), (\"Tuesday\", \"12:30\", \"17:00\"),\n    (\"Wednesday\", \"9:00\", \"10:30\"), (\"Wednesday\", \"11:00\", \"11:30\"), (\"Wednesday\", \"12:00\", \"12:30\"), (\"Wednesday\", \"13:00\", \"17:00\"),\n    (\"Thursday\", \"9:00\", \"13:00\"), (\"Thursday\", \"13:30\", \"17:00\")\n]\n\nparticipants_busy = [amber_busy, raymond_busy]\npreferences = {\"avoid_days\": [\"Thursday\"]}\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 30\n\nearliest_slot = find_meeting_time(participants_busy, work_hours_start, work_hours_end, meeting_duration, preferences)\n\nif earliest_slot:\n    day, start_time, end_time = earliest_slot\n    print(f\"{time_to_str(start_time)}:{time_to_str(end_time)}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_861"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Define schedules for Ann and Amanda\n    ann_schedule = {\n        'Monday': [(10 * 60 + 30, 11 * 60), (12 * 60, 12 * 60 + 30), (15 * 60 + 30, 16 * 60)],\n        'Tuesday': [(9 * 60, 9 * 60 + 30), (13 * 60, 13 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n        'Wednesday': [(9 * 60 + 30, 11 * 60), (12 * 60 + 30, 14 * 60), (15 * 60 + 30, 16 * 60)],\n        'Thursday': [(10 * 60, 10 * 60 + 30)]\n    }\n\n    amanda_schedule = {\n        'Monday': [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60), (11 * 60 + 30, 12 * 60), (13 * 60, 14 * 60 + 30)],\n        'Tuesday': [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 11 * 60), (12 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), (16 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Thursday': [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 12 * 60 + 30), (13 * 60, 14 * 60), (14 * 60 + 30, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)]\n    }\n\n    # Iterate through each day to find the earliest available slot\n    for day in days:\n        # Collect all busy times for both participants\n        busy_times = []\n        busy_times.extend(ann_schedule.get(day, []))\n        busy_times.extend(amanda_schedule.get(day, []))\n        busy_times.sort()\n\n        # Check available slots\n        prev_end = work_start\n        for start, end in busy_times:\n            if start > prev_end:\n                available_start = prev_end\n                available_end = start\n                if available_end - available_start >= meeting_duration:\n                    # Found a suitable slot\n                    meeting_start = available_start\n                    meeting_end = meeting_start + meeting_duration\n                    return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n            prev_end = max(prev_end, end)\n\n        # Check after the last meeting\n        if work_end - prev_end >= meeting_duration:\n            meeting_start = prev_end\n            meeting_end = meeting_start + meeting_duration\n            return f\"{meeting_start // 60:02d}:{meeting_end // 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_862"
        },
        {
            "final_program_time": "{13:30:14:30}",
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Define schedules for Abigail and Sara\n    abigail_schedule = {\n        'Monday': [(9*60, 10*60), (12.5*60, 13.5*60), (15.5*60, 16*60), (16.5*60, 17*60)],\n        'Tuesday': [(9*60, 10*60), (11.5*60, 12*60), (13*60, 13.5*60), (15*60, 15.5*60)],\n        'Wednesday': [(9.5*60, 10*60), (10.5*60, 12*60), (14*60, 15*60), (16*60, 16.5*60)],\n        'Thursday': [(11*60, 12*60), (14*60, 14.5*60), (16*60, 16.5*60)]\n    }\n    \n    sara_schedule = {\n        'Monday': [(9*60, 11.5*60), (12*60, 13.5*60), (14.5*60, 17*60)],\n        'Tuesday': [(9*60, 10.5*60), (11*60, 17*60)],\n        'Wednesday': [(9*60, 10.5*60), (11*60, 14.5*60), (15.5*60, 16*60), (16.5*60, 17*60)],\n        'Thursday': [(9*60, 9.5*60), (10*60, 13.5*60), (14*60, 17*60)]\n    }\n    \n    # Function to find available slots for a person on a given day\n    def get_available_slots(schedule, day):\n        busy_slots = schedule.get(day, [])\n        available = []\n        prev_end = work_start\n        \n        for start, end in sorted(busy_slots):\n            if start > prev_end:\n                available.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            available.append((prev_end, work_end))\n        \n        return available\n    \n    # Check each day for overlapping available slots of 60 minutes\n    for day in days:\n        abigail_slots = get_available_slots(abigail_schedule, day)\n        sara_slots = get_available_slots(sara_schedule, day)\n        \n        # Find overlapping slots\n        for a_start, a_end in abigail_slots:\n            for s_start, s_end in sara_slots:\n                overlap_start = max(a_start, s_start)\n                overlap_end = min(a_end, s_end)\n                if overlap_end - overlap_start >= 60:  # 60 minutes available\n                    # Return the first suitable slot\n                    start_hour = int(overlap_start // 60)\n                    start_min = int(overlap_start % 60)\n                    end_hour = int((overlap_start + 60) // 60)\n                    end_min = int((overlap_start + 60) % 60)\n                    return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_863"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Bruce's schedule: day -> list of (start, end) in minutes\n    bruce_schedule = {\n        'Monday': [(9*60, 9*60+30), (10*60+30, 11*60), (12*60, 12*60+30),\n                   (13*60, 13*60+30), (14*60, 14*60+30), (16*60, 16*60+30)],\n        'Tuesday': [(10*60, 10*60+30), (12*60+30, 13*60+30), (16*60+30, 17*60)],\n        'Wednesday': [(10*60, 10*60+30), (12*60, 12*60+30), (15*60, 15*60+30)],\n        'Thursday': [(11*60+30, 12*60+30), (14*60+30, 15*60)],\n    }\n    \n    # Amy's schedule: day -> list of (start, end) in minutes\n    amy_schedule = {\n        'Monday': [(9*60, 10*60), (11*60, 11*60+30), (13*60+30, 14*60),\n                   (14*60+30, 15*60+30), (16*60, 17*60)],\n        'Tuesday': [(9*60, 14*60), (15*60+30, 16*60)],\n        'Wednesday': [(9*60, 9*60+30), (10*60, 13*60), (13*60+30, 14*60),\n                     (14*60+30, 15*60+30), (16*60+30, 17*60)],\n        'Thursday': [(9*60, 10*60), (10*60+30, 12*60), (12*60+30, 13*60),\n                     (13*60+30, 14*60), (15*60, 16*60+30)],\n    }\n    \n    # Bruce prefers not to meet on Wednesday\n    preferred_days = [day for day in days if day != 'Wednesday']\n    \n    for day in preferred_days:\n        # Collect all busy intervals for both participants\n        busy_intervals = bruce_schedule.get(day, []) + amy_schedule.get(day, [])\n        busy_intervals.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_hours_start\n        \n        for start, end in busy_intervals:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_hours_end:\n            free_slots.append((prev_end, work_hours_end))\n        \n        # Check for a 1-hour slot\n        for start, end in free_slots:\n            if end - start >= 60:\n                meeting_start = start\n                meeting_end = meeting_start + 60\n                # Convert back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_864"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Define busy times for Megan and Daniel in minutes since midnight\n    megan_busy = {\n        'Monday': [(13 * 60, 13 * 60 + 30), (14 * 60, 15 * 60 + 30)],\n        'Tuesday': [(9 * 60, 9 * 60 + 30), (12 * 60, 12 * 60 + 30), (16 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 11 * 60 + 30), (12 * 60 + 30, 14 * 60), (16 * 60, 16 * 60 + 30)],\n        'Thursday': [(13 * 60 + 30, 14 * 60 + 30), (15 * 60, 15 * 60 + 30)]\n    }\n    \n    daniel_busy = {\n        'Monday': [(10 * 60, 11 * 60 + 30), (12 * 60 + 30, 15 * 60)],\n        'Tuesday': [(9 * 60, 10 * 60), (10 * 60 + 30, 17 * 60)],\n        'Wednesday': [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60 + 30), (12 * 60, 17 * 60)],\n        'Thursday': [(9 * 60, 12 * 60), (12 * 60 + 30, 14 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)]\n    }\n    \n    # Iterate through each day to find the earliest available slot\n    for day in days:\n        # Collect all busy intervals for both participants\n        busy_intervals = megan_busy.get(day, []) + daniel_busy.get(day, [])\n        busy_intervals.sort()  # Sort by start time\n        \n        # Find available slots\n        prev_end = work_start\n        for start, end in busy_intervals:\n            if start > prev_end:\n                # Check if the slot is at least 1 hour\n                if (start - prev_end) >= 60:\n                    # Found a suitable slot\n                    start_time = prev_end\n                    end_time = start_time + 60\n                    return f\"{start_time // 60:02d}:{start_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after the last busy interval\n        if work_end - prev_end >= 60:\n            start_time = prev_end\n            end_time = start_time + 60\n            return f\"{start_time // 60:02d}:{start_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_865"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    meeting_duration = 30  # minutes\n    \n    # Catherine's schedule: day -> list of busy intervals in minutes\n    catherine_schedule = {\n        'Monday': [(9*60 + 30, 10*60), (13*60 + 30, 14*60)],\n        'Tuesday': [(11*60, 11*60 + 30), (12*60 + 30, 14*60), (16*60 + 30, 17*60)],\n        'Wednesday': [(16*60 + 30, 17*60)],\n        'Thursday': [(12*60 + 30, 13*60), (13*60 + 30, 14*60)]\n    }\n    \n    # Peter's schedule: day -> list of busy intervals in minutes\n    peter_schedule = {\n        'Monday': [(9*60, 10*60 + 30), (11*60, 11*60 + 30), (12*60, 14*60), (14*60 + 30, 17*60)],\n        'Tuesday': [(9*60, 17*60)],\n        'Wednesday': [(9*60, 15*60 + 30), (16*60, 17*60)],\n        'Thursday': [(9*60, 12*60), (12*60 + 30, 16*60), (16*60 + 30, 17*60)]\n    }\n    \n    # Peter's preferred days to avoid\n    avoid_days = ['Monday', 'Thursday']\n    \n    # Iterate through each day not in avoid_days\n    for day in days:\n        if day in avoid_days:\n            continue\n        \n        # Get busy intervals for both participants\n        catherine_busy = catherine_schedule.get(day, [])\n        peter_busy = peter_schedule.get(day, [])\n        \n        # Combine and sort all busy intervals\n        all_busy = catherine_busy + peter_busy\n        all_busy.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= meeting_duration:\n                # Found a suitable slot\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                \n                # Convert back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                \n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_866"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Betty's busy times in minutes since midnight\n    betty_busy = {\n        'Monday': [(10*60, 10*60+30), (13*60+30, 14*60), (15*60, 15*60+30), (16*60, 16*60+30)],\n        'Tuesday': [(9*60, 9*60+30), (11*60+30, 12*60), (12*60+30, 13*60), (13*60+30, 14*60), (16*60+30, 17*60)],\n        'Wednesday': [(9*60+30, 10*60+30), (13*60, 13*60+30), (14*60, 14*60+30)],\n        'Thursday': [(9*60+30, 10*60), (11*60+30, 12*60), (14*60, 14*60+30), (15*60, 15*60+30), (16*60+30, 17*60)]\n    }\n    \n    # Scott's busy times in minutes since midnight\n    scott_busy = {\n        'Monday': [(9*60+30, 15*60), (15*60+30, 16*60), (16*60+30, 17*60)],\n        'Tuesday': [(9*60, 9*60+30), (10*60, 11*60), (11*60+30, 12*60), (12*60+30, 13*60+30), (14*60, 15*60), (16*60, 16*60+30)],\n        'Wednesday': [(9*60+30, 12*60+30), (13*60, 13*60+30), (14*60, 14*60+30), (15*60, 15*60+30), (16*60, 16*60+30)],\n        'Thursday': [(9*60, 9*60+30), (10*60, 10*60+30), (11*60, 12*60), (12*60+30, 13*60), (15*60, 16*60), (16*60+30, 17*60)]\n    }\n    \n    # Constraints\n    betty_no_days = ['Monday']\n    betty_no_times_before = {'Tuesday': 15*60, 'Thursday': 15*60}\n    scott_avoid_day = 'Wednesday'\n    \n    # Iterate through each day and find available slots\n    for day in days:\n        if day in betty_no_days:\n            continue\n        if day == scott_avoid_day:\n            continue\n        \n        # Get busy times for both participants\n        busy_times = betty_busy.get(day, []) + scott_busy.get(day, [])\n        busy_times.sort()\n        \n        # Merge overlapping busy times\n        merged = []\n        for start, end in busy_times:\n            if not merged:\n                merged.append((start, end))\n            else:\n                last_start, last_end = merged[-1]\n                if start <= last_end:\n                    merged[-1] = (last_start, max(end, last_end))\n                else:\n                    merged.append((start, end))\n        \n        # Check Betty's no before time constraint\n        min_start = work_start\n        if day in betty_no_times_before:\n            min_start = max(min_start, betty_no_times_before[day])\n        \n        # Find available slots\n        prev_end = min_start\n        for start, end in merged:\n            if start > prev_end and (start - prev_end) >= 30:\n                # Found a slot\n                slot_start = prev_end\n                slot_end = slot_start + 30\n                return f\"{slot_start//60:02d}:{slot_start%60:02d}:{slot_end//60:02d}:{slot_end%60:02d}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy time\n        if work_end - prev_end >= 30:\n            slot_start = prev_end\n            slot_end = slot_start + 30\n            return f\"{slot_start//60:02d}:{slot_start%60:02d}:{slot_end//60:02d}:{slot_end%60:02d}\"\n    \n    return \"No time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_867"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Define blocked times for each participant per day in minutes since midnight\n    megan_blocked = {\n        'Monday': [(10 * 60, 10 * 60 + 30), (13 * 60, 14 * 60), (14 * 60 + 30, 15 * 60)],\n        'Tuesday': [(10 * 60 + 30, 11 * 60)],\n        'Wednesday': [(16 * 60, 16 * 60 + 30)],\n        'Thursday': []\n    }\n    \n    beverly_blocked = {\n        'Monday': [(9 * 60, 10 * 60 + 30), (11 * 60, 11 * 60 + 30), (12 * 60 + 30, 13 * 60 + 30), (14 * 60 + 30, 16 * 60 + 30)],\n        'Tuesday': [(9 * 60, 10 * 60), (10 * 60 + 30, 17 * 60)],\n        'Wednesday': [(9 * 60, 10 * 60 + 30), (12 * 60, 13 * 60), (14 * 60, 14 * 60 + 30), (16 * 60, 17 * 60)],\n        'Thursday': [(10 * 60 + 30, 11 * 60 + 30), (12 * 60 + 30, 13 * 60), (14 * 60, 14 * 60 + 30), (15 * 60 + 30, 17 * 60)]\n    }\n    \n    # Preferences\n    megan_avoid_days = ['Monday', 'Tuesday', 'Wednesday']  # Megan wants to avoid these days\n    beverly_avoid_thursday_after = 14 * 60 + 30  # Beverly doesn't want to meet on Thursday after 14:30\n    \n    # Iterate through each day to find a suitable time\n    for day in days:\n        if day in megan_avoid_days:\n            continue  # Skip days Megan wants to avoid\n        \n        # Combine and sort all blocked times for both participants\n        all_blocked = megan_blocked[day] + beverly_blocked[day]\n        all_blocked.sort()\n        \n        # Find available slots\n        available_slots = []\n        prev_end = work_hours_start\n        \n        for start, end in all_blocked:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_hours_end:\n            available_slots.append((prev_end, work_hours_end))\n        \n        # Check for a 30-minute slot\n        for start, end in available_slots:\n            if day == 'Thursday' and start >= beverly_avoid_thursday_after:\n                continue  # Skip Thursday after 14:30 for Beverly\n            if end - start >= 30:\n                meeting_start = start\n                meeting_end = meeting_start + 30\n                # Format the time as HH:MM:HH:MM\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"  # Should not reach here per problem statement\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_868"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\"]\n    \n    # Define participants' busy slots in minutes since midnight\n    # Format: {day: [(start1, end1), (start2, end2), ...]}\n    philip_busy = {\n        \"Monday\": [(10*60, 10*60+30), (11*60, 11*60+30), (13*60+30, 14*60+30), (15*60, 17*60)],\n        \"Tuesday\": [(10*60+30, 11*60), (12*60+30, 13*60+30), (14*60, 15*60+30), (16*60, 16*60+30)],\n        \"Wednesday\": [(9*60, 9*60+30), (10*60, 11*60), (11*60+30, 12*60), (13*60+30, 15*60)],\n        \"Thursday\": [(9*60, 9*60+30), (11*60+30, 12*60), (14*60, 15*60), (15*60+30, 16*60), (16*60+30, 17*60)]\n    }\n    \n    roy_busy = {\n        \"Monday\": [(9*60, 10*60+30), (11*60, 14*60+30), (15*60, 16*60+30)],\n        \"Tuesday\": [(9*60, 17*60)],\n        \"Wednesday\": [(10*60, 10*60+30), (11*60, 12*60), (12*60+30, 14*60), (14*60+30, 16*60), (16*60+30, 17*60)],\n        \"Thursday\": [(9*60, 12*60+30), (13*60, 17*60)]\n    }\n    \n    # Apply preferences\n    # Philip doesn't want to meet on Monday\n    days_to_check = [day for day in days if day != \"Monday\"]\n    # Roy wants to avoid Wednesday after 11:00, so remove Wednesday\n    days_to_check = [day for day in days_to_check if day != \"Wednesday\"]\n    \n    meeting_duration = 30  # minutes\n    \n    for day in days_to_check:\n        # Get both participants' busy times for the day\n        pb = philip_busy.get(day, [])\n        rb = roy_busy.get(day, [])\n        \n        # Combine and sort all busy intervals\n        all_busy = pb + rb\n        all_busy.sort()\n        \n        # Find free slots\n        prev_end = work_hours_start\n        free_slots = []\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy slot\n        if prev_end < work_hours_end:\n            free_slots.append((prev_end, work_hours_end))\n        \n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            available_start = slot_start\n            available_end = slot_end\n            \n            # Ensure the slot is long enough\n            if available_end - available_start >= meeting_duration:\n                # Convert back to HH:MM format\n                start_hh = available_start // 60\n                start_mm = available_start % 60\n                end_time = available_start + meeting_duration\n                end_hh = end_time // 60\n                end_mm = end_time % 60\n                \n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_869"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to consider based on constraints\n    # Doris cannot meet on Monday or Tuesday, Jeremy prefers not Thursday\n    # So possible days: Wednesday\n    days = ['Wednesday']\n\n    # Define schedules for each participant on the possible day\n    doris_schedule = {\n        'Wednesday': [(9 * 60, 9 * 60 + 30), (11 * 60, 11 * 60 + 30)]  # 9:00-9:30, 11:00-11:30\n    }\n    jeremy_schedule = {\n        'Wednesday': [(9 * 60, 10 * 60 + 30), (11 * 60, 17 * 60)]  # 9:00-10:30, 11:00-17:00\n    }\n\n    for day in days:\n        # Collect all busy times for the day\n        busy_times = []\n        # Add Doris's busy times\n        busy_times.extend(doris_schedule.get(day, []))\n        # Add Jeremy's busy times\n        busy_times.extend(jeremy_schedule.get(day, []))\n\n        # Sort busy times by start time\n        busy_times.sort()\n\n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        for start, end in busy_times:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n\n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= meeting_duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_870"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to consider (Monday is 0, Tuesday is 1, etc.)\n    days = [1, 2, 3]  # Tuesday, Wednesday, Thursday (excluding Monday per Anthony's preference)\n    \n    # Joseph's meetings in minutes since start of day for each day\n    joseph_meetings = {\n        1: [  # Tuesday\n            (9 * 60, 10 * 60),\n            (10 * 60 + 30, 12 * 60 + 30),\n            (13 * 60, 14 * 60),\n            (14 * 60 + 30, 16 * 60),\n            (16 * 60 + 30, 17 * 60)\n        ],\n        2: [  # Wednesday\n            (9 * 60, 9 * 60 + 30),\n            (10 * 60, 11 * 60 + 30),\n            (13 * 60, 16 * 60),\n            (16 * 60 + 30, 17 * 60)\n        ],\n        3: [  # Thursday\n            (9 * 60, 9 * 60 + 30),\n            (10 * 60, 10 * 60 + 30),\n            (11 * 60, 11 * 60 + 30),\n            (12 * 60, 12 * 60 + 30),\n            (13 * 60, 13 * 60 + 30),\n            (14 * 60, 15 * 60),\n            (16 * 60 + 30, 17 * 60)\n        ]\n    }\n    \n    meeting_duration = 30  # minutes\n    \n    # Iterate through days in order\n    for day in days:\n        # Get Joseph's meetings for the day\n        meetings = joseph_meetings.get(day, [])\n        \n        # Find available slots for Joseph\n        available_slots = []\n        prev_end = work_start\n        \n        for start, end in sorted(meetings):\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n        \n        # Check each available slot for Joseph (Anthony is always free)\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= meeting_duration:\n                # Found the earliest possible slot\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                \n                # Convert back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                \n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No meeting time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_871"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to consider\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Define Jacob's schedule in minutes since midnight\n    jacob_schedule = {\n        'Monday': [(10 * 60 + 30, 11 * 60), (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60 + 30), (16 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60 + 30, 10 * 60 + 30), (12 * 60 + 30, 13 * 60), (14 * 60, 14 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Wednesday': [],\n        'Thursday': [(10 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), (15 * 60, 16 * 60 + 30)]\n    }\n    \n    # Define Beverly's schedule in minutes since midnight\n    beverly_schedule = {\n        'Monday': [(9 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 12 * 60 + 30), (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Thursday': [(9 * 60, 11 * 60 + 30), (12 * 60, 14 * 60), (15 * 60, 17 * 60)]\n    }\n    \n    # Duration of the meeting in minutes\n    duration = 30\n    \n    # Jacob doesn't want to meet on Thursday, Beverly wants to avoid Tuesday and Wednesday before 16:00\n    preferred_days = ['Wednesday']\n    \n    for day in preferred_days:\n        # Get busy times for both participants on this day\n        jacob_busy = jacob_schedule[day]\n        beverly_busy = beverly_schedule[day]\n        \n        # Combine and sort all busy times\n        all_busy = jacob_busy + beverly_busy\n        all_busy.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check for a slot that fits the duration\n        for start, end in free_slots:\n            if end - start >= duration:\n                # Beverly doesn't want Wednesday before 16:00\n                if day == 'Wednesday' and start < 16 * 60:\n                    continue\n                meeting_start = start\n                meeting_end = meeting_start + duration\n                # Format the time as HH:MM:HH:MM\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    # If preferred days don't work, check other days except Thursday and Tuesday\n    for day in ['Monday', 'Tuesday', 'Wednesday']:\n        if day in preferred_days or (day == 'Thursday') or (day == 'Tuesday' and 'Tuesday' not in preferred_days):\n            continue\n        \n        jacob_busy = jacob_schedule[day]\n        beverly_busy = beverly_schedule[day]\n        \n        all_busy = jacob_busy + beverly_busy\n        all_busy.sort()\n        \n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        for start, end in free_slots:\n            if end - start >= duration:\n                meeting_start = start\n                meeting_end = meeting_start + duration\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_872"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Deborah's schedule: completely free\n    deborah_free = {\n        day: [(work_start, work_end)] for day in days\n    }\n    \n    # John's schedule: blocked times\n    john_blocked = {\n        'Monday': [(9*60, 15*60), (15*60 + 30, 17*60)],\n        'Tuesday': [(9*60, 13*60 + 30), (14*60, 15*60 + 30), (16*60, 17*60)],\n        'Wednesday': [(9*60, 11*60), (11*60 + 30, 12*60), (13*60 + 30, 16*60), (16*60 + 30, 17*60)],\n        'Thursday': [(9*60, 9*60 + 30), (10*60, 13*60 + 30), (14*60, 17*60)]\n    }\n    \n    # Convert blocked times to free times for John\n    john_free = {}\n    for day in days:\n        blocked = john_blocked[day]\n        free = []\n        prev_end = work_start\n        for start, end in sorted(blocked):\n            if start > prev_end:\n                free.append((prev_end, start))\n            prev_end = end\n        if prev_end < work_end:\n            free.append((prev_end, work_end))\n        john_free[day] = free\n    \n    # Find overlapping free times for Deborah and John\n    meeting_duration = 60  # 1 hour\n    for day in days:\n        deb_intervals = deborah_free[day]\n        john_intervals = john_free[day]\n        \n        # Check all combinations of free intervals\n        for d_start, d_end in deb_intervals:\n            for j_start, j_end in john_intervals:\n                # Find overlap\n                overlap_start = max(d_start, j_start)\n                overlap_end = min(d_end, j_end)\n                if overlap_end - overlap_start >= meeting_duration:\n                    # Found a suitable time\n                    start_time = overlap_start\n                    end_time = start_time + meeting_duration\n                    # Format the time as HH:MM:HH:MM\n                    start_str = f\"{start_time // 60:02d}:{start_time % 60:02d}\"\n                    end_str = f\"{end_time // 60:02d}:{end_time % 60:02d}\"\n                    return f\"{start_str}:{end_str}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_873"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Define days to consider\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n\n    # Samuel's schedule: {day: [(start1, end1), (start2, end2), ...]}\n    samuel_schedule = {\n        'Monday': [(10.5 * 60, 11.5 * 60), (12.5 * 60, 13.5 * 60), (15 * 60, 15.5 * 60)],\n        'Tuesday': [(9.5 * 60, 10 * 60), (10.5 * 60, 11 * 60), (12 * 60, 12.5 * 60), (13.5 * 60, 14 * 60), (16.5 * 60, 17 * 60)],\n        'Wednesday': [(14 * 60, 14.5 * 60), (16 * 60, 16.5 * 60)],\n        'Thursday': [(11.5 * 60, 12 * 60), (12.5 * 60, 13 * 60), (15 * 60, 15.5 * 60), (16 * 60, 16.5 * 60)]\n    }\n\n    # Kimberly's schedule: {day: [(start1, end1), (start2, end2), ...]}\n    kimberly_schedule = {\n        'Monday': [(9.5 * 60, 10.5 * 60), (11.5 * 60, 13.5 * 60), (14 * 60, 14.5 * 60), (15 * 60, 16.5 * 60)],\n        'Tuesday': [(9 * 60, 9.5 * 60), (10 * 60, 13.5 * 60), (14 * 60, 14.5 * 60), (15.5 * 60, 17 * 60)],\n        'Wednesday': [(9.5 * 60, 11.5 * 60), (12.5 * 60, 13 * 60), (13.5 * 60, 14 * 60), (16 * 60, 17 * 60)],\n        'Thursday': [(9 * 60, 10 * 60), (10.5 * 60, 12.5 * 60), (13 * 60, 17 * 60)]\n    }\n\n    # Samuel doesn't want to meet on Tuesday\n    days_to_check = [day for day in days if day != 'Tuesday']\n\n    for day in days_to_check:\n        # Get both schedules for the day\n        samuel_busy = samuel_schedule.get(day, [])\n        kimberly_busy = kimberly_schedule.get(day, [])\n\n        # Combine and sort all busy intervals\n        all_busy = samuel_busy + kimberly_busy\n        all_busy.sort()\n\n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n\n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n\n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            available_start = slot_start\n            available_end = slot_end\n\n            # Ensure the slot is at least meeting_duration long\n            if available_end - available_start >= meeting_duration:\n                # Check Kimberly's preference: not Wednesday after 12:30\n                if day == 'Wednesday' and available_start >= 12.5 * 60:\n                    continue\n                # Found a suitable time\n                start_time = available_start\n                end_time = start_time + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                start_hh = int(start_time // 60)\n                start_mm = int(start_time % 60)\n                end_hh = int(end_time // 60)\n                end_mm = int(end_time % 60)\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_874"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Natalie's busy times in minutes since midnight for each day\n    natalie_busy = {\n        'Monday': [(9*60, 9*60+30), (10*60, 12*60), (12*60+30, 13*60), (14*60, 14*60+30), (15*60, 16*60+30)],\n        'Tuesday': [(9*60, 9*60+30), (10*60, 10*60+30), (12*60+30, 14*60), (16*60, 17*60)],\n        'Wednesday': [(11*60, 11*60+30), (16*60, 16*60+30)],\n        'Thursday': [(10*60, 11*60), (11*60+30, 15*60), (15*60+30, 16*60), (16*60+30, 17*60)]\n    }\n    \n    # William's busy times in minutes since midnight for each day\n    william_busy = {\n        'Monday': [(9*60+30, 11*60), (11*60+30, 17*60)],\n        'Tuesday': [(9*60, 13*60), (13*60+30, 16*60)],\n        'Wednesday': [(9*60, 12*60+30), (13*60, 14*60+30), (15*60+30, 16*60), (16*60+30, 17*60)],\n        'Thursday': [(9*60, 10*60+30), (11*60, 11*60+30), (12*60, 12*60+30), (13*60, 14*60), (15*60, 17*60)]\n    }\n    \n    meeting_duration = 60  # 1 hour in minutes\n    \n    for day in days:\n        # Collect all busy intervals for both participants on this day\n        busy_intervals = natalie_busy[day] + william_busy[day]\n        busy_intervals.sort()  # Sort by start time\n        \n        # Find free intervals by merging busy intervals\n        free_intervals = []\n        prev_end = work_start\n        \n        for start, end in busy_intervals:\n            if start > prev_end:\n                free_intervals.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_intervals.append((prev_end, work_end))\n        \n        # Check each free interval for availability\n        for start, end in free_intervals:\n            available_start = start\n            available_end = end\n            \n            if available_end - available_start >= meeting_duration:\n                # Convert back to HH:MM format\n                meeting_start = available_start\n                meeting_end = meeting_start + meeting_duration\n                \n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                \n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_875"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef parse_time(time_str):\n    return datetime.strptime(time_str, '%H:%M')\n\ndef time_to_str(time_obj):\n    return time_obj.strftime('%H:%M')\n\ndef find_meeting_time(participants_schedules, preferences, duration, work_hours_start, work_hours_end, days):\n    duration = timedelta(minutes=duration)\n    work_start = parse_time(work_hours_start)\n    work_end = parse_time(work_hours_end)\n    \n    for day in days:\n        if day in preferences.get('avoid_days', {}):\n            continue\n        \n        # Collect all busy intervals for the day for all participants\n        busy_intervals = []\n        for participant in participants_schedules:\n            busy_intervals.extend(participants_schedules[participant].get(day, []))\n        \n        # Convert busy intervals to datetime objects\n        busy_slots = []\n        for interval in busy_intervals:\n            start, end = interval.split(' to ')\n            busy_slots.append((parse_time(start), parse_time(end)))\n        \n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in busy_slots:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if work_end > prev_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            slot_duration = slot_end - slot_start\n            if slot_duration >= duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + duration\n                return f\"{time_to_str(meeting_start)}:{time_to_str(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    'Ethan': {\n        'Monday': ['10:30 to 11:00', '12:00 to 13:00', '14:30 to 15:30'],\n        'Tuesday': ['10:30 to 11:30', '12:30 to 13:00', '14:00 to 14:30', '15:30 to 16:00'],\n        'Wednesday': ['9:30 to 10:30', '11:30 to 12:00', '13:00 to 15:00', '16:30 to 17:00'],\n        'Thursday': ['11:00 to 11:30', '12:30 to 13:00', '14:00 to 14:30', '15:00 to 15:30', '16:00 to 17:00']\n    },\n    'Henry': {\n        'Monday': ['9:30 to 10:00', '10:30 to 13:30', '14:00 to 14:30', '15:30 to 17:00'],\n        'Tuesday': ['9:00 to 9:30', '10:00 to 11:00', '11:30 to 14:00', '14:30 to 17:00'],\n        'Wednesday': ['9:00 to 9:30', '10:00 to 10:30', '11:30 to 12:00', '12:30 to 14:00', '14:30 to 16:00'],\n        'Thursday': ['10:00 to 11:00', '11:30 to 12:00', '13:00 to 14:00', '15:00 to 15:30', '16:00 to 16:30']\n    }\n}\n\n# Define preferences\npreferences = {\n    'Ethan': {'avoid_days': ['Thursday']},\n    'Henry': {'avoid_days': ['Tuesday']}\n}\n\n# Define meeting parameters\nmeeting_duration = 30\nwork_hours = ('9:00', '17:00')\ndays_to_check = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n\n# Find meeting time\nmeeting_time = find_meeting_time(\n    participants_schedules,\n    preferences,\n    meeting_duration,\n    work_hours[0],\n    work_hours[1],\n    days_to_check\n)\n\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_876"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Days to consider: Monday (0), Tuesday (1), Wednesday (2), Thursday (3)\n    days = [0, 1, 2, 3]\n    \n    # Daniel's busy times (in minutes since midnight)\n    daniel_busy = {\n        0: [(9*60, 9*60+30), (10*60, 10*60+30), (11*60, 11*60+30), (16*60+30, 17*60)],\n        1: [(10*60, 10*60+30), (13*60+30, 14*60+30)],\n        2: [(10*60+30, 11*60), (12*60+30, 13*60), (14*60, 14*60+30)],\n        3: [(9*60, 9*60+30), (10*60, 11*60+30), (12*60+30, 13*60+30), (14*60, 16*60)]\n    }\n    \n    # Dorothy's busy times (in minutes since midnight)\n    dorothy_busy = {\n        0: [(9*60, 10*60), (10*60+30, 12*60+30), (13*60, 13*60+30), (14*60, 15*60), (15*60+30, 16*60+30)],\n        1: [(9*60+30, 10*60), (11*60, 12*60+30), (15*60+30, 17*60)],\n        2: [(9*60, 9*60+30), (10*60, 10*60+30), (11*60, 11*60+30), (12*60, 13*60), (14*60, 15*60+30), (16*60, 17*60)],\n        3: [(9*60, 9*60+30), (10*60, 10*60+30), (11*60, 12*60+30), (13*60, 16*60), (16*60+30, 17*60)]\n    }\n    \n    # Constraints\n    # Daniel would rather not meet on Wednesday (day 2)\n    preferred_days = [0, 1, 3]\n    # Dorothy cannot meet on Tuesday before 14:30 (day 1 before 14:30)\n    \n    # Iterate through each day in preferred order\n    for day in preferred_days:\n        # Check Dorothy's Tuesday constraint\n        if day == 1:\n            start_time = max(work_start, 14*60 + 30)  # 14:30\n        else:\n            start_time = work_start\n        \n        # Generate all possible slots for the day\n        current_time = start_time\n        while current_time + 60 <= work_end:\n            slot_end = current_time + 60\n            # Check if slot is free for both\n            daniel_free = True\n            for busy_start, busy_end in daniel_busy.get(day, []):\n                if not (slot_end <= busy_start or current_time >= busy_end):\n                    daniel_free = False\n                    break\n            \n            dorothy_free = True\n            for busy_start, busy_end in dorothy_busy.get(day, []):\n                if not (slot_end <= busy_start or current_time >= busy_end):\n                    dorothy_free = False\n                    break\n            \n            if daniel_free and dorothy_free:\n                # Format the time as HH:MM:HH:MM\n                start_hh = current_time // 60\n                start_mm = current_time % 60\n                end_hh = slot_end // 60\n                end_mm = slot_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n            \n            # Move to next slot (increment by 30 minutes for efficiency)\n            current_time += 30\n    \n    # If no slot found in preferred days, check Wednesday (though Daniel prefers not)\n    day = 2\n    current_time = work_start\n    while current_time + 60 <= work_end:\n        slot_end = current_time + 60\n        # Check if slot is free for both\n        daniel_free = True\n        for busy_start, busy_end in daniel_busy.get(day, []):\n            if not (slot_end <= busy_start or current_time >= busy_end):\n                daniel_free = False\n                break\n        \n        dorothy_free = True\n        for busy_start, busy_end in dorothy_busy.get(day, []):\n            if not (slot_end <= busy_start or current_time >= busy_end):\n                dorothy_free = False\n                break\n        \n        if daniel_free and dorothy_free:\n            # Format the time as HH:MM:HH:MM\n            start_hh = current_time // 60\n            start_mm = current_time % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n        \n        # Move to next slot\n        current_time += 30\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_877"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Days to consider\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n\n    # Janet's schedule: each entry is (day, start, end) in minutes since midnight\n    janet_meetings = [\n        ('Monday', 11 * 60 + 30, 12 * 60),\n        ('Monday', 12 * 60 + 30, 13 * 60),\n        ('Tuesday', 11 * 60, 12 * 60 + 30),\n        ('Tuesday', 14 * 60, 14 * 60 + 30),\n        ('Tuesday', 16 * 60, 16 * 60 + 30),\n        ('Wednesday', 11 * 60, 11 * 60 + 30),\n        ('Wednesday', 13 * 60, 14 * 60),\n        ('Wednesday', 14 * 60 + 30, 15 * 60),\n        ('Wednesday', 16 * 60 + 30, 17 * 60),\n        ('Thursday', 10 * 60, 11 * 60),\n        ('Thursday', 11 * 60 + 30, 12 * 60),\n        ('Thursday', 13 * 60 + 30, 14 * 60 + 30),\n        ('Thursday', 15 * 60, 15 * 60 + 30)\n    ]\n\n    # Alan's schedule\n    alan_meetings = [\n        ('Monday', 9 * 60, 10 * 60 + 30),\n        ('Monday', 11 * 60 + 30, 12 * 60 + 30),\n        ('Monday', 13 * 60 + 30, 14 * 60),\n        ('Monday', 15 * 60 + 30, 16 * 60 + 30),\n        ('Tuesday', 9 * 60, 9 * 60 + 30),\n        ('Tuesday', 10 * 60 + 30, 11 * 60 + 30),\n        ('Tuesday', 12 * 60 + 30, 13 * 60),\n        ('Tuesday', 14 * 60, 15 * 60 + 30),\n        ('Tuesday', 16 * 60, 17 * 60),\n        ('Wednesday', 9 * 60, 9 * 60 + 30),\n        ('Wednesday', 11 * 60 + 30, 12 * 60 + 30),\n        ('Wednesday', 13 * 60 + 30, 14 * 60 + 30),\n        ('Wednesday', 15 * 60, 15 * 60 + 30),\n        ('Thursday', 9 * 60, 10 * 60),\n        ('Thursday', 10 * 60 + 30, 11 * 60),\n        ('Thursday', 11 * 60 + 30, 12 * 60),\n        ('Thursday', 13 * 60, 14 * 60),\n        ('Thursday', 14 * 60 + 30, 15 * 60),\n        ('Thursday', 15 * 60 + 30, 16 * 60 + 30)\n    ]\n\n    # Alan's constraints: not before 16:30 on Monday\n    alan_constraints = [('Monday', 0, 16 * 60 + 30)]\n\n    # Check each day for available slots\n    for day in days:\n        # Collect all busy intervals for Janet and Alan on this day\n        janet_busy = [ (start, end) for (d, start, end) in janet_meetings if d == day ]\n        alan_busy = [ (start, end) for (d, start, end) in alan_meetings if d == day ]\n        \n        # Add Alan's constraints for the day\n        for (d, start, end) in alan_constraints:\n            if d == day:\n                alan_busy.append((start, end))\n\n        # Merge and sort all busy intervals\n        all_busy = janet_busy + alan_busy\n        all_busy.sort()\n\n        # Find free intervals by checking gaps between busy intervals\n        free_slots = []\n        prev_end = work_start\n\n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after the last busy interval\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n\n        # Check each free slot for a meeting duration\n        for start, end in free_slots:\n            if end - start >= meeting_duration:\n                # Found a suitable slot\n                meeting_start = start\n                meeting_end = start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_878"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef parse_time(time_str):\n    return datetime.strptime(time_str, \"%H:%M\")\n\ndef time_to_str(time_obj):\n    return time_obj.strftime(\"%H:%M\")\n\ndef find_earliest_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration, days):\n    time_slots = []\n    meeting_duration = timedelta(minutes=meeting_duration)\n    \n    for day in days:\n        # Initialize the day's available time with work hours\n        available_start = parse_time(work_hours_start)\n        available_end = parse_time(work_hours_end)\n        \n        # Collect all busy times for the day for all participants\n        busy_times = []\n        for schedule in participants_schedules:\n            if day in schedule:\n                for busy_start, busy_end in schedule[day]:\n                    busy_start_time = parse_time(busy_start)\n                    busy_end_time = parse_time(busy_end)\n                    busy_times.append((busy_start_time, busy_end_time))\n        \n        # Sort busy times by start time\n        busy_times.sort()\n        \n        # Find available slots between busy times\n        current_time = available_start\n        for busy_start, busy_end in busy_times:\n            if busy_start > current_time:\n                slot_start = current_time\n                slot_end = busy_start\n                if slot_end - slot_start >= meeting_duration:\n                    time_slots.append((day, slot_start, slot_start + meeting_duration))\n            current_time = max(current_time, busy_end)\n        \n        # Check after last busy time\n        if available_end > current_time:\n            slot_start = current_time\n            slot_end = available_end\n            if slot_end - slot_start >= meeting_duration:\n                time_slots.append((day, slot_start, slot_start + meeting_duration))\n    \n    if not time_slots:\n        return None\n    \n    # Find the earliest possible slot\n    earliest_slot = min(time_slots, key=lambda x: (days.index(x[0]), x[1]))\n    day, start_time, end_time = earliest_slot\n    return f\"{start_time.strftime('%H:%M')}:{end_time.strftime('%H:%M')}\"\n\n# Define participants' schedules\njack_schedule = {\n    \"Monday\": [(\"13:30\", \"14:00\"), (\"15:30\", \"16:00\")],\n    \"Tuesday\": [(\"9:30\", \"11:00\"), (\"12:00\", \"12:30\"), (\"16:00\", \"16:30\")],\n    \"Wednesday\": [(\"12:00\", \"13:00\"), (\"13:30\", \"14:30\"), (\"15:00\", \"15:30\")],\n    \"Thursday\": [(\"9:00\", \"10:00\"), (\"12:00\", \"12:30\"), (\"14:30\", \"15:00\")],\n}\n\ngerald_schedule = {\n    \"Monday\": [(\"9:00\", \"10:30\"), (\"11:00\", \"13:30\"), (\"14:00\", \"15:00\"), (\"15:30\", \"16:30\")],\n    \"Tuesday\": [(\"9:00\", \"13:30\"), (\"14:00\", \"17:00\")],\n    \"Wednesday\": [(\"9:00\", \"9:30\"), (\"10:00\", \"10:30\"), (\"11:00\", \"11:30\"), (\"12:00\", \"17:00\")],\n    \"Thursday\": [(\"9:00\", \"12:30\"), (\"13:00\", \"16:00\"), (\"16:30\", \"17:00\")],\n}\n\nparticipants_schedules = [jack_schedule, gerald_schedule]\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 30\ndays = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\"]\n\nearliest_meeting = find_earliest_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration, days)\nprint(earliest_meeting)\n```",
            "count": "calendar_scheduling_example_879"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    meeting_duration = 60  # minutes\n    \n    # Define blocked times for Anna and Billy in minutes since midnight\n    # Format: {day: [(start1, end1), (start2, end2), ...]}\n    anna_blocked = {\n        'Monday': [(10 * 60, 10 * 60 + 30), (14 * 60, 15 * 60)],\n        'Tuesday': [(9 * 60 + 30, 10 * 60), (14 * 60, 15 * 60), (16 * 60 + 30, 17 * 60)],\n        'Wednesday': [(9 * 60 + 30, 10 * 60 + 30), (13 * 60 + 30, 14 * 60)],\n        'Thursday': [(9 * 60 + 30, 10 * 60), (11 * 60 + 30, 12 * 60), (13 * 60 + 30, 14 * 60), (16 * 60 + 30, 17 * 60)]\n    }\n    \n    billy_blocked = {\n        'Monday': [(9 * 60, 10 * 60 + 30), (11 * 60, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Tuesday': [(9 * 60, 17 * 60)],  # Entire day blocked\n        'Wednesday': [(9 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30), (15 * 60 + 30, 17 * 60)],\n        'Thursday': [(9 * 60, 14 * 60 + 30), (16 * 60, 16 * 60 + 30)]\n    }\n    \n    # Iterate through each day, avoiding Wednesday if possible\n    preferred_days = ['Monday', 'Thursday', 'Tuesday', 'Wednesday']  # Wednesday last due to preference\n    \n    for day in preferred_days:\n        if day == 'Wednesday' and len(preferred_days) > 1:\n            continue  # Try other days first\n        \n        # Collect all blocked times for both participants on this day\n        combined_blocked = []\n        combined_blocked.extend(anna_blocked.get(day, []))\n        combined_blocked.extend(billy_blocked.get(day, []))\n        \n        # Sort blocked intervals by start time\n        combined_blocked.sort()\n        \n        # Find free slots by checking gaps between blocked intervals\n        prev_end = work_start\n        free_slots = []\n        \n        for start, end in combined_blocked:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after last blocked interval\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for availability of meeting duration\n        for slot_start, slot_end in free_slots:\n            available_start = slot_start\n            available_end = slot_end - meeting_duration\n            \n            if available_start <= available_end:\n                # Found a suitable time\n                meeting_start = available_start\n                meeting_end = meeting_start + meeting_duration\n                \n                # Convert minutes back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                \n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    # If no time found in preferred days, try Wednesday (though problem states solution exists)\n    day = 'Wednesday'\n    combined_blocked = []\n    combined_blocked.extend(anna_blocked.get(day, []))\n    combined_blocked.extend(billy_blocked.get(day, []))\n    combined_blocked.sort()\n    \n    prev_end = work_start\n    free_slots = []\n    \n    for start, end in combined_blocked:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    for slot_start, slot_end in free_slots:\n        available_start = slot_start\n        available_end = slot_end - meeting_duration\n        \n        if available_start <= available_end:\n            meeting_start = available_start\n            meeting_end = meeting_start + meeting_duration\n            \n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            \n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No time found\"  # Shouldn't reach here per problem statement\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_880"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Days to consider\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Evelyn's blocked times in minutes since start of day\n    evelyn_blocked = {\n        'Monday': [(9*60 + 30, 10*60), (10*60 + 30, 11*60), (11*60 + 30, 12*60),\n                   (13*60, 15*60)],\n        'Tuesday': [(10*60, 11*60), (12*60, 14*60), (15*60, 15*60 + 30),\n                    (16*60, 17*60)],\n        'Wednesday': [(9*60, 10*60 + 30), (13*60 + 30, 16*60)],\n        'Thursday': [(9*60 + 30, 10*60), (11*60, 12*60), (12*60 + 30, 13*60),\n                     (15*60 + 30, 16*60 + 30)]\n    }\n    \n    # Dylan's blocked times in minutes since start of day\n    dylan_blocked = {\n        'Monday': [(9*60, 9*60 + 30), (10*60 + 30, 11*60), (13*60, 13*60 + 30),\n                   (14*60, 14*60 + 30), (15*60 + 30, 16*60 + 30)],\n        'Tuesday': [(9*60, 13*60), (13*60 + 30, 14*60), (14*60 + 30, 17*60)],\n        'Wednesday': [(9*60, 10*60 + 30), (11*60, 12*60 + 30), (13*60, 14*60),\n                      (14*60 + 30, 15*60)],\n        'Thursday': [(9*60 + 30, 10*60 + 30), (11*60 + 30, 12*60),\n                     (13*60 + 30, 14*60), (14*60 + 30, 17*60)]\n    }\n    \n    # Additional constraints\n    evelyn_no_monday_before = 16 * 60 + 30  # 16:30\n    dylan_no_tuesday = True\n    dylan_no_wednesday = True\n    dylan_no_thursday = True\n    \n    # Iterate through each day to find a suitable time\n    for day in days:\n        if day == 'Tuesday' and dylan_no_tuesday:\n            continue\n        if day == 'Wednesday' and dylan_no_wednesday:\n            continue\n        if day == 'Thursday' and dylan_no_thursday:\n            continue\n        \n        # Combine and sort all blocked times for both participants\n        all_blocked = evelyn_blocked.get(day, []) + dylan_blocked.get(day, [])\n        all_blocked.sort()\n        \n        # Check available slots\n        prev_end = work_start\n        for start, end in all_blocked:\n            if start > prev_end:\n                # Check if this slot is long enough (30 minutes)\n                if start - prev_end >= 30:\n                    # Check Evelyn's Monday constraint\n                    if day == 'Monday' and prev_end < evelyn_no_monday_before:\n                        prev_end = max(prev_end, evelyn_no_monday_before)\n                        if start - prev_end >= 30:\n                            return format_time(day, prev_end, prev_end + 30)\n                        else:\n                            continue\n                    else:\n                        return format_time(day, prev_end, prev_end + 30)\n            prev_end = max(prev_end, end)\n        \n        # Check after last blocked time\n        if work_end - prev_end >= 30:\n            if day == 'Monday' and prev_end < evelyn_no_monday_before:\n                prev_end = max(prev_end, evelyn_no_monday_before)\n                if work_end - prev_end >= 30:\n                    return format_time(day, prev_end, prev_end + 30)\n            else:\n                return format_time(day, prev_end, prev_end + 30)\n    \n    return \"No time found\"\n\ndef format_time(day, start_min, end_min):\n    start_h = start_min // 60\n    start_m = start_min % 60\n    end_h = end_min // 60\n    end_m = end_min % 60\n    return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_881"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef parse_time(time_str):\n    return datetime.strptime(time_str, \"%H:%M\")\n\ndef format_time(time_obj):\n    return time_obj.strftime(\"%H:%M\")\n\ndef find_meeting_time(participants_schedules, preferences, duration, work_hours_start, work_hours_end, days):\n    duration = timedelta(minutes=duration)\n    work_start = parse_time(work_hours_start)\n    work_end = parse_time(work_hours_end)\n    \n    for day in days:\n        if day in preferences.get(\"Virginia\", []) and \"avoid\" in preferences[\"Virginia\"][day]:\n            continue\n        if day in preferences.get(\"Kayla\", []) and \"avoid\" in preferences[\"Kayla\"][day]:\n            continue\n        \n        # Collect all busy intervals for the day\n        busy_intervals = []\n        for person, schedule in participants_schedules.items():\n            for busy in schedule.get(day, []):\n                start, end = busy.split(\" to \")\n                busy_intervals.append((parse_time(start), parse_time(end)))\n        \n        # Sort busy intervals by start time\n        busy_intervals.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in busy_intervals:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for duration\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + duration\n                return f\"{format_time(meeting_start)}:{format_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define schedules\nparticipants_schedules = {\n    \"Virginia\": {\n        \"Monday\": [\"10:00 to 11:30\", \"12:00 to 14:30\", \"15:00 to 17:00\"],\n        \"Tuesday\": [\"9:00 to 10:00\", \"12:00 to 12:30\", \"13:00 to 14:00\", \"15:00 to 17:00\"],\n        \"Wednesday\": [\"10:30 to 11:00\", \"14:30 to 15:30\"],\n        \"Thursday\": [\"10:00 to 10:30\", \"11:00 to 11:30\", \"12:00 to 12:30\", \"13:00 to 13:30\", \"15:30 to 16:30\"]\n    },\n    \"Kayla\": {\n        \"Monday\": [\"9:00 to 9:30\", \"12:00 to 13:00\"],\n        \"Tuesday\": [\"9:00 to 12:00\", \"14:00 to 14:30\", \"15:00 to 15:30\", \"16:30 to 17:00\"],\n        \"Wednesday\": [\"9:00 to 10:30\", \"11:00 to 16:30\"],\n        \"Thursday\": [\"9:00 to 10:00\", \"10:30 to 11:30\", \"12:00 to 17:00\"]\n    }\n}\n\n# Define preferences\npreferences = {\n    \"Virginia\": {\"Wednesday\": \"avoid\"},\n    \"Kayla\": {\"Monday\": \"avoid\", \"Thursday\": \"avoid\"}\n}\n\n# Find meeting time\nmeeting_time = find_meeting_time(\n    participants_schedules,\n    preferences,\n    30,\n    \"9:00\",\n    \"17:00\",\n    [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\"]\n)\n\n# Output the first available slot\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_882"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Elijah's busy times in minutes since midnight for each day\n    elijah_busy = {\n        'Monday': [(11*60, 13*60)],\n        'Tuesday': [(9*60, 10*60), (14*60, 15*30), (16*60, 16*30)],\n        'Wednesday': [(9*60, 10*60), (10*30, 11*60), (12*60, 12*30), (15*30, 16*60), (16*30, 17*60)],\n        'Thursday': [(9*60, 9*30), (10*60, 10*30), (14*30, 15*30)]\n    }\n    \n    # Debra's busy times in minutes since midnight for each day\n    debra_busy = {\n        'Monday': [(9*60, 9*30), (10*30, 11*60), (11*30, 17*60)],\n        'Tuesday': [(9*60, 15*30), (16*60, 17*60)],\n        'Wednesday': [(9*60, 17*60)],\n        'Thursday': [(9*60, 10*30), (11*60, 14*30), (15*60, 15*30), (16*60, 16*30)]\n    }\n    \n    meeting_duration = 30  # minutes\n    \n    # Iterate through each day in order\n    for day in days:\n        if day == 'Tuesday':\n            continue  # Debra can't meet on Tuesday\n        \n        # Combine and sort both participants' busy times for the day\n        combined_busy = elijah_busy.get(day, []) + debra_busy.get(day, [])\n        combined_busy.sort()\n        \n        # Find free slots\n        prev_end = work_start\n        for start, end in combined_busy:\n            if start > prev_end:\n                # Check if there's enough time for the meeting\n                if start - prev_end >= meeting_duration:\n                    # Format the time as HH:MM:HH:MM\n                    start_time = f\"{prev_end // 60:02d}:{prev_end % 60:02d}\"\n                    end_time = f\"{(prev_end + meeting_duration) // 60:02d}:{(prev_end + meeting_duration) % 60:02d}\"\n                    return f\"{start_time}:{end_time}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after the last busy slot\n        if work_end - prev_end >= meeting_duration:\n            start_time = f\"{prev_end // 60:02d}:{prev_end % 60:02d}\"\n            end_time = f\"{(prev_end + meeting_duration) // 60:02d}:{(prev_end + meeting_duration) % 60:02d}\"\n            return f\"{start_time}:{end_time}\"\n    \n    return \"No suitable time found\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_883"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Jason's busy times in minutes since midnight for each day\n    jason_busy = {\n        'Monday': [(9*60, 10*60 + 30), (13*60, 13*60 + 30), (15*60, 15*60 + 30), (16*60, 16*60 + 30)],\n        'Tuesday': [(10*60, 15*60)],\n        'Wednesday': [(9*60 + 30, 11*60), (11*60 + 30, 12*60), (12*60 + 30, 13*60), (13*60 + 30, 14*60)],\n        'Thursday': [(10*60 + 30, 11*60), (12*60 + 30, 13*60), (14*60 + 30, 15*60), (15*60 + 30, 16*60)]\n    }\n    \n    # Lori's busy times in minutes since midnight for each day\n    lori_busy = {\n        'Monday': [(10*60 + 30, 11*60), (12*60, 12*60 + 30), (13*60 + 30, 14*60), (16*60, 16*60 + 30)],\n        'Tuesday': [(10*60, 12*60), (12*60 + 30, 14*60 + 30), (15*60, 17*60)],\n        'Wednesday': [(9*60, 9*60 + 30), (10*60, 11*60), (13*60, 13*60 + 30), (14*60, 14*60 + 30), (15*60 + 30, 16*60 + 30)],\n        'Thursday': [(9*60, 12*60), (12*60 + 30, 13*60 + 30), (15*60 + 30, 17*60)]\n    }\n    \n    # Lori cannot meet on Wednesday\n    days_to_check = [day for day in days if day != 'Wednesday']\n    \n    # Check each day in order\n    for day in days_to_check:\n        # Get busy intervals for both participants\n        jason_intervals = jason_busy.get(day, [])\n        lori_intervals = lori_busy.get(day, [])\n        \n        # Combine and sort all busy intervals\n        all_busy = jason_intervals + lori_intervals\n        all_busy.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for a 30-minute window\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= 30:\n                meeting_start = slot_start\n                meeting_end = meeting_start + 30\n                # Convert back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_884"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Define Jesse's availability (completely free)\n    jesse_availability = {day: [(work_start, work_end)] for day in days}\n    \n    # Define Jerry's busy times in minutes since midnight\n    jerry_busy = {\n        'Monday': [(11*60, 11*60+30), (12*60, 12*60+30), (13*60, 13*60+30), (14*60+30, 15*60+30)],\n        'Tuesday': [(9*60, 11*60), (11*60+30, 12*60+30), (13*60, 14*60), (14*60+30, 15*60), (15*60+30, 17*60)],\n        'Wednesday': [(9*60, 16*60+30)],\n        'Thursday': [(9*60+30, 10*60), (11*60, 14*60), (14*60+30, 15*60), (16*60, 17*60)],\n    }\n    \n    # Jerry cannot meet on Monday after 15:30\n    jerry_busy['Monday'].append((15*60+30, work_end))\n    \n    # Generate Jerry's available times by inverting busy times\n    jerry_availability = {}\n    for day in days:\n        busy_times = jerry_busy.get(day, [])\n        busy_times.sort()  # Ensure times are in order\n        available = []\n        prev_end = work_start\n        \n        for start, end in busy_times:\n            if start > prev_end:\n                available.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            available.append((prev_end, work_end))\n        \n        jerry_availability[day] = available\n    \n    # Find overlapping 1-hour slots\n    meeting_duration = 60  # minutes\n    \n    for day in days:\n        # Get both participants' available times for the day\n        jesse_times = jesse_availability[day]\n        jerry_times = jerry_availability[day]\n        \n        # Check all possible overlaps between Jesse and Jerry's available slots\n        for jesse_start, jesse_end in jesse_times:\n            for jerry_start, jerry_end in jerry_times:\n                # Find the overlapping interval\n                overlap_start = max(jesse_start, jerry_start)\n                overlap_end = min(jesse_end, jerry_end)\n                \n                if overlap_start < overlap_end:\n                    # Check if there's enough time for the meeting\n                    available_duration = overlap_end - overlap_start\n                    if available_duration >= meeting_duration:\n                        # Found a suitable time\n                        start_time = overlap_start\n                        end_time = start_time + meeting_duration\n                        \n                        # Convert minutes back to HH:MM format\n                        def format_time(minutes):\n                            hours = minutes // 60\n                            mins = minutes % 60\n                            return f\"{hours:02d}:{mins:02d}\"\n                        \n                        return f\"{format_time(start_time)}:{format_time(end_time)}\"\n    \n    return \"No suitable time found\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_885"
        },
        {
            "final_program_time": "{16:00:17:00}",
            "expected_time": "{16:00:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Define Jesse's and Robert's blocked times in minutes since midnight for each day\n    jesse_blocked = {\n        'Monday': [(9*60 + 30, 10*60), (12*60, 13*60 + 30), (14*60, 14*60 + 30), (15*60 + 30, 16*60)],\n        'Tuesday': [(9*60, 10*60), (13*60 + 30, 14*60), (15*60 + 30, 16*60), (16*60 + 30, 17*60)],\n        'Wednesday': [(11*60 + 30, 12*60 + 30), (13*60, 13*60 + 30), (15*60 + 30, 16*60)],\n        'Thursday': [(12*60, 12*60 + 30), (13*60, 13*60 + 30), (14*60, 14*60 + 30), (15*60 + 30, 16*60)]\n    }\n    \n    robert_blocked = {\n        'Monday': [(10*60, 11*60), (12*60, 13*60 + 30), (14*60, 14*60 + 30), (15*60, 16*60)],\n        'Tuesday': [(9*60, 17*60)],\n        'Wednesday': [(9*60, 13*60 + 30), (14*60, 17*60)],\n        'Thursday': [(9*60 + 30, 11*60), (11*60 + 30, 15*60), (15*60 + 30, 17*60)]\n    }\n    \n    # Jesse cannot meet on Monday before 12:00\n    jesse_blocked['Monday'].append((work_hours_start, 12*60))\n    \n    meeting_duration = 60  # 1 hour\n    \n    for day in days:\n        # Combine and sort all blocked times for both participants\n        all_blocked = jesse_blocked.get(day, []) + robert_blocked.get(day, [])\n        all_blocked.sort()\n        \n        # Merge overlapping or adjacent blocked times\n        merged_blocked = []\n        for start, end in all_blocked:\n            if not merged_blocked:\n                merged_blocked.append((start, end))\n            else:\n                last_start, last_end = merged_blocked[-1]\n                if start <= last_end:\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged_blocked[-1] = (new_start, new_end)\n                else:\n                    merged_blocked.append((start, end))\n        \n        # Check the available slots before the first blocked time, between blocked times, and after the last blocked time\n        prev_end = work_hours_start\n        for start, end in merged_blocked:\n            if start > prev_end:\n                available_start = prev_end\n                available_end = start\n                if available_end - available_start >= meeting_duration:\n                    # Found a suitable slot\n                    meeting_start = available_start\n                    meeting_end = meeting_start + meeting_duration\n                    return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after the last blocked time\n        if work_hours_end - prev_end >= meeting_duration:\n            meeting_start = prev_end\n            meeting_end = meeting_start + meeting_duration\n            return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_886"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef parse_time(time_str):\n    return datetime.strptime(time_str, \"%H:%M\").time()\n\ndef time_to_minutes(time_obj):\n    return time_obj.hour * 60 + time_obj.minute\n\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return datetime.strptime(f\"{hours:02d}:{mins:02d}\", \"%H:%M\").time()\n\ndef find_earliest_meeting_time(nancy_busy, theresa_busy, work_start, work_end, meeting_duration):\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Generate all possible slots for the day\n    all_slots = []\n    current_start = work_start_min\n    while current_start + meeting_duration <= work_end_min:\n        all_slots.append((current_start, current_start + meeting_duration))\n        current_start += 1  # Check every minute for earliest availability\n    \n    # Check each slot for availability\n    for slot in all_slots:\n        slot_start, slot_end = slot\n        nancy_available = True\n        theresa_available = True\n        \n        # Check Nancy's availability\n        for busy_start, busy_end in nancy_busy:\n            busy_start_min = time_to_minutes(busy_start)\n            busy_end_min = time_to_minutes(busy_end)\n            if not (slot_end <= busy_start_min or slot_start >= busy_end_min):\n                nancy_available = False\n                break\n        \n        # Check Theresa's availability\n        for busy_start, busy_end in theresa_busy:\n            busy_start_min = time_to_minutes(busy_start)\n            busy_end_min = time_to_minutes(busy_end)\n            if not (slot_end <= busy_start_min or slot_start >= busy_end_min):\n                theresa_available = False\n                break\n        \n        if nancy_available and theresa_available:\n            return (minutes_to_time(slot_start), minutes_to_time(slot_end))\n    \n    return None\n\n# Define work hours\nwork_start = parse_time(\"09:00\")\nwork_end = parse_time(\"17:00\")\nmeeting_duration = 30  # minutes\n\n# Define busy times for Nancy and Theresa for each day\nnancy_busy = {\n    \"Monday\": [(parse_time(\"11:00\"), parse_time(\"11:30\"))],\n    \"Wednesday\": [(parse_time(\"09:30\"), parse_time(\"10:00\")), (parse_time(\"12:00\"), parse_time(\"12:30\"))],\n    \"Thursday\": [(parse_time(\"14:00\"), parse_time(\"14:30\"))],\n    \"Tuesday\": []\n}\n\ntheresa_busy = {\n    \"Monday\": [(parse_time(\"09:00\"), parse_time(\"10:30\")), (parse_time(\"11:30\"), parse_time(\"12:00\")), \n               (parse_time(\"14:30\"), parse_time(\"15:00\")), (parse_time(\"15:30\"), parse_time(\"16:00\"))],\n    \"Tuesday\": [(parse_time(\"09:00\"), parse_time(\"09:30\")), (parse_time(\"10:00\"), parse_time(\"11:00\")), \n                (parse_time(\"11:30\"), parse_time(\"12:30\")), (parse_time(\"14:00\"), parse_time(\"14:30\")), \n                (parse_time(\"15:30\"), parse_time(\"16:00\"))],\n    \"Wednesday\": [(parse_time(\"09:00\"), parse_time(\"09:30\")), (parse_time(\"10:30\"), parse_time(\"13:00\")), \n                  (parse_time(\"14:00\"), parse_time(\"16:00\")), (parse_time(\"16:30\"), parse_time(\"17:00\"))],\n    \"Thursday\": [(parse_time(\"09:30\"), parse_time(\"11:30\")), (parse_time(\"12:00\"), parse_time(\"17:00\"))]\n}\n\ndays = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\"]\n\n# Iterate through each day to find the earliest available slot\nfor day in days:\n    n_day_busy = nancy_busy.get(day, [])\n    t_day_busy = theresa_busy.get(day, [])\n    \n    meeting_time = find_earliest_meeting_time(n_day_busy, t_day_busy, work_start, work_end, meeting_duration)\n    if meeting_time:\n        start_time, end_time = meeting_time\n        print(f\"{start_time.strftime('%H:%M')}:{end_time.strftime('%H:%M')}\")\n        break\n```",
            "count": "calendar_scheduling_example_887"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Vincent's busy times in minutes since midnight for each day\n    vincent_busy = {\n        'Monday': [(9*60, 9*60 + 30), (10*60, 11*60), (12*60, 13*60 + 30),\n                   (14*60 + 30, 15*60), (15*60 + 30, 17*60)],\n        'Tuesday': [(10*60, 13*60 + 30), (14*60, 14*60 + 30), (15*60, 17*60)],\n        'Wednesday': [(9*60, 11*60), (11*60 + 30, 12*60), (13*60, 13*60 + 30),\n                      (14*60, 16*60), (16*60 + 30, 17*60)],\n        'Thursday': [(9*60 + 30, 11*60), (11*60 + 30, 13*60), (13*60 + 30, 14*60 + 30),\n                     (15*60, 16*60), (16*60 + 30, 17*60)]\n    }\n\n    # Preferences: Benjamin avoids Wednesday, Vincent avoids Monday\n    preferred_days = [day for day in days if day not in ['Monday', 'Wednesday']]\n    # Fallback to all days if no preferred days are left (though in this case, Tuesday and Thursday remain)\n    \n    for day in preferred_days:\n        busy_slots = vincent_busy[day]\n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Check time before first busy slot\n        prev_end = work_start\n        for start, end in busy_slots:\n            if start - prev_end >= meeting_duration:\n                # Found a slot\n                meeting_start = prev_end\n                meeting_end = meeting_start + meeting_duration\n                return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n            prev_end = max(prev_end, end)\n        \n        # Check time after last busy slot\n        if work_end - prev_end >= meeting_duration:\n            meeting_start = prev_end\n            meeting_end = meeting_start + meeting_duration\n            return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n\n    # If no slot found in preferred days, check other days (though preferences are met here)\n    for day in [d for d in days if d not in preferred_days]:\n        busy_slots = vincent_busy[day]\n        busy_slots.sort()\n        prev_end = work_start\n        for start, end in busy_slots:\n            if start - prev_end >= meeting_duration:\n                meeting_start = prev_end\n                meeting_end = meeting_start + meeting_duration\n                return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n            prev_end = max(prev_end, end)\n        if work_end - prev_end >= meeting_duration:\n            meeting_start = prev_end\n            meeting_end = meeting_start + meeting_duration\n            return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_888"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to consider\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n\n    # Define Danielle's blocked times in minutes since start of day\n    danielle_blocked = {\n        'Monday': [(9*60, 9*60 + 30), (13*60 + 30, 14*60), (14*60 + 30, 15*60 + 30), (16*60, 16*60 + 30)],\n        'Tuesday': [(10*60 + 30, 11*60), (12*60, 12*60 + 30)],\n        'Wednesday': [(11*60 + 30, 12*60), (13*60 + 30, 14*60), (15*60, 15*60 + 30)],\n        'Thursday': [(9*60, 10*60), (11*60 + 30, 12*60), (16*60 + 30, 17*60)]\n    }\n\n    # Define Angela's blocked times in minutes since start of day\n    angela_blocked = {\n        'Monday': [(9*60, 16*60)],\n        'Tuesday': [(9*60, 10*60), (10*60 + 30, 11*60), (11*60 + 30, 12*60), (12*60 + 30, 17*60)],\n        'Wednesday': [(9*60, 12*60 + 30), (13*60, 13*60 + 30), (14*60 + 30, 16*60)],\n        'Thursday': [(9*60, 10*60 + 30), (11*60, 16*60 + 30)]\n    }\n\n    # Apply preferences\n    # Danielle doesn't want to meet on Wednesday\n    days.remove('Wednesday')\n    # Angela would rather not meet on Tuesday or Thursday\n    preferred_days = [day for day in days if day not in ['Tuesday', 'Thursday']]\n    # If no preferred days left, fall back to all remaining days\n    if not preferred_days:\n        preferred_days = days\n\n    # Check each day in preferred order\n    for day in preferred_days:\n        # Get both participants' blocked times for this day\n        blocked_times = sorted(danielle_blocked[day] + angela_blocked[day])\n        \n        # Find all available slots\n        available_slots = []\n        prev_end = work_start\n        \n        for start, end in blocked_times:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n        \n        # Check each available slot for enough time\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= meeting_duration:\n                # Found a suitable time\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                \n                # Convert back to HH:MM format\n                def format_time(minutes):\n                    hours = minutes // 60\n                    mins = minutes % 60\n                    return f\"{hours:02d}:{mins:02d}\"\n                \n                return f\"{format_time(meeting_start)}:{format_time(meeting_end)}\"\n\n    # If no time found in preferred days, check remaining days\n    for day in [d for d in days if d not in preferred_days]:\n        blocked_times = sorted(danielle_blocked[day] + angela_blocked[day])\n        available_slots = []\n        prev_end = work_start\n        \n        for start, end in blocked_times:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n        \n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= meeting_duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                \n                def format_time(minutes):\n                    hours = minutes // 60\n                    mins = minutes % 60\n                    return f\"{hours:02d}:{mins:02d}\"\n                \n                return f\"{format_time(meeting_start)}:{format_time(meeting_end)}\"\n\n    return \"No time found\"\n\n# Find and print the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_889"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Define participants' schedules and constraints\n    adam_schedule = {\n        'Monday': [(9*60, 9*60+30), (10*60+30, 11*60), (12*60, 12*60+30), \n                   (13*60, 14*60), (14*60+30, 15*60)],\n        'Tuesday': [(12*60+30, 15*60), (16*60, 17*60)],\n        'Wednesday': [(9*60, 10*60+30), (12*60, 14*60), (14*60+30, 15*60+30), \n                     (16*60, 17*60)],\n        'Thursday': [(9*60, 9*60+30), (12*60, 13*60+30)]\n    }\n    \n    sandra_schedule = {\n        'Monday': [(9*60, 17*60)],\n        'Tuesday': [(9*60, 14*60), (14*60+30, 16*60+30)],\n        'Wednesday': [(9*60, 10*60+30), (11*60, 11*60+30), (12*60, 12*60+30), \n                      (13*60, 13*60+30), (15*60, 17*60)],\n        'Thursday': [(9*60, 11*60+30), (12*60+30, 17*60)]\n    }\n    \n    # Adam's constraints: avoid Wednesday after 12:30 (but his schedule already reflects this)\n    \n    # Iterate through each day to find a 30-minute slot\n    for day in days:\n        # Combine both participants' busy times and sort\n        busy_times = []\n        if day in adam_schedule:\n            busy_times.extend(adam_schedule[day])\n        if day in sandra_schedule:\n            busy_times.extend(sandra_schedule[day])\n        \n        # Sort busy times by start time\n        busy_times.sort()\n        \n        # Check available slots\n        prev_end = work_hours_start\n        for busy_start, busy_end in busy_times:\n            if busy_start > prev_end:\n                # Found a potential slot\n                slot_start = prev_end\n                slot_end = busy_start\n                if slot_end - slot_start >= 30:  # Check if slot is long enough\n                    # Convert to HH:MM format\n                    start_hh = slot_start // 60\n                    start_mm = slot_start % 60\n                    end_hh = (slot_start + 30) // 60\n                    end_mm = (slot_start + 30) % 60\n                    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n            prev_end = max(prev_end, busy_end)\n        \n        # Check after last busy time\n        if work_hours_end - prev_end >= 30:\n            start_hh = prev_end // 60\n            start_mm = prev_end % 60\n            end_hh = (prev_end + 30) // 60\n            end_mm = (prev_end + 30) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Execute and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_890"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to consider (Monday=0, Tuesday=1, Wednesday=2, Thursday=3)\n    days = [2, 3]  # Excluding Monday (0) and Tuesday (1) as per Maria's preference\n    \n    # Maria's schedule: {day: [list of busy intervals in minutes]}\n    maria_schedule = {\n        2: [(9*60, 9*60+30), (12*60, 12*60+30), (14*60, 14*60+30), (16*60, 17*60)],\n        3: [(10*60, 11*60+30), (13*60, 13*60+30), (14*60, 15*60), (15*60+30, 16*60)]\n    }\n    \n    # Margaret's schedule: {day: [list of busy intervals in minutes]}\n    margaret_schedule = {\n        2: [(9*60, 9*60+30), (10*60, 12*60+30), (13*60+30, 14*60), (15*60+30, 16*60)],\n        3: [(9*60, 10*60), (11*60, 11*60+30), (12*60+30, 13*60), (13*60+30, 14*60), (15*60, 15*60+30), (16*60, 16*60+30)]\n    }\n    \n    # Iterate through each day in order\n    for day in days:\n        # Get both schedules for the day\n        maria_busy = maria_schedule.get(day, [])\n        margaret_busy = margaret_schedule.get(day, [])\n        \n        # Combine and sort all busy intervals\n        all_busy = maria_busy + margaret_busy\n        all_busy.sort()\n        \n        # Find free intervals\n        free_intervals = []\n        prev_end = work_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_intervals.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_intervals.append((prev_end, work_end))\n        \n        # Check each free interval for 30-minute availability\n        for start, end in free_intervals:\n            duration_needed = 30\n            if end - start >= duration_needed:\n                # Found a suitable time\n                meeting_start = start\n                meeting_end = meeting_start + duration_needed\n                \n                # Convert back to HH:MM format\n                def minutes_to_time(minutes):\n                    hh = minutes // 60\n                    mm = minutes % 60\n                    return f\"{hh:02d}:{mm:02d}\"\n                \n                day_name = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\"][day]\n                start_str = minutes_to_time(meeting_start)\n                end_str = minutes_to_time(meeting_end)\n                return f\"{start_str}:{end_str}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_891"
        },
        {
            "final_program_time": "{9:30:10:30}",
            "expected_time": "{9:30:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Define busy times for Willie and Michael in minutes since midnight\n    willie_busy = {\n        'Monday': [(10*60 + 30, 11*60), (11*60 + 30, 12*60), (14*60 + 30, 15*60), (15*60 + 30, 16*60)],\n        'Tuesday': [(10*60 + 30, 11*60), (13*60, 13*60 + 30), (15*60 + 30, 17*60)],\n        'Wednesday': [(9*60, 9*60 + 30), (14*60, 14*60 + 30), (16*60, 16*60 + 30)],\n        'Thursday': [(9*60, 10*60), (11*60, 12*60), (13*60 + 30, 14*60), (14*60 + 30, 15*60), (15*60 + 30, 16*60 + 30)]\n    }\n    \n    michael_busy = {\n        'Monday': [(9*60 + 30, 10*60 + 30), (11*60, 11*60 + 30), (12*60, 14*60 + 30), (15*60, 17*60)],\n        'Tuesday': [(9*60, 9*60 + 30), (11*60, 12*60), (12*60 + 30, 13*60 + 30), (14*60 + 30, 15*60), (16*60, 16*60 + 30)],\n        'Wednesday': [(9*60, 9*60 + 30), (10*60 + 30, 11*60), (11*60 + 30, 12*60), (13*60, 13*60 + 30), (14*60, 14*60 + 30), (15*60, 15*60 + 30), (16*60 + 30, 17*60)],\n        'Thursday': [(9*60, 10*60 + 30), (11*60, 12*60), (14*60, 14*60 + 30), (16*60, 17*60)]\n    }\n    \n    # Duration in minutes\n    duration = 60\n    \n    # Prefer to avoid Wednesday, so check other days first\n    preferred_days_order = ['Monday', 'Tuesday', 'Thursday', 'Wednesday']\n    \n    for day in preferred_days_order:\n        # Generate all possible slots for the day\n        slots = []\n        current_time = work_start\n        while current_time + duration <= work_end:\n            slots.append((current_time, current_time + duration))\n            current_time += 30  # Check every 30 minutes for flexibility\n        \n        # Check each slot for availability\n        for start, end in slots:\n            # Check Willie's availability\n            willie_available = True\n            for busy_start, busy_end in willie_busy[day]:\n                if not (end <= busy_start or start >= busy_end):\n                    willie_available = False\n                    break\n            \n            # Check Michael's availability if Willie is available\n            if willie_available:\n                michael_available = True\n                for busy_start, busy_end in michael_busy[day]:\n                    if not (end <= busy_start or start >= busy_end):\n                        michael_available = False\n                        break\n                \n                if michael_available:\n                    # Format the time as HH:MM:HH:MM\n                    start_hh = start // 60\n                    start_mm = start % 60\n                    end_hh = end // 60\n                    end_mm = end % 60\n                    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_892"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Michelle's constraints (in minutes since midnight)\n    michelle_busy = {\n        'Monday': [(11 * 60, 11 * 60 + 30), (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60)],\n        'Tuesday': [(10 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60 + 30), (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60)],\n        'Wednesday': [(10 * 60, 10 * 60 + 30), (15 * 60, 16 * 60)],\n        'Thursday': [(11 * 60, 11 * 60 + 30), (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60 + 30)]\n    }\n    \n    # Julie's constraints (in minutes since midnight)\n    julie_busy = {\n        'Monday': [(9 * 60, 17 * 60)],\n        'Tuesday': [(11 * 60, 12 * 60), (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60), (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Wednesday': [(9 * 60, 9 * 60 + 30), (10 * 60, 13 * 60 + 30), (14 * 60, 15 * 60), (16 * 60, 17 * 60)],\n        'Thursday': [(9 * 60, 10 * 60), (11 * 60, 12 * 60 + 30), (14 * 60, 15 * 60), (15 * 60 + 30, 17 * 60)]\n    }\n    \n    # Michelle doesn't want to meet on Tuesday\n    days_to_check = [day for day in days if day != 'Tuesday']\n    \n    for day in days_to_check:\n        # Collect all busy intervals for both participants\n        busy_intervals = michelle_busy.get(day, []) + julie_busy.get(day, [])\n        busy_intervals.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in busy_intervals:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check for a 30-minute slot\n        for start, end in free_slots:\n            if end - start >= 30:\n                meeting_start = start\n                meeting_end = meeting_start + 30\n                # Convert back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No meeting time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_893"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to consider (Monday=0, Tuesday=1, Wednesday=2, Thursday=3)\n    days = [1, 2, 3]  # Excluding Monday (0) as Jean doesn't want to meet then\n\n    # Lisa's busy times in minutes since midnight for each day\n    lisa_busy = {\n        0: [(9*60, 10*60 + 30)],  # Monday\n        1: [(10*60 + 30, 11*60), (11*60 + 30, 12*60)],  # Tuesday\n        2: [(13*60, 13*60 + 30), (15*60, 15*60 + 30)],  # Wednesday\n        3: [(9*60, 9*60 + 30), (12*60 + 30, 13*60), (13*60 + 30, 14*60), (16*60, 17*60)]  # Thursday\n    }\n\n    # Jean's busy times in minutes since midnight for each day\n    jean_busy = {\n        0: [(9*60, 15*60 + 30), (16*60 + 30, 17*60)],  # Monday\n        1: [(9*60, 17*60)],  # Tuesday (entire day)\n        2: [(9*60, 13*60 + 30), (14*60 + 30, 17*60)],  # Wednesday\n        3: [(9*60, 17*60)]  # Thursday (entire day)\n    }\n\n    # Iterate through each day\n    for day in days:\n        # Get busy times for Lisa and Jean for the day\n        lisa_day = lisa_busy.get(day, [])\n        jean_day = jean_busy.get(day, [])\n\n        # Combine and sort all busy intervals\n        all_busy = lisa_day + jean_day\n        all_busy.sort()\n\n        # Find free slots\n        prev_end = work_start\n        free_slots = []\n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n\n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= meeting_duration:\n                # Found a suitable slot\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                # Convert back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Execute and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_894"
        },
        {
            "final_program_time": "{13:30:14:30}",
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Days to consider: Monday (0), Tuesday (1), Wednesday (2), Thursday (3)\n    days = [0, 1, 2, 3]\n    \n    # Alexander's schedule: {day: [busy_intervals]}\n    alexander_busy = {\n        0: [(11*60, 11*60+30), (13*60, 13*60+30), (16*60+30, 17*60)],\n        1: [(9*60, 10*60+30), (12*60, 13*60), (13*60+30, 15*60)],\n        2: [(9*60, 9*60+30), (10*60, 10*60+30), (11*60, 11*60+30),\n            (12*60, 13*60), (14*60, 14*60+30), (15*60, 15*60+30), (16*60, 17*60)],\n        3: [(9*60, 11*60+30), (13*60, 13*60+30), (14*60+30, 16*60+30)]\n    }\n    \n    # Victoria's schedule: {day: [busy_intervals]}\n    victoria_busy = {\n        0: [(9*60, 15*60), (16*60, 17*60)],\n        1: [(9*60, 9*60+30), (10*60+30, 11*60), (12*60+30, 13*60),\n            (13*60+30, 14*60), (14*60+30, 15*60), (16*60, 16*60+30)],\n        2: [(9*60, 10*60+30), (11*60, 12*60+30), (13*60, 14*60), (15*60, 16*60+30)],\n        3: [(11*60+30, 12*60), (12*60+30, 13*60), (15*60+30, 16*60)]\n    }\n    \n    # Duration of the meeting in minutes\n    duration = 60\n    \n    # Preferences: Alexander doesn't want Monday (0), Victoria doesn't want Tuesday (1)\n    preferred_days = [day for day in days if day != 0 and day != 1]\n    \n    # Iterate through preferred days first, then others\n    for day in preferred_days + [0, 1]:\n        # Get busy intervals for both participants\n        a_busy = alexander_busy.get(day, [])\n        v_busy = victoria_busy.get(day, [])\n        \n        # Combine and sort all busy intervals\n        all_busy = a_busy + v_busy\n        all_busy.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if work_end > prev_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check for a slot that can fit the meeting\n        for start, end in free_slots:\n            if end - start >= duration:\n                meeting_start = start\n                meeting_end = meeting_start + duration\n                # Convert to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_895"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to consider based on preferences\n    days = {\n        \"Monday\": False,    # Ann doesn't want Monday\n        \"Tuesday\": True,     # Sharon doesn't want Tuesday, but Ann is okay\n        \"Wednesday\": True,\n        \"Thursday\": False    # Ann doesn't want Thursday\n    }\n    \n    # Ann's busy times in minutes since midnight\n    ann_busy = {\n        \"Tuesday\": [(11 * 60 + 30, 12 * 60)],  # 11:30-12:00\n        \"Wednesday\": [(11 * 60, 11 * 60 + 30)]  # 11:00-11:30\n    }\n    \n    # Sharon's busy times in minutes since midnight\n    sharon_busy = {\n        \"Tuesday\": [\n            (9 * 60 + 30, 10 * 60),      # 9:30-10:00\n            (10 * 60 + 30, 11 * 60 + 30), # 10:30-11:30\n            (12 * 60, 13 * 60),           # 12:00-13:00\n            (14 * 60, 15 * 60 + 30),      # 14:00-15:30\n            (16 * 60 + 30, 17 * 60)       # 16:30-17:00\n        ],\n        \"Wednesday\": [\n            (10 * 60, 11 * 60),           # 10:00-11:00\n            (11 * 60 + 30, 13 * 60 + 30), # 11:30-13:30\n            (14 * 60, 15 * 60),          # 14:00-15:00\n            (15 * 60 + 30, 16 * 60 + 30)  # 15:30-16:30\n        ]\n    }\n    \n    # Check each day\n    for day in days:\n        if not days[day]:\n            continue\n        \n        # Get busy intervals for both participants\n        ann_intervals = ann_busy.get(day, [])\n        sharon_intervals = sharon_busy.get(day, [])\n        \n        # Combine and sort all busy intervals\n        all_busy = ann_intervals + sharon_intervals\n        all_busy.sort()\n        \n        # Find free slots\n        prev_end = work_start\n        free_slots = []\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check for a 1-hour (60-minute) slot\n        for start, end in free_slots:\n            if end - start >= 60:\n                meeting_start = start\n                meeting_end = start + 60\n                # Format the time as HH:MM:HH:MM\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_896"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{10:00:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Define busy times for Gabriel and Cynthia in minutes since midnight\n    gabriel_busy = {\n        'Monday': [(9*60 + 30, 10*60 + 30), (12*60 + 30, 14*60), (15*60, 15*60 + 30)],\n        'Tuesday': [(11*60, 11*60 + 30), (12*60, 12*60 + 30)],\n        'Wednesday': [(9*60 + 30, 10*60), (12*60, 12*60 + 30)],\n        'Thursday': [(10*60, 11*60), (11*60 + 30, 12*60), (16*60 + 30, 17*60)]\n    }\n    \n    cynthia_busy = {\n        'Monday': [(9*60, 12*60 + 30), (13*60, 13*60 + 30), (14*60, 17*60)],\n        'Tuesday': [(9*60, 17*60)],\n        'Wednesday': [(9*60, 10*60), (11*60, 13*60), (13*60 + 30, 17*60)],\n        'Thursday': [(9*60, 16*60), (16*60 + 30, 17*60)]\n    }\n    \n    meeting_duration = 60  # 1 hour in minutes\n    \n    for day in days:\n        # Collect all busy intervals for both participants on this day\n        busy_intervals = gabriel_busy.get(day, []) + cynthia_busy.get(day, [])\n        busy_intervals.sort()  # Sort by start time\n        \n        # Find free slots by checking gaps between busy intervals\n        prev_end = work_start\n        for start, end in busy_intervals:\n            if start > prev_end:\n                # Found a free slot from prev_end to start\n                if start - prev_end >= meeting_duration:\n                    # Convert minutes back to HH:MM format\n                    start_time = f\"{prev_end // 60:02d}:{prev_end % 60:02d}\"\n                    end_time = f\"{(prev_end + meeting_duration) // 60:02d}:{(prev_end + meeting_duration) % 60:02d}\"\n                    return f\"{start_time}:{end_time}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy interval\n        if work_end - prev_end >= meeting_duration:\n            start_time = f\"{prev_end // 60:02d}:{prev_end % 60:02d}\"\n            end_time = f\"{(prev_end + meeting_duration) // 60:02d}:{(prev_end + meeting_duration) % 60:02d}\"\n            return f\"{start_time}:{end_time}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_897"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Define participants' schedules and preferences\n    william_busy = {\n        'Monday': [(12 * 60, 12 * 60 + 30), (14 * 60 + 30, 15 * 60)],\n        'Tuesday': [(9 * 60, 9 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n        'Wednesday': [(9 * 60, 9 * 60 + 30), (12 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Thursday': [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 11 * 60)]\n    }\n    carol_busy = {\n        'Monday': [(9 * 60, 11 * 60 + 30), (12 * 60, 13 * 60), (13 * 60 + 30, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 17 * 60)],\n        'Wednesday': [(9 * 60, 10 * 60 + 30), (11 * 60, 11 * 60 + 30), (12 * 60, 13 * 60 + 30), (14 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Thursday': [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 11 * 60 + 30), (13 * 60 + 30, 16 * 60 + 30)]\n    }\n    \n    # Apply preferences: William doesn't want Thursday, Carol prefers not Monday or Wednesday\n    preferred_days = ['Tuesday']  # Only Tuesday is left after preferences\n    \n    for day in preferred_days:\n        # Collect all busy intervals for the day\n        busy_intervals = william_busy[day] + carol_busy[day]\n        busy_intervals.sort()\n        \n        # Find free intervals\n        free_intervals = []\n        prev_end = work_start\n        \n        for start, end in busy_intervals:\n            if start > prev_end:\n                free_intervals.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_intervals.append((prev_end, work_end))\n        \n        # Check for a 30-minute slot\n        for start, end in free_intervals:\n            if end - start >= 30:\n                meeting_start = start\n                meeting_end = meeting_start + 30\n                # Format the time as HH:MM:HH:MM\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_898"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to consider\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Christian's schedule: {day: list of (start, end) meetings in minutes}\n    christian_schedule = {\n        'Monday': [(11 * 60 + 30, 12 * 60), (13 * 60 + 30, 14 * 60), (15 * 60, 15 * 60 + 30)],\n        'Tuesday': [(10 * 60, 10 * 60 + 30), (14 * 60, 14 * 60 + 30)],\n        'Wednesday': [(10 * 60, 11 * 60), (12 * 60, 12 * 60 + 30), (13 * 60, 14 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Thursday': [(10 * 60 + 30, 11 * 60), (13 * 60, 13 * 60 + 30)]\n    }\n    \n    # Abigail's schedule: {day: list of (start, end) meetings in minutes}\n    abigail_schedule = {\n        'Monday': [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 12 * 60 + 30), (13 * 60, 14 * 60 + 30), (15 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 9 * 60 + 30), (10 * 60, 12 * 60), (12 * 60 + 30, 13 * 60 + 30), (14 * 60, 16 * 60 + 30)],\n        'Wednesday': [(9 * 60, 10 * 60 + 30), (11 * 60, 14 * 60), (14 * 60 + 30, 17 * 60)],\n        'Thursday': [(9 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60 + 30), (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)]\n    }\n    \n    # Constraints:\n    # Christian wants to avoid more meetings on Thursday\n    # Abigail does not want to meet on Monday after 9:30 or on Tuesday\n    \n    # Remove days based on constraints\n    days_to_check = [day for day in days if day not in ['Thursday', 'Tuesday']]\n    \n    for day in days_to_check:\n        # Get busy times for both participants on this day\n        christian_busy = christian_schedule.get(day, [])\n        abigail_busy = abigail_schedule.get(day, [])\n        \n        # Combine and sort all busy times\n        all_busy = christian_busy + abigail_busy\n        all_busy.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check for a 30-minute slot\n        for start, end in free_slots:\n            if end - start >= 30:\n                meeting_start = start\n                meeting_end = start + 30\n                # Format the time as HH:MM:HH:MM\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    # If no slot found in preferred days, check Thursday (even though Christian prefers not to)\n    day = 'Thursday'\n    christian_busy = christian_schedule.get(day, [])\n    abigail_busy = abigail_schedule.get(day, [])\n    \n    all_busy = christian_busy + abigail_busy\n    all_busy.sort()\n    \n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    for start, end in free_slots:\n        if end - start >= 30:\n            meeting_start = start\n            meeting_end = start + 30\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_899"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to consider (Monday to Friday)\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n    \n    # Jeremy's schedule: {day: [(busy_start, busy_end), ...]}\n    jeremy_schedule = {\n        'Monday': [(12 * 60, 13 * 60 + 30), (14 * 60 + 30, 16 * 60 + 30)],\n        'Tuesday': [(9 * 60, 10 * 60), (11 * 60, 11 * 60 + 30), (14 * 60, 14 * 60 + 30), (16 * 60, 17 * 60)],\n        'Wednesday': [(10 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60), (16 * 60, 16 * 60 + 30)],\n        'Thursday': [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 11 * 60), (11 * 60 + 30, 12 * 60), \n                     (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60), (15 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Friday': [(9 * 60, 9 * 60 + 30), (16 * 60 + 30, 17 * 60)]\n    }\n    \n    # Lori's schedule: {day: [(busy_start, busy_end), ...]}\n    lori_schedule = {\n        'Monday': [(14 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60, 11 * 60), (11 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60 + 30), (15 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 10 * 60), (10 * 60 + 30, 13 * 60 + 30), (14 * 60, 17 * 60)],\n        'Thursday': [(9 * 60, 11 * 60 + 30), (12 * 60 + 30, 17 * 60)],\n        'Friday': [(9 * 60 + 30, 13 * 60), (13 * 60 + 30, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)]\n    }\n    \n    # Duration of the meeting in minutes\n    duration = 60\n    \n    # Iterate through each day (excluding Friday first to prioritize earlier days)\n    prioritized_days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n    \n    for day in prioritized_days:\n        if day == 'Friday' and len(prioritized_days) > 1:\n            continue  # Skip Friday initially to prioritize other days\n        \n        # Get both participants' schedules for the day\n        jeremy_busy = jeremy_schedule.get(day, [])\n        lori_busy = lori_schedule.get(day, [])\n        \n        # Combine and sort all busy intervals for the day\n        all_busy = jeremy_busy + lori_busy\n        all_busy.sort()\n        \n        # Find free slots by checking gaps between busy intervals\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check the slot after the last busy interval\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for availability of duration\n        for slot_start, slot_end in free_slots:\n            available_start = slot_start\n            available_end = slot_end - duration\n            \n            if available_start <= available_end:\n                # Found a valid slot, convert to HH:MM format\n                meeting_start = available_start\n                meeting_end = meeting_start + duration\n                \n                # Format the time\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                \n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    # If no slot found in prioritized days, check Friday (though Lori prefers to avoid)\n    day = 'Friday'\n    jeremy_busy = jeremy_schedule.get(day, [])\n    lori_busy = lori_schedule.get(day, [])\n    all_busy = jeremy_busy + lori_busy\n    all_busy.sort()\n    \n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    for slot_start, slot_end in free_slots:\n        available_start = slot_start\n        available_end = slot_end - duration\n        \n        if available_start <= available_end:\n            meeting_start = available_start\n            meeting_end = meeting_start + duration\n            \n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            \n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_900"
        },
        {
            "final_program_time": "{9:30:10:30}",
            "expected_time": "{9:30:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Define days to consider (Monday to Friday, excluding Thursday per Sean's preference)\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Friday']\n\n    # Sean's schedule: {day: [(busy_start, busy_end), ...]}\n    sean_schedule = {\n        'Monday': [(9.5 * 60, 10 * 60), (11.5 * 60, 12 * 60), (14.5 * 60, 15 * 60)],\n        'Tuesday': [(9 * 60, 10.5 * 60), (12 * 60, 12.5 * 60), (16.5 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 9.5 * 60), (11 * 60, 11.5 * 60), (12 * 60, 12.5 * 60), \n                      (13 * 60, 13.5 * 60), (16 * 60, 16.5 * 60)],\n        'Friday': [(9 * 60, 9.5 * 60), (12 * 60, 13 * 60), (13.5 * 60, 14 * 60), \n                   (15 * 60, 16.5 * 60)],\n    }\n\n    # Paul's schedule: {day: [(busy_start, busy_end), ...]}\n    paul_schedule = {\n        'Monday': [(10 * 60, 10.5 * 60), (11 * 60, 15.5 * 60), (16 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 12.5 * 60), (13 * 60, 14 * 60), (14.5 * 60, 16 * 60)],\n        'Wednesday': [(13.5 * 60, 14 * 60), (14.5 * 60, 15 * 60), (15.5 * 60, 16 * 60)],\n        'Friday': [(10 * 60, 10.5 * 60), (11 * 60, 11.5 * 60), (12 * 60, 13 * 60), \n                   (14 * 60, 14.5 * 60), (15 * 60, 16 * 60), (16.5 * 60, 17 * 60)],\n    }\n\n    for day in days:\n        # Get both schedules for the day\n        sean_busy = sean_schedule.get(day, [])\n        paul_busy = paul_schedule.get(day, [])\n\n        # Combine and sort all busy intervals\n        all_busy = sorted(sean_busy + paul_busy, key=lambda x: x[0])\n\n        # Find free slots\n        prev_end = work_start\n        free_slots = []\n\n        for busy_start, busy_end in all_busy:\n            if busy_start > prev_end:\n                free_slots.append((prev_end, busy_start))\n            prev_end = max(prev_end, busy_end)\n\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n\n        # Check for a slot that can fit the meeting\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= meeting_duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                start_hh = int(meeting_start // 60)\n                start_mm = int(meeting_start % 60)\n                end_hh = int(meeting_end // 60)\n                end_mm = int(meeting_end % 60)\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_901"
        },
        {
            "final_program_time": null,
            "expected_time": "{15:30:16:30}",
            "type_error": null,
            "full_response": "```python\nfrom typing import List, Dict, Tuple\n\ndef parse_time(time_str: str) -> int:\n    \"\"\"Convert time string in HH:MM format to minutes since 9:00.\"\"\"\n    hh, mm = map(int, time_str.split(':'))\n    return (hh - 9) * 60 + mm\n\ndef format_time(minutes: int) -> str:\n    \"\"\"Convert minutes since 9:00 back to HH:MM format.\"\"\"\n    hh = 9 + minutes // 60\n    mm = minutes % 60\n    return f\"{hh:02d}:{mm:02d}\"\n\ndef find_earliest_meeting_time(\n    schedules: Dict[str, List[Tuple[int, int]]],\n    duration: int,\n    days: List[str],\n    work_hours: Tuple[str, str]\n) -> str:\n    \"\"\"Find the earliest available meeting time that fits all participants' schedules.\"\"\"\n    work_start = parse_time(work_hours[0])\n    work_end = parse_time(work_hours[1])\n    \n    # Combine all busy intervals from all participants\n    all_busy = []\n    for person in schedules.values():\n        all_busy.extend(person)\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append([start, end])\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1][1] = max(end, last_end)\n            else:\n                merged.append([start, end])\n    \n    # Check the time before the first busy interval\n    prev_end = work_start\n    for start, end in merged:\n        if start - prev_end >= duration:\n            return f\"{format_time(prev_end)}:{format_time(prev_end + duration)}\"\n        prev_end = max(prev_end, end)\n    \n    # Check the time after the last busy interval\n    if work_end - prev_end >= duration:\n        return f\"{format_time(prev_end)}:{format_time(prev_end + duration)}\"\n    \n    return \"No available time found\"\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 60  # minutes\n\n# Define schedules for Lawrence and John\nlawrence_schedule = [\n    (parse_time(\"9:30\"), parse_time(\"10:00\")),\n    (parse_time(\"10:30\"), parse_time(\"11:00\")),\n    (parse_time(\"15:30\"), parse_time(\"16:00\")),\n    (parse_time(\"9:00\"), parse_time(\"9:30\")),  # Tuesday\n    (parse_time(\"10:00\"), parse_time(\"11:00\")),\n    (parse_time(\"11:30\"), parse_time(\"12:00\")),\n    (parse_time(\"13:30\"), parse_time(\"14:00\")),\n    (parse_time(\"9:00\"), parse_time(\"9:30\")),  # Wednesday\n    (parse_time(\"10:00\"), parse_time(\"10:30\")),\n    (parse_time(\"11:00\"), parse_time(\"11:30\")),\n    (parse_time(\"13:00\"), parse_time(\"13:30\")),\n    (parse_time(\"15:00\"), parse_time(\"16:00\")),\n    (parse_time(\"16:30\"), parse_time(\"17:00\")),\n    (parse_time(\"9:00\"), parse_time(\"9:30\")),  # Thursday\n    (parse_time(\"11:00\"), parse_time(\"12:30\")),\n    (parse_time(\"13:30\"), parse_time(\"14:00\")),\n    (parse_time(\"16:00\"), parse_time(\"16:30\")),\n    (parse_time(\"9:30\"), parse_time(\"11:00\")),  # Friday\n    (parse_time(\"11:30\"), parse_time(\"12:30\")),\n    (parse_time(\"13:00\"), parse_time(\"14:00\")),\n    (parse_time(\"15:00\"), parse_time(\"15:30\")),\n    (parse_time(\"16:00\"), parse_time(\"16:30\")),\n]\n\njohn_schedule = [\n    (parse_time(\"9:00\"), parse_time(\"12:30\")),  # Monday\n    (parse_time(\"13:00\"), parse_time(\"14:00\")),\n    (parse_time(\"14:30\"), parse_time(\"16:30\")),\n    (parse_time(\"9:30\"), parse_time(\"10:30\")),  # Tuesday\n    (parse_time(\"11:30\"), parse_time(\"13:00\")),\n    (parse_time(\"14:00\"), parse_time(\"15:30\")),\n    (parse_time(\"16:30\"), parse_time(\"17:00\")),\n    (parse_time(\"9:00\"), parse_time(\"12:00\")),  # Wednesday\n    (parse_time(\"12:30\"), parse_time(\"13:30\")),\n    (parse_time(\"14:30\"), parse_time(\"16:00\")),\n    (parse_time(\"9:00\"), parse_time(\"10:30\")),  # Thursday\n    (parse_time(\"11:00\"), parse_time(\"11:30\")),\n    (parse_time(\"12:00\"), parse_time(\"13:30\")),\n    (parse_time(\"14:30\"), parse_time(\"16:00\")),\n    (parse_time(\"10:00\"), parse_time(\"10:30\")),  # Friday\n    (parse_time(\"12:00\"), parse_time(\"12:30\")),\n    (parse_time(\"13:00\"), parse_time(\"14:00\")),\n    (parse_time(\"15:00\"), parse_time(\"15:30\")),\n    (parse_time(\"16:00\"), parse_time(\"17:00\")),\n]\n\nschedules = {\n    \"Lawrence\": lawrence_schedule,\n    \"John\": john_schedule,\n}\n\n# Find the earliest meeting time\nmeeting_time = find_earliest_meeting_time(schedules, duration, [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"], work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_902"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration_minutes=30):\n    days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"]\n    start_hour, end_hour = work_hours\n    time_slots = []\n    \n    for day in days:\n        current_time = start_hour * 60  # Convert to minutes\n        end_time = end_hour * 60\n        \n        # Collect all busy times for the day for all participants\n        day_busy = []\n        for participant in participants_busy:\n            if day in participant:\n                for busy_slot in participant[day]:\n                    start, end = busy_slot\n                    day_busy.append((start * 60, end * 60))  # Convert to minutes\n        \n        # Sort all busy slots by start time\n        day_busy.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = current_time\n        \n        for busy_start, busy_end in day_busy:\n            if busy_start > prev_end:\n                free_slots.append((prev_end, busy_start))\n            prev_end = max(prev_end, busy_end)\n        \n        if prev_end < end_time:\n            free_slots.append((prev_end, end_time))\n        \n        # Check each free slot for duration\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= duration_minutes:\n                meeting_start = slot_start\n                meeting_end = meeting_start + duration_minutes\n                # Convert back to hours\n                start_h = meeting_start // 60\n                start_m = meeting_start % 60\n                end_h = meeting_end // 60\n                end_m = meeting_end % 60\n                time_slots.append((day, start_h, start_m, end_h, end_m))\n        \n        if time_slots:\n            break  # Found the earliest slot\n    \n    if not time_slots:\n        return None\n    \n    # Return the earliest slot (first one found)\n    day, start_h, start_m, end_h, end_m = time_slots[0]\n    return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n\n# Define participants' busy times\nashley_busy = {\n    \"Monday\": [(9, 10), (10.5, 11.5), (12, 12.5), (16, 16.5)],\n    \"Tuesday\": [(9, 12), (12.5, 13), (13.5, 14), (16, 17)],\n    \"Wednesday\": [(9.5, 10), (11, 11.5), (12, 13), (14, 15), (16, 16.5)],\n    \"Thursday\": [(9.5, 10), (10.5, 11), (12.5, 13), (14, 15), (16, 17)],\n    \"Friday\": [(10, 10.5), (11, 11.5), (14, 14.5), (16, 16.5)],\n}\n\ncarolyn_busy = {\n    \"Monday\": [(9, 17)],\n    \"Tuesday\": [(9, 13), (14, 17)],\n    \"Wednesday\": [(9.5, 10.5), (12.5, 13), (13.5, 16), (16.5, 17)],\n    \"Thursday\": [(9, 17)],\n    \"Friday\": [(9.5, 17)],\n}\n\nparticipants_busy = [ashley_busy, carolyn_busy]\nwork_hours = (9, 17)  # 9:00 to 17:00\n\n# Find the earliest meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_903"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Days to consider (0=Monday, 1=Tuesday, ..., 4=Friday)\n    days = [0, 1, 2, 3, 4]\n    \n    # Duration of the meeting in minutes\n    duration = 30\n    \n    # Daniel's busy times per day in minutes since midnight\n    daniel_busy = {\n        0: [(9*60+30, 10*60+30), (12*60, 12*60+30), (13*60, 14*60), (14*60+30, 15*60), (15*60+30, 16*60)],\n        1: [(11*60, 12*60), (13*60, 13*60+30), (15*60+30, 16*60), (16*60+30, 17*60)],\n        2: [(9*60, 10*60), (14*60, 14*60+30)],\n        3: [(10*60+30, 11*60), (12*60, 13*60), (14*60+30, 15*60), (15*60+30, 16*60)],\n        4: [(9*60, 9*60+30), (11*60+30, 12*60), (13*60, 13*60+30), (16*60+30, 17*60)]\n    }\n    \n    # Bradley's busy times per day in minutes since midnight\n    bradley_busy = {\n        0: [(9*60+30, 11*60), (11*60+30, 12*60), (12*60+30, 13*60), (14*60, 15*60)],\n        1: [(10*60+30, 11*60), (12*60, 13*60), (13*60+30, 14*60), (15*60+30, 16*60+30)],\n        2: [(9*60, 10*60), (11*60, 13*60), (13*60+30, 14*60), (14*60+30, 17*60)],\n        3: [(9*60, 12*60+30), (13*60+30, 14*60), (14*60+30, 15*60), (15*60+30, 16*60+30)],\n        4: [(9*60, 9*60+30), (10*60, 12*60+30), (13*60, 13*60+30), (14*60, 14*60+30), (15*60+30, 16*60+30)]\n    }\n    \n    # Apply preferences\n    # Daniel doesn't want Wednesday or Thursday\n    preferred_days = [day for day in days if day not in [2, 3]]\n    # Bradley doesn't want Monday, Tuesday before 12:00, or Friday\n    preferred_days = [day for day in preferred_days if day not in [0, 1, 4]]\n    \n    # Since Bradley's preferences eliminate all days, we need to relax constraints\n    # Let's relax Bradley's preferences to not include Tuesday before 12:00 and Friday\n    # So Bradley is okay with Monday, Tuesday after 12:00, Wednesday, Thursday\n    # Daniel doesn't want Wednesday or Thursday, so possible days are Monday, Tuesday\n    # Bradley doesn't want Monday, so only Tuesday after 12:00 is left\n    possible_days = [1]  # Tuesday\n    \n    for day in possible_days:\n        # Get busy times for both participants on this day\n        daniel_busy_today = daniel_busy.get(day, [])\n        bradley_busy_today = bradley_busy.get(day, [])\n        \n        # Combine and sort all busy intervals\n        all_busy = daniel_busy_today + bradley_busy_today\n        all_busy.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check if any free slot can accommodate the meeting\n        for start, end in free_slots:\n            if day == 1 and start < 12 * 60:\n                continue  # Bradley doesn't want Tuesday before 12:00\n            if end - start >= duration:\n                meeting_start = start\n                meeting_end = meeting_start + duration\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    # If no slot found (though problem states there is one), return None\n    return None\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_904"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to consider (Monday to Friday)\n    days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"]\n\n    # Define Amy's busy times in minutes since midnight\n    amy_busy = {\n        \"Monday\": [(10 * 60 + 30, 11 * 60), (13 * 60, 13 * 60 + 30)],\n        \"Tuesday\": [(9 * 60 + 30, 10 * 60 + 30), (13 * 60 + 30, 14 * 60 + 30)],\n        \"Wednesday\": [(9 * 60 + 30, 10 * 60 + 30), (11 * 60 + 30, 12 * 60), \n                      (13 * 60 + 30, 14 * 60 + 30), (15 * 60 + 30, 17 * 60)],\n        \"Thursday\": [(9 * 60, 9 * 60 + 30), (14 * 60 + 30, 15 * 60), \n                     (15 * 60 + 30, 16 * 60)],\n        \"Friday\": [(12 * 60 + 30, 13 * 60 + 30), (15 * 60 + 30, 16 * 60)]\n    }\n\n    # Define Anna's busy times in minutes since midnight\n    anna_busy = {\n        \"Monday\": [(9 * 60, 13 * 60), (13 * 60 + 30, 17 * 60)],\n        \"Tuesday\": [(9 * 60, 11 * 60), (11 * 60 + 30, 17 * 60)],\n        \"Wednesday\": [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 11 * 60 + 30),\n                      (12 * 60, 14 * 60), (15 * 60, 15 * 60 + 30), \n                      (16 * 60, 16 * 60 + 30)],\n        \"Thursday\": [(9 * 60 + 30, 17 * 60)],\n        \"Friday\": [(9 * 60, 10 * 60), (10 * 60 + 30, 13 * 60), \n                   (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60), \n                   (15 * 60 + 30, 17 * 60)]\n    }\n\n    # Apply preferences: Amy avoids Wednesday, Anna avoids Friday\n    preferred_days = [day for day in days if day not in [\"Wednesday\", \"Friday\"]]\n\n    for day in preferred_days:\n        # Collect all busy intervals for both participants on this day\n        busy_intervals = amy_busy.get(day, []) + anna_busy.get(day, [])\n        busy_intervals.sort()\n\n        # Check the time before the first busy interval\n        if busy_intervals:\n            first_start = busy_intervals[0][0]\n            if first_start - work_start >= meeting_duration:\n                # Found a slot at the start of the day\n                start_time = work_start\n                end_time = start_time + meeting_duration\n                return f\"{start_time//60:02d}:{start_time%60:02d}:{end_time//60:02d}:{end_time%60:02d}\"\n\n        # Check gaps between busy intervals\n        for i in range(1, len(busy_intervals)):\n            prev_end = busy_intervals[i-1][1]\n            curr_start = busy_intervals[i][0]\n            if curr_start - prev_end >= meeting_duration:\n                start_time = prev_end\n                end_time = start_time + meeting_duration\n                return f\"{start_time//60:02d}:{start_time%60:02d}:{end_time//60:02d}:{end_time%60:02d}\"\n\n        # Check the time after the last busy interval\n        if busy_intervals:\n            last_end = busy_intervals[-1][1]\n            if work_end - last_end >= meeting_duration:\n                start_time = last_end\n                end_time = start_time + meeting_duration\n                return f\"{start_time//60:02d}:{start_time%60:02d}:{end_time//60:02d}:{end_time%60:02d}\"\n        else:\n            # No busy intervals, entire day is free\n            start_time = work_start\n            end_time = start_time + meeting_duration\n            return f\"{start_time//60:02d}:{start_time%60:02d}:{end_time//60:02d}:{end_time%60:02d}\"\n\n    # If no slot found in preferred days, check remaining days (though problem states solution exists)\n    remaining_days = [day for day in days if day not in preferred_days]\n    for day in remaining_days:\n        busy_intervals = amy_busy.get(day, []) + anna_busy.get(day, [])\n        busy_intervals.sort()\n\n        if busy_intervals:\n            first_start = busy_intervals[0][0]\n            if first_start - work_start >= meeting_duration:\n                start_time = work_start\n                end_time = start_time + meeting_duration\n                return f\"{start_time//60:02d}:{start_time%60:02d}:{end_time//60:02d}:{end_time%60:02d}\"\n\n        for i in range(1, len(busy_intervals)):\n            prev_end = busy_intervals[i-1][1]\n            curr_start = busy_intervals[i][0]\n            if curr_start - prev_end >= meeting_duration:\n                start_time = prev_end\n                end_time = start_time + meeting_duration\n                return f\"{start_time//60:02d}:{start_time%60:02d}:{end_time//60:02d}:{end_time%60:02d}\"\n\n        if busy_intervals:\n            last_end = busy_intervals[-1][1]\n            if work_end - last_end >= meeting_duration:\n                start_time = last_end\n                end_time = start_time + meeting_duration\n                return f\"{start_time//60:02d}:{start_time%60:02d}:{end_time//60:02d}:{end_time%60:02d}\"\n        else:\n            start_time = work_start\n            end_time = start_time + meeting_duration\n            return f\"{start_time//60:02d}:{start_time%60:02d}:{end_time//60:02d}:{end_time%60:02d}\"\n\n    return \"No time found\"  # Should not reach here per problem statement\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_905"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\nfrom typing import List, Dict, Tuple\n\ndef find_meeting_time(participants: List[Dict], duration: int, work_hours: Tuple[str, str], days: List[str]) -> str:\n    # Parse work hours\n    work_start, work_end = work_hours\n    work_start_min = convert_time_to_minutes(work_start)\n    work_end_min = convert_time_to_minutes(work_end)\n    \n    # Iterate through each day\n    for day in days:\n        # Skip days based on preferences\n        if (day == \"Tuesday\" or day == \"Wednesday\") and any(p.get(\"preferences\", {}).get(\"no_\" + day.lower(), False) for p in participants):\n            continue\n        \n        # Get busy intervals for each participant for the day\n        busy_intervals = []\n        for participant in participants:\n            day_busy = participant[\"schedule\"].get(day, [])\n            for interval in day_busy:\n                start, end = interval.split(\" to \")\n                busy_intervals.append((convert_time_to_minutes(start), convert_time_to_minutes(end)))\n        \n        # Sort busy intervals\n        busy_intervals.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start_min\n        for start, end in busy_intervals:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end_min:\n            free_slots.append((prev_end, work_end_min))\n        \n        # Check for a slot that fits the duration and preferences\n        for start, end in free_slots:\n            if end - start >= duration:\n                # Check Marilyn's preference for Monday after 13:00\n                if day == \"Monday\" and start >= convert_time_to_minutes(\"13:00\"):\n                    if any(p.get(\"preferences\", {}).get(\"no_monday_afternoon\", False) for p in participants):\n                        continue\n                proposed_start = start\n                proposed_end = start + duration\n                return f\"{convert_minutes_to_time(proposed_start)}:{convert_minutes_to_time(proposed_end)}\"\n    \n    return \"No suitable time found\"\n\ndef convert_time_to_minutes(time_str: str) -> int:\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef convert_minutes_to_time(minutes: int) -> str:\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Define participants, constraints, and preferences\nparticipants = [\n    {\n        \"name\": \"Jean\",\n        \"schedule\": {\n            \"Monday\": [\"11:00 to 12:00\", \"12:30 to 13:00\", \"16:00 to 17:00\"],\n            \"Tuesday\": [\"9:30 to 10:00\", \"10:30 to 11:00\", \"11:30 to 13:00\", \"13:30 to 14:00\", \"14:30 to 15:00\", \"16:00 to 16:30\"],\n            \"Wednesday\": [\"9:00 to 9:30\", \"10:30 to 11:00\", \"13:00 to 14:30\", \"16:00 to 17:00\"],\n            \"Thursday\": [\"11:00 to 11:30\"],\n            \"Friday\": [\"11:30 to 12:30\", \"13:00 to 14:30\", \"15:00 to 15:30\", \"16:00 to 16:30\"]\n        },\n        \"preferences\": {\n            \"no_tuesday\": True,\n            \"no_wednesday\": True\n        }\n    },\n    {\n        \"name\": \"Marilyn\",\n        \"schedule\": {\n            \"Monday\": [\"9:30 to 13:00\", \"14:00 to 16:00\", \"16:30 to 17:00\"],\n            \"Tuesday\": [\"9:00 to 13:30\", \"14:00 to 15:30\", \"16:00 to 17:00\"],\n            \"Wednesday\": [\"9:00 to 10:00\", \"10:30 to 12:30\", \"13:00 to 13:30\", \"14:30 to 15:00\", \"16:00 to 16:30\"],\n            \"Thursday\": [\"9:00 to 17:00\"],\n            \"Friday\": [\"9:00 to 12:00\", \"12:30 to 17:00\"]\n        },\n        \"preferences\": {\n            \"no_monday_afternoon\": True\n        }\n    }\n]\n\n# Meeting constraints\nduration = 30  # minutes\nwork_hours = (\"9:00\", \"17:00\")\ndays = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"]\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants, duration, work_hours, days)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_906"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 60  # 60 minutes\n\n    # Define days to consider (excluding Monday and Tuesday per Sharon's preference)\n    days = ['Wednesday', 'Thursday', 'Friday']\n\n    # Define busy times for Sharon and Martha in minutes since midnight\n    # Format: {day: [(start1, end1), (start2, end2), ...]}\n    sharon_busy = {\n        'Wednesday': [(12 * 60, 12 * 60 + 30)],\n        'Friday': [(10 * 60 + 30, 11 * 60)]\n    }\n    martha_busy = {\n        'Wednesday': [\n            (9 * 60, 9 * 60 + 30),\n            (10 * 60, 15 * 60),\n            (15 * 60 + 30, 16 * 60 + 30)\n        ],\n        'Thursday': [\n            (10 * 60, 11 * 60 + 30),\n            (12 * 60, 13 * 60 + 30),\n            (14 * 60, 16 * 60 + 30)\n        ],\n        'Friday': [\n            (9 * 60 + 30, 11 * 60),\n            (11 * 60 + 30, 15 * 60 + 30),\n            (16 * 60, 17 * 60)\n        ]\n    }\n\n    # Iterate through each day\n    for day in days:\n        # Combine and sort all busy intervals for the day\n        busy_intervals = []\n        # Add Sharon's busy times\n        if day in sharon_busy:\n            busy_intervals.extend(sharon_busy[day])\n        # Add Martha's busy times\n        if day in martha_busy:\n            busy_intervals.extend(martha_busy[day])\n        # Sort intervals by start time\n        busy_intervals.sort()\n\n        # Find available slots\n        prev_end = work_start\n        for start, end in busy_intervals:\n            if start > prev_end:\n                # Check if there's enough time for the meeting\n                if start - prev_end >= meeting_duration:\n                    # Found a slot\n                    meeting_start = prev_end\n                    meeting_end = meeting_start + meeting_duration\n                    return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy interval\n        if work_end - prev_end >= meeting_duration:\n            meeting_start = prev_end\n            meeting_end = meeting_start + meeting_duration\n            return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_907"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:30:12:00}",
            "type_error": "TypeError",
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(frank_busy, diana_busy, work_hours, duration, excluded_days):\n    days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"]\n    start_work, end_work = work_hours\n    delta = timedelta(minutes=duration)\n    \n    for day in days:\n        if day in excluded_days:\n            continue\n        \n        # Get busy times for the current day\n        frank_day = [slot for slot in frank_busy if slot[0] == day]\n        diana_day = [slot for slot in diana_busy if slot[0] == day]\n        \n        # Combine and sort all busy slots for the day\n        busy_slots = frank_day + diana_day\n        busy_slots.sort(key=lambda x: x[1])\n        \n        # Initialize available slots\n        available_slots = []\n        prev_end = start_work\n        \n        for slot in busy_slots:\n            slot_start = slot[1]\n            if slot_start > prev_end:\n                available_slots.append((prev_end, slot_start))\n            prev_end = max(prev_end, slot[2])\n        \n        if prev_end < end_work:\n            available_slots.append((prev_end, end_work))\n        \n        # Check each available slot for sufficient duration\n        for slot in available_slots:\n            slot_start, slot_end = slot\n            if (datetime.combine(datetime.today(), slot_end) - \n                datetime.combine(datetime.today(), slot_start)) >= delta:\n                return f\"{slot_start.strftime('%H:%M')}:{(slot_start + delta).strftime('%H:%M')}\"\n    \n    return \"No available time found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (datetime.strptime(\"09:00\", \"%H:%M\").time(), datetime.strptime(\"17:00\", \"%H:%M\").time())\n\n# Define busy slots for Frank and Diana\nfrank_busy = [\n    (\"Tuesday\", datetime.strptime(\"11:00\", \"%H:%M\").time(), datetime.strptime(\"11:30\", \"%H:%M\").time()),\n    (\"Tuesday\", datetime.strptime(\"12:30\", \"%H:%M\").time(), datetime.strptime(\"13:00\", \"%H:%M\").time()),\n    (\"Wednesday\", datetime.strptime(\"10:00\", \"%H:%M\").time(), datetime.strptime(\"10:30\", \"%H:%M\").time()),\n    (\"Thursday\", datetime.strptime(\"12:30\", \"%H:%M\").time(), datetime.strptime(\"13:00\", \"%H:%M\").time()),\n    (\"Friday\", datetime.strptime(\"13:30\", \"%H:%M\").time(), datetime.strptime(\"14:00\", \"%H:%M\").time()),\n    (\"Friday\", datetime.strptime(\"15:30\", \"%H:%M\").time(), datetime.strptime(\"16:00\", \"%H:%M\").time()),\n]\n\ndiana_busy = [\n    (\"Monday\", datetime.strptime(\"09:00\", \"%H:%M\").time(), datetime.strptime(\"11:30\", \"%H:%M\").time()),\n    (\"Monday\", datetime.strptime(\"12:30\", \"%H:%M\").time(), datetime.strptime(\"13:00\", \"%H:%M\").time()),\n    (\"Monday\", datetime.strptime(\"14:00\", \"%H:%M\").time(), datetime.strptime(\"15:00\", \"%H:%M\").time()),\n    (\"Monday\", datetime.strptime(\"16:00\", \"%H:%M\").time(), datetime.strptime(\"16:30\", \"%H:%M\").time()),\n    (\"Tuesday\", datetime.strptime(\"09:30\", \"%H:%M\").time(), datetime.strptime(\"10:00\", \"%H:%M\").time()),\n    (\"Tuesday\", datetime.strptime(\"10:30\", \"%H:%M\").time(), datetime.strptime(\"12:00\", \"%H:%M\").time()),\n    (\"Tuesday\", datetime.strptime(\"14:00\", \"%H:%M\").time(), datetime.strptime(\"14:30\", \"%H:%M\").time()),\n    (\"Wednesday\", datetime.strptime(\"10:00\", \"%H:%M\").time(), datetime.strptime(\"10:30\", \"%H:%M\").time()),\n    (\"Wednesday\", datetime.strptime(\"11:30\", \"%H:%M\").time(), datetime.strptime(\"12:30\", \"%H:%M\").time()),\n    (\"Wednesday\", datetime.strptime(\"14:00\", \"%H:%M\").time(), datetime.strptime(\"14:30\", \"%H:%M\").time()),\n    (\"Wednesday\", datetime.strptime(\"16:00\", \"%H:%M\").time(), datetime.strptime(\"16:30\", \"%H:%M\").time()),\n    (\"Thursday\", datetime.strptime(\"09:00\", \"%H:%M\").time(), datetime.strptime(\"11:30\", \"%H:%M\").time()),\n    (\"Thursday\", datetime.strptime(\"12:00\", \"%H:%M\").time(), datetime.strptime(\"13:00\", \"%H:%M\").time()),\n    (\"Thursday\", datetime.strptime(\"13:30\", \"%H:%M\").time(), datetime.strptime(\"15:00\", \"%H:%M\").time()),\n    (\"Thursday\", datetime.strptime(\"15:30\", \"%H:%M\").time(), datetime.strptime(\"17:00\", \"%H:%M\").time()),\n    (\"Friday\", datetime.strptime(\"10:00\", \"%H:%M\").time(), datetime.strptime(\"10:30\", \"%H:%M\").time()),\n    (\"Friday\", datetime.strptime(\"11:00\", \"%H:%M\").time(), datetime.strptime(\"12:30\", \"%H:%M\").time()),\n    (\"Friday\", datetime.strptime(\"14:00\", \"%H:%M\").time(), datetime.strptime(\"16:00\", \"%H:%M\").time()),\n]\n\n# Diana does not want to meet on Tuesday or Thursday\nexcluded_days = [\"Tuesday\", \"Thursday\"]\n\n# Meeting duration is 30 minutes\nduration = 30\n\n# Find the earliest available time\nmeeting_time = find_meeting_time(frank_busy, diana_busy, work_hours, duration, excluded_days)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_908"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Days to consider\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n    \n    # Jeremy's busy times in minutes since midnight\n    jeremy_busy = {\n        'Monday': [(12 * 60, 12 * 60 + 30)],\n        'Tuesday': [(11 * 60 + 30, 12 * 60), (15 * 60, 15 * 60 + 30)],\n        'Wednesday': [(10 * 60 + 30, 11 * 60), (14 * 60, 14 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Thursday': [(13 * 60 + 30, 14 * 60), (15 * 60, 15 * 60 + 30)],\n        'Friday': [(14 * 60 + 30, 15 * 60)]\n    }\n    \n    # Anna's busy times in minutes since midnight\n    anna_busy = {\n        'Monday': [(9 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 14 * 60), (14 * 60 + 30, 17 * 60)],\n        'Thursday': [(9 * 60, 11 * 60 + 30), (12 * 60 + 30, 15 * 60), (16 * 60 + 30, 17 * 60)],\n        'Friday': [(9 * 60, 13 * 60 + 30), (14 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)]\n    }\n    \n    # Jeremy's preference to avoid Thursday after 13:00\n    jeremy_preference = {'Thursday': (13 * 60, work_end)}\n    \n    meeting_duration = 30  # minutes\n    \n    for day in days:\n        if day in jeremy_preference:\n            # Skip times after 13:00 on Thursday\n            day_end = jeremy_preference[day][0]\n        else:\n            day_end = work_end\n        \n        # Generate all possible time slots for the day\n        time_slots = []\n        current_time = work_start\n        while current_time + meeting_duration <= day_end:\n            time_slots.append((current_time, current_time + meeting_duration))\n            current_time += 30  # Check every 30 minutes\n        \n        # Check each time slot for availability\n        for start, end in time_slots:\n            # Check Jeremy's availability\n            jeremy_available = True\n            if day in jeremy_busy:\n                for busy_start, busy_end in jeremy_busy[day]:\n                    if not (end <= busy_start or start >= busy_end):\n                        jeremy_available = False\n                        break\n            \n            if not jeremy_available:\n                continue\n            \n            # Check Anna's availability\n            anna_available = True\n            if day in anna_busy:\n                for busy_start, busy_end in anna_busy[day]:\n                    if not (end <= busy_start or start >= busy_end):\n                        anna_available = False\n                        break\n            \n            if anna_available:\n                # Convert minutes back to HH:MM format\n                start_hh = start // 60\n                start_mm = start % 60\n                end_hh = end // 60\n                end_mm = end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_909"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to consider\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n    \n    # Bryan's constraints and meetings\n    bryan_meetings = {\n        'Thursday': [(9 * 60 + 30, 10 * 60), (12 * 60 + 30, 13 * 60)],\n        'Friday': [(10 * 60 + 30, 11 * 60), (14 * 60, 14 * 60 + 30)],\n    }\n    bryan_avoid = ['Tuesday']\n    \n    # Nicholas's constraints and meetings\n    nicholas_meetings = {\n        'Monday': [(11 * 60 + 30, 12 * 60), (13 * 60, 15 * 60 + 30)],\n        'Tuesday': [(9 * 60, 9 * 60 + 30), (11 * 60, 13 * 60 + 30), (14 * 60, 16 * 60 + 30)],\n        'Wednesday': [(9 * 60, 9 * 60 + 30), (10 * 60, 11 * 60), (11 * 60 + 30, 13 * 60 + 30), \n                      (14 * 60, 14 * 60 + 30), (15 * 60, 16 * 60 + 30)],\n        'Thursday': [(10 * 60 + 30, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), \n                     (15 * 60, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n        'Friday': [(9 * 60, 10 * 60 + 30), (11 * 60, 12 * 60), (12 * 60 + 30, 14 * 60 + 30), \n                   (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)],\n    }\n    nicholas_avoid = ['Monday', 'Thursday']\n    \n    # Iterate through each day\n    for day in days:\n        if day in bryan_avoid or day in nicholas_avoid:\n            continue\n        \n        # Get all busy times for both participants on this day\n        busy_times = []\n        \n        # Add Bryan's meetings\n        if day in bryan_meetings:\n            busy_times.extend(bryan_meetings[day])\n        \n        # Add Nicholas's meetings\n        if day in nicholas_meetings:\n            busy_times.extend(nicholas_meetings[day])\n        \n        # Sort busy times by start time\n        busy_times.sort()\n        \n        # Find available slots\n        prev_end = work_start\n        available_slots = []\n        \n        for start, end in busy_times:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after last meeting\n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n        \n        # Check for a 60-minute slot\n        for start, end in available_slots:\n            if end - start >= 60:\n                # Convert start time to HH:MM format\n                start_hh = start // 60\n                start_mm = start % 60\n                end_hh = (start + 60) // 60\n                end_mm = (start + 60) % 60\n                \n                # Format as HH:MM:HH:MM\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_910"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:00:10:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(brittany_busy, judith_busy, work_hours, duration):\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n    start_hour, end_hour = work_hours\n    duration_minutes = duration * 60\n\n    for day in days:\n        # Get Brittany's busy slots for the day\n        brittany_day = brittany_busy.get(day, [])\n        # Get Judith's busy slots for the day\n        judith_day = judith_busy.get(day, [])\n\n        # Combine and sort all busy slots for the day\n        all_busy = brittany_day + judith_day\n        all_busy.sort()\n\n        # Initialize the previous end time to start of work day\n        prev_end = start_hour * 60\n\n        for busy_start, busy_end in all_busy:\n            busy_start_min = busy_start[0] * 60 + busy_start[1]\n            busy_end_min = busy_end[0] * 60 + busy_end[1]\n\n            # Check if there's a gap between previous end and current start\n            if busy_start_min > prev_end:\n                gap = busy_start_min - prev_end\n                if gap >= duration_minutes:\n                    # Found a suitable slot\n                    start_time = prev_end\n                    end_time = start_time + duration_minutes\n                    # Convert back to HH:MM format\n                    start_hh = start_time // 60\n                    start_mm = start_time % 60\n                    end_hh = end_time // 60\n                    end_mm = end_time % 60\n                    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n            # Update previous end time\n            if busy_end_min > prev_end:\n                prev_end = busy_end_min\n\n        # Check the gap after the last busy slot until end of work day\n        if (end_hour * 60) - prev_end >= duration_minutes:\n            start_time = prev_end\n            end_time = start_time + duration_minutes\n            start_hh = start_time // 60\n            start_mm = start_time % 60\n            end_hh = end_time // 60\n            end_mm = end_time % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Define work hours (9:00 to 17:00)\nwork_hours = (9, 17)\n\n# Define Brittany's busy times in (HH, MM) format\nbrittany_busy = {\n    'Wednesday': [\n        ((9, 30), (10, 30)),\n        ((11, 0), (11, 30)),\n        ((13, 30), (14, 0)),\n        ((15, 0), (15, 30))\n    ],\n    'Friday': [\n        ((9, 0), (9, 30))\n    ]\n}\n\n# Define Judith's busy times in (HH, MM) format\njudith_busy = {\n    'Monday': [\n        ((9, 0), (10, 0)),\n        ((10, 30), (13, 0)),\n        ((13, 30), (15, 0)),\n        ((16, 0), (17, 0))\n    ],\n    'Tuesday': [\n        ((9, 0), (10, 0)),\n        ((11, 0), (11, 30)),\n        ((12, 0), (13, 30)),\n        ((14, 0), (15, 30))\n    ],\n    'Wednesday': [\n        ((9, 0), (17, 0))\n    ],\n    'Thursday': [\n        ((9, 0), (9, 30)),\n        ((10, 0), (14, 0)),\n        ((14, 30), (17, 0))\n    ],\n    'Friday': [\n        ((9, 0), (11, 0)),\n        ((12, 0), (12, 30)),\n        ((14, 30), (15, 0)),\n        ((16, 30), (17, 0))\n    ]\n}\n\n# Find the earliest meeting time for 30 minutes\nmeeting_time = find_meeting_time(brittany_busy, judith_busy, work_hours, 0.5)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_911"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n\n    # Dorothy's busy times in minutes since start of day\n    dorothy_busy = {\n        'Monday': [(12*60, 12*60+30), (13*60+30, 14*60), (15*60+30, 16*60), (16*60+30, 17*60)],\n        'Tuesday': [(9*60+30, 10*60+30), (11*60, 11*60+30), (13*60, 13*60+30)],\n        'Wednesday': [(9*60+30, 10*60+30), (11*60, 12*60), (13*60, 14*60), (16*60+30, 17*60)],\n        'Thursday': [(9*60, 9*60+30), (14*60, 14*60+30), (15*60, 15*60+30)],\n        'Friday': [(10*60+30, 11*60), (11*60+30, 12*60), (12*60+30, 13*60), (13*60+30, 14*60+30), (15*60, 15*60+30)]\n    }\n\n    # Lawrence's busy times in minutes since start of day\n    lawrence_busy = {\n        'Monday': [(9*60, 17*60)],\n        'Tuesday': [(9*60, 17*60)],\n        'Wednesday': [(9*60, 17*60)],\n        'Thursday': [(9*60, 17*60)],\n        'Friday': [(9*60+30, 10*60+30), (11*60, 14*60), (14*60+30, 16*60), (16*60+30, 17*60)]\n    }\n\n    # Lawrence can't meet on Friday before 11:30\n    lawrence_constraints = {\n        'Friday': (11*60+30, None)\n    }\n\n    for day in days:\n        # Check if Lawrence is entirely busy on this day (like Monday-Thursday)\n        if day in ['Monday', 'Tuesday', 'Wednesday', 'Thursday']:\n            if all(start <= work_start and end >= work_end for start, end in lawrence_busy[day]):\n                continue\n\n        # Get both participants' busy times for the day\n        busy_times = dorothy_busy[day] + lawrence_busy[day]\n        busy_times.sort()  # Sort by start time\n\n        # Check Lawrence's constraints for the day\n        constraint_start = None\n        if day in lawrence_constraints:\n            constraint_start, _ = lawrence_constraints[day]\n            if constraint_start:\n                # Adjust work_start to be the later of the two\n                effective_start = max(work_start, constraint_start)\n            else:\n                effective_start = work_start\n        else:\n            effective_start = work_start\n\n        # Find available slots\n        prev_end = effective_start\n        for start, end in busy_times:\n            if start > prev_end:\n                # Found a gap\n                available_start = prev_end\n                available_end = start\n                if available_end - available_start >= meeting_duration:\n                    # Convert back to HH:MM format\n                    start_hh = available_start // 60\n                    start_mm = available_start % 60\n                    end_hh = (available_start + meeting_duration) // 60\n                    end_mm = (available_start + meeting_duration) % 60\n                    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n            prev_end = max(prev_end, end)\n\n        # Check after last busy time\n        if work_end - prev_end >= meeting_duration:\n            start_hh = prev_end // 60\n            start_mm = prev_end % 60\n            end_hh = (prev_end + meeting_duration) // 60\n            end_mm = (prev_end + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_912"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to consider (only Thursday, based on Nicole's constraints)\n    days = ['Thursday']\n    \n    # Define busy times for Joan and Nicole on Thursday\n    joan_busy = [\n        (10 * 60 + 30, 11 * 60),    # 10:30-11:00\n        (12 * 60, 12 * 60 + 30),    # 12:00-12:30\n        (13 * 60, 13 * 60 + 30),    # 13:00-13:30\n        (14 * 60 + 30, 15 * 60),    # 14:30-15:00\n        (16 * 60 + 30, 17 * 60)     # 16:30-17:00\n    ]\n    \n    nicole_busy = [\n        (10 * 60 + 30, 11 * 60),    # 10:30-11:00\n        (14 * 60 + 30, 15 * 60),    # 14:30-15:00\n        (16 * 60 + 30, 17 * 60)     # 16:30-17:00\n    ]\n    \n    # Combine and sort all busy intervals\n    all_busy = joan_busy + nicole_busy\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy intervals\n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    # Check the slot after the last busy interval\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Find the earliest 30-minute slot\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_913"
        },
        {
            "final_program_time": "{11:00:12:00}",
            "expected_time": "{11:00:12:00}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef parse_time(time_str):\n    return datetime.strptime(time_str, \"%H:%M\")\n\ndef format_time(time_obj):\n    return time_obj.strftime(\"%H:%M\")\n\ndef find_earliest_meeting_time(benjamin_schedule, melissa_schedule, work_hours_start, work_hours_end, meeting_duration):\n    days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"]\n    meeting_duration = timedelta(minutes=meeting_duration)\n    \n    for day in days:\n        # Initialize available slots for the day\n        day_start = parse_time(work_hours_start)\n        day_end = parse_time(work_hours_end)\n        available_slots = [(day_start, day_end)]\n        \n        # Process Benjamin's schedule\n        for entry in benjamin_schedule.get(day, []):\n            start, end = parse_time(entry[0]), parse_time(entry[1])\n            new_slots = []\n            for slot in available_slots:\n                slot_start, slot_end = slot\n                if start >= slot_end or end <= slot_start:\n                    new_slots.append(slot)\n                else:\n                    if slot_start < start:\n                        new_slots.append((slot_start, start))\n                    if end < slot_end:\n                        new_slots.append((end, slot_end))\n            available_slots = new_slots\n        \n        # Process Melissa's schedule\n        for entry in melissa_schedule.get(day, []):\n            start, end = parse_time(entry[0]), parse_time(entry[1])\n            new_slots = []\n            for slot in available_slots:\n                slot_start, slot_end = slot\n                if start >= slot_end or end <= slot_start:\n                    new_slots.append(slot)\n                else:\n                    if slot_start < start:\n                        new_slots.append((slot_start, start))\n                    if end < slot_end:\n                        new_slots.append((end, slot_end))\n            available_slots = new_slots\n        \n        # Check for a suitable slot\n        for slot in available_slots:\n            slot_start, slot_end = slot\n            if slot_end - slot_start >= meeting_duration:\n                return f\"{format_time(slot_start)}:{format_time(slot_start + meeting_duration)}\"\n    \n    return \"No available slot found\"\n\n# Define work hours\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 60  # minutes\n\n# Define Benjamin's schedule\nbenjamin_schedule = {\n    \"Monday\": [(\"11:00\", \"11:30\"), (\"16:00\", \"16:30\")],\n    \"Tuesday\": [(\"13:00\", \"13:30\")],\n    \"Wednesday\": [(\"11:30\", \"12:00\"), (\"13:00\", \"14:00\"), (\"16:30\", \"17:00\")],\n    \"Thursday\": [(\"09:00\", \"09:30\"), (\"15:00\", \"15:30\")],\n    \"Friday\": [(\"12:30\", \"13:00\"), (\"13:30\", \"14:00\"), (\"16:00\", \"16:30\")]\n}\n\n# Define Melissa's schedule\nmelissa_schedule = {\n    \"Monday\": [(\"09:00\", \"16:00\"), (\"16:30\", \"17:00\")],\n    \"Tuesday\": [(\"09:00\", \"09:30\"), (\"10:00\", \"11:00\"), (\"12:00\", \"12:30\"), (\"13:00\", \"13:30\"), (\"14:00\", \"17:00\")],\n    \"Wednesday\": [(\"09:00\", \"10:00\"), (\"12:00\", \"12:30\"), (\"13:00\", \"13:30\"), (\"14:00\", \"15:00\"), (\"15:30\", \"16:00\"), (\"16:30\", \"17:00\")],\n    \"Thursday\": [(\"09:00\", \"10:30\"), (\"11:00\", \"15:00\"), (\"15:30\", \"16:30\")],\n    \"Friday\": [(\"09:00\", \"12:00\"), (\"12:30\", \"17:00\")]\n}\n\n# Find the earliest meeting time\nresult = find_earliest_meeting_time(benjamin_schedule, melissa_schedule, work_hours_start, work_hours_end, meeting_duration)\nprint(result)\n```",
            "count": "calendar_scheduling_example_914"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n\n    # Christine's busy times in minutes since midnight for each day\n    christine_busy = {\n        'Monday': [(10 * 60, 10 * 60 + 30), (14 * 60, 14 * 60 + 30), (15 * 60, 15 * 60 + 30)],\n        'Tuesday': [(10 * 60, 10 * 60 + 30)],\n        'Wednesday': [(9 * 60, 10 * 60), (13 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30)],\n        'Thursday': [(9 * 60, 11 * 60), (11 * 60 + 30, 12 * 60 + 30), (13 * 60 + 30, 14 * 60 + 30), (15 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Friday': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (11 * 60, 12 * 60 + 30), (13 * 60 + 30, 14 * 60), (15 * 60 + 30, 16 * 60)]\n    }\n\n    # Keith's busy times in minutes since midnight for each day\n    keith_busy = {\n        'Monday': [(9 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 10 * 60 + 30), (11 * 60, 15 * 60), (15 * 60 + 30, 17 * 60)],\n        'Thursday': [(9 * 60, 9 * 60 + 30), (10 * 60, 15 * 60), (15 * 60 + 30, 17 * 60)],\n        'Friday': [(9 * 60 + 30, 12 * 60), (13 * 60 + 30, 17 * 60)]\n    }\n\n    # Duration of the meeting in minutes\n    duration = 30\n\n    # Iterate through each day to find the earliest available slot\n    for day in days:\n        # Combine and sort busy times for both participants\n        busy_times = christine_busy.get(day, []) + keith_busy.get(day, [])\n        busy_times.sort()\n\n        # Initialize previous end time to work start\n        prev_end = work_start\n\n        # Check between busy times for available slot\n        for start, end in busy_times:\n            if start > prev_end and (start - prev_end) >= duration:\n                # Found a slot\n                meeting_start = prev_end\n                meeting_end = meeting_start + duration\n                # Format the time as HH:MM:HH:MM\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n            prev_end = max(prev_end, end)\n\n        # Check after last busy time\n        if work_end - prev_end >= duration:\n            meeting_start = prev_end\n            meeting_end = meeting_start + duration\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No available time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_915"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to consider (Monday to Friday)\n    days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"]\n    \n    # Sharon's busy times in minutes since start of day\n    sharon_busy = {\n        \"Monday\": [(10 * 60 + 30, 11 * 60), (13 * 60 + 30, 14 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        \"Wednesday\": [(9 * 60, 9 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n        \"Thursday\": [(13 * 60 + 30, 14 * 60), (15 * 60, 15 * 60 + 30)],\n        \"Friday\": [(9 * 60, 9 * 60 + 30), (13 * 60 + 30, 14 * 60)],\n    }\n    \n    # Jose's busy times in minutes since start of day\n    jose_busy = {\n        \"Monday\": [(9 * 60, 17 * 60)],\n        \"Tuesday\": [(9 * 60, 10 * 60 + 30), (11 * 60, 17 * 60)],\n        \"Wednesday\": [(10 * 60, 17 * 60)],\n        \"Thursday\": [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60), (11 * 60 + 30, 13 * 60), (14 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        \"Friday\": [(9 * 60, 17 * 60)],\n    }\n    \n    # Jose doesn't want to meet on Tuesday\n    days_to_check = [day for day in days if day != \"Tuesday\"]\n    \n    for day in days_to_check:\n        # Collect all busy intervals for both participants\n        busy_intervals = []\n        \n        # Add Sharon's busy intervals\n        if day in sharon_busy:\n            busy_intervals.extend(sharon_busy[day])\n        \n        # Add Jose's busy intervals\n        if day in jose_busy:\n            busy_intervals.extend(jose_busy[day])\n        \n        # Sort busy intervals by start time\n        busy_intervals.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in busy_intervals:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy interval\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for 30-minute availability\n        for start, end in free_slots:\n            if end - start >= 30:\n                # Found the earliest available slot\n                meeting_start = start\n                meeting_end = meeting_start + 30\n                # Convert back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_916"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:30:13:00}",
            "type_error": "TypeError",
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef parse_time(time_str):\n    return datetime.strptime(time_str, \"%H:%M\")\n\ndef format_time(time_obj):\n    return time_obj.strftime(\"%H:%M\")\n\ndef get_available_slots(person_schedule, work_start, work_end, day_duration):\n    available_slots = []\n    busy_slots = sorted(person_schedule, key=lambda x: parse_time(x[0]))\n    \n    prev_end = work_start\n    for start, end in busy_slots:\n        start_time = parse_time(start)\n        end_time = parse_time(end)\n        if start_time > prev_end:\n            available_slots.append((prev_end, start_time))\n        prev_end = max(prev_end, end_time)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    return available_slots\n\ndef find_meeting_time(amber_schedule, cynthia_schedule, duration, work_start_str, work_end_str):\n    duration = timedelta(minutes=duration)\n    work_start = parse_time(work_start_str)\n    work_end = parse_time(work_end_str)\n    \n    # Convert schedules to datetime objects\n    amber_busy = [(parse_time(start), parse_time(end)) for start, end in amber_schedule]\n    cynthia_busy = [(parse_time(start), parse_time(end)) for start, end in cynthia_schedule]\n    \n    # Get available slots for both\n    amber_available = get_available_slots(amber_busy, work_start, work_end, duration)\n    cynthia_available = get_available_slots(cynthia_busy, work_start, work_end, duration)\n    \n    # Find overlapping slots\n    for a_start, a_end in amber_available:\n        for c_start, c_end in cynthia_available:\n            overlap_start = max(a_start, c_start)\n            overlap_end = min(a_end, c_end)\n            if overlap_start < overlap_end and (overlap_end - overlap_start) >= duration:\n                return (overlap_start, overlap_start + duration)\n    \n    return None\n\n# Define work hours\nwork_start = \"09:00\"\nwork_end = \"17:00\"\n\n# Define schedules\namber_schedule = [\n    (\"11:00\", \"11:30\"),  # Monday\n    (\"09:30\", \"10:00\"),  # Tuesday\n    (\"14:00\", \"14:30\"),  # Tuesday\n    (\"11:00\", \"11:30\"),  # Wednesday\n    (\"12:00\", \"13:00\"),  # Wednesday\n    (\"14:00\", \"15:00\"),  # Wednesday\n    (\"16:30\", \"17:00\"),  # Wednesday\n    (\"09:00\", \"09:30\"),  # Thursday\n    (\"10:00\", \"11:00\"),  # Thursday\n    (\"13:00\", \"15:00\"),  # Thursday\n    (\"15:30\", \"17:00\"),  # Thursday\n    (\"12:30\", \"13:00\"),  # Friday\n    (\"13:30\", \"15:30\"),  # Friday\n    (\"16:00\", \"17:00\")   # Friday\n]\n\ncynthia_schedule = [\n    (\"09:00\", \"12:30\"),  # Monday\n    (\"13:00\", \"14:30\"),  # Monday\n    (\"15:00\", \"17:00\"),  # Monday\n    (\"09:30\", \"12:00\"),  # Tuesday\n    (\"12:30\", \"13:00\"),  # Tuesday\n    (\"13:30\", \"14:00\"),  # Tuesday\n    (\"14:30\", \"17:00\"),  # Tuesday\n    (\"09:00\", \"09:30\"),  # Wednesday\n    (\"10:30\", \"12:30\"),  # Wednesday\n    (\"13:30\", \"17:00\"),  # Wednesday\n    (\"09:30\", \"12:00\"),  # Thursday\n    (\"12:30\", \"16:30\"),  # Thursday\n    (\"09:00\", \"09:30\"),  # Friday\n    (\"10:00\", \"12:30\"),  # Friday\n    (\"13:00\", \"15:30\"),  # Friday\n    (\"16:00\", \"17:00\")   # Friday\n]\n\n# Find the earliest meeting time\nmeeting_time = find_meeting_time(amber_schedule, cynthia_schedule, 30, work_start, work_end)\n\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{format_time(start)}:{format_time(end)}\")\nelse:\n    print(\"No available time found.\")\n```",
            "count": "calendar_scheduling_example_917"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n    \n    # Define participants' blocked times in minutes since midnight\n    # Format: {day: [(start1, end1), (start2, end2), ...]}\n    cheryl_blocked = {\n        'Monday': [(13 * 60 + 30, 14 * 60)],\n        'Wednesday': [(10 * 60, 10 * 60 + 30), (14 * 60 + 30, 15 * 60)],\n        'Thursday': [(10 * 60, 10 * 60 + 30)],\n        'Friday': [(11 * 60, 12 * 60)]\n    }\n    \n    brittany_blocked = {\n        'Monday': [(9 * 60, 10 * 60), (11 * 60, 12 * 60), (12 * 60 + 30, 13 * 60),\n                   (14 * 60, 15 * 60), (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 17 * 60)],\n        'Wednesday': [(10 * 60, 10 * 60 + 30), (12 * 60, 13 * 60), (13 * 60 + 30, 14 * 60 + 30),\n                      (16 * 60 + 30, 17 * 60)],\n        'Thursday': [(10 * 60, 10 * 60 + 30), (13 * 60, 13 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n        'Friday': [(9 * 60, 10 * 60), (11 * 60, 11 * 60 + 30), (12 * 60 + 30, 13 * 60),\n                   (13 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60)]\n    }\n    \n    # Preferences: Cheryl no Wednesday, Brittany no Monday\n    preferred_days = [day for day in days if day not in ['Wednesday', 'Monday']]\n    \n    # Check each day in preferred order\n    for day in preferred_days:\n        # Collect all blocked times for both participants on this day\n        blocked = []\n        if day in cheryl_blocked:\n            blocked.extend(cheryl_blocked[day])\n        if day in brittany_blocked:\n            blocked.extend(brittany_blocked[day])\n        \n        # Sort blocked times by start time\n        blocked.sort()\n        \n        # Find available slots\n        available_start = work_hours_start\n        for (start, end) in blocked:\n            if start > available_start:\n                # Check if there's enough time before this block\n                if start - available_start >= 60:\n                    # Found a slot\n                    meeting_start = available_start\n                    meeting_end = meeting_start + 60\n                    return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n            # Update available_start to the end of this block if it's later\n            if end > available_start:\n                available_start = end\n        \n        # Check after last block\n        if work_hours_end - available_start >= 60:\n            meeting_start = available_start\n            meeting_end = meeting_start + 60\n            return f\"{meeting_start // 60:02d}:{meeting_end // 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    # If no preferred day works, check remaining days (though problem states solution exists)\n    for day in days:\n        if day in ['Wednesday', 'Monday']:\n            continue  # already checked preferred days\n        blocked = []\n        if day in cheryl_blocked:\n            blocked.extend(cheryl_blocked[day])\n        if day in brittany_blocked:\n            blocked.extend(brittany_blocked[day])\n        blocked.sort()\n        available_start = work_hours_start\n        for (start, end) in blocked:\n            if start > available_start:\n                if start - available_start >= 60:\n                    meeting_start = available_start\n                    meeting_end = meeting_start + 60\n                    return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n            if end > available_start:\n                available_start = end\n        if work_hours_end - available_start >= 60:\n            meeting_start = available_start\n            meeting_end = meeting_start + 60\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No time found\"  # should not reach here per problem statement\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_918"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n    \n    # Joshua's constraints: meetings and unavailable day\n    joshua_meetings = {\n        'Monday': [(12 * 60 + 30, 13 * 60)],    # 12:30-13:00\n        'Tuesday': [(13 * 60, 13 * 60 + 30)],    # 13:00-13:30\n    }\n    joshua_unavailable_days = ['Thursday']\n    \n    # Vincent's blocked times\n    vincent_blocked = {\n        'Monday': [\n            (9 * 60, 10 * 60 + 30),    # 9:00-10:30\n            (11 * 60, 12 * 60),        # 11:00-12:00\n            (13 * 60 + 30, 14 * 60 + 30),  # 13:30-14:30\n            (15 * 60 + 30, 16 * 60),    # 15:30-16:00\n        ],\n        'Tuesday': [\n            (9 * 60, 11 * 60),         # 9:00-11:00\n            (11 * 60 + 30, 12 * 60),   # 11:30-12:00\n            (14 * 60, 15 * 60),        # 14:00-15:00\n        ],\n        'Wednesday': [\n            (9 * 60 + 30, 10 * 60),    # 9:30-10:00\n            (11 * 60, 11 * 60 + 30),   # 11:00-11:30\n            (12 * 60, 13 * 60),        # 12:00-13:00\n            (14 * 60, 15 * 60),        # 14:00-15:00\n            (15 * 60 + 30, 16 * 60),   # 15:30-16:00\n        ],\n        'Thursday': [\n            (9 * 60, 10 * 60 + 30),    # 9:00-10:30\n            (11 * 60 + 30, 14 * 60 + 30),  # 11:30-14:30\n            (16 * 60 + 30, 17 * 60),   # 16:30-17:00\n        ],\n        'Friday': [\n            (9 * 60, 11 * 60),         # 9:00-11:00\n            (12 * 60, 12 * 60 + 30),   # 12:00-12:30\n            (13 * 60 + 30, 14 * 60),   # 13:30-14:00\n            (14 * 60 + 30, 16 * 60 + 30),  # 14:30-16:30\n        ],\n    }\n    \n    # Check each day in order\n    for day in days:\n        if day in joshua_unavailable_days:\n            continue\n        \n        # Get all busy intervals for both participants on this day\n        busy_intervals = []\n        \n        # Add Joshua's meetings\n        if day in joshua_meetings:\n            busy_intervals.extend(joshua_meetings[day])\n        \n        # Add Vincent's blocked times\n        if day in vincent_blocked:\n            busy_intervals.extend(vincent_blocked[day])\n        \n        # Sort all busy intervals by start time\n        busy_intervals.sort()\n        \n        # Find the earliest available 30-minute slot\n        prev_end = work_start\n        for start, end in busy_intervals:\n            if start > prev_end and (start - prev_end) >= 30:\n                # Found a slot\n                meeting_start = prev_end\n                meeting_end = meeting_start + 30\n                return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after the last busy interval\n        if work_end - prev_end >= 30:\n            meeting_start = prev_end\n            meeting_end = meeting_start + 30\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_919"
        },
        {
            "final_program_time": "{13:30:14:30}",
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef parse_time(time_str):\n    return datetime.strptime(time_str, \"%H:%M\")\n\ndef format_time(time_obj):\n    return time_obj.strftime(\"%H:%M\")\n\ndef find_earliest_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration, days):\n    time_slots = []\n    work_start = parse_time(work_hours_start)\n    work_end = parse_time(work_hours_end)\n    delta = timedelta(minutes=meeting_duration)\n    \n    for day in days:\n        # Initialize available time for the day as the entire work hours\n        available_slots = [(work_start, work_end)]\n        \n        # Process each participant's schedule for the day\n        for participant in participants_schedules:\n            if day not in participant:\n                continue  # No meetings, all day is available\n            meetings = participant[day]\n            new_available_slots = []\n            \n            for slot_start, slot_end in available_slots:\n                current_start = slot_start\n                # Sort meetings by start time\n                sorted_meetings = sorted(meetings, key=lambda x: parse_time(x[0]))\n                for meeting_start, meeting_end in sorted_meetings:\n                    meeting_start_time = parse_time(meeting_start)\n                    meeting_end_time = parse_time(meeting_end)\n                    if current_start < meeting_start_time:\n                        new_available_slots.append((current_start, meeting_start_time))\n                    current_start = max(current_start, meeting_end_time)\n                if current_start < slot_end:\n                    new_available_slots.append((current_start, slot_end))\n            available_slots = new_available_slots\n        \n        # Check available slots for this day\n        for slot_start, slot_end in available_slots:\n            if (slot_end - slot_start) >= delta:\n                time_slots.append((day, slot_start, slot_start + delta))\n    \n    if not time_slots:\n        return None\n    \n    # Find the earliest time slot\n    earliest_slot = min(time_slots, key=lambda x: (days.index(x[0]), x[1]))\n    day, start_time, end_time = earliest_slot\n    return f\"{format_time(start_time)}:{format_time(end_time)}\"\n\n# Define participants' schedules\ncharles_schedule = {\n    \"Tuesday\": [(\"10:00\", \"11:00\"), (\"13:00\", \"14:00\"), (\"15:00\", \"16:00\")],\n    \"Wednesday\": [(\"12:00\", \"12:30\")],\n    \"Thursday\": [(\"16:30\", \"17:00\")],\n    \"Friday\": [(\"10:30\", \"11:30\"), (\"12:30\", \"13:00\"), (\"15:30\", \"16:00\")],\n}\n\nlori_schedule = {\n    \"Monday\": [(\"9:00\", \"9:30\"), (\"10:00\", \"11:30\"), (\"12:00\", \"13:30\"), (\"14:00\", \"17:00\")],\n    \"Tuesday\": [(\"9:00\", \"10:30\"), (\"11:00\", \"15:30\"), (\"16:00\", \"17:00\")],\n    \"Wednesday\": [(\"9:30\", \"13:30\"), (\"14:30\", \"16:30\")],\n    \"Thursday\": [(\"9:00\", \"13:00\"), (\"14:30\", \"16:30\")],\n    \"Friday\": [(\"9:00\", \"11:30\"), (\"12:00\", \"17:00\")],\n}\n\n# Parameters\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 60  # minutes\ndays = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"]\n\n# Find the earliest meeting time\nearliest_time = find_earliest_meeting_time(\n    [charles_schedule, lori_schedule],\n    work_hours_start,\n    work_hours_end,\n    meeting_duration,\n    days\n)\n\nprint(earliest_time)\n```",
            "count": "calendar_scheduling_example_920"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n\n    # Define busy times for James and Jacob in minutes since midnight\n    james_busy = {\n        'Monday': [(11 * 60 + 30, 12 * 60), (13 * 60 + 30, 14 * 60), (15 * 60 + 30, 16 * 60)],\n        'Tuesday': [(10 * 60 + 30, 11 * 60)],\n        'Thursday': [(15 * 60, 15 * 60 + 30)],\n        'Friday': [(12 * 60 + 30, 13 * 60)],\n    }\n    jacob_busy = {\n        'Monday': [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60 + 30), (12 * 60, 13 * 60 + 30),\n                  (14 * 60, 15 * 60), (16 * 60, 16 * 60 + 30)],\n        'Tuesday': [(9 * 60 + 30, 10 * 60 + 30), (11 * 60, 11 * 60 + 30), (12 * 60, 12 * 60 + 30),\n                   (13 * 60 + 30, 14 * 60 + 30), (15 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Wednesday': [(9 * 60, 17 * 60)],\n        'Thursday': [(10 * 60, 10 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60),\n                    (16 * 60, 16 * 60 + 30)],\n        'Friday': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (11 * 60, 12 * 60),\n                  (13 * 60 + 30, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n    }\n\n    # Apply preferences\n    # James avoids Monday after 14:00, so remove his Monday slots after 14:00\n    james_busy['Monday'] = [slot for slot in james_busy['Monday'] if slot[0] < 14 * 60]\n    # Jacob avoids Tuesday, Thursday, Friday, so remove those days\n    preferred_days = [day for day in days if day not in ['Tuesday', 'Thursday', 'Friday']]\n\n    # Iterate through preferred days to find a suitable time\n    for day in preferred_days:\n        # Collect all busy times for both participants on this day\n        busy_times = []\n        if day in james_busy:\n            busy_times.extend(james_busy[day])\n        if day in jacob_busy:\n            busy_times.extend(jacob_busy[day])\n        # Sort busy times by start time\n        busy_times.sort()\n\n        # Check available slots\n        prev_end = work_start\n        for start, end in busy_times:\n            if start > prev_end:\n                available_start = prev_end\n                available_end = start\n                if available_end - available_start >= meeting_duration:\n                    # Found a suitable slot\n                    meeting_start = available_start\n                    meeting_end = meeting_start + meeting_duration\n                    return f\"{int(meeting_start // 60):02d}:{int(meeting_start % 60):02d}:{int(meeting_end // 60):02d}:{int(meeting_end % 60):02d}\"\n            prev_end = max(prev_end, end)\n        # Check after last busy time\n        if work_end - prev_end >= meeting_duration:\n            meeting_start = prev_end\n            meeting_end = meeting_start + meeting_duration\n            return f\"{int(meeting_start // 60):02d}:{int(meeting_start % 60):02d}:{int(meeting_end // 60):02d}:{int(meeting_end % 60):02d}\"\n\n    # If no slot found in preferred days, check remaining days (though preferences say it shouldn't be needed)\n    for day in days:\n        if day in preferred_days:\n            continue\n        busy_times = []\n        if day in james_busy:\n            busy_times.extend(james_busy[day])\n        if day in jacob_busy:\n            busy_times.extend(jacob_busy[day])\n        busy_times.sort()\n\n        prev_end = work_start\n        for start, end in busy_times:\n            if start > prev_end:\n                available_start = prev_end\n                available_end = start\n                if available_end - available_start >= meeting_duration:\n                    meeting_start = available_start\n                    meeting_end = meeting_start + meeting_duration\n                    return f\"{int(meeting_start // 60):02d}:{int(meeting_start % 60):02d}:{int(meeting_end // 60):02d}:{int(meeting_end % 60):02d}\"\n            prev_end = max(prev_end, end)\n        if work_end - prev_end >= meeting_duration:\n            meeting_start = prev_end\n            meeting_end = meeting_start + meeting_duration\n            return f\"{int(meeting_start // 60):02d}:{int(meeting_start % 60):02d}:{int(meeting_end // 60):02d}:{int(meeting_end % 60):02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_921"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to consider\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n\n    # Bobby's schedule: day -> list of busy intervals in minutes\n    bobby_schedule = {\n        'Monday': [(9.5 * 60, 10.5 * 60), (11.5 * 60, 12 * 60), (14.5 * 60, 15.5 * 60), (16 * 60, 16.5 * 60)],\n        'Tuesday': [(9 * 60, 10 * 60), (10.5 * 60, 11.5 * 60), (14 * 60, 15 * 60), (15.5 * 60, 16 * 60), (16.5 * 60, 17 * 60)],\n        'Wednesday': [(9.5 * 60, 10 * 60), (10.5 * 60, 11.5 * 60), (12 * 60, 13 * 60), (14.5 * 60, 15 * 60), (15.5 * 60, 17 * 60)],\n        'Friday': [(9 * 60, 11 * 60), (12 * 60, 13 * 60), (13.5 * 60, 14.5 * 60), (16 * 60, 16.5 * 60)],\n    }\n\n    # Brandon's schedule: day -> list of busy intervals in minutes\n    brandon_schedule = {\n        'Monday': [(10 * 60, 11 * 60), (11.5 * 60, 13 * 60), (13.5 * 60, 14 * 60), (14.5 * 60, 17 * 60)],\n        'Tuesday': [(10 * 60, 10.5 * 60), (11.5 * 60, 12 * 60), (12.5 * 60, 13.5 * 60), (15.5 * 60, 16.5 * 60)],\n        'Wednesday': [(9 * 60, 10 * 60), (10.5 * 60, 11 * 60), (11.5 * 60, 12.5 * 60), (13 * 60, 13.5 * 60), (14.5 * 60, 15.5 * 60), (16.5 * 60, 17 * 60)],\n        'Thursday': [(9 * 60, 11 * 60), (11.5 * 60, 12 * 60), (13 * 60, 14.5 * 60), (15 * 60, 16 * 60)],\n        'Friday': [(9.5 * 60, 10.5 * 60), (11 * 60, 11.5 * 60), (12 * 60, 13 * 60), (13.5 * 60, 14.5 * 60), (15.5 * 60, 16 * 60)],\n    }\n\n    # Preferences\n    bobby_avoid_days = ['Thursday', 'Friday']\n    brandon_avoid_days_before_12 = ['Monday', 'Tuesday', 'Wednesday']\n\n    # Iterate through each day and find available slots\n    for day in days:\n        if day in bobby_avoid_days:\n            continue\n        if day in brandon_avoid_days_before_12:\n            start_time = max(work_start, 12 * 60)\n        else:\n            start_time = work_start\n\n        # Collect all busy intervals for both participants\n        bobby_busy = bobby_schedule.get(day, [])\n        brandon_busy = brandon_schedule.get(day, [])\n\n        # Merge and sort all busy intervals\n        all_busy = bobby_busy + brandon_busy\n        all_busy.sort()\n\n        # Find available slots\n        current_time = start_time\n        for busy_start, busy_end in all_busy:\n            if busy_start > current_time:\n                if busy_start - current_time >= meeting_duration:\n                    # Found a slot\n                    end_time = current_time + meeting_duration\n                    return f\"{int(current_time // 60):02d}:{int(current_time % 60):02d}:{int(end_time // 60):02d}:{int(end_time % 60):02d}\"\n            current_time = max(current_time, busy_end)\n        \n        # Check after last busy interval\n        if work_end - current_time >= meeting_duration:\n            end_time = current_time + meeting_duration\n            return f\"{int(current_time // 60):02d}:{int(current_time % 60):02d}:{int(end_time // 60):02d}:{int(end_time % 60):02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_922"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_earliest_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to check\n    days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"]\n    \n    # Define Kyle's schedule: {day: [(start1, end1), (start2, end2), ...]}\n    kyle_schedule = {\n        \"Monday\": [(10.5 * 60, 11 * 60)],\n        \"Tuesday\": [(10 * 60, 11 * 60), (12 * 60, 12.5 * 60), (13.5 * 60, 14 * 60)],\n        \"Wednesday\": [(10 * 60, 10.5 * 60), (12 * 60, 12.5 * 60), (13.5 * 60, 14 * 60)],\n        \"Thursday\": [(14.5 * 60, 15 * 60)],\n        \"Friday\": [(10 * 60, 10.5 * 60), (13 * 60, 13.5 * 60), (16.5 * 60, 17 * 60)]\n    }\n    \n    # Define Sharon's schedule\n    sharon_schedule = {\n        \"Monday\": [(9 * 60, 9.5 * 60), (10.5 * 60, 11 * 60), (11.5 * 60, 12 * 60), \n                   (12.5 * 60, 14.5 * 60), (15 * 60, 15.5 * 60)],\n        \"Tuesday\": [(9 * 60, 10 * 60), (10.5 * 60, 11 * 60), (11.5 * 60, 13 * 60), \n                   (13.5 * 60, 14 * 60), (14.5 * 60, 15 * 60), (16.5 * 60, 17 * 60)],\n        \"Wednesday\": [(9 * 60, 11.5 * 60), (12 * 60, 14.5 * 60), (15 * 60, 17 * 60)],\n        \"Thursday\": [(9.5 * 60, 15.5 * 60), (16 * 60, 17 * 60)],\n        \"Friday\": [(9 * 60, 10 * 60), (10.5 * 60, 11.5 * 60), (12.5 * 60, 13 * 60), \n                   (13.5 * 60, 14.5 * 60), (15 * 60, 17 * 60)]\n    }\n    \n    # Meeting duration in minutes\n    duration = 30\n    \n    for day in days:\n        # Collect all busy intervals for both participants\n        busy_intervals = []\n        \n        # Add Kyle's busy times\n        if day in kyle_schedule:\n            busy_intervals.extend(kyle_schedule[day])\n        \n        # Add Sharon's busy times\n        if day in sharon_schedule:\n            busy_intervals.extend(sharon_schedule[day])\n        \n        # Sort all busy intervals by start time\n        busy_intervals.sort()\n        \n        # Find available slots\n        available_slots = []\n        prev_end = work_start\n        \n        for start, end in busy_intervals:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy interval\n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n        \n        # Check each available slot for duration\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= duration:\n                # Found the earliest available slot\n                meeting_start = slot_start\n                meeting_end = meeting_start + duration\n                # Format the time as HH:MM:HH:MM\n                start_hh = int(meeting_start // 60)\n                start_mm = int(meeting_start % 60)\n                end_hh = int(meeting_end // 60)\n                end_mm = int(meeting_end % 60)\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time found\"\n\n# Output the earliest meeting time\nprint(find_earliest_meeting_time())\n```",
            "count": "calendar_scheduling_example_923"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Days to consider: Monday (0), Tuesday (1), Wednesday (2), Friday (4) (excluding Thursday)\n    days = [0, 1, 2, 4]\n    \n    # Danielle's blocked times in minutes since start of day, per day\n    danielle_blocked = {\n        0: [(9*60 + 30, 10*60), (11*60, 12*60), (13*60, 13*60 + 30)],\n        1: [(10*60 + 30, 11*60), (15*60 + 30, 16*60)],\n        2: [(9*60 + 30, 10*60), (12*60 + 30, 13*60)],\n        4: [(9*60 + 30, 10*60), (12*60, 12*60 + 30), (15*60 + 30, 16*60)],\n    }\n    \n    # Amanda's blocked times in minutes since start of day, per day\n    amanda_blocked = {\n        0: [(9*60 + 30, 10*60 + 30), (11*60, 12*60), (12*60 + 30, 15*60), (15*60 + 30, 17*60)],\n        1: [(9*60, 10*60 + 30), (11*60, 17*60)],\n        2: [(9*60, 9*60 + 30), (10*60 + 30, 12*60 + 30), (13*60, 16*60)],\n        4: [(10*60, 10*60 + 30), (12*60, 13*60), (14*60 + 30, 15*60 + 30), (16*60, 17*60)],\n    }\n    \n    meeting_duration = 30  # minutes\n    \n    for day in days:\n        # Collect all blocked times for both participants on this day\n        blocked = danielle_blocked.get(day, []) + amanda_blocked.get(day, [])\n        blocked.sort()  # Sort by start time\n        \n        # Find free slots\n        prev_end = work_start\n        for start, end in blocked:\n            if start > prev_end:\n                # Found a free slot\n                slot_start = prev_end\n                slot_end = start\n                if slot_end - slot_start >= meeting_duration:\n                    # Return the earliest possible time\n                    meeting_start = slot_start\n                    meeting_end = meeting_start + meeting_duration\n                    return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after last blocked time\n        if work_end - prev_end >= meeting_duration:\n            meeting_start = prev_end\n            meeting_end = meeting_start + meeting_duration\n            return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n    \n    return \"No time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_924"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:00:10:30}",
            "type_error": "ValueError",
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef parse_schedule(schedule_str):\n    schedule = {}\n    lines = schedule_str.split(';')\n    for line in lines:\n        if not line.strip():\n            continue\n        parts = line.split(' during ')\n        day = parts[0].strip()\n        time_ranges = parts[1].strip().split(', ')\n        schedule[day] = []\n        for time_range in time_ranges:\n            start, end = time_range.split(' to ')\n            schedule[day].append((start, end))\n    return schedule\n\ndef parse_preferred_days(pref_str):\n    disliked_days = []\n    parts = pref_str.split('.')\n    for part in parts:\n        part = part.strip()\n        if part:\n            day = part.split()[-1].strip()\n            disliked_days.append(day)\n    return disliked_days\n\ndef time_to_minutes(time_str):\n    h, m = map(int, time_str.split(':'))\n    return h * 60 + m\n\ndef minutes_to_time(minutes):\n    h = minutes // 60\n    m = minutes % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef find_available_slot(debra_schedule, eugene_schedule, disliked_days, duration_minutes=30):\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n    work_start = time_to_minutes('9:00')\n    work_end = time_to_minutes('17:00')\n    \n    for day in days:\n        if day in disliked_days:\n            continue\n        \n        debra_busy = debra_schedule.get(day, [])\n        eugene_busy = eugene_schedule.get(day, [])\n        \n        # Combine and sort all busy intervals\n        all_busy = []\n        for start, end in debra_busy:\n            all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n        for start, end in eugene_busy:\n            all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n        all_busy.sort()\n        \n        # Find available slots\n        prev_end = work_start\n        available_slots = []\n        for start, end in all_busy:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n        \n        # Check for a slot that fits the duration\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= duration_minutes:\n                return day, minutes_to_time(slot_start), minutes_to_time(slot_start + duration_minutes)\n    \n    return None\n\n# Input data\ndebra_schedule_str = \"\"\"Debra has meetings on Monday during 10:00 to 11:00, 11:30 to 14:00, Tuesday during 11:00 to 11:30, 14:00 to 14:30, Wednesday during 10:00 to 10:30, 12:00 to 13:00, 13:30 to 14:00, 15:00 to 15:30, 16:30 to 17:00, Thursday during 9:30 to 10:00, 12:30 to 14:00, 16:00 to 17:00, Friday during 9:00 to 9:30, 10:30 to 11:00, 14:00 to 14:30, 15:00 to 15:30, 16:00 to 16:30;\"\"\"\neugene_schedule_str = \"\"\"Eugene is busy on Monday during 9:00 to 9:30, 10:00 to 11:30, 12:00 to 14:00, 14:30 to 15:30, 16:00 to 17:00, Tuesday during 9:00 to 10:00, 10:30 to 11:00, 12:00 to 12:30, 13:00 to 14:00, 16:00 to 16:30, Wednesday during 9:00 to 10:00, 11:00 to 14:00, 14:30 to 15:00, 15:30 to 16:00, 16:30 to 17:00, Thursday during 9:00 to 9:30, 11:00 to 11:30, 12:00 to 12:30, 13:00 to 15:30, 16:00 to 16:30, Friday during 9:30 to 11:00, 11:30 to 13:00, 13:30 to 14:00, 14:30 to 15:00, 15:30 to 17:00;\"\"\"\neugene_preferences = \"Eugene would rather not meet on Monday. Wednesday. Thursday. Friday.\"\n\n# Parse schedules and preferences\ndebra_schedule = parse_schedule(debra_schedule_str)\neugene_schedule = parse_schedule(eugene_schedule_str)\ndisliked_days = parse_preferred_days(eugene_preferences)\n\n# Find the earliest available slot\nresult = find_available_slot(debra_schedule, eugene_schedule, disliked_days)\nif result:\n    day, start_time, end_time = result\n    print(f\"{start_time}:{end_time}\")\nelse:\n    print(\"No available slot found\")\n```",
            "count": "calendar_scheduling_example_925"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_earliest_meeting_time():\n    # Define work hours (9:00 to 17:00)\n    work_start = 9 * 60  # in minutes\n    work_end = 17 * 60   # in minutes\n    \n    # Days to check: Monday (0) to Friday (4)\n    days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"]\n    \n    # Thomas's busy times in minutes since midnight for each day\n    thomas_busy = {\n        0: [(13*60, 14*60), (16*60 + 30, 17*60)],  # Monday\n        1: [(14*60, 14*60 + 30), (16*60 + 30, 17*60)],  # Tuesday\n        2: [(10*60, 10*60 + 30), (11*60, 11*60 + 30), (14*60, 14*60 + 30), (16*60, 16*60 + 30)],  # Wednesday\n        3: [(10*60, 10*60 + 30), (12*60, 12*60 + 30), (13*60, 13*60 + 30), (14*60 + 30, 15*60), (15*60 + 30, 16*60)],  # Thursday\n        4: [(10*60 + 30, 11*60), (12*60 + 30, 13*60 + 30), (16*60, 16*60 + 30)]  # Friday\n    }\n    \n    # Jennifer's busy times in minutes since midnight for each day\n    jennifer_busy = {\n        0: [(9*60, 17*60)],  # Monday (entire day)\n        1: [(9*60, 17*60)],  # Tuesday (entire day)\n        2: [(9*60, 15*60), (15*60 + 30, 16*60), (16*60 + 30, 17*60)],  # Wednesday\n        3: [(9*60, 12*60), (12*60 + 30, 13*60 + 30), (15*60, 16*60 + 30)],  # Thursday\n        4: [(9*60, 12*60), (12*60 + 30, 17*60)]  # Friday\n    }\n    \n    # Iterate through each day\n    for day in range(5):\n        # Collect all busy intervals for both participants\n        busy_intervals = []\n        \n        # Add Thomas's busy times\n        if day in thomas_busy:\n            busy_intervals.extend(thomas_busy[day])\n        \n        # Add Jennifer's busy times\n        if day in jennifer_busy:\n            busy_intervals.extend(jennifer_busy[day])\n        \n        # Sort busy intervals by start time\n        busy_intervals.sort()\n        \n        # Merge overlapping or adjacent intervals\n        merged = []\n        for interval in busy_intervals:\n            if not merged:\n                merged.append(interval)\n            else:\n                last_start, last_end = merged[-1]\n                current_start, current_end = interval\n                if current_start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = last_start\n                    new_end = max(last_end, current_end)\n                    merged[-1] = (new_start, new_end)\n                else:\n                    merged.append(interval)\n        \n        # Find the earliest available 30-minute slot\n        prev_end = work_start\n        for interval in merged:\n            start, end = interval\n            if start > prev_end:\n                # Check if there's a 30-minute gap\n                if start - prev_end >= 30:\n                    # Found a slot\n                    meeting_start = prev_end\n                    meeting_end = meeting_start + 30\n                    # Format the output as HH:MM:HH:MM\n                    start_hh = meeting_start // 60\n                    start_mm = meeting_start % 60\n                    end_hh = meeting_end // 60\n                    end_mm = meeting_end % 60\n                    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after the last busy interval\n        if prev_end + 30 <= work_end:\n            meeting_start = prev_end\n            meeting_end = meeting_start + 30\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time found\"\n\n# Run the function and print the result\nprint(find_earliest_meeting_time())\n```",
            "count": "calendar_scheduling_example_926"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days\n    work_hours = (9, 17)  # 9:00 to 17:00\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n    \n    # Betty's schedule: {day: [(busy_start, busy_end), ...]}\n    betty_schedule = {\n        'Monday': [(9, 10)],\n        'Tuesday': [(11.5, 12), (15, 15.5)],\n        'Wednesday': [(13.5, 14)],\n        'Thursday': [(16.5, 17)],\n        'Friday': []\n    }\n    \n    # Roy's schedule: {day: [(busy_start, busy_end), ...]}\n    roy_schedule = {\n        'Monday': [(9, 10), (10.5, 12), (13.5, 14.5), (15.5, 16.5)],\n        'Tuesday': [(12.5, 13), (15, 15.5), (16, 16.5)],\n        'Wednesday': [(9, 10), (10.5, 11.5), (12.5, 13.5), (14, 15.5), (16, 17)],\n        'Thursday': [(9, 10), (10.5, 17)],\n        'Friday': [(9, 14), (15, 15.5), (16.5, 17)]\n    }\n    \n    # Preferences\n    betty_pref = {'Monday': False, 'Wednesday': False, 'Friday': False}  # Avoid these days\n    roy_pref = {'Tuesday': (13, None)}  # Only after 13:00 on Tuesday\n    \n    # Iterate through days in order, checking for available slots\n    for day in days:\n        if betty_pref.get(day, True) is False:\n            continue  # Skip days Betty prefers not to meet\n        \n        # Check Roy's preference for the day\n        roy_day_pref = roy_pref.get(day, (work_hours[0], None))\n        start_hour = roy_day_pref[0]\n        end_hour = roy_day_pref[1] if roy_day_pref[1] is not None else work_hours[1]\n        \n        # Combine and sort all busy intervals for the day\n        busy_intervals = []\n        \n        # Add Betty's busy times\n        for interval in betty_schedule[day]:\n            busy_intervals.append((interval[0], interval[1]))\n        \n        # Add Roy's busy times\n        for interval in roy_schedule[day]:\n            busy_intervals.append((interval[0], interval[1]))\n        \n        # Sort busy intervals by start time\n        busy_intervals.sort()\n        \n        # Find available slots\n        current_time = start_hour\n        available_slots = []\n        \n        for interval in busy_intervals:\n            if interval[0] > current_time:\n                available_slots.append((current_time, interval[0]))\n            current_time = max(current_time, interval[1])\n        \n        # Check after last busy interval\n        if current_time < end_hour:\n            available_slots.append((current_time, end_hour))\n        \n        # Check for a 1-hour slot\n        for slot in available_slots:\n            slot_start, slot_end = slot\n            if slot_end - slot_start >= 1:\n                # Found a valid slot\n                meeting_start = slot_start\n                meeting_end = meeting_start + 1\n                \n                # Format the time as HH:MM:HH:MM\n                def format_time(time_float):\n                    hours = int(time_float)\n                    minutes = int((time_float - hours) * 60)\n                    return f\"{hours:02d}:{minutes:02d}\"\n                \n                start_str = format_time(meeting_start)\n                end_str = format_time(meeting_end)\n                return f\"{start_str}:{end_str}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_927"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Days to check\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n    \n    # Joseph's busy times in minutes since midnight for each day\n    joseph_busy = {\n        'Monday': [(10*60 + 30, 11*60), (11*60 + 30, 13*60), (13*60 + 30, 14*60), (15*60 + 30, 16*60 + 30)],\n        'Tuesday': [(15*60, 16*60)],\n        'Wednesday': [(13*60 + 30, 14*60), (16*60, 16*60 + 30)],\n        'Thursday': [(13*60, 13*60 + 30), (14*60, 14*60 + 30), (16*60 + 30, 17*60)],\n        'Friday': [(10*60, 10*60 + 30), (13*60 + 30, 14*60)]\n    }\n    \n    # Austin's busy times in minutes since midnight for each day\n    austin_busy = {\n        'Monday': [(9*60, 10*60), (10*60 + 30, 11*60 + 30), (13*60, 13*60 + 30), (15*60, 17*60)],\n        'Tuesday': [(9*60, 9*60 + 30), (10*60, 10*60 + 30), (11*60, 12*60), (13*60, 13*60 + 30), (14*60, 17*60)],\n        'Wednesday': [(9*60, 11*60), (12*60, 13*60), (13*60 + 30, 17*60)],\n        'Thursday': [(9*60, 17*60)],\n        'Friday': [(9*60 + 30, 10*60), (10*60 + 30, 11*60), (12*60, 13*60), (13*60 + 30, 14*60), (15*60, 17*60)]\n    }\n    \n    # Check each day for the earliest available slot\n    for day in days:\n        # Combine and sort both participants' busy times for the day\n        busy_times = joseph_busy.get(day, []) + austin_busy.get(day, [])\n        busy_times.sort()\n        \n        # Merge overlapping or adjacent busy intervals\n        merged = []\n        for start, end in busy_times:\n            if not merged:\n                merged.append([start, end])\n            else:\n                last_start, last_end = merged[-1]\n                if start <= last_end:\n                    merged[-1] = [last_start, max(end, last_end)]\n                else:\n                    merged.append([start, end])\n        \n        # Check the available slots before the first busy time, between busy times, and after the last busy time\n        prev_end = work_start\n        for start, end in merged:\n            if start > prev_end:\n                available_start = prev_end\n                available_end = start\n                if available_end - available_start >= 60:  # 1 hour meeting\n                    # Convert minutes back to HH:MM format\n                    start_hh = available_start // 60\n                    start_mm = available_start % 60\n                    end_hh = (available_start + 60) // 60\n                    end_mm = (available_start + 60) % 60\n                    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after the last busy time\n        if work_end - prev_end >= 60:\n            start_hh = prev_end // 60\n            start_mm = prev_end % 60\n            end_hh = (prev_end + 60) // 60\n            end_mm = (prev_end + 60) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_928"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to consider based on constraints\n    # Kathleen doesn't want to meet on Tuesday\n    # Christian cannot meet on Monday, Wednesday, Friday\n    # Only possible day is Thursday\n    day = \"Thursday\"\n    \n    # Kathleen's blocked times on Thursday in minutes since midnight\n    kathleen_blocked = [\n        (9 * 60, 9 * 60 + 30),   # 9:00-9:30\n        (11 * 60, 11 * 60 + 30),  # 11:00-11:30\n        (13 * 60, 13 * 60 + 30),  # 13:00-13:30\n        (14 * 60, 14 * 60 + 30),  # 14:00-14:30\n    ]\n    \n    # Christian's blocked times on Thursday in minutes since midnight\n    christian_blocked = [\n        (9 * 60, 9 * 60 + 30),   # 9:00-9:30\n        (11 * 60, 13 * 60),       # 11:00-13:00\n        (14 * 60, 15 * 60),       # 14:00-15:00\n        (15 * 60 + 30, 17 * 60),  # 15:30-17:00\n    ]\n    \n    # Combine and sort all blocked times for both participants\n    all_blocked = kathleen_blocked + christian_blocked\n    all_blocked.sort()\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in all_blocked:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit 30 minutes\n    for slot in available_slots:\n        start, end = slot\n        if end - start >= 30:\n            meeting_start = start\n            meeting_end = meeting_start + 30\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available slot found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_929"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days\n    work_hours = (9, 17)  # 9:00 to 17:00\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n    \n    # Define Jean's and Jennifer's schedules with blocked times\n    jean_schedule = {\n        'Monday': [(10, 10.5), (12, 12.5), (13.5, 14), (15, 15.5), (16.5, 17)],\n        'Tuesday': [(10, 10.5), (14, 14.5), (16, 16.5)],\n        'Thursday': [(14, 14.5), (15, 15.5)],\n        'Friday': [(9.5, 10), (11, 11.5), (12, 12.5), (14.5, 15)]\n    }\n    \n    jennifer_schedule = {\n        'Monday': [(10.5, 11), (12, 12.5), (14.5, 15), (16, 17)],\n        'Tuesday': [(10, 13.5), (14.5, 15)],\n        'Wednesday': [(9, 11.5), (12, 13.5), (14.5, 17)],\n        'Thursday': [(9.5, 10), (12, 13), (13.5, 14), (14.5, 15), (16.5, 17)],\n        'Friday': [(10, 11), (12, 13.5), (14.5, 17)]\n    }\n    \n    # Preferences\n    jean_prefs = {\n        'Monday': False,\n        'Thursday': (10, False)  # After 10:00 is not preferred\n    }\n    \n    jennifer_prefs = {\n        'Tuesday': False,\n        'Wednesday': False,\n        'Friday': False\n    }\n    \n    # Iterate through each day and find a 30-minute slot\n    for day in days:\n        # Check Jean's preferences\n        if day == 'Monday' and jean_prefs.get('Monday') is False:\n            continue\n        if day == 'Thursday' and jean_prefs.get('Thursday') is not None:\n            pref_time, pref_bool = jean_prefs['Thursday']\n            if pref_bool is False:\n                # Only consider times before or equal to pref_time\n                max_time = pref_time\n            else:\n                max_time = work_hours[1]\n        else:\n            max_time = work_hours[1]\n        \n        # Check Jennifer's preferences\n        if jennifer_prefs.get(day) is False:\n            continue\n        \n        # Combine and sort all blocked times for both participants\n        jean_blocks = jean_schedule.get(day, [])\n        jennifer_blocks = jennifer_schedule.get(day, [])\n        all_blocks = sorted(jean_blocks + jennifer_blocks, key=lambda x: x[0])\n        \n        # Find available slots\n        available_slots = []\n        prev_end = work_hours[0]\n        \n        for block in all_blocks:\n            block_start, block_end = block\n            if block_start > prev_end:\n                available_slots.append((prev_end, block_start))\n            prev_end = max(prev_end, block_end)\n        \n        if prev_end < work_hours[1]:\n            available_slots.append((prev_end, work_hours[1]))\n        \n        # Check for a 30-minute slot in available slots\n        for slot in available_slots:\n            slot_start, slot_end = slot\n            if day == 'Thursday' and jean_prefs.get('Thursday') is not None:\n                pref_time, pref_bool = jean_prefs['Thursday']\n                if pref_bool is False and slot_start >= pref_time:\n                    continue  # Skip slots after preferred time\n            \n            if slot_end - slot_start >= 0.5:  # 30 minutes\n                meeting_start = slot_start\n                meeting_end = meeting_start + 0.5\n                # Format the time\n                start_hour = int(meeting_start)\n                start_min = int((meeting_start - start_hour) * 60)\n                end_hour = int(meeting_end)\n                end_min = int((meeting_end - end_hour) * 60)\n                return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n    \n    return \"No suitable time found.\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_930"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to consider\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n    \n    # Noah's schedule: {day: [(start, end), ...]}\n    noah_schedule = {\n        'Monday': [(9*60, 10*60), (12*60, 12.5*60), (13*60, 13.5*60), (15.5*60, 16*60)],\n        'Tuesday': [(9*60, 10.5*60), (11*60, 11.5*60), (12*60, 12.5*60), (14*60, 15*60), (16*60, 17*60)],\n        'Wednesday': [(10*60, 12*60), (14*60, 15*60), (15.5*60, 16*60), (16.5*60, 17*60)],\n        'Thursday': [(10*60, 10.5*60), (11*60, 12*60), (16*60, 16.5*60)],\n        'Friday': [(9.5*60, 10*60), (10.5*60, 12*60), (12.5*60, 13.5*60), (15*60, 15.5*60), (16.5*60, 17*60)]\n    }\n    \n    # Kathryn's schedule: {day: [(start, end), ...]}\n    kathryn_schedule = {\n        'Monday': [(9*60, 12*60), (13*60, 14.5*60), (15*60, 17*60)],\n        'Tuesday': [(9*60, 12.5*60), (13*60, 17*60)],\n        'Wednesday': [(9*60, 9.5*60), (12.5*60, 17*60)],\n        'Thursday': [(9*60, 11.5*60), (12*60, 13*60), (14*60, 15*60), (15.5*60, 17*60)],\n        'Friday': [(9*60, 11*60), (11.5*60, 12.5*60), (13*60, 16*60)]\n    }\n    \n    # Noah prefers to avoid Wednesday, so we'll prioritize other days\n    preferred_days = [day for day in days if day != 'Wednesday']\n    preferred_days.append('Wednesday')  # Check Wednesday last\n    \n    meeting_duration = 30  # minutes\n    \n    for day in preferred_days:\n        # Collect all busy times for both participants on this day\n        busy_times = noah_schedule.get(day, []) + kathryn_schedule.get(day, [])\n        busy_times.sort()  # Sort by start time\n        \n        # Find all free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in busy_times:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            available_start = slot_start\n            available_end = slot_end\n            \n            if available_end - available_start >= meeting_duration:\n                # Found a suitable slot\n                meeting_start = available_start\n                meeting_end = meeting_start + meeting_duration\n                \n                # Convert back to HH:MM format\n                def minutes_to_time(minutes):\n                    hours = int(minutes // 60)\n                    mins = int(minutes % 60)\n                    return f\"{hours:02d}:{mins:02d}\"\n                \n                start_time = minutes_to_time(meeting_start)\n                end_time = minutes_to_time(meeting_end)\n                return f\"{start_time}:{end_time}\"\n    \n    return \"No suitable time found\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_931"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to consider (Monday=0, Tuesday=1, ..., Friday=4)\n    days = [0, 1, 2, 3, 4]\n\n    # Virginia's busy times in minutes since midnight for each day\n    virginia_busy = {\n        0: [(9*60 + 30, 10*60), (12*60, 12*60 + 30), (14*60 + 30, 15*60), (16*60 + 30, 17*60)],\n        1: [(9*60, 10*60 + 30), (11*60, 11*60 + 30), (13*60 + 30, 14*60 + 30), (15*60 + 30, 16*60)],\n        2: [(10*60, 12*60), (13*60, 13*60 + 30), (14*60 + 30, 15*60), (16*60, 17*60)],\n        3: [(9*60, 9*60 + 30), (10*60, 11*60), (13*60, 14*60), (14*60 + 30, 16*60), (16*60 + 30, 17*60)],\n        4: [(9*60 + 30, 10*60 + 30), (12*60, 13*60), (13*60 + 30, 15*60 + 30), (16*60, 17*60)]\n    }\n\n    # Maria's busy times in minutes since midnight for each day\n    maria_busy = {\n        0: [(9*60, 10*60 + 30), (11*60 + 30, 15*60 + 30), (16*60, 17*60)],\n        1: [(9*60, 10*60), (12*60, 15*60 + 30), (16*60, 16*60 + 30)],\n        2: [(9*60 + 30, 12*60), (13*60, 13*60 + 30), (14*60, 15*60 + 30), (16*60, 17*60)],\n        3: [(9*60 + 30, 11*60), (12*60, 15*60 + 30), (16*60, 17*60)],\n        4: [(10*60 + 30, 11*60 + 30), (12*60, 12*60 + 30), (13*60 + 30, 14*60), (14*60 + 30, 16*60 + 30)]\n    }\n\n    # Apply preferences\n    # Virginia doesn't want Monday, Tuesday, Thursday, Friday\n    preferred_days = [2]  # Only Wednesday left after preferences\n\n    # Maria doesn't want Wednesday after 13:30\n    maria_wednesday_cutoff = 13 * 60 + 30\n\n    # Iterate through each possible day\n    for day in preferred_days:\n        # Get both persons' busy times for this day\n        v_busy = virginia_busy.get(day, [])\n        m_busy = maria_busy.get(day, [])\n\n        # Combine and sort all busy intervals\n        all_busy = v_busy + m_busy\n        all_busy.sort()\n\n        # Find free slots\n        current_time = work_start\n        free_slots = []\n\n        for busy_start, busy_end in all_busy:\n            if busy_start > current_time:\n                free_slots.append((current_time, busy_start))\n            current_time = max(current_time, busy_end)\n\n        if current_time < work_end:\n            free_slots.append((current_time, work_end))\n\n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            # Check if slot is long enough\n            if slot_end - slot_start >= meeting_duration:\n                # Apply Maria's Wednesday after 13:30 constraint\n                if day == 2:\n                    latest_start = min(slot_end - meeting_duration, maria_wednesday_cutoff - meeting_duration)\n                    if latest_start >= slot_start:\n                        start_time = slot_start\n                        end_time = start_time + meeting_duration\n                        return f\"{int(start_time//60):02d}:{int(start_time%60):02d}:{int(end_time//60):02d}:{int(end_time%60):02d}\"\n                else:\n                    start_time = slot_start\n                    end_time = start_time + meeting_duration\n                    return f\"{int(start_time//60):02d}:{int(start_time%60):02d}:{int(end_time//60):02d}:{int(end_time%60):02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_932"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration, days):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = meeting_duration * 60\n\n    # Initialize available slots for each day\n    for day in days:\n        # Get all busy intervals for the day for all participants\n        busy_intervals = []\n        for participant in participants_schedules:\n            for meeting in participant.get(day, []):\n                start = time_to_minutes(meeting[0])\n                end = time_to_minutes(meeting[1])\n                busy_intervals.append((start, end))\n        \n        # Sort busy intervals by start time\n        busy_intervals.sort()\n\n        # Merge overlapping or adjacent busy intervals\n        merged = []\n        for start, end in busy_intervals:\n            if not merged:\n                merged.append((start, end))\n            else:\n                last_start, last_end = merged[-1]\n                if start <= last_end:\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged[-1] = (new_start, new_end)\n                else:\n                    merged.append((start, end))\n\n        # Find free intervals\n        free_intervals = []\n        prev_end = work_start\n        for start, end in merged:\n            if start > prev_end:\n                free_intervals.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            free_intervals.append((prev_end, work_end))\n\n        # Check if any free interval can accommodate the meeting\n        for start, end in free_intervals:\n            if end - start >= duration:\n                meeting_start = start\n                meeting_end = meeting_start + duration\n                return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No suitable time found\"\n\n# Define participants' schedules\nanthony_schedule = {\n    \"Monday\": [(\"10:30\", \"11:00\"), (\"13:00\", \"14:00\"), (\"16:30\", \"17:00\")],\n    \"Tuesday\": [(\"9:30\", \"11:00\"), (\"11:30\", \"12:00\"), (\"13:30\", \"14:00\"), (\"15:30\", \"16:00\")],\n    \"Wednesday\": [(\"10:00\", \"11:00\"), (\"13:00\", \"13:30\"), (\"14:00\", \"14:30\"), (\"16:30\", \"17:00\")],\n    \"Thursday\": [(\"10:30\", \"11:00\"), (\"11:30\", \"12:30\"), (\"13:30\", \"14:30\"), (\"15:00\", \"16:00\"), (\"16:30\", \"17:00\")],\n    \"Friday\": [(\"9:00\", \"11:00\"), (\"11:30\", \"15:30\"), (\"16:30\", \"17:00\")]\n}\n\nrandy_schedule = {\n    \"Monday\": [(\"9:00\", \"17:00\")],\n    \"Tuesday\": [(\"9:00\", \"9:30\"), (\"10:00\", \"12:30\"), (\"13:00\", \"17:00\")],\n    \"Wednesday\": [(\"9:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"16:30\")],\n    \"Thursday\": [(\"10:00\", \"11:30\"), (\"12:30\", \"13:30\"), (\"14:00\", \"14:30\"), (\"15:00\", \"15:30\"), (\"16:00\", \"17:00\")],\n    \"Friday\": [(\"9:00\", \"17:00\")]\n}\n\nparticipants = [anthony_schedule, randy_schedule]\nwork_hours = (\"9:00\", \"17:00\")\nmeeting_duration = 1  # in hours\ndays_to_check = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants, work_hours[0], work_hours[1], meeting_duration, days_to_check)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_933"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{10:00:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_earliest_meeting_time(participants_schedules, work_hours, days, duration):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = map(time_to_minutes, work_hours.split('-'))\n    duration_minutes = duration * 60\n    \n    # Check all days in order\n    for day in days:\n        # Collect all busy intervals for the day for all participants\n        busy_intervals = []\n        for participant in participants_schedules:\n            if day in participant:\n                for interval in participant[day]:\n                    start, end = map(time_to_minutes, interval.split('-'))\n                    busy_intervals.append((start, end))\n        \n        # Sort all busy intervals by start time\n        busy_intervals.sort()\n        \n        # Find free slots by checking gaps between busy intervals and work hours\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in busy_intervals:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy interval\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for availability of duration_minutes\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= duration_minutes:\n                meeting_start = slot_start\n                meeting_end = meeting_start + duration_minutes\n                return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules\njulia_schedule = {\n    \"Monday\": [\"9:30-10:00\", \"11:30-12:30\", \"13:00-13:30\", \"14:00-15:30\"],\n    \"Tuesday\": [\"11:30-12:00\", \"16:00-16:30\"],\n    \"Wednesday\": [\"11:30-12:00\", \"13:00-13:30\"],\n    \"Thursday\": [\"9:00-9:30\", \"11:00-12:00\", \"12:30-13:00\", \"14:30-15:00\", \"16:00-17:00\"],\n    \"Friday\": [\"9:30-10:30\", \"12:30-13:00\", \"13:30-14:00\", \"14:30-15:00\", \"15:30-16:00\"]\n}\n\njanet_schedule = {\n    \"Monday\": [\"11:30-14:00\", \"14:30-16:00\", \"16:30-17:00\"],\n    \"Tuesday\": [\"9:30-11:00\", \"11:30-15:00\", \"15:30-17:00\"],\n    \"Wednesday\": [\"9:00-10:00\", \"11:00-15:30\", \"16:00-17:00\"],\n    \"Thursday\": [\"9:00-12:30\", \"13:00-13:30\", \"14:00-16:00\", \"16:30-17:00\"],\n    \"Friday\": [\"9:30-10:30\", \"12:00-12:30\", \"13:00-14:30\", \"15:00-17:00\"]\n}\n\nparticipants = [julia_schedule, janet_schedule]\nwork_hours = \"9:00-17:00\"\ndays = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"]\nduration = 1  # in hours\n\n# Find the earliest meeting time\nmeeting_time = find_earliest_meeting_time(participants, work_hours, days, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_934"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n    \n    # Terry's schedule: day -> list of busy intervals in minutes\n    terry_busy = {\n        'Monday': [(10*60 + 30, 11*60), (12*60 + 30, 14*60), (15*60, 17*60)],\n        'Tuesday': [(9*60 + 30, 10*60), (10*60 + 30, 11*60), (14*60, 14*60 + 30), (16*60, 16*60 + 30)],\n        'Wednesday': [(9*60 + 30, 10*60 + 30), (11*60, 12*60), (13*60, 13*60 + 30), (15*60, 16*60), (16*60 + 30, 17*60)],\n        'Thursday': [(9*60 + 30, 10*60), (12*60, 12*60 + 30), (13*60, 14*60 + 30), (16*60, 16*60 + 30)],\n        'Friday': [(9*60, 11*60 + 30), (12*60, 12*60 + 30), (13*60 + 30, 16*60), (16*60 + 30, 17*60)]\n    }\n    \n    # Frances's schedule: day -> list of busy intervals in minutes\n    frances_busy = {\n        'Monday': [(9*60 + 30, 11*60), (11*60 + 30, 13*60), (14*60, 14*60 + 30), (15*60, 16*60)],\n        'Tuesday': [(9*60, 9*60 + 30), (10*60, 10*60 + 30), (11*60, 12*60), (13*60, 14*60 + 30), (15*60 + 30, 16*60 + 30)],\n        'Wednesday': [(9*60 + 30, 10*60), (10*60 + 30, 11*60), (11*60 + 30, 16*60), (16*60 + 30, 17*60)],\n        'Thursday': [(11*60, 12*60 + 30), (14*60 + 30, 17*60)],\n        'Friday': [(9*60 + 30, 10*60 + 30), (11*60, 12*60 + 30), (13*60, 16*60), (16*60 + 30, 17*60)]\n    }\n    \n    # Frances prefers to avoid Tuesday, so we check other days first\n    preferred_days = ['Monday', 'Wednesday', 'Thursday', 'Friday', 'Tuesday']\n    \n    meeting_duration = 30  # minutes\n    \n    for day in preferred_days:\n        # Get both Terry and Frances's busy times for the day\n        terry_busy_today = terry_busy.get(day, [])\n        frances_busy_today = frances_busy.get(day, [])\n        \n        # Combine and sort all busy intervals\n        all_busy = terry_busy_today + frances_busy_today\n        all_busy.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            available_start = slot_start\n            available_end = slot_end\n            \n            # Ensure the slot is at least 30 minutes\n            if available_end - available_start >= meeting_duration:\n                # The earliest possible time is the start of the slot\n                meeting_start = available_start\n                meeting_end = meeting_start + meeting_duration\n                \n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                \n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_935"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(brittany_schedule, stephen_schedule, work_hours, duration_minutes=30):\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n    start_hour, end_hour = work_hours\n    \n    for day in days:\n        # Get Brittany's and Stephen's meetings for the day\n        brittany_meetings = brittany_schedule.get(day, [])\n        stephen_meetings = stephen_schedule.get(day, [])\n        \n        # Combine and sort all meetings for the day\n        all_meetings = brittany_meetings + stephen_meetings\n        all_meetings.sort()\n        \n        # Check the time before the first meeting\n        if all_meetings:\n            first_meeting_start = all_meetings[0][0]\n            if first_meeting_start > start_hour:\n                available_start = start_hour\n                available_end = first_meeting_start\n                if (available_end - available_start) >= duration_minutes / 60:\n                    return f\"{day}: {int(available_start)}:{'00' if int(available_start) == available_start else '30'}:{int(available_start)}:{'30' if int(available_start) == available_start else '00'}\"\n        \n        # Check the time between meetings\n        for i in range(1, len(all_meetings)):\n            prev_end = all_meetings[i-1][1]\n            curr_start = all_meetings[i][0]\n            if curr_start > prev_end:\n                available_start = prev_end\n                available_end = curr_start\n                if (available_end - available_start) >= duration_minutes / 60:\n                    return f\"{day}: {int(available_start)}:{'00' if int(available_start) == available_start else '30'}:{int(available_start)}:{'30' if int(available_start) == available_start else '00'}\"\n        \n        # Check the time after the last meeting\n        if all_meetings:\n            last_meeting_end = all_meetings[-1][1]\n            if last_meeting_end < end_hour:\n                available_start = last_meeting_end\n                available_end = end_hour\n                if (available_end - available_start) >= duration_minutes / 60:\n                    return f\"{day}: {int(available_start)}:{'00' if int(available_start) == available_start else '30'}:{int(available_start)}:{'30' if int(available_start) == available_start else '00'}\"\n        else:\n            # No meetings all day\n            return f\"{day}: {start_hour}:00:{start_hour + duration_minutes / 60}:00\"\n    \n    return \"No available time found.\"\n\n# Define schedules\nbrittany_schedule = {\n    'Monday': [(10.5, 11), (12, 12.5), (13.5, 14.5), (15, 15.5), (16, 16.5)],\n    'Tuesday': [(10, 10.5), (11, 11.5), (12.5, 13), (13.5, 14), (14.5, 15), (16, 16.5)],\n    'Wednesday': [(9, 11), (11.5, 13.5), (14.5, 15), (15.5, 16), (16.5, 17)],\n    'Thursday': [(9.5, 10), (11, 11.5), (15.5, 16), (16.5, 17)],\n    'Friday': [(9, 9.5), (11.5, 12), (12.5, 13), (14.5, 15), (16.5, 17)]\n}\n\nstephen_schedule = {\n    'Monday': [(9, 17)],\n    'Tuesday': [(9, 17)],\n    'Wednesday': [(9, 9.5), (10, 13.5), (14, 17)],\n    'Thursday': [(9, 17)],\n    'Friday': [(9, 17)]\n}\n\nwork_hours = (9, 17)\n\n# Find meeting time\nresult = find_meeting_time(brittany_schedule, stephen_schedule, work_hours)\nprint(result.split(': ')[1].replace('.', ':'))\n```",
            "count": "calendar_scheduling_example_936"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to consider (Monday=0, Tuesday=1, ..., Friday=4)\n    days = [0, 1, 2, 3, 4]  # Monday to Friday\n    \n    # Jesse's constraints: day -> list of busy intervals in minutes\n    jesse_busy = {\n        0: [(9*60 + 30, 10*60), (10*60 + 30, 11*60), (13*60, 15*60 + 30), (16*60, 17*60)],\n        1: [(10*60, 11*60), (12*60, 13*60), (14*60 + 30, 15*60), (15*60 + 30, 16*60)],\n        2: [(11*60 + 30, 12*60), (14*60, 15*60)],\n        3: [(9*60, 9*60 + 30), (10*60, 10*60 + 30), (11*60 + 30, 12*60), (13*60, 15*60 + 30), (16*60, 16*60 + 30)],\n        4: [(9*60 + 30, 10*60), (10*60 + 30, 11*60 + 30), (12*60, 12*60 + 30), (13*60 + 30, 14*60), (15*60 + 30, 16*60 + 30)],\n    }\n    \n    # Lori's constraints: day -> list of busy intervals in minutes\n    lori_busy = {\n        0: [(9*60, 10*60 + 30), (11*60, 13*60), (13*60 + 30, 14*60), (15*60, 15*60 + 30), (16*60, 17*60)],\n        1: [(9*60, 9*60 + 30), (10*60 + 30, 11*60 + 30), (12*60, 12*60 + 30), (14*60, 16*60)],\n        2: [(9*60, 10*60), (12*60, 12*60 + 30), (13*60, 14*60), (14*60 + 30, 15*60)],\n        3: [(9*60 + 30, 11*60), (11*60 + 30, 12*60 + 30), (13*60 + 30, 14*60), (14*60 + 30, 15*60), (16*60, 16*60 + 30)],\n        4: [(9*60 + 30, 10*60), (11*60, 12*60 + 30), (13*60, 15*60), (16*60, 16*60 + 30)],\n    }\n    \n    # Additional constraints: Jesse cannot meet on Tuesday or Friday, Lori cannot meet on Monday\n    excluded_days_jesse = {1, 4}  # Tuesday and Friday\n    excluded_days_lori = {0}       # Monday\n    \n    # Iterate through each day in order\n    for day in sorted(days):\n        if day in excluded_days_jesse or day in excluded_days_lori:\n            continue\n        \n        # Combine and sort all busy intervals for both participants\n        busy_intervals = jesse_busy.get(day, []) + lori_busy.get(day, [])\n        busy_intervals.sort()\n        \n        # Merge overlapping or adjacent intervals\n        merged = []\n        for start, end in busy_intervals:\n            if not merged:\n                merged.append([start, end])\n            else:\n                last_start, last_end = merged[-1]\n                if start <= last_end:\n                    merged[-1][1] = max(last_end, end)\n                else:\n                    merged.append([start, end])\n        \n        # Check the available slots before the first busy interval, between intervals, and after last\n        prev_end = work_start\n        available_slots = []\n        \n        for start, end in merged:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n        \n        # Check each available slot for a 30-minute window\n        for slot_start, slot_end in available_slots:\n            duration_needed = 30\n            if slot_end - slot_start >= duration_needed:\n                meeting_start = slot_start\n                meeting_end = meeting_start + duration_needed\n                # Convert back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_937"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Days to consider\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n\n    # Eugene's busy times in minutes since midnight for each day\n    eugene_busy = {\n        'Monday': [(11*60, 12*60), (13*60 + 30, 14*60), (14*60 + 30, 15*60), (16*60, 16*60 + 30)],\n        'Wednesday': [(9*60, 9*60 + 30), (11*60, 11*60 + 30), (12*60, 12*60 + 30), (13*60 + 30, 15*60)],\n        'Thursday': [(9*60 + 30, 10*60), (11*60, 12*60 + 30)],\n        'Friday': [(10*60 + 30, 11*60), (12*60, 12*60 + 30), (13*60, 13*60 + 30)],\n        'Tuesday': []  # No busy times on Tuesday\n    }\n\n    # Eric's busy times in minutes since midnight for each day\n    eric_busy = {\n        'Monday': [(9*60, 17*60)],\n        'Tuesday': [(9*60, 17*60)],\n        'Wednesday': [(9*60, 11*60 + 30), (12*60, 14*60), (14*60 + 30, 16*60 + 30)],\n        'Thursday': [(9*60, 17*60)],\n        'Friday': [(9*60, 11*60), (11*60 + 30, 17*60)]\n    }\n\n    # Iterate through each day, avoiding Wednesday if possible\n    preferred_days = [day for day in days if day != 'Wednesday'] + ['Wednesday']\n    \n    for day in preferred_days:\n        # Collect all busy intervals for both participants on this day\n        busy_intervals = eugene_busy.get(day, []) + eric_busy.get(day, [])\n        busy_intervals.sort()\n\n        # Merge overlapping or adjacent intervals\n        merged = []\n        for start, end in busy_intervals:\n            if not merged:\n                merged.append((start, end))\n            else:\n                last_start, last_end = merged[-1]\n                if start <= last_end:\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged[-1] = (new_start, new_end)\n                else:\n                    merged.append((start, end))\n\n        # Check the time before the first busy interval\n        if not merged:\n            # No busy intervals, the whole day is free\n            proposed_start = work_start\n            proposed_end = proposed_start + meeting_duration\n            if proposed_end <= work_end:\n                return f\"{format_time(proposed_start)}:{format_time(proposed_end)}\"\n        else:\n            first_start, first_end = merged[0]\n            if work_start + meeting_duration <= first_start:\n                proposed_start = work_start\n                proposed_end = proposed_start + meeting_duration\n                return f\"{format_time(proposed_start)}:{format_time(proposed_end)}\"\n\n        # Check the time between busy intervals\n        for i in range(len(merged) - 1):\n            current_end = merged[i][1]\n            next_start = merged[i + 1][0]\n            if current_end + meeting_duration <= next_start:\n                proposed_start = current_end\n                proposed_end = proposed_start + meeting_duration\n                return f\"{format_time(proposed_start)}:{format_time(proposed_end)}\"\n\n        # Check the time after the last busy interval\n        last_start, last_end = merged[-1]\n        if last_end + meeting_duration <= work_end:\n            proposed_start = last_end\n            proposed_end = proposed_start + meeting_duration\n            return f\"{format_time(proposed_start)}:{format_time(proposed_end)}\"\n\n    return \"No suitable time found\"\n\ndef format_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_938"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(donna_schedule, kenneth_schedule, work_hours_start, work_hours_end, meeting_duration, days):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    for day in days:\n        # Collect all busy intervals for Donna and Kenneth on the current day\n        donna_busy = []\n        for interval in donna_schedule.get(day, []):\n            start, end = interval.split(' to ')\n            donna_busy.append((time_to_minutes(start), time_to_minutes(end)))\n        \n        kenneth_busy = []\n        for interval in kenneth_schedule.get(day, []):\n            start, end = interval.split(' to ')\n            kenneth_busy.append((time_to_minutes(start), time_to_minutes(end)))\n        \n        # Merge and sort all busy intervals for both participants\n        all_busy = donna_busy + kenneth_busy\n        all_busy.sort()\n        \n        # Find free intervals by checking gaps between busy intervals\n        free_intervals = []\n        prev_end = work_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_intervals.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_intervals.append((prev_end, work_end))\n        \n        # Check each free interval for availability\n        for start, end in free_intervals:\n            if end - start >= meeting_duration:\n                meeting_start = start\n                meeting_end = meeting_start + meeting_duration\n                return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No meeting time found\"\n\n# Define schedules\ndonna_schedule = {\n    'Monday': ['12:00 to 12:30', '16:30 to 17:00'],\n    'Wednesday': ['9:30 to 10:00'],\n    'Friday': ['16:00 to 16:30']\n}\n\nkenneth_schedule = {\n    'Monday': ['9:00 to 12:00', '13:00 to 13:30', '15:00 to 15:30', '16:00 to 17:00'],\n    'Tuesday': ['9:00 to 13:30', '14:30 to 17:00'],\n    'Wednesday': ['9:30 to 10:30', '11:00 to 11:30', '12:00 to 12:30', '13:00 to 14:30', '15:00 to 16:30'],\n    'Thursday': ['9:00 to 11:00', '11:30 to 13:30', '14:00 to 16:30'],\n    'Friday': ['9:00 to 9:30', '10:00 to 17:00']\n}\n\n# Parameters\nwork_hours_start = '9:00'\nwork_hours_end = '17:00'\nmeeting_duration = 30  # minutes\ndays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n\n# Find meeting time\nresult = find_meeting_time(donna_schedule, kenneth_schedule, work_hours_start, work_hours_end, meeting_duration, days)\nprint(result)\n```",
            "count": "calendar_scheduling_example_939"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n    \n    # Megan's constraints: no meetings, but can't meet on Wednesday\n    megan_available_days = [day for day in days if day != 'Wednesday']\n    \n    # Kelly's schedule: blocked times per day\n    kelly_schedule = {\n        'Monday': [(10 * 60, 11 * 60 + 30), (13 * 60, 14 * 60), (16 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 12 * 60 + 30), (13 * 60, 17 * 60)],\n        'Wednesday': [(10 * 60, 11 * 60 + 30), (14 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Thursday': [(9 * 60, 9 * 60 + 30), (10 * 60, 11 * 60), (11 * 60 + 30, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Friday': [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60), (11 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60 + 30), (15 * 60, 17 * 60)]\n    }\n    \n    # Kelly's preference: not on Monday after 14:00\n    kelly_preference = {\n        'Monday': (14 * 60, 17 * 60)\n    }\n    \n    meeting_duration = 60  # 1 hour\n    \n    # Iterate through available days for Megan\n    for day in megan_available_days:\n        # Get Kelly's blocked times for the day\n        blocked_times = kelly_schedule.get(day, [])\n        \n        # Add Kelly's preference as a blocked time if applicable\n        if day in kelly_preference:\n            blocked_times.append(kelly_preference[day])\n        \n        # Sort blocked times by start time\n        blocked_times.sort()\n        \n        # Find available slots\n        available_slots = []\n        prev_end = work_start\n        \n        for start, end in blocked_times:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after last blocked time\n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n        \n        # Check each available slot for a meeting duration\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= meeting_duration:\n                # Found a suitable time\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                \n                # Convert minutes back to HH:MM format\n                def format_time(minutes):\n                    hours = minutes // 60\n                    mins = minutes % 60\n                    return f\"{hours:02d}:{mins:02d}\"\n                \n                return f\"{format_time(meeting_start)}:{format_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_940"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(emily_busy, elizabeth_busy, days, work_hours, duration):\n    start_work, end_work = work_hours\n    meeting_duration = duration\n    \n    for day in days:\n        # Initialize available time for the day\n        emily_available = [(start_work, end_work)]\n        elizabeth_available = [(start_work, end_work)]\n        \n        # Subtract busy times for Emily\n        for busy in emily_busy.get(day, []):\n            start, end = busy\n            new_available = []\n            for slot in emily_available:\n                if slot[1] <= start or slot[0] >= end:\n                    new_available.append(slot)\n                else:\n                    if slot[0] < start:\n                        new_available.append((slot[0], start))\n                    if slot[1] > end:\n                        new_available.append((end, slot[1]))\n            emily_available = new_available\n        \n        # Subtract busy times for Elizabeth\n        for busy in elizabeth_busy.get(day, []):\n            start, end = busy\n            new_available = []\n            for slot in elizabeth_available:\n                if slot[1] <= start or slot[0] >= end:\n                    new_available.append(slot)\n                else:\n                    if slot[0] < start:\n                        new_available.append((slot[0], start))\n                    if slot[1] > end:\n                        new_available.append((end, slot[1]))\n            elizabeth_available = new_available\n        \n        # Find overlapping slots\n        for emily_slot in emily_available:\n            for elizabeth_slot in elizabeth_available:\n                start = max(emily_slot[0], elizabeth_slot[0])\n                end = min(emily_slot[1], elizabeth_slot[1])\n                if end - start >= meeting_duration:\n                    return f\"{day} {start}:{end}\"\n    \n    return \"No meeting time found\"\n\n# Define work hours and meeting duration\nwork_hours = (9.0, 17.0)\nmeeting_duration = 1.0  # 1 hour\n\n# Define days to check\ndays = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"]\n\n# Define busy times for Emily and Elizabeth\nemily_busy = {\n    \"Monday\": [(12.0, 12.5), (13.5, 14.5)],\n    \"Tuesday\": [(13.0, 13.5)],\n    \"Wednesday\": [(9.0, 9.5), (10.0, 11.0), (16.5, 17.0)],\n    \"Thursday\": [(9.0, 9.5), (11.5, 12.0), (15.5, 16.0)],\n    \"Friday\": [(12.5, 13.0), (15.0, 15.5), (16.0, 16.5)]\n}\n\nelizabeth_busy = {\n    \"Monday\": [(9.0, 10.5), (11.0, 12.5), (13.0, 13.5), (14.5, 17.0)],\n    \"Tuesday\": [(9.0, 10.5), (11.0, 11.5), (12.0, 13.5), (14.5, 17.0)],\n    \"Wednesday\": [(9.0, 10.5), (11.0, 11.5), (12.0, 17.0)],\n    \"Thursday\": [(9.5, 10.5), (11.0, 12.0), (12.5, 14.0), (14.5, 15.0), (15.5, 17.0)],\n    \"Friday\": [(9.0, 11.5), (12.0, 14.0), (14.5, 15.0), (15.5, 17.0)]\n}\n\n# Find a meeting time\nmeeting_time = find_meeting_time(emily_busy, elizabeth_busy, days, work_hours, meeting_duration)\nprint(meeting_time.split()[1].replace('.', ':'))\n```",
            "count": "calendar_scheduling_example_941"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Days to consider: Tuesday, Friday (Monday and Thursday are excluded per Samuel's preference)\n    days = ['Tuesday', 'Friday']\n    \n    # Victoria's busy times in minutes since start of day\n    victoria_busy = {\n        'Tuesday': [\n            (10 * 60, 11 * 60),    # 10:00-11:00\n            (11 * 60 + 30, 13 * 60), # 11:30-13:00\n            (13 * 60 + 30, 14 * 60), # 13:30-14:00\n            (15 * 60 + 30, 16 * 60)  # 15:30-16:00\n        ],\n        'Friday': [\n            (11 * 60 + 30, 12 * 60), # 11:30-12:00\n            (12 * 60 + 30, 13 * 60), # 12:30-13:00\n            (15 * 60, 15 * 60 + 30)   # 15:00-15:30\n        ]\n    }\n    \n    # Samuel's busy times in minutes since start of day\n    samuel_busy = {\n        'Tuesday': [(9 * 60, 17 * 60)],  # 9:00-17:00 (entire day)\n        'Friday': [\n            (9 * 60, 12 * 60),          # 9:00-12:00\n            (12 * 60 + 30, 17 * 60)      # 12:30-17:00\n        ]\n    }\n    \n    # Check available slots on each day\n    for day in days:\n        # Get busy times for both participants\n        v_busy = victoria_busy.get(day, [])\n        s_busy = samuel_busy.get(day, [])\n        \n        # Merge and sort all busy intervals\n        all_busy = v_busy + s_busy\n        all_busy.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for 30-minute availability\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= 30:\n                # Convert back to HH:MM format\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_hh = (slot_start + 30) // 60\n                end_mm = (slot_start + 30) % 60\n                \n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No meeting time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_942"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(janice_busy, richard_busy, work_hours, duration):\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n    start_hour, end_hour = work_hours\n    \n    for day in days:\n        # Get busy slots for the day\n        janice_day = [slot for slot in janice_busy if slot[0] == day]\n        richard_day = [slot for slot in richard_busy if slot[0] == day]\n        \n        # Combine and sort all busy slots\n        busy_slots = janice_day + richard_day\n        busy_slots.sort(key=lambda x: x[1])\n        \n        # Initialize previous end time to start of work day\n        prev_end = start_hour * 60\n        \n        # Check gaps between busy slots\n        for slot in busy_slots:\n            slot_start = slot[1] * 60\n            if slot_start - prev_end >= duration:\n                # Found a gap\n                start_time = prev_end\n                end_time = start_time + duration\n                return f\"{int(start_time//60):02d}:{int(start_time%60):02d}:{int(end_time//60):02d}:{int(end_time%60):02d}\"\n            prev_end = max(prev_end, slot[2] * 60)\n        \n        # Check after last busy slot\n        if (end_hour * 60) - prev_end >= duration:\n            start_time = prev_end\n            end_time = start_time + duration\n            return f\"{int(start_time//60):02d}:{int(start_time%60):02d}:{int(end_time//60):02d}:{int(end_time%60):02d}\"\n    \n    return \"No meeting time found\"\n\n# Define busy slots for Janice and Richard\njanice_busy = [\n    ('Monday', 11.5, 12.0),\n    ('Tuesday', 9.5, 10.0),\n    ('Tuesday', 14.5, 15.0),\n    ('Wednesday', 11.0, 11.5),\n    ('Wednesday', 13.5, 14.0),\n    ('Thursday', 15.5, 16.0),\n    ('Friday', 13.5, 14.0),\n    ('Friday', 16.0, 16.5)\n]\n\nrichard_busy = [\n    ('Monday', 9.0, 10.5),\n    ('Monday', 12.5, 13.5),\n    ('Monday', 14.0, 14.5),\n    ('Monday', 15.0, 15.5),\n    ('Tuesday', 9.5, 10.0),\n    ('Tuesday', 10.5, 11.0),\n    ('Tuesday', 12.0, 13.0),\n    ('Tuesday', 14.0, 14.5),\n    ('Tuesday', 15.5, 16.0),\n    ('Tuesday', 16.5, 17.0),\n    ('Wednesday', 9.0, 12.0),\n    ('Wednesday', 13.0, 13.5),\n    ('Wednesday', 14.0, 16.0),\n    ('Thursday', 9.0, 10.0),\n    ('Thursday', 10.5, 11.5),\n    ('Thursday', 12.0, 12.5),\n    ('Thursday', 13.0, 14.5),\n    ('Thursday', 15.0, 15.5),\n    ('Thursday', 16.0, 17.0),\n    ('Friday', 9.0, 17.0)\n]\n\nwork_hours = (9.0, 17.0)\nduration = 30  # minutes\n\nprint(find_meeting_time(janice_busy, richard_busy, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_943"
        },
        {
            "final_program_time": "{12:30:13:30}",
            "expected_time": "{12:30:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n    \n    # Define busy slots for Joe and Denise in minutes since midnight\n    joe_busy = {\n        'Tuesday': [(9*60, 9*60+30), (10*60, 10*60+30), (11*60+30, 12*60+30),\n                   (13*60, 13*60+30), (14*60, 14*60+30), (15*60, 15*60+30),\n                   (16*60, 16*60+30)],\n        'Wednesday': [(9*60, 9*60+30), (10*60+30, 11*60), (11*60+30, 12*60),\n                     (12*60+30, 13*60), (15*60, 15*60+30)],\n        'Thursday': [(10*60+30, 11*60), (11*60+30, 12*60+30), (14*60+30, 15*60),\n                     (16*60+30, 17*60)],\n        'Friday': [(9*60, 10*60), (11*60+30, 12*60+30), (14*60+30, 15*60),\n                   (16*60, 16*60+30)]\n    }\n    \n    denise_busy = {\n        'Tuesday': [(9*60, 10*60), (10*60+30, 11*60), (11*60+30, 12*60),\n                    (12*60+30, 13*60), (14*60+30, 15*60+30), (16*60+30, 17*60)],\n        'Wednesday': [(9*60, 12*60), (12*60+30, 17*60)],\n        'Thursday': [(9*60, 11*60), (11*60+30, 12*60), (12*60+30, 13*60),\n                     (13*60+30, 17*60)],\n        'Friday': [(9*60, 12*60+30), (14*60, 15*60+30), (16*60, 17*60)]\n    }\n    \n    # Iterate through each day (excluding Monday)\n    for day in days[1:]:\n        # Collect all busy slots for both participants\n        busy_slots = []\n        if day in joe_busy:\n            busy_slots.extend(joe_busy[day])\n        if day in denise_busy:\n            busy_slots.extend(denise_busy[day])\n        \n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Find free slots by checking gaps between busy slots\n        previous_end = work_hours_start\n        for start, end in busy_slots:\n            if start > previous_end:\n                # Found a free slot\n                free_slot_start = previous_end\n                free_slot_end = start\n                if free_slot_end - free_slot_start >= 60:  # 1 hour duration\n                    # Format the time as HH:MM:HH:MM\n                    start_h = free_slot_start // 60\n                    start_m = free_slot_start % 60\n                    end_h = (free_slot_start + 60) // 60\n                    end_m = (free_slot_start + 60) % 60\n                    return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n            previous_end = max(previous_end, end)\n        \n        # Check after the last busy slot\n        if work_hours_end - previous_end >= 60:\n            start_h = previous_end // 60\n            start_m = previous_end % 60\n            end_h = (previous_end + 60) // 60\n            end_m = (previous_end + 60) % 60\n            return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_944"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to check (Monday to Friday)\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n\n    # Patricia's schedule (converted to minutes since midnight)\n    patricia_busy = {\n        'Monday': [(9 * 60, 10 * 60 + 30), (11 * 60, 13 * 60), (14 * 60, 14 * 60 + 30), (16 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60 + 30, 10 * 60), (12 * 60 + 30, 13 * 60), (15 * 60 + 30, 16 * 60)],\n        'Wednesday': [(10 * 60, 12 * 60), (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60), (15 * 60, 16 * 60)],\n        'Thursday': [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 11 * 60), (11 * 60 + 30, 12 * 60), \n                     (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 16 * 60 + 30)],\n        'Friday': [(11 * 60, 11 * 60 + 30), (15 * 60 + 30, 16 * 60)]\n    }\n\n    # Sharon's schedule (converted to minutes since midnight)\n    sharon_busy = {\n        'Monday': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (11 * 60, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Tuesday': [(9 * 60, 9 * 60 + 30), (10 * 60, 13 * 60 + 30), (14 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Thursday': [(9 * 60, 10 * 60 + 30), (11 * 60, 16 * 60 + 30)],\n        'Friday': [(9 * 60, 17 * 60)]\n    }\n\n    # Patricia cannot meet on Tuesday\n    days_to_check = [day for day in days if day != 'Tuesday']\n\n    for day in days_to_check:\n        # Combine both participants' busy times and sort\n        combined_busy = patricia_busy.get(day, []) + sharon_busy.get(day, [])\n        combined_busy.sort()\n\n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n\n        for start, end in combined_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n\n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= meeting_duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                # Convert back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No meeting time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_945"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n    \n    # Define Juan's busy times in minutes since midnight for each day\n    juan_busy = {\n        'Monday': [(11 * 60, 11 * 60 + 30)],\n        'Tuesday': [(11 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60 + 30), (15 * 60 + 30, 16 * 60)],\n        'Wednesday': [(14 * 60 + 30, 15 * 60)],\n        'Thursday': [(15 * 60 + 30, 16 * 60)],\n        'Friday': [(10 * 60 + 30, 11 * 60)]\n    }\n    \n    # Define Doris's busy times in minutes since midnight for each day\n    doris_busy = {\n        'Monday': [(9 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Wednesday': [(9 * 60, 9 * 60 + 30), (10 * 60, 12 * 60 + 30), (14 * 60, 14 * 60 + 30), (15 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Thursday': [(9 * 60 + 30, 13 * 60), (14 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Friday': [(9 * 60, 10 * 60), (10 * 60 + 30, 12 * 60), (13 * 60, 14 * 60 + 30), (15 * 60, 17 * 60)]\n    }\n    \n    # Doris's preferences to avoid Tuesday and Friday\n    preferred_days = ['Monday', 'Wednesday', 'Thursday']\n    \n    # Iterate through preferred days first, then others\n    for day in preferred_days + [d for d in days if d not in preferred_days]:\n        # Get busy intervals for both participants\n        juan_intervals = juan_busy.get(day, [])\n        doris_intervals = doris_busy.get(day, [])\n        \n        # Merge and sort all busy intervals\n        all_busy = juan_intervals + doris_intervals\n        all_busy.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_hours_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_hours_end:\n            free_slots.append((prev_end, work_hours_end))\n        \n        # Check each free slot for 30-minute availability\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= 30:\n                # Convert back to HH:MM format\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_hh = (slot_start + 30) // 60\n                end_mm = (slot_start + 30) % 60\n                \n                # Format as HH:MM:HH:MM\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_946"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n    \n    # Teresa's schedule: {day: [(start1, end1), (start2, end2), ...]}\n    teresa_schedule = {\n        'Monday': [(10 * 60, 10 * 60 + 30), (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60)],\n        'Tuesday': [(15 * 60, 16 * 60)],\n        'Wednesday': [(11 * 60 + 30, 12 * 60 + 30), (15 * 60 + 30, 16 * 60)],\n        'Thursday': [(10 * 60 + 30, 11 * 60 + 30)],\n        'Friday': [(10 * 60 + 30, 11 * 60), (12 * 60 + 30, 13 * 60)]\n    }\n    \n    # Keith's schedule: {day: [(start1, end1), (start2, end2), ...]}\n    keith_schedule = {\n        'Monday': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (11 * 60, 14 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Tuesday': [(9 * 60 + 30, 13 * 60), (13 * 60 + 30, 17 * 60)],\n        'Wednesday': [(9 * 60 + 30, 11 * 60), (11 * 60 + 30, 14 * 60 + 30), (15 * 60, 17 * 60)],\n        'Thursday': [(9 * 60, 12 * 60), (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 16 * 60 + 30)],\n        'Friday': [(9 * 60, 17 * 60)]\n    }\n    \n    # Duration in minutes\n    duration = 60\n    \n    for day in days:\n        # Collect all busy times for both participants on this day\n        busy_times = []\n        \n        # Add Teresa's busy times\n        for block in teresa_schedule.get(day, []):\n            busy_times.append(block)\n        \n        # Add Keith's busy times\n        for block in keith_schedule.get(day, []):\n            busy_times.append(block)\n        \n        # Sort busy times by start time\n        busy_times.sort()\n        \n        # Find available slots\n        prev_end = work_start\n        for start, end in busy_times:\n            if start > prev_end:\n                # Check if the slot is long enough\n                if start - prev_end >= duration:\n                    # Found a suitable slot\n                    start_time = prev_end\n                    end_time = start_time + duration\n                    return f\"{start_time // 60:02d}:{start_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after the last busy time\n        if work_end - prev_end >= duration:\n            start_time = prev_end\n            end_time = start_time + duration\n            return f\"{start_time // 60:02d}:{start_time % 60:02d}:{end_time // 60:02d}:{end_time % 60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_947"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n    \n    # Define Jordan's busy times in minutes since midnight\n    jordan_busy = {\n        'Monday': [(9 * 60 + 30, 10 * 60)],\n        'Thursday': [(12 * 60, 12 * 60 + 30)]\n    }\n    \n    # Define Michael's busy times in minutes since midnight\n    michael_busy = {\n        'Monday': [\n            (10 * 60, 11 * 60),\n            (11 * 60 + 30, 13 * 60),\n            (13 * 60 + 30, 16 * 60),\n            (16 * 60 + 30, 17 * 60)\n        ],\n        'Tuesday': [\n            (9 * 60 + 30, 10 * 60),\n            (10 * 60 + 30, 11 * 60),\n            (11 * 60 + 30, 12 * 60),\n            (12 * 60 + 30, 13 * 60),\n            (13 * 60 + 30, 14 * 60),\n            (15 * 60, 16 * 60),\n            (16 * 60 + 30, 17 * 60)\n        ],\n        'Wednesday': [\n            (9 * 60, 9 * 60 + 30),\n            (10 * 60, 16 * 60 + 30)\n        ],\n        'Thursday': [\n            (10 * 60, 10 * 60 + 30),\n            (11 * 60, 14 * 60 + 30),\n            (15 * 60, 15 * 60 + 30),\n            (16 * 60 + 30, 17 * 60)\n        ],\n        'Friday': [\n            (10 * 60 + 30, 11 * 60 + 30),\n            (12 * 60, 13 * 60 + 30),\n            (14 * 60, 15 * 60),\n            (15 * 60 + 30, 16 * 60 + 30)\n        ]\n    }\n    \n    # Iterate through each day to find the earliest available slot\n    for day in days:\n        # Collect all busy intervals for both participants\n        busy_intervals = []\n        \n        # Add Jordan's busy times for the day\n        if day in jordan_busy:\n            busy_intervals.extend(jordan_busy[day])\n        \n        # Add Michael's busy times for the day\n        if day in michael_busy:\n            busy_intervals.extend(michael_busy[day])\n        \n        # Sort all busy intervals by start time\n        busy_intervals.sort()\n        \n        # Check the time before the first busy interval\n        prev_end = work_hours_start\n        for interval in busy_intervals:\n            start, end = interval\n            if start > prev_end and (start - prev_end) >= 60:\n                # Found a suitable slot\n                meeting_start = prev_end\n                meeting_end = meeting_start + 60\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n            prev_end = max(prev_end, end)\n        \n        # Check the time after the last busy interval\n        if work_hours_end - prev_end >= 60:\n            meeting_start = prev_end\n            meeting_end = meeting_start + 60\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_948"
        }
    ]
}