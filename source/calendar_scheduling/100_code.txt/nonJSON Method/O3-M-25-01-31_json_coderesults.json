{
    "0shot": [
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\ndef time_to_minutes(t):\n    \"\"\"Convert time string HH:MM to minutes since midnight.\"\"\"\n    h, m = map(int, t.split(':'))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    \"\"\"Convert minutes since midnight to time string HH:MM.\"\"\"\n    return f\"{m // 60:02d}:{m % 60:02d}\"\n\n# Define workday boundaries and meeting duration in minutes\nwork_start = time_to_minutes(\"09:00\")\nwork_end   = time_to_minutes(\"17:00\")\nmeeting_duration = 60\n\n# Define each participant's blocked intervals as (start, end) in minutes.\n# Note: end time is considered non-inclusive; meeting ending exactly at a blocked start time is allowed.\nmichelle_busy = [(time_to_minutes(\"11:00\"), time_to_minutes(\"12:00\"))]\nsteven_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"13:30\"), time_to_minutes(\"14:00\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\"))\n]\njerry_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"11:00\")),\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"12:30\")),\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"14:30\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\")),\n    (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))\n]\n\n# All participants' busy schedules in a list for convenience\nall_busy = [michelle_busy, steven_busy, jerry_busy]\n\ndef is_available(start, busy_intervals):\n    \"\"\"Check if a meeting starting at 'start' (in minutes) for meeting_duration is free in the given busy_intervals.\"\"\"\n    meeting_end = start + meeting_duration\n    for bstart, bend in busy_intervals:\n        # Check if meeting overlaps with a busy interval.\n        # Overlap occurs if meeting starts before the busy period ends and finishes after the busy period starts.\n        if start < bend and meeting_end > bstart:\n            return False\n    return True\n\ndef find_meeting_time():\n    # Iterate over each possible minute for the meeting start time within work hours.\n    for start in range(work_start, work_end - meeting_duration + 1):\n        meeting_possible = True\n        for person_busy in all_busy:\n            if not is_available(start, person_busy):\n                meeting_possible = False\n                break\n        if meeting_possible:\n            meeting_start_str = minutes_to_time(start)\n            meeting_end_str = minutes_to_time(start + meeting_duration)\n            return f\"{{{meeting_start_str}:{meeting_end_str}}}\"\n    return None\n\nif __name__ == '__main__':\n    meeting_time = find_meeting_time()\n    if meeting_time:\n        print(meeting_time)\n    else:\n        print(\"No available meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_0"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\ndef time_to_minutes(t):\n    # t is a string in format \"HH:MM\"\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\n# Working hours for the day: 09:00 to 17:00\nWORK_START = time_to_minutes(\"09:00\")\nWORK_END = time_to_minutes(\"17:00\")\nMEETING_DURATION = 30  # minutes\n\n# Schedules for each participant represented as (start, end) in minutes since midnight.\nraymond_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n    (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\"))\n]\n\nbilly_busy = [\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))\n]\n\ndonald_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"11:00\")),\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"14:30\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"17:00\"))\n]\n\n# Billy prefers to avoid meetings after 15:00.\n# Therefore, we must ensure the meeting ends by 15:00.\nBILLY_PREFERRED_END = time_to_minutes(\"15:00\")\n\ndef invert_busy(busy, start, end):\n    \"\"\"Given a list of busy intervals (sorted by start time), return a list of free intervals within [start, end].\"\"\"\n    free = []\n    current = start\n    for b_start, b_end in sorted(busy):\n        if b_start > current:\n            free.append((current, b_start))\n        current = max(current, b_end)\n    if current < end:\n        free.append((current, end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Intersect two lists of intervals.\"\"\"\n    i, j = 0, 0\n    intersection = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # find overlap\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap < end_overlap:\n            intersection.append((start_overlap, end_overlap))\n        # move the pointer that finishes earlier\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\n# Calculate free intervals for each participant based on their busy schedules.\nraymond_free = invert_busy(raymond_busy, WORK_START, WORK_END)\nbilly_free = invert_busy(billy_busy, WORK_START, WORK_END)\ndonald_free = invert_busy(donald_busy, WORK_START, WORK_END)\n\n# Intersect free intervals across all participants.\ncommon_free = intersect_intervals(raymond_free, billy_free)\ncommon_free = intersect_intervals(common_free, donald_free)\n\n# Now search for a common free slot that can accommodate the meeting duration and meets Billy's preference.\nproposed_slot = None\nfor free_start, free_end in common_free:\n    # We need the meeting to finish by Billy's preferred end time if possible.\n    latest_end = min(free_end, BILLY_PREFERRED_END)\n    if free_start + MEETING_DURATION <= latest_end:\n        proposed_slot = (free_start, free_start + MEETING_DURATION)\n        break\n\nif proposed_slot:\n    start_time = minutes_to_time(proposed_slot[0])\n    end_time = minutes_to_time(proposed_slot[1])\n    # Output in the format HH:MM:HH:MM\n    print(f\"{{{start_time}:{end_time}}}\")\nelse:\n    print(\"No suitable meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_1"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_time(minutes):\n    \"\"\"Convert minutes past midnight to HH:MM string.\"\"\"\n    hour = minutes // 60\n    minute = minutes % 60\n    return f\"{hour:02d}:{minute:02d}\"\n\n# Define working hours in minutes\nwork_start = 9 * 60      # 540 minutes (9:00)\nwork_end = 17 * 60       # 1020 minutes (17:00)\n\n# Define meeting duration in minutes\nmeeting_duration = 30\n\n# Define each participant's busy intervals (start inclusive, end exclusive) in minutes\n# Roy's busy times: 9:00-9:30, 10:00-10:30, 11:00-11:30, 12:30-13:00.\nroy_busy = [(9*60, 9*60 + 30),\n            (10*60, 10*60 + 30),\n            (11*60, 11*60 + 30),\n            (12*60 + 30, 13*60)]\n\n# Kathryn's busy times: 9:30-10:00, 16:30-17:00.\nkathryn_busy = [(9*60 + 30, 10*60),\n                (16*60 + 30, 17*60)]\n\n# Amy's busy times: 9:00-14:30, 15:00-16:00, 16:30-17:00.\namy_busy = [(9*60, 14*60 + 30),\n            (15*60, 16*60),\n            (16*60 + 30, 17*60)]\n\n# Amy's preference: she would rather not meet after 15:30.\n# Hence, we require that the meeting ends by 15:30.\nlatest_meeting_end = 15 * 60 + 30  # 15:30 in minutes\nlatest_start = latest_meeting_end - meeting_duration  # meeting must start no later than this\n\ndef is_free(start, end, busy_times):\n    \"\"\"Return True if the interval [start, end) does not intersect with any busy interval.\"\"\"\n    for b_start, b_end in busy_times:\n        # Check if there is any overlap between [start, end) and [b_start, b_end)\n        if not (end <= b_start or start >= b_end):\n            return False\n    return True\n\n# Find a meeting time from work_start to latest_start\nmeeting_start = None\nfor start in range(work_start, latest_start + 1):\n    end = start + meeting_duration\n    if end > work_end:\n        break  # outside of work hours\n\n    # Check each participant's availability during [start, end)\n    if (is_free(start, end, roy_busy) and \n        is_free(start, end, kathryn_busy) and\n        is_free(start, end, amy_busy)):\n        meeting_start = start\n        break\n\nif meeting_start is not None:\n    meeting_end = meeting_start + meeting_duration\n    start_str = minutes_to_time(meeting_start)\n    end_str = minutes_to_time(meeting_end)\n    # Output in the format {HH:MM:HH:MM}\n    print(\"{\" + f\"{start_str}:{end_str}\" + \"}\")\nelse:\n    print(\"No available meeting slot found.\")\n'''",
            "count": "calendar_scheduling_example_2"
        },
        {
            "final_program_time": "{9:30:10:30}",
            "expected_time": "{9:30:10:30}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_time(m):\n    hours = m // 60\n    minutes = m % 60\n    return f\"{hours:02d}:{minutes:02d}\"\n\ndef subtract_busy(working, busies):\n    free = []\n    start_work, end_work = working\n    current = start_work\n    for b in sorted(busies, key=lambda x: x[0]):\n        busy_start, busy_end = b\n        if busy_start > current:\n            free.append((current, busy_start))\n        current = max(current, busy_end)\n    if current < end_work:\n        free.append((current, end_work))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    i, j = 0, 0\n    intersection = []\n    while i < len(intervals1) and j < len(intervals2):\n        a_start, a_end = intervals1[i]\n        b_start, b_end = intervals2[j]\n        start = max(a_start, b_start)\n        end = min(a_end, b_end)\n        if start < end:\n            intersection.append((start, end))\n        if a_end < b_end:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\n# Define working hours in minutes (9:00 to 17:00)\nworking_hours = (9 * 60, 17 * 60)\n\n# Define busy intervals for each participant in minutes:\n# Arthur: 9:00-9:30, 10:30-12:00, 16:00-17:00\narthur_busy = [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 12 * 60), (16 * 60, 17 * 60)]\n\n# Michael: 13:00-13:30, 14:00-14:30\nmichael_busy = [(13 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30)]\n\n# Samantha: 10:30-11:00, 12:00-15:00, 15:30-17:00\nsamantha_busy = [(10 * 60 + 30, 11 * 60), (12 * 60, 15 * 60), (15 * 60 + 30, 17 * 60)]\n\n# Calculate free intervals for each participant\narthur_free = subtract_busy(working_hours, arthur_busy)\nmichael_free = subtract_busy(working_hours, michael_busy)\nsamantha_free = subtract_busy(working_hours, samantha_busy)\n\n# Compute the common free intervals among all participants\ncommon_free = intersect_intervals(arthur_free, michael_free)\ncommon_free = intersect_intervals(common_free, samantha_free)\n\n# Meeting duration = 60 minutes\nmeeting_duration = 60\n\nproposed_time = None\nfor interval in common_free:\n    start, end = interval\n    if end - start >= meeting_duration:\n        proposed_time = (start, start + meeting_duration)\n        break\n\nif proposed_time:\n    start_str = minutes_to_time(proposed_time[0])\n    end_str = minutes_to_time(proposed_time[1])\n    print(f\"{{{start_str}:{end_str}}}\")\nelse:\n    print(\"No available time slot found\")\n'''",
            "count": "calendar_scheduling_example_3"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef get_free_intervals(busy, work_start, work_end):\n    free = []\n    current = work_start\n    for interval in busy:\n        start_busy, end_busy = interval\n        if start_busy > current:\n            free.append((current, start_busy))\n        current = max(current, end_busy)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    intersection = []\n    i, j = 0, 0\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        start_int = max(start1, start2)\n        end_int = min(end1, end2)\n        if start_int < end_int:\n            intersection.append((start_int, end_int))\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\ndef find_meeting_slot(common_free, duration):\n    for start, end in common_free:\n        if end - start >= duration:\n            return start, start + duration\n    return None\n\nif __name__ == \"__main__\":\n    meeting_duration = 30  # in minutes\n    work_start = time_to_minutes(\"09:00\")\n    work_end = time_to_minutes(\"17:00\")\n    \n    # Busy intervals provided in HH:MM format for each participant\n    donna_busy_times = [(\"14:00\", \"14:30\"), (\"15:30\", \"16:00\")]\n    john_busy_times = [(\"11:00\", \"11:30\"), (\"16:30\", \"17:00\")]\n    billy_busy_times = [(\"09:00\", \"10:00\"), (\"10:30\", \"14:00\"), (\"14:30\", \"17:00\")]\n    \n    # Convert busy times to minutes\n    donna_busy = [(time_to_minutes(s), time_to_minutes(e)) for s, e in donna_busy_times]\n    john_busy = [(time_to_minutes(s), time_to_minutes(e)) for s, e in john_busy_times]\n    billy_busy = [(time_to_minutes(s), time_to_minutes(e)) for s, e in billy_busy_times]\n    \n    # Calculate free intervals for each participant over the work day\n    donna_free = get_free_intervals(donna_busy, work_start, work_end)\n    john_free = get_free_intervals(john_busy, work_start, work_end)\n    billy_free = get_free_intervals(billy_busy, work_start, work_end)\n    \n    # Intersect free intervals among all participants\n    common_free = intersect_intervals(donna_free, john_free)\n    common_free = intersect_intervals(common_free, billy_free)\n    \n    slot = find_meeting_slot(common_free, meeting_duration)\n    if slot:\n        start_time = minutes_to_time(slot[0])\n        end_time = minutes_to_time(slot[1])\n        print(f\"{{{start_time}:{end_time}}}\")\n    else:\n        print(\"No available meeting slot found.\")\n'''",
            "count": "calendar_scheduling_example_4"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_time(m):\n    hours = m // 60\n    minutes = m % 60\n    return f\"{hours:02d}:{minutes:02d}\"\n\ndef intersect_intervals(intervals1, intervals2):\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find the overlap\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap < end_overlap:\n            result.append((start_overlap, end_overlap))\n        # Move the pointer which has the earlier ending\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Meeting duration in minutes\nduration = 30\n\n# For simplicity, convert times to minutes from midnight.\n# Work hours for Monday: 9:00 (540) to 17:00 (1020)\n# However, Charlotte does not want meetings after 13:30 (810).\n# So we restrict our search to the interval [540, 810]\n\n# Kathryn's free intervals (in minutes)\n# Blocked: 9:00-9:30 (540-570), 10:30-11:00 (630-660), 11:30-12:00 (690-720),\n#          13:30-14:30 (810-870), 16:30-17:00 (990-1020)\n# Work hours: 540-1020, so free intervals:\nkathryn_free = [(570, 630), (660, 690), (720, 810), (870, 990)]\n\n# Charlotte's free intervals (in minutes)\n# Blocked: 12:00-12:30 (720-750), 16:00-16:30 (960-990)\n# Also, Charlotte does not want any meeting after 13:30 (810).\n# From work hours 540-1020, her free intervals are:\ncharlotte_free = [(540, 720), (750, 1020)]\n# Now restrict to before 13:30 --> intersect with [540, 810]\ncharlotte_free = intersect_intervals(charlotte_free, [(540, 810)])\n\n# Lauren's free intervals (in minutes)\n# Blocked: 9:00-10:00 (540-600), 12:00-12:30 (720-750), 13:30-14:30 (810-870),\n#          15:00-16:00 (900-960), 16:30-17:00 (990-1020)\n# From work hours 540-1020, her free intervals:\nlauren_free = [(600, 720), (750, 810), (870, 900), (960, 990)]\n# Restrict to before 13:30 since Charlotte is only available until then:\nlauren_free = intersect_intervals(lauren_free, [(540, 810)])\n\n# Also restrict Kathryn's free intervals to before 13:30:\nkathryn_free = intersect_intervals(kathryn_free, [(540, 810)])\n\n# Now compute common free intervals among all three\ncommon_free = intersect_intervals(kathryn_free, charlotte_free)\ncommon_free = intersect_intervals(common_free, lauren_free)\n\n# Find a common interval that can accommodate the meeting duration\nproposed_meeting = None\nfor start, end in common_free:\n    if end - start >= duration:\n        proposed_meeting = (start, start + duration)\n        break\n\nif proposed_meeting:\n    start_time = minutes_to_time(proposed_meeting[0])\n    end_time = minutes_to_time(proposed_meeting[1])\n    print(f\"{start_time}:{end_time}\")\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_5"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\ndef to_minutes(time_str):\n    \"\"\"Converts HH:MM to minutes since 00:00.\"\"\"\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef to_timestr(minutes):\n    \"\"\"Converts minutes since 00:00 to HH:MM string.\"\"\"\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Meeting parameters\nwork_start = to_minutes(\"09:00\")\nwork_end   = to_minutes(\"17:00\")\nmeeting_duration = 60  # in minutes\n\n# Busy intervals for each participant (start and end in minutes from midnight)\n# Thomas: free entire day -> no blocks.\n# Dylan's busy intervals.\ndylan_busy = [\n    (to_minutes(\"10:30\"), to_minutes(\"11:00\")),\n    (to_minutes(\"13:30\"), to_minutes(\"14:00\"))\n]\n\n# Jerry's busy intervals.\njerry_busy = [\n    (to_minutes(\"09:00\"), to_minutes(\"11:00\")),\n    (to_minutes(\"11:30\"), to_minutes(\"14:30\")),\n    (to_minutes(\"16:00\"), to_minutes(\"17:00\"))\n]\n\ndef invert_busy(busy, day_start, day_end):\n    \"\"\"Given busy intervals sorted by start time, returns free intervals in [day_start, day_end].\"\"\"\n    free_intervals = []\n    current_start = day_start\n    for b_start, b_end in sorted(busy):\n        if current_start < b_start:\n            free_intervals.append((current_start, b_start))\n        current_start = max(current_start, b_end)\n    if current_start < day_end:\n        free_intervals.append((current_start, day_end))\n    return free_intervals\n\n# Thomas free intervals = whole workday\nthomas_free = [(work_start, work_end)]\ndylan_free = invert_busy(dylan_busy, work_start, work_end)\njerry_free = invert_busy(jerry_busy, work_start, work_end)\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Intersect two lists of intervals.\"\"\"\n    intersection = []\n    i, j = 0, 0\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        inter_start = max(start1, start2)\n        inter_end = min(end1, end2)\n        if inter_start < inter_end:\n            intersection.append((inter_start, inter_end))\n        if end1 <= end2:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\n# Calculate the common free intervals for all participants:\ncommon_free = intersect_intervals(thomas_free, dylan_free)\ncommon_free = intersect_intervals(common_free, jerry_free)\n\n# Find the first interval that can accommodate a meeting_duration meeting\nmeeting_start = None\nfor interval in common_free:\n    start, end = interval\n    if end - start >= meeting_duration:\n        meeting_start = start\n        break\n\nif meeting_start is not None:\n    meeting_end = meeting_start + meeting_duration\n    # Output time in format HH:MM:HH:MM\n    print(f\"{to_timestr(meeting_start)}:{to_timestr(meeting_end)}\")\nelse:\n    print(\"No available meeting time\")\n'''",
            "count": "calendar_scheduling_example_6"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\n# Helper function to convert \"HH:MM\" to minutes since midnight\ndef time_to_minutes(t):\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\n# Helper function to convert minutes since midnight to \"HH:MM\"\ndef minutes_to_time(m):\n    return f\"{m//60:02d}:{m%60:02d}\"\n\n# Function to compute free intervals from busy intervals within work hours.\ndef compute_free_intervals(busy, work_start, work_end):\n    # Sort busy intervals by start time.\n    busy = sorted(busy, key=lambda x: x[0])\n    free = []\n    current_start = work_start\n    for start, end in busy:\n        if start > current_start:\n            free.append((current_start, start))\n        current_start = max(current_start, end)\n    if current_start < work_end:\n        free.append((current_start, work_end))\n    return free\n\n# Function to compute intersection of two lists of intervals.\ndef intersect_intervals(intervals1, intervals2):\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        start = max(start1, start2)\n        end = min(end1, end2)\n        if start < end:\n            result.append((start, end))\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Work day hours in minutes (9:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Meeting duration in minutes (30 minutes)\nmeeting_duration = 30\n\n# Busy intervals for each participant in minutes (start, end)\n# Heather: 9:00-9:30, 10:30-11:00, 13:00-14:00, 14:30-15:00, 16:00-16:30\nheather_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"14:00\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))\n]\n\n# Nicholas has no meetings.\nnicholas_busy = []\n\n# Zachary: 9:00-10:30, 11:00-12:00, 12:30-13:00, 13:30-16:30\nzachary_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"13:30\"), time_to_minutes(\"16:30\"))\n]\n\n# Compute free intervals for each participant\nheather_free = compute_free_intervals(heather_busy, work_start, work_end)\nnicholas_free = compute_free_intervals(nicholas_busy, work_start, work_end)\nzachary_free = compute_free_intervals(zachary_busy, work_start, work_end)\n\n# Intersect free intervals for all participants\nfree_all = intersect_intervals(heather_free, nicholas_free)\nfree_all = intersect_intervals(free_all, zachary_free)\n\n# Zachary's preference: meeting should end by 14:00.\nlatest_end_for_zachary = time_to_minutes(\"14:00\")\n\nmeeting_slot = None\nfor start, end in free_all:\n    # Ensure the slot has enough duration and also meets Zachary's preference.\n    # We need meeting start + duration <= min(end, latest_end_for_zachary)\n    possible_latest_end = min(end, latest_end_for_zachary)\n    if start + meeting_duration <= possible_latest_end:\n        meeting_slot = (start, start + meeting_duration)\n        break\n\nif meeting_slot:\n    start_time = minutes_to_time(meeting_slot[0])\n    end_time = minutes_to_time(meeting_slot[1])\n    print(f\"{start_time}:{end_time}\")\nelse:\n    print(\"No available slot found\")\n'''",
            "count": "calendar_scheduling_example_7"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "'''python\ndef to_minutes(time_str):\n    # Convert \"HH:MM\" to minutes since midnight\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef to_hhmm(minutes):\n    # Convert minutes since midnight to \"HH:MM\" format (zero padded)\n    return f\"{minutes//60:02d}:{minutes%60:02d}\"\n\ndef interval_intersection(interval1, interval2):\n    # Given two intervals (start, end) return their intersection or None\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start < end:\n        return (start, end)\n    return None\n\ndef intersect_intervals(list1, list2):\n    # Given two lists of intervals, return intersection intervals.\n    result = []\n    i, j = 0, 0\n    while i < len(list1) and j < len(list2):\n        inter = interval_intersection(list1[i], list2[j])\n        if inter:\n            result.append(inter)\n        # Move to the next interval which finishes earlier\n        if list1[i][1] < list2[j][1]:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Define work hours in minutes (9:00 to 17:00)\nwork_start = to_minutes(\"09:00\")\nwork_end = to_minutes(\"17:00\")\nwork_interval = [(work_start, work_end)]\n\n# Pre-defined blocked schedules (from the task)\n# Adam's meetings on Monday: 10:00-10:30, 12:30-13:00, 13:30-14:30.\nadam_blocked = [(to_minutes(\"10:00\"), to_minutes(\"10:30\")),\n                (to_minutes(\"12:30\"), to_minutes(\"13:00\")),\n                (to_minutes(\"13:30\"), to_minutes(\"14:30\"))]\n\n# Jerry's meetings on Monday: 9:00-9:30, 12:00-12:30, 15:00-16:00.\njerry_blocked = [(to_minutes(\"09:00\"), to_minutes(\"09:30\")),\n                 (to_minutes(\"12:00\"), to_minutes(\"12:30\")),\n                 (to_minutes(\"15:00\"), to_minutes(\"16:00\"))]\n\n# Matthew's meetings on Monday: 9:30-11:00, 11:30-12:30, 13:00-14:00, 14:30-17:00.\nmatthew_blocked = [(to_minutes(\"09:30\"), to_minutes(\"11:00\")),\n                   (to_minutes(\"11:30\"), to_minutes(\"12:30\")),\n                   (to_minutes(\"13:00\"), to_minutes(\"14:00\")),\n                   (to_minutes(\"14:30\"), to_minutes(\"17:00\"))]\n\ndef get_free_intervals(blocked, work_interval):\n    free = []\n    for (ws, we) in work_interval:\n        current = ws\n        for start, end in sorted(blocked):\n            if current < start:\n                free.append((current, start))\n            current = max(current, end)\n        if current < we:\n            free.append((current, we))\n    return free\n\n# Get free intervals for each participant\nadam_free = get_free_intervals(adam_blocked, work_interval)\njerry_free = get_free_intervals(jerry_blocked, work_interval)\nmatthew_free = get_free_intervals(matthew_blocked, work_interval)\n\n# Find common free intervals among all three by intersecting intervals lists\ncommon_free = intersect_intervals(adam_free, jerry_free)\ncommon_free = intersect_intervals(common_free, matthew_free)\n\nmeeting_duration = 30  # minutes\n\nmeeting_time = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        meeting_time = (start, start + meeting_duration)\n        break\n\nif meeting_time:\n    start_str = to_hhmm(meeting_time[0])\n    end_str = to_hhmm(meeting_time[1])\n    print(f\"{start_str}:{end_str}\")\nelse:\n    print(\"No common meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_8"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02}:{mins:02}\"\n\n# Define work hours and meeting duration in minutes\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nmeeting_duration = 30\n\n# Busy intervals for each participant, represented as (start, end) in minutes\ndiane_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"15:30\"))\n]\n\nkelly_busy = [\n    (time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\"))\n]\n\ndeborah_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"14:00\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"17:00\"))\n]\n\n# Function to compute free intervals within work hours based on busy periods\ndef compute_free_intervals(busy_intervals):\n    busy_intervals.sort(key=lambda interval: interval[0])\n    free_intervals = []\n    current_time = work_start\n    for start, end in busy_intervals:\n        if start > current_time:\n            free_intervals.append((current_time, start))\n        current_time = max(current_time, end)\n    if current_time < work_end:\n        free_intervals.append((current_time, work_end))\n    return free_intervals\n\ndiane_free = compute_free_intervals(diane_busy)\nkelly_free = compute_free_intervals(kelly_busy)\ndeborah_free = compute_free_intervals(deborah_busy)\n\n# Function to get intersections between two lists of intervals\ndef intersect_intervals(intervals1, intervals2):\n    i, j = 0, 0\n    intersections = []\n    while i < len(intervals1) and j < len(intervals2):\n        start = max(intervals1[i][0], intervals2[j][0])\n        end = min(intervals1[i][1], intervals2[j][1])\n        if start + meeting_duration <= end:\n            intersections.append((start, end))\n        if intervals1[i][1] < intervals2[j][1]:\n            i += 1\n        else:\n            j += 1\n    return intersections\n\n# Find common free intervals among all participants\ncommon_free = intersect_intervals(diane_free, kelly_free)\ncommon_free = intersect_intervals(common_free, deborah_free)\n\n# Select the first interval that can accommodate the meeting duration\nmeeting_time = None\nfor start, end in common_free:\n    if start + meeting_duration <= end:\n        meeting_start = start\n        meeting_end = start + meeting_duration\n        meeting_time = f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n        break\n\nif meeting_time:\n    print(meeting_time)\nelse:\n    print(\"No common free slot available.\")\n'''",
            "count": "calendar_scheduling_example_9"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\n# Helper function to convert datetime to a time string (HH:MM)\ndef format_time(dt):\n    return dt.strftime(\"%H:%M\")\n\n# Define meeting duration (30 minutes)\nmeeting_duration = timedelta(minutes=30)\n\n# Use an arbitrary base date (e.g., January 1, 2020)\nbase_date = datetime(2020, 1, 1)\n\ndef dt(hour, minute):\n    return datetime.combine(base_date.date(), datetime.strptime(f\"{hour}:{minute}\", \"%H:%M\").time())\n\n# Define the work hours: from 9:00 to 17:00\nwork_start = dt(9, 0)\nwork_end = dt(17, 0)\n\n# Participant schedules on Monday:\n# Diana's busy slots\ndiana_busy = [\n    (dt(11, 30), dt(12, 0)),\n    (dt(13, 0), dt(13, 30))\n]\n# Janet's busy slots and meeting constraint (won't do meeting after 12:00)\njanet_busy = [\n    (dt(9, 0), dt(10, 0)),\n    (dt(12, 30), dt(13, 0)),\n    (dt(14, 0), dt(15, 0)),\n    (dt(15, 30), work_end)\n]\n# Ethan is free the whole day\nethan_busy = []  # No busy slots for Ethan\n\n# Janet's additional constraint: meeting must be scheduled before 12:00.\njanet_meeting_deadline = dt(12, 0)\n\n# A function to compute free intervals from busy intervals within given bounds\ndef compute_free_intervals(busy, start, end):\n    free_intervals = []\n    current = start\n    # Sort busy intervals by start time\n    for b_start, b_end in sorted(busy, key=lambda x: x[0]):\n        if current < b_start:\n            free_intervals.append((current, b_start))\n        current = max(current, b_end)\n    if current < end:\n        free_intervals.append((current, end))\n    return free_intervals\n\n# Compute each participant's free intervals within work hours \n# For Janet, cap the available time at 12:00 due to her constraint.\ndiana_free = compute_free_intervals(diana_busy, work_start, work_end)\njanet_free = compute_free_intervals(janet_busy, work_start, janet_meeting_deadline)\nethan_free = compute_free_intervals(ethan_busy, work_start, work_end)\n\n# A function that finds the intersection of two lists of intervals\ndef intersect_intervals(intervals1, intervals2):\n    result = []\n    i, j = 0, 0\n    while i < len(intervals1) and j < len(intervals2):\n        start = max(intervals1[i][0], intervals2[j][0])\n        end = min(intervals1[i][1], intervals2[j][1])\n        if end - start >= meeting_duration:\n            result.append((start, end))\n        # Move to the next interval in the list that ends earlier\n        if intervals1[i][1] < intervals2[j][1]:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Find common free intervals for everyone\ncommon_free = intersect_intervals(diana_free, janet_free)\ncommon_free = intersect_intervals(common_free, ethan_free)\n\n# Select the first interval where a 30-minute meeting can be scheduled\nmeeting_slot = None\nfor start, end in common_free:\n    if start + meeting_duration <= end:\n        meeting_slot = (start, start + meeting_duration)\n        break\n\nif meeting_slot:\n    print(f\"{format_time(meeting_slot[0])}:{format_time(meeting_slot[1])}\")\nelse:\n    print(\"No available slot found\")\n'''",
            "count": "calendar_scheduling_example_10"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\n# Helper function to convert time string HH:MM to minutes since 00:00\ndef time_to_minutes(t):\n    h, m = map(int, t.split(':'))\n    return h * 60 + m\n\n# Helper function to convert minutes since 00:00 to time string HH:MM\ndef minutes_to_time(m):\n    return \"{:02d}:{:02d}\".format(m // 60, m % 60)\n\n# Function to compute free intervals given busy intervals and work boundaries\n# busy_intervals: list of tuples (start, end) in minutes, non-overlapping and sorted.\ndef compute_free_intervals(busy_intervals, work_start, work_end):\n    free = []\n    current = work_start\n    for b_start, b_end in busy_intervals:\n        if current < b_start:\n            free.append((current, b_start))\n        current = max(current, b_end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\n# Function to compute intersection of two lists of intervals\ndef intersect_intervals(int1, int2):\n    i, j = 0, 0\n    intersection = []\n    while i < len(int1) and j < len(int2):\n        start = max(int1[i][0], int2[j][0])\n        end = min(int1[i][1], int2[j][1])\n        if start < end:\n            intersection.append((start, end))\n        # Move to next interval from the one that finishes first\n        if int1[i][1] < int2[j][1]:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\n# Meeting parameters\nmeeting_duration = 30  # minutes\n\n# Work day boundaries (9:00 to 17:00) in minutes\nwork_start = time_to_minutes(\"09:00\")\nwork_end   = time_to_minutes(\"17:00\")\n\n# Busy schedules for each participant (times are in minutes since midnight)\n# Alexander busy intervals:\nalex_busy = [\n    (time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n    (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"17:00\"))\n]\n\n# Elizabeth busy intervals:\neliz_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"12:30\")),\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"14:30\"))\n]\n\n# Walter busy intervals:\nwalter_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"14:30\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"17:00\"))\n]\n\n# Compute free intervals for each participant\nalex_free = compute_free_intervals(alex_busy, work_start, work_end)\neliz_free = compute_free_intervals(eliz_busy, work_start, work_end)\nwalter_free = compute_free_intervals(walter_busy, work_start, work_end)\n\n# Compute common free intervals by intersecting all free intervals\ncommon_free = intersect_intervals(alex_free, eliz_free)\ncommon_free = intersect_intervals(common_free, walter_free)\n\n# Find the first time slot that is at least meeting_duration long\nmeeting_start = None\nmeeting_end = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        meeting_start = start\n        meeting_end = start + meeting_duration\n        break\n\nif meeting_start is not None:\n    # Output in the required format: {HH:MM:HH:MM}\n    output = f\"{{{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}}}\"\n    print(output)\nelse:\n    print(\"No available meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_11"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    \"\"\"Converts a time string 'HH:MM' to minutes from midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    \"\"\"Converts minutes from midnight to a time string 'HH:MM'.\"\"\"\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\ndef get_free_intervals(busy_intervals, work_start, work_end):\n    \"\"\"\n    Given a list of busy intervals (each as a tuple (start, end) in minutes),\n    returns a list of free intervals within work_start and work_end.\n    \"\"\"\n    free_intervals = []\n    current_start = work_start\n    # Assumed that busy_intervals are sorted by start time.\n    for start, end in busy_intervals:\n        if start > current_start:\n            free_intervals.append((current_start, start))\n        current_start = max(current_start, end)\n    if current_start < work_end:\n        free_intervals.append((current_start, work_end))\n    return free_intervals\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"\n    Given two lists of intervals, returns the intersection intervals.\n    Each interval is a tuple (start, end).\n    \"\"\"\n    i, j = 0, 0\n    intersections = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find the intersection between intervals\n        start_inter = max(start1, start2)\n        end_inter = min(end1, end2)\n        if start_inter < end_inter:\n            intersections.append((start_inter, end_inter))\n        # Move to the next interval in the list that ends first\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersections\n\ndef schedule_meeting():\n    # Work day bounds in minutes (9:00 to 17:00)\n    work_start = time_to_minutes(\"09:00\")\n    work_end = time_to_minutes(\"17:00\")\n    meeting_duration = 60  # in minutes\n    \n    # Participant schedules (busy intervals)\n    # David has no meetings.\n    busy_david = []\n    \n    # Debra's meetings on Monday (given in format 'HH:MM')\n    busy_debra = [\n        (time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n        (time_to_minutes(\"11:00\"), time_to_minutes(\"11:30\")),\n        (time_to_minutes(\"12:00\"), time_to_minutes(\"13:00\")),\n        (time_to_minutes(\"14:00\"), time_to_minutes(\"14:30\")),\n        (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\")),\n    ]\n    \n    # Kevin's meetings on Monday (given in format 'HH:MM')\n    busy_kevin = [\n        (time_to_minutes(\"09:00\"), time_to_minutes(\"12:00\")),\n        (time_to_minutes(\"14:00\"), time_to_minutes(\"17:00\")),\n    ]\n    \n    # Calculate free intervals for each\n    free_david = [(work_start, work_end)]  # David is free the entire day.\n    free_debra = get_free_intervals(busy_debra, work_start, work_end)\n    free_kevin = get_free_intervals(busy_kevin, work_start, work_end)\n    \n    # Intersect free times. We need common free slots where all participants are free.\n    # First, intersect Debra and Kevin's free intervals.\n    common_free = intersect_intervals(free_debra, free_kevin)\n    # David is free all day so the common free interval remains unchanged.\n    \n    # Find the earliest interval where meeting_duration fits.\n    for start, end in common_free:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Output the result in the format HH:MM:HH:MM\n            print(f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\")\n            return\n\n# Execute the meeting scheduling function\nif __name__ == \"__main__\":\n    schedule_meeting()'''",
            "count": "calendar_scheduling_example_12"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Define work day boundaries in minutes (9:00 to 17:00)\nwork_start = 9 * 60     # 540\nwork_end = 17 * 60      # 1020\n\n# Meeting duration in minutes (30 minutes)\nmeeting_duration = 30\n\n# Busy intervals for each participant in minutes\n# Format: (start_in_minutes, end_in_minutes)\n# Gerald's busy intervals and his preference: avoid meetings before 13:00 (13:00 = 780 minutes)\ngerald_busy = [(9 * 60, 9 * 60 + 30), (13 * 60, 14 * 60), (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)]\n# Adjust Gerald's work start based on preference (only consider time slots starting at or after 13:00)\ngerald_avail_start = max(work_start, 13 * 60)  # 780\n\nbarbara_busy = [(9 * 60 + 30, 10 * 60), (11 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 17 * 60)]\n# Roy is free the entire day, so no busy intervals.\nroy_busy = []\n\ndef invert_busy(busy, start, end):\n    \"\"\"Given busy intervals and a time range [start, end], return free intervals.\"\"\"\n    free = []\n    current = start\n    for bstart, bend in sorted(busy, key=lambda x: x[0]):\n        if bstart > current:\n            free.append((current, bstart))\n        current = max(current, bend)\n    if current < end:\n        free.append((current, end))\n    return free\n\n# Compute free intervals within work hours\ngerald_free = invert_busy([b for b in gerald_busy if b[0] < work_end and b[1] > gerald_avail_start], gerald_avail_start, work_end)\nbarbara_free = invert_busy(barbara_busy, work_start, work_end)\nroy_free = [(work_start, work_end)]  # Roy is free the entire work day\n\ndef intersect_intervals(intv1, intv2):\n    \"\"\"Return intersection of two lists of intervals.\"\"\"\n    i, j = 0, 0\n    intersection = []\n    while i < len(intv1) and j < len(intv2):\n        start = max(intv1[i][0], intv2[j][0])\n        end = min(intv1[i][1], intv2[j][1])\n        if start + meeting_duration <= end:  # room for meeting_duration\n            intersection.append((start, end))\n        # Move the pointer that ends earlier\n        if intv1[i][1] < intv2[j][1]:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\n# Intersect free intervals for all participants\ncommon_free = intersect_intervals(gerald_free, barbara_free)\ncommon_free = intersect_intervals(common_free, roy_free)\n\n# Find the first slot where a meeting can fit\nmeeting_time = None\nfor interval in common_free:\n    start, end = interval\n    if start + meeting_duration <= end:\n        meeting_time = (start, start + meeting_duration)\n        break\n\nif meeting_time:\n    start_time = minutes_to_time(meeting_time[0])\n    end_time = minutes_to_time(meeting_time[1])\n    # Output in the format HH:MM:HH:MM enclosed by curly braces\n    print(f\"{{{start_time}:{end_time}}}\")\nelse:\n    print(\"No available slot found.\")\n'''",
            "count": "calendar_scheduling_example_13"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    \"\"\"Convert HH:MM string to minutes since midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    \"\"\"Convert minutes since midnight to HH:MM string.\"\"\"\n    return f\"{minutes//60:02d}:{minutes%60:02d}\"\n\n# Define working hours in minutes\nwork_start = time_to_minutes(\"09:00\")\nwork_end   = time_to_minutes(\"17:00\")\nmeeting_duration = 30\n\n# Define busy intervals for each participant in (start, end) in minutes.\n# Brandon has meetings on Monday during 13:00-14:00, 15:30-16:00, 16:30-17:00.\n# He would like to avoid additional meetings on Monday before 14:30, so we add a blocking interval.\nbrandon_busy = [\n    (work_start, time_to_minutes(\"14:30\")),  # Preference: avoid meetings before 14:30\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\")),\n    (time_to_minutes(\"16:30\"), work_end)\n]\n\n# Jerry has no meetings the whole day.\njerry_busy = []  # free all day\n\n# Bradley has meetings during 9:00-11:30, 12:00-15:00, 16:00-16:30.\nbradley_busy = [\n    (work_start, time_to_minutes(\"11:30\")),\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))\n]\n\ndef invert_busy(busy_list):\n    \"\"\"Given a list of busy intervals within work hours, return a list of free intervals.\"\"\"\n    free_intervals = []\n    current_start = work_start\n    for interval in sorted(busy_list, key=lambda x: x[0]):\n        b_start, b_end = interval\n        if current_start < b_start:\n            free_intervals.append((current_start, b_start))\n        current_start = max(current_start, b_end)\n    if current_start < work_end:\n        free_intervals.append((current_start, work_end))\n    return free_intervals\n\n# Calculate free intervals for each participant.\nbrandon_free = invert_busy(brandon_busy)\njerry_free   = [(work_start, work_end)]  # whole day free\nbradley_free = invert_busy(bradley_busy)\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Intersect two lists of intervals.\"\"\"\n    i, j = 0, 0\n    intersection = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        start_max = max(start1, start2)\n        end_min   = min(end1, end2)\n        if start_max < end_min:\n            intersection.append((start_max, end_min))\n        # move to the next interval in the list with the earlier end time\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\n# Intersect the free intervals for all participants.\ncommon_free = intersect_intervals(brandon_free, jerry_free)\ncommon_free = intersect_intervals(common_free, bradley_free)\n\n# Find an interval that can accommodate the meeting duration.\nproposed_meeting = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        proposed_meeting = (start, start + meeting_duration)\n        break\n\nif proposed_meeting:\n    start_time = minutes_to_time(proposed_meeting[0])\n    end_time = minutes_to_time(proposed_meeting[1])\n    # Output in the format {HH:MM:HH:MM}\n    print(f\"{{{start_time}:{end_time}}}\")\nelse:\n    print(\"No available slot found.\")\n'''",
            "count": "calendar_scheduling_example_14"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    \"\"\"Convert time in 'HH:MM' format to minutes since midnight.\"\"\"\n    h, m = map(int, t.split(':'))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    \"\"\"Convert minutes since midnight to 'HH:MM' format.\"\"\"\n    h = m // 60\n    minutes = m % 60\n    return f\"{h:02d}:{minutes:02d}\"\n\ndef subtract_busy_times(free, busy):\n    \"\"\"Subtract busy intervals from a list of free intervals.\n       Both free and busy intervals are lists of (start, end) in minutes.\n    \"\"\"\n    result = []\n    for f_start, f_end in free:\n        current_start = f_start\n        for b_start, b_end in busy:\n            # If busy slot is completely before or after the free segment, skip it.\n            if b_end <= current_start or b_start >= f_end:\n                continue\n            # If there's a gap between current_start and the busy start, add it.\n            if b_start > current_start:\n                result.append((current_start, b_start))\n            # Move the current start to the end of the busy slot if needed.\n            current_start = max(current_start, b_end)\n        # Add the last available segment if any remains.\n        if current_start < f_end:\n            result.append((current_start, f_end))\n    return result\n\ndef intersect_intervals(list1, list2):\n    \"\"\"Compute intersection of two lists of intervals.\n       Each interval is a tuple (start, end) in minutes.\n    \"\"\"\n    result = []\n    for s1, e1 in list1:\n        for s2, e2 in list2:\n            start = max(s1, s2)\n            end = min(e1, e2)\n            if start + meeting_duration <= end:\n                result.append((start, end))\n    return result\n\n# Meeting duration in minutes\nmeeting_duration = 30\n\n# Workday start and end in minutes (9:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Constraint: Christine cannot meet before 12:00 on Monday.\nconstraint_start = time_to_minutes(\"12:00\")\n# Effective work start for Christine is the later of work_start and constraint_start.\neffective_start = max(work_start, constraint_start)\n\n# Base available interval for everyone initially is the workday, but for Christine it's starting at 12:00.\nbase_interval = [(effective_start, work_end)]\n\n# Define busy intervals for each participant in minutes.\njoyce_busy = [\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"11:30\")),\n    (time_to_minutes(\"13:30\"), time_to_minutes(\"14:00\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"16:30\"))\n]\n# For Joyce, her base day is still 9:00-17:00, but we only consider times after 12:00 because of Christine.\njoyce_available = subtract_busy_times([(work_start, work_end)], joyce_busy)\n# Intersect Joyce's availability with the constraint [12:00, 17:00]\njoyce_available = [(max(start, effective_start), end) for start, end in joyce_available if end > effective_start]\n\nalex_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"11:00\")),\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n    (time_to_minutes(\"13:30\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\")),\n    (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))\n]\nalex_available = subtract_busy_times([(work_start, work_end)], alex_busy)\n# Also restrict Alexander\u2019s available time to times after 12:00 per Christine's constraint.\nalex_available = [(max(start, effective_start), end) for start, end in alex_available if end > effective_start]\n\n# Christine has no meetings, but her effective availability is just the constraint.\nchristine_available = base_interval\n\n# Find the common free intervals among all participants.\ncommon = intersect_intervals(joyce_available, alex_available)\ncommon = intersect_intervals(common, christine_available)\n\n# Now choose the earliest interval in which a meeting of meeting_duration minutes can fit.\nmeeting_time = None\nfor start, end in common:\n    if start + meeting_duration <= end:\n        meeting_time = (start, start + meeting_duration)\n        break\n\nif meeting_time:\n    start_time_str = minutes_to_time(meeting_time[0])\n    end_time_str = minutes_to_time(meeting_time[1])\n    print(f\"{start_time_str}:{end_time_str}\")\nelse:\n    print(\"No suitable meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_15"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "'''python\ndef to_minutes(time_str):\n    \"\"\"Converts time in HH:MM format to minutes since midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef to_hhmm(minutes):\n    \"\"\"Converts minutes since midnight to HH:MM format.\"\"\"\n    h = minutes // 60\n    m = minutes % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef complement_intervals(busy, work_start, work_end):\n    \"\"\"Given a list of busy intervals (each a tuple (start, end) in minutes) and overall working hours,\n    return a list of free intervals within working hours.\"\"\"\n    free = []\n    # sort busy intervals by start time\n    busy_sorted = sorted(busy, key=lambda x: x[0])\n    prev_end = work_start\n    for start, end in busy_sorted:\n        if start > prev_end:\n            free.append((prev_end, start))\n        # update prev_end to the maximum busy end encountered so far\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free.append((prev_end, work_end))\n    return free\n\ndef intersect_intervals(int1, int2):\n    \"\"\"Intersect two lists of intervals. Each interval is a tuple (start, end) in minutes.\"\"\"\n    i, j = 0, 0\n    result = []\n    while i < len(int1) and j < len(int2):\n        start = max(int1[i][0], int2[j][0])\n        end = min(int1[i][1], int2[j][1])\n        if start < end:  # valid non-empty intersection\n            result.append((start, end))\n        # move to the next interval in the list that ends first.\n        if int1[i][1] < int2[j][1]:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef main():\n    # Define working hours: 09:00 to 17:00 in minutes (from midnight)\n    work_start = to_minutes(\"09:00\")\n    work_end = to_minutes(\"17:00\")\n    \n    meeting_duration = 30  # in minutes\n\n    # Define busy intervals for each participant (times in HH:MM)\n    # Scott is busy: 9:30-10:30, 13:30-14:00, 14:30-15:00, 15:30-16:00, 16:30-17:00.\n    scott_busy = [\n        (to_minutes(\"09:30\"), to_minutes(\"10:30\")),\n        (to_minutes(\"13:30\"), to_minutes(\"14:00\")),\n        (to_minutes(\"14:30\"), to_minutes(\"15:00\")),\n        (to_minutes(\"15:30\"), to_minutes(\"16:00\")),\n        (to_minutes(\"16:30\"), to_minutes(\"17:00\"))\n    ]\n    \n    # Gabriel has no meetings.\n    gabriel_busy = []  # free the whole day\n    \n    # Christine is busy: 9:00-10:00, 10:30-12:30, 13:00-17:00.\n    christine_busy = [\n        (to_minutes(\"09:00\"), to_minutes(\"10:00\")),\n        (to_minutes(\"10:30\"), to_minutes(\"12:30\")),\n        (to_minutes(\"13:00\"), to_minutes(\"17:00\"))\n    ]\n    \n    # Compute free intervals from busy times within working hours for each participant.\n    scott_free = complement_intervals(scott_busy, work_start, work_end)\n    gabriel_free = complement_intervals(gabriel_busy, work_start, work_end)\n    christine_free = complement_intervals(christine_busy, work_start, work_end)\n    \n    # Compute the common free intervals by intersecting free intervals.\n    common_free = intersect_intervals(scott_free, gabriel_free)\n    common_free = intersect_intervals(common_free, christine_free)\n    \n    # Now, find the first common interval that can fit the meeting duration.\n    meeting_time = None\n    for start, end in common_free:\n        if end - start >= meeting_duration:\n            meeting_time = (start, start + meeting_duration)\n            break\n\n    if meeting_time:\n        meeting_start = to_hhmm(meeting_time[0])\n        meeting_end = to_hhmm(meeting_time[1])\n        # Output in the format {HH:MM:HH:MM}\n        print(f\"{{{meeting_start}:{meeting_end}}}\")\n    else:\n        print(\"No available time slot found.\")\n\nif __name__ == \"__main__\":\n    main()\n'''",
            "count": "calendar_scheduling_example_16"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import timedelta, datetime\n\n# Helper function to convert \"HH:MM\" string to minutes since midnight\ndef time_to_minutes(t_str):\n    h, m = map(int, t_str.split(\":\"))\n    return h * 60 + m\n\n# Helper function to convert minutes since midnight to \"HH:MM\" string\ndef minutes_to_time(m):\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\n# Compute free intervals from working hours given busy intervals.\n# working_interval: (start, end) in minutes\n# busy_intervals: list of (start, end) in minutes. They must be sorted by start time.\ndef compute_free_intervals(working_interval, busy_intervals):\n    free = []\n    work_start, work_end = working_interval\n    current = work_start\n    for b_start, b_end in sorted(busy_intervals):\n        if b_start > current:\n            free.append((current, b_start))\n        current = max(current, b_end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\n# Compute intersection between two lists of intervals.\ndef intersect_intervals(list1, list2):\n    i, j = 0, 0\n    intersection = []\n    while i < len(list1) and j < len(list2):\n        start1, end1 = list1[i]\n        start2, end2 = list2[j]\n        # Find overlap\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap < end_overlap:\n            intersection.append((start_overlap, end_overlap))\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\n# Meeting parameters\nmeeting_duration = 30  # minutes\n\n# Working hours for Monday (09:00 to 17:00) in minutes since midnight\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nworking_hours = (work_start, work_end)\n\n# Busy intervals for each participant in minutes\nmargaret_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n    (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\"))\n]\n\ndonna_busy = [\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))\n]\n\nhelen_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"11:30\")),\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"14:00\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"17:00\"))\n]\n\n# Helen's personal constraint: do not meet on Monday after 13:30.\n# So for Helen, we restrict her working hours to finish by 13:30.\nhelen_latest = time_to_minutes(\"13:30\")\n# Adjust working hours for Helen accordingly:\nhelen_working_hours = (work_start, helen_latest)\n\n# Compute free intervals for each participant\nmargaret_free = compute_free_intervals(working_hours, margaret_busy)\ndonna_free = compute_free_intervals(working_hours, donna_busy)\n# For Helen, limit her free intervals to her adjusted working hours\nraw_helen_free = compute_free_intervals(working_hours, helen_busy)\nhelen_free = []\nfor start, end in raw_helen_free:\n    # Only consider intervals that finish by 13:30\n    if start < helen_latest:\n        helen_free.append((start, min(end, helen_latest)))\n\n# Find common free intervals across all participants\ncommon_free = intersect_intervals(margaret_free, donna_free)\ncommon_free = intersect_intervals(common_free, helen_free)\n\n# Look for a time slot in the common free intervals with at least meeting_duration minutes\nproposed_slot = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        # Ensure the meeting would finish by Helen's final limit (already enforced in helen_free)\n        proposed_slot = (start, start + meeting_duration)\n        break\n\nif proposed_slot:\n    start_str = minutes_to_time(proposed_slot[0])\n    end_str = minutes_to_time(proposed_slot[1])\n    # Output in the required format HH:MM:HH:MM\n    print(f\"{start_str}:{end_str}\")\nelse:\n    print(\"No available slot found.\")\n'''",
            "count": "calendar_scheduling_example_17"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    \"\"\"Converts a time string 'HH:MM' to minutes from midnight.\"\"\"\n    h, m = map(int, t.split(':'))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    \"\"\"Converts minutes from midnight to time string 'HH:MM'.\"\"\"\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef get_free_intervals(busy, work_start, work_end):\n    \"\"\"Given sorted busy intervals, returns free intervals within work hours.\"\"\"\n    free = []\n    # Check before the first busy interval\n    if busy:\n        if work_start < busy[0][0]:\n            free.append((work_start, busy[0][0]))\n    else:\n        free.append((work_start, work_end))\n    # Between busy intervals:\n    for i in range(len(busy)-1):\n        end_current = busy[i][1]\n        start_next = busy[i+1][0]\n        if end_current < start_next:\n            free.append((end_current, start_next))\n    # After the last busy interval\n    if busy:\n        if busy[-1][1] < work_end:\n            free.append((busy[-1][1], work_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Intersect two lists of intervals, each interval is a tuple (start, end).\"\"\"\n    i, j = 0, 0\n    intersection = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find overlapping interval\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap < end_overlap:\n            intersection.append((start_overlap, end_overlap))\n        # Move to the next interval that ends first\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\n# Workday boundaries in minutes (9:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nmeeting_duration = 30  # in minutes\n\n# Busy schedules (each as a list of tuples: (start, end) in minutes)\n# Brian has no meetings.\nbrian_busy = []\n\n# Billy's busy intervals on Monday:\n# 10:00-10:30, 11:30-12:00, 14:00-14:30, 16:30-17:00\nbilly_busy = [\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"14:30\")),\n    (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))\n]\n\n# Patricia's busy intervals on Monday:\n# 9:00-12:30, 13:30-14:00, 14:30-16:00, 16:30-17:00\npatricia_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"12:30\")),\n    (time_to_minutes(\"13:30\"), time_to_minutes(\"14:00\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"16:00\")),\n    (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))\n]\n\n# Compute free intervals for each participant\nbrian_free = get_free_intervals(brian_busy, work_start, work_end)\nbilly_free = get_free_intervals(billy_busy, work_start, work_end)\npatricia_free = get_free_intervals(patricia_busy, work_start, work_end)\n\n# Compute common free intervals\ncommon_free = intersect_intervals(brian_free, billy_free)\ncommon_free = intersect_intervals(common_free, patricia_free)\n\n# Billy prefers to avoid meetings after 15:30.\nbilly_latest_finish = time_to_minutes(\"15:30\")\n\n# Find the earliest common free interval that can accommodate the meeting,\n# and also finish by Billy's preferred cutoff if possible.\nmeeting_time = None\nfor start, end in common_free:\n    # Adjust the interval if it goes beyond Billy's preferred time\n    effective_end = min(end, billy_latest_finish)\n    if effective_end - start >= meeting_duration:\n        meeting_time = (start, start + meeting_duration)\n        break\n\n# If no slot is found before 15:30, then try without Billy's preference constraint.\nif meeting_time is None:\n    for start, end in common_free:\n        if end - start >= meeting_duration:\n            meeting_time = (start, start + meeting_duration)\n            break\n\nif meeting_time:\n    start_str = minutes_to_time(meeting_time[0])\n    end_str = minutes_to_time(meeting_time[1])\n    print(f\"{{{start_str}:{end_str}}}\")\nelse:\n    print(\"No available meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_18"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "'''python\ndef to_minutes(time_str):\n    \"\"\"Convert time string 'HH:MM' to minutes since midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(':'))\n    return hours * 60 + minutes\n\ndef to_time_str(minutes):\n    \"\"\"Convert minutes since midnight to time string 'HH:MM'.\"\"\"\n    return f\"{minutes // 60:02d}:{minutes % 60:02d}\"\n\ndef get_free_intervals(working_start, working_end, busy_intervals):\n    \"\"\"Calculate free intervals given a working period and busy intervals.\n    \n    busy_intervals: list of (start, end) times in minutes.\n    Returns a list of (free_start, free_end) intervals.\n    \"\"\"\n    free = []\n    current = working_start\n    for bstart, bend in sorted(busy_intervals):\n        if current < bstart:\n            free.append((current, bstart))\n        current = max(current, bend)\n    if current < working_end:\n        free.append((current, working_end))\n    return free\n\ndef intersect_intervals(list1, list2):\n    \"\"\"Return intersection of two lists of intervals.\n    \n    Each list is a list of tuples (start, end).  \n    \"\"\"\n    intersections = []\n    i, j = 0, 0\n    while i < len(list1) and j < len(list2):\n        start1, end1 = list1[i]\n        start2, end2 = list2[j]\n        # Find intersection between intervals\n        start_int = max(start1, start2)\n        end_int = min(end1, end2)\n        if start_int < end_int:\n            intersections.append((start_int, end_int))\n        # Move the pointer for the interval that finishes first\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersections\n\n# Define the working hours in minutes (9:00 to 17:00)\nworking_start = to_minutes(\"09:00\")\nworking_end = to_minutes(\"17:00\")\n\n# Define busy intervals for everyone in minutes\nstephen_busy = [\n    (to_minutes(\"10:00\"), to_minutes(\"10:30\")),\n    (to_minutes(\"13:00\"), to_minutes(\"13:30\")),\n    (to_minutes(\"14:30\"), to_minutes(\"15:00\")),\n    (to_minutes(\"16:00\"), to_minutes(\"16:30\"))\n]\n\nedward_busy = [\n    (to_minutes(\"09:00\"), to_minutes(\"09:30\")),\n    (to_minutes(\"10:00\"), to_minutes(\"10:30\")),\n    (to_minutes(\"13:30\"), to_minutes(\"14:30\")),\n    (to_minutes(\"15:00\"), to_minutes(\"16:00\"))\n]\n\nangela_busy = [\n    (to_minutes(\"09:00\"), to_minutes(\"11:30\")),\n    (to_minutes(\"12:30\"), to_minutes(\"13:00\")),\n    (to_minutes(\"13:30\"), to_minutes(\"15:30\")),\n    (to_minutes(\"16:00\"), to_minutes(\"17:00\"))\n]\n\n# Calculate free intervals for each participant\nstephen_free = get_free_intervals(working_start, working_end, stephen_busy)\nedward_free  = get_free_intervals(working_start, working_end, edward_busy)\nangela_free  = get_free_intervals(working_start, working_end, angela_busy)\n\n# Function to intersect free intervals for all participants\ndef intersect_all(interval_lists):\n    # Start with the first list of intervals\n    common = interval_lists[0]\n    for intervals in interval_lists[1:]:\n        common = intersect_intervals(common, intervals)\n    return common\n\ncommon_free = intersect_all([stephen_free, edward_free, angela_free])\n\n# Meeting duration in minutes (1 hour)\nmeeting_duration = 60\n\nmeeting_time = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        meeting_time = (start, start + meeting_duration)\n        break\n\nif meeting_time:\n    meeting_start_str = to_time_str(meeting_time[0])\n    meeting_end_str = to_time_str(meeting_time[1])\n    print(f\"{{{meeting_start_str}:{meeting_end_str}}}\")\nelse:\n    print(\"No common meeting time available.\")\n'''",
            "count": "calendar_scheduling_example_19"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_time(m):\n    \"\"\"Convert minutes since midnight to HH:MM format.\"\"\"\n    return f\"{m // 60:02d}:{m % 60:02d}\"\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Intersect two lists of intervals. Each interval is a tuple (start, end) in minutes.\n       Returns a list of overlapping intervals.\"\"\"\n    result = []\n    i, j = 0, 0\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find overlap between intervals\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap < end_overlap:\n            result.append((start_overlap, end_overlap))\n        # Move to next interval in the list which finishes first\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef subtract_busy(working, busy):\n    \"\"\"Subtract busy intervals from working interval.\n       working: a tuple (start, end)\n       busy: a list of intervals (start, end)\n       Returns a list of free intervals.\"\"\"\n    free = []\n    start_work, end_work = working\n    current_start = start_work\n    for bstart, bend in sorted(busy):\n        if bstart > current_start:\n            free.append((current_start, min(bstart, end_work)))\n        current_start = max(current_start, bend)\n    if current_start < end_work:\n        free.append((current_start, end_work))\n    return free\n\ndef schedule_meeting():\n    # Define working hours Monday in minutes (9:00 to 17:00)\n    working_hours = (9 * 60, 17 * 60)\n    meeting_duration = 30  # in minutes\n\n    # Define busy intervals for each participant (in minutes from midnight)\n    # Ralph busy: 13:30-14:00, 14:30-15:00\n    busy_ralph = [(13 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60)]\n    # Peter busy: 9:00-9:30, 11:00-13:00, 16:00-16:30\n    busy_peter = [(9 * 60, 9 * 60 + 30), (11 * 60, 13 * 60), (16 * 60, 16 * 60 + 30)]\n    # Daniel busy: 9:00-10:00, 10:30-15:30, 16:00-17:00\n    busy_daniel = [(9 * 60, 10 * 60), (10 * 60 + 30, 15 * 60 + 30), (16 * 60, 17 * 60)]\n    \n    # Daniel prefers no meetings after 13:30.\n    daniel_preference_deadline = 13 * 60 + 30\n\n    # Compute free intervals for each participant within working hours.\n    free_ralph = subtract_busy(working_hours, busy_ralph)\n    free_peter = subtract_busy(working_hours, busy_peter)\n    free_daniel = subtract_busy(working_hours, busy_daniel)\n    \n    # Only consider Daniel's free intervals that start before his preference deadline.\n    free_daniel = [(start, min(end, daniel_preference_deadline)) for start, end in free_daniel if start < daniel_preference_deadline and min(end, daniel_preference_deadline) - start >= meeting_duration]\n\n    # Find common free intervals among the three participants.\n    common_free = intersect_intervals(free_ralph, free_peter)\n    common_free = intersect_intervals(common_free, free_daniel)\n\n    # Find an interval that can accommodate the meeting duration.\n    for start, end in common_free:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Output in the format HH:MM:HH:MM.\n            print(f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\")\n            return\n\n    # If no common time found (should not happen as per the problem statement).\n    print(\"No common free interval available.\")\n\nif __name__ == \"__main__\":\n    schedule_meeting()\n'''",
            "count": "calendar_scheduling_example_20"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    # time_str in format \"HH:MM\"\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Define working hours (in minutes)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Meeting duration in minutes\nmeeting_duration = 60\n\n# Define busy intervals for each participant (in minutes):\n# Bobby is free all day.\n# Scott is busy from 11:30 to 12:00 and 15:30 to 16:00.\nscott_busy = [\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\"))\n]\n\n# Kimberly is busy from 11:00 to 12:00, 12:30 to 13:00, 13:30 to 14:00, 14:30 to 15:00, 15:30 to 17:00.\nkimberly_busy = [\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"13:30\"), time_to_minutes(\"14:00\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"17:00\"))\n]\n\n# Aggregate all busy intervals from all participants\nbusy_intervals = scott_busy + kimberly_busy\n\n# Sort intervals by start time\nbusy_intervals.sort(key=lambda x: x[0])\n\n# Merge overlapping busy intervals\nmerged_busy = []\nfor interval in busy_intervals:\n    if not merged_busy:\n        merged_busy.append(interval)\n    else:\n        last = merged_busy[-1]\n        if interval[0] <= last[1]:\n            merged_busy[-1] = (last[0], max(last[1], interval[1]))\n        else:\n            merged_busy.append(interval)\n\n# Find free intervals between working hours\nfree_intervals = []\ncurrent_start = work_start\n\nfor b_start, b_end in merged_busy:\n    if current_start < b_start:\n        free_intervals.append((current_start, b_start))\n    current_start = max(current_start, b_end)\n\nif current_start < work_end:\n    free_intervals.append((current_start, work_end))\n\n# Find a slot that can accommodate the meeting duration\nscheduled_slot = None\nfor start, end in free_intervals:\n    if end - start >= meeting_duration:\n        scheduled_slot = (start, start + meeting_duration)\n        break\n\n# Output the scheduled meeting time in HH:MM:HH:MM format if found.\nif scheduled_slot:\n    start_time = minutes_to_time(scheduled_slot[0])\n    end_time = minutes_to_time(scheduled_slot[1])\n    # Format as {HH:MM:HH:MM}\n    print(f\"{{{start_time}:{end_time}}}\")\nelse:\n    print(\"No available slot found.\")\n'''",
            "count": "calendar_scheduling_example_21"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "'''python\ndef minutes(time_str):\n    \"\"\"Convert HH:MM string to minutes since midnight.\"\"\"\n    hours, mins = map(int, time_str.split(\":\"))\n    return hours * 60 + mins\n\ndef time_str(minutes_val):\n    \"\"\"Convert minutes since midnight to HH:MM string.\"\"\"\n    hours = minutes_val // 60\n    mins = minutes_val % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\ndef get_free_intervals(busy, work_start, work_end):\n    \"\"\"Given busy intervals (sorted list of (start, end) in minutes),\n       return list of free intervals within work hours as (start, end).\"\"\"\n    free = []\n    current = work_start\n    for start, end in busy:\n        if start > current:\n            free.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Return intersection of two lists of intervals.\"\"\"\n    result = []\n    i, j = 0, 0\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # find overlapping period\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap < end_overlap:\n            result.append((start_overlap, end_overlap))\n        # move the pointer with the earlier finishing interval\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef main():\n    # Meeting constraints\n    meeting_duration = 60  # in minutes\n    work_start = minutes(\"09:00\")\n    work_end = minutes(\"17:00\")\n    \n    # Busy intervals for each participant in minutes (start, end)\n    # Theresa's busy intervals\n    theresa_busy = [\n        (minutes(\"09:00\"), minutes(\"09:30\")),\n        (minutes(\"12:30\"), minutes(\"13:30\")),\n        (minutes(\"14:00\"), minutes(\"15:00\")),\n        (minutes(\"16:30\"), minutes(\"17:00\"))\n    ]\n    \n    # Charles's busy intervals\n    charles_busy = [\n        (minutes(\"10:00\"), minutes(\"10:30\")),\n        (minutes(\"11:30\"), minutes(\"12:30\")),\n        (minutes(\"14:00\"), minutes(\"15:30\"))\n    ]\n    \n    # Betty's busy intervals\n    betty_busy = [\n        (minutes(\"09:00\"), minutes(\"10:30\")),\n        (minutes(\"12:00\"), minutes(\"12:30\")),\n        (minutes(\"13:00\"), minutes(\"14:00\")),\n        (minutes(\"15:00\"), minutes(\"16:00\"))\n    ]\n    \n    # Compute free intervals for each participant\n    theresa_free = get_free_intervals(theresa_busy, work_start, work_end)\n    charles_free = get_free_intervals(charles_busy, work_start, work_end)\n    betty_free = get_free_intervals(betty_busy, work_start, work_end)\n    \n    # Intersect free intervals among all participants\n    common_free = intersect_intervals(theresa_free, charles_free)\n    common_free = intersect_intervals(common_free, betty_free)\n    \n    # Find earliest common time interval that fits meeting duration\n    meeting_slot = None\n    for start, end in common_free:\n        if end - start >= meeting_duration:\n            meeting_slot = (start, start + meeting_duration)\n            break\n    \n    if meeting_slot:\n        start_str = time_str(meeting_slot[0])\n        end_str = time_str(meeting_slot[1])\n        print(\"{\" + f\"{start_str}:{end_str}\" + \"}\")\n    else:\n        print(\"No available slot found.\")\n\nif __name__ == \"__main__\":\n    main()\n'''",
            "count": "calendar_scheduling_example_22"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "'''python\ndef to_minutes(time_str):\n    \"\"\"Convert time in HH:MM format to minutes since midnight.\"\"\"\n    h, m = map(int, time_str.split(\":\"))\n    return h * 60 + m\n\ndef to_time_str(minutes):\n    \"\"\"Convert minutes since midnight to HH:MM format.\"\"\"\n    h = minutes // 60\n    m = minutes % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef get_free_intervals(busy_intervals, work_start, work_end):\n    \"\"\"\n    Given a list of busy intervals (each as a tuple of minutes: (start, end)) \n    and working hours boundaries, return a list of free intervals within working hours.\n    \"\"\"\n    free = []\n    current = work_start\n    for interval in sorted(busy_intervals):\n        busy_start, busy_end = interval\n        if busy_start > current:\n            free.append((current, busy_start))\n        current = max(current, busy_end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Intersect two lists of intervals.\"\"\"\n    i, j = 0, 0\n    intersection = []\n    while i < len(intervals1) and j < len(intervals2):\n        a_start, a_end = intervals1[i]\n        b_start, b_end = intervals2[j]\n        start = max(a_start, b_start)\n        end = min(a_end, b_end)\n        if start < end:\n            intersection.append((start, end))\n        # Move to the next interval\n        if a_end < b_end:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\ndef intersect_multiple(lists_of_intervals):\n    \"\"\"Compute the intersection among multiple lists of intervals.\"\"\"\n    if not lists_of_intervals:\n        return []\n    intersection = lists_of_intervals[0]\n    for intervals in lists_of_intervals[1:]:\n        intersection = intersect_intervals(intersection, intervals)\n    return intersection\n\ndef main():\n    # Define working hours and meeting duration (in minutes)\n    work_start = to_minutes(\"09:00\")\n    work_end = to_minutes(\"17:00\")\n    meeting_duration = 60\n\n    # Define busy intervals for each participant as (start, end) in minutes.\n    billy_busy = [(to_minutes(\"11:30\"), to_minutes(\"12:00\")),\n                  (to_minutes(\"13:00\"), to_minutes(\"15:00\")),\n                  (to_minutes(\"16:00\"), to_minutes(\"16:30\"))]\n    \n    maria_busy = [(to_minutes(\"09:00\"), to_minutes(\"09:30\")),\n                  (to_minutes(\"10:00\"), to_minutes(\"10:30\")),\n                  (to_minutes(\"13:00\"), to_minutes(\"13:30\")),\n                  (to_minutes(\"14:00\"), to_minutes(\"14:30\"))]\n    \n    william_busy = [(to_minutes(\"09:30\"), to_minutes(\"10:00\")),\n                    (to_minutes(\"12:00\"), to_minutes(\"12:30\")),\n                    (to_minutes(\"13:30\"), to_minutes(\"15:00\")),\n                    (to_minutes(\"15:30\"), to_minutes(\"17:00\"))]\n\n    # Compute free intervals for each participant\n    billy_free = get_free_intervals(billy_busy, work_start, work_end)\n    maria_free = get_free_intervals(maria_busy, work_start, work_end)\n    william_free = get_free_intervals(william_busy, work_start, work_end)\n\n    # Find common free intervals by intersecting everyone\u2019s free times\n    common_free = intersect_multiple([billy_free, maria_free, william_free])\n\n    meeting_time = None\n    # Check each common free interval for the meeting duration.\n    for start, end in common_free:\n        if end - start >= meeting_duration:\n            meeting_time = (start, start + meeting_duration)\n            break\n\n    if meeting_time:\n        start_str = to_time_str(meeting_time[0])\n        end_str = to_time_str(meeting_time[1])\n        print(f\"{start_str}:{end_str}\")\n    else:\n        print(\"No available time slot.\")\n\nif __name__ == \"__main__\":\n    main()\n'''",
            "count": "calendar_scheduling_example_23"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\ndef time_to_minutes(t):\n    # Convert a time string in HH:MM format to minutes since midnight\n    h, m = map(int, t.split(':'))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    # Convert minutes since midnight to a time string in HH:MM format\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\n# Meeting and work day parameters\nwork_start = time_to_minutes(\"09:00\")\nwork_end   = time_to_minutes(\"17:00\")\nmeeting_duration = 30  # in minutes\n\n# Benjamin constraint: meeting must not happen after 09:30\nbenjamin_latest = time_to_minutes(\"09:30\")\n\n# Brenda's busy intervals (start, end) in minutes from midnight\nbrenda_busy = [\n    (time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"12:30\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"16:30\"))\n]\n\ndef is_conflict(meeting_start, meeting_end, busy_intervals):\n    for busy_start, busy_end in busy_intervals:\n        # check if meeting overlaps with a busy interval\n        if not (meeting_end <= busy_start or meeting_start >= busy_end):\n            return True\n    return False\n\n# Since Benjamin does not want to meet after 09:30,\n# the meeting should finish by Benjamin's latest time.\nlatest_possible_start = min(work_end - meeting_duration, benjamin_latest - meeting_duration)\n\n# Find a slot starting from work_start that works for everyone\nproposed_start = None\ntime_slot = work_start\nwhile time_slot <= latest_possible_start:\n    meeting_end = time_slot + meeting_duration\n    # Check that meeting is within Benjamin's timeframe (it must finish by 09:30)\n    if meeting_end > benjamin_latest:\n        time_slot += 1\n        continue\n    # Check Brenda's schedule\n    if is_conflict(time_slot, meeting_end, brenda_busy):\n        time_slot += 1\n        continue\n    # Found a valid slot\n    proposed_start = time_slot\n    break\n\nif proposed_start is not None:\n    proposed_end = proposed_start + meeting_duration\n    output = f\"{minutes_to_time(proposed_start)}:{minutes_to_time(proposed_end)}\"\n    print(output)\nelse:\n    print(\"No valid meeting slot found.\")\n'''",
            "count": "calendar_scheduling_example_24"
        },
        {
            "final_program_time": "{13:30:14:30}",
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\ndef time_to_minutes(t):\n    \"\"\"Converts 'HH:MM' to minutes since midnight.\"\"\"\n    h, m = map(int, t.split(':'))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    \"\"\"Converts minutes since midnight to 'HH:MM'.\"\"\"\n    return f\"{m//60:02d}:{m%60:02d}\"\n\ndef get_free_intervals(busy, work_start, work_end):\n    \"\"\"Return list of free intervals given busy intervals and work hours.\n       Each interval is a tuple (start, end) in minutes.\n    \"\"\"\n    free = []\n    # sort busy by start time\n    busy.sort(key=lambda x: x[0])\n    # before first busy\n    if work_start < busy[0][0]:\n        free.append((work_start, busy[0][0]))\n    # between busy intervals\n    for i in range(len(busy)-1):\n        if busy[i][1] < busy[i+1][0]:\n            free.append((busy[i][1], busy[i+1][0]))\n    # after last busy\n    if busy[-1][1] < work_end:\n        free.append((busy[-1][1], work_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Intersect two lists of intervals and return the common intervals.\"\"\"\n    i, j = 0, 0\n    intersection = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        start_int = max(start1, start2)\n        end_int = min(end1, end2)\n        if start_int < end_int:\n            intersection.append((start_int, end_int))\n        # Move the interval which ends first\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\n# Define work hours (in minutes)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Meeting duration in minutes\nmeeting_duration = 60\n\n# Busy intervals for each participant (converted to minutes)\n# Anthony's busy intervals: 9:30-10:00, 12:00-13:00, 16:00-16:30.\nanthony_busy = [(time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n                (time_to_minutes(\"12:00\"), time_to_minutes(\"13:00\")),\n                (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))]\n\n# Pamela's busy intervals: 9:30-10:00, 16:30-17:00.\npamela_busy = [(time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n               (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))]\n\n# Zachary's busy intervals: 9:00-11:30, 12:00-12:30, 13:00-13:30, 14:30-15:00, 16:00-17:00.\nzachary_busy = [(time_to_minutes(\"09:00\"), time_to_minutes(\"11:30\")),\n                (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n                (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n                (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\")),\n                (time_to_minutes(\"16:00\"), time_to_minutes(\"17:00\"))]\n\n# Calculate free intervals based on work hours.\nanthony_free = get_free_intervals(anthony_busy, work_start, work_end)\n# For Pamela, also consider her preference: do not meet after 14:30.\n# So we cap her available time at 14:30 (which is 14:30 = 14*60+30 = 870 minutes).\nraw_pamela_free = get_free_intervals(pamela_busy, work_start, work_end)\npamela_free = []\ncap_time = time_to_minutes(\"14:30\")\nfor start, end in raw_pamela_free:\n    # Adjust the free interval so that meeting will not extend past cap_time.\n    # We want the meeting to finish by cap_time at the latest.\n    if start < cap_time:\n        pam_free_end = min(end, cap_time)\n        pamela_free.append((start, pam_free_end))\n\nzachary_free = get_free_intervals(zachary_busy, work_start, work_end)\n\n# Now, compute the common free intervals between all three.\ncommon_free = intersect_intervals(anthony_free, pamela_free)\ncommon_free = intersect_intervals(common_free, zachary_free)\n\n# Look for an interval that can accommodate the meeting duration.\nmeeting_slot = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        meeting_slot = (start, start + meeting_duration)\n        break\n\nif meeting_slot:\n    # Format the output as HH:MM:HH:MM inside curly braces.\n    meeting_start = minutes_to_time(meeting_slot[0])\n    meeting_end = minutes_to_time(meeting_slot[1])\n    print(f\"{{{meeting_start}:{meeting_end}}}\")\nelse:\n    print(\"No available slot found.\")\n'''",
            "count": "calendar_scheduling_example_25"
        },
        {
            "final_program_time": "{15:30:16:30}",
            "expected_time": "{15:30:16:30}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_since_midnight(time_str):\n    \"\"\"Convert HH:MM time string to minutes since midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef time_str(minutes):\n    \"\"\"Convert minutes since midnight to HH:MM formatted string.\"\"\"\n    return f\"{minutes//60:02d}:{minutes%60:02d}\"\n\n# Define work hours in minutes since midnight\nwork_start = minutes_since_midnight(\"09:00\")\nwork_end = minutes_since_midnight(\"17:00\")\nmeeting_duration = 60  # in minutes\n\n# Define busy intervals for each participant in minutes.\n# Katherine and Nicole are free all day, so we only consider Kevin's schedule.\n# Kevin's busy intervals: [09:00-10:00], [10:30-11:30], [12:00-15:30], [16:30-17:00]\nbusy_intervals = [\n    (minutes_since_midnight(\"09:00\"), minutes_since_midnight(\"10:00\")),\n    (minutes_since_midnight(\"10:30\"), minutes_since_midnight(\"11:30\")),\n    (minutes_since_midnight(\"12:00\"), minutes_since_midnight(\"15:30\")),\n    (minutes_since_midnight(\"16:30\"), minutes_since_midnight(\"17:00\"))\n]\n\ndef is_time_available(start, duration, busy_intervals):\n    \"\"\"Check if the interval [start, start+duration) does not overlap any busy interval.\"\"\"\n    end = start + duration\n    for b_start, b_end in busy_intervals:\n        # If there is any overlap, return False.\n        if not (end <= b_start or start >= b_end):\n            return False\n    return True\n\n# Find a starting time for the meeting within working hours\nmeeting_start = None\nfor t in range(work_start, work_end - meeting_duration + 1):\n    if is_time_available(t, meeting_duration, busy_intervals):\n        meeting_start = t\n        break\n\nif meeting_start is not None:\n    meeting_end = meeting_start + meeting_duration\n    # Format the meeting time as HH:MM:HH:MM (start and end)\n    meeting_time = f\"{time_str(meeting_start)}:{time_str(meeting_end)}\"\n    print(meeting_time)\nelse:\n    print(\"No available time found.\")\n'''",
            "count": "calendar_scheduling_example_26"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\ndef time_to_minutes(time_str):\n    \"\"\"Converts time in HH:MM format to minutes since midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    \"\"\"Converts minutes since midnight back to HH:MM format with zero padding.\"\"\"\n    return f\"{minutes // 60:02d}:{minutes % 60:02d}\"\n\n# Define workday boundaries\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nmeeting_duration = 30  # in minutes\n\n# Busy intervals for each participant (start, end) expressed in minutes.\n# Jesse: [(10:00 to 10:30), (15:30 to 16:00)]\njesse_busy = [(time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n              (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\"))]\n\n# Kathryn: no busy times, so we leave it empty.\nkathryn_busy = []\n\n# Megan: [(10:30 to 11:00), (11:30 to 12:30), (13:30 to 14:30), (15:00 to 16:30)]\nmegan_busy = [(time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n              (time_to_minutes(\"11:30\"), time_to_minutes(\"12:30\")),\n              (time_to_minutes(\"13:30\"), time_to_minutes(\"14:30\")),\n              (time_to_minutes(\"15:00\"), time_to_minutes(\"16:30\"))]\n\n# Combine all busy intervals for the participants.\nbusy_intervals = jesse_busy + kathryn_busy + megan_busy\n# Sort intervals by start time.\nbusy_intervals.sort(key=lambda x: x[0])\n\ndef is_slot_free(start, end, intervals):\n    \"\"\"Check if a slot from start to end is free (i.e., doesn't overlap any busy intervals).\"\"\"\n    for busy_start, busy_end in intervals:\n        # Check if [start, end) overlaps with busy interval [busy_start, busy_end)\n        if not (end <= busy_start or start >= busy_end):\n            return False\n    return True\n\nmeeting_start = None\n\n# Iterate over possible start times within work hours.\ncurrent = work_start\nwhile current + meeting_duration <= work_end:\n    if is_slot_free(current, current + meeting_duration, busy_intervals):\n        meeting_start = current\n        break\n    current += 1  # move minute by minute\n\nif meeting_start is not None:\n    meeting_end = meeting_start + meeting_duration\n    # Output in the format HH:MM:HH:MM\n    print(f\"{{{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}}}\")\nelse:\n    print(\"No available meeting slot found.\")\n'''",
            "count": "calendar_scheduling_example_27"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    \"\"\"Convert time string 'HH:MM' to minutes since midnight.\"\"\"\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    \"\"\"Convert minutes since midnight to time string 'HH:MM'.\"\"\"\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef get_free_intervals(busy_intervals, work_start, work_end):\n    \"\"\"\n    Given a list of busy intervals (tuples of (start, end) in minutes) and\n    work start and end in minutes, return list of free intervals within [work_start, work_end].\n    \"\"\"\n    free = []\n    # Sort busy intervals\n    busy_intervals.sort(key=lambda x: x[0])\n    current = work_start\n    for start, end in busy_intervals:\n        if start > current:\n            free.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Intersect two lists of intervals where each interval is a tuple (start, end).\"\"\"\n    i, j = 0, 0\n    intersections = []\n    while i < len(intervals1) and j < len(intervals2):\n        s1, e1 = intervals1[i]\n        s2, e2 = intervals2[j]\n        # Find the overlap, if any\n        start = max(s1, s2)\n        end = min(e1, e2)\n        if start < end:\n            intersections.append((start, end))\n        # Move pointer for the interval that ends first\n        if e1 < e2:\n            i += 1\n        else:\n            j += 1\n    return intersections\n\ndef intersect_all(intervals_list):\n    \"\"\"Intersect a list of interval lists.\"\"\"\n    if not intervals_list:\n        return []\n    current_intersect = intervals_list[0]\n    for intervals in intervals_list[1:]:\n        current_intersect = intersect_intervals(current_intersect, intervals)\n    return current_intersect\n\ndef main():\n    # Define work hours in minutes (9:00 to 17:00)\n    work_start = time_to_minutes(\"09:00\")\n    work_end = time_to_minutes(\"17:00\")\n    meeting_duration = 30  # Duration in minutes\n\n    # Define busy schedules for each participant in minutes.\n    # Format: list of tuples (start, end)\n    brittany_busy = [\n        (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n        (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))\n    ]\n    emily_busy = []  # Emily is free the entire day.\n    doris_busy = [\n        (time_to_minutes(\"09:00\"), time_to_minutes(\"11:00\")),\n        (time_to_minutes(\"11:30\"), time_to_minutes(\"14:30\")),\n        (time_to_minutes(\"15:00\"), time_to_minutes(\"17:00\"))\n    ]\n\n    # Calculate free intervals for each participant\n    brittany_free = get_free_intervals(brittany_busy, work_start, work_end)\n    emily_free = get_free_intervals(emily_busy, work_start, work_end)\n    doris_free = get_free_intervals(doris_busy, work_start, work_end)\n\n    # Calculate common free intervals among all participants\n    common_free = intersect_all([brittany_free, emily_free, doris_free])\n\n    # Find earliest time slot that can accommodate the meeting duration.\n    meeting_time = None\n    for start, end in common_free:\n        if end - start >= meeting_duration:\n            meeting_time = (start, start + meeting_duration)\n            break\n\n    if meeting_time:\n        meeting_start_str = minutes_to_time(meeting_time[0])\n        meeting_end_str = minutes_to_time(meeting_time[1])\n        # Print in the format HH:MM:HH:MM\n        print(f\"{meeting_start_str}:{meeting_end_str}\")\n    else:\n        print(\"No available time slot found.\")\n\nif __name__ == \"__main__\":\n    main()\n'''",
            "count": "calendar_scheduling_example_28"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_time(minutes):\n    \"\"\"Converts minutes since midnight to HH:MM string.\"\"\"\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\ndef interval_conflict(meeting_start, meeting_end, busy_start, busy_end):\n    \"\"\"Checks if meeting interval conflicts with a busy interval.\"\"\"\n    return meeting_start < busy_end and meeting_end > busy_start\n\ndef is_slot_free(meeting_start, meeting_end, busy_times):\n    \"\"\"Checks if the meeting slot [meeting_start, meeting_end) conflicts with any busy times.\"\"\"\n    for (busy_start, busy_end) in busy_times:\n        if interval_conflict(meeting_start, meeting_end, busy_start, busy_end):\n            return False\n    return True\n\ndef find_common_slot(meeting_duration, work_start, work_end, schedules):\n    \"\"\"\n    Finds a common meeting slot of meeting_duration minutes between work_start and work_end.\n    schedules is a list of lists of busy time intervals for each participant, in minutes.\n    \"\"\"\n    # Try every possible start time in minutes.\n    for start in range(work_start, work_end - meeting_duration + 1):\n        end = start + meeting_duration\n        # Check each participant's schedule.\n        if all(is_slot_free(start, end, busy_times) for busy_times in schedules):\n            return start, end\n    return None\n\ndef main():\n    # Define work hours: 9:00 to 17:00 in minutes since midnight.\n    work_start = 9 * 60  # 540 minutes\n    work_end = 17 * 60   # 1020 minutes\n    meeting_duration = 60  # 60 minutes\n\n    # Define busy schedules in minutes for each participant.\n    # Madison: blocked 9:30-10:00 and 11:30-12:00\n    madison_busy = [(9 * 60 + 30, 9 * 60 + 60), (11 * 60 + 30, 12 * 60)]\n    # Diana: meetings 11:00-11:30 and 13:00-13:30\n    diana_busy = [(11 * 60, 11 * 60 + 30), (13 * 60, 13 * 60 + 30)]\n    # Shirley: busy 9:00-12:00, 13:30-15:00, 15:30-17:00\n    shirley_busy = [(9 * 60, 12 * 60), (13 * 60 + 30, 15 * 60), (15 * 60 + 30, 17 * 60)]\n    \n    schedules = [madison_busy, diana_busy, shirley_busy]\n\n    slot = find_common_slot(meeting_duration, work_start, work_end, schedules)\n    if slot:\n        start, end = slot\n        # Format the output as requested: {HH:MM:HH:MM}\n        meeting_time = f\"{{{minutes_to_time(start)}:{minutes_to_time(end)}}}\"\n        print(meeting_time)\n    else:\n        print(\"No common meeting slot found.\")\n\nif __name__ == \"__main__\":\n    main()\n'''",
            "count": "calendar_scheduling_example_29"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\n# Convert time string \"HH:MM\" to minutes since midnight\ndef time_to_minutes(t):\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\n# Convert minutes since midnight to time string \"HH:MM\"\ndef minutes_to_time(m):\n    return f\"{m//60:02d}:{m%60:02d}\"\n\n# Check if the meeting interval [start, end) overlaps with any busy interval in schedule.\ndef is_free(busy, start, end):\n    for b_start, b_end in busy:\n        # If meeting starts before busy ends and ends after busy starts, there's an overlap.\n        if start < b_end and end > b_start:\n            return False\n    return True\n\n# Meeting and work settings (times in minutes)\nwork_start = time_to_minutes(\"09:00\")\nwork_end   = time_to_minutes(\"17:00\")\nmeeting_duration = 30\n\n# Melissa prefers not to meet after 14:00.\n# So meeting must finish by 14:00.\nlatest_allowed_finish = time_to_minutes(\"14:00\")\nlatest_start = latest_allowed_finish - meeting_duration\n\n# Participants' busy schedules on Monday (as tuples of (start, end) in minutes)\njeffrey_busy = [\n    (time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\"))\n]\n\nvirginia_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))\n]\n\nmelissa_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"11:30\")),\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"17:00\"))\n]\n\n# Find the earliest candidate meeting time that fits all constraints.\nproposed_start = None\nfor start in range(work_start, latest_start + 1):\n    end = start + meeting_duration\n    # Check if the meeting falls within work hours (it does by design) \n    # and also meets Melissa's constraint (end <= 14:00)\n    if end > latest_allowed_finish:\n        continue\n    if (is_free(jeffrey_busy, start, end) and \n        is_free(virginia_busy, start, end) and \n        is_free(melissa_busy, start, end)):\n        proposed_start = start\n        break\n\nif proposed_start is None:\n    print(\"No available time slot found.\")\nelse:\n    proposed_end = proposed_start + meeting_duration\n    # Print in format HH:MM:HH:MM\n    print(f\"{{{minutes_to_time(proposed_start)}:{minutes_to_time(proposed_end)}}}\")\n'''",
            "count": "calendar_scheduling_example_30"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    # Converts \"HH:MM\" to minutes past midnight.\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    # Converts minutes past midnight back to \"HH:MM\" format.\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\ndef intervals_overlap(start1, end1, start2, end2):\n    # Returns True if two intervals [start1, end1) and [start2, end2) overlap.\n    return max(start1, start2) < min(end1, end2)\n\n# Meeting duration in minutes\nmeeting_duration = 30\n\n# Work hours boundaries (in minutes)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Constraint: Martha does not want to meet before 14:00.\nmartha_earliest = time_to_minutes(\"14:00\")\n\n# Busy intervals for each participant (times in minutes)\n# Richard: 13:30-14:00, 15:00-15:30\nrichard_busy = [\n    (time_to_minutes(\"13:30\"), time_to_minutes(\"14:00\")),\n    (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\"))\n]\n\n# Martha: busy 9:00-9:30, 13:00-13:30 (but meeting can only be after 14:00)\nmartha_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\"))\n]\n\n# Kimberly: busy 9:00-11:00, 11:30-12:00, 12:30-13:00, 14:00-16:00\nkimberly_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"11:00\")),\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"16:00\"))\n]\n\ndef is_slot_available(start, duration, busy_intervals):\n    end = start + duration\n    for busy_start, busy_end in busy_intervals:\n        if intervals_overlap(start, end, busy_start, busy_end):\n            return False\n    return True\n\n# Combine busy intervals check for all participants for a given time slot.\ndef is_slot_feasible(start):\n    # Meeting must start no earlier than 14:00 because of Martha's preference.\n    if start < martha_earliest:\n        return False\n    # Check against everyone's schedule.\n    if (is_slot_available(start, meeting_duration, richard_busy) and\n        is_slot_available(start, meeting_duration, martha_busy) and\n        is_slot_available(start, meeting_duration, kimberly_busy)):\n        return True\n    return False\n\n# Search for a feasible meeting time between the window defined by work hours.\n# The meeting must finish by work_end.\nfound_slot = False\nmeeting_start = None\n\n# We can consider candidate start times in 30 minute increments.\n# Start from max(work_start, martha_earliest) since Martha prefers meeting not earlier.\ncandidate_time = max(work_start, martha_earliest)\nwhile candidate_time + meeting_duration <= work_end:\n    if is_slot_feasible(candidate_time):\n        meeting_start = candidate_time\n        found_slot = True\n        break\n    candidate_time += 30\n\nif found_slot:\n    start_time_str = minutes_to_time(meeting_start)\n    end_time_str = minutes_to_time(meeting_start + meeting_duration)\n    # Output the result in HH:MM:HH:MM format.\n    print(f\"{start_time_str}:{end_time_str}\")\nelse:\n    print(\"No feasible meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_31"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\ndef to_minutes(time_str):\n    # time_str in HH:MM format\n    dt = datetime.strptime(time_str, \"%H:%M\")\n    return dt.hour * 60 + dt.minute\n\ndef to_time_str(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Work day start and end times in minutes\nwork_start = to_minutes(\"09:00\")\nwork_end = to_minutes(\"17:00\")\nmeeting_duration = 30\n\n# Busy schedules represented as (start, end) times in minutes for each participant\n\n# Emily's meetings\nemily_busy = [(to_minutes(\"10:00\"), to_minutes(\"10:30\")),\n              (to_minutes(\"11:30\"), to_minutes(\"12:30\")),\n              (to_minutes(\"14:00\"), to_minutes(\"15:00\")),\n              (to_minutes(\"16:00\"), to_minutes(\"16:30\"))]\n\n# Melissa's meetings\nmelissa_busy = [(to_minutes(\"09:30\"), to_minutes(\"10:00\")),\n                (to_minutes(\"14:30\"), to_minutes(\"15:00\"))]\n\n# Frank's meetings and additional constraint:\n# Frank does not want meetings after 09:30, so his available window is only until 09:30.\nfrank_busy = [(to_minutes(\"10:00\"), to_minutes(\"10:30\")),\n              (to_minutes(\"11:00\"), to_minutes(\"11:30\")),\n              (to_minutes(\"12:30\"), to_minutes(\"13:00\")),\n              (to_minutes(\"13:30\"), to_minutes(\"14:30\")),\n              (to_minutes(\"15:00\"), to_minutes(\"16:00\")),\n              (to_minutes(\"16:30\"), to_minutes(\"17:00\"))]\n# Frank's extra constraint: available only until 09:30.\nfrank_constraint_end = to_minutes(\"09:30\")\n\ndef get_free_slots(busy, day_start, day_end):\n    slots = []\n    # sort busy intervals by start time\n    busy = sorted(busy, key=lambda x: x[0])\n    current = day_start\n    for start, end in busy:\n        if current < start:\n            slots.append((current, start))\n        current = max(current, end)\n    if current < day_end:\n        slots.append((current, day_end))\n    return slots\n\n# Compute free slots for each participant for the work day\nemily_free = get_free_slots(emily_busy, work_start, work_end)\nmelissa_free = get_free_slots(melissa_busy, work_start, work_end)\nfrank_free = get_free_slots(frank_busy, work_start, work_end)\n\n# Apply Frank's additional constraint: available only before or at 09:30.\n# Any free interval starting before frank_constraint_end is truncated to [start, min(end, frank_constraint_end)]\ndef apply_frank_constraint(free_slots, constraint_end):\n    constrained = []\n    for start, end in free_slots:\n        if start < constraint_end:\n            constrained.append((start, min(end, constraint_end)))\n    return constrained\n\nfrank_free = apply_frank_constraint(frank_free, frank_constraint_end)\n\n# Helper function to compute intersection between two sets of slots\ndef intersect_slots(slots1, slots2):\n    i, j = 0, 0\n    intersections = []\n    while i < len(slots1) and j < len(slots2):\n        start1, end1 = slots1[i]\n        start2, end2 = slots2[j]\n        # Calculate overlap\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap + meeting_duration <= end_overlap:\n            intersections.append((start_overlap, end_overlap))\n        # Move the pointer that ends earlier\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersections\n\n# Find intersection of free slots among all three participants\nintersect_emily_melissa = intersect_slots(emily_free, melissa_free)\ncommon_slots = intersect_slots(intersect_emily_melissa, frank_free)\n\n# Pick the earliest slot that fits the meeting duration\nmeeting_time = None\nfor start, end in common_slots:\n    if start + meeting_duration <= end:\n        meeting_time = (start, start + meeting_duration)\n        break\n\nif meeting_time:\n    start_str = to_time_str(meeting_time[0])\n    end_str = to_time_str(meeting_time[1])\n    # Print in the required format HH:MM:HH:MM (e.g., 09:00:09:30)\n    print(f\"{start_str}:{end_str}\")\nelse:\n    print(\"No available meeting slot found.\")\n'''",
            "count": "calendar_scheduling_example_32"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_time_str(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\ndef get_free_intervals(busy_intervals, work_start, work_end):\n    free_intervals = []\n    current = work_start\n    # Ensure busy intervals are sorted\n    for start, end in sorted(busy_intervals):\n        if current < start:\n            free_intervals.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free_intervals.append((current, work_end))\n    return free_intervals\n\ndef intersect_intervals(intervals1, intervals2):\n    result = []\n    i, j = 0, 0\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find overlap between the two intervals\n        start = max(start1, start2)\n        end = min(end1, end2)\n        if start < end:\n            result.append((start, end))\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef find_meeting_slot(free_intervals, duration, end_constraint=None):\n    # end_constraint: the meeting must finish before this minute (if provided)\n    for start, end in free_intervals:\n        # Check if the free slot is long enough\n        if end - start >= duration:\n            proposed_start = start\n            proposed_end = start + duration\n            # If there's a constraint (like Bobby's preference before 15:00) ensure meeting ends by that time\n            if end_constraint is not None and proposed_end > end_constraint:\n                # Try shifting meeting earlier within the current free window if possible\n                if start <= end_constraint - duration:\n                    proposed_start = start\n                    proposed_end = proposed_start + duration\n                    if proposed_end <= end_constraint:\n                        return proposed_start, proposed_end\n                continue\n            return proposed_start, proposed_end\n    return None\n\ndef main():\n    meeting_duration = 30  # duration in minutes\n\n    # Define work hours in minutes from midnight\n    work_start = 9 * 60      # 9:00 -> 540 minutes\n    work_end = 17 * 60       # 17:00 -> 1020 minutes\n\n    # Busy intervals for each participant (in minutes)\n    # Lisa: 9:00-10:00, 10:30-11:30, 12:30-13:00, 16:00-16:30\n    lisa_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    # Bobby: 9:00-9:30, 10:00-10:30, 11:30-12:00, 15:00-15:30\n    bobby_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    \n    # Randy: 9:30-10:00, 10:30-11:00, 11:30-12:30, 13:00-13:30, 14:30-15:30, 16:00-16:30\n    randy_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n\n    # Compute free intervals for each participant\n    lisa_free = get_free_intervals(lisa_busy, work_start, work_end)\n    bobby_free = get_free_intervals(bobby_busy, work_start, work_end)\n    randy_free = get_free_intervals(randy_busy, work_start, work_end)\n\n    # Intersect free intervals between Lisa and Bobby\n    free_lb = intersect_intervals(lisa_free, bobby_free)\n    # Intersect the result with Randy's free intervals\n    all_free = intersect_intervals(free_lb, randy_free)\n\n    # Bobby prefers to avoid meetings after 15:00, so meeting must finish by 15:00 (15*60 minutes)\n    preferred_end_constraint = 15 * 60\n\n    slot = find_meeting_slot(all_free, meeting_duration, end_constraint=preferred_end_constraint)\n    # Fallback (should not be needed given a solution exists)\n    if slot is None:\n        slot = find_meeting_slot(all_free, meeting_duration)\n    \n    if slot:\n        start, end = slot\n        # Output the time in the format HH:MM:HH:MM\n        print(f\"{minutes_to_time_str(start)}:{minutes_to_time_str(end)}\")\n    else:\n        print(\"No available slot could be found.\")\n\nif __name__ == \"__main__\":\n    main()\n'''",
            "count": "calendar_scheduling_example_33"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_timestr(start, end):\n    # Convert minutes since midnight to HH:MM:HH:MM format string\n    start_hour, start_min = divmod(start, 60)\n    end_hour, end_min = divmod(end, 60)\n    return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Given two lists of intervals (start, end) in minutes, returns their intersection.\"\"\"\n    intersections = []\n    i, j = 0, 0\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find overlap\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap < end_overlap:\n            intersections.append((start_overlap, end_overlap))\n        # Move to next interval in the list that finishes first\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersections\n\ndef main():\n    # Working day in minutes: 9:00 is 540, 17:00 is 1020\n    work_day = [(540, 1020)]\n    \n    # Participant free intervals in minutes.\n    # Willie is free the entire work day.\n    willie_free = work_day\n    \n    # Richard busy intervals provided:\n    # busy: 10:00-10:30, 11:00-12:00, 13:00-14:00, 16:00-16:30.\n    # So his free intervals during work day are:\n    # 9:00-10:00, 10:30-11:00, 12:00-13:00, 14:00-16:00, 16:30-17:00.\n    richard_free = [(540, 600), (630, 660), (720, 780), (840, 960), (990, 1020)]\n    \n    # Noah busy intervals provided:\n    # busy: 10:00-10:30, 11:30-13:00, 13:30-14:00, 14:30-17:00.\n    # So Noah's free intervals are:\n    # 9:00-10:00, 10:30-11:30, 13:00-13:30, 14:00-14:30.\n    noah_free = [(540, 600), (630, 690), (780, 810), (840, 870)]\n    \n    meeting_duration = 60  # in minutes\n\n    # Compute common free time across all participants.\n    # Start with Willie's free time (all day) and intersect with Richard and Noah.\n    common_free = willie_free\n    for free in [richard_free, noah_free]:\n        common_free = intersect_intervals(common_free, free)\n    \n    # Now, find the earliest common free interval that can accommodate the meeting duration.\n    meeting_time = None\n    for start, end in common_free:\n        if end - start >= meeting_duration:\n            meeting_time = (start, start + meeting_duration)\n            break\n\n    if meeting_time:\n        print(minutes_to_timestr(meeting_time[0], meeting_time[1]))\n    else:\n        print(\"No available time slot found that satisfies the constraints.\")\n\nif __name__ == \"__main__\":\n    main()\n'''",
            "count": "calendar_scheduling_example_34"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "'''python\nimport datetime\n\ndef is_available(start, end, busy_intervals):\n    for b_start, b_end in busy_intervals:\n        # Check if meeting interval [start, end) overlaps with busy interval [b_start, b_end)\n        if max(start, b_start) < min(end, b_end):\n            return False\n    return True\n\n# Define work hours for Monday (using arbitrary date, e.g., Jan 1, 2023)\nwork_start = datetime.datetime(2023, 1, 1, 9, 0)\nwork_end = datetime.datetime(2023, 1, 1, 17, 0)\nmeeting_duration = datetime.timedelta(minutes=30)\n\n# Bradley's constraint: meeting should not start before 14:30\nbradley_constraint = datetime.datetime(2023, 1, 1, 14, 30)\n\n# Existing schedules for participants\n# Bradley is free all day (besides his own preference constraint)\nbusy_zachary = [\n    (datetime.datetime(2023, 1, 1, 10, 0), datetime.datetime(2023, 1, 1, 10, 30)),\n    (datetime.datetime(2023, 1, 1, 15, 0), datetime.datetime(2023, 1, 1, 15, 30))\n]\nbusy_teresa = [\n    (datetime.datetime(2023, 1, 1, 9, 0),  datetime.datetime(2023, 1, 1, 10, 30)),\n    (datetime.datetime(2023, 1, 1, 11, 0), datetime.datetime(2023, 1, 1, 12, 30)),\n    (datetime.datetime(2023, 1, 1, 13, 0), datetime.datetime(2023, 1, 1, 14, 0)),\n    (datetime.datetime(2023, 1, 1, 14, 30), datetime.datetime(2023, 1, 1, 16, 30))\n]\n\n# Starting search time is the maximum of work_start and Bradley's constraint.\ncurrent_time = max(work_start, bradley_constraint)\nmeeting_found = False\n\nwhile current_time + meeting_duration <= work_end:\n    meeting_end = current_time + meeting_duration\n    if (is_available(current_time, meeting_end, busy_zachary) and \n        is_available(current_time, meeting_end, busy_teresa)):\n        meeting_found = True\n        scheduled_meeting = (current_time, meeting_end)\n        break\n    # Advance by one minute\n    current_time += datetime.timedelta(minutes=1)\n\nif meeting_found:\n    print(scheduled_meeting[0].strftime('%H:%M') + ':' + scheduled_meeting[1].strftime('%H:%M'))\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_35"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\ndef time_to_minutes(time_str):\n    \"\"\"Converts HH:MM time string to minutes since midnight.\"\"\"\n    dt = datetime.strptime(time_str, \"%H:%M\")\n    return dt.hour * 60 + dt.minute\n\ndef minutes_to_time(minutes):\n    \"\"\"Converts minutes since midnight to HH:MM string.\"\"\"\n    return f\"{minutes // 60:02d}:{minutes % 60:02d}\"\n\n# Define meeting duration in minutes\nmeeting_duration = 60\n\n# Define the overall allowed time window (using Denise's preference: meeting must end by 12:30)\nwindow_start = time_to_minutes(\"09:00\")\nwindow_end = time_to_minutes(\"12:30\")  # meeting must end by 12:30, given Denise's preference\n\n# Busy intervals for participants (start and end times in minutes)\n# Ryan's busy intervals\nryan_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\"))\n]\n\n# Ruth is free all day so no busy intervals\nruth_busy = []\n\n# Denise's busy intervals\ndenise_busy = [\n    (time_to_minutes(\"09:30\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"16:30\"))\n]\n\ndef invert_busy(busy_intervals, start, end):\n    \"\"\"Given a list of busy intervals and an overall window [start, end],\n    returns a list of free intervals (as tuples) within that window.\"\"\"\n    free_intervals = []\n    current = start\n    # Sort busy intervals by start time\n    busy_intervals_sorted = sorted(busy_intervals, key=lambda x: x[0])\n    for b_start, b_end in busy_intervals_sorted:\n        if b_start > current:\n            free_intervals.append((current, b_start))\n        current = max(current, b_end)\n    if current < end:\n        free_intervals.append((current, end))\n    return free_intervals\n\n# Get free intervals for each participant within the allowed window\nryan_free = invert_busy(ryan_busy, window_start, window_end)\nruth_free = [(window_start, window_end)]  # Ruth is free all day in the window\ndenise_free = invert_busy(denise_busy, window_start, window_end)\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Find intersection between two lists of intervals.\"\"\"\n    i, j = 0, 0\n    intersections = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find overlap\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap < end_overlap:\n            intersections.append((start_overlap, end_overlap))\n        # Move to the next interval in the list that ends first\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersections\n\n# Get common free intervals among the three participants\ncommon_free = intersect_intervals(ryan_free, ruth_free)\ncommon_free = intersect_intervals(common_free, denise_free)\n\n# Find the earliest common free interval that can accommodate the meeting duration.\nproposed_start = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        proposed_start = start\n        break\n\nif proposed_start is not None:\n    proposed_end = proposed_start + meeting_duration\n    # Output in the format HH:MM:HH:MM\n    output = f\"{minutes_to_time(proposed_start)}:{minutes_to_time(proposed_end)}\"\n    print(output)\nelse:\n    print(\"No available meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_36"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\ndef time_from_str(t_str):\n    return datetime.strptime(t_str, \"%H:%M\")\n\ndef str_from_time(t):\n    return t.strftime(\"%H:%M\")\n\n# Define meeting parameters\nmeeting_duration = timedelta(minutes=30)\nwork_start = time_from_str(\"09:00\")\nwork_end   = time_from_str(\"17:00\")\n\n# Busy intervals for each participant on Monday.\n# Each tuple is (start_time, end_time) as datetime objects.\ngregory_busy = [(time_from_str(\"11:00\"), time_from_str(\"11:30\")),\n                (time_from_str(\"12:00\"), time_from_str(\"12:30\")),\n                (time_from_str(\"15:30\"), time_from_str(\"16:30\"))]\n\nteresa_busy = []  # empty, fully available\n\ncarol_busy = [(time_from_str(\"09:00\"), time_from_str(\"10:30\")),\n              (time_from_str(\"11:00\"), time_from_str(\"16:00\")),\n              (time_from_str(\"16:30\"), time_from_str(\"17:00\"))]\n\n# Function to compute free intervals given busy intervals and work hours.\ndef get_free_intervals(busy, start, end):\n    # sort busy intervals and clip them to work start and end\n    busy = sorted(busy, key=lambda x: x[0])\n    free = []\n    current = start\n    for b_start, b_end in busy:\n        # if the busy slot is completely before the current pointer, skip\n        if b_end <= current:\n            continue\n        # if there is a gap\n        if b_start > current:\n            free.append((current, min(b_start, end)))\n        current = max(current, b_end)\n        if current >= end:\n            break\n    if current < end:\n        free.append((current, end))\n    return free\n\n# Compute free intervals for each participant\ngregory_free = get_free_intervals(gregory_busy, work_start, work_end)\nteresa_free  = get_free_intervals(teresa_busy,  work_start, work_end)\ncarol_free   = get_free_intervals(carol_busy,   work_start, work_end)\n\n# Function to compute intersection of two lists of intervals.\ndef intersect_intervals(intervals1, intervals2):\n    result = []\n    i, j = 0, 0\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        intersect_start = max(start1, start2)\n        intersect_end   = min(end1, end2)\n        if intersect_start < intersect_end:\n            result.append((intersect_start, intersect_end))\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Compute intersection of free intervals of all participants.\ncommon_free = intersect_intervals(gregory_free, teresa_free)\ncommon_free = intersect_intervals(common_free, carol_free)\n\n# Find the first slot that fits the meeting duration.\nmeeting_start, meeting_end = None, None\nfor free_start, free_end in common_free:\n    if free_end - free_start >= meeting_duration:\n        meeting_start = free_start\n        meeting_end = meeting_start + meeting_duration\n        break\n\n# Format the result in the format {HH:MM:HH:MM}\nif meeting_start and meeting_end:\n    result = f\"{{{str_from_time(meeting_start)}:{str_from_time(meeting_end)}}}\"\n    print(result)\nelse:\n    print(\"No available slot found.\")\n'''",
            "count": "calendar_scheduling_example_37"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\n# Helper functions to convert between \"HH:MM\" strings and minutes since midnight\ndef time_to_minutes(t):\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    return f\"{m//60:02d}:{m%60:02d}\"\n\n# Function to get free intervals within work hours given busy intervals\ndef get_free_intervals(busy_intervals, work_start, work_end):\n    free_intervals = []\n    current = work_start\n    for start, end in sorted(busy_intervals):\n        if start > current:\n            free_intervals.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free_intervals.append((current, work_end))\n    return free_intervals\n\n# Function to compute intersection between two lists of intervals\ndef intersect_intervals(intervals1, intervals2):\n    i, j = 0, 0\n    intersection = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        start_int = max(start1, start2)\n        end_int = min(end1, end2)\n        if start_int < end_int:  # Valid intersection exists\n            intersection.append((start_int, end_int))\n        # Move the pointer that ends first\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\n# Meeting duration in minutes\nmeeting_duration = 30\n\n# Define work hours in minutes (9:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Busy schedules for each participant (start and end as minutes from midnight)\n# Catherine's meetings: 10:30-11:00, 12:30-13:30, 14:30-15:00\ncatherine_busy = [\n    (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n    (time_to_minutes(\"12:30\"), time_to_minutes(\"13:30\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\"))\n]\n\n# Michael's meetings: 9:30-10:30, 12:00-13:00, 13:30-14:00, 15:00-15:30\nmichael_busy = [\n    (time_to_minutes(\"09:30\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"13:30\"), time_to_minutes(\"14:00\")),\n    (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\"))\n]\n\n# Alexander's meetings: 9:00-9:30, 10:00-10:30, 11:00-12:00, 13:00-13:30, 14:00-16:00, 16:30-17:00\nalexander_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"16:00\")),\n    (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))\n]\n\n# Get free intervals for each participant\ncatherine_free = get_free_intervals(catherine_busy, work_start, work_end)\nmichael_free = get_free_intervals(michael_busy, work_start, work_end)\nalexander_free = get_free_intervals(alexander_busy, work_start, work_end)\n\n# Calculate the common free intervals by intersecting the free times of all three participants\ncommon_free = intersect_intervals(catherine_free, michael_free)\ncommon_free = intersect_intervals(common_free, alexander_free)\n\n# Find a time slot among the common free intervals that can accommodate the meeting duration\nproposed_time = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        proposed_time = (start, start + meeting_duration)\n        break\n\nif proposed_time:\n    start_time_formatted = minutes_to_time(proposed_time[0])\n    end_time_formatted = minutes_to_time(proposed_time[1])\n    # Print the result in the format HH:MM:HH:MM, e.g. {16:00:16:30}\n    print(f\"{{{start_time_formatted}:{end_time_formatted}}}\")\nelse:\n    print(\"No available slot found.\")\n'''",
            "count": "calendar_scheduling_example_38"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    \"\"\"Converts HH:MM string to minutes since midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(':'))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    \"\"\"Converts minutes since midnight to HH:MM string.\"\"\"\n    h = minutes // 60\n    m = minutes % 60\n    return f\"{h:02d}:{m:02d}\"\n\n# Meeting duration in minutes\nmeeting_duration = 30\n\n# Work hours boundaries (in minutes since midnight)\nwork_start = time_to_minutes(\"09:00\")\nwork_end   = time_to_minutes(\"17:00\")\n\n# Busy intervals for each participant as (start, end) in minutes\n# Emily is free all day, so no busy intervals for her.\nbusy_emily = []\n\n# Victoria's busy times on Monday\nbusy_victoria = [\n    (time_to_minutes(\"13:30\"), time_to_minutes(\"14:00\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"15:30\")),\n    (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))\n]\n\n# Nancy's busy times on Monday\nbusy_nancy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"14:00\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"15:30\"))\n]\n\n# Combine busy schedules into a list for easier checking.\nall_busy = [busy_emily, busy_victoria, busy_nancy]\n\ndef is_available(start, end, busy_intervals):\n    \"\"\"Check if the interval [start, end) does not clash with any busy intervals in the list.\"\"\"\n    for busy in busy_intervals:\n        busy_start, busy_end = busy\n        # Check for overlap - if start is before busy_end and end is after busy_start, they overlap.\n        if start < busy_end and end > busy_start:\n            return False\n    return True\n\ndef find_meeting_time():\n    # Iterate over each participant's schedule starting from work_start until work_end - meeting_duration\n    candidate = work_start\n    while candidate + meeting_duration <= work_end:\n        interval_free = True\n        for schedule in all_busy:\n            if not is_available(candidate, candidate + meeting_duration, schedule):\n                interval_free = False\n                break\n        if interval_free:\n            return candidate, candidate + meeting_duration\n        candidate += 1  # Increment by one minute\n    return None\n\nresult = find_meeting_time()\nif result:\n    start_time, end_time = result\n    print(f\"{minutes_to_time(start_time)}:{minutes_to_time(end_time)}\")\nelse:\n    print(\"No available time slot found\")\n'''",
            "count": "calendar_scheduling_example_39"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    \"\"\"Converts a time string 'HH:MM' to minutes since midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(':'))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    \"\"\"Converts minutes since midnight to a time string 'HH:MM'.\"\"\"\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\ndef compute_free_intervals(busy_intervals, work_start, work_end):\n    \"\"\"\n    Given a list of busy intervals [(start, end), ...] in minutes (sorted and non-overlapping)\n    and the overall work period [work_start, work_end],\n    returns a list of free intervals.\n    \"\"\"\n    free = []\n    current = work_start\n    for start, end in busy_intervals:\n        if start > current:\n            free.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Intersect two lists of intervals.\"\"\"\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Overlap interval:\n        start = max(start1, start2)\n        end = min(end1, end2)\n        if start < end:\n            result.append((start, end))\n        # Move pointer for the interval that ends first\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef find_meeting_slot(free_schedule, duration):\n    \"\"\"\n    Given a list of free intervals (in minutes) and required duration (in minutes),\n    return the earliest time slot (start, end) that can accommodate the meeting.\n    \"\"\"\n    for start, end in free_schedule:\n        if end - start >= duration:\n            return (start, start + duration)\n    return None\n\ndef main():\n    # Convert working hours into minutes\n    work_start = time_to_minutes(\"09:00\")\n    work_end = time_to_minutes(\"17:00\")\n    meeting_duration = 60  # in minutes\n\n    # Busy intervals for each participant (converted to minutes)\n    # Jacob's meetings: 10:00-11:00, 11:30-12:00, 16:00-16:30\n    jacob_busy = [(time_to_minutes(\"10:00\"), time_to_minutes(\"11:00\")),\n                  (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n                  (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))]\n\n    # Gabriel's meetings: 9:30-11:30, 13:00-13:30, 15:00-15:30\n    gabriel_busy = [(time_to_minutes(\"09:30\"), time_to_minutes(\"11:30\")),\n                    (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n                    (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\"))]\n\n    # Matthew's meetings: 9:00-9:30, 10:30-11:00, 11:30-12:00, 12:30-14:00, 15:30-16:30\n    matthew_busy = [(time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n                    (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n                    (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n                    (time_to_minutes(\"12:30\"), time_to_minutes(\"14:00\")),\n                    (time_to_minutes(\"15:30\"), time_to_minutes(\"16:30\"))]\n\n    # Compute free intervals for each person\n    jacob_free = compute_free_intervals(jacob_busy, work_start, work_end)\n    gabriel_free = compute_free_intervals(gabriel_busy, work_start, work_end)\n    matthew_free = compute_free_intervals(matthew_busy, work_start, work_end)\n\n    # Find common free intervals across all participants by intersection\n    common_free = intersect_intervals(jacob_free, gabriel_free)\n    common_free = intersect_intervals(common_free, matthew_free)\n\n    # Find a slot with meeting duration\n    meeting_slot = find_meeting_slot(common_free, meeting_duration)\n\n    if meeting_slot:\n        start_time = minutes_to_time(meeting_slot[0])\n        end_time = minutes_to_time(meeting_slot[1])\n        print(f\"{{{start_time}:{end_time}}}\")\n    else:\n        print(\"No common meeting slot available.\")\n\nif __name__ == \"__main__\":\n    main()\n'''",
            "count": "calendar_scheduling_example_40"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "'''python\ndef schedule_meeting():\n    # Duration of the meeting in minutes\n    meeting_duration = 30\n    \n    # Helper functions to convert between \"HH:MM\" and minutes\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(\":\"))\n        return h * 60 + m\n\n    def minutes_to_time_str(minutes):\n        h = minutes // 60\n        m = minutes % 60\n        return f\"{h:02d}:{m:02d}\"\n    \n    # Define working hours (in minutes)\n    work_start = time_to_minutes(\"09:00\")\n    work_end = time_to_minutes(\"17:00\")\n    \n    # Alan's constraint: he does not want to meet before 14:30.\n    alan_earliest = time_to_minutes(\"14:30\")\n    \n    # Busy intervals for Nancy (each tuple= (start_time, end_time))\n    nancy_busy = [\n        (time_to_minutes(\"11:00\"), time_to_minutes(\"12:30\")),\n        (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n        (time_to_minutes(\"14:00\"), time_to_minutes(\"15:00\"))\n    ]\n    \n    # Busy intervals for Patricia\n    patricia_busy = [\n        (time_to_minutes(\"10:00\"), time_to_minutes(\"12:00\")),\n        (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\")),\n        (time_to_minutes(\"13:30\"), time_to_minutes(\"16:00\"))\n    ]\n    \n    # Alan has no meetings, but his availability starts at 14:30.\n    # Combine Nancy's and Patricia's busy intervals\n    busy_intervals = nancy_busy + patricia_busy\n    \n    # Sort intervals by start time and merge overlapping ones\n    busy_intervals.sort(key=lambda x: x[0])\n    merged_busy = []\n    for start, end in busy_intervals:\n        if not merged_busy or start > merged_busy[-1][1]:\n            merged_busy.append([start, end])\n        else:\n            merged_busy[-1][1] = max(merged_busy[-1][1], end)\n            \n    # Determine free intervals within working hours\n    free_intervals = []\n    current = work_start\n    for interval in merged_busy:\n        busy_start, busy_end = interval\n        if current < busy_start:\n            free_intervals.append((current, busy_start))\n        current = max(current, busy_end)\n    if current < work_end:\n        free_intervals.append((current, work_end))\n    \n    # Adjust free intervals considering Alan's constraint (meeting must start no earlier than 14:30)\n    adjusted_free = []\n    for start, end in free_intervals:\n        if end > alan_earliest:\n            # Ensure start time is the maximum of the free interval's start and Alan's earliest available time\n            adjusted_free.append((max(start, alan_earliest), end))\n    \n    # Look for a free interval that can accommodate the meeting duration\n    for start, end in adjusted_free:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Print the meeting time in the \"HH:MM:HH:MM\" format\n            print(f\"{minutes_to_time_str(meeting_start)}:{minutes_to_time_str(meeting_end)}\")\n            return\n    \n    print(\"No valid meeting time found.\")\n\nif __name__ == \"__main__\":\n    schedule_meeting()\n'''",
            "count": "calendar_scheduling_example_41"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import timedelta, datetime\n\n# Helper functions\ndef time_to_minutes(t):\n    # t in \"HH:MM\" format to minutes since midnight\n    hours, minutes = map(int, t.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(m):\n    # m: minutes since midnight to \"HH:MM\"\n    hours = m // 60\n    mins = m % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\ndef invert_busy_intervals(busy, work_start, work_end):\n    free = []\n    if busy:\n        # if there's free time before the first busy interval\n        if busy[0][0] > work_start:\n            free.append((work_start, busy[0][0]))\n        # between busy intervals\n        for i in range(len(busy) - 1):\n            if busy[i][1] < busy[i+1][0]:\n                free.append((busy[i][1], busy[i+1][0]))\n        # if there's free time after the last busy period\n        if busy[-1][1] < work_end:\n            free.append((busy[-1][1], work_end))\n    else:\n        free.append((work_start, work_end))\n    return free\n\ndef intersect_intervals(intervals_a, intervals_b):\n    # Given two lists of intervals, return their intersection intervals\n    intersection = []\n    i = j = 0\n    while i < len(intervals_a) and j < len(intervals_b):\n        start_a, end_a = intervals_a[i]\n        start_b, end_b = intervals_b[j]\n        # Find the overlapping portion\n        start_overlap = max(start_a, start_b)\n        end_overlap = min(end_a, end_b)\n        if start_overlap < end_overlap:\n            intersection.append((start_overlap, end_overlap))\n        # Move to the next interval\n        if end_a < end_b:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\ndef find_meeting_time(free_intervals, duration):\n    for start, end in free_intervals:\n        if end - start >= duration:\n            return (start, start + duration)\n    return None\n\n# Define work hours in minutes (9:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nmeeting_duration = 60  # in minutes\n\n# Given busy schedules for each participant (times in minutes)\n# Julie busy: 9:00-9:30, 11:00-11:30, 12:00-12:30, 13:30-14:00, 16:00-17:00\njulie_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"11:30\")),\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n    (time_to_minutes(\"13:30\"), time_to_minutes(\"14:00\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"17:00\"))\n]\n\n# Sean busy: 9:00-9:30, 13:00-13:30, 15:00-15:30, 16:00-16:30\nsean_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n    (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))\n]\n\n# Lori busy: 10:00-10:30, 11:00-13:00, 15:30-17:00\nlori_busy = [\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"17:00\"))\n]\n\n# Compute free intervals for each participant\njulie_free = invert_busy_intervals(julie_busy, work_start, work_end)\nsean_free = invert_busy_intervals(sean_busy, work_start, work_end)\nlori_free = invert_busy_intervals(lori_busy, work_start, work_end)\n\n# Find common free intervals by intersecting free intervals of all participants\ncommon_free = intersect_intervals(julie_free, sean_free)\ncommon_free = intersect_intervals(common_free, lori_free)\n\n# Find a valid meeting time from the common free intervals that satisfies the meeting duration\nmeeting_slot = find_meeting_time(common_free, meeting_duration)\n\nif meeting_slot:\n    start_time = minutes_to_time(meeting_slot[0])\n    end_time = minutes_to_time(meeting_slot[1])\n    print(f\"{{{start_time}:{end_time}}}\")\nelse:\n    print(\"No common available meeting slot found.\")\n'''",
            "count": "calendar_scheduling_example_42"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "'''python\ndef to_minutes(t):\n    \"\"\"Convert HH:MM string to minutes since midnight.\"\"\"\n    hours, minutes = map(int, t.split(\":\"))\n    return hours * 60 + minutes\n\ndef to_str(minutes):\n    \"\"\"Convert minutes since midnight to HH:MM string.\"\"\"\n    h = minutes // 60\n    m = minutes % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef get_free_intervals(busy, start, end):\n    \"\"\"Given a list of busy intervals and work day boundaries, return free intervals.\"\"\"\n    free = []\n    prev = start\n    for s, e in sorted(busy):\n        if prev < s:\n            free.append((prev, s))\n        prev = max(prev, e)\n    if prev < end:\n        free.append((prev, end))\n    return free\n\ndef intersect_intervals(list1, list2):\n    \"\"\"Intersect two lists of intervals.\"\"\"\n    res = []\n    i, j = 0, 0\n    while i < len(list1) and j < len(list2):\n        a, b = list1[i]\n        c, d = list2[j]\n        inter_start = max(a, c)\n        inter_end = min(b, d)\n        if inter_start < inter_end:\n            res.append((inter_start, inter_end))\n        # Move on to the next interval in whichever ends first\n        if b < d:\n            i += 1\n        else:\n            j += 1\n    return res\n\n# Define work day parameters and meeting duration (in minutes):\nwork_start = to_minutes(\"09:00\")\nwork_end = to_minutes(\"17:00\")\nmeeting_duration = 30\n\n# Define busy schedules for each participant (times in HH:MM):\nalbert_busy = [\n    (to_minutes(\"09:30\"), to_minutes(\"10:30\")),\n    (to_minutes(\"12:00\"), to_minutes(\"12:30\")),\n    (to_minutes(\"14:00\"), to_minutes(\"14:30\")),\n    (to_minutes(\"15:00\"), to_minutes(\"15:30\")),\n    (to_minutes(\"16:30\"), to_minutes(\"17:00\"))\n]\n\ngregory_busy = [\n    (to_minutes(\"11:00\"), to_minutes(\"11:30\")),\n    (to_minutes(\"12:30\"), to_minutes(\"13:00\")),\n    (to_minutes(\"13:30\"), to_minutes(\"14:00\")),\n    (to_minutes(\"15:30\"), to_minutes(\"16:00\"))\n]\n\nbenjamin_busy = [\n    (to_minutes(\"09:30\"), to_minutes(\"10:00\")),\n    (to_minutes(\"10:30\"), to_minutes(\"11:00\")),\n    (to_minutes(\"11:30\"), to_minutes(\"13:30\")),\n    (to_minutes(\"14:00\"), to_minutes(\"15:00\")),\n    (to_minutes(\"15:30\"), to_minutes(\"16:00\")),\n    (to_minutes(\"16:30\"), to_minutes(\"17:00\"))\n]\n\n# Compute free intervals for each participant:\nalbert_free = get_free_intervals(albert_busy, work_start, work_end)\ngregory_free = get_free_intervals(gregory_busy, work_start, work_end)\nbenjamin_free = get_free_intervals(benjamin_busy, work_start, work_end)\n\n# Compute common free intervals:\ncommon_free = intersect_intervals(albert_free, gregory_free)\ncommon_free = intersect_intervals(common_free, benjamin_free)\n\n# Find earliest available slot that fits the meeting duration:\nproposed_time = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        proposed_time = (start, start + meeting_duration)\n        break\n\nif proposed_time:\n    print(f\"{to_str(proposed_time[0])}:{to_str(proposed_time[1])}\")\nelse:\n    print(\"No common time found\")\n'''",
            "count": "calendar_scheduling_example_43"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\ndef time_to_minutes(t):\n    \"\"\"Convert time string in HH:MM format to minutes since midnight.\"\"\"\n    h, m = map(int, t.split(':'))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    \"\"\"Convert minutes since midnight to HH:MM format.\"\"\"\n    return f\"{m//60:02d}:{m%60:02d}\"\n\ndef intersect_intervals(intervals_a, intervals_b):\n    \"\"\"Return the intersection of two lists of intervals.\n    Each interval is a tuple (start, end) in minutes.\n    \"\"\"\n    i, j = 0, 0\n    result = []\n    while i < len(intervals_a) and j < len(intervals_b):\n        start_a, end_a = intervals_a[i]\n        start_b, end_b = intervals_b[j]\n        # Find the overlap between intervals_a[i] and intervals_b[j]\n        start_overlap = max(start_a, start_b)\n        end_overlap = min(end_a, end_b)\n        if start_overlap < end_overlap:\n            result.append((start_overlap, end_overlap))\n        # Move the pointer that ends earlier.\n        if end_a < end_b:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Meeting parameters\nmeeting_duration = 30  # minutes\n\n# Define working hours and Isabella's preference (no meeting after 13:00)\n# Work hours: 09:00 to 17:00, but Isabella prefers before 13:00.\nwork_start = time_to_minutes(\"09:00\")\nisabella_end = time_to_minutes(\"13:00\")  # Isabella's preferred end time\ncommon_window = (work_start, isabella_end)\n\n# Define each participant's free intervals (in minutes) within the common_window.\n# Isabella is free all day, but by preference she wants the meeting before 13:00.\nisabella_free = [(max(work_start, common_window[0]), common_window[1])]\n\n# Ronald's free intervals on Monday (within work hours):\n# Free: 09:00-11:30, 12:00-14:00. But we need to restrict to before 13:00.\nronald_free = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"11:30\")),\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"14:00\"))\n]\n# Intersect Ronald's free intervals with the common window [09:00,13:00]\nronald_free = intersect_intervals(ronald_free, [common_window])\n\n# Amanda's free intervals on Monday:\n# Free: 09:00-09:30, 12:00-12:30, 13:00-13:30, etc.\namanda_free = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\"))\n]\n# Restrict Amanda's free intervals to the common window [09:00,13:00]\namanda_free = intersect_intervals(amanda_free, [common_window])\n\n# Now, find the common free intervals for all participants.\ncommon_free = intersect_intervals(isabella_free, ronald_free)\ncommon_free = intersect_intervals(common_free, amanda_free)\n\n# Search for the first interval that can accommodate the meeting duration.\nscheduled_time = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        scheduled_time = (start, start + meeting_duration)\n        break\n\nif scheduled_time:\n    start_str = minutes_to_time(scheduled_time[0])\n    end_str = minutes_to_time(scheduled_time[1])\n    # The required format is HH:MM:HH:MM\n    print(f\"{start_str}:{end_str}\")\nelse:\n    print(\"No common meeting slot found.\")\n'''",
            "count": "calendar_scheduling_example_44"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\ndef minutes_to_time_str(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Meeting parameters\nmeeting_duration = 30  # in minutes\n\n# Work hours in minutes from midnight\nwork_start = 9 * 60   # 9:00 AM -> 540 minutes\nwork_end   = 17 * 60  # 17:00 (5 PM) -> 1020 minutes\n\n# Samuel's blocked intervals (in minutes)\n# Each interval is a tuple: (start, end)\nblocked_intervals = [\n    (9 * 60, 10 * 60 + 30),     # 09:00 to 10:30 -> (540, 630)\n    (11 * 60 + 30, 12 * 60),     # 11:30 to 12:00 -> (690, 720)\n    (13 * 60, 13 * 60 + 30),     # 13:00 to 13:30 -> (780, 810)\n    (14 * 60, 16 * 60),          # 14:00 to 16:00 -> (840, 960)\n    (16 * 60 + 30, 17 * 60)      # 16:30 to 17:00 -> (990, 1020)\n]\n\n# Sort blocked intervals by start time, though they should already be sorted.\nblocked_intervals.sort(key=lambda interval: interval[0])\n\n# Initialize current_time as work day start\ncurrent_time = work_start\n\n# Find the earliest free slot for the meeting\nmeeting_start = None\n\nfor interval in blocked_intervals:\n    free_interval = interval[0] - current_time  # length of free time before this block\n    if free_interval >= meeting_duration:\n        meeting_start = current_time\n        break\n    # Update current_time to the later end of the current block if needed\n    if current_time < interval[1]:\n        current_time = interval[1]\n\n# If no slot was found in between blocked intervals, check after last meeting\nif meeting_start is None and work_end - current_time >= meeting_duration:\n    meeting_start = current_time\n\nif meeting_start is not None:\n    meeting_end = meeting_start + meeting_duration\n    # Format times as HH:MM:HH:MM\n    output = f\"{{{minutes_to_time_str(meeting_start)}:{minutes_to_time_str(meeting_end)}}}\"\n    print(output)\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_45"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\ndef time_to_minutes(t):\n    h, m = map(int, t.split(':'))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef intersect_intervals(intervals1, intervals2):\n    result = []\n    for start1, end1 in intervals1:\n        for start2, end2 in intervals2:\n            start = max(start1, start2)\n            end = min(end1, end2)\n            if start + duration <= end:\n                result.append((start, end))\n    return result\n\n# Meeting duration in minutes\nduration = 30\n\n# Work day in minutes [start, end]\nwork_start = time_to_minutes(\"09:00\")\nwork_end   = time_to_minutes(\"17:00\")\nwork_interval = [(work_start, work_end)]\n\n# Blocked schedules for each participant converted to minute intervals.\n# Arthur has blocked: 09:30-10:00, 14:00-14:30\narthur_blocks = [(time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n                 (time_to_minutes(\"14:00\"), time_to_minutes(\"14:30\"))]\n\n# Theresa has meetings on: 09:00-09:30, 12:00-13:00, 15:00-16:30\ntheresa_blocks = [(time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n                  (time_to_minutes(\"12:00\"), time_to_minutes(\"13:00\")),\n                  (time_to_minutes(\"15:00\"), time_to_minutes(\"16:30\"))]\n\n# Carl has blocked: 09:00-11:30, 12:00-14:00, 14:30-17:00\ncarl_blocks = [(time_to_minutes(\"09:00\"), time_to_minutes(\"11:30\")),\n               (time_to_minutes(\"12:00\"), time_to_minutes(\"14:00\")),\n               (time_to_minutes(\"14:30\"), time_to_minutes(\"17:00\"))]\n\ndef get_free_intervals(blocks, work_interval):\n    free = []\n    for work_start, work_end in work_interval:\n        current = work_start\n        for block_start, block_end in sorted(blocks):\n            if current < block_start:\n                free.append((current, block_start))\n            current = max(current, block_end)\n        if current < work_end:\n            free.append((current, work_end))\n    return free\n\n# Compute free intervals for each participant\narthur_free = get_free_intervals(arthur_blocks, work_interval)\ntheresa_free = get_free_intervals(theresa_blocks, work_interval)\ncarl_free = get_free_intervals(carl_blocks, work_interval)\n\n# Find common free intervals between Arthur and Theresa\ncommon_free = intersect_intervals(arthur_free, theresa_free)\n# Then intersect with Carl's free intervals\ncommon_free = intersect_intervals(common_free, carl_free)\n\n# Select the earliest time slot that fits the meeting duration\nmeeting_time = None\nfor start, end in common_free:\n    if end - start >= duration:\n        meeting_time = (start, start + duration)\n        break\n\nif meeting_time:\n    meeting_str = f\"{{{minutes_to_time(meeting_time[0])}:{minutes_to_time(meeting_time[1])}}}\"\n    print(meeting_str)\nelse:\n    print(\"No available time slot.\")\n'''",
            "count": "calendar_scheduling_example_46"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_time(minutes):\n    \"\"\"Convert minutes (since midnight) to a HH:MM string.\"\"\"\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\ndef interval_intersection(intervals1, intervals2):\n    \"\"\"Return the intersection of two lists of intervals.\n    Each interval is a tuple (start, end) in minutes.\n    \"\"\"\n    result = []\n    i, j = 0, 0\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        start_int = max(start1, start2)\n        end_int = min(end1, end2)\n        if start_int < end_int:\n            result.append((start_int, end_int))\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef find_meeting_time():\n    # Meeting duration in minutes (1 hour)\n    meeting_duration = 60\n\n    # Workday in minutes: 9:00 = 540, 17:00 = 1020\n    work_start = 540\n    work_end = 1020\n    work_interval = [(work_start, work_end)]\n    \n    # Define busy intervals for each participant (start, end in minutes)\n    # David is free all day so his free interval is just the work interval.\n    \n    # Eric's meetings: 9:00-9:30, 10:30-11:30, 15:00-15:30\n    eric_busy = [(540, 570), (630, 690), (900, 930)]\n    # Roger's meetings: 9:30-10:30, 11:00-12:00, 12:30-13:00, 14:30-15:00, 15:30-16:30\n    roger_busy = [(570, 630), (660, 720), (750, 780), (870, 900), (930, 990)]\n    \n    # Function to compute free intervals given busy intervals and overall availability\n    def get_free_intervals(busy, overall):\n        free = []\n        for start, end in overall:\n            current = start\n            for b_start, b_end in busy:\n                if b_start > current:\n                    free.append((current, min(b_start, end)))\n                current = max(current, b_end)\n                if current >= end:\n                    break\n            if current < end:\n                free.append((current, end))\n        return free\n\n    # Free intervals for each participant\n    david_free = work_interval  # David is free all day\n    eric_free = get_free_intervals(eric_busy, work_interval)\n    roger_free = get_free_intervals(roger_busy, work_interval)\n    \n    # Now find common free intervals across all participants\n    # First, intersect Eric and Roger's free intervals\n    common_free = interval_intersection(eric_free, roger_free)\n    # Then, since David is free all day, common intervals remain the same.\n\n    # Select the first interval that can accommodate the meeting duration\n    for start, end in common_free:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = start + meeting_duration\n            # Output the proposed meeting time in format HH:MM:HH:MM\n            print(f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\")\n            return\n\nfind_meeting_time()\n'''",
            "count": "calendar_scheduling_example_47"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_time(minutes):\n    h = minutes // 60\n    m = minutes % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef subtract_intervals(base, intervals):\n    # Given a base interval and a list of intervals to subtract (assumed sorted, non overlapping),\n    # return a list of free intervals (start, end) in minutes.\n    free = []\n    start, end = base\n    current = start\n    for b_start, b_end in intervals:\n        if b_start > current:\n            free.append((current, min(b_start, end)))\n        current = max(current, b_end)\n        if current >= end:\n            break\n    if current < end:\n        free.append((current, end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    # Given two lists of intervals, return their intersection.\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        start = max(intervals1[i][0], intervals2[j][0])\n        end = min(intervals1[i][1], intervals2[j][1])\n        if start < end:\n            result.append((start, end))\n        # Move the pointer with the smaller endpoint\n        if intervals1[i][1] < intervals2[j][1]:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Define working hours in minutes (9:00 to 17:00)\nwork_start = 9 * 60  # 540\nwork_end = 17 * 60   # 1020\nwork_interval = (work_start, work_end)\n\n# Busy intervals for each participant (in minutes from midnight)\njanet_busy = [(9*60+30, 10*60+30), (12*60+30, 13*60), (14*60, 14*60+30)]\nrachel_busy = []  # No meetings\ncynthia_busy = [(9*60+30, 10*60), (11*60, 11*60+30), (12*60+30, 14*60+30), (16*60, 17*60)]\n\n# Get free intervals for each participant by subtracting their busy intervals from the work interval.\n# Assume busy intervals are sorted.\njanet_free = subtract_intervals(work_interval, janet_busy)\nrachel_free = subtract_intervals(work_interval, rachel_busy)\ncynthia_free = subtract_intervals(work_interval, cynthia_busy)\n\n# Intersect free intervals for all participants\nintersect_free = intersect_intervals(janet_free, rachel_free)\nintersect_free = intersect_intervals(intersect_free, cynthia_free)\n\n# Cynthia prefers not to meet before 13:30 (which is 13*60+30 = 810 minutes)\npreferred_start = 13*60 + 30  # 810\nmeeting_duration = 60\n\n# Find the first time slot that fits the meeting duration and preferred start constraint.\nproposed_start = None\nfor start, end in intersect_free:\n    # Ensure the meeting starts no earlier than 13:30\n    available_start = max(start, preferred_start)\n    if end - available_start >= meeting_duration:\n        proposed_start = available_start\n        proposed_end = available_start + meeting_duration\n        break\n\nif proposed_start is None:\n    print(\"No available meeting time found.\")\nelse:\n    # Print in the format {HH:MM:HH:MM}\n    meeting_time = f\"{{{minutes_to_time(proposed_start)}:{minutes_to_time(proposed_end)}}}\"\n    print(meeting_time)\n'''",
            "count": "calendar_scheduling_example_48"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    # Converts \"HH:MM\" to total minutes from midnight.\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    # Converts total minutes from midnight to \"HH:MM\" format.\n    return f\"{minutes//60:02d}:{minutes%60:02d}\"\n\n# Meeting duration in minutes\nmeeting_duration = 30\n\n# Work day boundaries (9:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Kathleen prefers that the meeting does not extend after 14:30.\n# So the meeting must end by 14:30.\nlatest_meeting_end_for_kathleen = time_to_minutes(\"14:30\")\n# Thus the meeting must start no later than:\nlatest_meeting_start = latest_meeting_end_for_kathleen - meeting_duration\n\n# Busy intervals for each participant (start and end times in minutes)\n# Teresa: [9:00-10:00, 13:00-13:30, 14:00-14:30, 15:00-15:30, 16:30-17:00]\nteresa_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"14:30\")),\n    (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\")),\n    (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))\n]\n\n# Kathleen: [9:00-9:30, 12:30-13:00, 13:30-14:00, 15:00-15:30]\nkathleen_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"13:30\"), time_to_minutes(\"14:00\")),\n    (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\"))\n]\n\n# Patricia: [9:00-10:30, 11:30-12:00, 13:00-13:30, 14:00-14:30, 15:30-16:00, 16:30-17:00]\npatricia_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"14:30\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\")),\n    (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))\n]\n\ndef is_free(start, busy_periods):\n    \"\"\"\n    Check if a meeting starting at 'start' for 'meeting_duration'\n    does not conflict with any busy interval in busy_periods.\n    \"\"\"\n    meeting_end = start + meeting_duration\n    for busy_start, busy_end in busy_periods:\n        # Check if meeting [start, meeting_end) overlaps with busy interval.\n        if start < busy_end and meeting_end > busy_start:\n            return False\n    return True\n\n# Combine all constraints: meeting must be within work hours, must end by 14:30 for Kathleen,\n# and must not conflict with any participant's busy intervals.\n# We iterate over possible start times (in minutes) from work_start to latest_meeting_start.\nfound_meeting = False\nmeeting_start_time = None\n\nfor t in range(work_start, latest_meeting_start + 1):\n    meeting_end = t + meeting_duration\n    # Ensure meeting is within overall work hours\n    if meeting_end > work_end:\n        continue\n    # Kathleen's constraint: meeting_end must be <= 14:30.\n    if meeting_end > latest_meeting_end_for_kathleen:\n        continue\n    # Check each participant.\n    if (is_free(t, teresa_busy) and\n        is_free(t, kathleen_busy) and\n        is_free(t, patricia_busy)):\n        meeting_start_time = t\n        found_meeting = True\n        break\n\nif found_meeting:\n    meeting_end_time = meeting_start_time + meeting_duration\n    # Output in the format HH:MM:HH:MM\n    print(f\"{minutes_to_time(meeting_start_time)}:{minutes_to_time(meeting_end_time)}\")\nelse:\n    print(\"No available meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_49"
        },
        {
            "final_program_time": "{13:30:14:30}",
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Define work hours and meeting duration\nworking_start = \"09:00\"\nworking_end = \"17:00\"\nmeeting_duration = 60  # in minutes\n\n# Busy times for Emma\nbusy_times = [\n    (\"09:00\", \"10:30\"),\n    (\"11:00\", \"12:00\"),\n    (\"12:30\", \"13:30\"),\n    (\"14:30\", \"15:30\"),\n    (\"16:00\", \"16:30\")\n]\n\n# Convert work hours to minutes\nstart_work = time_to_minutes(working_start)\nend_work = time_to_minutes(working_end)\n\n# Sort busy intervals (they are already sorted, but this ensures order)\nbusy_times.sort(key=lambda interval: time_to_minutes(interval[0]))\n\n# Find free slots\nfree_slots = []\ncurrent_time = start_work\n\nfor busy_start_str, busy_end_str in busy_times:\n    busy_start = time_to_minutes(busy_start_str)\n    busy_end = time_to_minutes(busy_end_str)\n    if busy_start > current_time:\n        free_slots.append((current_time, busy_start))\n    current_time = max(current_time, busy_end)\n\nif current_time < end_work:\n    free_slots.append((current_time, end_work))\n\n# Look for a slot with enough duration\nmeeting_slot = None\nfor free_start, free_end in free_slots:\n    if free_end - free_start >= meeting_duration:\n        meeting_slot = (free_start, free_start + meeting_duration)\n        break\n\n# Output the meeting time in the format HH:MM:HH:MM\nif meeting_slot:\n    start_meeting = minutes_to_time(meeting_slot[0])\n    end_meeting   = minutes_to_time(meeting_slot[1])\n    print(\"{\" + start_meeting + \":\" + end_meeting + \"}\")\nelse:\n    print(\"No available meeting slot.\")\n'''",
            "count": "calendar_scheduling_example_50"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_str(m):\n    hh = m // 60\n    mm = m % 60\n    return f\"{hh:02d}:{mm:02d}\"\n\ndef get_free_intervals(busy_intervals, work_start, work_end):\n    # Assumes busy_intervals are sorted by start time.\n    free = []\n    current = work_start\n    for start, end in sorted(busy_intervals):\n        if start > current:\n            free.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    # Given two lists of intervals, return their intersection.\n    i, j = 0, 0\n    intersection = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find overlap between intervals\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap < end_overlap:\n            intersection.append((start_overlap, end_overlap))\n        # Move the pointer with the earlier finishing interval.\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\ndef find_meeting_time(common_free, duration):\n    for start, end in common_free:\n        if end - start >= duration:\n            return start, start + duration\n    return None\n\ndef main():\n    # Working hours: 9:00 to 17:00 in minutes\n    work_start = 9 * 60   # 540\n    work_end = 17 * 60    # 1020\n    meeting_duration = 60  # in minutes\n\n    # Busy intervals in minutes for each participant (start, end)\n    # Brandon: 11:30-12:00, 12:30-13:30, 14:00-14:30\n    brandon_busy = [(11*60+30, 12*60), (12*60+30, 13*60+30), (14*60, 14*60+30)]\n    # Donna: 10:00-10:30, 12:00-12:30\n    donna_busy = [(10*60, 10*60+30), (12*60, 12*60+30)]\n    # Jack: 9:30-10:00, 10:30-11:00, 11:30-12:30, 13:00-14:30, 15:30-17:00\n    jack_busy = [(9*60+30, 10*60), (10*60+30, 11*60), (11*60+30, 12*60+30),\n                 (13*60, 14*60+30), (15*60+30, 17*60)]\n\n    # Calculate free intervals for each participant\n    brandon_free = get_free_intervals(brandon_busy, work_start, work_end)\n    donna_free = get_free_intervals(donna_busy, work_start, work_end)\n    jack_free = get_free_intervals(jack_busy, work_start, work_end)\n\n    # Find common free intervals across all participants\n    common_free = intersect_intervals(brandon_free, donna_free)\n    common_free = intersect_intervals(common_free, jack_free)\n\n    # Find a common interval that can fit the meeting duration\n    meeting_slot = find_meeting_time(common_free, meeting_duration)\n    if meeting_slot:\n        start, end = meeting_slot\n        # Format output as HH:MM:HH:MM\n        print(f\"{minutes_to_str(start)}:{minutes_to_str(end)}\")\n    else:\n        print(\"No available time slot found.\")\n\nif __name__ == \"__main__\":\n    main()\n'''",
            "count": "calendar_scheduling_example_51"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\ndef time_to_minutes(t):\n    \"\"\"Converts a time string HH:MM to minutes since midnight.\"\"\"\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    \"\"\"Converts minutes since midnight to time string HH:MM.\"\"\"\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef subtract_busy_intervals(free_interval, busy_intervals):\n    \"\"\"\n    Given a free interval (start, end) and a list of busy intervals,\n    subtract the busy intervals from the free interval.\n    Returns a list of resulting free intervals.\n    \"\"\"\n    free_parts = [free_interval]\n    for busy in busy_intervals:\n        new_free = []\n        for part in free_parts:\n            start, end = part\n            # If no overlap, continue\n            if busy[1] <= start or busy[0] >= end:\n                new_free.append(part)\n            else:\n                # left part\n                if busy[0] > start:\n                    new_free.append((start, busy[0]))\n                # right part\n                if busy[1] < end:\n                    new_free.append((busy[1], end))\n        free_parts = new_free\n    return free_parts\n\ndef get_free_intervals(work_interval, busy_intervals):\n    \"\"\"\n    Given overall work_interval (start, end) and sorted busy intervals within it,\n    return the list of free intervals.\n    \"\"\"\n    return subtract_busy_intervals(work_interval, busy_intervals)\n\ndef intersect_intervals(intervals_a, intervals_b):\n    \"\"\"\n    Given two lists of intervals, compute the intersection intervals.\n    Each interval is a tuple (start, end) in minutes.\n    \"\"\"\n    result = []\n    i, j = 0, 0\n    while i < len(intervals_a) and j < len(intervals_b):\n        start = max(intervals_a[i][0], intervals_b[j][0])\n        end = min(intervals_a[i][1], intervals_b[j][1])\n        if start < end:\n            result.append((start, end))\n        # Move the interval that ends earlier.\n        if intervals_a[i][1] < intervals_b[j][1]:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef main():\n    # Work hours: 9:00 to 17:00\n    work_interval = (time_to_minutes(\"09:00\"), time_to_minutes(\"17:00\"))\n    \n    meeting_duration = 60  # minutes\n\n    # Busy intervals for each participant in minutes:\n    # Grace: 9:00-9:30, 10:00-11:00, 16:00-16:30\n    grace_busy = [\n        (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n        (time_to_minutes(\"10:00\"), time_to_minutes(\"11:00\")),\n        (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))\n    ]\n    # Randy: 12:30-13:00, 16:00-16:30\n    randy_busy = [\n        (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\")),\n        (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))\n    ]\n    # Susan: 9:00-14:30, 15:30-16:00\n    susan_busy = [\n        (time_to_minutes(\"09:00\"), time_to_minutes(\"14:30\")),\n        (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\"))\n    ]\n    \n    grace_free = get_free_intervals(work_interval, grace_busy)\n    randy_free = get_free_intervals(work_interval, randy_busy)\n    susan_free = get_free_intervals(work_interval, susan_busy)\n    \n    # First get common free intervals for Grace and Randy\n    common_free = intersect_intervals(grace_free, randy_free)\n    # Then intersect with Susan's free intervals\n    common_free = intersect_intervals(common_free, susan_free)\n    \n    meeting_time = None\n    \n    # Find an interval that can accommodate the meeting duration\n    for start, end in common_free:\n        if end - start >= meeting_duration:\n            meeting_time = (start, start + meeting_duration)\n            break\n\n    if meeting_time:\n        start_time = minutes_to_time(meeting_time[0])\n        end_time = minutes_to_time(meeting_time[1])\n        # Output in the format {HH:MM:HH:MM}\n        print(f\"{{{start_time}:{end_time}}}\")\n    else:\n        print(\"No possible meeting slot found.\")\n\nif __name__ == \"__main__\":\n    main()\n'''",
            "count": "calendar_scheduling_example_52"
        },
        {
            "final_program_time": "{15:30:16:30}",
            "expected_time": "{15:30:16:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    \"\"\"Convert time string 'HH:MM' to minutes since midnight.\"\"\"\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    \"\"\"Convert minutes since midnight to time string 'HH:MM'.\"\"\"\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef subtract_busy(time_range, busy_intervals):\n    \"\"\"Subtract busy intervals from a given time range.\n       Both time_range and busy_intervals use minutes.\n       Returns a list of free intervals (as tuples) within time_range.\n    \"\"\"\n    free_intervals = []\n    current_start = time_range[0]\n    for busy in busy_intervals:\n        busy_start, busy_end = busy\n        if busy_start > current_start:\n            free_intervals.append((current_start, busy_start))\n        # Move current start forward if busy overlaps with current_start.\n        if busy_end > current_start:\n            current_start = max(current_start, busy_end)\n    if current_start < time_range[1]:\n        free_intervals.append((current_start, time_range[1]))\n    return free_intervals\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Intersect two lists of intervals.\"\"\"\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        a_start, a_end = intervals1[i]\n        b_start, b_end = intervals2[j]\n        # Find overlap\n        start = max(a_start, b_start)\n        end = min(a_end, b_end)\n        if start < end:\n            result.append((start, end))\n        # Advance the interval that ends earlier.\n        if a_end < b_end:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef find_common_slot(free_lists, duration):\n    \"\"\"Find a common interval among all free_lists with at least 'duration' minutes.\"\"\"\n    # Start by intersecting intervals for the first two sets and then accumulate.\n    common = free_lists[0]\n    for free in free_lists[1:]:\n        common = intersect_intervals(common, free)\n    # Now find an interval that fits the meeting duration.\n    for interval in common:\n        start, end = interval\n        if (end - start) >= duration:\n            return start, start + duration\n    return None\n\n# Define work day boundaries in minutes.\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nmeeting_duration = 60  # minutes\n\n# Define busy intervals for each participant in minutes.\n# Noah's busy intervals: (none) so he is free all day.\nnoah_busy = []\n\n# Alice's busy intervals: 9:30-10:00, 12:30-13:00, 14:30-15:00, 16:30-17:00\nalice_busy = [\n    (time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))\n]\n\n# Arthur's busy intervals: 9:00-9:30, 10:00-11:00, 11:30-12:00, 13:00-14:00, 15:00-15:30, 16:30-17:00\narthur_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"11:00\")),\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"14:00\")),\n    (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\")),\n    (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))\n]\n\n# Compute free intervals for each participant.\nnoah_free = subtract_busy((work_start, work_end), noah_busy)\nalice_free = subtract_busy((work_start, work_end), alice_busy)\narthur_free = subtract_busy((work_start, work_end), arthur_busy)\n\n# Combine free intervals across all participants.\ncommon_slot = find_common_slot([noah_free, alice_free, arthur_free], meeting_duration)\n\nif common_slot:\n    start, end = common_slot\n    print(f\"{minutes_to_time(start)}:{minutes_to_time(end)}\")\nelse:\n    print(\"No available slot found.\")\n'''",
            "count": "calendar_scheduling_example_53"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    \"\"\"Convert HH:MM to minutes since midnight.\"\"\"\n    h, m = map(int, time_str.split(':'))\n    return h * 60 + m\n\ndef minutes_to_time(minutes):\n    \"\"\"Convert minutes since midnight to HH:MM format.\"\"\"\n    h = minutes // 60\n    m = minutes % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef subtract_intervals(available, block):\n    \"\"\"Subtract block intervals from available intervals.\n       Both available and block are lists of (start, end) in minutes.\n    \"\"\"\n    result = []\n    for start_a, end_a in available:\n        current_start = start_a\n        for start_b, end_b in block:\n            # If no overlap, skip\n            if end_b <= current_start or start_b >= end_a:\n                continue\n            # If there is overlap, add the interval before the block if valid\n            if start_b > current_start:\n                result.append((current_start, start_b))\n            # Move current start to the end of the block if it's inside available\n            if end_b < end_a:\n                current_start = end_b\n            else:\n                current_start = end_a\n                break\n        if current_start < end_a:\n            result.append((current_start, end_a))\n    return result\n\ndef intersect_intervals(list1, list2):\n    \"\"\"Intersect two lists of intervals.\"\"\"\n    result = []\n    i, j = 0, 0\n    while i < len(list1) and j < len(list2):\n        start1, end1 = list1[i]\n        start2, end2 = list2[j]\n        # Find overlap\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap < end_overlap:\n            result.append((start_overlap, end_overlap))\n        # Move pointer with the earlier finishing interval\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Define business hours\nbusiness_start = time_to_minutes(\"09:00\")\nbusiness_end = time_to_minutes(\"17:00\")\nbusiness_hours = [(business_start, business_end)]\n\n# Meeting duration in minutes (1 hour)\nmeeting_duration = 60\n\n# Define blocked intervals for each participant in minutes\n# Isabella: 11:00-11:30, 15:30-16:00\nisabella_blocks = [(time_to_minutes(\"11:00\"), time_to_minutes(\"11:30\")),\n                    (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\"))]\n\n# Tyler: 9:00-10:00; plus cannot meet after 16:00\ntyler_blocks = [(time_to_minutes(\"09:00\"), time_to_minutes(\"10:00\"))]\n# For Tyler, adjust business hours: meeting must end by 16:00, so his effective available hours are 09:00-16:00.\ntyler_business = [(business_start, time_to_minutes(\"16:00\"))]\n\n# Jordan: 9:00-10:00, 10:30-11:00, 12:30-13:30, 14:00-14:30, 15:00-16:00\njordan_blocks = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n    (time_to_minutes(\"12:30\"), time_to_minutes(\"13:30\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"14:30\")),\n    (time_to_minutes(\"15:00\"), time_to_minutes(\"16:00\"))\n]\n\n# Compute free intervals for each participant\n# Isabella free intervals during business hours\nisabella_free = subtract_intervals(business_hours, isabella_blocks)\n\n# Tyler free intervals within his adjusted business hours and subtract his blocks\ntyler_free = subtract_intervals(tyler_business, tyler_blocks)\n\n# Jordan free intervals during business hours subtract his blocks\njordan_free = subtract_intervals(business_hours, jordan_blocks)\n\n# Compute common free intervals among all participants\ncommon_free = intersect_intervals(isabella_free, tyler_free)\ncommon_free = intersect_intervals(common_free, jordan_free)\n\n# Find the earliest common free interval that can accommodate the meeting\nmeeting_time = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        meeting_time = (start, start + meeting_duration)\n        break\n\nif meeting_time:\n    start_str = minutes_to_time(meeting_time[0])\n    end_str = minutes_to_time(meeting_time[1])\n    # Output in the format {HH:MM:HH:MM}\n    print(f\"{{{start_str}:{end_str}}}\")\nelse:\n    print(\"No available meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_54"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "'''python\ndef minutes(time_str):\n    \"\"\"Convert HH:MM to total minutes.\"\"\"\n    h, m = map(int, time_str.split(':'))\n    return h * 60 + m\n\ndef time_str(minutes_val):\n    \"\"\"Convert total minutes to HH:MM format.\"\"\"\n    h = minutes_val // 60\n    m = minutes_val % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef get_free_intervals(busy, start, end):\n    \"\"\"Convert busy intervals into free time intervals within [start, end].\"\"\"\n    busy = sorted(busy)\n    free_intervals = []\n    current = start\n    for bstart, bend in busy:\n        if current < bstart:\n            free_intervals.append((current, bstart))\n        current = max(current, bend)\n    if current < end:\n        free_intervals.append((current, end))\n    return free_intervals\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Find intersection between two lists of intervals.\"\"\"\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        common_start = max(start1, start2)\n        common_end = min(end1, end2)\n        if common_start < common_end:\n            result.append((common_start, common_end))\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef find_common_free(intervals_list):\n    \"\"\"Find common free intervals across all people's schedules.\"\"\"\n    common = intervals_list[0]\n    for intervals in intervals_list[1:]:\n        common = intersect_intervals(common, intervals)\n    return common\n\n# Workday constraints: Monday 09:00 to 17:00\nwork_start = minutes(\"09:00\")  # 540 minutes\nwork_end = minutes(\"17:00\")    # 1020 minutes\n\n# Given busy schedules for each person\n# Keith is busy from 14:00-14:30 and 16:00-16:30\nkeith_busy = [(minutes(\"14:00\"), minutes(\"14:30\")),\n              (minutes(\"16:00\"), minutes(\"16:30\"))]\n\n# Christine is free the entire day\nchristine_busy = []\n\n# Cynthia has meetings from 09:00-10:30 and 11:30-17:00\ncynthia_busy = [(minutes(\"09:00\"), minutes(\"10:30\")),\n                (minutes(\"11:30\"), minutes(\"17:00\"))]\n\n# Get free intervals for each participant\nkeith_free = get_free_intervals(keith_busy, work_start, work_end)\nchristine_free = [(work_start, work_end)]\ncynthia_free = get_free_intervals(cynthia_busy, work_start, work_end)\n\n# Find common free intervals among all participants\ncommon_free = find_common_free([keith_free, christine_free, cynthia_free])\n\nmeeting_duration = 60  # Meeting duration in minutes\n\nproposed_time = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        proposed_time = (start, start + meeting_duration)\n        break\n\nif proposed_time:\n    # Output the meeting time in the format {HH:MM:HH:MM}\n    print(f\"{{{time_str(proposed_time[0])}:{time_str(proposed_time[1])}}}\")\nelse:\n    print(\"No common slot available\")\n'''",
            "count": "calendar_scheduling_example_55"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\n# Define a helper function to convert time string to minutes from midnight\ndef time_to_minutes(t):\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\n# Define a helper function to convert minutes from midnight to time string in HH:MM format\ndef minutes_to_time(m):\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\n# Define meeting duration in minutes\nmeeting_duration = 30\n\n# Define workday boundaries in minutes\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Define busy intervals for each participant (start, end in minutes)\njeremy_busy = [(time_to_minutes(\"12:00\"), time_to_minutes(\"13:00\")),\n               (time_to_minutes(\"13:30\"), time_to_minutes(\"14:00\")),\n               (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\"))]\n\ndonna_busy = [(time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n              (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n              (time_to_minutes(\"16:00\"), time_to_minutes(\"17:00\"))]\n\nrobert_busy = [(time_to_minutes(\"09:00\"), time_to_minutes(\"11:00\")),\n               (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n               (time_to_minutes(\"12:30\"), time_to_minutes(\"17:00\"))]\n\n# A function to compute free intervals given busy intervals and work boundaries\ndef get_free_intervals(busy, start, end):\n    free = []\n    # Sort busy intervals by start time\n    busy = sorted(busy, key=lambda x: x[0])\n    current = start\n    for b_start, b_end in busy:\n        if b_start > current:\n            free.append((current, b_start))\n        current = max(current, b_end)\n    if current < end:\n        free.append((current, end))\n    return free\n\n# Get free intervals for each participant\njeremy_free = get_free_intervals(jeremy_busy, work_start, work_end)\ndonna_free  = get_free_intervals(donna_busy, work_start, work_end)\nrobert_free = get_free_intervals(robert_busy, work_start, work_end)\n\n# A function to compute intersection of two lists of intervals\ndef intersect_intervals(ints1, ints2):\n    intersections = []\n    i, j = 0, 0\n    while i < len(ints1) and j < len(ints2):\n        start1, end1 = ints1[i]\n        start2, end2 = ints2[j]\n        # Find overlap\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap + meeting_duration <= end_overlap:\n            intersections.append((start_overlap, end_overlap))\n        # Move in whichever interval ends first\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersections\n\n# Get intersection between Jeremy and Donna\njd_intersect = intersect_intervals(jeremy_free, donna_free)\n# Then intersect with Robert's free intervals\ncommon_free = intersect_intervals(jd_intersect, robert_free)\n\n# Now, from common_free, select the first interval that can accommodate the meeting duration\nproposed_start = None\nfor interval in common_free:\n    start, end = interval\n    if start + meeting_duration <= end:\n        proposed_start = start\n        break\n\nif proposed_start is not None:\n    proposed_end = proposed_start + meeting_duration\n    result = f\"{{{minutes_to_time(proposed_start)}:{minutes_to_time(proposed_end)}}}\"\n    print(result)\nelse:\n    print(\"No suitable time found.\")\n'''",
            "count": "calendar_scheduling_example_56"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Meeting duration in minutes\nmeeting_duration = 30\n\n# Working hours in minutes (9:00 to 17:00)\nwork_start = 9 * 60     # 540\nwork_end = 17 * 60      # 1020\n\n# Busy schedules (start and end in minutes from midnight)\n# Virginia busy: 10:00 to 12:00\nvirginia_busy = [(10 * 60, 12 * 60)]\n# Charles busy: 12:00 to 12:30 and 13:00 to 13:30\ncharles_busy = [(12 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30)]\n# Megan busy: 9:00 to 12:00; 13:30 to 16:00; 16:30 to 17:00\nmegan_busy = [(9 * 60, 12 * 60), (13 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)]\n\n# Charles prefers no meetings before 14:30 (in minutes)\ncharles_preference_start = 14 * 60 + 30  # 870 minutes\n\ndef invert_busy(busy_intervals, start, end):\n    \"\"\"Given busy intervals and a start and end, return the free intervals.\"\"\"\n    free_intervals = []\n    current = start\n    for b_start, b_end in sorted(busy_intervals):\n        if b_start > current:\n            free_intervals.append((current, b_start))\n        current = max(current, b_end)\n    if current < end:\n        free_intervals.append((current, end))\n    return free_intervals\n\n# Calculate free intervals for each participant during working hours.\nvirginia_free = invert_busy(virginia_busy, work_start, work_end)\ncharles_free = invert_busy(charles_busy, work_start, work_end)\nmegan_free = invert_busy(megan_busy, work_start, work_end)\n\ndef intersect_intervals(intervals1, intervals2):\n    result = []\n    i, j = 0, 0\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        inter_start = max(start1, start2)\n        inter_end = min(end1, end2)\n        if inter_start + meeting_duration <= inter_end:\n            result.append((inter_start, inter_end))\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Compute common free intervals among all three participants.\ncommon_free = intersect_intervals(virginia_free, charles_free)\ncommon_free = intersect_intervals(common_free, megan_free)\n\n# Among the common free intervals, find an interval that satisfies:\n# 1. Duration of at least 30 minutes.\n# 2. Starts at or after Charles's preferred start time (14:30 or 870 minutes).\nscheduled_interval = None\nfor start, end in common_free:\n    # adjust start based on Charles's preference\n    proposed_start = max(start, charles_preference_start)\n    if proposed_start + meeting_duration <= end:\n        scheduled_interval = (proposed_start, proposed_start + meeting_duration)\n        break\n\nif scheduled_interval:\n    meeting_start_str = minutes_to_time(scheduled_interval[0])\n    meeting_end_str = minutes_to_time(scheduled_interval[1])\n    # Output in HH:MM:HH:MM format enclosed in {}\n    print(f\"{{{meeting_start_str}:{meeting_end_str}}}\")\nelse:\n    print(\"No available meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_57"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    \"\"\"Convert HH:MM time string to minutes since midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    \"\"\"Convert minutes since midnight to a HH:MM time string.\"\"\"\n    h = minutes // 60\n    m = minutes % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Find the intersection between two lists of intervals.\n    Each interval is a tuple (start, end) in minutes.\n    Returns a list of intersected intervals.\n    \"\"\"\n    i, j = 0, 0\n    intersections = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find the intersection of the two intervals\n        start_int = max(start1, start2)\n        end_int = min(end1, end2)\n        if start_int < end_int:\n            intersections.append((start_int, end_int))\n        # Move the pointer that ends first\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersections\n\n# Define work hours in minutes (9:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Define free intervals for each participant as lists of (start, end) in minutes.\n# Instead of computing busy, we already know their free intervals within work hours.\n# Joan's meetings: 11:00-11:30, 12:30-13:00\njoan_free = [\n    (work_start, time_to_minutes(\"11:00\")),\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"12:30\")),\n    (time_to_minutes(\"13:00\"), work_end)\n]\n\n# Theresa's meetings: 12:00-12:30, 15:00-15:30\ntheresa_free = [\n    (work_start, time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"12:30\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"15:30\"), work_end)\n]\n\n# Shirley's meetings: 9:30-10:30, 11:00-12:00, 13:00-14:00, 15:30-16:30\nshirley_free = [\n    (work_start, time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"15:30\")),\n    (time_to_minutes(\"16:30\"), work_end)\n]\n\n# First, intersect Joan and Theresa free intervals.\nintersection_jt = intersect_intervals(joan_free, theresa_free)\n# Then, intersect with Shirley's free intervals.\ncommon_free = intersect_intervals(intersection_jt, shirley_free)\n\nmeeting_duration = 60  # minutes (1 hour)\nproposed_start = None\n\n# Find a time slot that fits the meeting duration.\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        proposed_start = start\n        break\n\nif proposed_start is not None:\n    meeting_start = proposed_start\n    meeting_end = meeting_start + meeting_duration\n    # Format time output as \"{HH:MM:HH:MM}\"\n    output = f\"{{{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}}}\"\n    print(output)\nelse:\n    print(\"No available slot found\")\n'''",
            "count": "calendar_scheduling_example_58"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "'''python\ndef to_minutes(time_str):\n    # Converts a time string \"HH:MM\" to minutes since midnight.\n    hours, minutes = map(int, time_str.split(':'))\n    return hours * 60 + minutes\n\ndef to_timestr(minutes):\n    # Converts minutes since midnight to \"HH:MM\" format.\n    h = minutes // 60\n    m = minutes % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef overlaps(slot_start, slot_end, busy_start, busy_end):\n    # returns True if [slot_start, slot_end) overlaps with [busy_start, busy_end)\n    return slot_start < busy_end and slot_end > busy_start\n\n# Define work hours and meeting duration in minutes.\nwork_start = to_minutes(\"09:00\")\nwork_end = to_minutes(\"17:00\")\nmeeting_duration = 30  # in minutes\n\n# Participant schedules (busy intervals in minutes since midnight)\n# Jeffrey has no busy meetings but does not want to start before 14:00.\njeffrey_preference_start = to_minutes(\"14:00\")  # So available from 14:00 to work_end\n\n# Jack's busy intervals on Monday.\njack_busy = [\n    (to_minutes(\"10:30\"), to_minutes(\"11:30\")),\n    (to_minutes(\"13:00\"), to_minutes(\"13:30\")),\n    (to_minutes(\"14:00\"), to_minutes(\"14:30\")),\n    (to_minutes(\"16:00\"), to_minutes(\"17:00\"))\n]\n\n# Judith's busy intervals on Monday.\njudith_busy = [\n    (to_minutes(\"09:00\"), to_minutes(\"10:00\")),\n    (to_minutes(\"10:30\"), to_minutes(\"11:00\")),\n    (to_minutes(\"11:30\"), to_minutes(\"14:00\")),\n    (to_minutes(\"14:30\"), to_minutes(\"15:00\")),\n    (to_minutes(\"15:30\"), to_minutes(\"17:00\"))\n]\n\ndef check_availability(start_time, busy_list):\n    end_time = start_time + meeting_duration\n    for bstart, bend in busy_list:\n        if overlaps(start_time, end_time, bstart, bend):\n            return False\n    return True\n\n# We'll search for a meeting start time between max(work_start, jeffrey_preference_start) and work_end - meeting_duration.\nsearch_start = max(work_start, jeffrey_preference_start)\nsearch_end = work_end - meeting_duration\n\nmeeting_time = None\n\nfor candidate in range(search_start, search_end + 1):\n    candidate_end = candidate + meeting_duration\n    \n    # Check Jeffrey (no busy interval but check his preference which is already satisfied by candidate being >= search_start)\n    # Check Jack's schedule.\n    if not check_availability(candidate, jack_busy):\n        continue\n    # Check Judith's schedule.\n    if not check_availability(candidate, judith_busy):\n        continue\n    \n    # If we reached here, candidate works for everyone.\n    meeting_time = candidate\n    break\n\nif meeting_time is not None:\n    meeting_start_str = to_timestr(meeting_time)\n    meeting_end_str = to_timestr(meeting_time + meeting_duration)\n    print(f\"{meeting_start_str}:{meeting_end_str}\")\nelse:\n    print(\"No available meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_59"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "'''python\ndef to_minutes(time_str):\n    \"\"\"Convert HH:MM string to minutes past midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef to_time_str(minutes):\n    \"\"\"Convert minutes past midnight to HH:MM string.\"\"\"\n    return f\"{minutes // 60:02d}:{minutes % 60:02d}\"\n\ndef subtract_busy(free_interval, busy_intervals):\n    \"\"\"Subtract busy intervals from a free interval.\n    free_interval is a tuple (start, end) in minutes.\n    busy_intervals is a list of (start, end) in minutes that lie within free_interval.\n    Returns a list of free intervals.\n    \"\"\"\n    free_parts = []\n    start, end = free_interval\n    current = start\n    for bstart, bend in sorted(busy_intervals):\n        if bstart > current:\n            free_parts.append((current, min(bstart, end)))\n        current = max(current, bend)\n        if current >= end:\n            break\n    if current < end:\n        free_parts.append((current, end))\n    return free_parts\n\ndef interval_intersection(intervals1, intervals2):\n    \"\"\"Find intersection of two lists of intervals.\n       Each interval is a tuple (start, end) in minutes.\n    \"\"\"\n    result = []\n    i, j = 0, 0\n    while i < len(intervals1) and j < len(intervals2):\n        a_start, a_end = intervals1[i]\n        b_start, b_end = intervals2[j]\n        # Find intersection\n        start = max(a_start, b_start)\n        end = min(a_end, b_end)\n        if start < end:\n            result.append((start, end))\n        if a_end <= b_end:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef get_free_intervals(working_start, working_end, busy_times):\n    \"\"\"Return free intervals within working period subtracting busy_times.\n       busy_times is a list of tuples (start, end) in minutes.\n    \"\"\"\n    # Filter busy times within working hours and sort them\n    busy = []\n    for b in busy_times:\n        bstart, bend = b\n        # Only consider overlap with working period\n        if bend <= working_start or bstart >= working_end:\n            continue\n        busy.append((max(bstart, working_start), min(bend, working_end)))\n    busy.sort()\n    return subtract_busy((working_start, working_end), busy)\n\nif __name__ == \"__main__\":\n    # Meeting duration 30 minutes\n    meeting_duration = 30\n\n    # Define working period for Lisa and Raymond as 09:00 to 17:00 in minutes\n    work_start = to_minutes(\"09:00\")\n    work_end = to_minutes(\"17:00\")\n    \n    # Define busy intervals for each participant in minutes\n    # Lisa's busy times on Monday: 10:30-11:00, 11:30-12:00, 14:00-15:00\n    lisa_busy = [(to_minutes(\"10:30\"), to_minutes(\"11:00\")),\n                 (to_minutes(\"11:30\"), to_minutes(\"12:00\")),\n                 (to_minutes(\"14:00\"), to_minutes(\"15:00\"))]\n    \n    # Dorothy is free the entire day but prefers to avoid meetings after 10:30.\n    # So for meeting purposes, we restrict her working period to 09:00 to 10:30.\n    dorothy_work_start = work_start\n    dorothy_work_end = to_minutes(\"10:30\")\n    dorothy_busy = []  # No busy intervals within her preferred window.\n    \n    # Raymond's busy times on Monday: 09:00-10:00, 10:30-11:00, 11:30-15:00, 16:00-17:00\n    raymond_busy = [(to_minutes(\"09:00\"), to_minutes(\"10:00\")),\n                    (to_minutes(\"10:30\"), to_minutes(\"11:00\")),\n                    (to_minutes(\"11:30\"), to_minutes(\"15:00\")),\n                    (to_minutes(\"16:00\"), to_minutes(\"17:00\"))]\n    \n    # Compute free intervals for each participant.\n    lisa_free = get_free_intervals(work_start, work_end, lisa_busy)\n    dorothy_free = get_free_intervals(dorothy_work_start, dorothy_work_end, dorothy_busy)\n    raymond_free = get_free_intervals(work_start, work_end, raymond_busy)\n    \n    # Get intersection of free intervals for all participants\n    common_free = interval_intersection(lisa_free, dorothy_free)\n    common_free = interval_intersection(common_free, raymond_free)\n    \n    # Find the earliest common slot that can accommodate the meeting duration\n    meeting_slot = None\n    for start, end in common_free:\n        if end - start >= meeting_duration:\n            meeting_slot = (start, start + meeting_duration)\n            break\n\n    if meeting_slot:\n        start_str = to_time_str(meeting_slot[0])\n        end_str = to_time_str(meeting_slot[1])\n        # Output in the format {HH:MM:HH:MM}\n        print(f\"{{{start_str}:{end_str}}}\")\n    else:\n        print(\"No available slot found.\")\n'''",
            "count": "calendar_scheduling_example_60"
        },
        {
            "final_program_time": "{13:30:14:30}",
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\ndef time_to_minutes(t):\n    # t is a string in HH:MM format\n    hours, minutes = map(int, t.split(':'))\n    return hours * 60 + minutes\n\ndef minutes_to_time(m):\n    # convert minutes to HH:MM string\n    hours = m // 60\n    minutes = m % 60\n    return f\"{hours:02d}:{minutes:02d}\"\n\n# Define meeting parameters\nmeeting_duration = 60  # in minutes\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Busy intervals for each participant (start, end) in minutes\n# They are assumed to be closed at start and open at end.\nbusy_robert = []  # Robert is free whole day\nbusy_lisa = [(time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n             (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\"))]\nbusy_patrick = [(time_to_minutes(\"09:30\"), time_to_minutes(\"11:30\")),\n                (time_to_minutes(\"12:30\"), time_to_minutes(\"13:30\")),\n                (time_to_minutes(\"16:00\"), time_to_minutes(\"17:00\"))]\n\ndef get_free_slots(busy, work_start, work_end):\n    # sort busy intervals by start time\n    busy = sorted(busy)\n    free = []\n    current = work_start\n    for start, end in busy:\n        if start > current:\n            free.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\n# Calculate free slots for each participant\nfree_robert = [(work_start, work_end)]  # free all day\nfree_lisa = get_free_slots(busy_lisa, work_start, work_end)\nfree_patrick = get_free_slots(busy_patrick, work_start, work_end)\n\ndef intersect_intervals(slots1, slots2):\n    # Given two lists of intervals, compute the intersection\n    intersections = []\n    i, j = 0, 0\n    while i < len(slots1) and j < len(slots2):\n        start1, end1 = slots1[i]\n        start2, end2 = slots2[j]\n        start = max(start1, start2)\n        end = min(end1, end2)\n        if start + meeting_duration <= end:  # Enough time for meeting\n            intersections.append((start, end))\n        # Move the pointer that ends first\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersections\n\n# First, intersect free slots for Lisa and Patrick\nintersect_lp = intersect_intervals(free_lisa, free_patrick)\n# Now intersect with Robert's free (which is the whole day) \nfinal_slots = intersect_intervals(intersect_lp, free_robert)\n\n# Find the earliest time slot that can accommodate the meeting duration\nmeeting_slot = None\nfor start, end in final_slots:\n    if end - start >= meeting_duration:\n        meeting_slot = (start, start + meeting_duration)\n        break\n\nif meeting_slot:\n    start_time = minutes_to_time(meeting_slot[0])\n    end_time = minutes_to_time(meeting_slot[1])\n    print(f\"{start_time}:{end_time}\")\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_61"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "'''python\nimport datetime\n\ndef time_to_minutes(time_str):\n    \"\"\"Converts a HH:MM string to minutes since midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(':'))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    \"\"\"Converts minutes since midnight to a HH:MM string.\"\"\"\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02}:{mins:02}\"\n\n# Meeting parameters\nmeeting_duration = 60  # in minutes\n\n# Define working hours (09:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Participants' availability:\n# Abigail and Michael are free all day within working hours.\n# Sharon is busy during 09:00-13:00 and 14:00-17:00.\nsharon_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"17:00\"))\n]\n\n# Calculate Sharon's free intervals within working hours.\nsharon_free = []\ncurrent_time = work_start\n\nfor busy_start, busy_end in sharon_busy:\n    if current_time < busy_start:\n        sharon_free.append((current_time, busy_start))\n    current_time = max(current_time, busy_end)\nif current_time < work_end:\n    sharon_free.append((current_time, work_end))\n\n# Look for a free interval that can accommodate the meeting duration.\nmeeting_slot = None\nfor start, end in sharon_free:\n    if end - start >= meeting_duration:\n        meeting_slot = (start, start + meeting_duration)\n        break\n\nif meeting_slot:\n    start_time_str = minutes_to_time(meeting_slot[0])\n    end_time_str = minutes_to_time(meeting_slot[1])\n    print(f\"{{{start_time_str}:{end_time_str}}}\")\nelse:\n    print(\"No available slot\")\n'''",
            "count": "calendar_scheduling_example_62"
        },
        {
            "final_program_time": "{16:00:17:00}",
            "expected_time": "{16:00:17:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    # t format: \"HH:MM\"\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef get_free_intervals(busy_intervals, work_start, work_end):\n    free = []\n    current = work_start\n    for start, end in sorted(busy_intervals):\n        if current < start:\n            free.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    intersection = []\n    i, j = 0, 0\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        start = max(start1, start2)\n        end = min(end1, end2)\n        if start < end:\n            intersection.append((start, end))\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\ndef find_common_free_interval(free_intervals_list, duration):\n    # Intersect the free intervals one by one\n    common = free_intervals_list[0]\n    for free in free_intervals_list[1:]:\n        common = intersect_intervals(common, free)\n    # Find an interval in common that is at least the required duration\n    for start, end in common:\n        if end - start >= duration:\n            return start, start + duration\n    return None\n\ndef main():\n    # Define working hours: 9:00 to 17:00.\n    work_start = time_to_minutes(\"09:00\")\n    work_end = time_to_minutes(\"17:00\")\n    meeting_duration = 60  # in minutes\n    \n    # Define busy intervals for each participant in minutes.\n    # Format: (start, end) where times are in minutes from midnight.\n    busy = {\n        \"Madison\": [],  # free entire day\n        \"Judith\": [\n            (time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n            (time_to_minutes(\"11:00\"), time_to_minutes(\"12:00\")),\n            (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\"))\n        ],\n        \"Roger\": [\n            (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n            (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n            (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n            (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n            (time_to_minutes(\"14:00\"), time_to_minutes(\"16:00\"))\n        ]\n    }\n    \n    # Compute free intervals for each participant.\n    free_intervals = {}\n    for person, b_intervals in busy.items():\n        free_intervals[person] = get_free_intervals(b_intervals, work_start, work_end)\n    \n    # Create a list of free intervals lists.\n    free_list = list(free_intervals.values())\n    \n    # Find a common free interval that fits the meeting duration.\n    meeting_slot = find_common_free_interval(free_list, meeting_duration)\n    \n    if meeting_slot:\n        start, end = meeting_slot\n        meeting_time = f\"{{{minutes_to_time(start)}:{minutes_to_time(end)}}}\"\n        print(meeting_time)\n    else:\n        print(\"No common time slot available.\")\n\nif __name__ == \"__main__\":\n    main()\n'''",
            "count": "calendar_scheduling_example_63"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\ndef to_minutes(time_str):\n    \"\"\"Converts time in HH:MM format to minutes since midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef to_time_str(minutes):\n    \"\"\"Converts minutes since midnight to HH:MM formatted string.\"\"\"\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Meeting and work constraints\nmeeting_duration = 60  # minutes\nwork_start = to_minutes(\"09:00\")\nwork_end = to_minutes(\"17:00\")\n\n# Schedules (busy intervals as list of (start, end) in minutes)\nnancy_busy = [(to_minutes(\"09:30\"), to_minutes(\"10:00\")),\n              (to_minutes(\"12:30\"), to_minutes(\"13:00\"))]\n\nalbert_busy = []  # no meetings\n\nnathan_busy = [(to_minutes(\"09:00\"), to_minutes(\"12:30\")),\n               (to_minutes(\"13:00\"), to_minutes(\"14:30\")),\n               (to_minutes(\"16:00\"), to_minutes(\"17:00\"))]\n\ndef get_free_times(busy, start, end):\n    \"\"\"Given a list of busy intervals and work start/end, return free intervals.\"\"\"\n    free_intervals = []\n    busy_sorted = sorted(busy, key=lambda x: x[0])\n    # initial free block from work start to first busy start, if any\n    current_start = start\n    for b_start, b_end in busy_sorted:\n        if current_start < b_start:\n            free_intervals.append((current_start, b_start))\n        current_start = max(current_start, b_end)\n    if current_start < end:\n        free_intervals.append((current_start, end))\n    return free_intervals\n\n# Compute free intervals for each person\nnancy_free = get_free_times(nancy_busy, work_start, work_end)\nalbert_free = get_free_times(albert_busy, work_start, work_end)\nnathan_free = get_free_times(nathan_busy, work_start, work_end)\n\n# Function to compute intersection of two lists of free intervals\ndef intersect_intervals(intervals1, intervals2):\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        start = max(intervals1[i][0], intervals2[j][0])\n        end = min(intervals1[i][1], intervals2[j][1])\n        if start < end:\n            result.append((start, end))\n        if intervals1[i][1] < intervals2[j][1]:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Intersect all free intervals for the three participants\ncommon_free = intersect_intervals(nancy_free, albert_free)\ncommon_free = intersect_intervals(common_free, nathan_free)\n\n# Find a time slot that can accommodate a 60 minutes meeting\nproposed_start = None\nproposed_end = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        proposed_start = start\n        proposed_end = start + meeting_duration\n        break\n\nif proposed_start is not None:\n    meeting_time = f\"{to_time_str(proposed_start)}:{to_time_str(proposed_end)}\"\n    print(meeting_time)\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_64"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    h, m = map(int, time_str.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(minutes):\n    h = minutes // 60\n    m = minutes % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef get_free_intervals(busy, start, end):\n    busy_sorted = sorted(busy, key=lambda x: x[0])\n    free = []\n    current = start\n    for b_start, b_end in busy_sorted:\n        if b_start > current:\n            free.append((current, b_start))\n        current = max(current, b_end)\n    if current < end:\n        free.append((current, end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    result = []\n    i, j = 0, 0\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        start_int = max(start1, start2)\n        end_int = min(end1, end2)\n        if start_int + meeting_duration <= end_int:\n            result.append((start_int, end_int))\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Work day boundaries\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nmeeting_duration = 30\n\n# Busy schedules for participants (in minutes)\nbusy_john = [\n    (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\"))\n]\n\nbusy_andrea = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"12:30\")),\n    (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))\n]\n# Andrea cannot meet after 16:30.\nandrea_end = time_to_minutes(\"16:30\")\n\nbusy_lisa = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"15:30\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))\n]\n\n# Calculate free intervals for each participant\nfree_john = get_free_intervals(busy_john, work_start, work_end)\nfree_andrea = get_free_intervals(busy_andrea, work_start, andrea_end)\nfree_lisa = get_free_intervals(busy_lisa, work_start, work_end)\n\n# Compute common free intervals\ncommon_free = intersect_intervals(free_john, free_andrea)\ncommon_free = intersect_intervals(common_free, free_lisa)\n\n# Find the first available slot of meeting_duration minutes\nmeeting_slot = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        meeting_slot = (start, start + meeting_duration)\n        break\n\nif meeting_slot:\n    print(f\"{minutes_to_time(meeting_slot[0])}:{minutes_to_time(meeting_slot[1])}\")\nelse:\n    print(\"No Available Slot\")\n'''",
            "count": "calendar_scheduling_example_65"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\n# Meeting constraints\nmeeting_duration = 60  # minutes\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Participant schedules:\n# Ronald and Maria are free all day.\n# Charles has busy intervals as follows:\nbusy_intervals = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"11:30\")),\n    (time_to_minutes(\"13:30\"), time_to_minutes(\"14:00\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"16:30\")),\n]\n\n# Find Charles' free intervals between work_start and work_end.\nfree_intervals = []\ncurrent_start = work_start\n\nfor busy_start, busy_end in busy_intervals:\n    if current_start < busy_start:\n        free_intervals.append((current_start, busy_start))\n    current_start = max(current_start, busy_end)\n\nif current_start < work_end:\n    free_intervals.append((current_start, work_end))\n\n# Find the first free interval that can accommodate the meeting_duration.\nmeeting_slot = None\nfor free_start, free_end in free_intervals:\n    if free_end - free_start >= meeting_duration:\n        meeting_slot = (free_start, free_start + meeting_duration)\n        break\n\nif meeting_slot:\n    # Format: HH:MM:HH:MM\n    output = f\"{minutes_to_time(meeting_slot[0])}:{minutes_to_time(meeting_slot[1])}\"\n    print(output)\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_66"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\n# Define meeting duration in minutes\nmeeting_duration = 30\n\n# Working hours and Linda's constraint: meeting must finish before 14:00.\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"14:00\", \"%H:%M\")  # Because Linda cannot meet after 14:00\n\n# Busy intervals for each participant (start, end)\n# Times are given in HH:MM format as strings.\n# Jacqueline busy times on Monday\njacqueline_busy = [\n    (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"13:30\", \"%H:%M\")),\n    (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))\n]\n\n# Christian is free the entire day, so no busy intervals.\nchristian_busy = []\n\n# Linda busy times on Monday\nlinda_busy = [\n    (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n    (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n    (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\")),\n    (datetime.strptime(\"15:30\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))\n]\n\n# Since Linda cannot meet after 14:00, we limit the search to work_start and 14:00.\ndef is_time_slot_free(start_time, end_time, busy_slots):\n    for busy_start, busy_end in busy_slots:\n        # Check if the meeting time overlaps with a busy slot\n        if start_time < busy_end and end_time > busy_start:\n            return False\n    return True\n\n# Combine busy intervals from all participants. \n# We will check each participant's schedule within the meeting search window.\ndef is_slot_available(start_time):\n    end_time = start_time + timedelta(minutes=meeting_duration)\n    if end_time > work_end:\n        return False\n    if not is_time_slot_free(start_time, end_time, jacqueline_busy):\n        return False\n    if not is_time_slot_free(start_time, end_time, christian_busy):\n        return False\n    if not is_time_slot_free(start_time, end_time, linda_busy):\n        return False\n    return True\n\n# Start searching from work_start in increments of 15 minutes (or can be minute-by-minute).\ncurrent_time = work_start\nfound_slot = None\n\nwhile current_time + timedelta(minutes=meeting_duration) <= work_end:\n    if is_slot_available(current_time):\n        found_slot = (current_time, current_time + timedelta(minutes=meeting_duration))\n        break\n    current_time += timedelta(minutes=15)  # Increment by 15 minutes for efficiency\n\nif found_slot:\n    start, end = found_slot\n    # Format the output in HH:MM:HH:MM\n    output = f\"{{{start.strftime('%H:%M')}:{end.strftime('%H:%M')}}}\"\n    print(output)\nelse:\n    print(\"No available slot found.\")\n'''",
            "count": "calendar_scheduling_example_67"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    \"\"\"Converts time in HH:MM format to minutes since midnight.\"\"\"\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    \"\"\"Converts minutes since midnight to HH:MM format.\"\"\"\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef invert_intervals(blocks, start, end):\n    \"\"\"Given a list of blocked intervals, return the free intervals between start and end.\n       Each interval is a tuple (start, end) in minutes.\n    \"\"\"\n    free = []\n    current = start\n    for b_start, b_end in sorted(blocks):\n        if current < b_start:\n            free.append((current, b_start))\n        current = max(current, b_end)\n    if current < end:\n        free.append((current, end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Intersect two lists of intervals.\"\"\"\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find intersection\n        start = max(start1, start2)\n        end = min(end1, end2)\n        if start < end:\n            result.append((start, end))\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Define work hours in minutes (from 9:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nmeeting_duration = 30  # minutes\n\n# Blocked intervals for each participant, expressed in minutes.\n# Format: list of tuples (start, end)\nmichael_blocks = [\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"13:30\"), time_to_minutes(\"14:00\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\"))\n]\nbryan_blocks = []  # Bryan is free all day.\nlauren_blocks = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"17:00\"))\n]\n\n# Compute free intervals for each participant within work hours.\nmichael_free = invert_intervals(michael_blocks, work_start, work_end)\nbryan_free   = invert_intervals(bryan_blocks, work_start, work_end)\nlauren_free  = invert_intervals(lauren_blocks, work_start, work_end)\n\n# Now compute the common free intervals by intersecting the free intervals.\ncommon_free = intersect_intervals(michael_free, bryan_free)\ncommon_free = intersect_intervals(common_free, lauren_free)\n\n# Find the earliest interval that can accommodate the meeting duration.\nmeeting_start = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        meeting_start = start\n        meeting_end = start + meeting_duration\n        break\n\nif meeting_start is not None:\n    start_str = minutes_to_time(meeting_start)\n    end_str = minutes_to_time(meeting_end)\n    # Output in the format {HH:MM:HH:MM}\n    print(\"{\" + f\"{start_str}:{end_str}\" + \"}\")\nelse:\n    print(\"No suitable meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_68"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{10:00:11:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    \"\"\"Converts a time string in HH:MM format to minutes since midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(mins):\n    \"\"\"Converts minutes since midnight to a time string in HH:MM format.\"\"\"\n    hours = mins // 60\n    minutes = mins % 60\n    return f\"{hours:02d}:{minutes:02d}\"\n\ndef get_free_intervals(busy_intervals, work_start, work_end):\n    \"\"\"Given a list of busy intervals (each as (start, end) in minutes) and \n    the working hours, returns a list of free intervals (start, end) in minutes.\"\"\"\n    free_intervals = []\n    current = work_start\n    for interval in sorted(busy_intervals):\n        busy_start, busy_end = interval\n        if busy_start > current:\n            free_intervals.append((current, busy_start))\n        current = max(current, busy_end)\n    if current < work_end:\n        free_intervals.append((current, work_end))\n    return free_intervals\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Returns the intersection of two lists of intervals.\"\"\"\n    i, j = 0, 0\n    intersection = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find intersection\n        start = max(start1, start2)\n        end = min(end1, end2)\n        if start < end:\n            intersection.append((start, end))\n        # Move to the next interval in the list that finishes first\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\n# Define work hours in minutes (9:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nmeeting_duration = 60  # in minutes\n\n# Busy intervals for each participant converted to minutes\n# Shirley: 11:00-11:30, 14:00-15:00, 16:00-16:30\nshirley_busy = [\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"11:30\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))\n]\n\n# Stephen: 13:00-13:30, 15:30-16:00\nstephen_busy = [\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\"))\n]\n\n# Paul: 9:00-10:00, 11:00-17:00\npaul_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"17:00\"))\n]\n\n# Compute free intervals for each participant within work hours\nshirley_free = get_free_intervals(shirley_busy, work_start, work_end)\nstephen_free = get_free_intervals(stephen_busy, work_start, work_end)\npaul_free = get_free_intervals(paul_busy, work_start, work_end)\n\n# Compute common free intervals among all participants\ncommon_free = intersect_intervals(shirley_free, stephen_free)\ncommon_free = intersect_intervals(common_free, paul_free)\n\n# Find a slot with at least meeting_duration minutes\nmeeting_slot = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        meeting_slot = (start, start + meeting_duration)\n        break\n\nif meeting_slot:\n    start_time = minutes_to_time(meeting_slot[0])\n    end_time = minutes_to_time(meeting_slot[1])\n    # Output in format HH:MM:HH:MM\n    print(f\"{start_time}:{end_time}\")\nelse:\n    print(\"No available slot found.\")\n'''",
            "count": "calendar_scheduling_example_69"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\ndef time_to_minutes(t_str):\n    \"\"\"Convert HH:MM to minutes since midnight.\"\"\"\n    h, m = map(int, t_str.split(':'))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    \"\"\"Convert minutes since midnight to HH:MM.\"\"\"\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef subtract_busy(time_block, busy_intervals):\n    \"\"\"\n    Given a time block (start, end) and busy intervals (list of (start,end)),\n    return a list of free intervals within the block.\n    \"\"\"\n    free = []\n    start, end = time_block\n    current = start\n    for b_start, b_end in sorted(busy_intervals):\n        if b_start > current:\n            free.append((current, min(b_start, end)))\n        current = max(current, b_end)\n        if current >= end:\n            break\n    if current < end:\n        free.append((current, end))\n    return free\n\ndef intersect_intervals(intervals_list):\n    \"\"\"\n    Given a list of lists of intervals, return the intersection of these intervals.\n    \"\"\"\n    def intersect_two(list1, list2):\n        result = []\n        i, j = 0, 0\n        while i < len(list1) and j < len(list2):\n            start1, end1 = list1[i]\n            start2, end2 = list2[j]\n            # find overlap\n            start_overlap = max(start1, start2)\n            end_overlap = min(end1, end2)\n            if start_overlap < end_overlap:\n                result.append((start_overlap, end_overlap))\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        return result\n\n    if not intervals_list:\n        return []\n    common = intervals_list[0]\n    for intervals in intervals_list[1:]:\n        common = intersect_two(common, intervals)\n    return common\n\n# Define meeting parameters and work hours in minutes\nmeeting_duration = 30  # minutes\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nwork_block = (work_start, work_end)\n\n# Busy schedules (in HH:MM), converted to minutes\n# Denise busy: 12:00-12:30, 15:30-16:00\ndenise_busy = [(time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n               (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\"))]\n# Angela has no meetings\nangela_busy = []\n# Natalie busy: 9:00-11:30, 12:00-13:00, 14:00-14:30, 15:00-17:00\nnatalie_busy = [(time_to_minutes(\"09:00\"), time_to_minutes(\"11:30\")),\n                (time_to_minutes(\"12:00\"), time_to_minutes(\"13:00\")),\n                (time_to_minutes(\"14:00\"), time_to_minutes(\"14:30\")),\n                (time_to_minutes(\"15:00\"), time_to_minutes(\"17:00\"))]\n\n# Compute free intervals for each participant within work hours\ndenise_free = subtract_busy(work_block, denise_busy)\nangela_free = subtract_busy(work_block, angela_busy)\nnatalie_free = subtract_busy(work_block, natalie_busy)\n\n# Find common free intervals across all participants\ncommon_free = intersect_intervals([denise_free, angela_free, natalie_free])\n\n# Choose the earliest slot with enough duration for the meeting\nmeeting_slot = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        meeting_slot = (start, start + meeting_duration)\n        break\n\nif meeting_slot:\n    start_time = minutes_to_time(meeting_slot[0])\n    end_time = minutes_to_time(meeting_slot[1])\n    # Output format HH:MM:HH:MM e.g. {11:30:12:00}\n    print(f\"{{{start_time}:{end_time}}}\")\nelse:\n    print(\"No available slot found.\")\n'''",
            "count": "calendar_scheduling_example_70"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    \"\"\"Converts a time string \"HH:MM\" to minutes since 00:00.\"\"\"\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    \"\"\"Converts minutes since 00:00 to a time string \"HH:MM\".\"\"\"\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\ndef subtract_blocked(free_interval, blocked):\n    \"\"\"Subtracts a blocked interval from a free interval.\n       free_interval and blocked are tuples (start, end) in minutes.\n       Returns a list of intervals (could be split into two parts).\"\"\"\n    free_start, free_end = free_interval\n    block_start, block_end = blocked\n    intervals = []\n    # If the blocked interval does not overlap, return the original free interval.\n    if block_end <= free_start or block_start >= free_end:\n        return [free_interval]\n    # If there is free time before the block:\n    if block_start > free_start:\n        intervals.append((free_start, block_start))\n    # If there is free time after the block:\n    if block_end < free_end:\n        intervals.append((block_end, free_end))\n    return intervals\n\ndef compute_free_intervals(work_interval, blocked_intervals):\n    \"\"\"Compute free intervals within the work interval given a list of blocked intervals.\n       Both work_interval and each blocked interval are tuples (start, end) in minutes.\n       Blocked intervals are assumed to be sorted by start time.\n    \"\"\"\n    free_intervals = [work_interval]\n    for block in blocked_intervals:\n        new_free_intervals = []\n        for free_int in free_intervals:\n            new_free_intervals.extend(subtract_blocked(free_int, block))\n        free_intervals = new_free_intervals\n    return free_intervals\n\ndef intersect_intervals(intervals_list):\n    \"\"\"Intersect a list of lists of intervals.\n       intervals_list is a list where each element is a list of intervals (tuples).\n       Returns the intersection as a list of intervals.\n    \"\"\"\n    # Start with the full day of consideration. We assume all intervals are within working hours.\n    if not intervals_list:\n        return []\n    common = intervals_list[0]\n    for intervals in intervals_list[1:]:\n        new_common = []\n        for (s1, e1) in common:\n            for (s2, e2) in intervals:\n                # Find overlap between (s1, e1) and (s2, e2)\n                start = max(s1, s2)\n                end = min(e1, e2)\n                if end - start > 0:\n                    new_common.append((start, end))\n        common = new_common\n    return common\n\ndef find_meeting_slot(common_intervals, duration, latest_start_preference=None):\n    \"\"\"Find the earliest meeting slot of given duration (in minutes) within the common_intervals.\n       Optionally, if latest_start_preference is provided, then only consider slots that\n       start before this time (in minutes).\n    \"\"\"\n    for (start, end) in sorted(common_intervals):\n        # Adjust start if latest_start_preference is in effect\n        if latest_start_preference is not None and start >= latest_start_preference:\n            continue\n        candidate_start = start\n        candidate_end = candidate_start + duration\n        # Check if candidate fits in the interval and also respects the latest start preference.\n        if candidate_end <= end and (latest_start_preference is None or candidate_start < latest_start_preference):\n            return (candidate_start, candidate_end)\n    return None\n\ndef main():\n    meeting_duration = 30  # in minutes\n\n    # Define working hours (Monday 09:00 to 17:00)\n    work_start = time_to_minutes(\"09:00\")\n    work_end = time_to_minutes(\"17:00\")\n    work_interval = (work_start, work_end)\n\n    # Participant schedules:\n    # Nicole is free the entire day (no blocks).\n    nicole_blocks = []  # no blocked intervals\n\n    # John's blocks: 12:30-13:00, 16:30-17:00\n    john_blocks = [\n        (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\")),\n        (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))\n    ]\n    \n    # Ethan's blocks: 09:00-10:00, 11:30-14:00, 14:30-17:00\n    ethan_blocks = [\n        (time_to_minutes(\"09:00\"), time_to_minutes(\"10:00\")),\n        (time_to_minutes(\"11:30\"), time_to_minutes(\"14:00\")),\n        (time_to_minutes(\"14:30\"), time_to_minutes(\"17:00\"))\n    ]\n\n    # Compute free intervals for each participant\n    nicole_free = compute_free_intervals(work_interval, nicole_blocks)\n    john_free = compute_free_intervals(work_interval, john_blocks)\n    ethan_free = compute_free_intervals(work_interval, ethan_blocks)\n\n    # John's additional preference: He would rather not meet on Monday after 12:00.\n    # So we need to ensure the meeting starts before 12:00.\n    john_preference_cutoff = time_to_minutes(\"12:00\")\n\n    # For John's schedule consider only the portions that start before the cutoff.\n    john_free_with_pref = []\n    for (s, e) in john_free:\n        # Only consider interval if it starts before the cutoff.\n        if s < john_preference_cutoff:\n            # Adjust end if it goes beyond the cutoff.\n            john_free_with_pref.append((s, min(e, john_preference_cutoff)))\n    \n    # Now find the intersection of free intervals among all participants.\n    common_free = intersect_intervals([nicole_free, john_free_with_pref, ethan_free])\n\n    # Find a meeting slot of 30 minutes in the common intervals.\n    slot = find_meeting_slot(common_free, meeting_duration)\n    if slot is not None:\n        start, end = slot\n        meeting_time = f\"{minutes_to_time(start)}:{minutes_to_time(end)}\"\n        print(meeting_time)\n    else:\n        print(\"No possible meeting slot found.\")\n\nif __name__ == \"__main__\":\n    main()\n'''",
            "count": "calendar_scheduling_example_71"
        },
        {
            "final_program_time": "{13:30:14:30}",
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\n# Helper function to convert time string to minutes since midnight\ndef time_to_minutes(t: str) -> int:\n    h, m = map(int, t.split(':'))\n    return h * 60 + m\n\n# Helper function to convert minutes since midnight to time string HH:MM\ndef minutes_to_time(m: int) -> str:\n    return f\"{m//60:02d}:{m%60:02d}\"\n\n# Given a list of busy intervals and working hours, generate free intervals\ndef get_free_intervals(busy, work_start, work_end):\n    free = []\n    current = work_start\n    # Sort busy intervals by start time\n    busy.sort(key=lambda x: x[0])\n    for b_start, b_end in busy:\n        if b_start > current:\n            free.append((current, b_start))\n        current = max(current, b_end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\n# Function to compute intersection of two lists of intervals\ndef intersect_intervals(intervals1, intervals2):\n    i, j = 0, 0\n    intersection = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # find overlap\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap < end_overlap:\n            intersection.append((start_overlap, end_overlap))\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\n# Working hours: 9:00 to 17:00 (in minutes)\nwork_start = time_to_minutes(\"09:00\")\nwork_end   = time_to_minutes(\"17:00\")\n\n# Meeting duration: 60 minutes\nmeeting_duration = 60\n\n# Busy intervals for each person, represented in minutes since midnight.\n# Intervals are represented as (start, end) where start and end are in minutes.\n# Mason has no meetings, so his busy intervals list is empty.\nmason_busy = []\n\n# Amy's busy intervals on Monday: 9:30 to 11:30, 13:00 to 13:30, 16:30 to 17:00\namy_busy = [\n    (time_to_minutes(\"09:30\"), time_to_minutes(\"11:30\")),\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n    (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))\n]\n\n# Christopher's busy intervals on Monday: 9:00 to 10:00, 12:00 to 13:30, 14:30 to 15:00, 15:30 to 16:30\nchris_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"13:30\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"16:30\"))\n]\n\n# Get free intervals for each participant based on working hours\nmason_free = get_free_intervals(mason_busy, work_start, work_end)\namy_free = get_free_intervals(amy_busy, work_start, work_end)\nchris_free = get_free_intervals(chris_busy, work_start, work_end)\n\n# Find the common free intervals for all participants\ncommon_free = intersect_intervals(mason_free, amy_free)\ncommon_free = intersect_intervals(common_free, chris_free)\n\n# Find the first common interval that can accommodate the meeting_duration\nmeeting_slot = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        meeting_slot = (start, start + meeting_duration)\n        break\n\nif meeting_slot:\n    start_time = minutes_to_time(meeting_slot[0])\n    end_time = minutes_to_time(meeting_slot[1])\n    # Output in the format HH:MM:HH:MM\n    print(f\"{{{start_time}:{end_time}}}\")\nelse:\n    print(\"No available meeting slot found.\")\n'''",
            "count": "calendar_scheduling_example_72"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\n# Define a helper function to convert a time string in \"HH:MM\" format to minutes since midnight.\ndef time_to_minutes(t_str):\n    h, m = map(int, t_str.split(':'))\n    return h * 60 + m\n\n# Helper function to convert minutes since midnight to \"HH:MM\" string.\ndef minutes_to_time(m):\n    return f\"{m // 60:02d}:{m % 60:02d}\"\n\n# Function to subtract busy intervals from an available window.\ndef get_free_intervals(available_start, available_end, busy_intervals):\n    free_intervals = []\n    current_start = available_start\n    for start, end in sorted(busy_intervals):\n        # if the busy interval is completely before the current start, skip\n        if end <= current_start:\n            continue\n        # if there is a gap between current_start and the start of busy interval\n        if start > current_start:\n            free_intervals.append((current_start, min(start, available_end)))\n        current_start = max(current_start, end)\n        if current_start >= available_end:\n            break\n    # after all busy intervals, if there is still a gap until available_end:\n    if current_start < available_end:\n        free_intervals.append((current_start, available_end))\n    return free_intervals\n\n# Work hours in minutes since midnight (9:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nmeeting_duration = 30  # in minutes\n\n# Define busy schedules for each participant as list of (start, end) in minutes.\nbradley_busy = [(time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n                (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n                (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\")),\n                (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))]\n\nandrew_busy = [(time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n               (time_to_minutes(\"12:30\"), time_to_minutes(\"13:30\")),\n               (time_to_minutes(\"14:00\"), time_to_minutes(\"14:30\")),\n               (time_to_minutes(\"15:00\"), time_to_minutes(\"16:00\"))]\n\nmelissa_busy = [(time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n                (time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n                (time_to_minutes(\"11:00\"), time_to_minutes(\"14:00\")),\n                (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\")),\n                (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))]\n\n# Calculate free intervals for each participant within work hours.\nbradley_free = get_free_intervals(work_start, work_end, bradley_busy)\nandrew_free = get_free_intervals(work_start, work_end, andrew_busy)\nmelissa_free = get_free_intervals(work_start, work_end, melissa_busy)\n\n# Helper function to compute intersection of two lists of intervals.\ndef intersect_intervals(intervals1, intervals2):\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find the overlap.\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap < end_overlap:\n            result.append((start_overlap, end_overlap))\n        # Move the pointer that ends earlier.\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Compute the common free intervals.\ncommon_free = intersect_intervals(bradley_free, andrew_free)\ncommon_free = intersect_intervals(common_free, melissa_free)\n\n# Look for an interval that can accommodate the meeting duration.\nscheduled_time = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        meeting_start = start\n        meeting_end = start + meeting_duration\n        scheduled_time = (meeting_start, meeting_end)\n        break\n\nif scheduled_time:\n    output = f\"{minutes_to_time(scheduled_time[0])}:{minutes_to_time(scheduled_time[1])}\"\n    print(output)\nelse:\n    print(\"No available slot found.\")\n'''",
            "count": "calendar_scheduling_example_73"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_str(start, end):\n    # Convert minutes since midnight to HH:MM format for both start and end\n    return f\"{start//60:02d}:{start%60:02d}:{end//60:02d}:{end%60:02d}\"\n\ndef intersect_two(intervals1, intervals2):\n    \"\"\"Intersect two lists of intervals. Each interval is a tuple (start, end) in minutes.\"\"\"\n    result = []\n    i, j = 0, 0\n    while i < len(intervals1) and j < len(intervals2):\n        a_start, a_end = intervals1[i]\n        b_start, b_end = intervals2[j]\n        # compute overlap\n        start = max(a_start, b_start)\n        end = min(a_end, b_end)\n        if start < end:\n            result.append((start, end))\n        # move to the next interval for the one that ends earlier\n        if a_end < b_end:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef intersect_all(lists):\n    \"\"\"Intersect a list of interval lists.\"\"\"\n    if not lists:\n        return []\n    current = lists[0]\n    for intervals in lists[1:]:\n        current = intersect_two(current, intervals)\n    return current\n\n# Define work hours in minutes: 9:00 to 17:00 -> 540 to 1020\nwork_start = 540\nwork_end = 1020\n\n# Meeting duration in minutes\nmeeting_duration = 60\n\n# Participant schedules (busy times in minutes)\n# Eric: busy 10:00-12:00, and does not want meetings after 15:30,\n# so his effective available period ends at 15:30 (930)\neric_busy = [(600, 720)]\n# Albert: busy 12:00-12:30 and 15:30-16:00\nalbert_busy = [(720, 750), (930, 960)]\n# Katherine: busy 10:00-11:00, 11:30-14:00, 15:00-15:30\nkatherine_busy = [(600, 660), (690, 840), (900, 930)]\n\ndef invert_busy(busy_list, start, end):\n    \"\"\"Return free intervals between start and end given busy_list (which is assumed sorted).\"\"\"\n    free = []\n    current = start\n    for b_start, b_end in busy_list:\n        if current < b_start:\n            free.append((current, b_start))\n        current = max(current, b_end)\n    if current < end:\n        free.append((current, end))\n    return free\n\n# Calculate free intervals for each participant within their effective working hours:\neric_free = invert_busy(eric_busy, work_start, 930)  # Eric doesn\u2019t want meetings after 15:30 (930)\nalbert_free = invert_busy(albert_busy, work_start, 930)\nkatherine_free = invert_busy(katherine_busy, work_start, 930)\n\n# Intersect free intervals for all participants:\ncommon_free = intersect_all([eric_free, albert_free, katherine_free])\n\n# Find the earliest interval from the common free intervals that is at least meeting_duration long\nmeeting_time = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        meeting_time = (start, start + meeting_duration)\n        break\n\nif meeting_time:\n    print(minutes_to_str(*meeting_time))\nelse:\n    print(\"No possible time found.\")\n'''",
            "count": "calendar_scheduling_example_74"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_time(m):\n    hours = m // 60\n    minutes = m % 60\n    return f\"{hours:02d}:{minutes:02d}\"\n\ndef invert_busy(busy, work_start, work_end):\n    # Given a list of busy intervals (tuples of (start, end) in minutes) sorted by start,\n    # return free intervals within [work_start, work_end].\n    free = []\n    current = work_start\n    for start, end in busy:\n        if start > current:\n            free.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_intervals(int1, int2):\n    \"\"\"Intersects two lists of intervals. Each interval is a tuple (start, end).\"\"\"\n    result = []\n    i, j = 0, 0\n    while i < len(int1) and j < len(int2):\n        a_start, a_end = int1[i]\n        b_start, b_end = int2[j]\n        # Find overlap\n        start = max(a_start, b_start)\n        end = min(a_end, b_end)\n        if start < end:\n            result.append((start, end))\n        # Move to the next interval in the list which finishes earlier\n        if a_end < b_end:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef find_meeting_time():\n    meeting_duration = 60  # minutes\n    work_start = 9 * 60    # 9:00 in minutes\n    work_end = 17 * 60     # 17:00 in minutes\n\n    # Busy intervals for each participant in minutes.\n    # Jacob is busy: 9:00-9:30, 12:30-13:00, 14:30-15:00, 16:30-17:00\n    jacob_busy = [(9*60, 9*60+30), (12*60+30, 13*60), (14*60+30, 15*60), (16*60+30, 17*60)]\n    # Amanda is busy: 10:00-10:30, 12:00-12:30\n    amanda_busy = [(10*60, 10*60+30), (12*60, 12*60+30)]\n    # Lisa is busy: 11:00-13:00, 14:30-16:30\n    lisa_busy = [(11*60, 13*60), (14*60+30, 16*60+30)]\n\n    # Sort busy intervals (they should already be sorted)\n    jacob_busy.sort()\n    amanda_busy.sort()\n    lisa_busy.sort()\n\n    # Get free intervals for each participant given the work day.\n    jacob_free = invert_busy(jacob_busy, work_start, work_end)\n    amanda_free = invert_busy(amanda_busy, work_start, work_end)\n    lisa_free = invert_busy(lisa_busy, work_start, work_end)\n\n    # Intersect free intervals among all participants.\n    common_free = intersect_intervals(jacob_free, amanda_free)\n    common_free = intersect_intervals(common_free, lisa_free)\n\n    # Find the earliest time slot that can accommodate the meeting duration.\n    for start, end in common_free:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = start + meeting_duration\n            # Format the meeting time as HH:MM:HH:MM.\n            print(f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\")\n            return\n\nfind_meeting_time()\n'''",
            "count": "calendar_scheduling_example_75"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import timedelta, datetime\n\ndef time_to_minutes(time_str):\n    \"\"\"Convert HH:MM to minutes since midnight.\"\"\"\n    h, m = map(int, time_str.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    \"\"\"Convert minutes since midnight to HH:MM (24-hour format).\"\"\"\n    return f\"{m // 60:02}:{m % 60:02}\"\n\n# Define workday start and end in minutes\nworkday_start = time_to_minutes(\"09:00\")\nworkday_end   = time_to_minutes(\"17:00\")\nmeeting_duration = 60  # in minutes\n\n# Busy intervals for each participant in minutes\n# For clarity, intervals are given as (start, end) where times are in HH:MM format.\nbusy = {\n    \"Joyce\": [],\n    \"Beverly\": [(\"09:30\", \"10:00\"), (\"11:00\", \"11:30\"), (\"12:30\", \"13:00\"), \n                (\"14:00\", \"14:30\"), (\"15:30\", \"16:00\"), (\"16:30\", \"17:00\")],\n    \"Peter\": [(\"09:30\", \"10:30\"), (\"11:30\", \"13:00\"), (\"14:30\", \"15:30\"), \n              (\"16:30\", \"17:00\")]\n}\n\ndef invert_busy(busy_intervals):\n    \"\"\"Given busy intervals, return free intervals within the workday.\"\"\"\n    free_intervals = []\n    # Start with beginning of workday\n    current = workday_start\n    for start, end in sorted(busy_intervals, key=lambda x: time_to_minutes(x[0])):\n        busy_start = time_to_minutes(start)\n        busy_end = time_to_minutes(end)\n        if current < busy_start:\n            free_intervals.append((current, busy_start))\n        current = max(current, busy_end)\n    if current < workday_end:\n        free_intervals.append((current, workday_end))\n    return free_intervals\n\n# Get free intervals for each participant\nfree = {}\nfor participant, intervals in busy.items():\n    free[participant] = invert_busy(intervals)\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Intersect two lists of intervals.\"\"\"\n    i, j = 0, 0\n    intersection = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # The intersection of intervals is given by the max of the starts and the min of the ends.\n        start = max(start1, start2)\n        end = min(end1, end2)\n        if start < end:\n            intersection.append((start, end))\n        # Move the pointer that ends earlier.\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\n# Start with the free intervals of the first participant (Joyce)\ncommon_free = free[\"Joyce\"]\n\n# Intersect with free intervals of other participants\nfor participant in [\"Beverly\", \"Peter\"]:\n    common_free = intersect_intervals(common_free, free[participant])\n\n# Now, search for an interval that can accommodate the meeting duration.\nmeeting_time = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        meeting_time = (start, start + meeting_duration)\n        break\n\nif meeting_time:\n    start_str = minutes_to_time(meeting_time[0])\n    end_str = minutes_to_time(meeting_time[1])\n    # Output in the format HH:MM:HH:MM\n    print(f\"{start_str}:{end_str}\")\nelse:\n    print(\"No meeting slot available.\")\n'''",
            "count": "calendar_scheduling_example_76"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    hours, minutes = map(int, t.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(m):\n    return f\"{m // 60:02d}:{m % 60:02d}\"\n\n# Meeting constraints\nmeeting_duration = 30\n# Work hours are 09:00 to 17:00, but Donald prefers the meeting to be before 12:00.\nmeeting_start_limit = time_to_minutes(\"09:00\")\nmeeting_end_limit = time_to_minutes(\"12:00\")\n\n# Blocked times for each participant (converted to minutes)\ndonald_blocks = [\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"11:30\")),\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"16:30\")),\n]\n\njoyce_blocks = [\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\")),\n]\n\nabigail_blocks = [\n    (time_to_minutes(\"9:30\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"14:00\")),\n    (time_to_minutes(\"15:00\"), time_to_minutes(\"17:00\")),\n]\n\ndef get_free_intervals(blocks, start, end):\n    # Returns free intervals between start and end given blocked intervals.\n    free = []\n    current = start\n    for b_start, b_end in sorted(blocks):\n        # Only consider blocks that fall within or overlap our overall window.\n        if b_end <= start or b_start >= end:\n            continue\n        if b_start > current:\n            free.append((current, min(b_start, end)))\n        current = max(current, b_end)\n    if current < end:\n        free.append((current, end))\n    return free\n\n# Calculate free intervals for each participant within Monday's meeting window.\ndonald_free = get_free_intervals(donald_blocks, meeting_start_limit, meeting_end_limit)\njoyce_free = get_free_intervals(joyce_blocks, meeting_start_limit, meeting_end_limit)\nabigail_free = get_free_intervals(abigail_blocks, meeting_start_limit, meeting_end_limit)\n\ndef find_common_slot(free_lists, duration):\n    # Check each free interval combination to find an overlapping slot with at least the given duration.\n    for interval_d in free_lists[0]:\n        for interval_j in free_lists[1]:\n            # Overlap between Donald and Joyce\n            start_overlap = max(interval_d[0], interval_j[0])\n            end_overlap = min(interval_d[1], interval_j[1])\n            if end_overlap - start_overlap >= duration:\n                for interval_a in free_lists[2]:\n                    common_start = max(start_overlap, interval_a[0])\n                    common_end = min(end_overlap, interval_a[1])\n                    if common_end - common_start >= duration:\n                        return common_start, common_start + duration\n    return None\n\ncommon_slot = find_common_slot([donald_free, joyce_free, abigail_free], meeting_duration)\n\nif common_slot:\n    meeting_start = minutes_to_time(common_slot[0])\n    meeting_end = minutes_to_time(common_slot[1])\n    # Output in the format HH:MM:HH:MM\n    print(f\"{meeting_start}:{meeting_end}\")\nelse:\n    print(\"No available slot found\")\n'''",
            "count": "calendar_scheduling_example_77"
        },
        {
            "final_program_time": "{12:30:13:30}",
            "expected_time": "{12:30:13:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    \"\"\"Converts time in HH:MM format (string) to minutes since midnight.\"\"\"\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    \"\"\"Converts minutes since midnight to HH:MM format.\"\"\"\n    return f\"{m//60:02d}:{m%60:02d}\"\n\ndef invert_busy(busy_intervals, work_start, work_end):\n    \"\"\"Given a list of busy intervals and a work window, return free intervals.\"\"\"\n    free_intervals = []\n    current = work_start\n    for interval in sorted(busy_intervals):\n        start, end = interval\n        if start > current:\n            free_intervals.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free_intervals.append((current, work_end))\n    return free_intervals\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Intersect two lists of intervals. Each interval is a tuple (start, end).\"\"\"\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        start = max(start1, start2)\n        end = min(end1, end2)\n        if start + meeting_duration <= end:\n            result.append((start, end))\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Meeting parameters\nmeeting_duration = 60  # minutes\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Participants' busy schedules on Monday (times in HH:MM format)\n# Ronald: 09:00-10:00, 11:00-12:00\nronald_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"12:00\"))\n]\n\n# Teresa: 10:30-11:00, 14:00-14:30\nteresa_busy = [\n    (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"14:30\"))\n]\n\n# Carol: 09:00-12:30, 14:00-15:30, 16:00-17:00\ncarol_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"12:30\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"15:30\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"17:00\"))\n]\n\n# Compute free intervals for each participant within work hours\nronald_free = invert_busy(ronald_busy, work_start, work_end)\nteresa_free = invert_busy(teresa_busy, work_start, work_end)\ncarol_free  = invert_busy(carol_busy, work_start, work_end)\n\n# Find intersection of free intervals between participants\n# Intersect Ronald and Teresa\nintersect_rt = intersect_intervals(ronald_free, teresa_free)\n# Intersect the above result with Carol's free intervals\ncommon_free = intersect_intervals(intersect_rt, carol_free)\n\n# Find the first interval that can accommodate the meeting duration\nproposed_start = None\nfor start, end in common_free:\n    if start + meeting_duration <= end:\n        proposed_start = start\n        break\n\nif proposed_start is not None:\n    proposed_end = proposed_start + meeting_duration\n    print(f\"{minutes_to_time(proposed_start)}:{minutes_to_time(proposed_end)}\")\nelse:\n    print(\"No available meeting slot found.\")\n'''",
            "count": "calendar_scheduling_example_78"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    \"\"\"Converts a HH:MM time string to minutes from midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    \"\"\"Converts minutes from midnight to a HH:MM time string.\"\"\"\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02}:{mins:02}\"\n\ndef is_interval_free(start, end, busy_times):\n    \"\"\"Checks if the interval [start, end) is free given a list of busy intervals.\"\"\"\n    for b_start, b_end in busy_times:\n        # If the meeting overlaps with any busy slot, return False.\n        if not (end <= b_start or start >= b_end):\n            return False\n    return True\n\ndef find_meeting_slot(participants_busy, work_start, work_end, meeting_duration):\n    for candidate_start in range(work_start, work_end - meeting_duration + 1):\n        candidate_end = candidate_start + meeting_duration\n        # Check each participant's schedule.\n        if all(is_interval_free(candidate_start, candidate_end, busy_times) \n               for busy_times in participants_busy):\n            return candidate_start, candidate_end\n    return None\n\ndef main():\n    # Define workday boundaries in minutes (9:00 to 17:00)\n    work_start = time_to_minutes(\"09:00\")\n    work_end = time_to_minutes(\"17:00\")\n    \n    # Meeting duration in minutes (1 hour)\n    meeting_duration = 60\n    \n    # Define each participant's busy times as lists of tuples (start, end) in minutes.\n    amy_busy = [(time_to_minutes(\"11:00\"), time_to_minutes(\"11:30\")),\n                (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\"))]\n    emma_busy = []  # Emma has no meetings.\n    john_busy = [(time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n                 (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n                 (time_to_minutes(\"12:30\"), time_to_minutes(\"16:00\")),\n                 (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))]\n    \n    # List of busy schedules for all participants.\n    participants_busy = [amy_busy, emma_busy, john_busy]\n    \n    slot = find_meeting_slot(participants_busy, work_start, work_end, meeting_duration)\n    if slot:\n        start, end = slot\n        print(f\"{minutes_to_time(start)}:{minutes_to_time(end)}\")\n    else:\n        print(\"No available meeting slot found.\")\n\nif __name__ == \"__main__\":\n    main()\n'''",
            "count": "calendar_scheduling_example_79"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\ndef time_to_minutes(t):\n    return t.hour * 60 + t.minute\n\ndef minutes_to_time(minutes):\n    return datetime(1900, 1, 1, minutes // 60, minutes % 60)\n\n# Define work hours constraints\nwork_start = time_to_minutes(datetime(1900,1,1,9,0))\nwork_end = time_to_minutes(datetime(1900,1,1,17,0))\n\n# Alexis prefers not meeting after 15:00, so meeting must end by 15:00.\nlatest_meeting_end = time_to_minutes(datetime(1900,1,1,15,0))\n\nmeeting_duration = 30\n\n# Busy intervals for each participant (in minutes from midnight)\n# Format: (start_in_minutes, end_in_minutes)\nbusy_michelle = [\n    (time_to_minutes(datetime(1900,1,1,9,30)), time_to_minutes(datetime(1900,1,1,10,0))),\n    (time_to_minutes(datetime(1900,1,1,12,30)), time_to_minutes(datetime(1900,1,1,13,0)))\n]\n\nbusy_billy = [\n    (time_to_minutes(datetime(1900,1,1,10,30)), time_to_minutes(datetime(1900,1,1,11,0))),\n    (time_to_minutes(datetime(1900,1,1,11,30)), time_to_minutes(datetime(1900,1,1,12,0))),\n    (time_to_minutes(datetime(1900,1,1,14,30)), time_to_minutes(datetime(1900,1,1,15,0))),\n    (time_to_minutes(datetime(1900,1,1,16,0)), time_to_minutes(datetime(1900,1,1,16,30)))\n]\n\nbusy_alexis = [\n    (time_to_minutes(datetime(1900,1,1,9,30)), time_to_minutes(datetime(1900,1,1,10,30))),\n    (time_to_minutes(datetime(1900,1,1,11,0)), time_to_minutes(datetime(1900,1,1,12,0))),\n    (time_to_minutes(datetime(1900,1,1,12,30)), time_to_minutes(datetime(1900,1,1,13,0))),\n    (time_to_minutes(datetime(1900,1,1,13,30)), time_to_minutes(datetime(1900,1,1,14,30))),\n    (time_to_minutes(datetime(1900,1,1,16,0)), time_to_minutes(datetime(1900,1,1,16,30)))\n]\n\n# Helper function to merge busy intervals into free intervals for a participant\ndef get_free_intervals(busy, start, end):\n    free = []\n    # sort busy intervals just in case\n    busy = sorted(busy, key=lambda x: x[0])\n    current = start\n    for b_start, b_end in busy:\n        if current < b_start:\n            free.append((current, b_start))\n        current = max(current, b_end)\n    if current < end:\n        free.append((current, end))\n    return free\n\n# Calculate free intervals within constraints for each participant.\n# Alexis's constraint: meeting must finish by 15:00, so we limit free time to 15:00.\nfree_michelle = get_free_intervals(busy_michelle, work_start, work_end)\nfree_billy = get_free_intervals(busy_billy, work_start, work_end)\nfree_alexis = get_free_intervals(busy_alexis, work_start, latest_meeting_end)\n\n# Function to find intersection of two lists of intervals\ndef intersect_intervals(intervals1, intervals2):\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        inter_start = max(start1, start2)\n        inter_end = min(end1, end2)\n        if inter_start < inter_end:\n            result.append((inter_start, inter_end))\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Find common free intervals by intersecting the participant free intervals\ncommon_free = intersect_intervals(free_michelle, free_billy)\ncommon_free = intersect_intervals(common_free, free_alexis)\n\n# Find the earliest slot that fits the meeting duration\nmeeting_slot = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        meeting_slot = (start, start + meeting_duration)\n        break\n\nif meeting_slot:\n    start_time = minutes_to_time(meeting_slot[0]).strftime(\"%H:%M\")\n    end_time = minutes_to_time(meeting_slot[1]).strftime(\"%H:%M\")\n    # output in the requested format: HH:MM:HH:MM\n    print(f\"{start_time}:{end_time}\")\nelse:\n    print(\"No valid meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_80"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    hours, minutes = map(int, t.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(m):\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\n# Define work day start and end times\nwork_start = time_to_minutes(\"09:00\")\nwork_end   = time_to_minutes(\"17:00\")\nmeeting_duration = 60\n\n# Participant calendars (busy intervals as (start, end) in minutes)\nbusy = {\n    \"Jeremy\": [(\"14:30\", \"15:30\")],\n    \"Lawrence\": [(\"15:30\", \"16:00\"), (\"16:30\", \"17:00\")],\n    \"Helen\": [(\"9:30\", \"10:00\"), (\"10:30\", \"11:00\"), (\"11:30\", \"12:00\"),\n              (\"13:00\", \"14:00\"), (\"15:00\", \"15:30\"), (\"16:00\", \"17:00\")]\n}\n\ndef get_free_intervals(busy_intervals):\n    # Convert busy intervals to minutes and sort them\n    busy_minutes = []\n    for start, end in busy_intervals:\n        busy_minutes.append( (time_to_minutes(start), time_to_minutes(end)) )\n    busy_minutes.sort()\n    \n    free = []\n    current = work_start\n    for b_start, b_end in busy_minutes:\n        if current < b_start:\n            free.append((current, b_start))\n        current = max(current, b_end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\n# Get free intervals for each participant\nfree_intervals = {}\nfor person, intervals in busy.items():\n    free_intervals[person] = get_free_intervals(intervals)\n\n# Function to intersect two lists of intervals\ndef intersect_intervals(intervals1, intervals2):\n    i, j = 0, 0\n    intersection = []\n    while i < len(intervals1) and j < len(intervals2):\n        a_start, a_end = intervals1[i]\n        b_start, b_end = intervals2[j]\n        start_int = max(a_start, b_start)\n        end_int = min(a_end, b_end)\n        if start_int < end_int:\n            intersection.append((start_int, end_int))\n        if a_end < b_end:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\n# Compute common free intervals among all participants\ncommon_free = free_intervals[\"Jeremy\"]\nfor person in [\"Lawrence\", \"Helen\"]:\n    common_free = intersect_intervals(common_free, free_intervals[person])\n\n# Now, find an interval with at least the meeting duration\nmeeting_time = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        meeting_time = (start, start + meeting_duration)\n        break\n\nif meeting_time:\n    start_str = minutes_to_time(meeting_time[0])\n    end_str = minutes_to_time(meeting_time[1])\n    print(f\"{start_str}:{end_str}\")\nelse:\n    print(\"No available slot found\")\n    \n# The expected output is 12:00:13:00 based on the provided schedule.\n'''",
            "count": "calendar_scheduling_example_81"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    \"\"\"Converts a HH:MM string to minutes since midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    \"\"\"Converts minutes since midnight to a HH:MM string.\"\"\"\n    h = minutes // 60\n    m = minutes % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef complement_intervals(busy_intervals, work_start, work_end):\n    \"\"\"Given a sorted list of busy intervals (start, end) in minutes,\n    return a list of free intervals within the work period.\"\"\"\n    free = []\n    current = work_start\n    for start, end in busy_intervals:\n        if current < start:\n            free.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Intersect two lists of intervals. Both lists contain tuples (start, end).\"\"\"\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find overlap if any\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap < end_overlap:\n            result.append((start_overlap, end_overlap))\n        # Move the pointer for the interval that ends first\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef schedule_meeting():\n    # Define working hours in minutes\n    work_start = time_to_minutes(\"09:00\")\n    work_end = time_to_minutes(\"17:00\")\n    meeting_duration = 30  # 30 minutes\n\n    # Busy schedules in minutes (start, end)\n    michael_busy = [\n        (time_to_minutes(\"09:30\"), time_to_minutes(\"10:30\")),\n        (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\")),\n        (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\")),\n    ]\n    eric_busy = [\n        # Eric is wide open, so no busy intervals\n    ]\n    arthur_busy = [\n        (time_to_minutes(\"09:00\"), time_to_minutes(\"12:00\")),\n        (time_to_minutes(\"13:00\"), time_to_minutes(\"15:00\")),\n        (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\")),\n        (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\")),\n    ]\n\n    # Sort busy intervals (they are assumed to be non-overlapping and sorted)\n    michael_busy.sort()\n    eric_busy.sort()  # remains empty\n    arthur_busy.sort()\n\n    # Compute free intervals by taking complement within working hours\n    michael_free = complement_intervals(michael_busy, work_start, work_end)\n    eric_free = [(work_start, work_end)]  # Entire day free\n    arthur_free = complement_intervals(arthur_busy, work_start, work_end)\n\n    # Find common free intervals among all participants\n    common_free = intersect_intervals(michael_free, eric_free)\n    common_free = intersect_intervals(common_free, arthur_free)\n\n    # Choose the first common interval that fits the meeting duration\n    meeting_time = None\n    for start, end in common_free:\n        if end - start >= meeting_duration:\n            meeting_time = (start, start + meeting_duration)\n            break\n\n    if meeting_time:\n        meeting_start, meeting_end = meeting_time\n        # Print the meeting time in the format HH:MM:HH:MM enclosed in {}\n        print(f\"{{{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}}}\")\n    else:\n        print(\"No common free slot available.\")\n\nif __name__ == \"__main__\":\n    schedule_meeting()\n'''",
            "count": "calendar_scheduling_example_82"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{10:00:11:00}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\ndef time_to_minutes(t):\n    # t is a string \"HH:MM\"\n    h, m = map(int, t.split(':'))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    # returns time string in HH:MM format, ensuring two digits per field\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\n# Define working hours in minutes (09:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nmeeting_duration = 60  # duration in minutes\n\n# Busy times provided for each person - in (start, end) as strings\nbusy_times = {\n    \"Anthony\": [(\"14:00\", \"14:30\"), (\"15:00\", \"15:30\")],\n    \"Ronald\":  [(\"09:00\", \"10:00\"), (\"12:00\", \"12:30\"), (\"13:30\", \"14:00\")],\n    \"Jonathan\":[(\"09:00\", \"10:00\"), (\"11:00\", \"11:30\"), (\"12:00\", \"13:00\"),\n                (\"14:00\", \"14:30\"), (\"15:00\", \"17:00\")]\n}\n\n# Convert busy times to minutes and combine into one list\nall_busy = []\nfor person, intervals in busy_times.items():\n    for start, end in intervals:\n        all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n\n# Sort busy intervals by start time\nall_busy.sort(key=lambda x: x[0])\n\n# Merge overlapping busy intervals\nmerged_busy = []\nfor interval in all_busy:\n    if not merged_busy:\n        merged_busy.append(interval)\n    else:\n        prev_start, prev_end = merged_busy[-1]\n        curr_start, curr_end = interval\n        if curr_start <= prev_end:\n            merged_busy[-1] = (prev_start, max(prev_end, curr_end))\n        else:\n            merged_busy.append(interval)\n\n# Determine free intervals within working hours by subtracting busy intervals\nfree_intervals = []\ncurrent = work_start\nfor start, end in merged_busy:\n    if start > current:\n        free_intervals.append((current, start))\n    current = max(current, end)\nif current < work_end:\n    free_intervals.append((current, work_end))\n\n# Find first free interval that can accommodate the meeting duration\nmeeting_slot = None\nfor start, end in free_intervals:\n    if end - start >= meeting_duration:\n        meeting_slot = (start, start + meeting_duration)\n        break\n\nif meeting_slot:\n    meeting_start = minutes_to_time(meeting_slot[0])\n    meeting_end = minutes_to_time(meeting_slot[1])\n    print(f\"{meeting_start}:{meeting_end}\")\nelse:\n    print(\"No available time slot\")\n'''",
            "count": "calendar_scheduling_example_83"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_time(minutes):\n    \"\"\"Convert minutes since midnight to HH:MM format.\"\"\"\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\ndef find_free_intervals(busy_intervals, work_start, work_end):\n    \"\"\"\n    Given a list of busy intervals (in minutes) and a work day start and end,\n    return a list of free intervals (start, end) in minutes.\n    \"\"\"\n    # Sort the busy intervals by start time.\n    busy_intervals = sorted(busy_intervals, key=lambda x: x[0])\n    free_intervals = []\n    \n    # If there's time between work_start and first busy interval, add that as free.\n    if busy_intervals:\n        if work_start < busy_intervals[0][0]:\n            free_intervals.append((work_start, busy_intervals[0][0]))\n    else:\n        free_intervals.append((work_start, work_end))\n        return free_intervals\n\n    # Go through consecutive busy intervals.\n    for i in range(len(busy_intervals) - 1):\n        current_end = busy_intervals[i][1]\n        next_start = busy_intervals[i+1][0]\n        if current_end < next_start:\n            free_intervals.append((current_end, next_start))\n            \n    # Check time between last busy interval and work_end.\n    if busy_intervals[-1][1] < work_end:\n        free_intervals.append((busy_intervals[-1][1], work_end))\n    return free_intervals\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Return the intersection of two lists of intervals.\"\"\"\n    intersection = []\n    i, j = 0, 0\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find overlap interval\n        overlap_start = max(start1, start2)\n        overlap_end = min(end1, end2)\n        if overlap_start < overlap_end:\n            intersection.append((overlap_start, overlap_end))\n        # Move to the next interval in the list that ends first.\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\ndef intersect_multiple(interval_lists):\n    \"\"\"Return the intersection of multiple lists of intervals.\"\"\"\n    if not interval_lists:\n        return []\n    common = interval_lists[0]\n    for intervals in interval_lists[1:]:\n        common = intersect_intervals(common, intervals)\n    return common\n\ndef main():\n    # Define work day start and end in minutes from midnight (9:00 to 17:00)\n    work_start = 9 * 60    # 540 minutes\n    work_end = 17 * 60     # 1020 minutes\n    meeting_duration = 60  # in minutes\n\n    # Busy intervals for each participant on Monday (converted to minutes)\n    # Kevin: 9:30-10:00, 10:30-11:00, 15:00-16:00\n    kevin_busy = [\n        (9 * 60 + 30, 10 * 60),      # 9:30 to 10:00\n        (10 * 60 + 30, 11 * 60),     # 10:30 to 11:00\n        (15 * 60, 16 * 60)           # 15:00 to 16:00\n    ]\n    # Ryan: 10:30-11:30, 12:30-13:00, 13:30-14:00\n    ryan_busy = [\n        (10 * 60 + 30, 11 * 60 + 30), # 10:30 to 11:30\n        (12 * 60 + 30, 13 * 60),      # 12:30 to 13:00\n        (13 * 60 + 30, 14 * 60)       # 13:30 to 14:00\n    ]\n    # Eugene: 9:00-9:30, 10:00-11:00, 12:30-17:00\n    eugene_busy = [\n        (9 * 60, 9 * 60 + 30),        # 9:00 to 9:30\n        (10 * 60, 11 * 60),           # 10:00 to 11:00\n        (12 * 60 + 30, 17 * 60)       # 12:30 to 17:00\n    ]\n\n    # Compute free intervals for each participant.\n    kevin_free = find_free_intervals(kevin_busy, work_start, work_end)\n    ryan_free = find_free_intervals(ryan_busy, work_start, work_end)\n    eugene_free = find_free_intervals(eugene_busy, work_start, work_end)\n\n    # Get common free intervals across all participants.\n    common_free = intersect_multiple([kevin_free, ryan_free, eugene_free])\n\n    # Find a free interval that can accommodate a meeting of given duration.\n    meeting_time = None\n    for start, end in common_free:\n        if end - start >= meeting_duration:\n            meeting_time = (start, start + meeting_duration)\n            break\n\n    if meeting_time:\n        # Format the output as HH:MM:HH:MM within curly braces.\n        start_time_str = minutes_to_time(meeting_time[0])\n        end_time_str = minutes_to_time(meeting_time[1])\n        print(f\"{{{start_time_str}:{end_time_str}}}\")\n    else:\n        print(\"No available time slot found.\")\n\nif __name__ == \"__main__\":\n    main()\n'''",
            "count": "calendar_scheduling_example_84"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import timedelta, datetime\n\n# Define meeting duration in minutes\nMEETING_DURATION = 30\n\n# Define work day start and end times (in minutes from midnight)\nWORK_START = 9 * 60      # 9:00 AM -> 540 minutes\nWORK_END = 17 * 60       # 17:00 -> 1020 minutes\n\n# Julia's constraint: meeting must end on or before 13:30 (810 minutes)\nJULIA_END = 13 * 60 + 30  # 13:30 -> 810 minutes\n\n# Busy intervals for each participant (in minutes from midnight)\n# Each tuple represents (start, end) in minutes.\nkelly_busy = []  # Kelly is free all day\n\njulia_busy = [\n    (9 * 60 + 30, 10 * 60),    # 09:30 to 10:00\n    (14 * 60, 14 * 60 + 30),   # 14:00 to 14:30\n    (15 * 60, 15 * 60 + 30),   # 15:00 to 15:30\n    (16 * 60 + 30, 17 * 60)    # 16:30 to 17:00\n]\n\nmartha_busy = [\n    (9 * 60, 11 * 60),         # 09:00 to 11:00\n    (12 * 60, 15 * 60)         # 12:00 to 15:00\n]\n\ndef is_slot_free(start, end, busy_intervals):\n    \"\"\"\n    Returns True if the time slot [start, end) in minutes does NOT conflict with any busy interval.\n    \"\"\"\n    for busy_start, busy_end in busy_intervals:\n        # Check if the meeting overlaps with a busy interval\n        if start < busy_end and end > busy_start:\n            return False\n    return True\n\ndef minutes_to_time_str(minutes):\n    \"\"\"Convert minutes from midnight to HH:MM format.\"\"\"\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# We iterate over possible starting times in minute increments.\n# Meeting must finish by both WORK_END and Julia's constraint (JULIA_END)\n# Also, since meeting duration is fixed, the latest start time is min(WORK_END, JULIA_END) - MEETING_DURATION.\nlatest_start = min(WORK_END, JULIA_END) - MEETING_DURATION\n\nmeeting_found = False\nproposed_start = None\nfor start in range(WORK_START, latest_start + 1):\n    end = start + MEETING_DURATION\n    # Check if meeting times are within working hours\n    if end > WORK_END:\n        continue\n    # Check Julia's constraint\n    if end > JULIA_END:\n        continue\n    # Check each participant's availability\n    if (is_slot_free(start, end, kelly_busy) and\n        is_slot_free(start, end, julia_busy) and\n        is_slot_free(start, end, martha_busy)):\n        proposed_start = start\n        meeting_found = True\n        break\n\nif meeting_found:\n    meeting_start_str = minutes_to_time_str(proposed_start)\n    meeting_end_str = minutes_to_time_str(proposed_start + MEETING_DURATION)\n    # Output in the format HH:MM:HH:MM\n    print(f\"{meeting_start_str}:{meeting_end_str}\")\nelse:\n    print(\"No available meeting slot was found.\")\n'''",
            "count": "calendar_scheduling_example_85"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import timedelta, datetime\n\n# Helper function to convert time string \"HH:MM\" to minutes since 00:00\ndef time_to_minutes(t):\n    h, m = map(int, t.split(':'))\n    return h * 60 + m\n\n# Helper function to convert minutes to time string \"HH:MM\"\ndef minutes_to_time(m):\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\n# Function to compute free intervals given work start, work end and busy intervals (sorted and non overlapping)\ndef compute_free_intervals(busy, work_start, work_end):\n    free = []\n    current = work_start\n    for b_start, b_end in busy:\n        if current < b_start:\n            free.append((current, b_start))\n        current = max(current, b_end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\n# Intersection of two lists of intervals\ndef intersect_intervals(intervals1, intervals2):\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Get the intersection start and end\n        start = max(start1, start2)\n        end = min(end1, end2)\n        if start < end:\n            result.append((start, end))\n        # Move the pointer with the smallest end time\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Meeting constraints\nmeeting_duration = 60  # in minutes\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Busy intervals for each person in minutes (start, end)\n# Samuel's busy intervals: 09:00-09:30, 10:00-10:30, 12:00-12:30, 14:00-15:00, 16:00-16:30\ns_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))\n]\n\n# Emma is free the entire day, so no busy intervals.\ne_busy = []\n\n# Brittany's busy intervals: 11:30-14:30, 15:00-15:30, 16:30-17:00\nb_busy = [\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"14:30\")),\n    (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\")),\n    (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))\n]\n\n# Compute free intervals for each person\ns_free = compute_free_intervals(s_busy, work_start, work_end)\ne_free = compute_free_intervals(e_busy, work_start, work_end)\nb_free = compute_free_intervals(b_busy, work_start, work_end)\n\n# Get common free intervals across all participants\ncommon_free = intersect_intervals(s_free, e_free)\ncommon_free = intersect_intervals(common_free, b_free)\n\n# Find the first interval that can fit the meeting_duration\nmeeting_time = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        meeting_time = (start, start + meeting_duration)\n        break\n\nif meeting_time:\n    start_str = minutes_to_time(meeting_time[0])\n    end_str = minutes_to_time(meeting_time[1])\n    print(f\"{{{start_str}:{end_str}}}\")\nelse:\n    print(\"No suitable meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_86"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\ndef time_to_minutes(t):\n    \"\"\"Convert time string 'HH:MM' to minutes from midnight.\"\"\"\n    h, m = map(int, t.split(':'))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    \"\"\"Convert minutes from midnight to time string 'HH:MM'.\"\"\"\n    return f\"{m//60:02d}:{m%60:02d}\"\n\ndef subtract_busy(base, busy):\n    \"\"\"\n    Given a base interval [start, end] and a list of busy intervals,\n    subtract busy intervals from the base.\n    Each interval is represented as a tuple (start, end) in minutes.\n    Returns a list of free intervals.\n    \"\"\"\n    free_intervals = []\n    current_start = base[0]\n    \n    for bstart, bend in sorted(busy):\n        if bstart > current_start:\n            free_intervals.append((current_start, min(bstart, base[1])))\n        current_start = max(current_start, bend)\n        if current_start >= base[1]:\n            break\n    if current_start < base[1]:\n        free_intervals.append((current_start, base[1]))\n    return free_intervals\n\ndef intersect_intervals(ints1, ints2):\n    \"\"\"Intersect two lists of intervals.\"\"\"\n    i, j = 0, 0\n    result = []\n    while i < len(ints1) and j < len(ints2):\n        start = max(ints1[i][0], ints2[j][0])\n        end = min(ints1[i][1], ints2[j][1])\n        if start < end:\n            result.append((start, end))\n        if ints1[i][1] < ints2[j][1]:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef find_meeting_slot(intersection, duration):\n    \"\"\"\n    Given a list of intervals and a required duration (in minutes),\n    returns the first interval that can accommodate the meeting.\n    \"\"\"\n    for start, end in intersection:\n        if end - start >= duration:\n            return (start, start + duration)\n    return None\n\n# Define work hours and meeting duration of 30 minutes.\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nwork_interval = (work_start, work_end)\nmeeting_duration = 30\n\n# Busy intervals for each participant in minutes.\nbrittany_busy = [(time_to_minutes(\"12:00\"), time_to_minutes(\"13:30\")),\n                  (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\")),\n                  (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\")),\n                  (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))]\n\nwayne_busy = [(time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n               (time_to_minutes(\"13:00\"), time_to_minutes(\"15:00\")),\n               (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))]\n\ncharles_busy = [(time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n                (time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n                (time_to_minutes(\"11:30\"), time_to_minutes(\"13:30\")),\n                (time_to_minutes(\"14:30\"), time_to_minutes(\"16:30\"))]\n\n# Calculate free intervals for each participant by subtracting busy intervals from work hours.\nbrittany_free = subtract_busy(work_interval, brittany_busy)\nwayne_free = subtract_busy(work_interval, wayne_busy)\ncharles_free = subtract_busy(work_interval, charles_busy)\n\n# Find common free intervals across all participants.\ncommon_free = intersect_intervals(brittany_free, wayne_free)\ncommon_free = intersect_intervals(common_free, charles_free)\n\n# Find a meeting slot in the common free intervals.\nslot = find_meeting_slot(common_free, meeting_duration)\n\nif slot:\n    meeting_start = minutes_to_time(slot[0])\n    meeting_end = minutes_to_time(slot[1])\n    print(f\"{meeting_start}:{meeting_end}\")\nelse:\n    print(\"No available meeting slot.\")\n'''",
            "count": "calendar_scheduling_example_87"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\ndef get_free_intervals(start, end, busy_intervals):\n    # busy_intervals should be sorted and merged if necessary\n    free_intervals = []\n    current = start\n    for b_start, b_end in busy_intervals:\n        if current < b_start:\n            free_intervals.append((current, b_start))\n        current = max(current, b_end)\n    if current < end:\n        free_intervals.append((current, end))\n    return free_intervals\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Return the intersection of two lists of intervals.\"\"\"\n    i, j = 0, 0\n    intersections = []\n    while i < len(intervals1) and j < len(intervals2):\n        a_start, a_end = intervals1[i]\n        b_start, b_end = intervals2[j]\n        # Find overlap\n        start_overlap = max(a_start, b_start)\n        end_overlap = min(a_end, b_end)\n        if start_overlap < end_overlap:\n            intersections.append((start_overlap, end_overlap))\n        # Move to next interval in list that ends first\n        if a_end < b_end:\n            i += 1\n        else:\n            j += 1\n    return intersections\n\ndef find_meeting_slot(meeting_duration, free_interval):\n    start, end = free_interval\n    if end - start >= meeting_duration:\n        return (start, start + meeting_duration)\n    return None\n\n# Work day in minutes (from midnight)\nwork_start = 9 * 60   # 9:00 -> 540 minutes\nwork_end   = 17 * 60  # 17:00 -> 1020 minutes\nmeeting_duration = 60  # meeting duration in minutes\n\n# Busy schedules in minutes for each participant (start, end).\n# Dennis: free all day, so no busy intervals.\ndennis_busy = []\n\n# Joseph busy: 9:00-9:30, 12:30-13:00\njoseph_busy = [(9 * 60, 9 * 60 + 30), (12 * 60 + 30, 13 * 60)]\n\n# Isabella busy: 9:00-10:30, 11:30-12:00, 13:30-14:00, 14:30-17:00\nisabella_busy = [\n    (9 * 60, 10 * 60 + 30),\n    (11 * 60 + 30, 12 * 60),\n    (13 * 60 + 30, 14 * 60),\n    (14 * 60 + 30, 17 * 60)\n]\n\n# Calculate free intervals from busy intervals for each participant\ndennis_free = get_free_intervals(work_start, work_end, dennis_busy)\njoseph_free = get_free_intervals(work_start, work_end, joseph_busy)\nisabella_free = get_free_intervals(work_start, work_end, isabella_busy)\n\n# Find common free intervals (intersection)\ncommon_free = intersect_intervals(dennis_free, joseph_free)\ncommon_free = intersect_intervals(common_free, isabella_free)\n\n# Find the earliest slot that can fit the meeting duration\nmeeting_slot = None\nfor interval in common_free:\n    slot = find_meeting_slot(meeting_duration, interval)\n    if slot:\n        meeting_slot = slot\n        break\n\nif meeting_slot:\n    start_time = minutes_to_time(meeting_slot[0])\n    end_time = minutes_to_time(meeting_slot[1])\n    print(f\"{start_time}:{end_time}\")\nelse:\n    print(\"No available slot found.\")\n'''",
            "count": "calendar_scheduling_example_88"
        },
        {
            "final_program_time": "{15:00:16:00}",
            "expected_time": "{15:00:16:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    # Convert HH:MM into minutes from midnight\n    hours, minutes = map(int, time_str.split(':'))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    # Convert minutes from midnight into HH:MM format\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\ndef get_free_intervals(busy_intervals, work_start, work_end):\n    # busy_intervals: list of tuples (start, end) in minutes, assumed sorted and non overlapping\n    free_intervals = []\n    if work_start < busy_intervals[0][0]:\n        free_intervals.append((work_start, busy_intervals[0][0]))\n    for i in range(len(busy_intervals)-1):\n        free_intervals.append((busy_intervals[i][1], busy_intervals[i+1][0]))\n    if busy_intervals[-1][1] < work_end:\n        free_intervals.append((busy_intervals[-1][1], work_end))\n    return free_intervals\n\ndef intersect_intervals(intervals1, intervals2):\n    # Returns the intersection of two lists of intervals\n    i, j = 0, 0\n    intersections = []\n    while i < len(intervals1) and j < len(intervals2):\n        start = max(intervals1[i][0], intervals2[j][0])\n        end = min(intervals1[i][1], intervals2[j][1])\n        if start < end:\n            intersections.append((start, end))\n        if intervals1[i][1] < intervals2[j][1]:\n            i += 1\n        else:\n            j += 1\n    return intersections\n\ndef find_common_free_interval(free_times, duration):\n    # free_times is a list of lists of intervals (each interval as (start, end))\n    common = free_times[0]\n    for ft in free_times[1:]:\n        common = intersect_intervals(common, ft)\n    for start, end in common:\n        if end - start >= duration:\n            return start, start + duration\n    return None\n\n# Work hours: 9:00 to 17:00\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nmeeting_duration = 60  # in minutes\n\n# Busy schedules for each participant in HH:MM format\nmichelle_busy = [(\"11:00\", \"12:00\"), (\"14:00\", \"15:00\")]\nandrea_busy = [(\"09:00\", \"09:30\"), (\"11:30\", \"12:30\"), (\"13:30\", \"14:00\"), (\"14:30\", \"15:00\"), (\"16:00\", \"16:30\")]\ndouglas_busy = [(\"09:00\", \"09:30\"), (\"10:00\", \"10:30\"), (\"11:00\", \"15:00\"), (\"16:00\", \"17:00\")]\n\n# Convert busy intervals to minutes\ndef convert_intervals(busy_list):\n    return sorted([(time_to_minutes(start), time_to_minutes(end)) for start, end in busy_list])\n\nmichelle_busy = convert_intervals(michelle_busy)\nandrea_busy = convert_intervals(andrea_busy)\ndouglas_busy = convert_intervals(douglas_busy)\n\n# Get free intervals for each person\nmichelle_free = get_free_intervals(michelle_busy, work_start, work_end)\nandrea_free = get_free_intervals(andrea_busy, work_start, work_end)\ndouglas_free = get_free_intervals(douglas_busy, work_start, work_end)\n\n# Find common free interval that fits the meeting duration\ncommon_interval = find_common_free_interval([michelle_free, andrea_free, douglas_free], meeting_duration)\n\nif common_interval:\n    meeting_start, meeting_end = common_interval\n    print(f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\")\nelse:\n    print(\"No common available interval found.\")\n'''",
            "count": "calendar_scheduling_example_89"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\ndef to_minutes(time_str):\n    \"\"\"Convert HH:MM to minutes past midnight.\"\"\"\n    t = datetime.strptime(time_str, \"%H:%M\")\n    return t.hour * 60 + t.minute\n\ndef to_time_str(minutes):\n    \"\"\"Convert minutes past midnight to HH:MM.\"\"\"\n    hour = minutes // 60\n    minute = minutes % 60\n    return f\"{hour:02d}:{minute:02d}\"\n\ndef invert_busy_intervals(busy_intervals, work_start, work_end):\n    \"\"\"Given sorted busy intervals, return free intervals within work hours.\"\"\"\n    free_intervals = []\n    current = work_start\n    for start, end in busy_intervals:\n        if start > current:\n            free_intervals.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free_intervals.append((current, work_end))\n    return free_intervals\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Intersect two lists of intervals.\"\"\"\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Calculate the intersection\n        start_int = max(start1, start2)\n        end_int = min(end1, end2)\n        if start_int < end_int:\n            result.append((start_int, end_int))\n        # Move the pointer that has the earliest finishing interval.\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Define meeting parameters.\nmeeting_duration = 30  # minutes\n\n# Workday boundaries Monday: 09:00 to 17:00.\nwork_start = to_minutes(\"09:00\")\nwork_end = to_minutes(\"17:00\")\n# Gloria's constraint: no meetings after 15:30.\ngloria_meeting_end_limit = to_minutes(\"15:30\")\n\n# Busy intervals for each participant given in HH:MM pairs.\n# Times are inclusive of start, exclusive of end.\n# Adam: 9:30-10:00, 10:30-11:00, 11:30-12:00, 16:30-17:00\nadam_busy = [\n    (to_minutes(\"09:30\"), to_minutes(\"10:00\")),\n    (to_minutes(\"10:30\"), to_minutes(\"11:00\")),\n    (to_minutes(\"11:30\"), to_minutes(\"12:00\")),\n    (to_minutes(\"16:30\"), to_minutes(\"17:00\"))\n]\n\n# Willie: 9:00-9:30, 15:30-16:00\nwillie_busy = [\n    (to_minutes(\"09:00\"), to_minutes(\"09:30\")),\n    (to_minutes(\"15:30\"), to_minutes(\"16:00\"))\n]\n\n# Gloria: 9:30-12:30, 13:00-13:30, 15:30-16:00\ngloria_busy = [\n    (to_minutes(\"09:30\"), to_minutes(\"12:30\")),\n    (to_minutes(\"13:00\"), to_minutes(\"13:30\")),\n    (to_minutes(\"15:30\"), to_minutes(\"16:00\"))\n]\n\n# Calculate free intervals for each participant.\nadam_free = invert_busy_intervals(adam_busy, work_start, work_end)\nwillie_free = invert_busy_intervals(willie_busy, work_start, work_end)\ngloria_free = invert_busy_intervals(gloria_busy, work_start, work_end)\n\n# Gloria prefers not to have meetings after 15:30.\n# So restrict Gloria's free intervals to end no later than 15:30.\nadjusted_gloria_free = []\nfor start, end in gloria_free:\n    if start < gloria_meeting_end_limit:\n        adjusted_gloria_free.append((start, min(end, gloria_meeting_end_limit)))\n\n# Intersect free intervals for all participants.\ncommon_free = intersect_intervals(adam_free, willie_free)\ncommon_free = intersect_intervals(common_free, adjusted_gloria_free)\n\n# Find the first interval that can accommodate the meeting_duration.\nmeeting_slot = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        meeting_slot = (start, start + meeting_duration)\n        break\n\nif meeting_slot:\n    start_str = to_time_str(meeting_slot[0])\n    end_str = to_time_str(meeting_slot[1])\n    # Output in the specified format: {HH:MM:HH:MM}\n    print(\"{\" + f\"{start_str}:{end_str}\" + \"}\")\nelse:\n    print(\"No possible meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_90"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    \"\"\"Convert time string HH:MM to minutes since midnight.\"\"\"\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    \"\"\"Convert minutes since midnight to time string HH:MM with leading zeros.\"\"\"\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef get_free_intervals(busy, work_start, work_end):\n    \"\"\"Return list of free intervals (start, end) given busy intervals within work hours.\"\"\"\n    free = []\n    # sort busy intervals by start time\n    busy = sorted(busy, key=lambda x: x[0])\n    current = work_start\n    for start, end in busy:\n        if start > current:\n            free.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Return the intersection between two lists of intervals.\"\"\"\n    i, j = 0, 0\n    intersection = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # find overlap\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap < end_overlap:\n            intersection.append((start_overlap, end_overlap))\n        # move to next interval in the list that ends first\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\ndef find_meeting_slot(free_intervals, duration):\n    \"\"\"Return the first interval in free_intervals that can accommodate duration.\"\"\"\n    for start, end in free_intervals:\n        if end - start >= duration:\n            return start, start + duration\n    return None\n\n# Define working hours\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nmeeting_duration = 60  # in minutes\n\n# Busy schedules for each participant in (start, end) time in minutes\ndanielle_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\")),\n    (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))\n]\n\nbruce_busy = [\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"11:30\")),\n    (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"14:30\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\"))\n]\n\neric_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"11:00\")),\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"15:30\"))\n]\n\n# Get free intervals for each participant\ndanielle_free = get_free_intervals(danielle_busy, work_start, work_end)\nbruce_free = get_free_intervals(bruce_busy, work_start, work_end)\neric_free = get_free_intervals(eric_busy, work_start, work_end)\n\n# Find common free intervals by intersecting the free intervals pairwise\ncommon_free = intersect_intervals(danielle_free, bruce_free)\ncommon_free = intersect_intervals(common_free, eric_free)\n\n# Search for an interval that fits the meeting duration\nmeeting_slot = find_meeting_slot(common_free, meeting_duration)\nif meeting_slot:\n    start, end = meeting_slot\n    # Print in the format HH:MM:HH:MM\n    print(f\"{minutes_to_time(start)}:{minutes_to_time(end)}\")\nelse:\n    print(\"No available slot found.\")\n'''",
            "count": "calendar_scheduling_example_91"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "'''python\ndef minutes(time_str):\n    \"\"\"Convert time HH:MM to total minutes from midnight.\"\"\"\n    hours, mins = map(int, time_str.split(\":\"))\n    return hours * 60 + mins\n\ndef format_time(minutes_val):\n    \"\"\"Convert minutes from midnight to HH:MM format.\"\"\"\n    hours = minutes_val // 60\n    mins = minutes_val % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Intersect two lists of intervals.\n    Each interval is a tuple (start, end) in minutes.\n    Returns a list with the overlapping intervals.\n    \"\"\"\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find the overlap between intervals\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap < end_overlap:\n            result.append((start_overlap, end_overlap))\n        # Move to next interval in the list where end is smallest\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef main():\n    meeting_duration = 60  # in minutes\n    \n    # Work hours: 9:00 to 17:00\n    work_start = minutes(\"09:00\")\n    work_end = minutes(\"17:00\")\n    work_interval = [(work_start, work_end)]\n    \n    # Jacqueline is busy during 09:30-10:00 and 16:30-17:00, so her free intervals are:\n    jacqueline_free = [(work_start, minutes(\"09:30\")),\n                        (minutes(\"10:00\"), minutes(\"16:30\"))]\n    \n    # Henry is free the entire day:\n    henry_free = [(work_start, work_end)]\n    \n    # William is busy during 09:30-10:30, 12:30-15:00, and 15:30-17:00,\n    # so his free intervals are:\n    william_free = [(work_start, minutes(\"09:30\")),\n                    (minutes(\"10:30\"), minutes(\"12:30\")),\n                    (minutes(\"15:00\"), minutes(\"15:30\"))]\n    \n    # Calculate the common free time across all participants.\n    # Start with work hours as the base.\n    common_free = work_interval\n    for free_intervals in [jacqueline_free, henry_free, william_free]:\n        common_free = intersect_intervals(common_free, free_intervals)\n    \n    # Find the earliest interval with enough duration for the meeting.\n    meeting_time = None\n    for start, end in common_free:\n        if end - start >= meeting_duration:\n            meeting_time = (start, start + meeting_duration)\n            break\n    \n    if meeting_time is not None:\n        start_str = format_time(meeting_time[0])\n        end_str = format_time(meeting_time[1])\n        print(f\"{{{start_str}:{end_str}}}\")\n    else:\n        print(\"No available time slot found.\")\n\nif __name__ == \"__main__\":\n    main()\n'''",
            "count": "calendar_scheduling_example_92"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    \"\"\"Converts a time string 'HH:MM' to minutes from midnight.\"\"\"\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    \"\"\"Converts minutes from midnight to a time string 'HH:MM'.\"\"\"\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef get_free_intervals(busy, work_start, work_end):\n    \"\"\"\n    Given a list of busy intervals (each a tuple (start, end) in minutes),\n    return the list of free intervals within the work hours [work_start, work_end].\n    Assumes busy intervals are sorted by start time.\n    \"\"\"\n    free = []\n    current = work_start\n    for start, end in busy:\n        if start > current:\n            free.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Find the intersection between two lists of intervals.\"\"\"\n    i, j = 0, 0\n    intersection = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # The overlapping part:\n        start = max(start1, start2)\n        end = min(end1, end2)\n        if start < end:\n            intersection.append((start, end))\n        # Move the pointer for the interval that ends first.\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\ndef find_meeting_time(intersections, duration):\n    \"\"\"\n    Given a list of intersected free intervals and a meeting duration,\n    return the earliest meeting interval that fits.\n    \"\"\"\n    for start, end in intersections:\n        if end - start >= duration:\n            return (start, start + duration)\n    return None\n\n# Define work hours in minutes (9:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nmeeting_duration = 30  # in minutes\n\n# Define busy schedules for each participant in minutes.\naustin_busy = [\n    (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n    (time_to_minutes(\"13:30\"), time_to_minutes(\"14:00\"))\n]\n\ndanielle_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\"))\n]\n\ncharles_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"11:30\")),\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"17:00\"))\n]\n\n# Calculate free intervals for each participant.\naustin_free = get_free_intervals(austin_busy, work_start, work_end)\ndanielle_free = get_free_intervals(danielle_busy, work_start, work_end)\ncharles_free = get_free_intervals(charles_busy, work_start, work_end)\n\n# Compute the intersection of free intervals across all participants.\nintersection_ad = intersect_intervals(austin_free, danielle_free)\nintersection_all = intersect_intervals(intersection_ad, charles_free)\n\n# Find the earliest meeting time that fits the meeting duration.\nmeeting = find_meeting_time(intersection_all, meeting_duration)\nif meeting:\n    start_time = minutes_to_time(meeting[0])\n    end_time = minutes_to_time(meeting[1])\n    print(f\"{{{start_time}:{end_time}}}\")\nelse:\n    print(\"No available meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_93"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\n# Helper functions to convert between HH:MM string and minutes\ndef time_to_minutes(time_str):\n    h, m = map(int, time_str.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(minutes):\n    h = minutes // 60\n    m = minutes % 60\n    return f\"{h:02d}:{m:02d}\"\n\n# Function to compute free intervals given busy intervals and working period\ndef get_free_intervals(busy_intervals, work_start, work_end):\n    # Sort busy intervals by start time\n    busy_intervals = sorted(busy_intervals, key=lambda x: x[0])\n    free_intervals = []\n    \n    # First free interval from the beginning of the work period to the first busy meeting\n    if work_start < busy_intervals[0][0]:\n        free_intervals.append((work_start, busy_intervals[0][0]))\n    \n    # Free intervals in between busy intervals\n    for i in range(len(busy_intervals) - 1):\n        end_current = busy_intervals[i][1]\n        start_next = busy_intervals[i+1][0]\n        if end_current < start_next:\n            free_intervals.append((end_current, start_next))\n    \n    # Last free interval from end of the last busy meeting to the end of work period\n    if busy_intervals[-1][1] < work_end:\n        free_intervals.append((busy_intervals[-1][1], work_end))\n    \n    return free_intervals\n\n# Function to compute intersection of intervals from multiple lists\ndef intersect_intervals(lists_of_intervals):\n    if not lists_of_intervals:\n        return []\n    # Start with the free intervals of the first person\n    intersection = lists_of_intervals[0]\n    \n    for free_intervals in lists_of_intervals[1:]:\n        new_intersection = []\n        for (s1, e1) in intersection:\n            for (s2, e2) in free_intervals:\n                # Compute overlap\n                start = max(s1, s2)\n                end = min(e1, e2)\n                if start < end:\n                    new_intersection.append((start, end))\n        intersection = new_intersection\n        if not intersection:\n            break\n    return intersection\n\n# Define working hours (in minutes)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nmeeting_duration = 30  # minutes\n\n# Define busy intervals for each participant in minutes (start, end)\n# Nicholas is free all day, so no busy intervals.\nnicholas_busy = []\n\n# Elizabeth's busy schedule on Monday\nelizabeth_busy = [\n    (time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"13:30\"), time_to_minutes(\"14:30\")),\n    (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\")),\n    (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))\n]\n\n# Sandra's busy schedule on Monday\nsandra_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"9:30\")),\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"13:30\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"16:30\"))\n]\n# Additional constraint: Sandra cannot meet before 13:00.\n# So, we adjust Sandra's effective work start time.\nsandra_work_start = max(work_start, time_to_minutes(\"13:00\"))\nsandra_work_end = work_end\n\n# For Nicholas, since he's free all day, his busy list is empty.\n# To use the same function, we can set his busy intervals as an empty list.\n# For computation of free intervals, if no busy intervals, the free interval is the whole working period.\ndef get_free_for_whole_day(work_start, work_end):\n    return [(work_start, work_end)]\n\nnicholas_free = get_free_for_whole_day(work_start, work_end)\nelizabeth_free = get_free_intervals(elizabeth_busy, work_start, work_end)\nsandra_free = get_free_intervals(sandra_busy, sandra_work_start, sandra_work_end)\n\n# Compute the intersection of free intervals of all participants\nall_free = intersect_intervals([nicholas_free, elizabeth_free, sandra_free])\n\n# Find the first interval that can accommodate the meeting duration\nmeeting_time = None\nfor start, end in all_free:\n    if end - start >= meeting_duration:\n        meeting_time = (start, start + meeting_duration)\n        break\n\nif meeting_time:\n    start_formatted = minutes_to_time(meeting_time[0])\n    end_formatted = minutes_to_time(meeting_time[1])\n    # Output format HH:MM:HH:MM\n    print(f\"{{{start_formatted}:{end_formatted}}}\")\nelse:\n    print(\"No available meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_94"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\n# Helper function to convert time string \"HH:MM\" to minutes since midnight\ndef time_to_minutes(t):\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\n# Helper function to convert minutes since midnight to time string \"HH:MM\"\ndef minutes_to_time(m):\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\n# Function to compute free intervals given working hours and busy intervals.\n# busy_intervals is a list of tuples [(start_str, end_str), ...] in \"HH:MM\" format.\ndef get_free_intervals(work_start, work_end, busy_intervals):\n    free = []\n    current = work_start\n    for interval in sorted(busy_intervals, key=lambda x: time_to_minutes(x[0])):\n        bstart = time_to_minutes(interval[0])\n        bend = time_to_minutes(interval[1])\n        if bstart > current:\n            free.append((current, bstart))\n        current = max(current, bend)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\n# Meeting duration in minutes (30 minutes)\nmeeting_duration = 30\n\n# Define working hours in minutes: 9:00 to 17:00\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Participant schedules (busy intervals)\n# Jennifer: meetings at 12:00-12:30 and 16:00-16:30 and she doesn't want to meet before 12:30.\njennifer_busy = [(\"12:00\", \"12:30\"), (\"16:00\", \"16:30\")]\n# Because of her preference, her effective working window starts at 12:30.\njennifer_effective_start = max(work_start, time_to_minutes(\"12:30\"))\njennifer_free = get_free_intervals(jennifer_effective_start, work_end, jennifer_busy)\n\n# Gary: meetings at 9:30-10:00, 10:30-11:00, 11:30-12:30, 14:00-14:30, 16:30-17:00.\ngary_busy = [(\"09:30\", \"10:00\"), (\"10:30\", \"11:00\"), (\"11:30\", \"12:30\"), (\"14:00\", \"14:30\"), (\"16:30\", \"17:00\")]\ngary_free = get_free_intervals(work_start, work_end, gary_busy)\n\n# Frances: meetings at 9:00-11:00, 11:30-12:30, 13:00-17:00.\nfrances_busy = [(\"09:00\", \"11:00\"), (\"11:30\", \"12:30\"), (\"13:00\", \"17:00\")]\nfrances_free = get_free_intervals(work_start, work_end, frances_busy)\n\n# Function to compute the intersection between two lists of intervals\ndef intersect_intervals(list1, list2):\n    i, j = 0, 0\n    result = []\n    while i < len(list1) and j < len(list2):\n        start = max(list1[i][0], list2[j][0])\n        end = min(list1[i][1], list2[j][1])\n        if start + meeting_duration <= end:  # Ensure enough room for the meeting\n            result.append((start, end))\n        if list1[i][1] < list2[j][1]:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Compute the intersection of free intervals for all participants.\nintersect_jg = intersect_intervals(jennifer_free, gary_free)\ncommon_free = intersect_intervals(intersect_jg, frances_free)\n\n# Find the first interval that can accommodate the meeting\nmeeting_start = None\nfor interval in common_free:\n    if interval[1] - interval[0] >= meeting_duration:\n        meeting_start = interval[0]\n        break\n\nif meeting_start is not None:\n    meeting_end = meeting_start + meeting_duration\n    # Output format: HH:MM:HH:MM enclosed in curly braces.\n    print(f\"{{{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}}}\")\nelse:\n    print(\"No available meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_95"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\n# Helper function: convert HH:MM string to minutes since midnight\ndef time_to_minutes(t):\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\n# Helper function: convert minutes since midnight back to HH:MM string (zero-padded)\ndef minutes_to_time(m):\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\n# Given working hours\nwork_start = time_to_minutes(\"09:00\")\nwork_end   = time_to_minutes(\"17:00\")\n\nmeeting_duration = 30  # minutes\n\n# Busy schedules for each participant (as tuples of start and end in minutes)\n# Christopher's busy times: 09:30-10:00, 10:30-11:00, 11:30-13:00, 15:00-15:30\nchristopher_busy = [\n    (time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\"))\n]\n\n# Robert's busy times: 09:30-10:00, 11:00-11:30, 12:00-12:30, 13:30-14:30, 15:00-15:30\nrobert_busy = [\n    (time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"11:30\")),\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n    (time_to_minutes(\"13:30\"), time_to_minutes(\"14:30\")),\n    (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\"))\n]\n\n# Wayne's busy times: 10:00-17:00\nwayne_busy = [\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"17:00\"))\n]\n\n# Function to compute free intervals from busy intervals within working hours\ndef compute_free_intervals(busy, work_start, work_end):\n    free_intervals = []\n    # Start with the beginning of the work day\n    current = work_start\n    for start, end in sorted(busy):\n        # If there's a gap between current and the next busy start, it's free time.\n        if current < start:\n            free_intervals.append((current, start))\n        # Update current to the end of the busy period if it is later than current.\n        current = max(current, end)\n    # If there's a gap after the last busy time until work_end:\n    if current < work_end:\n        free_intervals.append((current, work_end))\n    return free_intervals\n\n# Compute free intervals for each participant\nchristopher_free = compute_free_intervals(christopher_busy, work_start, work_end)\nrobert_free      = compute_free_intervals(robert_busy, work_start, work_end)\nwayne_free       = compute_free_intervals(wayne_busy, work_start, work_end)\n\n# Function to compute the intersection of two lists of intervals\ndef intersect_intervals(intervals1, intervals2):\n    i, j = 0, 0\n    intersections = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find the overlap between the two intervals\n        start_overlap = max(start1, start2)\n        end_overlap   = min(end1, end2)\n        if start_overlap < end_overlap:\n            intersections.append((start_overlap, end_overlap))\n        # Move the pointer of the interval that ends first.\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersections\n\n# Compute intersection of free intervals for all three participants\nintersection_all = intersect_intervals(christopher_free, robert_free)\nintersection_all = intersect_intervals(intersection_all, wayne_free)\n\n# Find the earliest interval that can accommodate the meeting duration.\nmeeting_time = None\nfor start, end in intersection_all:\n    if end - start >= meeting_duration:\n        meeting_time = (start, start + meeting_duration)\n        break\n\nif meeting_time:\n    start_str = minutes_to_time(meeting_time[0])\n    end_str   = minutes_to_time(meeting_time[1])\n    # Output in the format {HH:MM:HH:MM}\n    print(f\"{{{start_str}:{end_str}}}\")\nelse:\n    print(\"No suitable meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_96"
        },
        {
            "final_program_time": "{16:00:17:00}",
            "expected_time": "{16:00:17:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    \"\"\"Convert time 'HH:MM' to minutes since midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    \"\"\"Convert minutes since midnight to time string 'HH:MM'.\"\"\"\n    return f\"{minutes // 60:02d}:{minutes % 60:02d}\"\n\ndef subtract_busy(working_interval, busy_intervals):\n    \"\"\"\n    Given a working_interval tuple (start, end) and a sorted list of busy intervals,\n    return a list of free intervals within working_interval.\n    Assumes intervals are in minutes.\n    \"\"\"\n    free_intervals = []\n    current_start = working_interval[0]\n    for busy in busy_intervals:\n        busy_start, busy_end = busy\n        if busy_start > current_start:\n            free_intervals.append((current_start, busy_start))\n        current_start = max(current_start, busy_end)\n    if current_start < working_interval[1]:\n        free_intervals.append((current_start, working_interval[1]))\n    return free_intervals\n\ndef intersect_intervals(intervals_a, intervals_b):\n    \"\"\"\n    Given two lists of intervals, return the intersection intervals.\n    Each interval is a tuple (start, end).\n    \"\"\"\n    i, j = 0, 0\n    intersection = []\n    while i < len(intervals_a) and j < len(intervals_b):\n        start_a, end_a = intervals_a[i]\n        start_b, end_b = intervals_b[j]\n        start = max(start_a, start_b)\n        end = min(end_a, end_b)\n        if start < end:\n            intersection.append((start, end))\n        if end_a < end_b:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\n# Define working hours in minutes: 9:00 to 17:00\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nworking_hours = (work_start, work_end)\n\n# Meeting duration in minutes (1 hour)\nmeeting_duration = 60\n\n# Busy intervals for each participant (in minutes)\n# Joseph's busy times and his additional constraint: must not meet before 14:30.\njoseph_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n    (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"15:30\")),\n]\n# Kyle's busy times\nkyle_busy = [\n    (time_to_minutes(\"12:30\"), time_to_minutes(\"13:30\"))\n]\n# Joan's busy times\njoan_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"11:30\")),\n    (time_to_minutes(\"12:30\"), time_to_minutes(\"14:00\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\"))\n]\n\n# Compute free intervals for each participant within working hours\n\njoseph_free = subtract_busy(working_hours, joseph_busy)\nkyle_free = subtract_busy(working_hours, kyle_busy)\njoan_free = subtract_busy(working_hours, joan_busy)\n\n# Apply Joseph's preference: meeting must start at or after 14:30.\njoseph_pref = (time_to_minutes(\"14:30\"), work_end)\n\ndef apply_constraint(free_intervals, constraint):\n    constrained = []\n    for start, end in free_intervals:\n        new_start = max(start, constraint[0])\n        new_end = end\n        if new_start < new_end:\n            constrained.append((new_start, new_end))\n    return constrained\n\njoseph_free = apply_constraint(joseph_free, joseph_pref)\nkyle_free = apply_constraint(kyle_free, joseph_pref)\njoan_free = apply_constraint(joan_free, joseph_pref)\n\n# Find common free intervals across all participants.\ncommon_free = intersect_intervals(joseph_free, kyle_free)\ncommon_free = intersect_intervals(common_free, joan_free)\n\n# Find a common free interval that can accommodate the meeting duration.\nproposed_meeting = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        proposed_meeting = (start, start + meeting_duration)\n        break\n\nif proposed_meeting:\n    start_str = minutes_to_time(proposed_meeting[0])\n    end_str = minutes_to_time(proposed_meeting[1])\n    # Output in the format {HH:MM:HH:MM}\n    print(f\"{{{start_str}:{end_str}}}\")\nelse:\n    print(\"No available meeting time found\")\n'''",
            "count": "calendar_scheduling_example_97"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import timedelta, datetime\n\ndef time_to_minutes(t):\n    \"\"\"Converts a time string (HH:MM) to minutes since midnight.\"\"\"\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    \"\"\"Converts minutes since midnight to a time string (HH:MM).\"\"\"\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\n# Meeting parameters\nmeeting_duration = 30  # minutes\n\n# Working hours boundaries (using Juan's constraint of no meeting after 16:00 for meeting ending)\n# Work hours: 9:00 to 17:00, but Juan cannot meet after 16:00, so meeting must finish by 16:00.\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"16:00\")  # meeting must end by 16:00\n\n# Busy intervals for each participant (in minutes since midnight)\n# Times are given as start (inclusive) and end (exclusive)\nbusy_intervals = []\n\n# Juan's busy times: 9:00-10:30, 15:30-16:00\njuan_busy = [(time_to_minutes(\"09:00\"), time_to_minutes(\"10:30\")),\n             (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\"))]\n\n# Marilyn's busy times: 11:00-11:30, 12:30-13:00\nmarilyn_busy = [(time_to_minutes(\"11:00\"), time_to_minutes(\"11:30\")),\n                (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\"))]\n\n# Ronald's busy times: 9:00-10:30, 12:00-12:30, 13:00-13:30, 14:00-16:30\nronald_busy = [(time_to_minutes(\"09:00\"), time_to_minutes(\"10:30\")),\n               (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n               (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n               (time_to_minutes(\"14:00\"), time_to_minutes(\"16:30\"))]\n\n# Combine all busy intervals\nall_busy = juan_busy + marilyn_busy + ronald_busy\n\n# Filter busy intervals within the working hours (if they extend beyond, we clip them)\nclipped_busy = []\nfor start, end in all_busy:\n    # Clip the interval to working period\n    if end <= work_start or start >= work_end:\n        continue\n    clipped_busy.append((max(start, work_start), min(end, work_end)))\n\n# Sort intervals by start time\nclipped_busy.sort(key=lambda x: x[0])\n\n# Merge overlapping intervals\nmerged_busy = []\nfor interval in clipped_busy:\n    if not merged_busy:\n        merged_busy.append(interval)\n    else:\n        last = merged_busy[-1]\n        if interval[0] <= last[1]:\n            merged_busy[-1] = (last[0], max(last[1], interval[1]))\n        else:\n            merged_busy.append(interval)\n\n# Find free intervals within working hours based on merged busy slots\nfree_intervals = []\ncurrent_start = work_start\nfor start, end in merged_busy:\n    if current_start < start:\n        free_intervals.append((current_start, start))\n    current_start = max(current_start, end)\nif current_start < work_end:\n    free_intervals.append((current_start, work_end))\n\n# Find the first free interval that can accommodate the meeting_duration\nproposed_slot = None\nfor start, end in free_intervals:\n    if end - start >= meeting_duration:\n        proposed_slot = (start, start + meeting_duration)\n        break\n\nif proposed_slot:\n    meeting_start = minutes_to_time(proposed_slot[0])\n    meeting_end = minutes_to_time(proposed_slot[1])\n    # Output in the format {HH:MM:HH:MM}\n    print(f\"{{{meeting_start}:{meeting_end}}}\")\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_98"
        },
        {
            "final_program_time": "{15:00:16:00}",
            "expected_time": "{15:00:16:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_str(minutes):\n    \"\"\"Converts minutes since midnight to HH:MM format.\"\"\"\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Meeting parameters\nmeeting_duration = 60  # minutes\n\n# Define working hours (in minutes from midnight)\nwork_start = 9 * 60   # 09:00 -> 540 minutes\nwork_end = 17 * 60    # 17:00 -> 1020 minutes\n\n# Constraint: Mark prefers meetings not earlier than 15:00.\npreferred_start = 15 * 60  # 900 minutes\n\n# Overall allowed window starts at the later of working start and Mark's preference.\nwindow_start = max(work_start, preferred_start)\nwindow_end = work_end\n\n# Busy intervals for each participant (in minutes from midnight)\n# Format: (start, end)\nbusy_intervals = {\n    \"Stephanie\": [(9 * 60, 9 * 60 + 30), (13 * 60 + 30, 14 * 60)],\n    \"Mark\": [],  # No busy intervals\n    \"Scott\": [(9 * 60, 10 * 60), (11 * 60, 12 * 60 + 30), (14 * 60 + 30, 15 * 60), (16 * 60, 17 * 60)]\n}\n\n# Collect all busy intervals and consider only the parts that intersect our allowed window.\ncombined_busy = []\nfor person, intervals in busy_intervals.items():\n    for start, end in intervals:\n        # If the busy interval overlaps with our allowed window, adjust it.\n        if end <= window_start or start >= window_end:\n            continue  # Does not affect our window\n        busy_start = max(start, window_start)\n        busy_end = min(end, window_end)\n        combined_busy.append((busy_start, busy_end))\n\n# Merge overlapping busy intervals\ncombined_busy.sort()\nmerged_busy = []\nfor interval in combined_busy:\n    if not merged_busy:\n        merged_busy.append(interval)\n    else:\n        last_start, last_end = merged_busy[-1]\n        current_start, current_end = interval\n        if current_start <= last_end:\n            merged_busy[-1] = (last_start, max(last_end, current_end))\n        else:\n            merged_busy.append(interval)\n\n# Find free intervals in the allowed window based on merged busy intervals.\nfree_intervals = []\ncurrent = window_start\nfor busy_start, busy_end in merged_busy:\n    if current < busy_start:\n        free_intervals.append((current, busy_start))\n    current = max(current, busy_end)\nif current < window_end:\n    free_intervals.append((current, window_end))\n\n# Find the first free interval that can accommodate the meeting.\nmeeting_slot = None\nfor free_start, free_end in free_intervals:\n    if free_end - free_start >= meeting_duration:\n        meeting_slot = (free_start, free_start + meeting_duration)\n        break\n\nif meeting_slot:\n    start_time, end_time = meeting_slot\n    # Output in format {HH:MM:HH:MM}\n    print(f\"{{{time_str(start_time)}:{time_str(end_time)}}}\")\nelse:\n    print(\"No available slot found.\")\n'''",
            "count": "calendar_scheduling_example_99"
        }
    ],
    "5shot": [
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_time_str(t):\n    # Given t in minutes after 9:00, return HH:MM (24-hour) format.\n    total_minutes = 9 * 60 + t\n    hours = total_minutes // 60\n    minutes = total_minutes % 60\n    return f\"{hours:02d}:{minutes:02d}\"\n\ndef is_slot_free(start, duration, busy_intervals):\n    end = start + duration\n    for bstart, bend in busy_intervals:\n        # Check if the meeting [start, end) overlaps with a busy interval [bstart, bend)\n        if not (end <= bstart or start >= bend):\n            return False\n    return True\n\n# Busy intervals for each participant in minutes offset from 9:00.\n# Michelle is busy from 11:00 to 12:00 -> (120, 180)\nmichelle_busy = [(120, 180)]\n\n# Steven is busy from 9:00 to 9:30, 11:30 to 12:00, 13:30 to 14:00, 15:30 to 16:00:\nsteven_busy = [(0, 30), (150, 180), (270, 300), (390, 420)]\n\n# Jerry is busy from 9:00 to 9:30, 10:00 to 11:00, 11:30 to 12:30, 13:00 to 14:30, 15:30 to 16:00, 16:30 to 17:00:\njerry_busy = [(0, 30), (60, 120), (150, 210), (240, 330), (390, 420), (450, 480)]\n\nmeeting_duration = 60  # in minutes\nday_start = 0          # 0 corresponds to 9:00\nday_end = 480          # 480 minutes corresponds to 17:00\n\n# Iterate over the possible start times (in minutes from 9:00) such that the meeting fits before end of day.\nfound_slot = None\nfor t in range(day_start, day_end - meeting_duration + 1):\n    if (is_slot_free(t, meeting_duration, michelle_busy) and\n        is_slot_free(t, meeting_duration, steven_busy) and\n        is_slot_free(t, meeting_duration, jerry_busy)):\n        found_slot = t\n        break\n\nif found_slot is not None:\n    start_str = minutes_to_time_str(found_slot)\n    end_str = minutes_to_time_str(found_slot + meeting_duration)\n    # Output in the format {HH:MM:HH:MM}\n    print(f\"{{{start_str}:{end_str}}}\")\nelse:\n    print(\"No available slot found.\")\n'''",
            "count": "calendar_scheduling_example_0"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_str(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\ndef is_free(start, duration, busy_intervals):\n    end = start + duration\n    for b_start, b_end in busy_intervals:\n        # Check if [start, end) overlaps with [b_start, b_end)\n        if start < b_end and end > b_start:\n            return False\n    return True\n\ndef main():\n    meeting_duration = 30  # in minutes\n    work_start = 9 * 60    # 9:00 AM in minutes\n    work_end = 17 * 60     # 17:00 (5:00 PM) in minutes\n    \n    # Billy prefers no meetings after 15:00,\n    # so we require that the meeting ends by 15:00.\n    billy_end_constraint = 15 * 60  # 15:00 in minutes\n    \n    # Define busy intervals for each participant as tuples of (start, end) in minutes.\n    raymond_busy = [\n        (9 * 60, 9 * 60 + 30),       # 09:00 - 09:30\n        (11 * 60 + 30, 12 * 60),      # 11:30 - 12:00\n        (13 * 60, 13 * 60 + 30),      # 13:00 - 13:30\n        (15 * 60, 15 * 60 + 30)       # 15:00 - 15:30\n    ]\n    \n    billy_busy = [\n        (10 * 60, 10 * 60 + 30),      # 10:00 - 10:30\n        (12 * 60, 13 * 60),           # 12:00 - 13:00\n        (16 * 60 + 30, 17 * 60)       # 16:30 - 17:00\n    ]\n    \n    donald_busy = [\n        (9 * 60, 9 * 60 + 30),        # 09:00 - 09:30\n        (10 * 60, 11 * 60),           # 10:00 - 11:00\n        (12 * 60, 13 * 60),           # 12:00 - 13:00\n        (14 * 60, 14 * 60 + 30),      # 14:00 - 14:30\n        (16 * 60, 17 * 60)            # 16:00 - 17:00\n    ]\n    \n    def everyone_free(start):\n        return (is_free(start, meeting_duration, raymond_busy) and\n                is_free(start, meeting_duration, billy_busy) and\n                is_free(start, meeting_duration, donald_busy))\n    \n    # The meeting must finish by Billy's constraint (15:00).\n    latest_start = min(work_end, billy_end_constraint) - meeting_duration\n\n    meeting_start = None\n    for t in range(work_start, latest_start + 1):\n        if everyone_free(t):\n            meeting_start = t\n            break\n            \n    if meeting_start is not None:\n        start_str = minutes_to_str(meeting_start)\n        end_str = minutes_to_str(meeting_start + meeting_duration)\n        print(f\"{{{start_str}:{end_str}}}\")\n    else:\n        print(\"No available time slot found.\")\n\nif __name__ == \"__main__\":\n    main()\n'''",
            "count": "calendar_scheduling_example_1"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "'''python\ndef minutes(t):\n    \"\"\"Convert a time string \"HH:MM\" to minutes since 0:00.\"\"\"\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef time_str(m):\n    \"\"\"Convert minutes since 0:00 to a time string \"HH:MM\".\"\"\"\n    return f\"{m//60:02d}:{m%60:02d}\"\n\ndef subtract_busy(free, busy):\n    \"\"\"Subtract busy intervals from a free interval.\n    free is a tuple (start, end)\n    busy is a list of tuples (start, end)\n    Returns a list of free intervals after subtracting the busy ones.\n    \"\"\"\n    free_intervals = []\n    current_start, current_end = free\n    for b_start, b_end in sorted(busy):\n        if b_end <= current_start or b_start >= current_end:\n            continue  # no overlap\n        if current_start < b_start:\n            free_intervals.append((current_start, b_start))\n        current_start = max(current_start, b_end)\n    if current_start < current_end:\n        free_intervals.append((current_start, current_end))\n    return free_intervals\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Intersect two lists of intervals.\"\"\"\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find intersection\n        start = max(start1, start2)\n        end = min(end1, end2)\n        if start < end:\n            result.append((start, end))\n        # Move the pointer with the earlier ending interval\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef find_slot(free_intervals, duration):\n    \"\"\"Find the earliest slot with given duration from free_intervals.\"\"\"\n    for start, end in free_intervals:\n        if end - start >= duration:\n            return (start, start + duration)\n    return None\n\n# Convert meeting duration to minutes (30 minutes)\nmeeting_duration = 30\n\n# Working hours: 9:00 to 17:00\nwork_start = minutes(\"09:00\")\nwork_end = minutes(\"17:00\")\nworking_interval = (work_start, work_end)\n\n# Participant busy schedules in minutes\n# Roy busy: 9:00-9:30, 10:00-10:30, 11:00-11:30, 12:30-13:00\nroy_busy = [(minutes(\"09:00\"), minutes(\"09:30\")),\n            (minutes(\"10:00\"), minutes(\"10:30\")),\n            (minutes(\"11:00\"), minutes(\"11:30\")),\n            (minutes(\"12:30\"), minutes(\"13:00\"))]\n\n# Kathryn busy: 9:30-10:00, 16:30-17:00\nkathryn_busy = [(minutes(\"09:30\"), minutes(\"10:00\")),\n                (minutes(\"16:30\"), minutes(\"17:00\"))]\n\n# Amy busy: 9:00-14:30, 15:00-16:00, 16:30-17:00\namy_busy = [(minutes(\"09:00\"), minutes(\"14:30\")),\n            (minutes(\"15:00\"), minutes(\"16:00\")),\n            (minutes(\"16:30\"), minutes(\"17:00\"))]\n\n# Compute individual free intervals within working hours\nroy_free = subtract_busy(working_interval, roy_busy)\nkathryn_free = subtract_busy(working_interval, kathryn_busy)\namy_free = subtract_busy(working_interval, amy_busy)\n\n# Amy's preference: do not meet after 15:30, so restrict meeting to end by 15:30.\n# This means we only consider free intervals that end by 15:30.\nlatest_end_preference = minutes(\"15:30\")\namy_preferred_free = []\nfor start, end in amy_free:\n    # Only include the part up to 15:30\n    if start < latest_end_preference:\n        amy_preferred_free.append((start, min(end, latest_end_preference)))\n\n# Now intersect the free intervals for all participants\ncommon_free = intersect_intervals(roy_free, kathryn_free)\ncommon_free = intersect_intervals(common_free, amy_preferred_free)\n\n# Find earliest slot with required duration\nslot = find_slot(common_free, meeting_duration)\n\nif slot:\n    start_time, end_time = slot\n    # Output in the format HH:MM:HH:MM enclosed in curly braces\n    output = f\"{{{time_str(start_time)}:{time_str(end_time)}}}\"\n    print(output)\nelse:\n    print(\"No available slot found.\")\n'''",
            "count": "calendar_scheduling_example_2"
        },
        {
            "final_program_time": "{9:30:10:30}",
            "expected_time": "{9:30:10:30}",
            "type_error": null,
            "full_response": "'''python\ndef to_minutes(time_str):\n    # converts HH:MM string to minutes since midnight\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef to_time_str(minutes):\n    # converts minutes since midnight to HH:MM string with leading zeros\n    return f\"{minutes//60:02d}:{minutes%60:02d}\"\n\ndef get_free_intervals(busy, work_start, work_end):\n    # busy is a list of (start, end) in minutes, assumed sorted by start time.\n    free = []\n    current = work_start\n    for s, e in busy:\n        if current < s:\n            free.append((current, s))\n        current = max(current, e)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    # Both intervals1 and intervals2 are lists of (start, end) intervals.\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # The intersection interval:\n        start_int = max(start1, start2)\n        end_int = min(end1, end2)\n        if start_int < end_int:\n            result.append((start_int, end_int))\n        # Move to the next interval in whichever list ends first.\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef find_common_free(free_lists):\n    # Intersect free intervals from all lists\n    common = free_lists[0]\n    for free in free_lists[1:]:\n        common = intersect_intervals(common, free)\n    return common\n\ndef find_meeting_slot(common_intervals, duration):\n    # Return the earliest interval that fits the duration (in minutes).\n    for start, end in common_intervals:\n        if end - start >= duration:\n            # Return a meeting slot from start to start+duration.\n            return (start, start + duration)\n    return None\n\n# Working hours: 09:00 to 17:00\nwork_start = to_minutes(\"09:00\")\nwork_end = to_minutes(\"17:00\")\nmeeting_duration = 60  # one hour meeting\n\n# Busy intervals for each participant in minutes (start, end)\n# Arthur is busy: 09:00-09:30, 10:30-12:00, 16:00-17:00\narthur_busy = [(to_minutes(\"09:00\"), to_minutes(\"09:30\")),\n               (to_minutes(\"10:30\"), to_minutes(\"12:00\")),\n               (to_minutes(\"16:00\"), to_minutes(\"17:00\"))]\n\n# Michael is busy: 13:00-13:30, 14:00-14:30\nmichael_busy = [(to_minutes(\"13:00\"), to_minutes(\"13:30\")),\n                (to_minutes(\"14:00\"), to_minutes(\"14:30\"))]\n\n# Samantha is busy: 10:30-11:00, 12:00-15:00, 15:30-17:00\nsamantha_busy = [(to_minutes(\"10:30\"), to_minutes(\"11:00\")),\n                 (to_minutes(\"12:00\"), to_minutes(\"15:00\")),\n                 (to_minutes(\"15:30\"), to_minutes(\"17:00\"))]\n\n# Compute free intervals for each participant\narthur_free = get_free_intervals(arthur_busy, work_start, work_end)\nmichael_free = get_free_intervals(michael_busy, work_start, work_end)\nsamantha_free = get_free_intervals(samantha_busy, work_start, work_end)\n\n# Find common free intervals among all participants\ncommon_free = find_common_free([arthur_free, michael_free, samantha_free])\n\n# Find the earliest meeting slot that fits the meeting duration\nmeeting_slot = find_meeting_slot(common_free, meeting_duration)\n\nif meeting_slot:\n    start_str = to_time_str(meeting_slot[0])\n    end_str = to_time_str(meeting_slot[1])\n    # Output in the format HH:MM:HH:MM\n    print(f\"{{{start_str}:{end_str}}}\")\nelse:\n    print(\"No available meeting slot\")\n'''",
            "count": "calendar_scheduling_example_3"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_hhmm(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Meeting requirements\nmeeting_duration = 30  # in minutes\nwork_start = 9 * 60    # 9:00 in minutes\nwork_end = 17 * 60     # 17:00 in minutes\n\n# Busy schedules in minutes (start, end)\nbusy_schedules = {\n    \"Donna\": [(14 * 60, 14 * 60 + 30), (15 * 60 + 30, 16 * 60)],       # 14:00-14:30, 15:30-16:00\n    \"John\": [(11 * 60, 11 * 60 + 30), (16 * 60 + 30, 17 * 60)],          # 11:00-11:30, 16:30-17:00\n    \"Billy\": [(9 * 60, 10 * 60), (10 * 60 + 30, 14 * 60), (14 * 60 + 30, 17 * 60)]  # 9:00-10:00, 10:30-14:00, 14:30-17:00\n}\n\ndef is_slot_free(start, duration, busy_intervals):\n    end = start + duration\n    for b_start, b_end in busy_intervals:\n        # Check if meeting [start, end) overlaps with busy interval [b_start, b_end)\n        if not (end <= b_start or start >= b_end):\n            return False\n    return True\n\navailable_time = None\n# Iterate over each minute from work_start to the latest start time possible.\nfor start in range(work_start, work_end - meeting_duration + 1):\n    if all(is_slot_free(start, meeting_duration, busy_schedules[person]) for person in busy_schedules):\n        available_time = (start, start + meeting_duration)\n        break\n\nif available_time:\n    start_str = minutes_to_hhmm(available_time[0])\n    end_str = minutes_to_hhmm(available_time[1])\n    # Output in the specified format: {HH:MM:HH:MM}\n    print(f\"{{{start_str}:{end_str}}}\")\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_4"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    \"\"\"Converts time string 'HH:MM' to minutes from midnight.\"\"\"\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    \"\"\"Converts minutes from midnight to time string 'HH:MM'.\"\"\"\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef get_free_intervals(busy, window_start, window_end):\n    \"\"\"\n    Given busy intervals as a list of (start, end) in minutes,\n    and overall window [window_start, window_end],\n    return a list of available (free) intervals.\n    Assumes busy intervals are sorted by start time.\n    \"\"\"\n    free = []\n    current = window_start\n    for bstart, bend in sorted(busy):\n        if bend <= current:\n            continue\n        if bstart > current:\n            free.append((current, min(bstart, window_end)))\n        current = max(current, bend)\n        if current >= window_end:\n            break\n    if current < window_end:\n        free.append((current, window_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"\n    Intersect two lists of intervals.\n    Each interval is a tuple (start, end). Returns list of intersections.\n    \"\"\"\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find overlap between intervals\n        start = max(start1, start2)\n        end = min(end1, end2)\n        if start < end:\n            result.append((start, end))\n        # Move to the next interval in the list with the earlier ending time\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef intersect_multiple(intervals_list):\n    \"\"\"\n    Intersect multiple lists of intervals.\n    \"\"\"\n    if not intervals_list:\n        return []\n    intersected = intervals_list[0]\n    for intervals in intervals_list[1:]:\n        intersected = intersect_intervals(intersected, intervals)\n        if not intersected:\n            break\n    return intersected\n\n# Define the meeting parameters\nmeeting_duration = 30  # minutes\n\n# Effective meeting window due to Charlotte's preference (no meeting after 13:30)\nwindow_start = time_to_minutes(\"09:00\")\nwindow_end = time_to_minutes(\"13:30\")\n\n# Define busy intervals for each participant (only intervals within the [09:00,13:30] window)\n\n# Kathryn busy intervals (original: 09:00-09:30, 10:30-11:00, 11:30-12:00, 13:30-14:30, 16:30-17:00)\n# Only include intervals that affect the window [09:00,13:30]\nkathryn_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\"))\n]\n\n# Charlotte busy intervals (original: 12:00-12:30, 16:00-16:30)\n# Only include intervals within window [09:00,13:30]\ncharlotte_busy = [\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\"))\n]\n\n# Lauren busy intervals (original: 09:00-10:00, 12:00-12:30, 13:30-14:30, 15:00-16:00, 16:30-17:00)\n# Only include intervals within window [09:00,13:30]\nlauren_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\"))\n]\n\n# Compute free intervals for each participant\nkathryn_free = get_free_intervals(kathryn_busy, window_start, window_end)\ncharlotte_free = get_free_intervals(charlotte_busy, window_start, window_end)\nlauren_free = get_free_intervals(lauren_busy, window_start, window_end)\n\n# Compute the intersection of free intervals across all participants\ncommon_free = intersect_multiple([kathryn_free, charlotte_free, lauren_free])\n\n# Find the earliest interval that can accommodate the meeting\nproposed_start, proposed_end = None, None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        proposed_start = start\n        proposed_end = start + meeting_duration\n        break\n\nif proposed_start is not None:\n    result = f\"{minutes_to_time(proposed_start)}:{minutes_to_time(proposed_end)}\"\n    print(result)\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_5"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    \"\"\"Convert HH:MM string to minutes since midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    \"\"\"Convert minutes since midnight to HH:MM string with zero padding.\"\"\"\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\ndef interval_conflict(meeting_start, meeting_end, busy_intervals):\n    \"\"\"Check if the meeting [meeting_start, meeting_end) conflicts with any busy interval.\n       A conflict exists if meeting_start < busy_end and meeting_end > busy_start.\n    \"\"\"\n    for busy_start, busy_end in busy_intervals:\n        if meeting_start < busy_end and meeting_end > busy_start:\n            return True\n    return False\n\ndef find_meeting_slot():\n    meeting_duration = 60  # 1 hour in minutes\n    work_start = time_to_minutes(\"09:00\")\n    work_end = time_to_minutes(\"17:00\")\n    \n    # Busy intervals for each participant in minutes\n    # Thomas: no meetings (wide open) => no busy intervals\n    thomas_busy = []\n    \n    # Dylan busy intervals: 10:30-11:00 and 13:30-14:00\n    dylan_busy = [\n        (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n        (time_to_minutes(\"13:30\"), time_to_minutes(\"14:00\"))\n    ]\n    \n    # Jerry busy intervals: 9:00-11:00, 11:30-14:30, 16:00-17:00\n    jerry_busy = [\n        (time_to_minutes(\"09:00\"), time_to_minutes(\"11:00\")),\n        (time_to_minutes(\"11:30\"), time_to_minutes(\"14:30\")),\n        (time_to_minutes(\"16:00\"), time_to_minutes(\"17:00\"))\n    ]\n    \n    # Iterate over possible meeting start times in minutes\n    for start in range(work_start, work_end - meeting_duration + 1):\n        end = start + meeting_duration\n        # Check for conflicts with Dylan and Jerry; Thomas is free.\n        if not interval_conflict(start, end, dylan_busy) and not interval_conflict(start, end, jerry_busy):\n            return f\"{{{minutes_to_time(start)}:{minutes_to_time(end)}}}\"\n    \n    return \"No valid meeting slot found.\"\n\n# Main execution\nif __name__ == \"__main__\":\n    print(find_meeting_slot())\n'''",
            "count": "calendar_scheduling_example_6"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    # Convert \"HH:MM\" to minutes from midnight.\n    h, m = map(int, time_str.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(minutes):\n    h = minutes // 60\n    m = minutes % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef subtract_busy(free_interval, busy_intervals):\n    # free_interval is a tuple (start, end)\n    free_slots = [free_interval]\n    for busy in busy_intervals:\n        new_slots = []\n        for slot in free_slots:\n            # No overlap\n            if busy[1] <= slot[0] or busy[0] >= slot[1]:\n                new_slots.append(slot)\n            else:\n                # If there's a free portion before busy starts:\n                if busy[0] > slot[0]:\n                    new_slots.append((slot[0], busy[0]))\n                # If there's a free portion after busy ends:\n                if busy[1] < slot[1]:\n                    new_slots.append((busy[1], slot[1]))\n        free_slots = new_slots\n    return free_slots\n\ndef intersect_intervals(intervals1, intervals2):\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        start = max(intervals1[i][0], intervals2[j][0])\n        end = min(intervals1[i][1], intervals2[j][1])\n        if start < end:\n            result.append((start, end))\n        # Advance the one with the earlier end time.\n        if intervals1[i][1] < intervals2[j][1]:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Meeting parameters\nmeeting_duration = 30  # minutes\n\n# Work hours: 9:00 to 17:00 in minutes.\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nwork_interval = (work_start, work_end)\n\n# Busy intervals for each participant (start, end) in minutes.\n# Heather's busy intervals: 9:00-9:30, 10:30-11:00, 13:00-14:00, 14:30-15:00, 16:00-16:30.\nheather_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"14:00\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))\n]\n\n# Nicholas has no meetings all day.\nnicholas_busy = []  # no busy intervals\n\n# Zachary's busy intervals: 9:00-10:30, 11:00-12:00, 12:30-13:00, 13:30-16:30.\nzachary_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"13:30\"), time_to_minutes(\"16:30\"))\n]\n\n# Additional constraint for Zachary: Prefer not to meet after 14:00.\nlatest_meeting_end = time_to_minutes(\"14:00\")  # meeting must end on or before 14:00\n\n# Compute free intervals for each participant\nheather_free = subtract_busy(work_interval, heather_busy)\nnicholas_free = subtract_busy(work_interval, nicholas_busy)\nzachary_free = subtract_busy(work_interval, zachary_busy)\n\n# Intersect free intervals of Heather and Nicholas\nfree_hn = intersect_intervals(heather_free, nicholas_free)\n# Intersect that with Zachary's free intervals\nall_free = intersect_intervals(free_hn, zachary_free)\n\n# Find earliest interval where meeting_duration fits and meeting ends by latest_meeting_end\nproposed_start = None\n\nfor interval in all_free:\n    start, end = interval\n    # The meeting must also finish on or before latest_meeting_end.\n    available_end = min(end, latest_meeting_end)\n    if available_end - start >= meeting_duration:\n        proposed_start = start\n        break\n\nif proposed_start is not None:\n    proposed_end = proposed_start + meeting_duration\n    # Output in HH:MM:HH:MM format.\n    output = f\"{minutes_to_time(proposed_start)}:{minutes_to_time(proposed_end)}\"\n    print(f\"{{{output}}}\")\nelse:\n    print(\"No valid meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_7"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\n# Helper function to convert minutes-since-midnight to HH:MM format\ndef minutes_to_str(minutes):\n    return f\"{minutes//60:02d}:{minutes%60:02d}\"\n\n# Check if two intervals [start1, end1) and [start2, end2) overlap\ndef overlaps(start1, end1, start2, end2):\n    return not (end1 <= start2 or start1 >= end2)\n\n# Meeting duration in minutes\nduration = 30\n\n# Work day starts at 09:00 (540 minutes) and ends at 17:00 (1020 minutes)\nwork_start = 9 * 60\nwork_end = 17 * 60\n\n# Define busy intervals (in minutes since midnight) for each participant\n\n# Adam's busy intervals: 10:00-10:30, 12:30-13:00, 13:30-14:30\nadam_busy = [(10*60, 10*60+30), (12*60+30, 13*60), (13*60+30, 14*60+30)]\n\n# Jerry's busy intervals: 9:00-9:30, 12:00-12:30, 15:00-16:00\njerry_busy = [(9*60, 9*60+30), (12*60, 12*60+30), (15*60, 16*60)]\n\n# Matthew's busy intervals: 9:30-11:00, 11:30-12:30, 13:00-14:00, 14:30-17:00\nmatthew_busy = [(9*60+30, 11*60), (11*60+30, 12*60+30), (13*60, 14*60), (14*60+30, 17*60)]\n\n# Combine all busy intervals into a list for each participant\nparticipants_busy = [adam_busy, jerry_busy, matthew_busy]\n\n# Function to check if meeting starting at 't' minutes is free for a participant's busy intervals\ndef is_free(t, busy_intervals):\n    meeting_start = t\n    meeting_end = t + duration\n    for interval in busy_intervals:\n        busy_start, busy_end = interval\n        if overlaps(meeting_start, meeting_end, busy_start, busy_end):\n            return False\n    return True\n\n# Find earliest available time from work_start to work_end-duration\nmeeting_time = None\nfor t in range(work_start, work_end - duration + 1):\n    if all(is_free(t, busy) for busy in participants_busy):\n        meeting_time = t\n        break\n\nif meeting_time is not None:\n    start_str = minutes_to_str(meeting_time)\n    end_str = minutes_to_str(meeting_time + duration)\n    # Output in the specified format {HH:MM:HH:MM}\n    print(f\"{{{start_str}:{end_str}}}\")\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_8"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_timestr(m):\n    hours = m // 60\n    minutes = m % 60\n    return f\"{hours:02d}:{minutes:02d}\"\n\n# Meeting parameters\nmeeting_duration = 30  # minutes\nday_start = 9 * 60     # 9:00 in minutes (540)\nday_end = 17 * 60      # 17:00 in minutes (1020)\n\n# Busy intervals for each participant (in minutes)\n# Diane is busy: 9:00-9:30, 12:00-12:30, 14:30-15:30\ndiane_busy = [(9*60, 9*60+30), (12*60, 12*60+30), (14*60+30, 15*60+30)]\n\n# Kelly is busy: 9:30-10:00, 10:30-11:00\nkelly_busy = [(9*60+30, 10*60), (10*60+30, 11*60)]\n\n# Deborah is busy: 9:00-9:30, 10:00-14:00, 14:30-17:00\ndeborah_busy = [(9*60, 9*60+30), (10*60, 14*60), (14*60+30, 17*60)]\n\ndef is_free(busy, start, end):\n    \"\"\"\n    Returns True if the interval [start, end) does not\n    overlap with any busy intervals.\n    \"\"\"\n    for b_start, b_end in busy:\n        # Check if meeting overlaps with busy interval\n        if start < b_end and end > b_start:\n            return False\n    return True\n\n# Iterate over possible starting times (minute by minute)\nproposed_time = None\nfor candidate in range(day_start, day_end - meeting_duration + 1):\n    meeting_end = candidate + meeting_duration\n    if (is_free(diane_busy, candidate, meeting_end) and\n        is_free(kelly_busy, candidate, meeting_end) and\n        is_free(deborah_busy, candidate, meeting_end)):\n        proposed_time = (candidate, meeting_end)\n        break\n\nif proposed_time:\n    start_str = minutes_to_timestr(proposed_time[0])\n    end_str   = minutes_to_timestr(proposed_time[1])\n    # Output format as {HH:MM:HH:MM}\n    print(f\"{{{start_str}:{end_str}}}\")\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_9"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    \"\"\"Convert time string 'HH:MM' to minutes since midnight.\"\"\"\n    hours, minutes = map(int, t.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(m):\n    \"\"\"Convert minutes since midnight to time string 'HH:MM'.\"\"\"\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef get_free_intervals(busy, work_start, work_end):\n    \"\"\"Given busy intervals (each a tuple of start and end in minutes) within work hours,\n       return a list of free intervals (tuples in minutes).\"\"\"\n    free = []\n    current = work_start\n    for start, end in sorted(busy):\n        if current < start:\n            free.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_intervals(intv1, intv2):\n    \"\"\"Intersect two lists of intervals. Each interval is a (start, end) tuple.\"\"\"\n    i, j = 0, 0\n    intersections = []\n    while i < len(intv1) and j < len(intv2):\n        start1, end1 = intv1[i]\n        start2, end2 = intv2[j]\n        start_inter = max(start1, start2)\n        end_inter = min(end1, end2)\n        if start_inter < end_inter:\n            intersections.append((start_inter, end_inter))\n        # Move to next interval in list that finishes first\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersections\n\n# Define work hours (in minutes)\nwork_start = time_to_minutes(\"09:00\")\nwork_end   = time_to_minutes(\"17:00\")\n\n# Meeting duration in minutes (30 minutes)\nmeeting_duration = 30\n\n# Busy intervals for each participant (start, end in minutes)\n# Diana's busy intervals: 11:30-12:00 and 13:00-13:30\ndiana_busy = [\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\"))\n]\n\n# Ethan is free the entire day (no busy intervals)\nethan_busy = []\n\n# Janet's busy intervals: 9:00-10:00, 12:30-13:00, 14:00-15:00, and 15:30-17:00.\njanet_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"15:30\"), work_end)  # 15:30 to 17:00\n]\n\n# Janet prefers not to meet after 12:00.\n# We restrict her available meeting time to before 12:00.\njanet_meeting_limit = time_to_minutes(\"12:00\")\n\n# Compute free intervals for each participant\ndiana_free = get_free_intervals(diana_busy, work_start, work_end)\nethan_free = get_free_intervals(ethan_busy, work_start, work_end)\njanet_free = get_free_intervals(janet_busy, work_start, work_end)\n# Apply Janet's meeting preference: restrict her free time to before 12:00.\njanet_free = [(start, min(end, janet_meeting_limit)) for start, end in janet_free if start < janet_meeting_limit]\n\n# Find common free intervals among Diana, Ethan, and Janet\ncommon_free = intersect_intervals(diana_free, ethan_free)\ncommon_free = intersect_intervals(common_free, janet_free)\n\n# Find the earliest available slot with sufficient duration\nproposed_slot = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        proposed_slot = (start, start + meeting_duration)\n        break\n\nif proposed_slot:\n    start_time = minutes_to_time(proposed_slot[0])\n    end_time = minutes_to_time(proposed_slot[1])\n    # Output in the format {HH:MM:HH:MM}\n    print(\"{\" + f\"{start_time}:{end_time}\" + \"}\")\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_10"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    \"\"\"Converts 'HH:MM' to minutes since midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    \"\"\"Converts minutes since midnight to 'HH:MM' format with leading zeros.\"\"\"\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\ndef get_free_intervals(busy_intervals, work_start, work_end):\n    \"\"\"\n    Given a list of busy intervals (tuples of (start, end) in minutes),\n    return a list of free intervals between work_start and work_end.\n    Assumes busy_intervals are sorted by start time.\n    \"\"\"\n    free = []\n    current = work_start\n    for start, end in sorted(busy_intervals):\n        if start > current:\n            free.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"\n    Given two lists of intervals, return their intersection as a list of intervals.\n    Each interval is a tuple (start, end) in minutes.\n    \"\"\"\n    i, j = 0, 0\n    intersection = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find overlapping part\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap < end_overlap:\n            intersection.append((start_overlap, end_overlap))\n        # Move to the next interval in the list that finishes first\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\ndef find_common_free_slot(free1, free2, free3, duration):\n    \"\"\"\n    Given three lists of free intervals and a meeting duration (in minutes),\n    find the earliest interval that can accommodate the meeting.\n    \"\"\"\n    # Intersect free intervals pairwise first for efficiency:\n    common = intersect_intervals(free1, free2)\n    common = intersect_intervals(common, free3)\n    \n    # Look for a free interval with enough duration.\n    for start, end in common:\n        if end - start >= duration:\n            return start, start + duration\n    return None\n\ndef main():\n    # Work day parameters\n    work_start = time_to_minutes(\"09:00\")\n    work_end = time_to_minutes(\"17:00\")\n    meeting_duration = 30  # in minutes\n\n    # Busy intervals for each participant (in minutes from midnight).\n    # Alexander: 9:30-10:00, 10:30-11:00, 12:30-13:00, 14:30-15:00, 16:00-17:00\n    busy_alexander = [\n        (time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n        (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n        (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\")),\n        (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\")),\n        (time_to_minutes(\"16:00\"), time_to_minutes(\"17:00\"))\n    ]\n    \n    # Elizabeth: 9:00-9:30, 11:30-12:30, 13:00-14:30\n    busy_elizabeth = [\n        (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n        (time_to_minutes(\"11:30\"), time_to_minutes(\"12:30\")),\n        (time_to_minutes(\"13:00\"), time_to_minutes(\"14:30\"))\n    ]\n    \n    # Walter: 9:00-14:30, 15:30-17:00\n    busy_walter = [\n        (time_to_minutes(\"09:00\"), time_to_minutes(\"14:30\")),\n        (time_to_minutes(\"15:30\"), time_to_minutes(\"17:00\"))\n    ]\n    \n    # Determine free intervals for each participant\n    free_alexander = get_free_intervals(busy_alexander, work_start, work_end)\n    free_elizabeth = get_free_intervals(busy_elizabeth, work_start, work_end)\n    free_walter = get_free_intervals(busy_walter, work_start, work_end)\n    \n    # Find a common free slot\n    slot = find_common_free_slot(free_alexander, free_elizabeth, free_walter, meeting_duration)\n    \n    if slot:\n        start, end = slot\n        # Format and output the time as HH:MM:HH:MM\n        output = f\"{minutes_to_time(start)}:{minutes_to_time(end)}\"\n        print(output)\n    else:\n        print(\"No common available time slot found.\")\n\nif __name__ == \"__main__\":\n    main()\n'''",
            "count": "calendar_scheduling_example_11"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    \"\"\"Converts time string 'HH:MM' to minutes since 00:00.\"\"\"\n    hours, minutes = map(int, t.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(m):\n    \"\"\"Converts minutes since 00:00 to time string 'HH:MM'.\"\"\"\n    hours = m // 60\n    minutes = m % 60\n    return f\"{hours:02d}:{minutes:02d}\"\n\ndef get_free_intervals(busy_intervals, work_start, work_end):\n    \"\"\"Given sorted busy_intervals as a list of (start, end) in minutes,\n    returns a list of free intervals (start, end) within the work day.\"\"\"\n    free = []\n    current = work_start\n    for b_start, b_end in busy_intervals:\n        if current < b_start:\n            free.append((current, b_start))\n        current = max(current, b_end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Intersect two lists of intervals; intervals are (start, end) in minutes.\n    Returns a list of intervals which are the intersection.\"\"\"\n    i, j = 0, 0\n    intersections = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find overlap\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap < end_overlap:\n            intersections.append((start_overlap, end_overlap))\n        # Move the pointer that ends first\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersections\n\ndef find_meeting_slot(free_list, duration):\n    \"\"\"Given a list of free intervals (in minutes) and required duration,\n    returns the first interval that fits the duration.\"\"\"\n    for start, end in free_list:\n        if end - start >= duration:\n            return start, start + duration\n    return None\n\n# Define work hours (Monday 9:00 to 17:00) in minutes\nwork_start = time_to_minutes(\"09:00\")  # 540\nwork_end = time_to_minutes(\"17:00\")    # 1020\n\nmeeting_duration = 60  # one hour in minutes\n\n# Busy intervals for each participant in minutes\n# David is free the whole day, so no busy intervals.\ndavid_busy = []\n\n# Debra's busy intervals\ndebra_busy = [\n    (time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"11:30\")),\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"14:30\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))\n]\n\n# Kevin's busy intervals\nkevin_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"17:00\"))\n]\n\n# Compute free intervals for each participant\ndavid_free = get_free_intervals(david_busy, work_start, work_end)\ndebra_free = get_free_intervals(debra_busy, work_start, work_end)\nkevin_free = get_free_intervals(kevin_busy, work_start, work_end)\n\n# Compute intersection of free intervals for all participants\nintersect_debra_kevin = intersect_intervals(debra_free, kevin_free)\ncommon_free = intersect_intervals(david_free, intersect_debra_kevin)\n\n# Find the earliest slot that fits the meeting duration\nmeeting_slot = find_meeting_slot(common_free, meeting_duration)\nif meeting_slot:\n    start_time, end_time = meeting_slot\n    # Format and output in the required format {HH:MM:HH:MM}\n    start_str = minutes_to_time(start_time)\n    end_str = minutes_to_time(end_time)\n    print(f\"{{{start_str}:{end_str}}}\")\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_12"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "'''python\ndef to_minutes(time_str):\n    # Converts HH:MM to minutes from midnight.\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef to_timestr(minutes):\n    # Converts minutes from midnight to HH:MM format with leading zeros.\n    return f\"{minutes//60:02d}:{minutes%60:02d}\"\n\ndef compute_free_intervals(busy_intervals, work_start, work_end):\n    \"\"\"\n    Given a list of busy intervals [(start, end), ...] in minutes,\n    and the working hours [work_start, work_end], return a list of free intervals.\n    \"\"\"\n    free = []\n    # start with block from work_start to the first busy start (if any)\n    prev_end = work_start\n    for start, end in sorted(busy_intervals):\n        if start > prev_end:\n            free.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free.append((prev_end, work_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"\n    Given two lists of intervals, compute the intersection of these intervals.\n    Each interval is a tuple (start, end) in minutes.\n    \"\"\"\n    result = []\n    i, j = 0, 0\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # find overlap\n        overlap_start = max(start1, start2)\n        overlap_end = min(end1, end2)\n        if overlap_start < overlap_end:\n            result.append((overlap_start, overlap_end))\n        # move on from the interval that finishes first\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef find_slot(participant_intervals, duration, work_start, work_end):\n    \"\"\"\n    Given a list of free intervals for each participant, find the earliest common interval\n    with at least 'duration' minutes within work hours.\n    participant_intervals is a list of lists of intervals.\n    \"\"\"\n    # Start with the free intervals of the first participant\n    common = participant_intervals[0]\n    # Intersect with each subsequent participant's free intervals\n    for intervals in participant_intervals[1:]:\n        common = intersect_intervals(common, intervals)\n        if not common:\n            break\n    # Now find the earliest slot with at least 'duration' minutes.\n    for start, end in common:\n        if end - start >= duration:\n            return start, start + duration\n    return None\n\ndef main():\n    # Define meeting parameters\n    meeting_duration = 30  # in minutes\n    work_start = to_minutes(\"09:00\")\n    work_end = to_minutes(\"17:00\")\n\n    # Define busy schedules for participants in minutes (using minutes from midnight)\n    # Gerald's busy times on Monday\n    gerald_busy = [\n        (to_minutes(\"09:00\"), to_minutes(\"09:30\")),\n        (to_minutes(\"13:00\"), to_minutes(\"14:00\")),\n        (to_minutes(\"15:00\"), to_minutes(\"15:30\")),\n        (to_minutes(\"16:00\"), to_minutes(\"17:00\"))\n    ]\n    # Roy is free the entire day (no busy times)\n    roy_busy = []\n    # Barbara's busy times on Monday\n    barbara_busy = [\n        (to_minutes(\"09:30\"), to_minutes(\"10:00\")),\n        (to_minutes(\"11:30\"), to_minutes(\"14:00\")),\n        (to_minutes(\"14:30\"), to_minutes(\"15:00\")),\n        (to_minutes(\"15:30\"), to_minutes(\"17:00\"))\n    ]\n\n    # Gerald prefers no meetings before 13:00; apply that by adjusting work_start for him.\n    gerald_effective_start = max(work_start, to_minutes(\"13:00\"))\n\n    # Compute free intervals for each participant.\n    # For Gerald, restrict free intervals to [13:00, work_end].\n    gerald_free_full = compute_free_intervals(gerald_busy, work_start, work_end)\n    # Intersect with Gerald's preference interval.\n    gerald_preference = [(gerald_effective_start, work_end)]\n    gerald_free = intersect_intervals(gerald_free_full, gerald_preference)\n    \n    roy_free = compute_free_intervals(roy_busy, work_start, work_end)\n    barbara_free = compute_free_intervals(barbara_busy, work_start, work_end)\n\n    # Collect the free intervals list for each participant\n    participant_free = [gerald_free, roy_free, barbara_free]\n\n    slot = find_slot(participant_free, meeting_duration, work_start, work_end)\n    if slot:\n        start_minutes, end_minutes = slot\n        start_time = to_timestr(start_minutes)\n        end_time = to_timestr(end_minutes)\n        # Output in the requested format: {HH:MM:HH:MM}\n        print(f\"{{{start_time}:{end_time}}}\")\n    else:\n        print(\"No available slot found.\")\n    \nif __name__ == \"__main__\":\n    main()\n'''",
            "count": "calendar_scheduling_example_13"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_time(mins):\n    \"\"\"Convert minutes since midnight to HH:MM string.\"\"\"\n    hours = mins // 60\n    minutes = mins % 60\n    return f\"{hours:02d}:{minutes:02d}\"\n\ndef intersect_intervals(interval1, interval2):\n    \"\"\"Return the intersection of two intervals, each defined as [start, end),\n    or None if no overlap.\"\"\"\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start < end:\n        return (start, end)\n    return None\n\ndef intersect_interval_lists(list1, list2):\n    \"\"\"Intersect two lists of intervals.\"\"\"\n    i, j = 0, 0\n    result = []\n    while i < len(list1) and j < len(list2):\n        intersect = intersect_intervals(list1[i], list2[j])\n        if intersect:\n            result.append(intersect)\n        # Move to the next interval in the list that finishes first.\n        if list1[i][1] < list2[j][1]:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef compute_free_intervals(busy, work_start, work_end, constraint_start=None):\n    \"\"\"Given busy intervals (list of (start, end) in minutes),\n    compute free intervals within working hours.\n    Optionally, only consider free time starting from constraint_start.\"\"\"\n    free = []\n    # Adjust the start if there is a constraint.\n    current = work_start\n    if constraint_start is not None:\n        current = max(work_start, constraint_start)\n    # Iterate over busy intervals assumed sorted.\n    for b in busy:\n        if b[0] > current:\n            free.append((current, b[0]))\n        current = max(current, b[1])\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\n# Define working hours: 9:00 to 17:00 in minutes (from midnight)\nwork_start = 9 * 60   # 540\nwork_end = 17 * 60    # 1020\nmeeting_duration = 30\n\n# Define busy intervals for each participant in minutes.\n# For Brandon, his meetings:\nbrandon_busy = [(13*60, 14*60), (15*60+30, 16*60), (16*60+30, 17*60)]\n# Brandon would like to avoid meetings before 14:30.\nbrandon_constraint = 14*60 + 30  # 14:30 in minutes\n\n# For Jerry, no meetings.\njerry_busy = []\n\n# For Bradley, his meetings:\nbradley_busy = [(9*60, 11*60+30), (12*60, 15*60), (16*60, 16*60+30)]\n\n# Compute free intervals for each participant.\nbrandon_free = compute_free_intervals(brandon_busy, work_start, work_end, constraint_start=brandon_constraint)\njerry_free = compute_free_intervals(jerry_busy, work_start, work_end)\nbradley_free = compute_free_intervals(bradley_busy, work_start, work_end)\n\n# First, intersect Brandon's and Jerry's free times.\ncommon_free = intersect_interval_lists(brandon_free, jerry_free)\n# Then, intersect the result with Bradley's free times.\ncommon_free = intersect_interval_lists(common_free, bradley_free)\n\n# Find the earliest interval with at least meeting_duration minutes.\nproposed_start = None\nproposed_end = None\nfor interval in common_free:\n    start, end = interval\n    if end - start >= meeting_duration:\n        proposed_start = start\n        proposed_end = start + meeting_duration\n        break\n\n# Format and output the result in HH:MM:HH:MM format inside curly braces.\nif proposed_start is not None:\n    start_str = minutes_to_time(proposed_start)\n    end_str = minutes_to_time(proposed_end)\n    print(\"{\" + f\"{start_str}:{end_str}\" + \"}\")\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_14"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    \"\"\"Convert HH:MM string to minutes since midnight.\"\"\"\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    \"\"\"Convert minutes since midnight to HH:MM string.\"\"\"\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\n# Define working hours (in minutes)\nwork_start = time_to_minutes(\"09:00\")\nwork_end   = time_to_minutes(\"17:00\")\n\nmeeting_duration = 30\n\n# Busy intervals for each participant (start, end) in minutes\n# Joyce's busy times\njoyce_busy = [\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"11:30\")),\n    (time_to_minutes(\"13:30\"), time_to_minutes(\"14:00\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"16:30\"))\n]\n\n# Christine has no meetings, but cannot meet before 12:00.\n# We'll enforce that the meeting start >= 12:00.\nchristine_constraint = time_to_minutes(\"12:00\")\n\n# Alexander's busy times\nalex_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"11:00\")),\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n    (time_to_minutes(\"13:30\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\")),\n    (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))\n]\n\ndef is_free(busy_times, start, end):\n    \"\"\"Check if a meeting from start to end doesn't overlap any busy interval.\"\"\"\n    for b_start, b_end in busy_times:\n        # If meeting starts before a busy block ends and ends after it starts, there is an overlap.\n        if start < b_end and end > b_start:\n            return False\n    return True\n\n# Iterate over potential meeting start times (minute by minute)\n# Meeting must start no earlier than:\ncandidate_start = max(work_start, christine_constraint)\n\nproposed_start = None\nwhile candidate_start + meeting_duration <= work_end:\n    proposed_end = candidate_start + meeting_duration\n    \n    if (is_free(joyce_busy, candidate_start, proposed_end) and\n        is_free(alex_busy, candidate_start, proposed_end)):\n        proposed_start = candidate_start\n        break\n    candidate_start += 1\n\nif proposed_start is not None:\n    proposed_end = proposed_start + meeting_duration\n    # Output format HH:MM:HH:MM enclosed in curly braces\n    print(f\"{{{minutes_to_time(proposed_start)}:{minutes_to_time(proposed_end)}}}\")\nelse:\n    print(\"No valid meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_15"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\n# Define work day start and end in minutes from midnight\nWORK_DAY_START = 9 * 60   # 9:00 in minutes\nWORK_DAY_END = 17 * 60    # 17:00 in minutes\nMEETING_DURATION = 30     # in minutes\n\n# Define a function to convert minutes to HH:MM string\ndef minutes_to_timestr(minutes):\n    hrs = minutes // 60\n    mins = minutes % 60\n    return f\"{hrs:02d}:{mins:02d}\"\n\n# Busy intervals for each participant (start, end) in minutes since midnight\n# Scott's busy times: 9:30-10:30, 13:30-14:00, 14:30-15:00, 15:30-16:00, 16:30-17:00\nscott_busy = [(9 * 60 + 30, 10 * 60 + 30),\n              (13 * 60 + 30, 14 * 60),\n              (14 * 60 + 30, 15 * 60),\n              (15 * 60 + 30, 16 * 60),\n              (16 * 60 + 30, 17 * 60)]\n\n# Gabriel has no meetings\ngabriel_busy = []\n\n# Christine's busy times: 9:00-10:00, 10:30-12:30, 13:00-17:00\nchristine_busy = [(9 * 60, 10 * 60),\n                  (10 * 60 + 30, 12 * 60 + 30),\n                  (13 * 60, 17 * 60)]\n\n# Combine all busy intervals into a list for easy iteration per candidate check\nall_busy = [scott_busy, gabriel_busy, christine_busy]\n\n# Function to check if a candidate meeting time (start, start+duration) conflicts with a single person's busy intervals\ndef is_conflict(candidate_start, busy_intervals):\n    candidate_end = candidate_start + MEETING_DURATION\n    for start, end in busy_intervals:\n        # if meeting interval overlaps with busy interval\n        if not (candidate_end <= start or candidate_start >= end):\n            return True\n    return False\n\n# Loop over possible start times from WORK_DAY_START to WORK_DAY_END - MEETING_DURATION\nproposed_start = None\nfor candidate in range(WORK_DAY_START, WORK_DAY_END - MEETING_DURATION + 1):\n    conflict_found = False\n    for busy_list in all_busy:\n        if is_conflict(candidate, busy_list):\n            conflict_found = True\n            break\n    if not conflict_found:\n        proposed_start = candidate\n        break\n\nif proposed_start is not None:\n    proposed_end = proposed_start + MEETING_DURATION\n    # Format output as {HH:MM:HH:MM}\n    result = \"{\" + f\"{minutes_to_timestr(proposed_start)}:{minutes_to_timestr(proposed_end)}\" + \"}\"\n    print(result)\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_16"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import timedelta, datetime\n\ndef time_to_minutes(time_str):\n    \"\"\"Convert HH:MM string to minutes since midnight.\"\"\"\n    t = datetime.strptime(time_str, \"%H:%M\")\n    return t.hour * 60 + t.minute\n\ndef minutes_to_time(minutes):\n    \"\"\"Convert minutes since midnight to HH:MM string.\"\"\"\n    return f\"{minutes//60:02d}:{minutes%60:02d}\"\n\ndef free_intervals(busy, work_start, work_end):\n    \"\"\"Given busy intervals (as tuples of start, end in minutes) sorted by start,\n       return free intervals within [work_start, work_end].\"\"\"\n    free = []\n    current = work_start\n    for b_start, b_end in busy:\n        if current < b_start:\n            free.append((current, b_start))\n        current = max(current, b_end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Intersect two lists of intervals.\"\"\"\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        start = max(intervals1[i][0], intervals2[j][0])\n        end = min(intervals1[i][1], intervals2[j][1])\n        if start < end:\n            result.append((start, end))\n        if intervals1[i][1] < intervals2[j][1]:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Define working day start and end in minutes (9:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Meeting duration in minutes\nmeeting_duration = 30\n\n# Participant busy intervals provided as HH:MM strings for Monday.\n# Margaret: busy 09:00-10:00, 10:30-11:00, 11:30-12:00, 13:00-13:30, 15:00-15:30\nmargaret_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n    (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\"))\n]\n\n# Donna: busy 14:30-15:00, 16:00-16:30\ndonna_busy = [\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))\n]\n\n# Helen: busy 09:00-09:30, 10:00-11:30, 13:00-14:00, 14:30-15:00, 15:30-17:00\nhelen_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"11:30\")),\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"14:00\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"15:30\"), work_end)  # 15:30 to 17:00\n]\n\n# Helen prefers the meeting to finish by 13:30. Hence, the meeting must end no later than 13:30.\nlatest_end_for_helen = time_to_minutes(\"13:30\")\n\n# Calculate free intervals for each participant\nmargaret_free = free_intervals(margaret_busy, work_start, work_end)\ndonna_free = free_intervals(donna_busy, work_start, work_end)\nhelen_free = free_intervals(helen_busy, work_start, work_end)\n\n# Intersect free intervals for all participants\nintersect_md = intersect_intervals(margaret_free, donna_free)\ncommon_free = intersect_intervals(intersect_md, helen_free)\n\n# Filter common free intervals to those that can accommodate the meeting duration\n# and also satisfy Helen's constraint (meeting end <= 13:30).\npossible_slots = []\nfor start, end in common_free:\n    slot_start = start\n    while slot_start + meeting_duration <= end:\n        if slot_start + meeting_duration <= latest_end_for_helen:\n            possible_slots.append((slot_start, slot_start + meeting_duration))\n        slot_start += 1  # check minute by minute\n\n# Choose the earliest possible slot\nif possible_slots:\n    slot = possible_slots[0]\n    start_str = minutes_to_time(slot[0])\n    end_str = minutes_to_time(slot[1])\n    # Output in the requested format: {HH:MM:HH:MM}\n    print(f\"{{{start_str}:{end_str}}}\")\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_17"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "'''python\ndef to_minutes(time_str):\n    \"\"\"Convert HH:MM string to minutes since midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef to_time_str(minutes):\n    \"\"\"Convert minutes since midnight to HH:MM string.\"\"\"\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\ndef is_free(meeting_start, meeting_end, busy_intervals):\n    \"\"\"Return True if the meeting interval does not conflict with any busy interval.\"\"\"\n    for interval in busy_intervals:\n        busy_start, busy_end = interval\n        # Check for overlap. If meeting_start is before busy_end and meeting_end after busy_start, conflict.\n        if meeting_start < busy_end and meeting_end > busy_start:\n            return False\n    return True\n\n# Define work parameters in minutes.\nwork_start = to_minutes(\"09:00\")  # 540\nwork_end   = to_minutes(\"17:00\")  # 1020\nmeeting_duration = 30\n\n# Billy's meeting preference: avoid meetings after 15:30.\nlatest_meeting_end = to_minutes(\"15:30\")  # 930\n\n# Define busy intervals for each participant in minutes.\n# Brian is free all day.\nbrian_busy = []\n\n# Billy is busy:\n# 10:00 - 10:30, 11:30 - 12:00, 14:00 - 14:30, 16:30 - 17:00.\nbilly_busy = [\n    (to_minutes(\"10:00\"), to_minutes(\"10:30\")),\n    (to_minutes(\"11:30\"), to_minutes(\"12:00\")),\n    (to_minutes(\"14:00\"), to_minutes(\"14:30\")),\n    (to_minutes(\"16:30\"), to_minutes(\"17:00\"))\n]\n\n# Patricia is busy:\n# 9:00 - 12:30, 13:30 - 14:00, 14:30 - 16:00, 16:30 - 17:00.\npatricia_busy = [\n    (to_minutes(\"09:00\"), to_minutes(\"12:30\")),\n    (to_minutes(\"13:30\"), to_minutes(\"14:00\")),\n    (to_minutes(\"14:30\"), to_minutes(\"16:00\")),\n    (to_minutes(\"16:30\"), to_minutes(\"17:00\"))\n]\n\n# Combine all participants' busy intervals in a list of tuples and the corresponding participant names.\nparticipants_busy = [brian_busy, billy_busy, patricia_busy]\n\n# Search for the earliest meeting time.\n# Meeting must start no earlier than work_start and must finish by latest_meeting_end.\nearliest_meeting = None\n\nfor start in range(work_start, latest_meeting_end - meeting_duration + 1):\n    end = start + meeting_duration\n    # Ensure the meeting ends before or at Billy's preferred latest end.\n    if end > latest_meeting_end:\n        break\n    # Check if all participants are free during [start, end).\n    if all(is_free(start, end, busy) for busy in participants_busy):\n        earliest_meeting = (start, end)\n        break\n\nif earliest_meeting:\n    start_time_str = to_time_str(earliest_meeting[0])\n    end_time_str = to_time_str(earliest_meeting[1])\n    # Print result in the required format: {HH:MM:HH:MM}\n    print(f\"{{{start_time_str}:{end_time_str}}}\")\nelse:\n    print(\"No available slot found.\")\n'''",
            "count": "calendar_scheduling_example_18"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "'''python\ndef to_minutes(time_str):\n    \"\"\"Converts HH:MM string to minutes since midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef to_hhmm(minutes):\n    \"\"\"Converts minutes since midnight to HH:MM string (zero-padded).\"\"\"\n    hours = minutes // 60\n    minutes = minutes % 60\n    return f\"{hours:02d}:{minutes:02d}\"\n\ndef interval_conflicts(start, end, busy_intervals):\n    \"\"\"\n    Given a candidate meeting interval [start, end) in minutes,\n    check if it conflicts with any of the busy intervals.\n    Each busy interval is a tuple (busy_start, busy_end) in minutes.\n    \"\"\"\n    for b_start, b_end in busy_intervals:\n        # If there is any overlap.\n        if start < b_end and end > b_start:\n            return True\n    return False\n\ndef find_meeting_time(work_start, work_end, duration, participants_busy):\n    \"\"\"\n    Given work hours (in minutes), meeting duration and a list of lists,\n    where each sub-list contains busy intervals for one participant,\n    return the earliest start time (in minutes) where a meeting\n    of the given duration can be scheduled without conflict.\n    \"\"\"\n    # Check every minute from work_start to work_end - duration (inclusive)\n    for candidate in range(work_start, work_end - duration + 1):\n        candidate_end = candidate + duration\n        conflict = False\n        for busy_intervals in participants_busy:\n            if interval_conflicts(candidate, candidate_end, busy_intervals):\n                conflict = True\n                break\n        if not conflict:\n            return candidate, candidate_end\n    return None\n\n# Define work hours: 9:00 to 17:00 in minutes (9*60=540, 17*60=1020)\nwork_start = 9 * 60     # 540\nwork_end = 17 * 60      # 1020\nmeeting_duration = 60   # 1 hour meeting\n\n# Define busy intervals for each participant in minutes\n# Stephen: busy during 10:00-10:30, 13:00-13:30, 14:30-15:00, 16:00-16:30\nstephen_busy = [(to_minutes(\"10:00\"), to_minutes(\"10:30\")),\n                (to_minutes(\"13:00\"), to_minutes(\"13:30\")),\n                (to_minutes(\"14:30\"), to_minutes(\"15:00\")),\n                (to_minutes(\"16:00\"), to_minutes(\"16:30\"))]\n\n# Edward: busy during 9:00-9:30, 10:00-10:30, 13:30-14:30, 15:00-16:00\nedward_busy = [(to_minutes(\"09:00\"), to_minutes(\"09:30\")),\n               (to_minutes(\"10:00\"), to_minutes(\"10:30\")),\n               (to_minutes(\"13:30\"), to_minutes(\"14:30\")),\n               (to_minutes(\"15:00\"), to_minutes(\"16:00\"))]\n\n# Angela: busy during 9:00-11:30, 12:30-13:00, 13:30-15:30, 16:00-17:00\nangela_busy = [(to_minutes(\"09:00\"), to_minutes(\"11:30\")),\n               (to_minutes(\"12:30\"), to_minutes(\"13:00\")),\n               (to_minutes(\"13:30\"), to_minutes(\"15:30\")),\n               (to_minutes(\"16:00\"), to_minutes(\"17:00\"))]\n\nparticipants_busy = [stephen_busy, edward_busy, angela_busy]\n\nresult = find_meeting_time(work_start, work_end, meeting_duration, participants_busy)\nif result:\n    start, end = result\n    output = f\"{to_hhmm(start)}:{to_hhmm(end)}\"\n    print(output)\nelse:\n    print(\"No available meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_19"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    # t in \"HH:MM\" format\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef get_free_intervals(busy_intervals, work_start, work_end):\n    free = []\n    current = work_start\n    for start, end in busy_intervals:\n        if current < start:\n            free.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_intervals(ints1, ints2):\n    result = []\n    i, j = 0, 0\n    while i < len(ints1) and j < len(ints2):\n        start = max(ints1[i][0], ints2[j][0])\n        end = min(ints1[i][1], ints2[j][1])\n        if start < end:\n            result.append((start, end))\n        if ints1[i][1] < ints2[j][1]:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Work hours in minutes for Monday (09:00 - 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nmeeting_duration = 30  # in minutes\n\n# Busy intervals for each participant (start, end in minutes)\n# Ralph: 13:30-14:00, 14:30-15:00\nralph_busy = [(time_to_minutes(\"13:30\"), time_to_minutes(\"14:00\")),\n              (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\"))]\n# Peter: 9:00-9:30, 11:00-13:00, 16:00-16:30\npeter_busy = [(time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n              (time_to_minutes(\"11:00\"), time_to_minutes(\"13:00\")),\n              (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))]\n# Daniel: 9:00-10:00, 10:30-15:30, 16:00-17:00\ndaniel_busy = [(time_to_minutes(\"09:00\"), time_to_minutes(\"10:00\")),\n               (time_to_minutes(\"10:30\"), time_to_minutes(\"15:30\")),\n               (time_to_minutes(\"16:00\"), time_to_minutes(\"17:00\"))]\n\n# Daniel prefers no meetings after 13:30.\ndaniel_latest = time_to_minutes(\"13:30\")\n\n# Calculate free intervals for each participant over the work day.\nralph_free = get_free_intervals(ralph_busy, work_start, work_end)\npeter_free = get_free_intervals(peter_busy, work_start, work_end)\ndaniel_free = get_free_intervals(daniel_busy, work_start, work_end)\n\n# Restrict Daniel's free intervals to those that end no later than his cutoff.\ndaniel_free = [(start, min(end, daniel_latest)) for start, end in daniel_free if start < daniel_latest]\n\n# Find the intersection of free intervals among all participants.\nfree_intersections = intersect_intervals(ralph_free, peter_free)\nfree_intersections = intersect_intervals(free_intersections, daniel_free)\n\n# Find the earliest interval that can accommodate the meeting duration.\nproposed_start = None\nproposed_end = None\nfor start, end in free_intersections:\n    if end - start >= meeting_duration:\n        proposed_start = start\n        proposed_end = start + meeting_duration\n        break\n\nif proposed_start is not None:\n    print(f\"{minutes_to_time(proposed_start)}:{minutes_to_time(proposed_end)}\")\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_20"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    \"\"\"Converts time in format 'HH:MM' to minutes since midnight.\"\"\"\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    \"\"\"Converts minutes since midnight to time in format 'HH:MM'.\"\"\"\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef get_free_intervals(work_start, work_end, busy_intervals):\n    \"\"\"\n    Given a working period [work_start, work_end] and a list of busy intervals,\n    returns a list of free intervals as tuples (start, end).\n    busy_intervals should be sorted by start time.\n    \"\"\"\n    free = []\n    current_start = work_start\n    for bstart, bend in sorted(busy_intervals):\n        if bstart > current_start:\n            free.append((current_start, bstart))\n        current_start = max(current_start, bend)\n    if current_start < work_end:\n        free.append((current_start, work_end))\n    return free\n\ndef intersect_intervals(list1, list2):\n    \"\"\"\n    Given two lists of intervals, returns the intersection intervals.\n    Each list contains tuples (start, end).\n    \"\"\"\n    intersections = []\n    i, j = 0, 0\n    while i < len(list1) and j < len(list2):\n        start1, end1 = list1[i]\n        start2, end2 = list2[j]\n        # Compute overlapping interval:\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap < end_overlap:\n            intersections.append((start_overlap, end_overlap))\n        # Move to next interval\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersections\n\n# Define working hours for Monday\nwork_start = time_to_minutes(\"09:00\")  # 540\nwork_end = time_to_minutes(\"17:00\")    # 1020\n\n# Meeting duration in minutes (1 hour)\nmeeting_duration = 60\n\n# Busy intervals for each participant (in minutes since midnight)\n# Bobby's calendar: wide open (no busy intervals)\nbobby_busy = []\n\n# Scott's busy intervals: 11:30-12:00 and 15:30-16:00\nscott_busy = [\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\"))\n]\n\n# Kimberly's busy intervals:\n# 11:00-12:00, 12:30-13:00, 13:30-14:00, 14:30-15:00, 15:30-17:00\nkimberly_busy = [\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"13:30\"), time_to_minutes(\"14:00\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"17:00\"))\n]\n\n# Calculate free intervals for each participant\nbobby_free = get_free_intervals(work_start, work_end, bobby_busy)\nscott_free = get_free_intervals(work_start, work_end, scott_busy)\nkimberly_free = get_free_intervals(work_start, work_end, kimberly_busy)\n\n# First, compute intersection between Bobby and Scott (Bobby is fully free,\n# so effectively it's just Scott's free times)\ncommon_free = scott_free\n\n# Now, intersect with Kimberly's free intervals\ncommon_free = intersect_intervals(common_free, kimberly_free)\n\n# Find earliest interval that can accommodate the meeting duration\nproposed_meeting = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        proposed_meeting = (start, start + meeting_duration)\n        break\n\nif proposed_meeting:\n    start_time, end_time = proposed_meeting\n    # Format the time as HH:MM:HH:MM enclosed in curly braces\n    output = \"{\" + minutes_to_time(start_time) + \":\" + minutes_to_time(end_time) + \"}\"\n    print(output)\nelse:\n    print(\"No available meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_21"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "'''python\ndef convert_to_minutes(time_str):\n    # time_str is in the format \"HH:MM\"\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef convert_to_hhmm(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Work day start and end in minutes (9:00 to 17:00)\nwork_start = convert_to_minutes(\"09:00\")  # 540\nwork_end = convert_to_minutes(\"17:00\")    # 1020\n\nmeeting_duration = 60  # one hour in minutes\n\n# Busy intervals for each participant represented as (start, end) in minutes\ntheresa_busy = [(convert_to_minutes(\"09:00\"), convert_to_minutes(\"09:30\")),\n                (convert_to_minutes(\"12:30\"), convert_to_minutes(\"13:30\")),\n                (convert_to_minutes(\"14:00\"), convert_to_minutes(\"15:00\")),\n                (convert_to_minutes(\"16:30\"), convert_to_minutes(\"17:00\"))]\n\ncharles_busy = [(convert_to_minutes(\"10:00\"), convert_to_minutes(\"10:30\")),\n                (convert_to_minutes(\"11:30\"), convert_to_minutes(\"12:30\")),\n                (convert_to_minutes(\"14:00\"), convert_to_minutes(\"15:30\"))]\n\nbetty_busy = [(convert_to_minutes(\"09:00\"), convert_to_minutes(\"10:30\")),\n              (convert_to_minutes(\"12:00\"), convert_to_minutes(\"12:30\")),\n              (convert_to_minutes(\"13:00\"), convert_to_minutes(\"14:00\")),\n              (convert_to_minutes(\"15:00\"), convert_to_minutes(\"16:00\"))]\n\n# Combine busy schedules into a list for easy processing\nall_busy = [theresa_busy, charles_busy, betty_busy]\n\ndef is_time_slot_free(start, duration, busy_intervals):\n    end = start + duration\n    for bstart, bend in busy_intervals:\n        # Check if the meeting [start, end) overlaps with busy interval [bstart, bend)\n        if not (end <= bstart or start >= bend):\n            return False\n    return True\n\n# Iterate over each possible start time (in minutes) from work_start to work_end - meeting_duration\nproposed_start = None\nfor start in range(work_start, work_end - meeting_duration + 1):\n    # Check for each participant if the slot is free\n    slot_free = True\n    for busy in all_busy:\n        if not is_time_slot_free(start, meeting_duration, busy):\n            slot_free = False\n            break\n    if slot_free:\n        proposed_start = start\n        break\n\nif proposed_start is not None:\n    proposed_end = proposed_start + meeting_duration\n    output = f\"{{{convert_to_hhmm(proposed_start)}:{convert_to_hhmm(proposed_end)}}}\"\n    print(output)\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_22"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    # t is a string in HH:MM format\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef get_free_intervals(busy_intervals, work_start, work_end):\n    # busy_intervals is a list of tuples (start, end) in minutes and sorted by start\n    free = []\n    current = work_start\n    for start, end in busy_intervals:\n        if start > current:\n            free.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_intervals(int1, int2):\n    # Given two lists of intervals, find their intersection intervals.\n    i, j = 0, 0\n    intersection = []\n    while i < len(int1) and j < len(int2):\n        a_start, a_end = int1[i]\n        b_start, b_end = int2[j]\n        # intersection interval:\n        start = max(a_start, b_start)\n        end = min(a_end, b_end)\n        if start < end:\n            intersection.append((start, end))\n        # move forward the interval that ends first\n        if a_end < b_end:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\n# Work day boundaries in minutes from midnight (9:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nmeeting_duration = 60  # in minutes\n\n# Busy intervals for each participant in minutes.\n# Billy busy: 11:30-12:00, 13:00-15:00, 16:00-16:30\nbilly_busy = [\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))\n]\n\n# Maria busy: 09:00-09:30, 10:00-10:30, 13:00-13:30, 14:00-14:30\nmaria_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"14:30\"))\n]\n\n# William busy: 09:30-10:00, 12:00-12:30, 13:30-15:00, 15:30-17:00\nwilliam_busy = [\n    (time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n    (time_to_minutes(\"13:30\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"17:00\"))\n]\n\n# Compute free intervals for each participant\nbilly_free = get_free_intervals(billy_busy, work_start, work_end)\nmaria_free = get_free_intervals(maria_busy, work_start, work_end)\nwilliam_free = get_free_intervals(william_busy, work_start, work_end)\n\n# Find common free intervals across all three participants\ncommon_free = intersect_intervals(billy_free, maria_free)\ncommon_free = intersect_intervals(common_free, william_free)\n\n# Find the earliest common interval that can accommodate the meeting duration.\nproposed_start = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        proposed_start = start\n        break\n\nif proposed_start is not None:\n    proposed_end = proposed_start + meeting_duration\n    # Print in required format: HH:MM:HH:MM  (start:end)\n    print(f\"{minutes_to_time(proposed_start)}:{minutes_to_time(proposed_end)}\")\nelse:\n    print(\"No common time slot available\")\n'''",
            "count": "calendar_scheduling_example_23"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\n# Define work day start and end times (using a dummy date)\nwork_start = datetime(2023, 1, 1, 9, 0)\nwork_end = datetime(2023, 1, 1, 17, 0)\nmeeting_duration = timedelta(minutes=30)\n\n# Participant schedules\n# Benjamin is free but doesn't want to meet after 9:30, so any meeting must finish by 9:30.\n# Hannah is free the entire day.\n# Brenda is busy during 09:30-10:00, 11:30-12:30, and 14:00-16:30.\nschedules = {\n    \"Benjamin\": [],  # no meetings; constraint will be checked separately.\n    \"Hannah\": [],\n    \"Brenda\": [\n        (datetime(2023,1,1,9,30), datetime(2023,1,1,10,0)),\n        (datetime(2023,1,1,11,30), datetime(2023,1,1,12,30)),\n        (datetime(2023,1,1,14,0), datetime(2023,1,1,16,30))\n    ]\n}\n\n# Benjamin's personal constraint: Meeting must finish by 09:30.\nbenjamin_deadline = datetime(2023, 1, 1, 9, 30)\n\n# Function to check if a time slot is free for a given schedule\ndef is_slot_free(candidate_start, candidate_end, meetings):\n    for start, end in meetings:\n        # Check for any overlap between the candidate slot and existing meeting\n        if not (candidate_end <= start or candidate_start >= end):\n            return False\n    return True\n\n# Find the earliest available slot that meets all constraints\ncandidate = work_start\nfound_slot = None\n\nwhile candidate + meeting_duration <= work_end:\n    candidate_end = candidate + meeting_duration\n\n    # Enforce Benjamin's constraint: meeting must end no later than 09:30.\n    if candidate_end > benjamin_deadline:\n        break\n\n    # Check availability for each participant\n    if (is_slot_free(candidate, candidate_end, schedules[\"Benjamin\"]) and\n        is_slot_free(candidate, candidate_end, schedules[\"Hannah\"]) and\n        is_slot_free(candidate, candidate_end, schedules[\"Brenda\"])):\n        found_slot = (candidate, candidate_end)\n        break\n\n    # Increment candidate by a small interval (e.g., 15 minutes) to check the next possibility\n    candidate += timedelta(minutes=15)\n\nif found_slot:\n    start_time_str = found_slot[0].strftime(\"%H:%M\")\n    end_time_str = found_slot[1].strftime(\"%H:%M\")\n    print(\"{\" + f\"{start_time_str}:{end_time_str}\" + \"}\")\nelse:\n    print(\"No available slot\")\n'''",
            "count": "calendar_scheduling_example_24"
        },
        {
            "final_program_time": "{13:30:14:30}",
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    # t in \"HH:MM\" format\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef invert_busy(busy, start, end):\n    \"\"\"Given a list of busy intervals (start, end) in minutes (sorted, non-overlapping),\n    return list of free intervals within [start, end].\"\"\"\n    free = []\n    current = start\n    for bstart, bend in busy:\n        if bstart > current:\n            free.append((current, bstart))\n        current = max(current, bend)\n    if current < end:\n        free.append((current, end))\n    return free\n\ndef intersect_intervals(a, b):\n    \"\"\"Intersect two lists of intervals.\n       Each interval is a tuple (start, end) of minutes.\n    \"\"\"\n    i, j = 0, 0\n    result = []\n    while i < len(a) and j < len(b):\n        start = max(a[i][0], b[j][0])\n        end = min(a[i][1], b[j][1])\n        if start < end:\n            result.append((start, end))\n        if a[i][1] < b[j][1]:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Work hours in minutes:\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n# Pamela has an extra constraint: she does not want to meet after 14:30.\npamela_latest_end = time_to_minutes(\"14:30\")\n\n# Meeting duration: 60 minutes.\nmeeting_duration = 60\n\n# Busy intervals for each person (times in HH:MM, converted to minutes)\n# Anthony: busy 9:30-10:00, 12:00-13:00, 16:00-16:30\nanthony_busy = [(time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n                 (time_to_minutes(\"12:00\"), time_to_minutes(\"13:00\")),\n                 (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))]\n\n# Pamela: busy 9:30-10:00, 16:30-17:00\npamela_busy = [(time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n               (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))]\n\n# Zachary: busy 9:00-11:30, 12:00-12:30, 13:00-13:30, 14:30-15:00, 16:00-17:00\nzachary_busy = [(time_to_minutes(\"09:00\"), time_to_minutes(\"11:30\")),\n                (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n                (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n                (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\")),\n                (time_to_minutes(\"16:00\"), time_to_minutes(\"17:00\"))]\n\n# Define effective work hours for each:\n# Anthony and Zachary use the full work day; Pamela's effective end is 14:30.\nanthony_free = invert_busy(anthony_busy, work_start, work_end)\npamela_free = invert_busy(pamela_busy, work_start, pamela_latest_end)  # restrict to before 14:30\nzachary_free = invert_busy(zachary_busy, work_start, work_end)\n\n# Intersect free intervals of all participants:\nintersect_ab = intersect_intervals(anthony_free, pamela_free)\nall_free = intersect_intervals(intersect_ab, zachary_free)\n\n# Find earliest interval that can accommodate the meeting duration.\nproposed_start = None\nfor start, end in all_free:\n    if end - start >= meeting_duration:\n        proposed_start = start\n        break\n\nif proposed_start is not None:\n    proposed_end = proposed_start + meeting_duration\n    # Format output as {HH:MM:HH:MM}\n    output = f\"{{{minutes_to_time(proposed_start)}:{minutes_to_time(proposed_end)}}}\"\n    print(output)\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_25"
        },
        {
            "final_program_time": "{15:30:16:30}",
            "expected_time": "{15:30:16:30}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_time(m):\n    hrs = m // 60\n    mins = m % 60\n    return f\"{hrs:02d}:{mins:02d}\"\n\ndef find_meeting_slot(work_start, work_end, busy_intervals, duration):\n    # busy_intervals should be sorted by start time\n    free_intervals = []\n    \n    # First free interval before first busy meeting (if any)\n    if work_start < busy_intervals[0][0]:\n        free_intervals.append((work_start, busy_intervals[0][0]))\n    \n    # Free intervals between busy intervals\n    for i in range(len(busy_intervals) - 1):\n        end_current = busy_intervals[i][1]\n        start_next = busy_intervals[i+1][0]\n        if end_current < start_next:\n            free_intervals.append((end_current, start_next))\n    \n    # Free interval after last busy meeting\n    if busy_intervals[-1][1] < work_end:\n        free_intervals.append((busy_intervals[-1][1], work_end))\n    \n    # Find the earliest free interval with sufficient duration\n    for start, end in free_intervals:\n        if end - start >= duration:\n            return start, start + duration\n    return None\n\n# Work day start and end in minutes (9:00 - 17:00)\nwork_start = 9 * 60      # 540 minutes\nwork_end = 17 * 60       # 1020 minutes\n\n# Meeting duration of 60 minutes\nmeeting_duration = 60\n\n# Given constraints:\n# Katherine and Nicole are free the whole day.\n# Kevin is busy on Monday during:\n#  9:00 to 10:00, 10:30 to 11:30, 12:00 to 15:30, and 16:30 to 17:00.\n# Represent intervals as (start, end) in minutes.\nbusy_intervals = [\n    (9 * 60, 10 * 60),           # 09:00 - 10:00\n    (10 * 60 + 30, 11 * 60 + 30), # 10:30 - 11:30\n    (12 * 60, 15 * 60 + 30),      # 12:00 - 15:30\n    (16 * 60 + 30, 17 * 60)       # 16:30 - 17:00\n]\n\n# Ensure busy intervals are sorted\nbusy_intervals.sort(key=lambda x: x[0])\n\nslot = find_meeting_slot(work_start, work_end, busy_intervals, meeting_duration)\nif slot:\n    start_time, end_time = slot\n    # Format output as HH:MM:HH:MM\n    formatted_time = f\"{{{minutes_to_time(start_time)}:{minutes_to_time(end_time)}}}\"\n    print(formatted_time)\nelse:\n    print(\"No available slot found\")\n'''",
            "count": "calendar_scheduling_example_26"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "'''python\ndef to_minutes(time_str):\n    # time_str format \"HH:MM\"\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef to_time_str(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Define work hours in minutes\nwork_start = to_minutes(\"09:00\")\nwork_end = to_minutes(\"17:00\")\nmeeting_duration = 30\n\n# Busy schedules in minutes for each participant.\n# Jesse busy: 10:00-10:30, 15:30-16:00\njesse_busy = [(to_minutes(\"10:00\"), to_minutes(\"10:30\")),\n              (to_minutes(\"15:30\"), to_minutes(\"16:00\"))]\n\n# Kathryn is free all day.\nkathryn_busy = []\n\n# Megan busy: 10:30-11:00, 11:30-12:30, 13:30-14:30, 15:00-16:30\nmegan_busy = [(to_minutes(\"10:30\"), to_minutes(\"11:00\")),\n              (to_minutes(\"11:30\"), to_minutes(\"12:30\")),\n              (to_minutes(\"13:30\"), to_minutes(\"14:30\")),\n              (to_minutes(\"15:00\"), to_minutes(\"16:30\"))]\n\n# Combine all busy schedules in a dictionary for ease of iteration\nschedules = {\n    \"Jesse\": jesse_busy,\n    \"Kathryn\": kathryn_busy,\n    \"Megan\": megan_busy,\n}\n\ndef is_slot_free(start, end, busy_slots):\n    for busy_start, busy_end in busy_slots:\n        # Check if the candidate slot [start, end) overlaps with a busy slot.\n        if start < busy_end and busy_start < end:\n            return False\n    return True\n\ndef find_earliest_meeting():\n    candidate = work_start\n    while candidate + meeting_duration <= work_end:\n        candidate_end = candidate + meeting_duration\n        available = True\n        for person, busy_slots in schedules.items():\n            if not is_slot_free(candidate, candidate_end, busy_slots):\n                available = False\n                break\n        if available:\n            return candidate, candidate_end\n        candidate += 1  # increment by 1 minute\n    return None\n\nresult = find_earliest_meeting()\nif result:\n    start, end = result\n    # Output in the format HH:MM:HH:MM\n    output = f\"{to_time_str(start)}:{to_time_str(end)}\"\n    print(output)\nelse:\n    print(\"No available slot found\")\n'''",
            "count": "calendar_scheduling_example_27"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\n# Define work day boundaries (in minutes after midnight)\nwork_start = 9 * 60   # 9:00 AM in minutes\nwork_end   = 17 * 60  # 17:00 in minutes\nmeeting_duration = 30  # 30 minutes\n\n# Busy intervals for each participant (start, end) in minutes after midnight.\n# Brittany's busy times: 13:00-13:30 and 16:00-16:30\nbrittany_busy = [(13 * 60, 13 * 60 + 30), (16 * 60, 16 * 60 + 30)]\n\n# Emily is free the entire day (no busy intervals)\nemily_busy = []\n\n# Doris's busy times: 9:00-11:00, 11:30-14:30, 15:00-17:00\ndoris_busy = [(9 * 60, 11 * 60), (11 * 60 + 30, 14 * 60 + 30), (15 * 60, 17 * 60)]\n\n# Combine busy schedules into a list for each participant\nschedules = [brittany_busy, emily_busy, doris_busy]\n\ndef is_free(candidate_start, candidate_end, busy_times):\n    \"\"\"Check if candidate meeting time does not conflict with a person's busy times.\n    Two intervals [a,b) and [c,d) conflict if a < d and c < b.\"\"\"\n    for (busy_start, busy_end) in busy_times:\n        if candidate_start < busy_end and busy_start < candidate_end:\n            return False\n    return True\n\ndef find_earliest_meeting_time():\n    # Iterate from work_start to latest possible start that fits in work_end.\n    for candidate_start in range(work_start, work_end - meeting_duration + 1):\n        candidate_end = candidate_start + meeting_duration\n        # Check candidate for all participants:\n        if all(is_free(candidate_start, candidate_end, schedule) for schedule in schedules):\n            return candidate_start, candidate_end\n    return None\n\nresult = find_earliest_meeting_time()\nif result:\n    start, end = result\n    # Convert minutes to HH:MM format\n    start_hour, start_min = divmod(start, 60)\n    end_hour, end_min = divmod(end, 60)\n    # Format the time as HH:MM:HH:MM (e.g., 11:00:11:30)\n    proposed_time = f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n    print(proposed_time)\nelse:\n    print(\"No available time slot found\")\n'''",
            "count": "calendar_scheduling_example_28"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    \"\"\"Converts HH:MM string to minutes since midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    \"\"\"Converts minutes since midnight to HH:MM string.\"\"\"\n    return f\"{minutes // 60:02d}:{minutes % 60:02d}\"\n\ndef get_free_intervals(busy_intervals, work_start, work_end):\n    \"\"\"Given a sorted list of busy intervals [(start, end), ...] and work period,\n    returns a list of free intervals as (start, end).\"\"\"\n    free = []\n    current = work_start\n    for start, end in busy_intervals:\n        if start > current:\n            free.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_intervals(intervals_a, intervals_b):\n    \"\"\"Intersect two lists of intervals.\"\"\"\n    i, j = 0, 0\n    result = []\n    while i < len(intervals_a) and j < len(intervals_b):\n        a_start, a_end = intervals_a[i]\n        b_start, b_end = intervals_b[j]\n        # Find the intersection, if any.\n        start = max(a_start, b_start)\n        end = min(a_end, b_end)\n        if start < end:\n            result.append((start, end))\n        if a_end < b_end:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef intersect_all(intervals_list):\n    \"\"\"Compute the intersection of all lists of intervals.\"\"\"\n    if not intervals_list:\n        return []\n    current_intersection = intervals_list[0]\n    for intervals in intervals_list[1:]:\n        current_intersection = intersect_intervals(current_intersection, intervals)\n    return current_intersection\n\n# Workday start and end times in minutes (9:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Meeting duration in minutes (1 hour)\nmeeting_duration = 60\n\n# Busy intervals for each participant (converted to minutes)\n# Madison: busy 09:30-10:00 and 11:30-12:00\nbusy_madison = [(time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n                (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\"))]\n\n# Diana: busy 11:00-11:30 and 13:00-13:30\nbusy_diana = [(time_to_minutes(\"11:00\"), time_to_minutes(\"11:30\")),\n              (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\"))]\n\n# Shirley: busy 09:00-12:00, 13:30-15:00, 15:30-17:00\nbusy_shirley = [(time_to_minutes(\"09:00\"), time_to_minutes(\"12:00\")),\n                (time_to_minutes(\"13:30\"), time_to_minutes(\"15:00\")),\n                (time_to_minutes(\"15:30\"), time_to_minutes(\"17:00\"))]\n\n# Get free intervals for each participant\nfree_madison = get_free_intervals(busy_madison, work_start, work_end)\nfree_diana   = get_free_intervals(busy_diana, work_start, work_end)\nfree_shirley = get_free_intervals(busy_shirley, work_start, work_end)\n\n# Get common free intervals among all participants\ncommon_free = intersect_all([free_madison, free_diana, free_shirley])\n\n# Find earliest common free interval that can accommodate the meeting duration\nproposed_start = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        proposed_start = start\n        break\n\nif proposed_start is not None:\n    proposed_end = proposed_start + meeting_duration\n    start_str = minutes_to_time(proposed_start)\n    end_str = minutes_to_time(proposed_end)\n    # Output in the format {HH:MM:HH:MM}\n    print(\"{\" + f\"{start_str}:{end_str}\" + \"}\")\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_29"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "'''python\ndef minutes(time_str):\n    \"\"\"Convert a time string 'HH:MM' to minutes from midnight.\"\"\"\n    hours, mins = map(int, time_str.split(\":\"))\n    return hours * 60 + mins\n\ndef time_str(minutes_val):\n    \"\"\"Convert minutes from midnight to time string 'HH:MM'.\"\"\"\n    return f\"{minutes_val//60:02d}:{minutes_val%60:02d}\"\n\ndef subtract_interval(free, busy):\n    \"\"\"Subtract a busy interval from a free interval.\n       free: a tuple (start, end)\n       busy: a tuple (start, end)\n       Returns list of free intervals after subtracting busy.\n    \"\"\"\n    free_start, free_end = free\n    busy_start, busy_end = busy\n    result = []\n    # no overlap\n    if busy_end <= free_start or busy_start >= free_end:\n        result.append((free_start, free_end))\n    else:\n        # part before busy interval\n        if busy_start > free_start:\n            result.append((free_start, busy_start))\n        # part after busy interval\n        if busy_end < free_end:\n            result.append((busy_end, free_end))\n    return result\n\ndef compute_free_intervals(working, busies):\n    \"\"\"Compute free intervals given working hours and list of busy intervals.\n       Both working and busy intervals are tuples in minutes.\n       busies should be sorted.\n    \"\"\"\n    free = [working]\n    for b in busies:\n        new_free = []\n        for interval in free:\n            new_free.extend(subtract_interval(interval, b))\n        free = new_free\n    return free\n\ndef intersect_intervals(int1, int2):\n    \"\"\"Intersect two lists of intervals.\n       Each interval is a tuple (start, end). Returns the intersection.\n    \"\"\"\n    result = []\n    i, j = 0, 0\n    while i < len(int1) and j < len(int2):\n        start = max(int1[i][0], int2[j][0])\n        end = min(int1[i][1], int2[j][1])\n        if start < end:\n            result.append((start, end))\n        if int1[i][1] < int2[j][1]:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef find_slot(intersected, duration):\n    \"\"\"Find earliest slot of at least 'duration' minutes in a list of intervals.\n       Returns the start and end time of the meeting.\n    \"\"\"\n    for start, end in intersected:\n        if end - start >= duration:\n            return start, start + duration\n    return None\n\n# Meeting duration in minutes\nmeeting_duration = 30\n\n# Working hours (in minutes from midnight)\nwork_start = minutes(\"09:00\")\nwork_end = minutes(\"17:00\")\n\n# For Melissa, the working hours are shortened due to her preference not to meet after 14:00.\nmelissa_work_end = minutes(\"14:00\")\n\n# Busy intervals (given as tuples of start, end in minutes from midnight)\n# Jeffrey's busy intervals\njeffrey_busy = [\n    (minutes(\"09:30\"), minutes(\"10:00\")),\n    (minutes(\"10:30\"), minutes(\"11:00\"))\n]\n\n# Virginia's busy intervals\nvirginia_busy = [\n    (minutes(\"09:00\"), minutes(\"09:30\")),\n    (minutes(\"10:00\"), minutes(\"10:30\")),\n    (minutes(\"14:30\"), minutes(\"15:00\")),\n    (minutes(\"16:00\"), minutes(\"16:30\"))\n]\n\n# Melissa's busy intervals; note her working window is 09:00 to 14:00.\nmelissa_busy = [\n    (minutes(\"09:00\"), minutes(\"11:30\")),\n    (minutes(\"12:00\"), minutes(\"12:30\")),\n    (minutes(\"13:00\"), minutes(\"15:00\")),\n    (minutes(\"16:00\"), minutes(\"17:00\"))  # irrelevant due to working window\n]\n\n# Compute free intervals for each participant\njeffrey_free = compute_free_intervals((work_start, work_end), jeffrey_busy)\nvirginia_free = compute_free_intervals((work_start, work_end), virginia_busy)\nmelissa_free = compute_free_intervals((work_start, melissa_work_end), melissa_busy)\n\n# Intersect free intervals of all participants\ncommon_free = intersect_intervals(jeffrey_free, virginia_free)\ncommon_free = intersect_intervals(common_free, melissa_free)\n\n# Find the earliest slot that fits the meeting duration\nslot = find_slot(common_free, meeting_duration)\nif slot:\n    start_time, end_time = slot\n    # Format output as HH:MM:HH:MM\n    output = f\"{time_str(start_time)}:{time_str(end_time)}\"\n    print(output)\nelse:\n    print(\"No common slot available\")\n'''",
            "count": "calendar_scheduling_example_30"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "'''python\ndef to_minutes(time_str):\n    # Convert \"HH:MM\" to minutes since midnight\n    hrs, mins = map(int, time_str.split(\":\"))\n    return hrs * 60 + mins\n\ndef to_timestr(minutes):\n    # Convert minutes since midnight to \"HH:MM\"\n    hrs = minutes // 60\n    mins = minutes % 60\n    return f\"{hrs:02d}:{mins:02d}\"\n\ndef invert_busy(busy, work_start, work_end):\n    # Given a sorted list of busy (start, end) intervals (in minutes),\n    # return a list of free intervals within [work_start, work_end].\n    free = []\n    curr_start = work_start\n    for start, end in busy:\n        if start > curr_start:\n            free.append((curr_start, start))\n        curr_start = max(curr_start, end)\n    if curr_start < work_end:\n        free.append((curr_start, work_end))\n    return free\n\ndef intersect_intervals(list1, list2):\n    # Compute intersection of two lists of intervals\n    intersection = []\n    i, j = 0, 0\n    while i < len(list1) and j < len(list2):\n        start1, end1 = list1[i]\n        start2, end2 = list2[j]\n        # Find intersection between the two intervals\n        start = max(start1, start2)\n        end = min(end1, end2)\n        if start < end:\n            intersection.append((start, end))\n        # Move the one that ends first\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\n# Define working hours in minutes (9:00 to 17:00)\nwork_start = to_minutes(\"09:00\")  # 540 minutes\nwork_end = to_minutes(\"17:00\")    # 1020 minutes\nmeeting_duration = 30  # minutes\n\n# Busy intervals for each participant (in minutes)\n# Richard: 13:30-14:00, 15:00-15:30\nrichard_busy = [(to_minutes(\"13:30\"), to_minutes(\"14:00\")),\n                (to_minutes(\"15:00\"), to_minutes(\"15:30\"))]\n\n# Martha: 09:00-09:30, 13:00-13:30\nmartha_busy = [(to_minutes(\"09:00\"), to_minutes(\"09:30\")),\n               (to_minutes(\"13:00\"), to_minutes(\"13:30\"))]\n# Martha does not want to meet before 14:00\nmartha_constraint = to_minutes(\"14:00\")  # meeting must start at or after 14:00\n\n# Kimberly: 09:00-11:00, 11:30-12:00, 12:30-13:00, 14:00-16:00\nkimberly_busy = [(to_minutes(\"09:00\"), to_minutes(\"11:00\")),\n                 (to_minutes(\"11:30\"), to_minutes(\"12:00\")),\n                 (to_minutes(\"12:30\"), to_minutes(\"13:00\")),\n                 (to_minutes(\"14:00\"), to_minutes(\"16:00\"))]\n\n# Compute free intervals by inverting busy intervals\nrichard_free = invert_busy(richard_busy, work_start, work_end)\nmartha_free = invert_busy(martha_busy, work_start, work_end)\nkimberly_free = invert_busy(kimberly_busy, work_start, work_end)\n\n# Apply Martha's constraint: remove any free interval that starts before 14:00.\nmartha_free = [(max(start, martha_constraint), end) for start, end in martha_free if end > martha_constraint]\n\n# Now calculate the overall intersection of free intervals among all three participants.\n# First intersect Richard and Martha\nintersect_rm = intersect_intervals(richard_free, martha_free)\n# Now intersect the above with Kimberly's free intervals.\ncommon_free = intersect_intervals(intersect_rm, kimberly_free)\n\n# Find the earliest common free interval that can accommodate the meeting duration.\nmeeting_start = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        meeting_start = start\n        break\n\nif meeting_start is None:\n    print(\"No common available time slot found.\")\nelse:\n    meeting_end = meeting_start + meeting_duration\n    # Format output as {HH:MM:HH:MM}\n    output = f\"{{{to_timestr(meeting_start)}:{to_timestr(meeting_end)}}}\"\n    print(output)\n'''",
            "count": "calendar_scheduling_example_31"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    \"\"\"Convert HH:MM string to minutes since midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    \"\"\"Convert minutes since midnight to HH:MM string with zero padding.\"\"\"\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Meeting parameters\nmeeting_duration = 30  # in minutes\n\n# Working day boundaries (in minutes since midnight)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Frank does not want to meet after 09:30, so the meeting must end by 09:30.\nlatest_end_for_frank = time_to_minutes(\"09:30\")\n# Therefore, the latest possible meeting start is:\nlatest_start = latest_end_for_frank - meeting_duration\n\n# Busy schedules for participants (each as list of (start, end) in minutes)\n# Emily's busy times:\nemily_busy = [\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"12:30\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))\n]\n\n# Melissa's busy times:\nmelissa_busy = [\n    (time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\"))\n]\n\n# Frank's busy times:\nfrank_busy = [\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"11:30\")),\n    (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"13:30\"), time_to_minutes(\"14:30\")),\n    (time_to_minutes(\"15:00\"), time_to_minutes(\"16:00\")),\n    (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))\n]\n\n# Combine all busy times for easier checking\nschedules = [emily_busy, melissa_busy, frank_busy]\n\ndef is_slot_free(slot_start, slot_end, busy_intervals):\n    \"\"\"Check if the time slot [slot_start, slot_end) is free from any busy interval.\"\"\"\n    for busy_start, busy_end in busy_intervals:\n        # If there is any overlap, then slot is not free.\n        if not (slot_end <= busy_start or slot_start >= busy_end):\n            return False\n    return True\n\n# Find the earliest slot within working hours, considering Frank's constraint.\n# The meeting must be scheduled between work_start and latest_start (inclusive).\nproposed_start = None\nfor candidate_start in range(work_start, latest_start + 1):\n    candidate_end = candidate_start + meeting_duration\n    # Ensure candidate_end does not exceed the strict limit from Frank's preference.\n    if candidate_end > latest_end_for_frank:\n        continue\n    # Check each participant's schedule\n    if all(is_slot_free(candidate_start, candidate_end, busy) for busy in schedules):\n        proposed_start = candidate_start\n        break\n\nif proposed_start is not None:\n    proposed_end = proposed_start + meeting_duration\n    start_str = minutes_to_time(proposed_start)\n    end_str = minutes_to_time(proposed_end)\n    # Output in the format {HH:MM:HH:MM}\n    print(f\"{{{start_str}:{end_str}}}\")\nelse:\n    print(\"No available slot found.\")\n'''",
            "count": "calendar_scheduling_example_32"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "'''python\ndef to_minutes(time_str):\n    # Converts HH:MM string to minutes past midnight.\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef to_HHMM(minutes):\n    # Converts minutes past midnight to HH:MM string (zero-padded).\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\ndef interval_overlaps(s1, e1, s2, e2):\n    # Returns True if the intervals [s1, e1) and [s2, e2) overlap.\n    return max(s1, s2) < min(e1, e2)\n\ndef is_available(start, end, busy_intervals):\n    # Check if a meeting from start to end (in minutes) does not overlap any busy interval.\n    for b_start, b_end in busy_intervals:\n        if interval_overlaps(start, end, b_start, b_end):\n            return False\n    return True\n\n# Define working hours in minutes (9:00 and 17:00)\nwork_start = to_minutes(\"09:00\")\nwork_end   = to_minutes(\"17:00\")\n\n# Meeting duration in minutes\nduration = 30\n\n# For Bobby we require the meeting to finish by 15:00.\nbobby_latest_end = to_minutes(\"15:00\")\n\n# Define busy intervals for each participant as (start, end) in minutes.\n# Lisa's busy intervals: 09:00-10:00, 10:30-11:30, 12:30-13:00, 16:00-16:30\nlisa_busy = [\n    (to_minutes(\"09:00\"), to_minutes(\"10:00\")),\n    (to_minutes(\"10:30\"), to_minutes(\"11:30\")),\n    (to_minutes(\"12:30\"), to_minutes(\"13:00\")),\n    (to_minutes(\"16:00\"), to_minutes(\"16:30\"))\n]\n\n# Bobby's busy intervals: 09:00-09:30, 10:00-10:30, 11:30-12:00, 15:00-15:30\nbobby_busy = [\n    (to_minutes(\"09:00\"), to_minutes(\"09:30\")),\n    (to_minutes(\"10:00\"), to_minutes(\"10:30\")),\n    (to_minutes(\"11:30\"), to_minutes(\"12:00\")),\n    (to_minutes(\"15:00\"), to_minutes(\"15:30\"))\n]\n\n# Randy's busy intervals: 09:30-10:00, 10:30-11:00, 11:30-12:30,\n# 13:00-13:30, 14:30-15:30, 16:00-16:30\nrandy_busy = [\n    (to_minutes(\"09:30\"), to_minutes(\"10:00\")),\n    (to_minutes(\"10:30\"), to_minutes(\"11:00\")),\n    (to_minutes(\"11:30\"), to_minutes(\"12:30\")),\n    (to_minutes(\"13:00\"), to_minutes(\"13:30\")),\n    (to_minutes(\"14:30\"), to_minutes(\"15:30\")),\n    (to_minutes(\"16:00\"), to_minutes(\"16:30\"))\n]\n\n# List of participants' busy intervals\nschedules = [lisa_busy, bobby_busy, randy_busy]\n\n# Find the earliest slot within working hours that meets all constraints,\n# and that ends by Bobby's desired latest end time (15:00)\nproposed_start = None\n# Meeting must start no earlier than work_start and end by both work_end and bobby_latest_end.\n# Since Bobby wants to avoid meetings after 15:00, we restrict meeting's end time to <= 15:00.\nlatest_start = bobby_latest_end - duration\n\nfor start_time in range(work_start, latest_start + 1):\n    end_time = start_time + duration\n    # Check if the meeting fits within working hours for everyone:\n    if end_time > work_end:\n        continue\n    # Verify availability for all participants\n    if all(is_available(start_time, end_time, busy) for busy in schedules):\n        proposed_start = start_time\n        break\n\nif proposed_start is not None:\n    proposed_end = proposed_start + duration\n    # Format output as {HH:MM:HH:MM}\n    output = f\"{{{to_HHMM(proposed_start)}:{to_HHMM(proposed_end)}}}\"\n    print(output)\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_33"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    # Convert time in HH:MM string to minutes since midnight\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    # Convert minutes since midnight to HH:MM string\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef get_free_intervals(busy, work_start, work_end):\n    # busy is list of tuples (start, end) in minutes, assumed sorted.\n    free = []\n    current = work_start\n    for start, end in busy:\n        if current < start:\n            free.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        a_start, a_end = intervals1[i]\n        b_start, b_end = intervals2[j]\n        # Find intersection\n        start = max(a_start, b_start)\n        end = min(a_end, b_end)\n        if start < end:  # there is an intersection\n            result.append((start, end))\n        # Move to the next interval which finishes earlier\n        if a_end < b_end:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef find_slot(free_intervals, duration):\n    for start, end in free_intervals:\n        if end - start >= duration:\n            return (start, start + duration)\n    return None\n\n# Define work hours in minutes (9:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end   = time_to_minutes(\"17:00\")\n\n# Meeting duration in minutes (1 hour)\nduration = 60\n\n# Busy intervals for each participant in minutes\n# Willie is free the entire day, so his busy list is empty.\nwillie_busy = []\n\n# Richard busy intervals\n# 10:00 - 10:30, 11:00 - 12:00, 13:00 - 14:00, 16:00 - 16:30\nrichard_busy = [\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"14:00\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))\n]\n\n# Noah busy intervals\n# 10:00 - 10:30, 11:30 - 13:00, 13:30 - 14:00, 14:30 - 17:00\nnoah_busy = [\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"13:30\"), time_to_minutes(\"14:00\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"17:00\"))\n]\n\n# Compute free intervals for each participant\nwillie_free = [(work_start, work_end)]  # Willie is free the whole day\nrichard_free = get_free_intervals(richard_busy, work_start, work_end)\nnoah_free = get_free_intervals(noah_busy, work_start, work_end)\n\n# Find common free intervals\ncommon_free = intersect_intervals(willie_free, richard_free)\ncommon_free = intersect_intervals(common_free, noah_free)\n\n# Now, select the earliest slot that fits the meeting duration.\nslot = find_slot(common_free, duration)\n\nif slot:\n    start_time = minutes_to_time(slot[0])\n    end_time = minutes_to_time(slot[1])\n    # Output in the format HH:MM:HH:MM\n    print(f\"{{{start_time}:{end_time}}}\")\nelse:\n    print(\"No available time slot found\")\n'''",
            "count": "calendar_scheduling_example_34"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    hh, mm = map(int, time_str.split(\":\"))\n    return hh * 60 + mm\n\ndef minutes_to_time(minutes):\n    hh = minutes // 60\n    mm = minutes % 60\n    return f\"{hh:02d}:{mm:02d}\"\n\n# Define work hours in minutes (9:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nmeeting_duration = 30  # in minutes\n\n# Define participants' busy intervals in minutes\n# Bradley is free all day but doesn't want to meet before 14:30\nbradley_constraint = time_to_minutes(\"14:30\")  # meeting must start at or after this time\n\n# Zachary's busy intervals\nzachary_busy = [\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\"))\n]\n\n# Teresa's busy intervals\nteresa_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"12:30\")),\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"14:00\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"16:30\"))\n]\n\n# Combine all busy intervals for participants who actually have blocks.\n# Bradley is free so only consider Zachary and Teresa\n\ndef is_slot_free(start, busy_intervals):\n    end = start + meeting_duration\n    for busy_start, busy_end in busy_intervals:\n        # if meeting overlaps with a busy interval, return False\n        # Overlap occurs if start < busy_end and end > busy_start.\n        if start < busy_end and end > busy_start:\n            return False\n    return True\n\n# The effective meeting search should start at the maximum of work_start and Bradley's constraint.\nsearch_start = max(work_start, bradley_constraint)\n\nfound_slot = None\n# candidate start times from search_start to latest possible start (work_end - meeting_duration)\nfor candidate in range(search_start, work_end - meeting_duration + 1):\n    if is_slot_free(candidate, zachary_busy) and is_slot_free(candidate, teresa_busy):\n        found_slot = candidate\n        break\n\nif found_slot is not None:\n    start_time = minutes_to_time(found_slot)\n    end_time = minutes_to_time(found_slot + meeting_duration)\n    # Output in required format {HH:MM:HH:MM}\n    print(f\"{{{start_time}:{end_time}}}\")\nelse:\n    print(\"No available meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_35"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\n# Convert a time string \"HH:MM\" to minutes since midnight\ndef time_to_minutes(t):\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\n# Convert minutes since midnight to a time string \"HH:MM\"\ndef minutes_to_time(m):\n    return f\"{m//60:02d}:{m%60:02d}\"\n\n# Meeting duration in minutes\nmeeting_duration = 60\n\n# Work day start and end times (in minutes since midnight)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Denise's constraint: Meeting must finish by 12:30 because she doesn't want to meet after 12:30.\nlatest_end = time_to_minutes(\"12:30\")\nlatest_start = latest_end - meeting_duration\n\n# Busy intervals for each participant (each as a tuple: (start_minutes, end_minutes))\n# Ryan's busy intervals: 09:00-09:30 and 12:30-13:00\nryan_busy = [(time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n             (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\"))]\n\n# Ruth has no meetings (schedule is completely open)\nruth_busy = []\n\n# Denise's busy intervals: 09:30-10:30, 12:00-13:00, 14:30-16:30\ndenise_busy = [(time_to_minutes(\"09:30\"), time_to_minutes(\"10:30\")),\n               (time_to_minutes(\"12:00\"), time_to_minutes(\"13:00\")),\n               (time_to_minutes(\"14:30\"), time_to_minutes(\"16:30\"))]\n\n# Function to check if a meeting time (start, end) conflicts with a busy interval list.\ndef is_available(start, end, busy_intervals):\n    for b_start, b_end in busy_intervals:\n        # If meeting and busy interval overlap, return False.\n        if start < b_end and end > b_start:\n            return False\n    return True\n\n# Try each minute from work_start to latest_start for a valid meeting time.\nproposed_start = None\nfor start in range(work_start, latest_start + 1):\n    end = start + meeting_duration\n    # Check if meeting falls within work hours and respects Denise's constraint\n    if end > work_end or end > latest_end:\n        continue\n    if (is_available(start, end, ryan_busy) and \n        is_available(start, end, ruth_busy) and \n        is_available(start, end, denise_busy)):\n        proposed_start = start\n        break\n\nif proposed_start is not None:\n    proposed_end = proposed_start + meeting_duration\n    # Format output as HH:MM:HH:MM\n    output = f\"{minutes_to_time(proposed_start)}:{minutes_to_time(proposed_end)}\"\n    print(f\"{{{output}}}\")\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_36"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "'''python\ndef to_minutes(time_str):\n    # Converts \"HH:MM\" to minutes since midnight.\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef from_minutes(minutes):\n    # Converts minutes since midnight to \"HH:MM\"\n    h = minutes // 60\n    m = minutes % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef merge_busy_intervals(busy, work_start, work_end):\n    # Sort busy intervals and merge overlapping ones\n    busy = sorted(busy, key=lambda x: x[0])\n    merged = []\n    for interval in busy:\n        if not merged:\n            merged.append(interval)\n        else:\n            last = merged[-1]\n            if interval[0] <= last[1]:\n                merged[-1] = (last[0], max(last[1], interval[1]))\n            else:\n                merged.append(interval)\n    # Clip intervals to work hours\n    clipped = []\n    for start, end in merged:\n        clipped.append((max(start, work_start), min(end, work_end)))\n    return clipped\n\ndef get_free_intervals(busy, work_start, work_end):\n    busy = merge_busy_intervals(busy, work_start, work_end)\n    free = []\n    current = work_start\n    for start, end in busy:\n        if current < start:\n            free.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    i, j = 0, 0\n    intersection = []\n    while i < len(intervals1) and j < len(intervals2):\n        a_start, a_end = intervals1[i]\n        b_start, b_end = intervals2[j]\n        # Find overlap between intervals\n        start = max(a_start, b_start)\n        end = min(a_end, b_end)\n        if start < end:\n            intersection.append((start, end))\n        if a_end < b_end:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\n# Define work hours in minutes (using minutes since midnight)\nwork_start = to_minutes(\"09:00\")\nwork_end   = to_minutes(\"17:00\")\nmeeting_duration = 30  # in minutes\n\n# Busy intervals for each participant for Monday, in minutes since midnight.\n# Gregory: 11:00-11:30, 12:00-12:30, 15:30-16:30\ngregory_busy = [\n    (to_minutes(\"11:00\"), to_minutes(\"11:30\")),\n    (to_minutes(\"12:00\"), to_minutes(\"12:30\")),\n    (to_minutes(\"15:30\"), to_minutes(\"16:30\"))\n]\n\n# Teresa's calendar is free all day.\nteresa_busy = []\n\n# Carol: 9:00-10:30, 11:00-16:00, 16:30-17:00\ncarol_busy = [\n    (to_minutes(\"09:00\"), to_minutes(\"10:30\")),\n    (to_minutes(\"11:00\"), to_minutes(\"16:00\")),\n    (to_minutes(\"16:30\"), to_minutes(\"17:00\"))\n]\n\n# Compute free intervals for each participant.\ngregory_free = get_free_intervals(gregory_busy, work_start, work_end)\nteresa_free = get_free_intervals(teresa_busy, work_start, work_end)\ncarol_free   = get_free_intervals(carol_busy, work_start, work_end)\n\n# Intersect free intervals across all participants.\n# First, intersect Gregory and Teresa\ncommon_free = intersect_intervals(gregory_free, teresa_free)\n# Then, intersect with Carol\ncommon_free = intersect_intervals(common_free, carol_free)\n\n# Find the earliest interval with at least meeting_duration minutes.\nproposed_slot = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        proposed_slot = (start, start + meeting_duration)\n        break\n\nif proposed_slot:\n    start_str = from_minutes(proposed_slot[0])\n    end_str = from_minutes(proposed_slot[1])\n    # Output in the format HH:MM:HH:MM\n    print(f\"{start_str}:{end_str}\")\nelse:\n    print(\"No available slot\")\n'''",
            "count": "calendar_scheduling_example_37"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "'''python\ndef to_minutes(time_str):\n    # time_str in \"HH:MM\" format\n    h, m = map(int, time_str.split(\":\"))\n    return h * 60 + m\n\ndef to_timestr(minutes):\n    h = minutes // 60\n    m = minutes % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef get_free_intervals(busy, work_start, work_end):\n    \"\"\"\n    busy: list of tuples (start, end) in minutes, assumed sorted and non-overlapping\n    work_start, work_end: working hours boundaries in minutes.\n    Returns list of free intervals as (start, end).\n    \"\"\"\n    free = []\n    current = work_start\n    for start, end in busy:\n        if start > current:\n            free.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_intervals(list1, list2):\n    \"\"\"\n    Intersect two lists of intervals. Each interval is a tuple (start, end).\n    Returns the intersection list.\n    \"\"\"\n    i, j = 0, 0\n    intersection = []\n    while i < len(list1) and j < len(list2):\n        s1, e1 = list1[i]\n        s2, e2 = list2[j]\n        # the intersection between intervals is:\n        start = max(s1, s2)\n        end = min(e1, e2)\n        if start < end:\n            intersection.append((start, end))\n        if e1 < e2:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\n# Working hours: 9:00 to 17:00\nwork_start = to_minutes(\"09:00\")\nwork_end = to_minutes(\"17:00\")\nmeeting_duration = 30  # in minutes\n\n# Busy intervals for each person (in minutes)\n# Catherine busy: 10:30-11:00, 12:30-13:30, 14:30-15:00\ncatherine_busy = [(to_minutes(\"10:30\"), to_minutes(\"11:00\")),\n                  (to_minutes(\"12:30\"), to_minutes(\"13:30\")),\n                  (to_minutes(\"14:30\"), to_minutes(\"15:00\"))]\n\n# Michael busy: 9:30-10:30, 12:00-13:00, 13:30-14:00, 15:00-15:30\nmichael_busy = [(to_minutes(\"09:30\"), to_minutes(\"10:30\")),\n                (to_minutes(\"12:00\"), to_minutes(\"13:00\")),\n                (to_minutes(\"13:30\"), to_minutes(\"14:00\")),\n                (to_minutes(\"15:00\"), to_minutes(\"15:30\"))]\n\n# Alexander busy: 9:00-9:30, 10:00-10:30, 11:00-12:00, 13:00-13:30, 14:00-16:00, 16:30-17:00\nalexander_busy = [(to_minutes(\"09:00\"), to_minutes(\"09:30\")),\n                  (to_minutes(\"10:00\"), to_minutes(\"10:30\")),\n                  (to_minutes(\"11:00\"), to_minutes(\"12:00\")),\n                  (to_minutes(\"13:00\"), to_minutes(\"13:30\")),\n                  (to_minutes(\"14:00\"), to_minutes(\"16:00\")),\n                  (to_minutes(\"16:30\"), to_minutes(\"17:00\"))]\n\n# Get free intervals for each\ncatherine_free = get_free_intervals(catherine_busy, work_start, work_end)\nmichael_free = get_free_intervals(michael_busy, work_start, work_end)\nalexander_free = get_free_intervals(alexander_busy, work_start, work_end)\n\n# Compute common free intervals among all three\ncommon_free = intersect_intervals(catherine_free, michael_free)\ncommon_free = intersect_intervals(common_free, alexander_free)\n\n# Find earliest interval that can fit the meeting duration\nmeeting_time = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        meeting_time = (start, start + meeting_duration)\n        break\n\nif meeting_time:\n    start_str = to_timestr(meeting_time[0])\n    end_str = to_timestr(meeting_time[1])\n    print(f\"{{{start_str}:{end_str}}}\")\nelse:\n    print(\"No common available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_38"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\ndef time_to_minutes(time_str):\n    # Converts \"HH:MM\" to minutes since midnight.\n    dt = datetime.strptime(time_str, \"%H:%M\")\n    return dt.hour * 60 + dt.minute\n\ndef minutes_to_time(minutes):\n    # Converts minutes since midnight to \"HH:MM\"\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Workday start and end in minutes.\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nmeeting_duration = 30  # minutes\n\n# Participants' busy schedules, each as list of intervals [start, end) in minutes.\n# Emily is free all day.\nbusy_schedules = {\n    \"Victoria\": [\n        (time_to_minutes(\"13:30\"), time_to_minutes(\"14:00\")),\n        (time_to_minutes(\"14:30\"), time_to_minutes(\"15:30\")),\n        (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))\n    ],\n    \"Nancy\": [\n        (time_to_minutes(\"09:00\"), time_to_minutes(\"14:00\")),\n        (time_to_minutes(\"14:30\"), time_to_minutes(\"15:30\"))\n    ]\n}\n\ndef is_slot_free(start, end, schedules):\n    for person, intervals in schedules.items():\n        for int_start, int_end in intervals:\n            # Check for overlap: if meeting slot [start, end) and busy interval [int_start, int_end) overlap.\n            if start < int_end and int_start < end:\n                return False\n    return True\n\n# Iterate over possible meeting start times (in minutes) starting from work_start to work_end - meeting_duration.\nproposed_start = None\nfor start in range(work_start, work_end - meeting_duration + 1):\n    end = start + meeting_duration\n    if is_slot_free(start, end, busy_schedules):\n        proposed_start = start\n        break\n\nif proposed_start is not None:\n    start_time_str = minutes_to_time(proposed_start)\n    end_time_str = minutes_to_time(proposed_start + meeting_duration)\n    # Output in format {HH:MM:HH:MM}, e.g. {14:30:15:30}\n    print(f\"{{{start_time_str}:{end_time_str}}}\")\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_39"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    # \"HH:MM\" to minutes since midnight\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    # minutes (int) to \"HH:MM\"\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef get_free_intervals(busy_intervals, work_start, work_end):\n    # busy_intervals is a list of (start, end) in minutes, assumed sorted and non-overlapping.\n    free = []\n    current = work_start\n    for start, end in busy_intervals:\n        if current < start:\n            free.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    # Given two lists of intervals, find their intersection.\n    i, j = 0, 0\n    intersection = []\n    while i < len(intervals1) and j < len(intervals2):\n        start = max(intervals1[i][0], intervals2[j][0])\n        end = min(intervals1[i][1], intervals2[j][1])\n        if start < end:\n            intersection.append((start, end))\n        if intervals1[i][1] < intervals2[j][1]:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\ndef intersect_all(intervals_list):\n    # intervals_list is a list of lists of intervals.\n    if not intervals_list:\n        return []\n    common = intervals_list[0]\n    for intervals in intervals_list[1:]:\n        common = intersect_intervals(common, intervals)\n    return common\n\n# Working hours: 09:00 to 17:00\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nmeeting_duration = 60  # one hour in minutes\n\n# Busy intervals for each person; each interval is given as (start, end) in minutes.\n# Jacob's busy times: 10:00-11:00, 11:30-12:00, 16:00-16:30\njacob_busy = [(time_to_minutes(\"10:00\"), time_to_minutes(\"11:00\")),\n              (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n              (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))]\n\n# Gabriel's busy times: 9:30-11:30, 13:00-13:30, 15:00-15:30\ngabriel_busy = [(time_to_minutes(\"09:30\"), time_to_minutes(\"11:30\")),\n                (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n                (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\"))]\n\n# Matthew's busy times: 9:00-9:30, 10:30-11:00, 11:30-12:00, 12:30-14:00, 15:30-16:30\nmatthew_busy = [(time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n                (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n                (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n                (time_to_minutes(\"12:30\"), time_to_minutes(\"14:00\")),\n                (time_to_minutes(\"15:30\"), time_to_minutes(\"16:30\"))]\n\n# Compute free intervals for each person\njacob_free = get_free_intervals(jacob_busy, work_start, work_end)\ngabriel_free = get_free_intervals(gabriel_busy, work_start, work_end)\nmatthew_free = get_free_intervals(matthew_busy, work_start, work_end)\n\n# Find common free intervals among all participants\ncommon_free = intersect_all([jacob_free, gabriel_free, matthew_free])\n\n# Find earliest interval with sufficient duration for the meeting\nproposed_start = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        proposed_start = start\n        break\n\nif proposed_start is not None:\n    proposed_end = proposed_start + meeting_duration\n    result = f\"{{{minutes_to_time(proposed_start)}:{minutes_to_time(proposed_end)}}}\"\nelse:\n    result = \"No possible meeting time found.\"\n\nprint(result)\n'''",
            "count": "calendar_scheduling_example_40"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_time(minutes):\n    hrs = minutes // 60\n    mins = minutes % 60\n    return f\"{hrs:02d}:{mins:02d}\"\n\n# Define helper function to convert time string to minutes from midnight\ndef time_to_minutes(time_str):\n    hrs, mins = map(int, time_str.split(\":\"))\n    return hrs * 60 + mins\n\n# Work hours boundaries in minutes: 9:00 to 17:00\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Meeting duration in minutes (30 minutes)\nmeeting_duration = 30\n\n# Define each participant's busy intervals as tuples (start, end) in minutes.\n# Alan: No meetings but does not want to meet before 14:30\nalan_constraint_start = time_to_minutes(\"14:30\")  # Alan's effective available start time is 14:30.\nalan_busy = []  # Alan is otherwise free\n\n# Nancy: Busy from 11:00 to 12:30, 13:00 to 13:30, 14:00 to 15:00\nnancy_busy = [\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"12:30\")),\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"15:00\"))\n]\n\n# Patricia: Busy from 10:00 to 12:00, 12:30 to 13:00, 13:30 to 16:00\npatricia_busy = [\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"13:30\"), time_to_minutes(\"16:00\"))\n]\n\n# Function to compute free intervals within work hours given busy intervals.\ndef get_free_intervals(busy, overall_start, overall_end):\n    # First, sort the busy intervals by start time\n    busy = sorted(busy, key=lambda interval: interval[0])\n    free_intervals = []\n    current_start = overall_start\n    for b_start, b_end in busy:\n        if b_start > current_start:\n            free_intervals.append((current_start, b_start))\n        current_start = max(current_start, b_end)\n    # After last busy interval\n    if current_start < overall_end:\n        free_intervals.append((current_start, overall_end))\n    return free_intervals\n\n# Calculate available intervals for each person within work hours and considering constraints.\n# Alan: available from max(9:00, constraint 14:30) to 17:00.\nalan_free = [(max(work_start, alan_constraint_start), work_end)]\n\nnancy_free = get_free_intervals(nancy_busy, work_start, work_end)\npatricia_free = get_free_intervals(patricia_busy, work_start, work_end)\n\n# We need only intervals that are on or after Alan's constraint (14:30).\ndef filter_intervals(intervals, min_start):\n    return [(max(start, min_start), end) for start, end in intervals if end > min_start]\n\nnancy_free = filter_intervals(nancy_free, alan_constraint_start)\npatricia_free = filter_intervals(patricia_free, alan_constraint_start)\n\n# Function to compute intersection of two lists of intervals.\ndef intersect_intervals(list1, list2):\n    result = []\n    i, j = 0, 0\n    while i < len(list1) and j < len(list2):\n        start1, end1 = list1[i]\n        start2, end2 = list2[j]\n        # Find overlap\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap < end_overlap:\n            result.append((start_overlap, end_overlap))\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Intersect free intervals across all participants\nintersection = alan_free\nfor free in [nancy_free, patricia_free]:\n    intersection = intersect_intervals(intersection, free)\n\n# Find the earliest interval that can accommodate the meeting duration.\nmeeting_time = None\nfor start, end in intersection:\n    if end - start >= meeting_duration:\n        meeting_time = (start, start + meeting_duration)\n        break\n\nif meeting_time:\n    start_time = minutes_to_time(meeting_time[0])\n    end_time = minutes_to_time(meeting_time[1])\n    # Output in the specified format HH:MM:HH:MM\n    print(f\"{{{start_time}:{end_time}}}\")\nelse:\n    print(\"No available meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_41"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    # Convert \"HH:MM\" to minutes from midnight\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    # Convert minutes from midnight to \"HH:MM\"\n    return f\"{minutes // 60:02d}:{minutes % 60:02d}\"\n\ndef get_free_intervals(busy_intervals, work_start, work_end):\n    # Given a list of busy intervals (each as (start, end) in minutes),\n    # return a list of free intervals within [work_start, work_end]\n    # Assume busy_intervals are sorted and non overlapping.\n    free = []\n    current = work_start\n    for start, end in busy_intervals:\n        if start > current:\n            free.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    # Compute the intersection of two lists of intervals. Each interval is (start, end).\n    intersection = []\n    i, j = 0, 0\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find the overlap between current intervals\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap < end_overlap:\n            intersection.append((start_overlap, end_overlap))\n        # Advance the pointer that ends earlier\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\ndef find_meeting_slot(free_lists, duration):\n    # Compute intersection across all free interval lists\n    if not free_lists:\n        return None\n    common = free_lists[0]\n    for fl in free_lists[1:]:\n        common = intersect_intervals(common, fl)\n        if not common:\n            return None\n    # Find earliest common interval that can accommodate the meeting duration\n    for start, end in common:\n        if end - start >= duration:\n            return start, start + duration\n    return None\n\n# Work day boundaries in minutes (9:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Busy intervals for each participant (in minutes)\n# Julie: 9:00-9:30, 11:00-11:30, 12:00-12:30, 13:30-14:00, 16:00-17:00\njulie_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"11:30\")),\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n    (time_to_minutes(\"13:30\"), time_to_minutes(\"14:00\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"17:00\"))\n]\n\n# Sean: 9:00-9:30, 13:00-13:30, 15:00-15:30, 16:00-16:30\nsean_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n    (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))\n]\n\n# Lori: 10:00-10:30, 11:00-13:00, 15:30-17:00\nlori_busy = [\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"17:00\"))\n]\n\n# Calculate free intervals for each participant\njulie_free = get_free_intervals(julie_busy, work_start, work_end)\nsean_free = get_free_intervals(sean_busy, work_start, work_end)\nlori_free = get_free_intervals(lori_busy, work_start, work_end)\n\n# Meeting duration in minutes (1 hour)\nmeeting_duration = 60\n\n# Find the earliest meeting slot from the intersections of free times\nslot = find_meeting_slot([julie_free, sean_free, lori_free], meeting_duration)\n\nif slot:\n    start, end = slot\n    start_str = minutes_to_time(start)\n    end_str = minutes_to_time(end)\n    # Output in the format {HH:MM:HH:MM}\n    print(\"{\" + f\"{start_str}:{end_str}\" + \"}\")\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_42"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\ndef slot_conflicts(slot_start, slot_end, busy_intervals):\n    for busy_start, busy_end in busy_intervals:\n        # If the meeting overlaps with a busy interval, return True.\n        if not (slot_end <= busy_start or slot_start >= busy_end):\n            return True\n    return False\n\ndef find_meeting_time(busy_schedules, start_day, end_day, duration):\n    # Convert start_day and end_day from \"HH:MM\" to minutes since midnight.\n    start_minutes = int(start_day.split(\":\")[0]) * 60 + int(start_day.split(\":\")[1])\n    end_minutes = int(end_day.split(\":\")[0]) * 60 + int(end_day.split(\":\")[1])\n    \n    # Iterate each possible start minute until the last possible start minute.\n    for t in range(start_minutes, end_minutes - duration + 1):\n        slot_start = t\n        slot_end = t + duration\n        # Check if slot conflicts in any busy schedule.\n        if all(not slot_conflicts(slot_start, slot_end, busy) for busy in busy_schedules):\n            return slot_start, slot_end\n    return None, None\n\nif __name__ == \"__main__\":\n    # Define busy intervals for each participant in minutes from midnight.\n    # Albert's busy intervals: 09:30-10:30, 12:00-12:30, 14:00-14:30, 15:00-15:30, 16:30-17:00\n    albert_busy = [\n        (9*60+30, 10*60+30),\n        (12*60, 12*60+30),\n        (14*60, 14*60+30),\n        (15*60, 15*60+30),\n        (16*60+30, 17*60)\n    ]\n    # Gregory's busy intervals: 11:00-11:30, 12:30-13:00, 13:30-14:00, 15:30-16:00\n    gregory_busy = [\n        (11*60, 11*60+30),\n        (12*60+30, 13*60),\n        (13*60+30, 14*60),\n        (15*60+30, 16*60)\n    ]\n    # Benjamin's busy intervals: 09:30-10:00, 10:30-11:00, 11:30-13:30, 14:00-15:00, 15:30-16:00, 16:30-17:00\n    benjamin_busy = [\n        (9*60+30, 10*60),\n        (10*60+30, 11*60),\n        (11*60+30, 13*60+30),\n        (14*60, 15*60),\n        (15*60+30, 16*60),\n        (16*60+30, 17*60)\n    ]\n    \n    # List of all busy schedules.\n    busy_schedules = [albert_busy, gregory_busy, benjamin_busy]\n    # Setup working hours and meeting duration (in minutes).\n    work_start = \"09:00\"\n    work_end = \"17:00\"\n    meeting_duration = 30  # minutes\n    \n    start, end = find_meeting_time(busy_schedules, work_start, work_end, meeting_duration)\n    if start is not None:\n        print(f\"{minutes_to_time(start)}:{minutes_to_time(end)}\")\n    else:\n        print(\"No available slot found.\")\n'''",
            "count": "calendar_scheduling_example_43"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\ndef time_to_minutes(t):\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    return \"{:02d}:{:02d}\".format(m // 60, m % 60)\n\n# Define working hours in minutes (9:00 - 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Meeting duration in minutes\nmeeting_duration = 30\n\n# Participant schedules (busy intervals in minutes)\n# Format: (start, end)\n# Isabella: free entire day, but prefers not to meet after 13:00, so effective free until 13:00.\nisabella_busy = []\nisabella_free = [(work_start, min(work_end, time_to_minutes(\"13:00\")))]  # [09:00, 13:00]\n\n# Ronald busy times: 11:30-12:00, 14:00-14:30, 16:00-17:00.\nronald_busy = [\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"14:30\")),\n    (time_to_minutes(\"16:00\"), work_end)\n]\n# Amanda busy times: 9:30-12:00, 12:30-13:00, 13:30-14:00, 15:30-17:00.\namanda_busy = [\n    (time_to_minutes(\"09:30\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"13:30\"), time_to_minutes(\"14:00\")),\n    (time_to_minutes(\"15:30\"), work_end)\n]\n\ndef invert_busy(busy, start, end):\n    # Given busy intervals sorted, return free intervals in [start, end].\n    free = []\n    current = start\n    for b_start, b_end in sorted(busy):\n        if b_start > current:\n            free.append((current, b_start))\n        current = max(current, b_end)\n    if current < end:\n        free.append((current, end))\n    return free\n\n# Get free intervals for Ronald and Amanda within working hours.\nronald_free = invert_busy(ronald_busy, work_start, work_end)\namanda_free = invert_busy(amanda_busy, work_start, work_end)\n\n# Function to compute intersection of intervals from two lists.\ndef intersect_intervals(list1, list2):\n    i, j = 0, 0\n    intersection = []\n    while i < len(list1) and j < len(list2):\n        start1, end1 = list1[i]\n        start2, end2 = list2[j]\n        start_int = max(start1, start2)\n        end_int = min(end1, end2)\n        if start_int + meeting_duration <= end_int:\n            intersection.append((start_int, end_int))\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\n# Start by intersecting Isabella's free times with Ronald's free times.\nint1 = intersect_intervals(isabella_free, ronald_free)\n# Now intersect the above result with Amanda's free times.\ncommon_free = intersect_intervals(int1, amanda_free)\n\n# Choose the earliest interval that can accommodate the meeting duration.\nproposed_start = None\nfor start, end in common_free:\n    if start + meeting_duration <= end:\n        proposed_start = start\n        break\n\nif proposed_start is not None:\n    proposed_end = proposed_start + meeting_duration\n    result = \"{\" + minutes_to_time(proposed_start) + \":\" + minutes_to_time(proposed_end) + \"}\"\n    print(result)\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_44"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Working hours in minutes (from 9:00 to 17:00)\nwork_start = 9 * 60  # 540\nwork_end = 17 * 60   # 1020\n\n# Busy intervals for Samuel in minutes (converted from HH:MM to minutes)\nbusy_intervals = [\n    (9 * 60, 10 * 60 + 30),    # 09:00 - 10:30 -> (540, 630)\n    (11 * 60 + 30, 12 * 60),    # 11:30 - 12:00 -> (690, 720)\n    (13 * 60, 13 * 60 + 30),    # 13:00 - 13:30 -> (780, 810)\n    (14 * 60, 16 * 60),         # 14:00 - 16:00 -> (840, 960)\n    (16 * 60 + 30, 17 * 60)     # 16:30 - 17:00 -> (990, 1020)\n]\n\n# Duration of the meeting in minutes\nmeeting_duration = 30\n\n# Function to find earliest available slot for all participants\ndef find_earliest_slot():\n    # Start from the beginning of the working day\n    current_time = work_start\n\n    # Iterate over the busy intervals sorted by start time\n    for busy_start, busy_end in sorted(busy_intervals):\n        # If current time is less than the start of the busy interval,\n        # check if the free gap is long enough.\n        if current_time + meeting_duration <= busy_start:\n            # Found a free slot!\n            return (current_time, current_time + meeting_duration)\n        # Otherwise, update current_time to the end of the busy interval if it's later\n        if current_time < busy_end:\n            current_time = busy_end\n\n    # After processing all busy intervals, check the remaining time\n    if current_time + meeting_duration <= work_end:\n        return (current_time, current_time + meeting_duration)\n    \n    # If no slot found, return None (should not occur since a solution exists)\n    return None\n\nslot = find_earliest_slot()\nif slot:\n    start_time_str = minutes_to_time(slot[0])\n    end_time_str = minutes_to_time(slot[1])\n    # Output in the requested format: {HH:MM:HH:MM}\n    print(f\"{{{start_time_str}:{end_time_str}}}\")\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_45"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    \"\"\"Convert HH:MM string to minutes from midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    \"\"\"Convert minutes from midnight to HH:MM string.\"\"\"\n    return f\"{minutes//60:02d}:{minutes%60:02d}\"\n\n# Workday boundaries\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nmeeting_duration = 30  # in minutes\n\n# Busy intervals for each participant in minutes from midnight\n# Arthur: 09:30-10:00, 14:00-14:30\narthur_busy = [(time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n               (time_to_minutes(\"14:00\"), time_to_minutes(\"14:30\"))]\n\n# Theresa: 09:00-09:30, 12:00-13:00, 15:00-16:30\ntheresa_busy = [(time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n                (time_to_minutes(\"12:00\"), time_to_minutes(\"13:00\")),\n                (time_to_minutes(\"15:00\"), time_to_minutes(\"16:30\"))]\n\n# Carl: 09:00-11:30, 12:00-14:00, 14:30-17:00\ncarl_busy = [(time_to_minutes(\"09:00\"), time_to_minutes(\"11:30\")),\n             (time_to_minutes(\"12:00\"), time_to_minutes(\"14:00\")),\n             (time_to_minutes(\"14:30\"), time_to_minutes(\"17:00\"))]\n\ndef get_free_intervals(busy, start, end):\n    \"\"\"Given busy intervals sorted in order, return free intervals within [start, end).\"\"\"\n    free = []\n    current = start\n    for b_start, b_end in sorted(busy):\n        if current < b_start:\n            free.append((current, b_start))\n        current = max(current, b_end)\n    if current < end:\n        free.append((current, end))\n    return free\n\n# Calculate free intervals for each person\narthur_free = get_free_intervals(arthur_busy, work_start, work_end)\ntheresa_free = get_free_intervals(theresa_busy, work_start, work_end)\ncarl_free = get_free_intervals(carl_busy, work_start, work_end)\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Return intersection of two lists of intervals.\"\"\"\n    i, j = 0, 0\n    intersection = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # find overlap\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap < end_overlap:\n            intersection.append((start_overlap, end_overlap))\n        # Move to next interval\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\n# Find common free intervals between all three participants\ncommon_free = intersect_intervals(arthur_free, theresa_free)\ncommon_free = intersect_intervals(common_free, carl_free)\n\n# Function to find earliest slot of required duration in free intervals\ndef find_meeting_slot(free_intervals, duration):\n    for start, end in free_intervals:\n        if end - start >= duration:\n            return start, start + duration\n    return None\n\nslot = find_meeting_slot(common_free, meeting_duration)\nif slot:\n    start_time, end_time = slot\n    # Format as HH:MM:HH:MM (using colon as indicated)\n    print(f\"{minutes_to_time(start_time)}:{minutes_to_time(end_time)}\")\nelse:\n    print(\"No available time slot.\")\n\n# Expected output for this task is: 11:30:12:00\n'''",
            "count": "calendar_scheduling_example_46"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_time(mins):\n    hours = mins // 60\n    minutes = mins % 60\n    return f\"{hours:02d}:{minutes:02d}\"\n\n# Define working day start and end in minutes (from midnight)\nwork_start = 9 * 60  # 540 minutes (09:00)\nwork_end = 17 * 60   # 1020 minutes (17:00)\nmeeting_duration = 60  # one hour meeting\n\n# Busy intervals for each participant: (start, end) in minutes\n# David: no busy intervals\neric_busy = [\n    (9 * 60, 9 * 60 + 30),      # 09:00 - 09:30\n    (10 * 60 + 30, 11 * 60 + 30),# 10:30 - 11:30\n    (15 * 60, 15 * 60 + 30)      # 15:00 - 15:30\n]\n\nroger_busy = [\n    (9 * 60 + 30, 10 * 60 + 30),  # 09:30 - 10:30\n    (11 * 60, 12 * 60),           # 11:00 - 12:00\n    (12 * 60 + 30, 13 * 60),      # 12:30 - 13:00\n    (14 * 60 + 30, 15 * 60),      # 14:30 - 15:00\n    (15 * 60 + 30, 16 * 60 + 30)  # 15:30 - 16:30\n]\n\n# Combine busy intervals for all participants\n# David has no busy intervals, so we only consider Eric and Roger.\nall_busy = eric_busy + roger_busy\n\ndef is_conflict(start, end, busy_intervals):\n    # check if meeting (start, end) conflicts with any busy interval\n    for b_start, b_end in busy_intervals:\n        # Conflict exists if the meeting starts before a busy period ends\n        # and the busy period starts before the meeting ends.\n        if start < b_end and b_start < end:\n            return True\n    return False\n\nproposed_start = None\n# Iterate over possible start times from work_start to (work_end - meeting_duration)\nfor t in range(work_start, work_end - meeting_duration + 1):\n    meeting_end = t + meeting_duration\n    if not is_conflict(t, meeting_end, all_busy):\n        proposed_start = t\n        break\n\nif proposed_start is not None:\n    start_str = minutes_to_time(proposed_start)\n    end_str = minutes_to_time(proposed_start + meeting_duration)\n    print(f\"{{{start_str}:{end_str}}}\")\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_47"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_time(minutes):\n    \"\"\"Convert minutes since midnight to HH:MM string.\"\"\"\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\ndef invert_busy(busy, work_start, work_end):\n    \"\"\"\n    Given a sorted list of busy intervals [ (start, end), ... ],\n    return a list of free intervals within work hours.\n    \"\"\"\n    free = []\n    prev_end = work_start\n    for start, end in busy:\n        if start > prev_end:\n            free.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free.append((prev_end, work_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Intersect two lists of intervals.\"\"\"\n    result = []\n    i, j = 0, 0\n    while i < len(intervals1) and j < len(intervals2):\n        a_start, a_end = intervals1[i]\n        b_start, b_end = intervals2[j]\n        # find overlap\n        start = max(a_start, b_start)\n        end = min(a_end, b_end)\n        if start < end:\n            result.append((start, end))\n        # move next whichever interval ends earlier\n        if a_end < b_end:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef intersect_multiple(interval_lists):\n    \"\"\"Intersect a list of interval lists.\"\"\"\n    if not interval_lists:\n        return []\n    intersection = interval_lists[0]\n    for intervals in interval_lists[1:]:\n        intersection = intersect_intervals(intersection, intervals)\n    return intersection\n\n# Work hours for Monday: 9:00 to 17:00 in minutes from midnight.\nwork_start = 9 * 60   # 540\nwork_end   = 17 * 60  # 1020\n\n# Meeting duration in minutes (1 hour)\nmeeting_duration = 60\n\n# Busy intervals for each participant in minutes.\n# Janet: 9:30-10:30, 12:30-13:00, 14:00-14:30\njanet_busy = [(9*60+30, 10*60+30), (12*60+30, 13*60), (14*60, 14*60+30)]\n# Rachel: no meetings\nrachel_busy = []\n# Cynthia: 9:30-10:00, 11:00-11:30, 12:30-14:30, 16:00-17:00\ncynthia_busy = [(9*60+30, 10*60), (11*60, 11*60+30), (12*60+30, 14*60+30), (16*60, 17*60)]\n\n# Additional constraint: Cynthia would rather not meet before 13:30.\nconstraint_start = 13 * 60 + 30  # 13:30 in minutes\n\n# Compute free intervals for each participant.\njanet_free = invert_busy(janet_busy, work_start, work_end)\nrachel_free = invert_busy(rachel_busy, work_start, work_end)\ncynthia_free = invert_busy(cynthia_busy, work_start, work_end)\n\n# Intersect the free intervals.\ncommon_free = intersect_multiple([janet_free, rachel_free, cynthia_free])\n\n# Apply the additional constraint that meeting start is no earlier than 13:30.\nvalid_slots = []\nfor start, end in common_free:\n    # Adjust start if earlier than constraint_start.\n    if start < constraint_start:\n        start = constraint_start\n    if end - start >= meeting_duration:\n        valid_slots.append((start, end))\n\n# Choose the earliest valid slot that fits the meeting duration.\nproposed = None\nfor start, end in valid_slots:\n    if end - start >= meeting_duration:\n        proposed = (start, start + meeting_duration)\n        break\n\nif proposed:\n    proposed_time = f\"{{{minutes_to_time(proposed[0])}:{minutes_to_time(proposed[1])}}}\"\n    print(proposed_time)\nelse:\n    print(\"No available slot found.\")\n'''",
            "count": "calendar_scheduling_example_48"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "'''python\ndef to_minutes(time_str):\n    \"\"\"Convert time string HH:MM to minutes since midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef to_timestr(minutes):\n    \"\"\"Convert minutes since midnight to time string HH:MM with leading zeros.\"\"\"\n    h = minutes // 60\n    m = minutes % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef compute_free_intervals(busy, work_start, work_end):\n    \"\"\"Given a sorted list of busy intervals (start, end) in minutes, return free intervals.\"\"\"\n    free = []\n    # First free interval from work_start to first busy (if any)\n    if not busy:\n        return [(work_start, work_end)]\n    if work_start < busy[0][0]:\n        free.append((work_start, busy[0][0]))\n    # Gaps between busy intervals\n    for i in range(len(busy) - 1):\n        end_current = busy[i][1]\n        start_next = busy[i+1][0]\n        if end_current < start_next:\n            free.append((end_current, start_next))\n    # Last free interval from end of last busy to work_end\n    if busy[-1][1] < work_end:\n        free.append((busy[-1][1], work_end))\n    return free\n\ndef intersect_intervals(intervals_a, intervals_b):\n    \"\"\"Given two lists of intervals, produce their intersection.\"\"\"\n    result = []\n    i, j = 0, 0\n    while i < len(intervals_a) and j < len(intervals_b):\n        a_start, a_end = intervals_a[i]\n        b_start, b_end = intervals_b[j]\n        # Find overlap between intervals\n        start_overlap = max(a_start, b_start)\n        end_overlap = min(a_end, b_end)\n        if start_overlap < end_overlap:\n            result.append((start_overlap, end_overlap))\n        # Move to next interval in the list that finishes earlier\n        if a_end < b_end:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef intersect_multiple(lists):\n    \"\"\"Intersect multiple lists of intervals.\"\"\"\n    if not lists:\n        return []\n    common = lists[0]\n    for lst in lists[1:]:\n        common = intersect_intervals(common, lst)\n    return common\n\ndef main():\n    # Define working hours for Monday in minutes (9:00 to 17:00)\n    work_start = to_minutes(\"09:00\")\n    work_end = to_minutes(\"17:00\")\n    \n    # Meeting duration in minutes (30 minutes)\n    duration = 30\n    # Kathleen's preference: no meeting after 14:30 (i.e. meeting must end by 14:30)\n    latest_end_allowed = to_minutes(\"14:30\")\n    \n    # Busy intervals for each participant (in minutes)\n    # Teresa busy intervals: 9:00-10:00, 13:00-13:30, 14:00-14:30, 15:00-15:30, 16:30-17:00\n    teresa_busy = [(to_minutes(\"09:00\"), to_minutes(\"10:00\")),\n                    (to_minutes(\"13:00\"), to_minutes(\"13:30\")),\n                    (to_minutes(\"14:00\"), to_minutes(\"14:30\")),\n                    (to_minutes(\"15:00\"), to_minutes(\"15:30\")),\n                    (to_minutes(\"16:30\"), to_minutes(\"17:00\"))]\n    \n    # Kathleen busy intervals: 9:00-9:30, 12:30-13:00, 13:30-14:00, 15:00-15:30\n    kathleen_busy = [(to_minutes(\"09:00\"), to_minutes(\"09:30\")),\n                     (to_minutes(\"12:30\"), to_minutes(\"13:00\")),\n                     (to_minutes(\"13:30\"), to_minutes(\"14:00\")),\n                     (to_minutes(\"15:00\"), to_minutes(\"15:30\"))]\n    \n    # Patricia busy intervals: 9:00-10:30, 11:30-12:00, 13:00-13:30, 14:00-14:30, 15:30-16:00, 16:30-17:00\n    patricia_busy = [(to_minutes(\"09:00\"), to_minutes(\"10:30\")),\n                     (to_minutes(\"11:30\"), to_minutes(\"12:00\")),\n                     (to_minutes(\"13:00\"), to_minutes(\"13:30\")),\n                     (to_minutes(\"14:00\"), to_minutes(\"14:30\")),\n                     (to_minutes(\"15:30\"), to_minutes(\"16:00\")),\n                     (to_minutes(\"16:30\"), to_minutes(\"17:00\"))]\n    \n    # Compute free intervals for each participant within working hours\n    teresa_free = compute_free_intervals(teresa_busy, work_start, work_end)\n    kathleen_free = compute_free_intervals(kathleen_busy, work_start, work_end)\n    patricia_free = compute_free_intervals(patricia_busy, work_start, work_end)\n    \n    # Intersect free intervals across all participants to get common free time slots\n    common_free = intersect_multiple([teresa_free, kathleen_free, patricia_free])\n    \n    # Look for the earliest common time slot that can fit the meeting duration and respects Kathleen's preference.\n    proposed_start = None\n    for interval in common_free:\n        start, end = interval\n        # Candidate meeting must be fully contained in the intersection and end by latest_end_allowed.\n        candidate_start = start\n        candidate_end = candidate_start + duration\n        # Adjust candidate_end if the interval is longer than Kathleen's allowed time window.\n        if candidate_end <= end and candidate_end <= latest_end_allowed:\n            proposed_start = candidate_start\n            break\n        # If the interval extends past latest_end_allowed, try if we can start later in the interval to finish by latest_end_allowed.\n        if end > latest_end_allowed:\n            # The latest possible start in this interval to finish by Kathleen's preference\n            candidate_start = max(start, latest_end_allowed - duration)\n            candidate_end = candidate_start + duration\n            if candidate_start >= start and candidate_end <= end and candidate_end <= latest_end_allowed:\n                proposed_start = candidate_start\n                break\n\n    if proposed_start is not None:\n        proposed_end = proposed_start + duration\n        # Format the output as requested in the format {HH:MM:HH:MM}\n        print(f\"{{{to_timestr(proposed_start)}:{to_timestr(proposed_end)}}}\")\n    else:\n        print(\"No available time slot found.\")\n\nif __name__ == \"__main__\":\n    main()\n'''",
            "count": "calendar_scheduling_example_49"
        },
        {
            "final_program_time": "{13:30:14:30}",
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_time(minutes):\n    \"\"\"Convert minutes since midnight to HH:MM format.\"\"\"\n    hour = minutes // 60\n    minute = minutes % 60\n    return f\"{hour:02d}:{minute:02d}\"\n\ndef find_meeting_slot(work_start, work_end, busy_intervals, duration):\n    \"\"\"\n    Find the earliest meeting slot of given duration (in minutes)\n    within the work hours from work_start to work_end (in minutes),\n    given a list of busy intervals (each as a tuple (start, end) in minutes).\n    \"\"\"\n    # Sort busy intervals by start time\n    busy_intervals.sort()\n    \n    # Start with the working period start\n    current = work_start\n\n    # Check free time before each busy interval\n    for interval in busy_intervals:\n        busy_start, busy_end = interval\n        # If there is enough free time between current time and the busy interval start, return it.\n        if busy_start - current >= duration:\n            return current, current + duration\n        # Otherwise, update the current time to the maximum of current and busy_end\n        current = max(current, busy_end)\n\n    # Check free time after the last busy interval until end of work hours\n    if work_end - current >= duration:\n        return current, current + duration\n    return None\n\n# Define work hours in minutes (from 9:00 to 17:00)\nwork_start = 9 * 60   # 540 minutes (9:00)\nwork_end = 17 * 60    # 1020 minutes (17:00)\n\n# Emma's busy intervals in minutes since midnight:\n# 09:00 to 10:30, 11:00 to 12:00, 12:30 to 13:30, 14:30 to 15:30, 16:00 to 16:30\nbusy_intervals = [\n    (9 * 60, 10 * 60 + 30),    # 540 to 630\n    (11 * 60, 12 * 60),        # 660 to 720\n    (12 * 60 + 30, 13 * 60 + 30),  # 750 to 810\n    (14 * 60 + 30, 15 * 60 + 30),  # 870 to 930\n    (16 * 60, 16 * 60 + 30)     # 960 to 990\n]\n\n# Meeting duration: 1 hour = 60 minutes\nmeeting_duration = 60\n\n# Find the earliest meeting slot that works for everyone.\nslot = find_meeting_slot(work_start, work_end, busy_intervals, meeting_duration)\nif slot:\n    start_minutes, end_minutes = slot\n    start_time = minutes_to_time(start_minutes)\n    end_time = minutes_to_time(end_minutes)\n    # Output the result in the format {HH:MM:HH:MM}\n    print(f\"{{{start_time}:{end_time}}}\")\nelse:\n    print(\"No available meeting slot found.\")\n'''",
            "count": "calendar_scheduling_example_50"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    # t is a string in HH:MM format\n    h, m = map(int, t.split(':'))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\n# Workday boundaries in minutes (9:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\nmeeting_duration = 60  # in minutes\n\n# Busy schedules for each participant as list of (start_min, end_min) tuples.\nschedules = {\n    \"Brandon\": [(time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n                (time_to_minutes(\"12:30\"), time_to_minutes(\"13:30\")),\n                (time_to_minutes(\"14:00\"), time_to_minutes(\"14:30\"))],\n    \"Donna\":   [(time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n                (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\"))],\n    \"Jack\":    [(time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n                (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n                (time_to_minutes(\"11:30\"), time_to_minutes(\"12:30\")),\n                (time_to_minutes(\"13:00\"), time_to_minutes(\"14:30\")),\n                (time_to_minutes(\"15:30\"), time_to_minutes(\"17:00\"))]\n}\n\ndef is_time_slot_free(start, end, busy_intervals):\n    # Check if a time slot [start, end) overlaps with any busy interval.\n    for bstart, bend in busy_intervals:\n        # If the meeting starts before busy ends and ends after busy starts, there's an overlap.\n        if start < bend and end > bstart:\n            return False\n    return True\n\ndef all_available(start, end):\n    # Check all participants are free during [start, end)\n    for person in schedules:\n        if not is_time_slot_free(start, end, schedules[person]):\n            return False\n    return True\n\nproposed_start = None\n\n# Search for the earliest time slot in minute increments\nfor start in range(work_start, work_end - meeting_duration + 1):\n    end = start + meeting_duration\n    if all_available(start, end):\n        proposed_start = start\n        break\n\nif proposed_start is not None:\n    proposed_end = proposed_start + meeting_duration\n    # Format output as {HH:MM:HH:MM}\n    meeting_time = f\"{{{minutes_to_time(proposed_start)}:{minutes_to_time(proposed_end)}}}\"\n    print(meeting_time)\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_51"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    h, m = map(int, t.split(':'))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\n# Define the work day start and end times in minutes\nWORK_START = time_to_minutes(\"09:00\")\nWORK_END = time_to_minutes(\"17:00\")\n\n# Meeting duration in minutes (1 hour)\nMEETING_DURATION = 60\n\n# Busy intervals for each participant (in \"HH:MM\" format: start, end)\n# Grace busy: 9:00-9:30, 10:00-11:00, 16:00-16:30\ngrace_busy = [(time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n              (time_to_minutes(\"10:00\"), time_to_minutes(\"11:00\")),\n              (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))]\n\n# Randy busy: 12:30-13:00, 16:00-16:30\nrandy_busy = [(time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\")),\n              (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))]\n\n# Susan busy: 9:00-14:30, 15:30-16:00\nsusan_busy = [(time_to_minutes(\"09:00\"), time_to_minutes(\"14:30\")),\n              (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\"))]\n\ndef invert_busy(busy):\n    \"\"\"Given busy intervals, returns free intervals within work hours.\"\"\"\n    free = []\n    current = WORK_START\n    for start, end in sorted(busy):\n        if start > current:\n            free.append((current, start))\n        current = max(current, end)\n    if current < WORK_END:\n        free.append((current, WORK_END))\n    return free\n\n# Get the free intervals for each participant\ngrace_free = invert_busy(grace_busy)\nrandy_free = invert_busy(randy_busy)\nsusan_free = invert_busy(susan_busy)\n\n# Function to intersect two lists of intervals\ndef intersect_intervals(intervals1, intervals2):\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find the overlap between intervals1[i] and intervals2[j]\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap < end_overlap:\n            result.append((start_overlap, end_overlap))\n        # Move to the next interval in the list that ends first\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Intersect free intervals of all three participants\ncommon_free = intersect_intervals(grace_free, randy_free)\ncommon_free = intersect_intervals(common_free, susan_free)\n\n# Find the earliest interval that can accommodate the meeting duration\nmeeting_slot = None\nfor start, end in common_free:\n    if end - start >= MEETING_DURATION:\n        meeting_slot = (start, start + MEETING_DURATION)\n        break\n\nif meeting_slot:\n    start_str = minutes_to_time(meeting_slot[0])\n    end_str = minutes_to_time(meeting_slot[1])\n    print(f\"{{{start_str}:{end_str}}}\")\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_52"
        },
        {
            "final_program_time": "{15:30:16:30}",
            "expected_time": "{15:30:16:30}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_time(m):\n    \"\"\"Convert minutes since midnight to HH:MM string.\"\"\"\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef get_free_intervals(busy, day_start, day_end):\n    \"\"\"Given busy intervals (sorted, non-overlapping) as (start, end) in minutes,\n       return free intervals between day_start and day_end.\"\"\"\n    free = []\n    current = day_start\n    for start, end in busy:\n        if start > current:\n            free.append((current, start))\n        current = max(current, end)\n    if current < day_end:\n        free.append((current, day_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Intersect two lists of intervals.\"\"\"\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find overlap:\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap < end_overlap:\n            result.append((start_overlap, end_overlap))\n        # Move to next interval in the list that ends first\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef format_interval(interval):\n    \"\"\"Format interval tuple (start_min, end_min) as HH:MM:HH:MM\"\"\"\n    start, end = interval\n    return f\"{{{minutes_to_time(start)}:{minutes_to_time(end)}}}\"\n\n# Define working hours (9:00 - 17:00)\nday_start = 9 * 60   # 540 minutes\nday_end = 17 * 60    # 1020 minutes\n\n# Meeting duration in minutes (1 hour)\nmeeting_duration = 60\n\n# Busy intervals for each participant (in minutes) sorted and non-overlapping.\n# Noah's calendar is wide open, so no busy intervals.\nnoah_busy = []\n\n# Alice busy: 9:30-10:00, 12:30-13:00, 14:30-15:00, 16:30-17:00\nalice_busy = [(9*60+30, 10*60), (12*60+30, 13*60), (14*60+30, 15*60), (16*60+30, 17*60)]\n\n# Arthur busy: 9:00-9:30, 10:00-11:00, 11:30-12:00, 13:00-14:00, 15:00-15:30, 16:30-17:00\narthur_busy = [(9*60, 9*60+30), (10*60, 11*60), (11*60+30, 12*60), (13*60, 14*60), (15*60, 15*60+30), (16*60+30, 17*60)]\n\n# Compute free intervals for each participant.\nnoah_free = get_free_intervals(noah_busy, day_start, day_end)\nalice_free = get_free_intervals(alice_busy, day_start, day_end)\narthur_free = get_free_intervals(arthur_busy, day_start, day_end)\n\n# Find the intersection of free intervals between Noah, Alice and Arthur.\nfree_noah_alice = intersect_intervals(noah_free, alice_free)\ncommon_free = intersect_intervals(free_noah_alice, arthur_free)\n\n# Find the earliest interval with enough duration.\nproposed_interval = None\nfor interval in common_free:\n    start, end = interval\n    if end - start >= meeting_duration:\n        proposed_interval = (start, start + meeting_duration)\n        break\n\nif proposed_interval:\n    # Format the result: HH:MM:HH:MM\n    result = format_interval(proposed_interval)\n    print(result)\nelse:\n    print(\"No common time slot available.\")\n'''",
            "count": "calendar_scheduling_example_53"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_time(minutes):\n    hh = minutes // 60\n    mm = minutes % 60\n    return f\"{hh:02d}:{mm:02d}\"\n\ndef intersect_intervals(intervals1, intervals2):\n    intersection = []\n    i, j = 0, 0\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find the intersection between the two intervals\n        start = max(start1, start2)\n        end = min(end1, end2)\n        if start < end:\n            intersection.append((start, end))\n        # Move to next interval in the list that ends earlier\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\n# Define meeting duration in minutes (1 hour)\nmeeting_duration = 60\n\n# Free intervals for each participant in minutes since midnight:\n# Isabella is free: 09:00-11:00 and 11:30-15:30\nisabella_free = [(9*60, 11*60), (11*60+30, 15*60+30)]\n# Tyler is free: busy 09:00-10:00, and cannot meet after 16:00,\n# so his free interval for meetings is 10:00-16:00.\ntyler_free = [(10*60, 16*60)]\n# Jordan is free: busy intervals are 09:00-10:00, 10:30-11:00, 12:30-13:30, 14:00-14:30, 15:00-16:00,\n# so his free intervals are:\n# 10:00-10:30, 11:00-12:30, 13:30-14:00, 14:30-15:00.\njordan_free = [(10*60, 10*60+30), (11*60, 12*60+30), (13*60+30, 14*60), (14*60+30, 15*60)]\n\n# Compute the common free intervals by intersecting the free intervals lists.\ncommon = intersect_intervals(isabella_free, tyler_free)\ncommon = intersect_intervals(common, jordan_free)\n\nproposed_time = None\nfor start, end in common:\n    if end - start >= meeting_duration:\n        proposed_time = (start, start + meeting_duration)\n        break\n\nif proposed_time:\n    start_time = minutes_to_time(proposed_time[0])\n    end_time = minutes_to_time(proposed_time[1])\n    print(f\"{{{start_time}:{end_time}}}\")\nelse:\n    print(\"No available time slot found\")\n'''",
            "count": "calendar_scheduling_example_54"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_time_str(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\ndef get_free_intervals(busy, work_start, work_end):\n    # busy intervals should be sorted by start time\n    free = []\n    current = work_start\n    for start, end in busy:\n        if current < start:\n            free.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # find overlap\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap < end_overlap:\n            result.append((start_overlap, end_overlap))\n        # move to next interval\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef find_common_free_interval(free_lists, meeting_duration):\n    # Start with free intervals of the first person\n    common = free_lists[0]\n    for free in free_lists[1:]:\n        common = intersect_intervals(common, free)\n        if not common:\n            break\n    # Find the earliest interval that can accommodate the meeting_duration\n    for start, end in common:\n        if end - start >= meeting_duration:\n            return (start, start + meeting_duration)\n    return None\n\ndef main():\n    # Work day boundaries in minutes since midnight (9:00 to 17:00)\n    work_start = 9 * 60   # 540\n    work_end = 17 * 60    # 1020\n    meeting_duration = 60  # one hour meeting in minutes\n\n    # Define busy schedules in minutes for each person\n    # Keith: busy during 14:00-14:30 and 16:00-16:30\n    keith_busy = [(14 * 60, 14 * 60 + 30), (16 * 60, 16 * 60 + 30)]\n    # Christine: free all day (no busy intervals)\n    christine_busy = []\n    # Cynthia: busy during 09:00-10:30 and 11:30-17:00\n    cynthia_busy = [(9 * 60, 10 * 60 + 30), (11 * 60 + 30, 17 * 60)]\n\n    # Compute free intervals for each person\n    keith_free = get_free_intervals(keith_busy, work_start, work_end)\n    christine_free = get_free_intervals(christine_busy, work_start, work_end)\n    cynthia_free = get_free_intervals(cynthia_busy, work_start, work_end)\n\n    free_lists = [keith_free, christine_free, cynthia_free]\n    meeting_slot = find_common_free_interval(free_lists, meeting_duration)\n\n    if meeting_slot:\n        start_time, end_time = meeting_slot\n        # Format the output as {HH:MM:HH:MM}\n        output = \"{\" + f\"{minutes_to_time_str(start_time)}:{minutes_to_time_str(end_time)}\" + \"}\"\n        print(output)\n    else:\n        print(\"No common free slot available\")\n\nif __name__ == \"__main__\":\n    main()\n'''",
            "count": "calendar_scheduling_example_55"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\ndef check_availability(slot_start, slot_end, busy_intervals):\n    # Return True if the slot does NOT overlap with any busy intervals.\n    for start, end in busy_intervals:\n        # Check if [slot_start, slot_end) overlaps with [start, end)\n        if not (slot_end <= start or slot_start >= end):\n            return False\n    return True\n\ndef main():\n    meeting_duration = 30  # in minutes\n    work_start = 9 * 60    # 9:00 in minutes (540)\n    work_end = 17 * 60     # 17:00 in minutes (1020)\n\n    # Define busy times in minutes since midnight for each participant:\n    # Jeremy's busy intervals: 12:00-13:00, 13:30-14:00, 15:00-15:30\n    jeremy_busy = [(12*60, 13*60), (13*60+30, 14*60), (15*60, 15*60+30)]\n    \n    # Donna's busy intervals: 9:30-10:00, 13:00-13:30, 16:00-17:00\n    donna_busy = [(9*60+30, 10*60), (13*60, 13*60+30), (16*60, 17*60)]\n    \n    # Robert's busy intervals: 9:00-11:00, 11:30-12:00, 12:30-17:00\n    robert_busy = [(9*60, 11*60), (11*60+30, 12*60), (12*60+30, 17*60)]\n    \n    # Combine all participants' busy intervals for checking purposes.\n    # We have to check each participant separately.\n    all_busy = [jeremy_busy, donna_busy, robert_busy]\n\n    # Iterate through possible meeting start times from work_start to work_end - meeting_duration\n    for start in range(work_start, work_end - meeting_duration + 1):\n        end = start + meeting_duration\n        if all(check_availability(start, end, busy) for busy in all_busy):\n            # Found the earliest possible slot; format the output and print.\n            start_time = minutes_to_time(start)\n            end_time = minutes_to_time(end)\n            # Format as {HH:MM:HH:MM} as required.\n            print(\"{\" + f\"{start_time}:{end_time}\" + \"}\")\n            return\n\nif __name__ == \"__main__\":\n    main()\n'''",
            "count": "calendar_scheduling_example_56"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import timedelta, datetime\n\n# Utility function: convert time in \"HH:MM\" format to minutes since 0:00\ndef time_to_minutes(t):\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\n# Utility function: convert minutes since 0:00 to \"HH:MM\" format\ndef minutes_to_time(m):\n    h = m // 60\n    mins = m % 60\n    return f\"{h:02d}:{mins:02d}\"\n\n# Function to compute free intervals given busy intervals and working hours.\ndef compute_free_intervals(busy_intervals, work_start, work_end):\n    free_intervals = []\n    # Start with work_start\n    previous_end = work_start\n    for start, end in sorted(busy_intervals):\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_intervals.append((previous_end, work_end))\n    return free_intervals\n\n# Function to intersect two lists of intervals\ndef intersect_intervals(intervals1, intervals2):\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Compute intersection\n        start_int = max(start1, start2)\n        end_int = min(end1, end2)\n        if start_int < end_int:\n            result.append((start_int, end_int))\n        # Move on from whichever interval ends earlier.\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Meeting parameters\nmeeting_duration = 30  # in minutes\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Participant busy intervals (in minutes)\n# Virginia is busy from 10:00 to 12:00.\nvirginia_busy = [(time_to_minutes(\"10:00\"), time_to_minutes(\"12:00\"))]\n\n# Charles is busy from 12:00 to 12:30 and 13:00 to 13:30.\n# Additionally, Charles wants to avoid any meeting before 14:30, so his effective free time starts at 14:30.\ncharles_busy = [(time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n                (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\"))]\n# Charles working time is restricted by his preference: meeting not before 14:30.\ncharles_effective_start = max(work_start, time_to_minutes(\"14:30\"))\n\n# Megan is busy from 09:00 to 12:00 and 13:30 to 16:00 and 16:30 to 17:00.\nmegan_busy = [(time_to_minutes(\"09:00\"), time_to_minutes(\"12:00\")),\n              (time_to_minutes(\"13:30\"), time_to_minutes(\"16:00\")),\n              (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))]\n\n# Compute free intervals for each participant\n\n# Virginia free intervals from work_start to work_end\nvirginia_free = compute_free_intervals(virginia_busy, work_start, work_end)\n\n# For Charles, first compute free intervals within work hours then intersect with his effective start constraint.\ncharles_free_all = compute_free_intervals(charles_busy, work_start, work_end)\n# Now restrict Charles free intervals to those starting at or after 14:30.\ncharles_free = []\nfor start, end in charles_free_all:\n    if end <= charles_effective_start:\n        continue\n    restricted_start = max(start, charles_effective_start)\n    if restricted_start < end:\n        charles_free.append((restricted_start, end))\n\n# Megan free intervals\nmegan_free = compute_free_intervals(megan_busy, work_start, work_end)\n\n# Now, compute the intersection of the free intervals of all three participants.\ncommon_free = intersect_intervals(virginia_free, charles_free)\ncommon_free = intersect_intervals(common_free, megan_free)\n\n# Find the earliest common free interval that can fit the meeting duration.\nproposed_meeting = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        proposed_meeting = (start, start + meeting_duration)\n        break\n\nif proposed_meeting:\n    meeting_start = minutes_to_time(proposed_meeting[0])\n    meeting_end = minutes_to_time(proposed_meeting[1])\n    # Output format: {HH:MM:HH:MM}\n    print(f\"{{{meeting_start}:{meeting_end}}}\")\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_57"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    \"\"\"Convert HH:MM string to minutes since midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    \"\"\"Convert minutes since midnight to HH:MM string with zero-padding.\"\"\"\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Define working hours in minutes\nwork_start = time_to_minutes(\"09:00\")\nwork_end   = time_to_minutes(\"17:00\")\n\n# Meeting duration in minutes\nmeeting_duration = 60\n\n# Busy intervals for each person in HH:MM format\nbusy_schedules = {\n    \"Joan\":    [(\"11:00\", \"11:30\"), (\"12:30\", \"13:00\")],\n    \"Theresa\": [(\"12:00\", \"12:30\"), (\"15:00\", \"15:30\")],\n    \"Shirley\": [(\"9:30\", \"10:30\"), (\"11:00\", \"12:00\"), (\"13:00\", \"14:00\"), (\"15:30\", \"16:30\")]\n}\n\n# Convert busy intervals to minutes\nfor person, intervals in busy_schedules.items():\n    busy_schedules[person] = [(time_to_minutes(start), time_to_minutes(end)) for start, end in intervals]\n\ndef is_free(start_min, end_min, busy_intervals):\n    \"\"\"Return True if the period [start_min, end_min) does not overlap any busy interval.\"\"\"\n    for bstart, bend in busy_intervals:\n        # Check if the meeting interval overlaps the busy interval.\n        if not (end_min <= bstart or start_min >= bend):\n            return False\n    return True\n\ndef find_earliest_meeting():\n    # Iterate over each possible start minute that allows a full meeting duration\n    for meeting_start in range(work_start, work_end - meeting_duration + 1):\n        meeting_end = meeting_start + meeting_duration\n        # Check for all persons if the interval [meeting_start, meeting_end) is free\n        all_free = True\n        for person, busy_intervals in busy_schedules.items():\n            if not is_free(meeting_start, meeting_end, busy_intervals):\n                all_free = False\n                break\n        if all_free:\n            return meeting_start, meeting_end\n    return None\n\nresult = find_earliest_meeting()\n\nif result:\n    start, end = result\n    # format the output as {HH:MM:HH:MM}\n    output = \"{\" + minutes_to_time(start) + \":\" + minutes_to_time(end) + \"}\"\n    print(output)\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_58"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "'''python\ndef to_minutes(time_str):\n    # Converts \"HH:MM\" to minutes past midnight.\n    h, m = map(int, time_str.split(\":\"))\n    return h * 60 + m\n\ndef to_time_str(minutes):\n    # Converts minutes to \"HH:MM\" string with zero-padding.\n    h = minutes // 60\n    m = minutes % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef invert_busy(busy, start, end):\n    \"\"\"\n    Given a list of busy intervals [ (start, end), ... ] and the overall period start-end,\n    return list of free intervals.\n    \"\"\"\n    free = []\n    current = start\n    for bstart, bend in sorted(busy):\n        if current < bstart:\n            free.append((current, bstart))\n        current = max(current, bend)\n    if current < end:\n        free.append((current, end))\n    return free\n\ndef intersect_intervals(list1, list2):\n    \"\"\"\n    Given two lists of intervals, return their intersection.\n    Each list consists of tuples (start, end).\n    \"\"\"\n    i, j = 0, 0\n    intersection = []\n    while i < len(list1) and j < len(list2):\n        start1, end1 = list1[i]\n        start2, end2 = list2[j]\n        # Find intersection of current intervals\n        start_int = max(start1, start2)\n        end_int = min(end1, end2)\n        if start_int < end_int:\n            intersection.append((start_int, end_int))\n        # Advance the interval that finishes first\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\n# Workday and meeting duration\nwork_start = to_minutes(\"09:00\")\nwork_end = to_minutes(\"17:00\")\nduration = 30  # meeting duration in minutes\n\n# Person-specific constraints\n# Jeffrey: wide open, but prefers meetings not before 14:00.\njeffrey_avail = [(max(work_start, to_minutes(\"14:00\")), work_end)]\n\n# Jack's busy intervals:\njack_busy = [\n    (to_minutes(\"10:30\"), to_minutes(\"11:30\")),\n    (to_minutes(\"13:00\"), to_minutes(\"13:30\")),\n    (to_minutes(\"14:00\"), to_minutes(\"14:30\")),\n    (to_minutes(\"16:00\"), to_minutes(\"17:00\"))\n]\njack_free = invert_busy(jack_busy, work_start, work_end)\n\n# Judith's busy intervals:\njudith_busy = [\n    (to_minutes(\"09:00\"), to_minutes(\"10:00\")),\n    (to_minutes(\"10:30\"), to_minutes(\"11:00\")),\n    (to_minutes(\"11:30\"), to_minutes(\"14:00\")),\n    (to_minutes(\"14:30\"), to_minutes(\"15:00\")),\n    (to_minutes(\"15:30\"), to_minutes(\"17:00\"))\n]\njudith_free = invert_busy(judith_busy, work_start, work_end)\n\n# Calculate the common free intervals for Jack and Judith first.\ncommon_free = intersect_intervals(jack_free, judith_free)\n# Now intersect with Jeffrey's availability.\ncommon_free = intersect_intervals(common_free, jeffrey_avail)\n\n# Find the earliest interval that can accommodate the meeting duration.\nproposed_start = None\nfor start, end in common_free:\n    if end - start >= duration:\n        proposed_start = start\n        break\n\nif proposed_start is not None:\n    proposed_end = proposed_start + duration\n    # Output in format HH:MM:HH:MM enclosed in curly braces\n    output = f\"{{{to_time_str(proposed_start)}:{to_time_str(proposed_end)}}}\"\n    print(output)\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_59"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    # Converts time \"HH:MM\" to minutes since midnight.\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(mins):\n    # Converts minutes since midnight to a \"HH:MM\" string.\n    hours = mins // 60\n    minutes = mins % 60\n    return f\"{hours:02d}:{minutes:02d}\"\n\ndef is_slot_free(slot_start, slot_end, busy_intervals):\n    # Checks if the slot [slot_start, slot_end) does not overlap any busy interval.\n    for start, end in busy_intervals:\n        if slot_start < end and slot_end > start:\n            return False\n    return True\n\n# Meeting settings:\nmeeting_duration = 30  # in minutes\nwork_start = time_to_minutes(\"09:00\")\nwork_end   = time_to_minutes(\"17:00\")\n\n# Participants' busy intervals (in minutes after midnight)\n# Lisa's busy intervals: 10:30-11:00, 11:30-12:00, 14:00-15:00\nlisa_busy = [\n    (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"15:00\"))\n]\n\n# Dorothy's busy intervals: none (but she prefers no meetings after 10:30)\ndorothy_busy = []  # free all day\n\n# Raymond's busy intervals: 09:00-10:00, 10:30-11:00, 11:30-15:00, 16:00-17:00\nraymond_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"17:00\"))\n]\n\n# Dorothy's personal constraint: meeting must finish by 10:30.\ndorothy_latest_end = time_to_minutes(\"10:30\")\n\n# Since meeting duration is fixed, candidate start times should be such that:\n# slot_end = start + meeting_duration <= dorothy_latest_end.\ncandidate_latest_start = dorothy_latest_end - meeting_duration\n\n# Search for the earliest valid meeting slot (in minute increments)\nproposed_start = None\nfor start in range(work_start, candidate_latest_start + 1):\n    end = start + meeting_duration\n    # Check if meeting fits within work hours (it does by design here)\n    # Check busy intervals for each participant.\n    if (is_slot_free(start, end, lisa_busy) and\n        is_slot_free(start, end, dorothy_busy) and\n        is_slot_free(start, end, raymond_busy)):\n        proposed_start = start\n        break\n\nif proposed_start is not None:\n    proposed_end = proposed_start + meeting_duration\n    # Format the output as HH:MM:HH:MM\n    result = f\"{minutes_to_time(proposed_start)}:{minutes_to_time(proposed_end)}\"\n    print(result)\nelse:\n    print(\"No available meeting slot found.\")\n'''",
            "count": "calendar_scheduling_example_60"
        },
        {
            "final_program_time": "{13:30:14:30}",
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_str(m):\n    hours = m // 60\n    minutes = m % 60\n    return f\"{hours:02d}:{minutes:02d}\"\n\n# Working day in minutes (start: 9:00, end: 17:00)\nwork_start = 9 * 60   # 540 minutes\nwork_end = 17 * 60    # 1020 minutes\n\n# Duration of the meeting in minutes (1 hour)\nduration = 60\n\n# Busy intervals for each participant in minutes\n# Robert is free all day so no intervals are needed.\n# Lisa's busy intervals: [9:30-10:00] and [11:30-12:00]\nlisa_busy = [(9 * 60 + 30, 10 * 60),\n             (11 * 60 + 30, 12 * 60)]\n# Patrick's busy intervals: [9:30-11:30], [12:30-13:30], [16:00-17:00]\npatrick_busy = [(9 * 60 + 30, 11 * 60 + 30),\n                (12 * 60 + 30, 13 * 60 + 30),\n                (16 * 60, 17 * 60)]\n\n# Combine busy intervals for Lisa and Patrick\nbusy_intervals = lisa_busy + patrick_busy\n\ndef has_conflict(start, end):\n    for b_start, b_end in busy_intervals:\n        # Check if the meeting interval [start, end] overlaps with busy interval [b_start, b_end]\n        if start < b_end and b_start < end:\n            return True\n    return False\n\nproposed_start = None\n\n# Iterate over each minute starting from work_start to the last possible start time inclusive\nfor t in range(work_start, work_end - duration + 1):\n    meeting_start = t\n    meeting_end = t + duration\n    if not has_conflict(meeting_start, meeting_end):\n        proposed_start = meeting_start\n        break\n\nif proposed_start is not None:\n    proposed_end = proposed_start + duration\n    # Format the time as {HH:MM:HH:MM}\n    output = f\"{{{minutes_to_str(proposed_start)}:{minutes_to_str(proposed_end)}}}\"\n    print(output)\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_61"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\ndef time_to_minutes(time_str):\n    \"\"\"Converts a time string 'HH:MM' to minutes since midnight.\"\"\"\n    h, m = map(int, time_str.split(':'))\n    return h * 60 + m\n\ndef minutes_to_time(minutes):\n    \"\"\"Converts minutes since midnight to a time string 'HH:MM'.\"\"\"\n    h = minutes // 60\n    m = minutes % 60\n    return f\"{h:02d}:{m:02d}\"\n\n# Define working hours and meeting duration in minutes\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nmeeting_duration = 60  # 1 hour meeting\n\n# Participant availabilities:\n# Abigail is free whole day, Michael is free whole day, so they are available from 09:00 to 17:00\nabigail_free = [(work_start, work_end)]\nmichael_free  = [(work_start, work_end)]\n\n# Sharon's busy times on Monday are 09:00-13:00 and 14:00-17:00.\n# Thus, her free time is the gap from 13:00 to 14:00.\nsharon_free = [(time_to_minutes(\"13:00\"), time_to_minutes(\"14:00\"))]\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Finds intersection between two lists of intervals.\"\"\"\n    intersections = []\n    i, j = 0, 0\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find overlap between intervals\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap < end_overlap:\n            intersections.append((start_overlap, end_overlap))\n        # Move the pointer with the earlier ending time\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersections\n\n# Intersect all participants' free intervals\ncommon_free = intersect_intervals(abigail_free, michael_free)\ncommon_free = intersect_intervals(common_free, sharon_free)\n\n# Find earliest slot that can accommodate the meeting duration.\nproposed_slot = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        proposed_slot = (start, start + meeting_duration)\n        break\n\nif proposed_slot:\n    start_str = minutes_to_time(proposed_slot[0])\n    end_str = minutes_to_time(proposed_slot[1])\n    # Output in the format {HH:MM:HH:MM} as required.\n    print(f\"{{{start_str}:{end_str}}}\")\nelse:\n    print(\"No available slot found.\")\n'''",
            "count": "calendar_scheduling_example_62"
        },
        {
            "final_program_time": "{16:00:17:00}",
            "expected_time": "{16:00:17:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    \"\"\"Convert time in HH:MM format to minutes since midnight.\"\"\"\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    \"\"\"Convert minutes since midnight to HH:MM format.\"\"\"\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef interval_overlaps(start_a, end_a, start_b, end_b):\n    \"\"\"Check if two half-open intervals [start, end) overlap.\"\"\"\n    return not (end_a <= start_b or start_a >= end_b)\n\ndef is_slot_free(slot_start, slot_end, busy):\n    \"\"\"Return True if the candidate slot does not overlap with any busy interval.\"\"\"\n    for b_start, b_end in busy:\n        # If the candidate slot overlaps any busy block, return False\n        if interval_overlaps(slot_start, slot_end, b_start, b_end):\n            return False\n    return True\n\n# Define work hours in minutes (9:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end   = time_to_minutes(\"17:00\")\n\n# Meeting duration in minutes (1 hour)\nmeeting_duration = 60\n\n# Busy intervals for each participant (times in minutes since midnight)\n# Madison is free all day, so no busy intervals.\nbusy_madison = []\n\n# Judith's busy intervals: 10:00-10:30, 11:00-12:00, 12:30-13:00\nbusy_judith = [\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\"))\n]\n\n# Roger's busy intervals: 9:00-9:30, 10:30-11:00, 12:00-12:30, 13:00-13:30, 14:00-16:00\nbusy_roger = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"16:00\"))\n]\n\n# Combine busy intervals for all participants\n# A slot is available if it is free for Judith and Roger (Madison is always free).\nbusy_all = [busy_judith, busy_roger]\n\ndef slot_is_free_for_all(slot_start, slot_end):\n    for busy in busy_all:\n        if not is_slot_free(slot_start, slot_end, busy):\n            return False\n    return True\n\n# Find the earliest available slot within work hours with the required duration\ncandidate_start = work_start\nproposed_slot = None\n\nwhile candidate_start <= work_end - meeting_duration:\n    candidate_end = candidate_start + meeting_duration\n    if slot_is_free_for_all(candidate_start, candidate_end):\n        proposed_slot = (candidate_start, candidate_end)\n        break\n    candidate_start += 1  # increment minute by minute\n\nif proposed_slot:\n    start_str = minutes_to_time(proposed_slot[0])\n    end_str = minutes_to_time(proposed_slot[1])\n    # Print in the format {HH:MM:HH:MM}\n    print(f\"{{{start_str}:{end_str}}}\")\nelse:\n    print(\"No available slot found.\")\n'''",
            "count": "calendar_scheduling_example_63"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    \"\"\"Convert HH:MM string to total minutes from midnight.\"\"\"\n    h, m = map(int, time_str.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(minutes):\n    \"\"\"Convert minutes from midnight to HH:MM format.\"\"\"\n    h = minutes // 60\n    m = minutes % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef get_free_intervals(work_start, work_end, busy_intervals):\n    \"\"\"\n    Given a list of busy intervals (as tuples of (start, end) in minutes)\n    and the overall work period (start and end in minutes),\n    produce a list of free intervals within the work hours.\n    \"\"\"\n    free_intervals = []\n    current = work_start\n    for start, end in sorted(busy_intervals):\n        if current < start:\n            free_intervals.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free_intervals.append((current, work_end))\n    return free_intervals\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Return the intersection of two lists of intervals.\"\"\"\n    result = []\n    i, j = 0, 0\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Calculate intersection\n        start = max(start1, start2)\n        end = min(end1, end2)\n        if start < end:\n            result.append((start, end))\n        # Move to the next interval in the list that ends first\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Define work hours (in minutes from midnight)\nwork_start = time_to_minutes(\"09:00\")  # 540 minutes\nwork_end = time_to_minutes(\"17:00\")    # 1020 minutes\n\n# Busy intervals for each participant (converted to minutes)\n# Nancy busy: 09:30-10:00 and 12:30-13:00\nnancy_busy = [(time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n              (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\"))]\n\n# Albert is free all day \u2013 no busy intervals\nalbert_busy = []\n\n# Nathan busy: 09:00-12:30, 13:00-14:30, 16:00-17:00\nnathan_busy = [(time_to_minutes(\"09:00\"), time_to_minutes(\"12:30\")),\n               (time_to_minutes(\"13:00\"), time_to_minutes(\"14:30\")),\n               (time_to_minutes(\"16:00\"), time_to_minutes(\"17:00\"))]\n\n# Calculate free intervals for each participant\nnancy_free = get_free_intervals(work_start, work_end, nancy_busy)\nalbert_free = get_free_intervals(work_start, work_end, albert_busy)\nnathan_free = get_free_intervals(work_start, work_end, nathan_busy)\n\n# Function to intersect free intervals across all participants\ndef intersect_all(intervals_list):\n    from functools import reduce\n    return reduce(intersect_intervals, intervals_list)\n\ncommon_free = intersect_all([nancy_free, albert_free, nathan_free])\n\n# Meeting duration in minutes (1 hour)\nmeeting_duration = 60\n\n# Find the earliest interval that can accommodate the meeting\nproposed_start = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        proposed_start = start\n        break\n\nif proposed_start is not None:\n    proposed_end = proposed_start + meeting_duration\n    # Format output as required: {HH:MM:HH:MM}\n    output = f\"{{{minutes_to_time(proposed_start)}:{minutes_to_time(proposed_end)}}}\"\n    print(output)\nelse:\n    print(\"No possible meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_64"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    \"\"\"Convert time string HH:MM to minutes since midnight.\"\"\"\n    hours, minutes = map(int, t.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(m):\n    \"\"\"Convert minutes since midnight to time string HH:MM.\"\"\"\n    hours = m // 60\n    minutes = m % 60\n    return f\"{hours:02d}:{minutes:02d}\"\n\ndef is_slot_free(start, end, busy_intervals):\n    \"\"\"Check if the time slot [start, end) (in minutes) is free (does not overlap with any busy intervals).\"\"\"\n    for b_start, b_end in busy_intervals:\n        # If the candidate overlaps with a busy interval, reject it.\n        if not (end <= b_start or start >= b_end):\n            return False\n    return True\n\n# Define workday start and end times in minutes (09:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end   = time_to_minutes(\"17:00\")\nmeeting_duration = 30  # in minutes\n\n# Busy intervals for each participant in minutes since midnight.\n# Each tuple is (start, end) - the interval during which the participant is busy.\n# John is busy: 12:30-13:00, 15:30-16:00\njohn_busy = [\n    (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\"))\n]\n\n# Andrea is busy: 09:00-09:30, 11:00-12:30, 15:00-15:30, 16:00-16:30\nandrea_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"12:30\")),\n    (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))\n]\n# Andrea cannot meet after 16:30, so meeting must end by or before 16:30.\nandrea_latest_end = time_to_minutes(\"16:30\")\n\n# Lisa is busy: 09:00-10:00, 10:30-11:00, 12:00-12:30, 14:00-15:30, 16:00-16:30\nlisa_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"15:30\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))\n]\n\n# Iterate over possible start times from work_start to the latest possible start\n# Note: Andrea's constraint means the meeting must end by 16:30.\nfor candidate_start in range(work_start, work_end - meeting_duration + 1):\n    candidate_end = candidate_start + meeting_duration\n    # Check Andrea's meeting latest constraint: meeting must end by 16:30.\n    if candidate_end > andrea_latest_end:\n        continue\n    if (is_slot_free(candidate_start, candidate_end, john_busy) and\n        is_slot_free(candidate_start, candidate_end, andrea_busy) and\n        is_slot_free(candidate_start, candidate_end, lisa_busy)):\n        start_str = minutes_to_time(candidate_start)\n        end_str = minutes_to_time(candidate_end)\n        print(f\"{start_str}:{end_str}\")\n        break\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_65"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\ndef time_to_minutes(time_str):\n    \"\"\"Convert HH:MM time string to minutes from midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    \"\"\"Convert minutes from midnight to HH:MM time string.\"\"\"\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Define workday start and end in minutes\nwork_start = time_to_minutes(\"09:00\")\nwork_end   = time_to_minutes(\"17:00\")\n\n# Meeting duration in minutes (1 hour)\nmeeting_duration = 60\n\n# Charles' busy intervals on Monday in HH:MM (start, end)\n# Note: Ronald and Maria are free so we only consider Charles\nbusy_times = [\n    (\"09:00\", \"10:30\"),\n    (\"11:00\", \"11:30\"),\n    (\"13:30\", \"14:00\"),\n    (\"14:30\", \"15:00\"),\n    (\"15:30\", \"16:30\")\n]\n\n# Convert busy times to minutes\nbusy_intervals = [(time_to_minutes(start), time_to_minutes(end)) for start, end in busy_times]\n\n# Sort busy intervals (if not already sorted)\nbusy_intervals.sort()\n\n# Build free intervals from work start to work end excluding busy periods\nfree_intervals = []\ncurrent_start = work_start\n\nfor busy_start, busy_end in busy_intervals:\n    if busy_start > current_start:\n        free_intervals.append((current_start, busy_start))\n    # Update current start to the later of current_start or busy_end (if overlapping)\n    current_start = max(current_start, busy_end)\n\n# Append the last free interval if any exists between end of the last busy interval and work_end\nif current_start < work_end:\n    free_intervals.append((current_start, work_end))\n\n# Find the earliest free interval that can accommodate the meeting_duration\nproposed_start = None\nproposed_end = None\n\nfor free_start, free_end in free_intervals:\n    if free_end - free_start >= meeting_duration:\n        proposed_start = free_start\n        proposed_end = free_start + meeting_duration\n        break\n\nif proposed_start is not None and proposed_end is not None:\n    # Format result as {HH:MM:HH:MM}\n    start_str = minutes_to_time(proposed_start)\n    end_str = minutes_to_time(proposed_end)\n    print(f\"{{{start_str}:{end_str}}}\")\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_66"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    # t in \"HH:MM\" format, returns minutes since midnight\n    hours, minutes = map(int, t.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(m):\n    hours = m // 60\n    minutes = m % 60\n    return f\"{hours:02d}:{minutes:02d}\"\n\ndef intersect_intervals(intervals_a, intervals_b):\n    i, j = 0, 0\n    result = []\n    while i < len(intervals_a) and j < len(intervals_b):\n        start_a, end_a = intervals_a[i]\n        start_b, end_b = intervals_b[j]\n        start = max(start_a, start_b)\n        end = min(end_a, end_b)\n        if start < end:\n            result.append((start, end))\n        if end_a < end_b:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Define working day bounds (in minutes)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\n\n# Define busy intervals for each participant (in minutes)\n# Jacqueline: busy 13:00-13:30, 16:00-16:30\njac_busy = [(time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n            (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))]\n\n# Christian: free all day, so no busy intervals needed.\nchr_busy = []\n\n# Linda: busy 9:00-10:30, 11:30-12:30, 14:00-14:30, 15:30-16:30.\nlinda_busy = [(time_to_minutes(\"09:00\"), time_to_minutes(\"10:30\")),\n              (time_to_minutes(\"11:30\"), time_to_minutes(\"12:30\")),\n              (time_to_minutes(\"14:00\"), time_to_minutes(\"14:30\")),\n              (time_to_minutes(\"15:30\"), time_to_minutes(\"16:30\"))]\n\n# Additionally, Linda cannot meet after 14:00,\n# so we restrict her free time to end at 14:00.\nlinda_limit = time_to_minutes(\"14:00\")\n\ndef get_free_intervals(busy_intervals, work_start, work_end):\n    free = []\n    current_start = work_start\n    # sort busy intervals (if not already in order)\n    for b_start, b_end in sorted(busy_intervals):\n        if current_start < b_start:\n            free.append((current_start, b_start))\n        current_start = max(current_start, b_end)\n    if current_start < work_end:\n        free.append((current_start, work_end))\n    return free\n\n# Get free intervals for each participant\njac_free = get_free_intervals(jac_busy, work_start, work_end)\nchr_free = [(work_start, work_end)]  # Christian is free all day.\nlinda_free = get_free_intervals(linda_busy, work_start, work_end)\n# Apply Linda's constraint: meeting must end by 14:00, so adjust her free intervals:\nadjusted_linda_free = []\nfor start, end in linda_free:\n    if start < linda_limit:\n        adjusted_linda_free.append((start, min(end, linda_limit)))\nlinda_free = adjusted_linda_free\n\n# Intersect free intervals of all participants\ntemp = intersect_intervals(jac_free, chr_free)\ncommon_free = intersect_intervals(temp, linda_free)\n\n# Find the earliest available slot of required duration.\nmeeting_start = None\nfor start, end in common_free:\n    if end - start >= duration:\n        meeting_start = start\n        break\n\nif meeting_start is not None:\n    meeting_end = meeting_start + duration\n    # Format output as HH:MM:HH:MM\n    output = f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    print(output)\nelse:\n    print(\"No available meeting slot found.\")\n'''",
            "count": "calendar_scheduling_example_67"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    # Convert \"HH:MM\" to minutes since midnight.\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    # Convert minutes since midnight to \"HH:MM\"\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef compute_free_intervals(working_start, working_end, busy_intervals):\n    free = []\n    # Sort busy intervals by start time\n    busy_intervals.sort(key=lambda x: x[0])\n    current = working_start\n    for start, end in busy_intervals:\n        if start > current:\n            free.append((current, start))\n        current = max(current, end)\n    if current < working_end:\n        free.append((current, working_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    # Given two lists of intervals, return their intersection intervals.\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        a_start, a_end = intervals1[i]\n        b_start, b_end = intervals2[j]\n        # Find the intersection:\n        start = max(a_start, b_start)\n        end = min(a_end, b_end)\n        if start < end:\n            result.append((start, end))\n        # Move to the next interval in the list that ends first.\n        if a_end <= b_end:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Meeting parameters\nmeeting_duration = 30  # minutes\nworking_start = time_to_minutes(\"09:00\")\nworking_end   = time_to_minutes(\"17:00\")\n\n# Busy schedules (in \"HH:MM\" format)\n# Michael's busy intervals\nmichael_busy_str = [(\"10:00\", \"10:30\"), (\"11:30\", \"12:00\"), (\"13:30\", \"14:00\"), (\"15:30\", \"16:00\")]\nmichael_busy = [(time_to_minutes(start), time_to_minutes(end)) for start, end in michael_busy_str]\n\n# Bryan's schedule: wide open; no busy intervals\nbryan_busy = []\n\n# Lauren's busy intervals\nlauren_busy_str = [(\"09:00\", \"10:30\"), (\"14:30\", \"17:00\")]\nlauren_busy = [(time_to_minutes(start), time_to_minutes(end)) for start, end in lauren_busy_str]\n\n# Compute free intervals for each person\nmichael_free = compute_free_intervals(working_start, working_end, michael_busy)\nbryan_free = compute_free_intervals(working_start, working_end, bryan_busy)\nlauren_free = compute_free_intervals(working_start, working_end, lauren_busy)\n\n# Compute the intersection of free intervals among all participants\n# First intersect Michael and Bryan, then intersect with Lauren.\nintersection = intersect_intervals(michael_free, bryan_free)\nintersection = intersect_intervals(intersection, lauren_free)\n\n# Find earliest interval that can fit the meeting duration\nproposed_start = None\nfor start, end in intersection:\n    if end - start >= meeting_duration:\n        proposed_start = start\n        break\n\nif proposed_start is not None:\n    proposed_end = proposed_start + meeting_duration\n    result = f\"{minutes_to_time(proposed_start)}:{minutes_to_time(proposed_end)}\"\n    print(result)\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_68"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{10:00:11:00}",
            "type_error": null,
            "full_response": "'''python\ndef minutes(time_str):\n    \"\"\"Convert time string 'HH:MM' to minutes since midnight.\"\"\"\n    h, m = map(int, time_str.split(\":\"))\n    return h * 60 + m\n\ndef time_str(minutes_val):\n    \"\"\"Convert minutes since midnight to time string 'HH:MM'.\"\"\"\n    h = minutes_val // 60\n    m = minutes_val % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef subtract_busy(free_interval, busy):\n    \"\"\"\n    Subtract a busy interval from a free interval.\n    free_interval and busy are tuples (start, end) in minutes.\n    Returns list of resulting free intervals (may be empty or split).\n    \"\"\"\n    free_start, free_end = free_interval\n    busy_start, busy_end = busy\n\n    # no overlap\n    if busy_end <= free_start or busy_start >= free_end:\n        return [free_interval]\n\n    intervals = []\n    # interval before the busy block\n    if busy_start > free_start:\n        intervals.append((free_start, busy_start))\n    # interval after the busy block\n    if busy_end < free_end:\n        intervals.append((busy_end, free_end))\n    return intervals\n\ndef get_free_intervals(workday, busy_list):\n    \"\"\"\n    Given a workday interval and a list of busy intervals, return list of free intervals.\n    Intervals are tuples (start, end) in minutes.\n    \"\"\"\n    free_intervals = [workday]\n    for busy in sorted(busy_list):\n        new_free = []\n        for interval in free_intervals:\n            new_free.extend(subtract_busy(interval, busy))\n        free_intervals = new_free\n    return free_intervals\n\ndef intersect_intervals(list1, list2):\n    \"\"\"\n    Given two lists of intervals, return the intersection intervals.\n    Each interval is (start, end) in minutes.\n    \"\"\"\n    i, j = 0, 0\n    intersections = []\n    while i < len(list1) and j < len(list2):\n        a_start, a_end = list1[i]\n        b_start, b_end = list2[j]\n        # Find the intersection between intervals a and b\n        start = max(a_start, b_start)\n        end = min(a_end, b_end)\n        if start < end:\n            intersections.append((start, end))\n        # Move to the next interval\n        if a_end < b_end:\n            i += 1\n        else:\n            j += 1\n    return intersections\n\ndef find_meeting_time(participants_busy, meeting_duration, workday):\n    \"\"\"\n    Given a dictionary of participants with their busy intervals (in HH:MM strings),\n    meeting duration (in minutes), and the workday interval (tuple of HH:MM strings),\n    find the earliest meeting time that works for everyone.\n    Returns a tuple (start, end) as strings in HH:MM format.\n    \"\"\"\n    # Convert workday to minutes\n    work_start = minutes(workday[0])\n    work_end = minutes(workday[1])\n    work_interval = (work_start, work_end)\n    \n    common_free = [work_interval]\n    \n    # Process each participant's busy schedule\n    for busy_times in participants_busy.values():\n        # Convert busy times to minutes intervals\n        busy_intervals = [(minutes(start), minutes(end)) for start, end in busy_times]\n        # Get the participant's free intervals by subtracting busy intervals from workday\n        person_free = get_free_intervals(work_interval, busy_intervals)\n        # Intersect with running common free intervals\n        common_free = intersect_intervals(common_free, person_free)\n        if not common_free:\n            # No common free interval found\n            return None\n\n    # Find the earliest common free interval that is at least meeting_duration long\n    for start, end in common_free:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = start + meeting_duration\n            return time_str(meeting_start), time_str(meeting_end)\n    return None\n\n# Define workday and meeting duration (in minutes)\nworkday = (\"09:00\", \"17:00\")\nmeeting_duration = 60  # one hour\n\n# Define busy schedules for each participant (busy intervals as (start, end))\nparticipants_busy = {\n    \"Shirley\": [(\"11:00\", \"11:30\"), (\"14:00\", \"15:00\"), (\"16:00\", \"16:30\")],\n    \"Stephen\": [(\"13:00\", \"13:30\"), (\"15:30\", \"16:00\")],\n    \"Paul\": [(\"09:00\", \"10:00\"), (\"11:00\", \"17:00\")]\n}\n\nresult = find_meeting_time(participants_busy, meeting_duration, workday)\nif result:\n    meeting_start, meeting_end = result\n    # Output the result in the specified format: {HH:MM:HH:MM}\n    print(f\"{{{meeting_start}:{meeting_end}}}\")\nelse:\n    print(\"No available meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_69"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_time_str(minutes):\n    hours = 9 + minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\ndef is_free(slot_start, slot_end, free_intervals):\n    # Check if the time slot [slot_start, slot_end) is fully contained in any free interval.\n    for start, end in free_intervals:\n        if slot_start >= start and slot_end <= end:\n            return True\n    return False\n\n# Define meeting duration in minutes\nmeeting_duration = 30\n\n# Work hours are from 9:00 (0 minutes) to 17:00 (480 minutes)\nwork_start = 0\nwork_end = 480\n\n# Define free intervals for each participant in minutes offset from 9:00.\n# Denise is busy 12:00-12:30 and 15:30-16:00.\n# Work starts at 9:00 (0 minutes) and ends at 17:00 (480 minutes).\ndenise_free = [(0, 180),    # 9:00 to 12:00\n               (210, 390),  # 12:30 to 15:30\n               (420, 480)]  # 16:00 to 17:00\n\n# Angela has no meetings.\nangela_free = [(0, 480)]   # free whole day\n\n# Natalie is busy 9:00-11:30, 12:00-13:00, 14:00-14:30, 15:00-17:00.\nnatalie_free = [(150, 180),  # 11:30 to 12:00\n                (240, 300),  # 13:00 to 14:00\n                (330, 360)]  # 14:30 to 15:00\n\nparticipants_free = [denise_free, angela_free, natalie_free]\n\nearliest_start = None\n\n# Iterate through the day in minute increments to find the earliest time slot that fits\nfor t in range(work_start, work_end - meeting_duration + 1):\n    slot_start = t\n    slot_end = t + meeting_duration\n    if all(is_free(slot_start, slot_end, free) for free in participants_free):\n        earliest_start = slot_start\n        break\n\nif earliest_start is not None:\n    start_str = minutes_to_time_str(earliest_start)\n    end_str = minutes_to_time_str(earliest_start + meeting_duration)\n    # Output in the required format: {HH:MM:HH:MM}\n    print(f\"{{{start_str}:{end_str}}}\")\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_70"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    \"\"\"Convert HH:MM time string to minutes since midnight.\"\"\"\n    hours, minutes = map(int, t.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(m):\n    \"\"\"Convert minutes since midnight to HH:MM time string.\"\"\"\n    return f\"{m//60:02d}:{m%60:02d}\"\n\ndef intersect(interval1, interval2):\n    \"\"\"Return the intersection of two intervals.\n       Each interval is a tuple (start, end) in minutes.\n       Returns (start, end) of the intersection or None if no intersection exists.\n    \"\"\"\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start < end:\n        return (start, end)\n    else:\n        return None\n\n# Meeting parameters\nmeeting_duration = 30  # in minutes\n\n# Work hours and additional constraints:\n# Work hours overall: 09:00 to 17:00\nwork_interval = (time_to_minutes(\"09:00\"), time_to_minutes(\"17:00\"))\n\n# Participant's available times:\n# Nicole: free the entire day (work hours)\nnicole_free = work_interval\n\n# John:\n# Blocked times: 12:30-13:00, 16:30-17:00\n# And prefers not to meet after 12:00, so we restrict his available time to 09:00 to 12:00.\njohn_free = (time_to_minutes(\"09:00\"), time_to_minutes(\"12:00\"))\n\n# Ethan:\n# Blocked times: 09:00-10:00, 11:30-14:00, 14:30-17:00.\n# Therefore Ethan's free time during work hours is in two parts. \n# However, given John's constraint (ending by 12:00), we only need the intersection before 12:00.\n# Ethan's free window before 12:00 is 10:00-11:30.\nethan_free = (time_to_minutes(\"10:00\"), time_to_minutes(\"11:30\"))\n\n# Calculate overall intersection:\n# Since Nicole is free all day, we start with work hours,\n# then intersect with John's and Ethan's free intervals.\ncommon_interval = intersect(nicole_free, john_free)\ncommon_interval = intersect(common_interval, ethan_free)\n\n# Find the earliest meeting start time within the common interval that allows a full meeting_duration.\nif common_interval:\n    start_available, end_available = common_interval\n    # The meeting must finish by end_available:\n    if start_available + meeting_duration <= end_available:\n        meeting_start = start_available\n        meeting_end = meeting_start + meeting_duration\n        result = f\"{{{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}}}\"\n        print(result)\n    else:\n        print(\"No available time slot meets the meeting duration requirement.\")\nelse:\n    print(\"No common free interval found.\")\n'''",
            "count": "calendar_scheduling_example_71"
        },
        {
            "final_program_time": "{13:30:14:30}",
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    # Converts \"HH:MM\" to minutes since midnight.\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    # Converts minutes since midnight to \"HH:MM\" format.\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\ndef get_free_intervals(busy_intervals, work_start, work_end):\n    # Given a list of busy intervals (each a tuple (start, end) in minutes),\n    # return a list of available (free) intervals within the work period.\n    free = []\n    current_start = work_start\n    # Sort busy intervals by start time.\n    busy_intervals.sort(key=lambda x: x[0])\n    for start, end in busy_intervals:\n        if start > current_start:\n            free.append((current_start, start))\n        current_start = max(current_start, end)\n    if current_start < work_end:\n        free.append((current_start, work_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    # Intersect two lists of intervals.\n    result = []\n    i, j = 0, 0\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find overlap between these intervals\n        overlap_start = max(start1, start2)\n        overlap_end = min(end1, end2)\n        if overlap_start < overlap_end:\n            result.append((overlap_start, overlap_end))\n        # Move pointer that has the earlier ending interval.\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef intersect_all(intervals_list):\n    # Intersect a list of interval lists\n    if not intervals_list:\n        return []\n    intersection = intervals_list[0]\n    for intervals in intervals_list[1:]:\n        intersection = intersect_intervals(intersection, intervals)\n    return intersection\n\n# Define work day times\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Meeting duration in minutes (1 hour)\nmeeting_duration = 60\n\n# Busy intervals for each participant (in \"HH:MM\" format)\n# Mason has no meetings.\nmason_busy = []\n\n# Amy's busy intervals: 09:30-11:30, 13:00-13:30, 16:30-17:00\namy_busy = [\n    (time_to_minutes(\"09:30\"), time_to_minutes(\"11:30\")),\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n    (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))\n]\n\n# Christopher's busy intervals: 09:00-10:00, 12:00-13:30, 14:30-15:00, 15:30-16:30\nchristopher_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"13:30\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"16:30\"))\n]\n\n# Calculate free intervals for each participant\nmason_free = get_free_intervals(mason_busy, work_start, work_end)\namy_free = get_free_intervals(amy_busy, work_start, work_end)\nchristopher_free = get_free_intervals(christopher_busy, work_start, work_end)\n\n# Find common free intervals\ncommon_free = intersect_all([mason_free, amy_free, christopher_free])\n\n# Find the earliest interval that can accommodate the meeting duration.\nproposed_meeting = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        proposed_meeting = (start, start + meeting_duration)\n        break\n\nif proposed_meeting:\n    start_time = minutes_to_time(proposed_meeting[0])\n    end_time = minutes_to_time(proposed_meeting[1])\n    print(f\"{{{start_time}:{end_time}}}\")\nelse:\n    print(\"No available time slot meets the requirements.\")\n'''",
            "count": "calendar_scheduling_example_72"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_HHMM(m):\n    hh = m // 60\n    mm = m % 60\n    return f\"{hh:02d}:{mm:02d}\"\n\n# Define workday start and end in minutes (from midnight)\nwork_start = 9 * 60    # 9:00 => 540 minutes\nwork_end   = 17 * 60   # 17:00 => 1020 minutes\nmeeting_duration = 30  # meeting duration in minutes\n\n# Busy intervals for each participant (start, end in minutes)\n# Bradley: 09:30-10:00, 13:00-13:30, 14:30-15:00, 16:30-17:00\nbradley_busy = [(9*60+30, 10*60), (13*60, 13*60+30), (14*60+30, 15*60), (16*60+30, 17*60)]\n# Andrew: 09:00-09:30, 12:30-13:30, 14:00-14:30, 15:00-16:00\nandrew_busy = [(9*60, 9*60+30), (12*60+30, 13*60+30), (14*60, 14*60+30), (15*60, 16*60)]\n# Melissa: 09:00-09:30, 10:00-10:30, 11:00-14:00, 15:00-15:30, 16:00-16:30\nmelissa_busy = [(9*60, 9*60+30), (10*60, 10*60+30), (11*60, 14*60), (15*60, 15*60+30), (16*60, 16*60+30)]\n\n# Combine busy intervals in a dictionary for easier iteration\nparticipants_busy = [bradley_busy, andrew_busy, melissa_busy]\n\ndef is_free(start, busy_intervals):\n    \"\"\"Return True if the interval [start, start+meeting_duration) \n       does not overlap any busy interval in the list.\"\"\"\n    end = start + meeting_duration\n    for b_start, b_end in busy_intervals:\n        # Check if intervals overlap:\n        if not (end <= b_start or start >= b_end):\n            return False\n    return True\n\n# Iterate over each minute in the work day to find earliest slot\nproposed_time = None\nfor t in range(work_start, work_end - meeting_duration + 1):\n    # Check for every participant whether they are free for the meeting duration\n    if all(is_free(t, busy) for busy in participants_busy):\n        proposed_time = (t, t + meeting_duration)\n        break\n\nif proposed_time:\n    start_str = minutes_to_HHMM(proposed_time[0])\n    end_str = minutes_to_HHMM(proposed_time[1])\n    # Output in required format {HH:MM:HH:MM}\n    print(f\"{{{start_str}:{end_str}}}\")\nelse:\n    print(\"No common available slot found.\")\n'''",
            "count": "calendar_scheduling_example_73"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import timedelta, datetime\n\ndef minutes_to_time_str(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\ndef subtract_busy(free_interval, busy_intervals):\n    \"\"\"Subtract busy intervals from a free interval.\n       free_interval is a tuple (start, end); busy_intervals is a list of (start, end) tuples.\n       Returns a list of resulting free intervals.\n    \"\"\"\n    result = []\n    current_start, current_end = free_interval\n    # Sort busy intervals by start time\n    busy_intervals = sorted(busy_intervals, key=lambda x: x[0])\n    for b_start, b_end in busy_intervals:\n        # No overlap\n        if b_end <= current_start or b_start >= current_end:\n            continue\n        # If busy interval starts after current_start, add free time before busy\n        if b_start > current_start:\n            result.append((current_start, b_start))\n        # Move current_start forward\n        current_start = max(current_start, b_end)\n        if current_start >= current_end:\n            break\n    if current_start < current_end:\n        result.append((current_start, current_end))\n    return result\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Intersect two lists of intervals.\"\"\"\n    result = []\n    i, j = 0, 0\n    while i < len(intervals1) and j < len(intervals2):\n        a_start, a_end = intervals1[i]\n        b_start, b_end = intervals2[j]\n        # Find overlap\n        start = max(a_start, b_start)\n        end = min(a_end, b_end)\n        if start < end:\n            result.append((start, end))\n        # Move pointer with smaller end\n        if a_end < b_end:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Define working hours (in minutes). Monday: 9:00 is 9*60 = 540, 17:00 is 1020.\nwork_start = 540\nwork_end = 1020\n\n# Meeting duration in minutes\nmeeting_length = 60\n\n# Constraint: Eric does not want to meet after 15:30, so meeting end must be <= 15:30 (15*60+30 = 930)\nlatest_end = 930\n\n# Busy intervals for each participant (in minutes from midnight)\n# Eric: 10:00 to 12:00 => (600, 720)\neric_busy = [(600, 720)]\n# His free intervals must be capped to end by latest_end if after 12:00.\neric_initial_free = subtract_busy((work_start, work_end), eric_busy)\neric_free = []\nfor start, end in eric_initial_free:\n    # Adjust free interval if it goes beyond the latest allowed end\n    if start < latest_end:\n        eric_free.append((start, min(end, latest_end)))\n\n# Albert: busy 12:00 to 12:30 => (720,750), and 15:30 to 16:00 => (930,960)\nalbert_busy = [(720, 750), (930, 960)]\nalbert_free = subtract_busy((work_start, work_end), albert_busy)\n# No additional constraint for Albert.\n\n# Katherine: busy 10:00 to 11:00 => (600,660), 11:30 to 14:00 => (690,840), 15:00 to 15:30 => (900,930)\nkatherine_busy = [(600, 660), (690, 840), (900, 930)]\nkatherine_free = subtract_busy((work_start, work_end), katherine_busy)\n# Again, meeting must end by 15:30 due to Eric, so we filter intervals exceeding that.\nkatherine_free = [(start, min(end, latest_end)) for start, end in katherine_free if start < latest_end]\n\n# Now, intersect free intervals across Eric, Albert, and Katherine\ndef intersect_all(intervals_list):\n    if not intervals_list:\n        return []\n    current = intervals_list[0]\n    for intervals in intervals_list[1:]:\n        current = intersect_intervals(current, intervals)\n    return current\n\nall_free = intersect_all([eric_free, albert_free, katherine_free])\n\n# Find the earliest interval that can accommodate the meeting duration.\nproposed_slot = None\nfor start, end in all_free:\n    if end - start >= meeting_length:\n        proposed_slot = (start, start + meeting_length)\n        break\n\nif proposed_slot:\n    start_str = minutes_to_time_str(proposed_slot[0])\n    end_str = minutes_to_time_str(proposed_slot[1])\n    # Output in the format {HH:MM:HH:MM}\n    print(f\"{{{start_str}:{end_str}}}\")\nelse:\n    print(\"No available meeting slot found.\")\n'''",
            "count": "calendar_scheduling_example_74"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    # Convert \"HH:MM\" to minutes from midnight.\n    h, m = map(int, time_str.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(minutes):\n    # Convert minutes from midnight into \"HH:MM\" format.\n    h = minutes // 60\n    m = minutes % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef get_free_intervals(busy_intervals, work_start, work_end):\n    # busy_intervals: list of tuples (start, end) in minutes.\n    # Returns free intervals within working hours.\n    free = []\n    current = work_start\n    for b_start, b_end in sorted(busy_intervals):\n        if current < b_start:\n            free.append((current, b_start))\n        current = max(current, b_end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_intervals(list1, list2):\n    # returns the intersection of two lists of intervals.\n    i, j = 0, 0\n    intersection = []\n    while i < len(list1) and j < len(list2):\n        start = max(list1[i][0], list2[j][0])\n        end = min(list1[i][1], list2[j][1])\n        if start < end:\n            intersection.append((start, end))\n        if list1[i][1] < list2[j][1]:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\ndef intersect_free_intervals(free_lists):\n    # Intersect a list of free intervals lists.\n    if not free_lists:\n        return []\n    intersection = free_lists[0]\n    for free in free_lists[1:]:\n        intersection = intersect_intervals(intersection, free)\n    return intersection\n\n# Meeting parameters\nmeeting_duration = 60  # in minutes\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Busy intervals for each participant in minutes from midnight\n# Jacob busy times: 9:00-9:30, 12:30-13:00, 14:30-15:00, 16:30-17:00\njacob_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))\n]\n\n# Amanda busy times: 10:00-10:30, 12:00-12:30\namanda_busy = [\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\"))\n]\n\n# Lisa busy times: 11:00-13:00, 14:30-16:30\nlisa_busy = [\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"16:30\"))\n]\n\n# Get free intervals for each participant within working hours\njacob_free = get_free_intervals(jacob_busy, work_start, work_end)\namanda_free = get_free_intervals(amanda_busy, work_start, work_end)\nlisa_free = get_free_intervals(lisa_busy, work_start, work_end)\n\n# Compute common free intervals\ncommon_free = intersect_free_intervals([jacob_free, amanda_free, lisa_free])\n\n# Find earliest interval that can accommodate the meeting duration\nproposed_start, proposed_end = None, None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        proposed_start = start\n        proposed_end = start + meeting_duration\n        break\n\nif proposed_start is not None:\n    # Format output as HH:MM:HH:MM enclosed in braces.\n    output = \"{\" + f\"{minutes_to_time(proposed_start)}:{minutes_to_time(proposed_end)}\" + \"}\"\n    print(output)\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_75"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import timedelta, datetime\n\n# Helper function to convert HH:MM string to minutes from midnight.\ndef time_to_minutes(t):\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\n# Helper function to convert minutes from midnight to HH:MM string.\ndef minutes_to_time(m):\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\n# Function that, given a list of busy intervals and the overall working time,\n# returns a list of free intervals.\ndef get_free_intervals(busy, work_start, work_end):\n    free_intervals = []\n    # Sort the busy intervals by start time.\n    busy = sorted(busy, key=lambda x: x[0])\n    \n    # Start with the period before the first busy interval.\n    if work_start < busy[0][0]:\n        free_intervals.append((work_start, busy[0][0]))\n    \n    # Find gaps between busy intervals.\n    for i in range(len(busy) - 1):\n        end_current = busy[i][1]\n        start_next = busy[i + 1][0]\n        if end_current < start_next:\n            free_intervals.append((end_current, start_next))\n    \n    # Last gap after the last busy interval.\n    if busy[-1][1] < work_end:\n        free_intervals.append((busy[-1][1], work_end))\n    \n    return free_intervals\n\n# Function to get the intersection of two lists of intervals.\ndef intersect_intervals(intervals_a, intervals_b):\n    i, j = 0, 0\n    intersections = []\n    while i < len(intervals_a) and j < len(intervals_b):\n        # Find the intersection between intervals_a[i] and intervals_b[j]\n        start = max(intervals_a[i][0], intervals_b[j][0])\n        end = min(intervals_a[i][1], intervals_b[j][1])\n        if start < end:\n            intersections.append((start, end))\n        # Move to the next interval in the list which finishes earlier.\n        if intervals_a[i][1] < intervals_b[j][1]:\n            i += 1\n        else:\n            j += 1\n    return intersections\n\n# Define work hours (in minutes from midnight).\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Meeting duration: 60 minutes.\nmeeting_duration = 60\n\n# Busy schedules for the participants (in minutes since midnight)\n# Joyce has an open calendar, so no busy intervals.\njoyce_busy = []\n\n# Beverly's busy intervals\n# 9:30-10:00, 11:00-11:30, 12:30-13:00, 14:00-14:30, 15:30-16:00, 16:30-17:00\nbeverly_busy = [\n    (time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"11:30\")),\n    (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"14:30\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\")),\n    (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))\n]\n\n# Peter's busy intervals\n# 9:30-10:30, 11:30-13:00, 14:30-15:30, 16:30-17:00\npeter_busy = [\n    (time_to_minutes(\"09:30\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"15:30\")),\n    (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))\n]\n\n# Calculate free intervals for each participant.\n# For Joyce, the free interval is the whole work day.\njoyce_free = [(work_start, work_end)]\nbeverly_free = get_free_intervals(beverly_busy, work_start, work_end)\npeter_free   = get_free_intervals(peter_busy, work_start, work_end)\n\n# Get the intersection of free times for Beverly and Peter.\nfree_intersection = intersect_intervals(beverly_free, peter_free)\n# Then, include Joyce (who is free all day) so the intersection remains the same.\n# Find the earliest free slot that can accommodate the meeting duration.\nproposed_time = None\nfor start, end in free_intersection:\n    if end - start >= meeting_duration:\n        proposed_time = (start, start + meeting_duration)\n        break\n\nif proposed_time:\n    start_str = minutes_to_time(proposed_time[0])\n    end_str = minutes_to_time(proposed_time[1])\n    # Output in the format {HH:MM:HH:MM}\n    print(f\"{{{start_str}:{end_str}}}\")\nelse:\n    print(\"No available slot found.\")\n'''",
            "count": "calendar_scheduling_example_76"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "'''python\ndef to_minutes(time_str):\n    \"\"\"Convert HH:MM string to minutes since midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef to_time_str(minutes):\n    \"\"\"Convert minutes since midnight to HH:MM string with leading zeros.\"\"\"\n    return f\"{minutes//60:02d}:{minutes%60:02d}\"\n\ndef invert_intervals(busy, start, end):\n    \"\"\"Given a list of busy intervals [ (s,e), ... ] in minutes and a boundary (start, end),\n       return a list of free intervals within [start, end].\"\"\"\n    free = []\n    current = start\n    for bstart, bend in sorted(busy):\n        if bstart > current:\n            free.append((current, bstart))\n        current = max(current, bend)\n    if current < end:\n        free.append((current, end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Intersect two lists of intervals and return their intersection.\"\"\"\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        inter_start = max(start1, start2)\n        inter_end = min(end1, end2)\n        if inter_start < inter_end:\n            result.append((inter_start, inter_end))\n        # Move to next interval in the list which ends earlier\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef find_meeting_slot(free_intervals, duration):\n    \"\"\"Find earliest free interval of given duration (in minutes).\"\"\"\n    for start, end in free_intervals:\n        if end - start >= duration:\n            return (start, start + duration)\n    return None\n\n# Define working hours (Monday 9:00 to 17:00) in minutes.\nwork_start = to_minutes(\"09:00\")\nwork_end   = to_minutes(\"17:00\")\n\n# However, Donald does not want to meet after 12:00.\ndonald_latest = to_minutes(\"12:00\")\n# So for Donald, restrict meeting search to [work_start, donald_latest]\nmeeting_window = (work_start, donald_latest)\n\n# Define each participant's busy intervals in minutes.\n# Donald's busy intervals on Monday:\ndonald_busy = [\n    (to_minutes(\"10:00\"), to_minutes(\"10:30\")),\n    (to_minutes(\"11:00\"), to_minutes(\"11:30\")),\n    (to_minutes(\"12:00\"), to_minutes(\"12:30\")),\n    (to_minutes(\"13:00\"), to_minutes(\"13:30\")),\n    (to_minutes(\"15:30\"), to_minutes(\"16:30\"))\n]\n# Joyce's busy intervals on Monday:\njoyce_busy = [\n    (to_minutes(\"11:00\"), to_minutes(\"13:00\")),\n    (to_minutes(\"14:30\"), to_minutes(\"15:00\")),\n    (to_minutes(\"16:00\"), to_minutes(\"16:30\"))\n]\n# Abigail's busy intervals on Monday:\nabigail_busy = [\n    (to_minutes(\"09:30\"), to_minutes(\"10:00\")),\n    (to_minutes(\"11:30\"), to_minutes(\"12:00\")),\n    (to_minutes(\"13:00\"), to_minutes(\"14:00\")),\n    (to_minutes(\"15:00\"), to_minutes(\"17:00\"))\n]\n\n# Prepare free intervals for each participant, restricted to the meeting window.\ndonald_free = invert_intervals(donald_busy, meeting_window[0], meeting_window[1])\njoyce_free = invert_intervals(joyce_busy, work_start, work_end)  # Full day for Joyce\nabigail_free = invert_intervals(abigail_busy, work_start, work_end)  # Full day for Abigail\n\n# Since Donald does not want meetings after 12:00, we further restrict the overall intersection to meeting_window.\n# Intersect Joyce and Abigail free intervals first.\ncommon_free = intersect_intervals(joyce_free, abigail_free)\n# Restrict common_free to Donald's meeting window.\ncommon_free = intersect_intervals(common_free, [meeting_window])\n# Finally, intersect with Donald's free intervals.\ncommon_free = intersect_intervals(common_free, donald_free)\n\n# Meeting duration is 30 minutes.\nmeeting_duration = 30\n\nslot = find_meeting_slot(common_free, meeting_duration)\nif slot:\n    start_time, end_time = slot\n    # Format the output as HH:MM:HH:MM, e.g. {09:00:09:30}\n    output = f\"{{{to_time_str(start_time)}:{to_time_str(end_time)}}}\"\n    print(output)\nelse:\n    print(\"No common time slot available.\")\n'''",
            "count": "calendar_scheduling_example_77"
        },
        {
            "final_program_time": "{12:30:13:30}",
            "expected_time": "{12:30:13:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    \"\"\"Converts a time string 'HH:MM' to minutes since midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(':'))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    \"\"\"Converts minutes since midnight to time string 'HH:MM'.\"\"\"\n    return f\"{minutes//60:02d}:{minutes%60:02d}\"\n\ndef invert_busy(busy_intervals, work_start, work_end):\n    \"\"\"\n    Given a list of busy intervals and work hours,\n    returns a list of free intervals.\n    Each interval is a tuple (start, end) in minutes.\n    Assumes busy_intervals are sorted and non-overlapping.\n    \"\"\"\n    free = []\n    # Add free time before the first busy slot if any\n    if busy_intervals[0][0] > work_start:\n        free.append((work_start, busy_intervals[0][0]))\n    # Add free time between busy intervals\n    for i in range(len(busy_intervals) - 1):\n        end_current = busy_intervals[i][1]\n        start_next = busy_intervals[i+1][0]\n        if start_next > end_current:\n            free.append((end_current, start_next))\n    # Add free time after the last busy slot if any\n    if busy_intervals[-1][1] < work_end:\n        free.append((busy_intervals[-1][1], work_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Intersects two lists of intervals.\"\"\"\n    i, j = 0, 0\n    intersection = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find the overlap between intervals\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap < end_overlap:  # valid intersection\n            intersection.append((start_overlap, end_overlap))\n        # Move to next interval\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\n# Work hours on Monday: 9:00 to 17:00\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Busy intervals for each participant (in minutes)\n# Ronald: busy 9:00-10:00, 11:00-12:00\nronald_busy = [(time_to_minutes(\"09:00\"), time_to_minutes(\"10:00\")),\n               (time_to_minutes(\"11:00\"), time_to_minutes(\"12:00\"))]\n\n# Teresa: busy 10:30-11:00, 14:00-14:30\nteresa_busy = [(time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n               (time_to_minutes(\"14:00\"), time_to_minutes(\"14:30\"))]\n\n# Carol: busy 9:00-12:30, 14:00-15:30, 16:00-17:00\ncarol_busy = [(time_to_minutes(\"09:00\"), time_to_minutes(\"12:30\")),\n              (time_to_minutes(\"14:00\"), time_to_minutes(\"15:30\")),\n              (time_to_minutes(\"16:00\"), time_to_minutes(\"17:00\"))]\n\n# Convert busy intervals to free intervals for each participant\nronald_free = invert_busy(ronald_busy, work_start, work_end)\nteresa_free = invert_busy(teresa_busy, work_start, work_end)\ncarol_free  = invert_busy(carol_busy,  work_start, work_end)\n\n# Find common free intervals by intersecting free time of all participants\ncommon_free = intersect_intervals(ronald_free, teresa_free)\ncommon_free = intersect_intervals(common_free, carol_free)\n\n# Meeting duration (in minutes)\nmeeting_duration = 60\n\n# Find earliest possible interval that can accommodate the meeting\nproposed_start = None\nproposed_end = None\n\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        proposed_start = start\n        proposed_end = start + meeting_duration\n        break\n\nif proposed_start is not None:\n    # Format the result as {HH:MM:HH:MM}\n    result = \"{\" + f\"{minutes_to_time(proposed_start)}:{minutes_to_time(proposed_end)}\" + \"}\"\n    print(result)\nelse:\n    print(\"No available slot found\")\n'''",
            "count": "calendar_scheduling_example_78"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_time(m):\n    \"\"\"Convert minutes since midnight to HH:MM string.\"\"\"\n    hours = m // 60\n    minutes = m % 60\n    return f\"{hours:02d}:{minutes:02d}\"\n\n# Work day starts at 9:00 (540 minutes) and ends at 17:00 (1020 minutes)\nwork_start = 9 * 60        # 540 minutes\nwork_end = 17 * 60         # 1020 minutes\nmeeting_duration = 60      # meeting duration in minutes\n\n# Busy intervals for each participant in minutes [start, end)\n# Amy's busy intervals: 11:00-11:30 and 12:00-12:30\namy_busy = [(11 * 60, 11 * 60 + 30), (12 * 60, 12 * 60 + 30)]\n\n# Emma has no meetings.\nemma_busy = []\n\n# John's busy intervals: 10:00-10:30, 11:30-12:00, 12:30-16:00, 16:30-17:00\njohn_busy = [(10 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)]\n\n# Combine all busy intervals\nall_busy = amy_busy + emma_busy + john_busy\n\n# Sort intervals by start time\nall_busy.sort(key=lambda interval: interval[0])\n\n# Merge overlapping or contiguous busy intervals\nmerged_busy = []\nfor start, end in all_busy:\n    if not merged_busy:\n        merged_busy.append([start, end])\n    else:\n        last_start, last_end = merged_busy[-1]\n        # If intervals overlap or are contiguous, merge them\n        if start <= last_end:\n            merged_busy[-1][1] = max(last_end, end)\n        else:\n            merged_busy.append([start, end])\n\n# Now find free intervals within working hours\nfree_intervals = []\ncurrent_start = work_start\n\nfor busy_start, busy_end in merged_busy:\n    # Only consider busy intervals that affect the work hours\n    if busy_start > current_start:\n        free_interval = (current_start, busy_start)\n        free_intervals.append(free_interval)\n    current_start = max(current_start, busy_end)\n\nif current_start < work_end:\n    free_intervals.append((current_start, work_end))\n\n# Find earliest free interval that can accommodate the meeting duration\nproposed_start = None\nfor start, end in free_intervals:\n    if end - start >= meeting_duration:\n        proposed_start = start\n        break\n\nif proposed_start is not None:\n    proposed_end = proposed_start + meeting_duration\n    # Format the time in HH:MM:HH:MM enclosed in curly braces.\n    result = f\"{{{minutes_to_time(proposed_start)}:{minutes_to_time(proposed_end)}}}\"\n    print(result)\nelse:\n    print(\"No available time slot.\")\n'''",
            "count": "calendar_scheduling_example_79"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    # Converts \"HH:MM\" to minutes since midnight\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    # Converts minutes since midnight to \"HH:MM\"\n    return f\"{minutes//60:02d}:{minutes%60:02d}\"\n\n# Define working hours and meeting duration in minutes\nwork_start = time_to_minutes(\"09:00\")\n# Alexis doesn't want to meet after 15:00, so meeting must end by 15:00.\nwork_end = time_to_minutes(\"15:00\")\nmeeting_duration = 30\n\n# Define busy intervals for each participant as tuples (start, end) in minutes.\n# Michelle busy intervals\nmichelle_busy = [\n    (time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\"))\n]\n\n# Billy busy intervals\nbilly_busy = [\n    (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))  # Beyond 15:00, not relevant.\n]\n\n# Alexis busy intervals\nalexis_busy = [\n    (time_to_minutes(\"09:30\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"13:30\"), time_to_minutes(\"14:30\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))  # Beyond 15:00, not relevant.\n]\n\n# Combine busy intervals for the period up to work_end (15:00), ignoring intervals that start after work_end.\ndef is_free(start, busy_intervals):\n    end = start + meeting_duration\n    for b_start, b_end in busy_intervals:\n        # Only consider conflicts if the busy interval overlaps with [start, end)\n        if start < b_end and end > b_start:\n            return False\n    return True\n\n# Iterate over each minute from work_start to latest possible start time (work_end - meeting_duration).\nproposed_start = None\nfor candidate in range(work_start, work_end - meeting_duration + 1):\n    if (is_free(candidate, michelle_busy) and \n        is_free(candidate, billy_busy) and \n        is_free(candidate, alexis_busy)):\n        proposed_start = candidate\n        break\n\nif proposed_start is not None:\n    proposed_end = proposed_start + meeting_duration\n    # Output format: {HH:MM:HH:MM}\n    output = f\"{{{minutes_to_time(proposed_start)}:{minutes_to_time(proposed_end)}}}\"\n    print(output)\nelse:\n    print(\"No available meeting slot found.\")\n'''",
            "count": "calendar_scheduling_example_80"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    \"\"\"Converts HH:MM to minutes past midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    \"\"\"Converts minutes past midnight to HH:MM format with leading zeros.\"\"\"\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\ndef get_free_intervals(busy, work_start, work_end):\n    \"\"\"\n    Given a list of busy intervals (each a tuple of (start, end) in minutes),\n    returns a list of free intervals within the work day [work_start, work_end].\n    Assumes busy intervals are sorted.\n    \"\"\"\n    free = []\n    current = work_start\n    for interval in busy:\n        busy_start, busy_end = interval\n        if busy_start > current:\n            free.append((current, busy_start))\n        current = max(current, busy_end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Intersects two lists of intervals (each as (start, end)) and returns the list of overlapping intervals.\"\"\"\n    i, j = 0, 0\n    intersection = []\n    while i < len(intervals1) and j < len(intervals2):\n        start = max(intervals1[i][0], intervals2[j][0])\n        end = min(intervals1[i][1], intervals2[j][1])\n        if start < end:  # There is an overlap\n            intersection.append((start, end))\n        # Move to the next interval which ends earlier.\n        if intervals1[i][1] < intervals2[j][1]:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\n# Meeting parameters\nmeeting_duration = 60  # in minutes\n\n# Working hours: 9:00 to 17:00 in minutes\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Busy intervals for each participant (in minutes from midnight)\n# Jeremy's busy: 14:30 to 15:30\njeremy_busy = [(time_to_minutes(\"14:30\"), time_to_minutes(\"15:30\"))]\n# Lawrence's busy: 15:30 to 16:00 and 16:30 to 17:00\nlawrence_busy = [(time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\")),\n                 (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))]\n# Helen's busy: 9:30 to 10:00, 10:30 to 11:00, 11:30 to 12:00, 13:00 to 14:00, 15:00 to 15:30, 16:00 to 17:00\nhelen_busy = [(time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n              (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n              (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n              (time_to_minutes(\"13:00\"), time_to_minutes(\"14:00\")),\n              (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\")),\n              (time_to_minutes(\"16:00\"), time_to_minutes(\"17:00\"))]\n\n# Calculate free intervals for each participant\njeremy_free = get_free_intervals(jeremy_busy, work_start, work_end)\nlawrence_free = get_free_intervals(lawrence_busy, work_start, work_end)\nhelen_free = get_free_intervals(helen_busy, work_start, work_end)\n\n# Intersect free intervals for all participants\nintersect_jl = intersect_intervals(jeremy_free, lawrence_free)\ncommon_free = intersect_intervals(intersect_jl, helen_free)\n\n# Find the earliest common free interval that can accommodate the meeting duration\nmeeting_slot = None\nfor interval in common_free:\n    start, end = interval\n    if end - start >= meeting_duration:\n        meeting_slot = (start, start + meeting_duration)\n        break\n\nif meeting_slot:\n    meeting_start_str = minutes_to_time(meeting_slot[0])\n    meeting_end_str = minutes_to_time(meeting_slot[1])\n    # Output in the format HH:MM:HH:MM enclosed in curly braces\n    print(f\"{{{meeting_start_str}:{meeting_end_str}}}\")\nelse:\n    print(\"No common slot available\")\n'''",
            "count": "calendar_scheduling_example_81"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    \"\"\"Convert HH:MM string to minutes since midnight.\"\"\"\n    h, m = map(int, t.split(':'))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    \"\"\"Convert minutes since midnight to HH:MM string.\"\"\"\n    h = m // 60\n    m = m % 60\n    return f\"{h:02}:{m:02}\"\n\ndef invert_intervals(busy, work_start, work_end):\n    \"\"\"Given busy intervals (each as (start, end) in minutes) and working range,\n    return free intervals within the working day.\"\"\"\n    free = []\n    current = work_start\n    for start, end in sorted(busy):\n        if start > current:\n            free.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Intersect two lists of intervals (each interval is (start, end)).\"\"\"\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        start = max(intervals1[i][0], intervals2[j][0])\n        end = min(intervals1[i][1], intervals2[j][1])\n        if start + meeting_duration <= end:  # enough room for a meeting\n            result.append((start, end))\n        if intervals1[i][1] < intervals2[j][1]:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Work day in minutes\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nmeeting_duration = 30  # in minutes\n\n# Participant busy intervals in minutes\n# Michael busy: 09:30-10:30, 15:00-15:30, 16:00-16:30\nmichael_busy = [\n    (time_to_minutes(\"09:30\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))\n]\n\n# Eric's calendar is wide open, so no busy intervals.\neric_busy = []\n\n# Arthur busy: 09:00-12:00, 13:00-15:00, 15:30-16:00, 16:30-17:00\narthur_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\")),\n    (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))\n]\n\n# Compute free intervals for each participant\nmichael_free = invert_intervals(michael_busy, work_start, work_end)\neric_free    = invert_intervals(eric_busy, work_start, work_end)\narthur_free  = invert_intervals(arthur_busy, work_start, work_end)\n\n# Intersect free intervals of Michael and Eric (Eric is free entire day so it will be Michael's free)\ncommon_free = intersect_intervals(michael_free, eric_free)\n# Now intersect with Arthur's free intervals\ncommon_free = intersect_intervals(common_free, arthur_free)\n\n# Find the earliest interval that can accommodate the meeting duration\nscheduled_slot = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        scheduled_slot = (start, start + meeting_duration)\n        break\n\nif scheduled_slot:\n    start_str = minutes_to_time(scheduled_slot[0])\n    end_str = minutes_to_time(scheduled_slot[1])\n    # Output in the format {HH:MM:HH:MM} as required.\n    print(f\"{{{start_str}:{end_str}}}\")\nelse:\n    print(\"No available slot found\")\n'''",
            "count": "calendar_scheduling_example_82"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{10:00:11:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    \"\"\"Converts a time string HH:MM to minutes since midnight.\"\"\"\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    \"\"\"Converts minutes since midnight to time string HH:MM (zero-padded).\"\"\"\n    return f\"{m//60:02d}:{m%60:02d}\"\n\ndef subtract_intervals(whole, intervals):\n    \"\"\"Subtract busy intervals from a whole interval.\n       whole: tuple (start, end)\n       intervals: list of tuples [(start, end), ...] that lie within whole.\n       Returns a list of non-overlapping free intervals.\n    \"\"\"\n    free = []\n    start = whole[0]\n    for bs, be in sorted(intervals):\n        if bs > start:\n            free.append((start, bs))\n        start = max(start, be)\n    if start < whole[1]:\n        free.append((start, whole[1]))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Intersect two lists of intervals.\"\"\"\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        a1, b1 = intervals1[i]\n        a2, b2 = intervals2[j]\n        # Find overlap between intervals\n        start = max(a1, a2)\n        end = min(b1, b2)\n        if start < end:\n            result.append((start, end))\n        # Move the pointer that ends first\n        if b1 < b2:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef get_free_intervals(busy, work_interval):\n    \"\"\"Given a list of busy intervals and the working interval,\n       return the free intervals within the working interval.\n       busy: list of tuples (start, end) in minutes.\n       work_interval: tuple (start, end)\n    \"\"\"\n    # Merge overlapping busy intervals first\n    busy = sorted(busy)\n    merged = []\n    for interval in busy:\n        if not merged or interval[0] > merged[-1][1]:\n            merged.append(list(interval))\n        else:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n    merged = [tuple(x) for x in merged]\n    return subtract_intervals(work_interval, merged)\n\ndef find_earliest_meeting(participant_busy, work_interval, duration):\n    \"\"\"\n    participant_busy: list of lists. Each inner list represents busy intervals for a participant.\n                      Each busy interval is a tuple (start, end) in minutes.\n    work_interval: tuple (start, end) representing working hours.\n    duration: required duration in minutes.\n    \n    Returns the earliest available meeting interval as a tuple (start, end) in minutes.\n    \"\"\"\n    free_all = []\n    # Calculate free intervals for first participant.\n    free_all = get_free_intervals(participant_busy[0], work_interval)\n    # Intersect with free intervals of the remaining participants.\n    for busy in participant_busy[1:]:\n        free = get_free_intervals(busy, work_interval)\n        free_all = intersect_intervals(free_all, free)\n    \n    # Find the earliest free interval that is at least 'duration' minutes long.\n    for start, end in free_all:\n        if end - start >= duration:\n            return (start, start + duration)\n    return None\n\n# Define working hours: 09:00 to 17:00\nwork_interval = (time_to_minutes(\"09:00\"), time_to_minutes(\"17:00\"))\nmeeting_duration = 60  # one hour in minutes\n\n# Define busy schedules (in minutes) for each participant for Anthony, Ronald, and Jonathan.\n# Anthony busy: 14:00-14:30, 15:00-15:30\nanthony_busy = [\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"14:30\")),\n    (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\"))\n]\n# Ronald busy: 09:00-10:00, 12:00-12:30, 13:30-14:00\nronald_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n    (time_to_minutes(\"13:30\"), time_to_minutes(\"14:00\"))\n]\n# Jonathan busy: 09:00-10:00, 11:00-11:30, 12:00-13:00, 14:00-14:30, 15:00-17:00\njonathan_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"11:30\")),\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"14:30\")),\n    (time_to_minutes(\"15:00\"), time_to_minutes(\"17:00\"))\n]\n\n# List of busy schedules for all participants\nparticipant_busy = [anthony_busy, ronald_busy, jonathan_busy]\n\nmeeting_time = find_earliest_meeting(participant_busy, work_interval, meeting_duration)\nif meeting_time:\n    start_str = minutes_to_time(meeting_time[0])\n    end_str = minutes_to_time(meeting_time[1])\n    # Output in format {HH:MM:HH:MM}\n    print(f\"{{{start_str}:{end_str}}}\")\nelse:\n    print(\"No available time slot\")\n'''",
            "count": "calendar_scheduling_example_83"
        },
        {
            "final_program_time": "{11:30:12:30}",
            "expected_time": "{11:30:12:30}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\ndef str_to_minutes(t):\n    \"\"\"Convert HH:MM string to minutes since midnight.\"\"\"\n    h, m = map(int, t.split(':'))\n    return h * 60 + m\n\ndef minutes_to_str(m):\n    \"\"\"Convert minutes since midnight to HH:MM format.\"\"\"\n    return f\"{m//60:02d}:{m%60:02d}\"\n\ndef subtract_busy(work_interval, busy_intervals):\n    \"\"\"\n    Given a work_interval (start, end) and a list of busy intervals,\n    return a list of free intervals (start, end) within work_interval.\n    Assumes busy_intervals are sorted and non-overlapping.\n    \"\"\"\n    free_intervals = []\n    start, end = work_interval\n    current = start\n    for b_start, b_end in busy_intervals:\n        if b_start > current:\n            free_intervals.append((current, min(b_start, end)))\n        current = max(current, b_end)\n        if current >= end:\n            break\n    if current < end:\n        free_intervals.append((current, end))\n    return free_intervals\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"\n    Given two lists of intervals, return their intersection.\n    Each interval is a tuple (start, end). Both lists assumed sorted.\n    \"\"\"\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # find overlap\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap < end_overlap:\n            result.append((start_overlap, end_overlap))\n        # move forward in the list that ends earlier\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Define work hours (in minutes since midnight)\nwork_start = str_to_minutes(\"09:00\")\nwork_end   = str_to_minutes(\"17:00\")\nwork_interval = (work_start, work_end)\n\n# Meeting duration in minutes\nmeeting_duration = 60\n\n# Define busy intervals for each participant as lists of tuples (start, end) in minutes.\n# Intervals are assumed non-overlapping and sorted.\nkevin_busy = [\n    (str_to_minutes(\"09:30\"), str_to_minutes(\"10:00\")),\n    (str_to_minutes(\"10:30\"), str_to_minutes(\"11:00\")),\n    (str_to_minutes(\"15:00\"), str_to_minutes(\"16:00\"))\n]\n\nryan_busy = [\n    (str_to_minutes(\"10:30\"), str_to_minutes(\"11:30\")),\n    (str_to_minutes(\"12:30\"), str_to_minutes(\"13:00\")),\n    (str_to_minutes(\"13:30\"), str_to_minutes(\"14:00\"))\n]\n\neugene_busy = [\n    (str_to_minutes(\"09:00\"), str_to_minutes(\"09:30\")),\n    (str_to_minutes(\"10:00\"), str_to_minutes(\"11:00\")),\n    (str_to_minutes(\"12:30\"), str_to_minutes(\"17:00\"))\n]\n\n# Compute free intervals for each person within work hours.\nkevin_free = subtract_busy(work_interval, kevin_busy)\nryan_free = subtract_busy(work_interval, ryan_busy)\neugene_free = subtract_busy(work_interval, eugene_busy)\n\n# Compute the common free intervals (intersection)\ncommon_free = intersect_intervals(kevin_free, ryan_free)\ncommon_free = intersect_intervals(common_free, eugene_free)\n\n# Find earliest interval that can accommodate the meeting_duration\nproposed_start = None\nproposed_end = None\nfor (start, end) in common_free:\n    if end - start >= meeting_duration:\n        proposed_start = start\n        proposed_end = start + meeting_duration\n        break\n\nif proposed_start is not None:\n    # Format the output as HH:MM:HH:MM enclosed in curly braces.\n    output = f\"{{{minutes_to_str(proposed_start)}:{minutes_to_str(proposed_end)}}}\"\n    print(output)\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_84"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    # t in \"HH:MM\" format\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef overlaps(start, end, busy_start, busy_end):\n    # Returns True if [start, end) overlaps with [busy_start, busy_end)\n    return not (end <= busy_start or start >= busy_end)\n\n# Meeting settings\nmeeting_duration = 30  # in minutes\nwork_start = time_to_minutes(\"09:00\")\nwork_end   = time_to_minutes(\"17:00\")\n# Julia's constraint: meeting must end by 13:30\njulia_latest_end = time_to_minutes(\"13:30\")\n# Thus candidate meeting must finish by julia_latest_end.\nlatest_start = julia_latest_end - meeting_duration\n\n# Busy schedules (times in minutes) for each participant:\n# Kelly's calendar: free all day, so no busy intervals.\nkelly_busy = []\n\n# Julia's busy intervals on Monday: 9:30-10:00, 14:00-14:30, 15:00-15:30, 16:30-17:00.\njulia_busy = [\n    (time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"14:30\")),\n    (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\")),\n    (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))\n]\n\n# Martha's busy intervals on Monday: 9:00-11:00, 12:00-15:00.\nmartha_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"11:00\")),\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"15:00\"))\n]\n\n# Aggregate busy schedules in a dictionary keyed by participant for iteration.\nschedules = {\n    \"Kelly\": kelly_busy,\n    \"Julia\": julia_busy,\n    \"Martha\": martha_busy\n}\n\n# Find earliest possible meeting time that works for everyone.\nfound = False\ncandidate_start = work_start\n\nwhile candidate_start <= latest_start:\n    candidate_end = candidate_start + meeting_duration\n    # Check that candidate meeting is within working hours.\n    if candidate_end > work_end:\n        break\n    # Additionally, ensure it meets Julia's personal constraint (meeting must end by 13:30).\n    if candidate_end > julia_latest_end:\n        candidate_start += 1\n        continue\n\n    conflict = False\n    # Check each participant's busy schedule.\n    for person, busy_list in schedules.items():\n        for busy_start, busy_end in busy_list:\n            if overlaps(candidate_start, candidate_end, busy_start, busy_end):\n                conflict = True\n                break\n        if conflict:\n            break\n\n    if not conflict:\n        # Found a valid slot; output in the format {HH:MM:HH:MM}\n        start_str = minutes_to_time(candidate_start)\n        end_str = minutes_to_time(candidate_end)\n        print(f\"{{{start_str}:{end_str}}}\")\n        found = True\n        break\n\n    candidate_start += 1\n\nif not found:\n    print(\"No available time slot found\")\n'''",
            "count": "calendar_scheduling_example_85"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    # t is a string in \"HH:MM\" format\n    hours, minutes = map(int, t.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(m):\n    hours = m // 60\n    minutes = m % 60\n    return f\"{hours:02d}:{minutes:02d}\"\n\n# Define work hours (Monday, 9:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Define meeting duration in minutes\nmeeting_duration = 60\n\n# Busy intervals for each participant for Monday, represented as (start, end) in minutes.\n# Samuel's busy intervals:\nsamuel_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\")),\n]\n\n# Emma is free the entire day, so no busy intervals.\nemma_busy = []\n\n# Brittany's busy intervals:\nbrittany_busy = [\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"14:30\")),\n    (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\")),\n    (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\")),\n]\n\n# Combine all busy intervals from all participants\nall_busy = samuel_busy + emma_busy + brittany_busy\n\n# Sort busy intervals based on start time\nall_busy.sort(key=lambda interval: interval[0])\n\n# Merge overlapping busy intervals\nmerged_busy = []\nfor interval in all_busy:\n    if not merged_busy:\n        merged_busy.append(interval)\n    else:\n        last = merged_busy[-1]\n        # Check if current interval overlaps with the last merged interval\n        if interval[0] <= last[1]:\n            merged_busy[-1] = (last[0], max(last[1], interval[1]))\n        else:\n            merged_busy.append(interval)\n\n# Calculate free intervals as gaps between work_start, merged busy intervals, and work_end.\nfree_intervals = []\n# Check gap before first busy interval\nif work_start < merged_busy[0][0]:\n    free_intervals.append((work_start, merged_busy[0][0]))\n\n# Check gaps between merged intervals\nfor i in range(len(merged_busy) - 1):\n    end_current = merged_busy[i][1]\n    start_next = merged_busy[i+1][0]\n    if end_current < start_next:\n        free_intervals.append((end_current, start_next))\n        \n# Check gap after the last busy interval\nif merged_busy[-1][1] < work_end:\n    free_intervals.append((merged_busy[-1][1], work_end))\n\n# Find the earliest free interval that can accommodate the meeting duration\nproposed_meeting = None\nfor free in free_intervals:\n    if free[1] - free[0] >= meeting_duration:\n        proposed_meeting = (free[0], free[0] + meeting_duration)\n        break\n\nif proposed_meeting:\n    start_time = minutes_to_time(proposed_meeting[0])\n    end_time = minutes_to_time(proposed_meeting[1])\n    # Output in the format {HH:MM:HH:MM}\n    print(f\"{{{start_time}:{end_time}}}\")\nelse:\n    print(\"No available meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_86"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    \"\"\"Convert 'HH:MM' string to minutes since midnight.\"\"\"\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    \"\"\"Convert minutes since midnight to 'HH:MM' string with leading zeros.\"\"\"\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef subtract_busy(work_interval, busy_intervals):\n    \"\"\"Subtract busy intervals from work_interval.\n       work_interval: tuple (start, end) in minutes.\n       busy_intervals: list of tuples (start, end) in minutes.\n       Returns a list of free intervals (start, end).\n    \"\"\"\n    free = []\n    current_start = work_interval[0]\n    for busy in sorted(busy_intervals):\n        if busy[0] > current_start:\n            free.append((current_start, busy[0]))\n        current_start = max(current_start, busy[1])\n    if current_start < work_interval[1]:\n        free.append((current_start, work_interval[1]))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Intersect two lists of intervals.\n       Each interval is a tuple (start, end).\n       Return the list of intersections.\n    \"\"\"\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        start = max(intervals1[i][0], intervals2[j][0])\n        end = min(intervals1[i][1], intervals2[j][1])\n        if start < end:\n            result.append((start, end))\n        if intervals1[i][1] < intervals2[j][1]:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Define work hours and meeting duration\nwork_start = time_to_minutes(\"09:00\")\nwork_end   = time_to_minutes(\"17:00\")\nwork_interval = (work_start, work_end)\nmeeting_duration = 30  # minutes\n\n# Busy intervals for each participant (in minutes)\n# Brittany busy: 12:00-13:30, 14:30-15:00, 15:30-16:00, 16:30-17:00\nbrittany_busy = [\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"13:30\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\")),\n    (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))\n]\n\n# Wayne busy: 9:30-10:00, 13:00-15:00, 16:30-17:00\nwayne_busy = [\n    (time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))\n]\n\n# Charles busy: 9:00-9:30, 10:00-10:30, 11:30-13:30, 14:30-16:30\ncharles_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"13:30\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"16:30\"))\n]\n\n# Compute free intervals for each participant within work hours\nbrittany_free = subtract_busy(work_interval, brittany_busy)\nwayne_free = subtract_busy(work_interval, wayne_busy)\ncharles_free = subtract_busy(work_interval, charles_busy)\n\n# Compute the common free intervals among all three\ncommon_free = intersect_intervals(brittany_free, wayne_free)\ncommon_free = intersect_intervals(common_free, charles_free)\n\n# Find the earliest interval with enough duration for the meeting\nproposed_start = None\nfor interval in common_free:\n    if interval[1] - interval[0] >= meeting_duration:\n        proposed_start = interval[0]\n        break\n\nif proposed_start is None:\n    print(\"No available slot found\")\nelse:\n    proposed_end = proposed_start + meeting_duration\n    # Format the output in HH:MM:HH:MM enclosed in curly braces.\n    print(\"{\" + f\"{minutes_to_time(proposed_start)}:{minutes_to_time(proposed_end)}\" + \"}\")\n    \n# Expected output for this case is: {10:30:11:00}\n'''",
            "count": "calendar_scheduling_example_87"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "'''python\ndef to_minutes(time_str):\n    # Converts \"HH:MM\" to minutes since midnight.\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef from_minutes(minutes):\n    # Converts minutes since midnight to \"HH:MM\" with zero padding.\n    return f\"{minutes // 60:02d}:{minutes % 60:02d}\"\n\ndef merge_intervals(intervals):\n    # Merge overlapping intervals; each interval is a tuple (start, end) in minutes.\n    intervals.sort()\n    merged = []\n    for start, end in intervals:\n        if merged and start <= merged[-1][1]:\n            merged[-1] = (merged[-1][0], max(merged[-1][1], end))\n        else:\n            merged.append((start, end))\n    return merged\n\ndef find_free_interval(work_start, work_end, busy_intervals, duration):\n    # Given merged busy intervals, find the earliest free slot of at least \"duration\" minutes.\n    free_slots = []\n    current_time = work_start\n    for start, end in busy_intervals:\n        if start > current_time:\n            free_slots.append((current_time, start))\n        current_time = max(current_time, end)\n    if current_time < work_end:\n        free_slots.append((current_time, work_end))\n    \n    for free_start, free_end in free_slots:\n        if free_end - free_start >= duration:\n            return free_start, free_start + duration\n    return None\n\ndef main():\n    # Define meeting parameters\n    meeting_duration = 60  # minutes\n    work_start = to_minutes(\"09:00\")\n    work_end = to_minutes(\"17:00\")\n    \n    # Busy intervals (in minutes) for each participant:\n    # Dennis: no meetings, so no intervals to add.\n    # Joseph: busy 09:00-09:30 and 12:30-13:00.\n    # Isabella: busy 09:00-10:30, 11:30-12:00, 13:30-14:00, and 14:30-17:00.\n    busy_intervals = [\n        (to_minutes(\"09:00\"), to_minutes(\"09:30\")),   # Joseph\n        (to_minutes(\"12:30\"), to_minutes(\"13:00\")),   # Joseph\n        (to_minutes(\"09:00\"), to_minutes(\"10:30\")),   # Isabella\n        (to_minutes(\"11:30\"), to_minutes(\"12:00\")),   # Isabella\n        (to_minutes(\"13:30\"), to_minutes(\"14:00\")),   # Isabella\n        (to_minutes(\"14:30\"), to_minutes(\"17:00\"))    # Isabella\n    ]\n    \n    # Merge busy intervals for a combined schedule.\n    merged_busy = merge_intervals(busy_intervals)\n    \n    # Find earliest free interval that can accommodate the meeting.\n    meeting_slot = find_free_interval(work_start, work_end, merged_busy, meeting_duration)\n    \n    if meeting_slot:\n        start_time = from_minutes(meeting_slot[0])\n        end_time = from_minutes(meeting_slot[1])\n        print(\"{\" + f\"{start_time}:{end_time}\" + \"}\")\n    else:\n        print(\"No available slot found.\")\n\nif __name__ == \"__main__\":\n    main()\n'''",
            "count": "calendar_scheduling_example_88"
        },
        {
            "final_program_time": "{15:00:16:00}",
            "expected_time": "{15:00:16:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(time_str):\n    # Converts \"HH:MM\" to minutes since midnight\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(m):\n    # Converts minutes since midnight to \"HH:MM\"\n    return f\"{m//60:02d}:{m%60:02d}\"\n\ndef get_free_intervals(busy_intervals, work_start, work_end):\n    \"\"\"\n    Given a sorted list of busy intervals [(start, end), ...] in minutes,\n    return a list of free intervals [(start, end), ...] within [work_start, work_end].\n    \"\"\"\n    free = []\n    # Before the first busy interval:\n    if busy_intervals:\n        if work_start < busy_intervals[0][0]:\n            free.append((work_start, busy_intervals[0][0]))\n    else:\n        free.append((work_start, work_end))\n    \n    # Between busy intervals:\n    for i in range(len(busy_intervals) - 1):\n        current_end = busy_intervals[i][1]\n        next_start = busy_intervals[i+1][0]\n        if current_end < next_start:\n            free.append((current_end, next_start))\n    \n    # After the last busy interval:\n    if busy_intervals:\n        if busy_intervals[-1][1] < work_end:\n            free.append((busy_intervals[-1][1], work_end))\n    \n    return free\n\ndef intersect_intervals(list1, list2):\n    \"\"\"\n    Given two lists of intervals [(s,e),...], return their intersection intervals.\n    \"\"\"\n    i, j = 0, 0\n    result = []\n    while i < len(list1) and j < len(list2):\n        start1, end1 = list1[i]\n        start2, end2 = list2[j]\n        # Calculate intersection of the intervals\n        intersect_start = max(start1, start2)\n        intersect_end = min(end1, end2)\n        if intersect_start < intersect_end:\n            result.append((intersect_start, intersect_end))\n        # Move to the next interval in the list that ends first\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Work hours for Monday in minutes (9:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end   = time_to_minutes(\"17:00\")\nmeeting_duration = 60  # in minutes\n\n# Busy intervals for each participant (converted to minutes)\n# Michelle busy: 11:00-12:00, 14:00-15:00\nmichelle_busy = [\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"15:00\"))\n]\n\n# Andrea busy: 9:00-9:30, 11:30-12:30, 13:30-14:00, 14:30-15:00, 16:00-16:30\nandrea_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"12:30\")),\n    (time_to_minutes(\"13:30\"), time_to_minutes(\"14:00\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))\n]\n\n# Douglas busy: 9:00-9:30, 10:00-10:30, 11:00-15:00, 16:00-17:00\ndouglas_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"17:00\"))\n]\n\n# Get free intervals for each participant\nmichelle_free = get_free_intervals(michelle_busy, work_start, work_end)\nandrea_free   = get_free_intervals(andrea_busy, work_start, work_end)\ndouglas_free  = get_free_intervals(douglas_busy, work_start, work_end)\n\n# Intersect free intervals across all three participants\ncommon_free = intersect_intervals(michelle_free, andrea_free)\ncommon_free = intersect_intervals(common_free, douglas_free)\n\n# Find the earliest interval that can accommodate the meeting duration\nproposed_start, proposed_end = None, None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        proposed_start = start\n        proposed_end = start + meeting_duration\n        break\n\nif proposed_start is not None:\n    # Format the output as \"HH:MM:HH:MM\"\n    output = f\"{minutes_to_time(proposed_start)}:{minutes_to_time(proposed_end)}\"\n    print(f\"{{{output}}}\")  # The output is enclosed in curly braces.\nelse:\n    print(\"No available slot found.\")\n'''",
            "count": "calendar_scheduling_example_89"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "'''python\ndef intersect_intervals(list1, list2):\n    \"\"\"Intersect two lists of intervals.\n       Each interval is a tuple (start, end) in minutes.\n       Returns a list of intersected intervals.\n    \"\"\"\n    i, j = 0, 0\n    result = []\n    while i < len(list1) and j < len(list2):\n        start1, end1 = list1[i]\n        start2, end2 = list2[j]\n        # Find the intersection\n        start_int = max(start1, start2)\n        end_int = min(end1, end2)\n        if start_int < end_int:\n            result.append((start_int, end_int))\n        # Move to next interval\n        if end1 <= end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef minutes_to_time(minutes):\n    \"\"\"Convert minutes since midnight to HH:MM string.\"\"\"\n    h = minutes // 60\n    m = minutes % 60\n    return f\"{h:02d}:{m:02d}\"\n\n# Workday boundaries (in minutes from midnight): 9:00 to 17:00\nwork_start = 9 * 60   # 540\nwork_end = 17 * 60    # 1020\n\n# Meeting duration in minutes (half an hour)\nduration = 30\n\n# Define free time intervals for each participant (as minutes).\n# Adam:\n# Busy: 9:30-10:00, 10:30-11:00, 11:30-12:00, 16:30-17:00.\n# Therefore free intervals are:\nadam_free = [\n    (work_start, 9*60+30),    # 9:00 to 9:30 => (540, 570)\n    (10*60, 10*60+30),        # 10:00 to 10:30 => (600, 630)\n    (11*60, 11*60+30),        # 11:00 to 11:30 => (660, 690)\n    (12*60, 16*60+30)         # 12:00 to 16:30 => (720, 990)\n]\n\n# Willie:\n# Busy: 9:00-9:30, 15:30-16:00.\n# Free intervals (within work hours):\nwillie_free = [\n    (9*60+30, 15*60+30)       # 9:30 to 15:30 => (570, 930)\n    # The next free period after 16:00 is not considered because Gloria prefers no meetings after 15:30.\n]\n\n# Gloria:\n# Busy: 9:30-12:30, 13:00-13:30, and prefers to avoid meetings after 15:30.\n# So free intervals (within work hours and before 15:30) are:\ngloria_free = [\n    (work_start, 9*60+30),         # 9:00 to 9:30 => (540, 570)\n    (12*60+30, 13*60),             # 12:30 to 13:00 => (750, 780)\n    (13*60+30, 15*60+30)           # 13:30 to 15:30 => (810, 930)\n]\n\n# Compute the common free intervals.\ncommon = intersect_intervals(adam_free, willie_free)\ncommon = intersect_intervals(common, gloria_free)\n\n# Find the earliest slot with enough duration\nmeeting_start = None\nfor start, end in common:\n    if end - start >= duration:\n        meeting_start = start\n        break\n\nif meeting_start is not None:\n    meeting_end = meeting_start + duration\n    # Format output as {HH:MM:HH:MM}\n    output = f\"{{{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}}}\"\n    print(output)\nelse:\n    print(\"No available meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_90"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "'''python\nfrom datetime import datetime, timedelta\n\n# A helper function to convert time in \"HH:MM\" to minutes since midnight.\ndef time_to_minutes(t):\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\n# A helper function to convert minutes since midnight back to \"HH:MM\" format.\ndef minutes_to_time(minutes):\n    h = minutes // 60\n    m = minutes % 60\n    return f\"{h:02d}:{m:02d}\"\n\n# Function to compute free intervals given a list of busy intervals and overall work period.\n# busy_intervals is a list of tuples (start, end) where times are in minutes from midnight.\ndef compute_free_intervals(busy_intervals, work_start, work_end):\n    free = []\n    # Sort busy intervals by start time\n    busy_intervals.sort(key=lambda x: x[0])\n    \n    # First free period from work_start to first busy start, if any gap exists\n    if work_start < busy_intervals[0][0]:\n        free.append((work_start, busy_intervals[0][0]))\n    \n    # Gaps between busy intervals\n    for i in range(len(busy_intervals) - 1):\n        current_end = busy_intervals[i][1]\n        next_start = busy_intervals[i+1][0]\n        if current_end < next_start:\n            free.append((current_end, next_start))\n    \n    # Final free period from last busy end to work_end\n    if busy_intervals[-1][1] < work_end:\n        free.append((busy_intervals[-1][1], work_end))\n    return free\n\n# Function to compute the intersection of two lists of intervals.\ndef intersect_intervals(intervals1, intervals2):\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        start = max(intervals1[i][0], intervals2[j][0])\n        end = min(intervals1[i][1], intervals2[j][1])\n        if start < end:\n            result.append((start, end))\n        # Move to the next interval in whichever ends first.\n        if intervals1[i][1] < intervals2[j][1]:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Define work day boundaries (9:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end   = time_to_minutes(\"17:00\")\nmeeting_duration = 60  # meeting duration in minutes\n\n# Define busy intervals for each participant in minutes since midnight.\n# Danielle: 9:00-10:00, 10:30-11:00, 14:30-15:00, 15:30-16:00, 16:30-17:00\ndanielle_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\")),\n    (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))\n]\n\n# Bruce: 11:00-11:30, 12:30-13:00, 14:00-14:30, 15:30-16:00\nbruce_busy = [\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"11:30\")),\n    (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"14:30\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\"))\n]\n\n# Eric: 9:00-9:30, 10:00-11:00, 11:30-13:00, 14:30-15:30\neric_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"11:00\")),\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"15:30\"))\n]\n\n# Compute free intervals for each participant.\ndanielle_free = compute_free_intervals(danielle_busy, work_start, work_end)\nbruce_free    = compute_free_intervals(bruce_busy, work_start, work_end)\neric_free     = compute_free_intervals(eric_busy, work_start, work_end)\n\n# Compute the common free intervals among all three participants.\ncommon_free = intersect_intervals(danielle_free, bruce_free)\ncommon_free = intersect_intervals(common_free, eric_free)\n\n# Find the earliest common free interval with enough duration for the meeting.\nproposed_start = None\nproposed_end = None\nfor interval in common_free:\n    if interval[1] - interval[0] >= meeting_duration:\n        proposed_start = interval[0]\n        proposed_end = proposed_start + meeting_duration\n        break\n\n# Format and output the result in the format {HH:MM:HH:MM}\nif proposed_start is not None:\n    result = \"{\" + f\"{minutes_to_time(proposed_start)}:{minutes_to_time(proposed_end)}\" + \"}\"\n    print(result)\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_91"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_time(m):\n    \"\"\"Convert minutes (from midnight) to HH:MM string.\"\"\"\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef overlaps(start, end, busy):\n    \"\"\"Return True if the interval [start, end] overlaps with any busy interval in busy list.\"\"\"\n    for b_start, b_end in busy:\n        # If the meeting overlaps a busy interval:\n        if max(start, b_start) < min(end, b_end):\n            return True\n    return False\n\n# Busy schedules in minutes from midnight\n# Work day is from 9:00 (540 minutes) to 17:00 (1020 minutes)\n# Jacqueline: busy 9:30-10:00 and 16:30-17:00\njacqueline_busy = [(9*60+30, 10*60), (16*60+30, 17*60)]\n# Henry is free all day, so no busy intervals\nhenry_busy = []\n# William: busy 9:30-10:30, 12:30-15:00, 15:30-17:00\nwilliam_busy = [(9*60+30, 10*60+30), (12*60+30, 15*60), (15*60+30, 17*60)]\n\n# Define work hours and meeting duration\nwork_start = 9 * 60      # 9:00 in minutes\nwork_end = 17 * 60       # 17:00 in minutes\nmeeting_duration = 60    # meeting is 1 hour\n\n# Function to check if all participants are free for the meeting starting at time 'start'\ndef is_free(start):\n    end = start + meeting_duration\n    # Check each participant for overlapping busy intervals.\n    if overlaps(start, end, jacqueline_busy):\n        return False\n    if overlaps(start, end, henry_busy):\n        return False\n    if overlaps(start, end, william_busy):\n        return False\n    return True\n\n# Find the earliest available meeting start time\nfound = False\nfor start in range(work_start, work_end - meeting_duration + 1):\n    # Meeting should start at or after William is free\n    # Based on William's schedule, earliest available start is not before 10:30\n    # However, the simulation below covers all minutes, so we check every candidate.\n    if is_free(start):\n        meeting_start = start\n        meeting_end = start + meeting_duration\n        found = True\n        break\n\nif found:\n    # Format the output as {HH:MM:HH:MM}\n    output = f\"{{{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}}}\"\n    print(output)\nelse:\n    print(\"No available time slot found\")\n'''",
            "count": "calendar_scheduling_example_92"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    # t is a string \"HH:MM\"\n    hh, mm = map(int, t.split(\":\"))\n    return hh * 60 + mm\n\ndef minutes_to_time(m):\n    hh = m // 60\n    mm = m % 60\n    return f\"{hh:02d}:{mm:02d}\"\n\ndef merge_free_intervals(busy, work_start, work_end):\n    \"\"\"\n    Given busy intervals (each as a (start, end) tuple in minutes) sorted by start time,\n    return the list of free intervals between work_start and work_end.\n    \"\"\"\n    free = []\n    # start with the gap before the first busy interval (if any)\n    current = work_start\n    for s, e in busy:\n        if s > current:\n            free.append((current, s))\n        current = max(current, e)\n    # after last busy interval\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"\n    Given two lists of intervals, compute their intersections.\n    \"\"\"\n    i, j = 0, 0\n    inter = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find overlap between these two intervals\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap < end_overlap:\n            inter.append((start_overlap, end_overlap))\n        # Move to next interval in the list that ends first\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return inter\n\n# Define working hours in minutes (9:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nmeeting_duration = 30  # in minutes\n\n# Busy schedules (times given as strings in HH:MM format)\n# Austin busy: 10:30 to 11:00, 13:30 to 14:00\naustin_busy = [(time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n               (time_to_minutes(\"13:30\"), time_to_minutes(\"14:00\"))]\n\n# Danielle busy: 9:00 to 10:00, 11:00 to 12:00, 13:00 to 13:30, 15:30 to 16:00\ndanielle_busy = [(time_to_minutes(\"09:00\"), time_to_minutes(\"10:00\")),\n                 (time_to_minutes(\"11:00\"), time_to_minutes(\"12:00\")),\n                 (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n                 (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\"))]\n\n# Charles busy: 9:00 to 11:30, 12:00 to 12:30, 13:00 to 17:00\ncharles_busy = [(time_to_minutes(\"09:00\"), time_to_minutes(\"11:30\")),\n                (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n                (time_to_minutes(\"13:00\"), work_end)]  # 13:00 to 17:00\n\n# Compute free intervals for each participant\naustin_free = merge_free_intervals(austin_busy, work_start, work_end)\ndanielle_free = merge_free_intervals(danielle_busy, work_start, work_end)\ncharles_free = merge_free_intervals(charles_busy, work_start, work_end)\n\n# Compute the common free intervals among all three\ncommon_free = intersect_intervals(austin_free, danielle_free)\ncommon_free = intersect_intervals(common_free, charles_free)\n\n# Find the earliest common free interval that can accommodate the meeting_duration\nproposed_start = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        proposed_start = start\n        break\n\nif proposed_start is not None:\n    proposed_end = proposed_start + meeting_duration\n    # Output in the format HH:MM:HH:MM enclosed in curly braces as per example\n    output = f\"{{{minutes_to_time(proposed_start)}:{minutes_to_time(proposed_end)}}}\"\n    print(output)\nelse:\n    print(\"No available meeting slot.\")\n'''",
            "count": "calendar_scheduling_example_93"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    \"\"\"Convert time string 'HH:MM' to minutes since midnight.\"\"\"\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    \"\"\"Convert minutes since midnight to time string 'HH:MM', zero-padded.\"\"\"\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef invert_busy(busy, work_start, work_end):\n    \"\"\"Given a list of busy intervals (each as a tuple (start, end) in minutes)\n    and a work period [work_start, work_end], return a list of free intervals.\"\"\"\n    free = []\n    current = work_start\n    for start, end in sorted(busy):\n        if current < start:\n            free.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Intersect two lists of intervals.\"\"\"\n    result = []\n    i, j = 0, 0\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find overlapping interval\n        start = max(start1, start2)\n        end = min(end1, end2)\n        if start < end:\n            result.append((start, end))\n        # Move to next interval in the list with the earliest end time\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Define work hours for Monday (in minutes, assuming day starts at midnight)\nwork_start = time_to_minutes(\"09:00\")\nwork_end   = time_to_minutes(\"17:00\")\nmeeting_duration = 30  # minutes\n\n# Busy intervals for each participant, in \"HH:MM\" format.\n# Nicholas has no meetings.\nbusy_nicholas = []  \n\n# Elizabeth's busy intervals: \n# 9:30-10:00, 11:30-12:00, 13:30-14:30, 15:00-15:30, 16:30-17:00\nbusy_elizabeth = [\n    (time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"13:30\"), time_to_minutes(\"14:30\")),\n    (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\")),\n    (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))\n]\n\n# Sandra's busy intervals: \n# 9:00-9:30, 10:00-10:30, 11:30-13:30, 15:30-16:30\nbusy_sandra = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"13:30\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"16:30\"))\n]\n# Sandra cannot meet before 13:00. Although her schedule already prevents few times,\n# we enforce this by adding a busy block from work_start to 13:00.\nbusy_sandra.append((work_start, time_to_minutes(\"13:00\")))\n\n# Compute free intervals per participant.\nfree_nicholas = invert_busy(busy_nicholas, work_start, work_end)\nfree_elizabeth = invert_busy(busy_elizabeth, work_start, work_end)\nfree_sandra = invert_busy(busy_sandra, work_start, work_end)\n\n# Intersect the free intervals of all three participants.\nfree_all = intersect_intervals(free_nicholas, free_elizabeth)\nfree_all = intersect_intervals(free_all, free_sandra)\n\n# Find the earliest free interval that can accommodate the meeting duration.\nproposed_time = None\nfor start, end in free_all:\n    if end - start >= meeting_duration:\n        proposed_time = (start, start + meeting_duration)\n        break\n\nif proposed_time:\n    start_time, end_time = proposed_time\n    # Format output as HH:MM:HH:MM enclosed in curly braces.\n    output = \"{\" + f\"{minutes_to_time(start_time)}:{minutes_to_time(end_time)}\" + \"}\"\n    print(output)\nelse:\n    print(\"No available time found.\")\n'''",
            "count": "calendar_scheduling_example_94"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_time(m):\n    \"\"\"Convert minutes since midnight to HH:MM format.\"\"\"\n    hours = m // 60\n    minutes = m % 60\n    return f\"{hours:02d}:{minutes:02d}\"\n\ndef get_free_intervals(working, busy_intervals):\n    \"\"\"\n    Given a working interval and a list of busy intervals,\n    return a list of free intervals within working.\n    working: tuple (start, end) in minutes.\n    busy_intervals: list of tuples (start, end) in minutes.\n    \"\"\"\n    free = []\n    start = working[0]\n    # Sort busy intervals\n    sorted_busy = sorted(busy_intervals, key=lambda x: x[0])\n    for b_start, b_end in sorted_busy:\n        # Adjust busy interval to the working window.\n        current_busy_start = max(b_start, working[0])\n        current_busy_end   = min(b_end, working[1])\n        if current_busy_start > start:\n            free.append((start, current_busy_start))\n        start = max(start, current_busy_end)\n    if start < working[1]:\n        free.append((start, working[1]))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"\n    Intersect two lists of intervals.\n    \"\"\"\n    intersection = []\n    for s1, e1 in intervals1:\n        for s2, e2 in intervals2:\n            start = max(s1, s2)\n            end = min(e1, e2)\n            if start + meeting_duration <= end:\n                intersection.append((start, end))\n    return intersection\n\n# Define the meeting duration in minutes (30 min)\nmeeting_duration = 30\n\n# Define work hours in minutes.\nwork_start = 9 * 60   # 9:00 \u2192 540 minutes\nwork_end   = 17 * 60  # 17:00 \u2192 1020 minutes\n\n# For each participant, define their busy intervals in minutes.\n# Jennifer's busy intervals and constraint (does not want to meet before 12:30)\n# Her busy intervals: 12:00 to 12:30 and 16:00 to 16:30.\njennifer_busy = [(12 * 60, 12 * 60 + 30), (16 * 60, 16 * 60 + 30)]\n# Apply constraint: effective working start is max(9:00, 12:30)\njennifer_work = (max(work_start, 12 * 60 + 30), work_end)  # (750, 1020)\n\n# Gary's busy intervals: 9:30 to 10:00, 10:30 to 11:00, 11:30 to 12:30, 14:00 to 14:30, 16:30 to 17:00.\ngary_busy = [\n    (9 * 60 + 30, 10 * 60), \n    (10 * 60 + 30, 11 * 60), \n    (11 * 60 + 30, 12 * 60 + 30),\n    (14 * 60, 14 * 60 + 30),\n    (16 * 60 + 30, 17 * 60)\n]\ngary_work = (work_start, work_end)\n\n# Frances's busy intervals: 9:00 to 11:00, 11:30 to 12:30, 13:00 to 17:00.\nfrances_busy = [\n    (9 * 60, 11 * 60),\n    (11 * 60 + 30, 12 * 60 + 30),\n    (13 * 60, 17 * 60)\n]\nfrances_work = (work_start, work_end)\n\n# Calculate free intervals for each participant.\njennifer_free = get_free_intervals(jennifer_work, jennifer_busy)\ngary_free = get_free_intervals(gary_work, gary_busy)\nfrances_free = get_free_intervals(frances_work, frances_busy)\n\n# Intersect free intervals of all three participants.\nfirst_intersection = intersect_intervals(jennifer_free, gary_free)\ncommon_free = intersect_intervals(first_intersection, frances_free)\n\n# Find the earliest interval that can accommodate the meeting duration.\nproposed_time = None\nfor start, end in sorted(common_free, key=lambda x: x[0]):\n    if end - start >= meeting_duration:\n        proposed_time = (start, start + meeting_duration)\n        break\n\nif proposed_time:\n    start_str = minutes_to_time(proposed_time[0])\n    end_str   = minutes_to_time(proposed_time[1])\n    # Output in the specified format {HH:MM:HH:MM}\n    print(f\"{{{start_str}:{end_str}}}\")\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_95"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "'''python\ndef time_to_minutes(t):\n    \"\"\"Convert time string 'HH:MM' to minutes since midnight.\"\"\"\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    \"\"\"Convert minutes since midnight to time string 'HH:MM'.\"\"\"\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef subtract_busy(working, busys):\n    \"\"\"Given a working interval (start, end) and a list of busy intervals,\n    return a list of free intervals within working hours.\n    Both working and busy intervals are tuples (start, end) in minutes.\n    Assumes busys are sorted and non-overlapping.\n    \"\"\"\n    free = []\n    current_start = working[0]\n    for b in busys:\n        if b[0] > current_start:\n            free.append((current_start, b[0]))\n        current_start = max(current_start, b[1])\n    if current_start < working[1]:\n        free.append((current_start, working[1]))\n    return free\n\ndef intersect_intervals(list1, list2):\n    \"\"\"Intersect two lists of intervals. Each interval is a tuple (start, end) in minutes.\n    Returns a list of intervals.\n    \"\"\"\n    i, j = 0, 0\n    result = []\n    while i < len(list1) and j < len(list2):\n        start = max(list1[i][0], list2[j][0])\n        end = min(list1[i][1], list2[j][1])\n        if start < end:\n            result.append((start, end))\n        if list1[i][1] < list2[j][1]:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Define working hours (9:00 to 17:00) in minutes from midnight.\nworking_hours = (time_to_minutes(\"09:00\"), time_to_minutes(\"17:00\"))\n\n# Meeting duration in minutes\nmeeting_duration = 30\n\n# Busy intervals for each participant (in minutes)\n# Christopher is busy: 09:30-10:00, 10:30-11:00, 11:30-13:00, 15:00-15:30.\nchristopher_busy = [\n    (time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\"))\n]\n\n# Robert is busy: 09:30-10:00, 11:00-11:30, 12:00-12:30, 13:30-14:30, 15:00-15:30.\nrobert_busy = [\n    (time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"11:30\")),\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n    (time_to_minutes(\"13:30\"), time_to_minutes(\"14:30\")),\n    (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\"))\n]\n\n# Wayne is busy: 10:00-17:00.\nwayne_busy = [\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"17:00\"))\n]\n\n# Calculate free intervals for each participant.\nchristopher_free = subtract_busy(working_hours, christopher_busy)\nrobert_free = subtract_busy(working_hours, robert_busy)\nwayne_free = subtract_busy(working_hours, wayne_busy)\n\n# Compute the intersection of the free intervals for all three participants.\nfree_intersect = intersect_intervals(christopher_free, robert_free)\nfree_intersect = intersect_intervals(free_intersect, wayne_free)\n\n# Find the earliest interval that can accommodate the meeting duration.\nmeeting_time = None\nfor interval in free_intersect:\n    if interval[1] - interval[0] >= meeting_duration:\n        meeting_time = (interval[0], interval[0] + meeting_duration)\n        break\n\nif meeting_time:\n    start_str = minutes_to_time(meeting_time[0])\n    end_str = minutes_to_time(meeting_time[1])\n    # Output in the format {HH:MM:HH:MM}\n    print(f\"{{{start_str}:{end_str}}}\")\nelse:\n    print(\"No available slot found.\")\n'''",
            "count": "calendar_scheduling_example_96"
        },
        {
            "final_program_time": "{16:00:17:00}",
            "expected_time": "{16:00:17:00}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_str(m):\n    hours = m // 60\n    minutes = m % 60\n    return f\"{hours:02d}:{minutes:02d}\"\n\ndef subtract_interval(interval, busy):\n    # interval and busy are tuples (start, end) in minutes.\n    free_parts = []\n    start, end = interval\n    busy_start, busy_end = busy\n    \n    # No overlap\n    if busy_end <= start or busy_start >= end:\n        return [interval]\n    \n    # Busy covers entire interval\n    if busy_start <= start and busy_end >= end:\n        return []\n    \n    # Busy cuts the beginning\n    if busy_start <= start < busy_end < end:\n        free_parts.append((busy_end, end))\n        return free_parts\n    \n    # Busy cuts the end\n    if start < busy_start < end <= busy_end:\n        free_parts.append((start, busy_start))\n        return free_parts\n    \n    # Busy is in the middle, split into two parts\n    if start < busy_start and busy_end < end:\n        free_parts.append((start, busy_start))\n        free_parts.append((busy_end, end))\n        return free_parts\n\n    return [interval]\n\ndef subtract_busy(free_intervals, busy):\n    new_free = []\n    for interval in free_intervals:\n        new_free.extend(subtract_interval(interval, busy))\n    return new_free\n\ndef intersect_intervals(list1, list2):\n    result = []\n    i, j = 0, 0\n    while i < len(list1) and j < len(list2):\n        start1, end1 = list1[i]\n        start2, end2 = list2[j]\n        # Find overlap boundaries\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap < end_overlap:\n            result.append((start_overlap, end_overlap))\n        # Move pointer with earlier end\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef get_free_intervals(busy_intervals, work_start, work_end):\n    free = [(work_start, work_end)]\n    # Assume busy_intervals are sorted by start time\n    for busy in busy_intervals:\n        free = subtract_busy(free, busy)\n    return free\n\ndef main():\n    # Work hours on Monday: 9:00 to 17:00\n    work_start = 9 * 60   # 540 minutes\n    work_end = 17 * 60    # 1020 minutes\n\n    meeting_duration = 60  # minutes\n\n    # Busy intervals for each participant in minutes\n    # Joseph's busy: 9:00-10:00, 10:30-11:00, 12:30-13:00, 14:30-15:30\n    joseph_busy = [(9*60, 10*60),\n                   (10*60+30, 11*60),\n                   (12*60+30, 13*60),\n                   (14*60+30, 15*60+30)]\n    # Additionally, Joseph does not want to meet before 14:30, so his effective work start is 14:30.\n    joseph_pref = 14 * 60 + 30  # 870\n\n    # Kyle's busy: 12:30-13:30\n    kyle_busy = [(12*60+30, 13*60+30)]\n\n    # Joan's busy: 9:00-9:30, 10:00-10:30, 11:00-11:30, 12:30-14:00, 14:30-15:00, 15:30-16:00\n    joan_busy = [(9*60, 9*60+30),\n                 (10*60, 10*60+30),\n                 (11*60, 11*60+30),\n                 (12*60+30, 14*60),\n                 (14*60+30, 15*60),\n                 (15*60+30, 16*60)]\n\n    # Compute free intervals for each participant in the working day\n    joseph_free = get_free_intervals(joseph_busy, work_start, work_end)\n    # Enforce Joseph's preference: meeting can only start at or after 14:30.\n    joseph_free = [(max(interval[0], joseph_pref), interval[1]) for interval in joseph_free if interval[1] > joseph_pref]\n\n    kyle_free = get_free_intervals(kyle_busy, work_start, work_end)\n    joan_free = get_free_intervals(joan_busy, work_start, work_end)\n\n    # Find the intersection of the free intervals across all participants\n    intersect_joseph_kyle = intersect_intervals(joseph_free, kyle_free)\n    common_free = intersect_intervals(intersect_joseph_kyle, joan_free)\n\n    # Find the earliest interval that can accommodate the meeting duration\n    meeting_slot = None\n    for interval in common_free:\n        start, end = interval\n        if end - start >= meeting_duration:\n            meeting_slot = (start, start + meeting_duration)\n            break\n\n    if meeting_slot is not None:\n        start_str = minutes_to_str(meeting_slot[0])\n        end_str = minutes_to_str(meeting_slot[1])\n        # Output in the format HH:MM:HH:MM enclosed in braces.\n        print(\"{\" + f\"{start_str}:{end_str}\" + \"}\")\n    else:\n        print(\"No Possible Meeting Slot Found.\")\n\nif __name__ == \"__main__\":\n    main()\n'''",
            "count": "calendar_scheduling_example_97"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_time(minutes):\n    hrs = minutes // 60\n    mins = minutes % 60\n    return f\"{hrs:02d}:{mins:02d}\"\n\ndef is_free(busy_times, start, end):\n    # Check if the [start, end) interval overlaps any busy interval.\n    for bstart, bend in busy_times:\n        # If the meeting starts before a busy period ends and ends after it starts, they overlap.\n        if start < bend and end > bstart:\n            return False\n    return True\n\n# Define meeting duration in minutes\nmeeting_duration = 30\n\n# Define working time boundaries in minutes since midnight.\nwork_start = 9 * 60      # 09:00 -> 540 minutes\nwork_end   = 17 * 60     # 17:00 -> 1020 minutes\n\n# Additional constraint: for Juan, meeting must finish by 16:00.\njuan_latest_end = 16 * 60  # 16:00 -> 960 minutes\n# So the meeting must start no later than:\nlatest_start = min(work_end, juan_latest_end) - meeting_duration\n\n# Busy intervals (all times in minutes since midnight)\njuan_busy = [\n    (9 * 60, 10 * 60 + 30),  # 9:00 to 10:30 -> (540, 630)\n    (15 * 60 + 30, 16 * 60)  # 15:30 to 16:00 -> (930, 960)\n]\n\nmarilyn_busy = [\n    (11 * 60, 11 * 60 + 30),  # 11:00 to 11:30 -> (660, 690)\n    (12 * 60 + 30, 13 * 60)   # 12:30 to 13:00 -> (750, 780)\n]\n\nronald_busy = [\n    (9 * 60, 10 * 60 + 30),   # 9:00 to 10:30 -> (540, 630)\n    (12 * 60, 12 * 60 + 30),   # 12:00 to 12:30 -> (720, 750)\n    (13 * 60, 13 * 60 + 30),   # 13:00 to 13:30 -> (780, 810)\n    (14 * 60, 16 * 60 + 30)    # 14:00 to 16:30 -> (840, 990)\n]\n\n# Find earliest candidate start time (in minutes from midnight) that satisfies all constraints.\n# Iterate minute by minute from work_start to latest_start.\nproposed_start = None\nfor start in range(work_start, latest_start + 1):\n    end = start + meeting_duration\n    if end > work_end:\n        break\n    # Check Juan's availability\n    if not is_free(juan_busy, start, end):\n        continue\n    # Check Marilyn's availability\n    if not is_free(marilyn_busy, start, end):\n        continue\n    # Check Ronald's availability\n    if not is_free(ronald_busy, start, end):\n        continue\n    # If candidate is valid, select it and break out.\n    proposed_start = start\n    break\n\nif proposed_start is not None:\n    proposed_end = proposed_start + meeting_duration\n    start_str = minutes_to_time(proposed_start)\n    end_str = minutes_to_time(proposed_end)\n    # Output in the required HH:MM:HH:MM format.\n    print(f\"{start_str}:{end_str}\")\nelse:\n    print(\"No available meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_98"
        },
        {
            "final_program_time": "{15:00:16:00}",
            "expected_time": "{15:00:16:00}",
            "type_error": null,
            "full_response": "'''python\ndef minutes_to_str(m):\n    hours = m // 60\n    minutes = m % 60\n    return f\"{hours:02d}:{minutes:02d}\"\n\n# Define working hours in minutes since 00:00 (9:00 to 17:00)\nwork_start = 9 * 60   # 540\nwork_end = 17 * 60    # 1020\n\n# Meeting duration in minutes\nduration = 60\n\n# Constraint: Mark prefers meetings not before 15:00, so earliest start is 15:00\nearliest_start = 15 * 60  # 900\n\n# Define busy intervals in minutes for each participant\n# Stephanie busy: 9:00-9:30 (540-570) and 13:30-14:00 (810-840)\nstephanie_busy = [(540, 570), (810, 840)]\n# Scott busy: 9:00-10:00 (540-600), 11:00-12:30 (660-750), 14:30-15:00 (870-900), 16:00-17:00 (960-1020)\nscott_busy = [(540, 600), (660, 750), (870, 900), (960, 1020)]\n# Mark is free the entire day but prefers meeting after 15:00.\n\ndef is_free(start, end, busy_intervals):\n    \"\"\"Return True if interval [start, end] does not overlap any busy interval.\"\"\"\n    for b_start, b_end in busy_intervals:\n        # Check if [start, end] overlaps with busy interval\n        if not (end <= b_start or start >= b_end):\n            return False\n    return True\n\n# Starting from earliest possible start, try to schedule the meeting at the earliest availability.\n# Given the problem guarantees a solution, we'll check the candidate time.\ncandidate_start = earliest_start\ncandidate_end = candidate_start + duration\n\n# Check that candidate falls within working hours\nif candidate_end > work_end:\n    raise ValueError(\"Candidate meeting time exceeds working hours.\")\n\n# Check if candidate time is free for Stephanie and Scott\nif is_free(candidate_start, candidate_end, stephanie_busy) and is_free(candidate_start, candidate_end, scott_busy):\n    proposed_start = candidate_start\n    proposed_end = candidate_start + duration\n    # Output in the required format: {HH:MM:HH:MM}\n    print(\"{\" + minutes_to_str(proposed_start) + \":\" + minutes_to_str(proposed_end) + \"}\")\nelse:\n    # If the candidate does not work, then search minute-by-minute until an available slot is found.\n    found = False\n    for t in range(candidate_start + 1, work_end - duration + 1):\n        if is_free(t, t+duration, stephanie_busy) and is_free(t, t+duration, scott_busy):\n            proposed_start = t\n            proposed_end = t + duration\n            print(\"{\" + minutes_to_str(proposed_start) + \":\" + minutes_to_str(proposed_end) + \"}\")\n            found = True\n            break\n    if not found:\n        print(\"No available time\")\n'''",
            "count": "calendar_scheduling_example_99"
        }
    ]
}