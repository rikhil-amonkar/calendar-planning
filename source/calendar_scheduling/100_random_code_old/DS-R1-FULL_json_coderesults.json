{
    "0shot": [
        {
            "final_program_time": "{13:30:14:30}",
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedule, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    work_start, work_end = map(time_to_minutes, work_hours.split(' to '))\n    \n    # Generate busy slots for all participants\n    busy_slots = []\n    for schedule in participants_schedule.values():\n        for slot in schedule:\n            start, end = map(time_to_minutes, slot.split(' to '))\n            busy_slots.append((start, end))\n    \n    # Sort busy slots by start time\n    busy_slots.sort()\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in busy_slots:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the duration\n    duration_minutes = duration * 60\n    for slot in available_slots:\n        start, end = slot\n        if end - start >= duration_minutes:\n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration_minutes)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules and constraints\nparticipants_schedule = {\n    \"James\": [\"11:30 to 12:00\", \"14:30 to 15:00\"],\n    \"John\": [\"9:30 to 11:00\", \"11:30 to 12:00\", \"12:30 to 13:30\", \"14:30 to 16:30\"]\n}\nwork_hours = \"9:00 to 17:00\"\nduration = 1  # in hours\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedule, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_543"
        },
        {
            "final_program_time": null,
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Albert's busy times in minutes (start, end)\n    albert_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 30, 12 * 60),\n        (15 * 60, 16 * 30)\n    ]\n    # Albert cannot meet after 11:00 (11 * 60 minutes)\n    albert_no_meet_after = 11 * 60\n\n    # Deborah is free all day, so only Albert's constraints matter\n    # Generate possible slots between work hours, excluding busy times\n    possible_slots = []\n    previous_end = work_start\n\n    for busy_start, busy_end in sorted(albert_busy):\n        if busy_start > previous_end:\n            possible_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n\n    # Check the time after the last busy slot\n    if previous_end < work_end:\n        possible_slots.append((previous_end, work_end))\n\n    # Filter slots that are at least 30 minutes and before Albert's no-meet time\n    meeting_duration = 30\n    valid_slots = []\n    for slot_start, slot_end in possible_slots:\n        if slot_start >= albert_no_meet_after:\n            continue\n        if slot_end - slot_start >= meeting_duration:\n            valid_start = slot_start\n            valid_end = min(slot_start + meeting_duration, slot_end)\n            valid_slots.append((valid_start, valid_end))\n\n    # Select the earliest possible slot\n    if valid_slots:\n        meeting_start, meeting_end = valid_slots[0]\n        # Convert minutes back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No valid time slot found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_544"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time slots to minutes since start of the day\n    work_start = work_hours_start * 60\n    work_end = work_hours_end * 60\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Function to subtract busy slots from free slots\n    def subtract_busy_slots(free_slots, busy_start, busy_end):\n        new_free_slots = []\n        for slot_start, slot_end in free_slots:\n            if busy_start >= slot_end or busy_end <= slot_start:\n                new_free_slots.append((slot_start, slot_end))\n            else:\n                if slot_start < busy_start:\n                    new_free_slots.append((slot_start, busy_start))\n                if slot_end > busy_end:\n                    new_free_slots.append((busy_end, slot_end))\n        return new_free_slots\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            busy_start_min = busy_start[0] * 60 + busy_start[1]\n            busy_end_min = busy_end[0] * 60 + busy_end[1]\n            free_slots = subtract_busy_slots(free_slots, busy_start_min, busy_end_min)\n    \n    # Find the first slot that fits the duration\n    duration = duration_minutes\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules in (HH, MM) format\nparticipants_schedules = [\n    # Doris\n    [( (9, 0), (11, 0) ), ( (13, 30), (14, 0) ), ( (16, 0), (16, 30) )],\n    # Theresa\n    [( (10, 0), (12, 0) )],\n    # Christian (no meetings)\n    [],\n    # Terry\n    [( (9, 30), (10, 0) ), ( (11, 30), (12, 0) ), ( (12, 30), (13, 0) ), ( (13, 30), (14, 0) ), ( (14, 30), (15, 0) ), ( (15, 30), (17, 0) )],\n    # Carolyn\n    [( (9, 0), (10, 30) ), ( (11, 0), (11, 30) ), ( (12, 0), (13, 0) ), ( (13, 30), (14, 30) ), ( (15, 0), (17, 0) )],\n    # Kyle\n    [( (9, 0), (9, 30) ), ( (11, 30), (12, 0) ), ( (12, 30), (13, 0) ), ( (14, 30), (17, 0) )]\n]\n\n# Work hours and duration\nwork_hours_start = 9\nwork_hours_end = 17\nduration_minutes = 30\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes))\n```",
            "count": "calendar_scheduling_example_398"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Harold's busy times on Tuesday (in minutes since midnight)\n    harold_busy_tuesday = [\n        (9 * 60, 9 * 60 + 30),    # 9:00-9:30\n        (10 * 60 + 30, 11 * 60 + 30),  # 10:30-11:30\n        (12 * 60 + 30, 13 * 60 + 30),  # 12:30-13:30\n        (14 * 60 + 30, 15 * 60 + 30),  # 14:30-15:30\n        (16 * 60, 17 * 60)        # 16:00-17:00\n    ]\n\n    # Harold prefers Tuesday after 14:30, so we prioritize that\n    preferred_start = 14 * 60 + 30  # 14:30\n\n    # Check the preferred slot first (14:30-15:00)\n    slot_start = preferred_start\n    slot_end = slot_start + meeting_duration\n\n    # Check if the slot is within work hours and not busy\n    if slot_end <= work_end:\n        is_available = True\n        for busy_start, busy_end in harold_busy_tuesday:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                is_available = False\n                break\n        if is_available:\n            return f\"{slot_start // 60:02d}:{slot_start % 60:02d}:{slot_end // 60:02d}:{slot_end % 60:02d}\"\n\n    # If preferred slot is not available, check other times on Tuesday after 14:30\n    for busy_start, busy_end in sorted(harold_busy_tuesday):\n        if busy_start >= preferred_start:\n            slot_start = busy_end\n            slot_end = slot_start + meeting_duration\n            if slot_end > work_end:\n                continue\n            # Check if the slot is available\n            is_available = True\n            for other_start, other_end in harold_busy_tuesday:\n                if not (slot_end <= other_start or slot_start >= other_end):\n                    is_available = False\n                    break\n            if is_available:\n                return f\"{slot_start // 60:02d}:{slot_start % 60:02d}:{slot_end // 60:02d}:{slot_end % 60:02d}\"\n\n    # If no time after 14:30, check earlier on Tuesday (though Harold prefers to avoid)\n    for busy_start, busy_end in sorted(harold_busy_tuesday):\n        slot_start = busy_end\n        slot_end = slot_start + meeting_duration\n        if slot_end > work_end:\n            continue\n        # Check if the slot is available\n        is_available = True\n        for other_start, other_end in harold_busy_tuesday:\n            if not (slot_end <= other_start or slot_start >= other_end):\n                is_available = False\n                break\n        if is_available and slot_start >= work_start:\n            return f\"{slot_start // 60:02d}:{slot_start % 60:02d}:{slot_end // 60:02d}:{slot_end % 60:02d}\"\n\n    # Fallback (shouldn't reach here as per problem statement)\n    return \"No time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_625"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define busy intervals in minutes since midnight\n    jack_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    charlotte_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 13 * 60 + 30),\n        (14 * 60, 16 * 60)\n    ]\n\n    # Combine and sort all busy intervals\n    all_busy = jack_busy + charlotte_busy\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy intervals\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Filter free slots that are at least 30 minutes and meet Jack's preference (before 12:30)\n    meeting_duration = 30\n    suitable_slots = []\n    for start, end in free_slots:\n        if end - start >= meeting_duration and end <= 12 * 60 + 30:\n            suitable_slots.append((start, end))\n\n    # If no suitable slot before 12:30, check all free slots\n    if not suitable_slots:\n        for start, end in free_slots:\n            if end - start >= meeting_duration:\n                suitable_slots.append((start, end))\n\n    # Select the earliest suitable slot\n    if suitable_slots:\n        meeting_start = suitable_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Format the output as HH:MM:HH:MM\n        return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    else:\n        return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_502"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Nancy's busy times in minutes since start of day\n    nancy_busy = {\n        'Monday': [(10 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60 + 30),\n                   (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60 + 30),\n                   (16 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60 + 30, 10 * 60 + 30), (11 * 60, 11 * 60 + 30),\n                    (12 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30),\n                    (15 * 60 + 30, 16 * 60)],\n        'Wednesday': [(10 * 60, 11 * 60 + 30), (13 * 60 + 30, 16 * 60)]\n    }\n    \n    # Jose's busy times in minutes since start of day\n    jose_busy = {\n        'Monday': [(9 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 9 * 60 + 30), (10 * 60, 12 * 60 + 30),\n                     (13 * 60 + 30, 14 * 60 + 30), (15 * 60, 17 * 60)]\n    }\n    \n    meeting_duration = 30  # minutes\n    \n    for day in days:\n        # Collect all busy intervals for both participants\n        busy_intervals = nancy_busy.get(day, []) + jose_busy.get(day, [])\n        busy_intervals.sort()\n        \n        # Find free intervals\n        free_intervals = []\n        prev_end = work_start\n        \n        for start, end in busy_intervals:\n            if start > prev_end:\n                free_intervals.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_intervals.append((prev_end, work_end))\n        \n        # Check each free interval for availability\n        for start, end in free_intervals:\n            available_start = start\n            available_end = available_start + meeting_duration\n            \n            if available_end <= end:\n                # Format the time as HH:MM:HH:MM\n                start_hh = available_start // 60\n                start_mm = available_start % 60\n                end_hh = available_end // 60\n                end_mm = available_end % 60\n                \n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_798"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    meeting_duration = 30  # minutes\n\n    # Define busy times for each participant in minutes since midnight\n    # Format: {day: [(start1, end1), (start2, end2), ...]}\n    cheryl_busy = {\n        'Monday': [(9 * 60, 9 * 60 + 30), (11 * 60 + 30, 13 * 60), (15 * 60 + 30, 16 * 60)],\n        'Tuesday': [(15 * 60, 15 * 60 + 30)],\n        'Wednesday': []  # Cheryl cannot meet on Wednesday\n    }\n    kyle_busy = {\n        'Monday': [(9 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60 + 30, 17 * 60)],\n        'Wednesday': [(9 * 60, 9 * 60 + 30), (10 * 60, 13 * 60), (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 17 * 60)]\n    }\n\n    # Iterate through each day\n    for day in ['Monday', 'Tuesday']:  # Skip Wednesday as Cheryl cannot meet\n        # Combine and sort all busy intervals for the day\n        all_busy = cheryl_busy[day] + kyle_busy[day]\n        all_busy.sort()\n\n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n\n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= meeting_duration:\n                # Found a suitable slot\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_710"
        },
        {
            "final_program_time": null,
            "expected_time": "{13:30:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define busy intervals in minutes for each participant\n    anthony_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (12 * 60, 13 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    pamela_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    zachary_busy = [\n        (9 * 60, 11 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60, 17 * 60)\n    ]\n    \n    # Pamela's constraint: no meetings after 14:30\n    pamela_constraint = 14 * 60 + 30\n    \n    # Combine all busy intervals and constraints\n    def get_available_slots(busy_intervals, constraint=None):\n        slots = []\n        prev_end = work_start\n        for start, end in sorted(busy_intervals):\n            if start > prev_end:\n                slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            slots.append((prev_end, work_end))\n        if constraint:\n            slots = [(s, e) for s, e in slots if e <= constraint]\n        return slots\n    \n    anthony_slots = get_available_slots(anthony_busy)\n    pamela_slots = get_available_slots(pamela_busy, pamela_constraint)\n    zachary_slots = get_available_slots(zachary_busy)\n    \n    # Find overlapping slots\n    def find_overlap(slots1, slots2):\n        overlaps = []\n        i = j = 0\n        while i < len(slots1) and j < len(slots2):\n            s1, e1 = slots1[i]\n            s2, e2 = slots2[j]\n            overlap_start = max(s1, s2)\n            overlap_end = min(e1, e2)\n            if overlap_start < overlap_end:\n                overlaps.append((overlap_start, overlap_end))\n            if e1 < e2:\n                i += 1\n            else:\n                j += 1\n        return overlaps\n    \n    # Find overlap between all three\n    overlap_ap = find_overlap(anthony_slots, pamela_slots)\n    overlap_apz = find_overlap(overlap_ap, zachary_slots)\n    \n    # Find the first slot that can accommodate 1 hour (60 minutes)\n    meeting_duration = 60\n    for start, end in overlap_apz:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_25"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to make 9:00 as 0\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Initialize the free slots for the day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        new_free_slots = []\n        for slot in free_slots:\n            slot_start, slot_end = slot\n            # Get the participant's busy times\n            busy_times = []\n            for busy in schedule:\n                busy_start, busy_end = map(time_to_minutes, busy.split(' to '))\n                busy_times.append((busy_start, busy_end))\n            # Sort busy times\n            busy_times.sort()\n            # Find free intervals within the current slot\n            current_start = slot_start\n            for busy_start, busy_end in busy_times:\n                if busy_start > current_start:\n                    new_free_slots.append((current_start, busy_start))\n                current_start = max(current_start, busy_end)\n            if current_start < slot_end:\n                new_free_slots.append((current_start, slot_end))\n        # Update free_slots to the intersection\n        free_slots = new_free_slots\n    \n    # Find the first slot that can accommodate the meeting\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            meeting_start = minutes_to_time(slot_start)\n            meeting_end = minutes_to_time(slot_start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [],  # Tyler is free\n    [],  # Kelly is free\n    [\"11:00 to 11:30\", \"14:30 to 15:00\"],  # Stephanie\n    [],  # Hannah is free\n    [\"9:00 to 9:30\", \"10:00 to 12:00\", \"12:30 to 13:00\", \"14:00 to 17:00\"],  # Joe\n    [\"9:00 to 10:30\", \"11:30 to 12:00\", \"13:00 to 14:00\", \"14:30 to 15:30\", \"16:00 to 17:00\"],  # Diana\n    [\"9:00 to 10:00\", \"10:30 to 12:00\", \"12:30 to 13:00\", \"13:30 to 14:00\", \"14:30 to 15:30\", \"16:00 to 16:30\"],  # Deborah\n]\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_hours = \"9:00 to 17:00\"\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, duration, work_hours))\n```",
            "count": "calendar_scheduling_example_493"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define Nicole's busy times in minutes since midnight\n    nicole_busy = [\n        (9 * 60, 10 * 60),    # 9:00-10:00\n        (10.5 * 60, 16.5 * 60) # 10:30-16:30\n    ]\n    \n    # Nicole's preference: not before 16:00 (which is 16*60 minutes)\n    preferred_start = 16 * 60\n    \n    # Meeting duration in minutes\n    duration = 30\n    \n    # Judy is free all day, so we only need to consider Nicole's schedule\n    \n    # Check the time after Nicole's last meeting ends (16:30)\n    potential_start = nicole_busy[-1][1]  # 16:30\n    \n    # Check if it's after Nicole's preferred start time (16:00) and within work hours\n    if potential_start >= preferred_start and (potential_start + duration) <= work_end:\n        # Convert start and end times to HH:MM format\n        start_hh = potential_start // 60\n        start_mm = potential_start % 60\n        end_hh = (potential_start + duration) // 60\n        end_mm = (potential_start + duration) % 60\n        return f\"{int(start_hh):02d}:{int(start_mm):02d}:{int(end_hh):02d}:{int(end_mm):02d}\"\n    \n    # If no time found (though the problem states a solution exists)\n    return \"No time found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_548"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time slots to minutes since start of the day for easier handling\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n\n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules.values():\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort intervals by start time\n    busy_intervals.sort()\n\n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_end = max(end, last_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find the earliest gap that can fit the meeting\n    prev_end = work_start\n    for start, end in merged:\n        if start - prev_end >= duration:\n            meeting_start = prev_end\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n        prev_end = max(prev_end, end)\n    \n    # Check after the last busy interval\n    if work_end - prev_end >= duration:\n        meeting_start = prev_end\n        meeting_end = meeting_start + duration\n        return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return None\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"Megan\": [\"9:00 to 9:30\", \"10:00 to 11:00\", \"12:00 to 12:30\"],\n    \"Christine\": [\"9:00 to 9:30\", \"11:30 to 12:00\", \"13:00 to 14:00\", \"15:30 to 16:30\"],\n    \"Gabriel\": [],\n    \"Sara\": [\"11:30 to 12:00\", \"14:30 to 15:00\"],\n    \"Bruce\": [\"9:30 to 10:00\", \"10:30 to 12:00\", \"12:30 to 14:00\", \"14:30 to 15:00\", \"15:30 to 16:30\"],\n    \"Kathryn\": [\"10:00 to 15:30\", \"16:00 to 16:30\"],\n    \"Billy\": [\"9:00 to 9:30\", \"11:00 to 11:30\", \"12:00 to 14:00\", \"14:30 to 15:30\"],\n}\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, \"9:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_446"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define the duration of the meeting in minutes\n    duration = 30\n    \n    # Define the busy slots for each person in minutes since midnight\n    amy_busy = {\n        'Wednesday': [(11 * 60, 11 * 60 + 30), (13 * 60 + 30, 14 * 60)]\n    }\n    \n    pamela_busy = {\n        'Monday': [(9 * 60, 10 * 60 + 30), (11 * 60, 16 * 60 + 30)],\n        'Tuesday': [(9 * 60, 9 * 60 + 30), (10 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 9 * 60 + 30), (10 * 60, 11 * 60), \n                      (11 * 60 + 30, 13 * 60 + 30), (14 * 60 + 30, 15 * 60),\n                      (16 * 60, 16 * 60 + 30)]\n    }\n    \n    # Pamela's preferences: avoid Monday, Tuesday, and Wednesday before 16:00\n    # So we prioritize Wednesday after 16:00\n    preferred_day = 'Wednesday'\n    preferred_start = 16 * 60\n    \n    # Check preferred day and time first\n    if preferred_day in days:\n        # Generate time slots on preferred day after 16:00\n        start = max(work_start, preferred_start)\n        end = work_end\n        available_slots = []\n        \n        # Get busy times for both on preferred day\n        amy_busy_day = amy_busy.get(preferred_day, [])\n        pamela_busy_day = pamela_busy.get(preferred_day, [])\n        \n        # Merge and sort all busy intervals\n        all_busy = amy_busy_day + pamela_busy_day\n        all_busy.sort()\n        \n        # Find available slots\n        prev_end = start\n        for busy_start, busy_end in all_busy:\n            if busy_start > prev_end:\n                available_slots.append((prev_end, busy_start))\n            prev_end = max(prev_end, busy_end)\n        if prev_end < end:\n            available_slots.append((prev_end, end))\n        \n        # Check for a slot that fits the duration\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= duration:\n                # Convert to HH:MM format\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_hh = (slot_start + duration) // 60\n                end_mm = (slot_start + duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    # If preferred time not available, check other days and times\n    for day in days:\n        if day == preferred_day:\n            continue  # already checked\n        start = work_start\n        end = work_end\n        \n        # Get busy times for both on current day\n        amy_busy_day = amy_busy.get(day, [])\n        pamela_busy_day = pamela_busy.get(day, [])\n        \n        # Merge and sort all busy intervals\n        all_busy = amy_busy_day + pamela_busy_day\n        all_busy.sort()\n        \n        # Find available slots\n        available_slots = []\n        prev_end = start\n        for busy_start, busy_end in all_busy:\n            if busy_start > prev_end:\n                available_slots.append((prev_end, busy_start))\n            prev_end = max(prev_end, busy_end)\n        if prev_end < end:\n            available_slots.append((prev_end, end))\n        \n        # Check for a slot that fits the duration\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= duration:\n                # Convert to HH:MM format\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_hh = (slot_start + duration) // 60\n                end_mm = (slot_start + duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_786"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert each participant's busy slots to minutes\n    kimberly_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 12 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    marie_busy = [\n        (10 * 60, 11 * 60),\n        (11 * 60 + 30, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    diana_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 14 * 60 + 30),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    # Megan has no meetings but prefers to avoid before 10:00\n    megan_preferred_start = 10 * 60\n\n    # Combine all busy slots\n    all_busy = kimberly_busy + marie_busy + diana_busy\n\n    # Generate available slots by finding gaps in the schedule\n    all_busy.sort()  # Sort by start time\n    available_slots = []\n    prev_end = work_start\n\n    for start, end in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Filter slots that are at least 30 minutes and respect Megan's preference\n    meeting_duration = 30\n    possible_slots = []\n    for slot in available_slots:\n        start, end = slot\n        # Adjust start time if it's before Megan's preferred start\n        start = max(start, megan_preferred_start)\n        if end - start >= meeting_duration:\n            possible_slots.append((start, end))\n\n    # Select the earliest possible slot\n    if possible_slots:\n        chosen_slot = possible_slots[0]\n        start_time = chosen_slot[0]\n        end_time = start_time + meeting_duration\n        # Convert back to HH:MM format\n        start_hh = start_time // 60\n        start_mm = start_time % 60\n        end_hh = end_time // 60\n        end_mm = end_time % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_185"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday']\n\n    # Tyler's busy times in minutes since start of day\n    tyler_busy = {\n        'Tuesday': [(9 * 60, 9 * 60 + 30), (14 * 60 + 30, 15 * 60)],\n        'Wednesday': [(10 * 60 + 30, 11 * 60), (12 * 60 + 30, 13 * 60), \n                     (13 * 60 + 30, 14 * 60), (16 * 60 + 30, 17 * 60)]\n    }\n\n    # Ruth's busy times in minutes since start of day\n    ruth_busy = {\n        'Monday': [(9 * 60, 10 * 60), (10 * 60 + 30, 12 * 60), \n                   (12 * 60 + 30, 14 * 60 + 30), (15 * 60, 16 * 60), \n                   (16 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 17 * 60)]\n    }\n\n    # Tyler's preference to avoid Monday before 16:00\n    tyler_preference = {\n        'Monday': (16 * 60, work_end)\n    }\n\n    # Iterate through each day\n    for day in days:\n        # Check if day is Tuesday or Wednesday for Ruth's availability\n        if day in ['Tuesday', 'Wednesday']:\n            if day in ruth_busy and any(start == 9 * 60 and end == 17 * 60 for start, end in ruth_busy[day]):\n                continue  # Ruth is busy all day\n\n        # Generate all possible time slots for the day\n        slots = []\n        current_time = work_start\n        while current_time + meeting_duration <= work_end:\n            slots.append((current_time, current_time + meeting_duration))\n            current_time += meeting_duration\n\n        # Filter slots based on Tyler's busy times\n        available_slots = []\n        for slot in slots:\n            slot_start, slot_end = slot\n            conflict = False\n            if day in tyler_busy:\n                for busy_start, busy_end in tyler_busy[day]:\n                    if not (slot_end <= busy_start or slot_start >= busy_end):\n                        conflict = True\n                        break\n            if not conflict:\n                available_slots.append(slot)\n\n        # Filter slots based on Ruth's busy times\n        ruth_available_slots = []\n        for slot in available_slots:\n            slot_start, slot_end = slot\n            conflict = False\n            if day in ruth_busy:\n                for busy_start, busy_end in ruth_busy[day]:\n                    if not (slot_end <= busy_start or slot_start >= busy_end):\n                        conflict = True\n                        break\n            if not conflict:\n                ruth_available_slots.append(slot)\n\n        # Check Tyler's preference for Monday\n        if day == 'Monday':\n            preferred_slots = []\n            for slot in ruth_available_slots:\n                slot_start, slot_end = slot\n                if slot_start >= 16 * 60:  # After 16:00\n                    preferred_slots.append(slot)\n            ruth_available_slots = preferred_slots\n\n        # If there are available slots, return the first one\n        if ruth_available_slots:\n            slot = ruth_available_slots[0]\n            start_h = slot[0] // 60\n            start_m = slot[0] % 60\n            end_h = slot[1] // 60\n            end_m = slot[1] % 60\n            return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n\n    return \"No available time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_724"
        },
        {
            "final_program_time": "{14:30:15:00}",
            "expected_time": "{14:30:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\"]\n    meeting_duration = 30  # minutes\n\n    # Ruth's busy times in minutes since midnight for each day\n    ruth_busy = {\n        \"Monday\": [(9 * 60, 17 * 60)],\n        \"Tuesday\": [(9 * 60, 17 * 60)],\n        \"Wednesday\": [(9 * 60, 17 * 60)],\n        \"Thursday\": [(9 * 60, 11 * 60), (11 * 60 + 30, 14 * 60 + 30), (15 * 60, 17 * 60)],\n    }\n\n    # Julie's preference to avoid Thursday before 11:30\n    julie_preference = {\n        \"Thursday\": (9 * 60, 11 * 60 + 30)\n    }\n\n    # Iterate through each day to find a suitable time\n    for day in days:\n        if day not in ruth_busy:\n            continue  # Ruth is free all day (not the case here)\n\n        # Get Ruth's busy slots for the day\n        busy_slots = ruth_busy[day]\n        # Generate available slots for Ruth\n        available_slots = []\n        prev_end = work_hours_start\n\n        for start, end in sorted(busy_slots):\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_hours_end:\n            available_slots.append((prev_end, work_hours_end))\n\n        # Check Julie's preference for Thursday\n        if day == \"Thursday\":\n            avoid_start, avoid_end = julie_preference[\"Thursday\"]\n            # Filter out slots that overlap with Julie's preference to avoid\n            filtered_slots = []\n            for slot_start, slot_end in available_slots:\n                # Slot is entirely before or after the avoid time\n                if slot_end <= avoid_start or slot_start >= avoid_end:\n                    filtered_slots.append((slot_start, slot_end))\n                else:\n                    # Slot overlaps with avoid time, split or trim\n                    if slot_start < avoid_start:\n                        filtered_slots.append((slot_start, avoid_start))\n                    if slot_end > avoid_end:\n                        filtered_slots.append((avoid_end, slot_end))\n            available_slots = filtered_slots\n\n        # Check each available slot for a 30-minute window\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= meeting_duration:\n                # Found a suitable time\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                # Convert minutes back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_819"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:00:12:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_hour, end_hour = work_hours\n    # Convert work hours to minutes for easier calculation\n    start_time = start_hour * 60\n    end_time = end_hour * 60\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for block in schedule:\n            start = block[0] * 60\n            end = block[1] * 60\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append(interval)\n    \n    # Find available slots by checking gaps between busy intervals\n    available_slots = []\n    previous_end = start_time\n    \n    for interval in merged:\n        current_start, current_end = interval\n        if current_start > previous_end:\n            # There's a gap between previous_end and current_start\n            available_slots.append((previous_end, current_start))\n        previous_end = max(previous_end, current_end)\n    \n    # Check the gap after the last busy interval until end_time\n    if previous_end < end_time:\n        available_slots.append((previous_end, end_time))\n    \n    # Convert duration to minutes\n    duration_min = duration * 60\n    \n    # Find the first available slot that can fit the meeting\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            # Convert back to hours and minutes\n            start_h = meeting_start // 60\n            start_m = meeting_start % 60\n            end_h = meeting_end // 60\n            end_m = meeting_end % 60\n            return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules in 24-hour format\ngregory_schedule = [(9, 10), (10.5, 11.5), (12.5, 13), (13.5, 14)]\nnatalie_schedule = []\nchristine_schedule = [(9, 11.5), (13.5, 17)]\nvincent_schedule = [(9, 9.5), (10.5, 12), (12.5, 14), (14.5, 17)]\n\n# Combine all schedules\nparticipants_schedules = [gregory_schedule, natalie_schedule, christine_schedule, vincent_schedule]\n\n# Define work hours and meeting duration\nwork_hours = (9, 17)  # 9:00 to 17:00\nduration = 0.5  # half an hour\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_111"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Initialize the free slots for all participants\n    all_free_slots = []\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_slots.append((start, end))\n        \n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Calculate free slots\n        free_slots = []\n        prev_end = work_start\n        for start, end in busy_slots:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        all_free_slots.append(free_slots)\n    \n    # Find overlapping free slots\n    common_free_slots = []\n    # Start with the first participant's free slots\n    common_free_slots = all_free_slots[0]\n    \n    for participant_slots in all_free_slots[1:]:\n        new_common_slots = []\n        i = j = 0\n        while i < len(common_free_slots) and j < len(participant_slots):\n            slot1_start, slot1_end = common_free_slots[i]\n            slot2_start, slot2_end = participant_slots[j]\n            \n            # Find the overlap\n            overlap_start = max(slot1_start, slot2_start)\n            overlap_end = min(slot1_end, slot2_end)\n            \n            if overlap_start < overlap_end:\n                new_common_slots.append((overlap_start, overlap_end))\n            \n            # Move the pointer which ends first\n            if slot1_end < slot2_end:\n                i += 1\n            else:\n                j += 1\n        common_free_slots = new_common_slots\n    \n    # Find the first slot that can fit the duration\n    for slot_start, slot_end in common_free_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"9:00 to 9:30\", \"11:00 to 11:30\", \"12:00 to 12:30\", \"13:30 to 14:00\", \"16:00 to 17:00\"],  # Julie\n    [\"9:00 to 9:30\", \"13:00 to 13:30\", \"15:00 to 15:30\", \"16:00 to 16:30\"],  # Sean\n    [\"10:00 to 10:30\", \"11:00 to 13:00\", \"15:30 to 17:00\"],  # Lori\n]\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 60\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_42"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    participants = {\n        'Daniel': [],\n        'Kathleen': [('14:30', '15:30')],\n        'Carolyn': [('12:00', '12:30'), ('13:00', '13:30')],\n        'Roger': [],\n        'Cheryl': [('09:00', '09:30'), ('10:00', '11:30'), ('12:30', '13:30'), ('14:00', '17:00')],\n        'Virginia': [('09:30', '11:30'), ('12:00', '12:30'), ('13:00', '13:30'), ('14:30', '15:30'), ('16:00', '17:00')],\n        'Angela': [('09:30', '10:00'), ('10:30', '11:30'), ('12:00', '12:30'), ('13:00', '13:30'), ('14:00', '16:30')]\n    }\n    \n    work_start = '09:00'\n    work_end = '17:00'\n    duration = 30  # minutes\n    \n    # Roger's preference: not before 12:30\n    roger_preference_start = '12:30'\n    \n    # Convert time strings to minutes since 00:00 for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    roger_preference_min = time_to_minutes(roger_preference_start)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for person, intervals in participants.items():\n        for start, end in intervals:\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            busy_intervals.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals in the work day\n    free_intervals = []\n    prev_end = work_start_min\n    \n    # Adjust the start based on Roger's preference\n    if roger_preference_min > prev_end:\n        prev_end = roger_preference_min\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n    \n    # Find the first free interval that can accommodate the meeting duration\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_476"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Convert all schedules to minutes and mark busy intervals\n    busy_intervals = []\n    \n    # Melissa's schedule\n    busy_intervals.extend([(10*60, 11*60), (12*60 + 30, 14*60), (15*60, 15*60 + 30)])\n    \n    # Gregory's schedule\n    busy_intervals.extend([(12*60 + 30, 13*60), (15*60 + 30, 16*60)])\n    \n    # Victoria's schedule\n    busy_intervals.extend([(9*60, 9*60 + 30), (10*60 + 30, 11*60 + 30), (13*60, 14*60), \n                           (14*60 + 30, 15*60), (15*60 + 30, 16*60 + 30)])\n    \n    # Thomas's schedule\n    busy_intervals.extend([(10*60, 12*60), (12*60 + 30, 13*60), (14*60 + 30, 16*60)])\n    \n    # Jennifer's schedule\n    busy_intervals.extend([(9*60, 9*60 + 30), (10*60, 10*60 + 30), (11*60, 13*60), \n                           (13*60 + 30, 14*60 + 30), (15*60, 15*60 + 30), (16*60, 16*60 + 30)])\n    \n    # Wayne's preference: avoid before 14:00\n    preference_start = 14 * 60\n    \n    # Combine all busy intervals and sort\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append([start, end])\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1] = [last_start, max(last_end, end)]\n            else:\n                merged.append([start, end])\n    \n    # Find available slots after 14:00 (Wayne's preference)\n    available_slots = []\n    previous_end = max(work_start, preference_start)\n    \n    for start, end in merged:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Check for a 30-minute slot\n    meeting_duration = 30\n    for start, end in available_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_458"
        },
        {
            "final_program_time": "{11:00:12:00}",
            "expected_time": "{11:00:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Days to consider: Monday (0), Tuesday (1), Wednesday (2), Thursday (3), Friday (4)\n    days = [0, 1, 2, 3, 4]\n    \n    # Betty's constraints: day -> list of busy intervals (in minutes)\n    betty_busy = {\n        0: [(10*60, 10*60 + 30), (11*60 + 30, 12*60 + 30), (16*60, 16*60 + 30)],\n        1: [(9*60 + 30, 10*60), (10*60 + 30, 11*60), (12*60, 12*60 + 30), \n            (13*60 + 30, 15*60), (16*60 + 30, 17*60)],\n        2: [(13*60 + 30, 14*60), (14*60 + 30, 15*60)],\n        4: [(9*60, 10*60), (11*60 + 30, 12*60), (12*60 + 30, 13*60), (14*60 + 30, 15*60)]\n    }\n    \n    # Megan's constraints: day -> list of busy intervals (in minutes)\n    megan_busy = {\n        0: [(9*60, 17*60)],\n        1: [(9*60, 9*60 + 30), (10*60, 10*60 + 30), (12*60, 14*60), \n            (15*60, 15*60 + 30), (16*60, 16*60 + 30)],\n        2: [(9*60 + 30, 10*60 + 30), (11*60, 11*60 + 30), (12*60 + 30, 13*60), \n            (13*60 + 30, 14*60 + 30), (15*60 + 30, 17*60)],\n        3: [(9*60, 10*60 + 30), (11*60 + 30, 14*60), (14*60 + 30, 15*60), \n            (15*60 + 30, 16*60 + 30)],\n        4: [(9*60, 17*60)]\n    }\n    \n    # Betty cannot meet on Wednesday or Thursday\n    excluded_days_for_betty = [2, 3]\n    available_days = [day for day in days if day not in excluded_days_for_betty]\n    \n    # Iterate through available days and find a 1-hour slot\n    for day in available_days:\n        # Get busy intervals for both participants\n        betty_intervals = betty_busy.get(day, [])\n        megan_intervals = megan_busy.get(day, [])\n        \n        # Merge and sort all busy intervals\n        all_busy = betty_intervals + megan_intervals\n        all_busy.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check for a 1-hour slot\n        for start, end in free_slots:\n            if end - start >= 60:\n                meeting_start = start\n                meeting_end = start + 60\n                # Format the time as HH:MM:HH:MM\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_964"
        },
        {
            "final_program_time": "{16:30:17:00}",
            "expected_time": "{16:30:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Margaret's constraints (in minutes, converted from HH:MM)\n    margaret_unavailable = {\n        \"Monday\": [\n            (10 * 60 + 30, 11 * 60),      # 10:30-11:00\n            (11 * 60 + 30, 12 * 60),      # 11:30-12:00\n            (13 * 60, 13 * 60 + 30),     # 13:00-13:30\n            (15 * 60, 17 * 60)            # 15:00-17:00\n        ],\n        \"Tuesday\": [\n            (12 * 60, 12 * 60 + 30)      # 12:00-12:30\n        ]\n    }\n    \n    # Alexis's constraints (in minutes, converted from HH:MM)\n    alexis_unavailable = {\n        \"Monday\": [\n            (9 * 60 + 30, 11 * 60 + 30),  # 9:30-11:30\n            (12 * 60 + 30, 13 * 60),      # 12:30-13:00\n            (14 * 60, 17 * 60)            # 14:00-17:00\n        ],\n        \"Tuesday\": [\n            (9 * 60, 9 * 60 + 30),        # 9:00-9:30\n            (10 * 60, 10 * 60 + 30),      # 10:00-10:30\n            (14 * 60, 16 * 60 + 30)       # 14:00-16:30\n        ]\n    }\n    \n    # Margaret's preferences: not Monday, and Tuesday before 14:30\n    # So we only consider Tuesday, starting from 14:30 onwards\n    meeting_duration = 30\n    \n    # Check Tuesday for Margaret and Alexis\n    day = \"Tuesday\"\n    start_time = 14 * 60 + 30  # 14:30\n    \n    # Generate available slots for Margaret on Tuesday\n    margaret_slots = []\n    current_time = start_time\n    margaret_unavailable_tuesday = margaret_unavailable.get(day, [])\n    margaret_unavailable_tuesday.sort()  # Ensure sorted\n    \n    # Check from 14:30 onwards\n    for block in margaret_unavailable_tuesday:\n        if current_time >= block[1]:\n            continue\n        if current_time < block[0]:\n            margaret_slots.append((current_time, block[0]))\n        current_time = max(current_time, block[1])\n    \n    # Add remaining time until work_end\n    if current_time < work_end:\n        margaret_slots.append((current_time, work_end))\n    \n    # Generate available slots for Alexis on Tuesday\n    alexis_slots = []\n    current_time = start_time\n    alexis_unavailable_tuesday = alexis_unavailable.get(day, [])\n    alexis_unavailable_tuesday.sort()  # Ensure sorted\n    \n    # Check from 14:30 onwards\n    for block in alexis_unavailable_tuesday:\n        if current_time >= block[1]:\n            continue\n        if current_time < block[0]:\n            alexis_slots.append((current_time, block[0]))\n        current_time = max(current_time, block[1])\n    \n    # Add remaining time until work_end\n    if current_time < work_end:\n        alexis_slots.append((current_time, work_end))\n    \n    # Find overlapping slots\n    for m_slot in margaret_slots:\n        for a_slot in alexis_slots:\n            overlap_start = max(m_slot[0], a_slot[0])\n            overlap_end = min(m_slot[1], a_slot[1])\n            if overlap_end - overlap_start >= meeting_duration:\n                # Found a suitable slot\n                start_hour = overlap_start // 60\n                start_min = overlap_start % 60\n                end_hour = (overlap_start + meeting_duration) // 60\n                end_min = (overlap_start + meeting_duration) % 60\n                return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_629"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Robert's schedule: day -> list of (start, end) in minutes\n    robert_schedule = {\n        'Monday': [(11*60, 11*60+30), (14*60, 14*60+30), (15*60+30, 16*60)],\n        'Tuesday': [(10*60+30, 11*60), (15*60, 15*60+30)],\n        'Wednesday': [(10*60, 11*60), (11*60+30, 12*60), (12*60+30, 13*60), \n                      (13*60+30, 14*60), (15*60, 15*60+30), (16*60, 16*60+30)]\n    }\n    \n    # Ralph's schedule: day -> list of (start, end) in minutes\n    ralph_schedule = {\n        'Monday': [(10*60, 13*60+30), (14*60, 14*60+30), (15*60, 17*60)],\n        'Tuesday': [(9*60, 9*60+30), (10*60, 10*60+30), (11*60, 11*60+30),\n                    (12*60, 13*60), (14*60, 15*60+30), (16*60, 17*60)],\n        'Wednesday': [(10*60+30, 11*60), (11*60+30, 12*60), (13*60, 14*60+30),\n                     (16*60+30, 17*60)]\n    }\n    \n    meeting_duration = 30  # minutes\n    \n    # Iterate through days in order, skipping Monday if possible (Robert's preference)\n    for day in ['Tuesday', 'Wednesday', 'Monday']:\n        # Combine and sort all busy intervals for both participants\n        busy_intervals = []\n        # Add Robert's busy intervals\n        for interval in robert_schedule[day]:\n            busy_intervals.append((interval[0], interval[1], 'Robert'))\n        # Add Ralph's busy intervals\n        for interval in ralph_schedule[day]:\n            busy_intervals.append((interval[0], interval[1], 'Ralph'))\n        # Sort intervals by start time\n        busy_intervals.sort()\n        \n        # Find available slots by checking gaps between busy intervals\n        prev_end = work_start\n        for interval in busy_intervals:\n            start, end, _ = interval\n            if start > prev_end:\n                # Found a gap, check if it's long enough\n                if start - prev_end >= meeting_duration:\n                    # Return the earliest possible time in the gap\n                    return f\"{int(prev_end//60):02d}:{int(prev_end%60):02d}:{int((prev_end+meeting_duration)//60):02d}:{int((prev_end+meeting_duration)%60):02d}\"\n            # Update prev_end to the end of the current interval if it's later\n            if end > prev_end:\n                prev_end = end\n        # Check the gap after the last busy interval\n        if work_end - prev_end >= meeting_duration:\n            return f\"{int(prev_end//60):02d}:{int(prev_end%60):02d}:{int((prev_end+meeting_duration)//60):02d}:{int((prev_end+meeting_duration)%60):02d}\"\n    \n    # Shouldn't reach here as per problem statement\n    return \"No time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_702"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Convert each participant's busy slots to minutes\n    ryan_busy = [\n        (9 * 60, 9 * 60 + 30),   # 9:00-9:30\n        (12 * 60 + 30, 13 * 60)  # 12:30-13:00\n    ]\n    ruth_busy = []  # No meetings\n    denise_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),  # 9:30-10:30\n        (12 * 60, 13 * 60),           # 12:00-13:00\n        (14 * 60 + 30, 16 * 60 + 30)  # 14:30-16:30\n    ]\n    denise_no_meet_after = 12 * 60 + 30  # 12:30\n\n    # Combine all busy slots\n    all_busy = []\n    for slot in ryan_busy:\n        all_busy.append(('Ryan', slot[0], slot[1]))\n    for slot in ruth_busy:\n        all_busy.append(('Ruth', slot[0], slot[1]))\n    for slot in denise_busy:\n        all_busy.append(('Denise', slot[0], slot[1]))\n\n    # Sort all busy slots by start time\n    all_busy.sort(key=lambda x: x[1])\n\n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n\n    for busy in all_busy:\n        if busy[1] > prev_end:\n            available_slots.append((prev_end, busy[1]))\n        prev_end = max(prev_end, busy[2])\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Filter out slots that don't meet duration or Denise's constraint\n    valid_slots = []\n    for slot in available_slots:\n        start, end = slot\n        if end - start >= meeting_duration:\n            # Check if the slot starts before Denise's no-meet-after time\n            if start + meeting_duration <= denise_no_meet_after:\n                valid_slots.append(slot)\n\n    # Also check the slot after the last busy time if it's before denise_no_meet_after\n    if not valid_slots:\n        last_possible_start = denise_no_meet_after - meeting_duration\n        if last_possible_start >= work_start:\n            # Check if this slot is free for everyone\n            conflict = False\n            for busy in all_busy:\n                if busy[1] <= last_possible_start < busy[2] or \\\n                   busy[1] < last_possible_start + meeting_duration <= busy[2]:\n                    conflict = True\n                    break\n            if not conflict:\n                valid_slots.append((last_possible_start, last_possible_start + meeting_duration))\n\n    # Select the earliest valid slot\n    if valid_slots:\n        best_slot = valid_slots[0]\n        start_h = best_slot[0] // 60\n        start_m = best_slot[0] % 60\n        end_h = (best_slot[0] + meeting_duration) // 60\n        end_m = (best_slot[0] + meeting_duration) % 60\n        return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    else:\n        return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_36"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy_intervals = []\n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            all_busy_intervals.append((time_to_minutes(busy_start), time_to_minutes(busy_end)))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in all_busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability across all participants\n    candidate_intervals = []\n    for free_start, free_end in free_intervals:\n        if free_end - free_start >= duration_minutes:\n            candidate_intervals.append((free_start, free_end))\n    \n    # The first suitable interval is the earliest possible\n    if candidate_intervals:\n        meeting_start = candidate_intervals[0][0]\n        meeting_end = meeting_start + duration_minutes\n        return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    else:\n        return None\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [],  # Walter has no meetings\n    [(\"09:00\", \"09:30\"), (\"10:00\", \"10:30\"), (\"13:30\", \"14:30\"), (\"15:00\", \"16:00\")],  # Cynthia\n    [(\"10:00\", \"11:00\"), (\"13:00\", \"13:30\"), (\"14:00\", \"15:00\"), (\"16:00\", \"16:30\")],  # Ann\n    [(\"09:00\", \"11:30\"), (\"12:30\", \"13:30\"), (\"14:30\", \"17:00\")],  # Catherine\n    [(\"09:00\", \"09:30\"), (\"10:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"14:30\"), (\"15:00\", \"16:00\")],  # Kyle\n]\n\n# Find a 30-minute meeting between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, \"09:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_244"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours\n    start_min = time_to_minutes(start_work)\n    end_min = time_to_minutes(end_work)\n    \n    # Initialize a list to track busy intervals for all participants\n    busy_intervals = []\n    \n    for person, schedules in participants_schedules.items():\n        for interval in schedules:\n            start, end = interval\n            busy_start = time_to_minutes(start)\n            busy_end = time_to_minutes(end)\n            busy_intervals.append((busy_start, busy_end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots between merged busy intervals\n    available_slots = []\n    prev_end = start_min\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < end_min:\n        available_slots.append((prev_end, end_min))\n    \n    # Check each available slot for duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = minutes_to_time(slot_start)\n            meeting_end = minutes_to_time(slot_start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"Gregory\": [(\"9:00\", \"9:30\"), (\"11:30\", \"12:00\")],\n    \"Jonathan\": [(\"9:00\", \"9:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"13:30\"), (\"15:00\", \"16:00\"), (\"16:30\", \"17:00\")],\n    \"Barbara\": [(\"10:00\", \"10:30\"), (\"13:30\", \"14:00\")],\n    \"Jesse\": [(\"10:00\", \"11:00\"), (\"12:30\", \"14:30\")],\n    \"Alan\": [(\"9:30\", \"11:00\"), (\"11:30\", \"12:30\"), (\"13:00\", \"15:30\"), (\"16:00\", \"17:00\")],\n    \"Nicole\": [(\"9:00\", \"10:30\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:30\"), (\"14:00\", \"17:00\")],\n    \"Catherine\": [(\"9:00\", \"10:30\"), (\"12:00\", \"13:30\"), (\"15:00\", \"15:30\"), (\"16:00\", \"16:30\")]\n}\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_hours = (\"9:00\", \"17:00\")\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, duration, work_hours))\n```",
            "count": "calendar_scheduling_example_473"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:30:10:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(lisa_busy, anthony_busy, work_start, work_end, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        h = minutes // 60\n        m = minutes % 60\n        return f\"{h:02d}:{m:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Generate busy slots in minutes for Lisa and Anthony\n    def parse_busy_slots(busy_slots):\n        slots = []\n        for slot in busy_slots:\n            start, end = slot.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            slots.append((start_min, end_min))\n        return slots\n    \n    lisa_busy_min = parse_busy_slots(lisa_busy)\n    anthony_busy_min = parse_busy_slots(anthony_busy)\n    \n    # Combine and sort all busy slots\n    all_busy = lisa_busy_min + anthony_busy_min\n    all_busy.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = work_start_min\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        free_slots.append((prev_end, work_end_min))\n    \n    # Find the earliest slot that fits the duration\n    for start, end in free_slots:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Given data\nlisa_busy = [\"9:00 to 9:30\", \"10:30 to 11:00\", \"14:00 to 16:00\"]\nanthony_busy = [\"9:00 to 9:30\", \"11:00 to 11:30\", \"12:30 to 13:30\", \"14:00 to 15:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"]\nwork_start = \"9:00\"\nwork_end = \"17:00\"\nduration = 0.5  # half an hour\n\n# Find the meeting time\nmeeting_time = find_meeting_time(lisa_busy, anthony_busy, work_start, work_end, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_583"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday']\n    \n    # Define Jesse's busy times in minutes since midnight\n    jesse_busy = {\n        'Monday': [\n            (13 * 60 + 30, 14 * 60),      # 13:30-14:00\n            (14 * 60 + 30, 15 * 60)       # 14:30-15:00\n        ],\n        'Tuesday': [\n            (9 * 60, 9 * 60 + 30),         # 9:00-9:30\n            (13 * 60, 13 * 60 + 30),       # 13:00-13:30\n            (14 * 60, 15 * 60)             # 14:00-15:00\n        ]\n    }\n    \n    # Define Lawrence's busy times in minutes since midnight\n    lawrence_busy = {\n        'Monday': [\n            (9 * 60, 17 * 60)              # 9:00-17:00 (entire day)\n        ],\n        'Tuesday': [\n            (9 * 60 + 30, 10 * 60 + 30),   # 9:30-10:30\n            (11 * 60 + 30, 12 * 60 + 30),  # 11:30-12:30\n            (13 * 60, 13 * 60 + 30),      # 13:00-13:30\n            (14 * 60 + 30, 15 * 60),       # 14:30-15:00\n            (15 * 60 + 30, 16 * 60 + 30)   # 15:30-16:30\n        ]\n    }\n    \n    # Lawrence cannot meet on Tuesday after 16:30\n    lawrence_constraint = {\n        'Tuesday': 16 * 60 + 30  # 16:30\n    }\n    \n    meeting_duration = 30  # minutes\n    \n    # Iterate through each day\n    for day in days:\n        # Skip Monday for Lawrence as he's busy all day\n        if day == 'Monday':\n            continue\n        \n        # Get busy intervals for both participants\n        jesse_intervals = jesse_busy.get(day, [])\n        lawrence_intervals = lawrence_busy.get(day, [])\n        \n        # Combine and sort all busy intervals\n        all_busy = jesse_intervals + lawrence_intervals\n        all_busy.sort()\n        \n        # Check the constraint for Lawrence on Tuesday\n        if day == 'Tuesday':\n            work_end = min(work_end, lawrence_constraint['Tuesday'])\n        \n        # Find free slots\n        prev_end = work_start\n        for start, end in all_busy:\n            if start > prev_end:\n                # Check if there's enough time for the meeting\n                if start - prev_end >= meeting_duration:\n                    # Found a suitable slot\n                    meeting_start = prev_end\n                    meeting_end = meeting_start + meeting_duration\n                    # Format the output as HH:MM:HH:MM\n                    return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after the last busy interval\n        if work_end - prev_end >= meeting_duration:\n            meeting_start = prev_end\n            meeting_end = meeting_start + meeting_duration\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_652"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:00:16:30}",
            "type_error": "SyntaxError",
            "full_response": "```python\n'''\nThis script finds a suitable meeting time for Betty and Scott based on their schedules and constraints.\n'''",
            "count": "calendar_scheduling_example_867"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, meeting_duration, days):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = map(time_to_minutes, work_hours.split(' to '))\n    meeting_duration_min = time_to_minutes(f\"{meeting_duration}:00\") - time_to_minutes(\"0:00\")\n    \n    for day in days:\n        # Collect all busy intervals for the day for all participants\n        busy_intervals = []\n        for participant in participants_schedules:\n            for meeting in participant.get(day, []):\n                start, end = map(time_to_minutes, meeting.split(' to '))\n                busy_intervals.append((start, end))\n        \n        # Sort all busy intervals by start time\n        busy_intervals.sort()\n        \n        # Merge overlapping or adjacent intervals\n        merged = []\n        for start, end in busy_intervals:\n            if not merged:\n                merged.append((start, end))\n            else:\n                last_start, last_end = merged[-1]\n                if start <= last_end:\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged[-1] = (new_start, new_end)\n                else:\n                    merged.append((start, end))\n        \n        # Find available slots between work hours and busy intervals\n        available_slots = []\n        prev_end = work_start\n        \n        for start, end in merged:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n        \n        # Check each available slot for sufficient duration\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= meeting_duration_min:\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration_min\n                return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    {\n        \"Monday\": [\"10:00 to 10:30\", \"11:30 to 12:00\", \"13:00 to 13:30\", \"14:30 to 15:30\", \"16:00 to 16:30\"],\n        \"Tuesday\": [\"10:00 to 10:30\", \"11:00 to 12:00\", \"14:00 to 16:00\", \"16:30 to 17:00\"]\n    },\n    {\n        \"Monday\": [\"9:00 to 17:00\"],\n        \"Tuesday\": [\"11:00 to 11:30\", \"12:00 to 12:30\", \"13:00 to 14:00\", \"14:30 to 15:00\", \"15:30 to 17:00\"]\n    }\n]\n\n# Define constraints\nwork_hours = \"9:00 to 17:00\"\nmeeting_duration = 1  # hour\ndays = [\"Monday\", \"Tuesday\"]\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, meeting_duration, days)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_626"
        },
        {
            "final_program_time": "{9:30:10:30}",
            "expected_time": "{9:30:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Convert each person's busy slots to minutes\n    busy_slots = {\n        'Joshua': [(11 * 60, 12 * 60 + 30), (13 * 60 + 30, 14 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n        'Jerry': [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60), \n                  (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60)],\n        'Jesse': [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60), \n                  (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60 + 30)],\n        'Kenneth': [(10 * 60 + 30, 12 * 60 + 30), (13 * 60 + 30, 14 * 60), \n                    (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)],\n    }\n\n    # Collect all busy slots\n    all_busy = []\n    for person in busy_slots:\n        all_busy.extend(busy_slots[person])\n    \n    # Sort all busy slots by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for slot in free_slots:\n        start, end = slot\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_479"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Define schedules for Mary and Alexis in minutes since midnight\n    mary_schedule = {\n        'Tuesday': [(10 * 60, 10 * 60 + 30), (15 * 60 + 30, 16 * 60)],\n        'Wednesday': [(9 * 60 + 30, 10 * 60), (15 * 60, 15 * 60 + 30)],\n        'Thursday': [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60 + 30)],\n    }\n    \n    alexis_schedule = {\n        'Monday': [(9 * 60, 10 * 60), (10 * 60 + 30, 12 * 60), (12 * 60 + 30, 16 * 60 + 30)],\n        'Tuesday': [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60 + 30), (12 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 11 * 60), (11 * 60 + 30, 17 * 60)],\n        'Thursday': [(10 * 60, 12 * 60), (14 * 60, 14 * 60 + 30), (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)],\n    }\n    \n    # Check each day in order\n    for day in days:\n        # Get both schedules for the day\n        mary_busy = mary_schedule.get(day, [])\n        alexis_busy = alexis_schedule.get(day, [])\n        \n        # Combine and sort all busy intervals\n        all_busy = mary_busy + alexis_busy\n        all_busy.sort()\n        \n        # Find free slots by checking gaps between busy intervals\n        prev_end = work_start\n        for start, end in all_busy:\n            if start > prev_end:\n                # Found a free slot\n                free_start = prev_end\n                free_end = start\n                if free_end - free_start >= 30:  # Meeting duration is 30 minutes\n                    # Convert back to HH:MM format\n                    start_hh = free_start // 60\n                    start_mm = free_start % 60\n                    end_hh = (free_start + 30) // 60\n                    end_mm = (free_start + 30) % 60\n                    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy interval\n        if work_end - prev_end >= 30:\n            start_hh = prev_end // 60\n            start_mm = prev_end % 60\n            end_hh = (prev_end + 30) // 60\n            end_mm = (prev_end + 30) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_812"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:11:30}",
            "type_error": "SyntaxError",
            "full_response": "```python\n'''\nThis script finds a suitable meeting time for Eugene and Eric based on their schedules and constraints.\n'''",
            "count": "calendar_scheduling_example_938"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{14:00:15:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Define busy intervals in minutes since midnight for each day and participant\n    russell_busy = {\n        'Monday': [(10 * 60 + 30, 11 * 60)],  # 10:30-11:00\n        'Tuesday': [(13 * 60, 13 * 60 + 30)]  # 13:00-13:30\n    }\n    \n    alexander_busy = {\n        'Monday': [\n            (9 * 60, 11 * 60 + 30),  # 9:00-11:30\n            (12 * 60, 14 * 60 + 30), # 12:00-14:30\n            (15 * 60, 17 * 60)        # 15:00-17:00\n        ],\n        'Tuesday': [\n            (9 * 60, 10 * 60),        # 9:00-10:00\n            (13 * 60, 14 * 60),       # 13:00-14:00\n            (15 * 60, 15 * 60 + 30),  # 15:00-15:30\n            (16 * 60, 16 * 60 + 30)   # 16:00-16:30\n        ]\n    }\n\n    # Russell's preference: not before 13:30 on Tuesday\n    russell_preference_start = 13 * 60 + 30  # 13:30 in minutes\n\n    # Check Monday first\n    day = 'Monday'\n    # Get all busy intervals for both participants on Monday\n    busy_intervals = russell_busy.get(day, []) + alexander_busy.get(day, [])\n    # Sort intervals by start time\n    busy_intervals.sort()\n    \n    # Find free slots on Monday\n    previous_end = work_start\n    for start, end in busy_intervals:\n        if start > previous_end:\n            # Check if the slot is long enough\n            if start - previous_end >= meeting_duration:\n                # Found a suitable slot\n                meeting_start = previous_end\n                meeting_end = meeting_start + meeting_duration\n                # Format the output\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n        previous_end = max(previous_end, end)\n    # Check after the last busy interval\n    if work_end - previous_end >= meeting_duration:\n        meeting_start = previous_end\n        meeting_end = meeting_start + meeting_duration\n        return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    # Check Tuesday if Monday didn't work\n    day = 'Tuesday'\n    # Get all busy intervals for both participants on Tuesday\n    busy_intervals = russell_busy.get(day, []) + alexander_busy.get(day, [])\n    # Sort intervals by start time\n    busy_intervals.sort()\n    \n    # Find free slots on Tuesday, respecting Russell's preference\n    previous_end = max(work_start, russell_preference_start)\n    for start, end in busy_intervals:\n        if start > previous_end:\n            # Check if the slot is long enough\n            if start - previous_end >= meeting_duration:\n                # Found a suitable slot\n                meeting_start = previous_end\n                meeting_end = meeting_start + meeting_duration\n                # Format the output\n                return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n        previous_end = max(previous_end, end)\n    # Check after the last busy interval\n    if work_end - previous_end >= meeting_duration:\n        meeting_start = previous_end\n        meeting_end = meeting_start + meeting_duration\n        return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    # If no slot found (though the problem states there is one)\n    return \"No suitable time found\"\n\n# Run the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_678"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define each participant's busy times in minutes\n    adam_busy = [(14 * 60, 15 * 60)]\n    john_busy = [(13 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30), \n                 (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)]\n    stephanie_busy = [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 11 * 60),\n                      (11 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)]\n    anna_busy = [(9 * 60 + 30, 10 * 60), (12 * 60, 12 * 60 + 30),\n                 (13 * 60, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)]\n    \n    # Anna's preference: not before 14:30\n    anna_preference_start = 14 * 60 + 30\n\n    # Combine all busy times\n    all_busy = adam_busy + john_busy + stephanie_busy + anna_busy\n\n    # Generate free slots by finding gaps between busy times\n    # Start checking from max(work_start, anna_preference_start)\n    current_time = max(work_start, anna_preference_start)\n    meeting_duration = 30  # minutes\n\n    # Iterate through possible slots\n    while current_time + meeting_duration <= work_end:\n        slot_start = current_time\n        slot_end = slot_start + meeting_duration\n\n        # Check if the slot is free for everyone\n        conflict = False\n        for busy_start, busy_end in all_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                conflict = True\n                break\n        \n        if not conflict:\n            # Format the time as HH:MM:HH:MM\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n        \n        # Move to the next possible start time\n        current_time += 1\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_116"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Parse work hours\n    work_start, work_end = work_hours.split(' to ')\n    work_start = int(work_start.replace(':', ''))\n    work_end = int(work_end.replace(':', ''))\n    \n    # Generate all possible time slots within work hours in 30-minute increments\n    time_slots = []\n    current_time = work_start\n    while current_time + duration <= work_end:\n        # Convert current_time back to HHMM format for comparison\n        start_time = current_time\n        end_time = start_time + duration\n        time_slots.append((start_time, end_time))\n        # Increment by 30 minutes (50 in HHMM format)\n        current_time += 50\n        # Handle hour transition (e.g., 0950 -> 1000)\n        if str(current_time)[-2:] == '50':\n            current_time += 50\n    \n    # Check each time slot against participants' schedules\n    for slot in time_slots:\n        slot_start, slot_end = slot\n        valid = True\n        for person, schedules in participants_schedules.items():\n            if schedules == \"wide open the entire day\" or schedules == \"no meetings the whole day\":\n                continue\n            for busy_start, busy_end in schedules:\n                busy_start = int(busy_start.replace(':', ''))\n                busy_end = int(busy_end.replace(':', ''))\n                # Check if slot overlaps with any busy period\n                if not (slot_end <= busy_start or slot_start >= busy_end):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            # Format the time as HH:MM\n            start_str = f\"{str(slot_start)[:2]}:{str(slot_start)[2:]}\"\n            end_str = f\"{str(slot_end)[:2]}:{str(slot_end)[2:]}\"\n            return f\"{start_str}:{end_str}\"\n    return \"No available time slot found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"Andrew\": \"wide open the entire day\",\n    \"Grace\": \"no meetings the whole day\",\n    \"Samuel\": [(\"09:00\", \"10:30\"), (\"11:30\", \"12:00\"), (\"13:00\", \"13:30\"), (\"14:00\", \"16:00\"), (\"16:30\", \"17:00\")]\n}\n\n# Define work hours and meeting duration\nwork_hours = \"9:00 to 17:00\"\nduration = 30  # minutes\n\n# Find the earliest available meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_45"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define the participants' schedules and constraints\n    ryan_busy = {\n        'Monday': [(9*60+30, 10*60), (11*60, 12*60), (13*60, 13*60+30), (15*60+30, 16*60)],\n        'Tuesday': [(11*60+30, 12*60+30), (15*60+30, 16*60)],\n        'Wednesday': [(12*60, 13*60), (15*60+30, 16*60), (16*60+30, 17*60)],\n    }\n    \n    adam_busy = {\n        'Monday': [(9*60, 10*60+30), (11*60, 13*60+30), (14*60, 16*60), (16*60+30, 17*60)],\n        'Tuesday': [(9*60, 10*60), (10*60+30, 15*60+30), (16*60, 17*60)],\n        'Wednesday': [(9*60, 9*60+30), (10*60, 11*60), (11*60+30, 14*60+30), (15*60, 15*60+30), (16*60, 16*60+30)],\n    }\n    \n    # Apply constraints: Ryan cannot meet on Wednesday, Adam avoids Monday before 14:30\n    ryan_busy.pop('Wednesday', None)\n    adam_busy_adjusted = adam_busy.copy()\n    adam_busy_adjusted['Monday'] = [slot for slot in adam_busy['Monday'] if slot[0] >= 14*60+30]\n    \n    meeting_duration = 30  # minutes\n    \n    # Iterate through each day to find a suitable time\n    for day in ['Monday', 'Tuesday']:\n        # Combine both participants' busy times for the day and sort\n        busy_times = []\n        if day in ryan_busy:\n            busy_times.extend(ryan_busy[day])\n        if day in adam_busy_adjusted:\n            busy_times.extend(adam_busy_adjusted[day])\n        busy_times.sort()\n        \n        # Find free slots by checking gaps between busy times\n        previous_end = work_hours_start\n        for start, end in busy_times:\n            if start > previous_end:\n                if start - previous_end >= meeting_duration:\n                    # Found a suitable slot\n                    meeting_start = previous_end\n                    meeting_end = meeting_start + meeting_duration\n                    return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n            previous_end = max(previous_end, end)\n        \n        # Check after the last busy time\n        if work_hours_end - previous_end >= meeting_duration:\n            meeting_start = previous_end\n            meeting_end = meeting_start + meeting_duration\n            return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_707"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    all_busy_intervals = []\n    for schedule in participants_schedules:\n        busy_intervals = []\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            busy_intervals.append((start, end))\n        all_busy_intervals.append(busy_intervals)\n    \n    # Find all possible meeting start times in 1-minute increments\n    for start in range(work_start, work_end - duration_minutes + 1):\n        end = start + duration_minutes\n        valid = True\n        # Check against each participant's schedule\n        for busy_intervals in all_busy_intervals:\n            for busy_start, busy_end in busy_intervals:\n                if not (end <= busy_start or start >= busy_end):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return f\"{minutes_to_time(start)}:{minutes_to_time(end)}\"\n    return \"No valid time found\"\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"09:30 to 10:30\", \"13:30 to 14:30\"],  # Andrea\n    [\"12:30 to 13:00\", \"15:00 to 15:30\"],  # Ruth\n    [\"10:00 to 10:30\", \"11:00 to 11:30\", \"12:00 to 12:30\", \"13:30 to 14:00\", \"15:00 to 16:00\"],  # Steven\n    [],  # Grace\n    [\"09:00 to 09:30\", \"10:30 to 12:00\", \"12:30 to 13:00\", \"13:30 to 15:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"],  # Kyle\n    [\"09:00 to 11:00\", \"11:30 to 13:00\", \"13:30 to 14:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"],  # Elijah\n    [\"09:00 to 09:30\", \"10:00 to 11:30\", \"12:00 to 13:30\", \"14:00 to 16:00\", \"16:30 to 17:00\"],  # Lori\n]\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, \"09:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_457"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participant_busy_slots, work_hours_start, work_hours_end, meeting_duration, days):\n    for day in days:\n        # Initialize available slots as the entire work day\n        available_slots = [(work_hours_start, work_hours_end)]\n        \n        # Get busy slots for the current day\n        busy_slots = participant_busy_slots.get(day, [])\n        \n        # Subtract busy slots from available slots\n        for busy_start, busy_end in busy_slots:\n            new_available_slots = []\n            for avail_start, avail_end in available_slots:\n                if busy_start >= avail_end or busy_end <= avail_start:\n                    # No overlap, keep the available slot\n                    new_available_slots.append((avail_start, avail_end))\n                else:\n                    # Overlap, split the available slot\n                    if avail_start < busy_start:\n                        new_available_slots.append((avail_start, busy_start))\n                    if avail_end > busy_end:\n                        new_available_slots.append((busy_end, avail_end))\n            available_slots = new_available_slots\n        \n        # Check for a slot that can fit the meeting\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= meeting_duration:\n                # Return the earliest possible slot\n                return f\"{slot_start:02d}:00-{slot_start + meeting_duration:02d}:00\"\n    \n    return \"No available time slot found\"\n\n# Define participant's busy slots\nroy_busy_slots = {\n    \"Monday\": [\n        (10, 11.5),\n        (12, 13),\n        (14, 14.5),\n        (15, 17)\n    ],\n    \"Tuesday\": [\n        (10.5, 11.5),\n        (12, 14.5),\n        (15, 15.5),\n        (16, 17)\n    ],\n    \"Wednesday\": [\n        (9.5, 11.5),\n        (12.5, 14),\n        (14.5, 15.5),\n        (16.5, 17)\n    ]\n}\n\n# Define meeting parameters\nwork_hours_start = 9\nwork_hours_end = 17\nmeeting_duration = 1  # in hours\ndays_to_check = [\"Monday\", \"Tuesday\", \"Wednesday\"]\n\n# Find the earliest available time\nmeeting_time = find_meeting_time(roy_busy_slots, work_hours_start, work_hours_end, meeting_duration, days_to_check)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_773"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Convert blocked times to minutes since midnight\n    margaret_blocked = [\n        (9 * 60, 10 * 60),    # 9:00-10:00\n        (10 * 60 + 30, 11 * 60),  # 10:30-11:00\n        (11 * 60 + 30, 12 * 60),  # 11:30-12:00\n        (13 * 60, 13 * 60 + 30),  # 13:00-13:30\n        (15 * 60, 15 * 60 + 30)   # 15:00-15:30\n    ]\n    donna_blocked = [\n        (14 * 60 + 30, 15 * 60),  # 14:30-15:00\n        (16 * 60, 16 * 60 + 30)   # 16:00-16:30\n    ]\n    helen_blocked = [\n        (9 * 60, 9 * 60 + 30),    # 9:00-9:30\n        (10 * 60, 11 * 60 + 30),   # 10:00-11:30\n        (13 * 60, 14 * 60),        # 13:00-14:00\n        (14 * 60 + 30, 15 * 60),   # 14:30-15:00\n        (15 * 60 + 30, 17 * 60)    # 15:30-17:00\n    ]\n    helen_no_meet_after = 13 * 60 + 30  # 13:30\n\n    # Duration in minutes\n    duration = 30\n\n    # Generate all possible slots within work hours\n    for start in range(work_start, work_end - duration + 1):\n        end = start + duration\n        # Check Margaret's availability\n        margaret_available = True\n        for block_start, block_end in margaret_blocked:\n            if not (end <= block_start or start >= block_end):\n                margaret_available = False\n                break\n        if not margaret_available:\n            continue\n\n        # Check Donna's availability\n        donna_available = True\n        for block_start, block_end in donna_blocked:\n            if not (end <= block_start or start >= block_end):\n                donna_available = False\n                break\n        if not donna_available:\n            continue\n\n        # Check Helen's availability and preference\n        helen_available = True\n        for block_start, block_end in helen_blocked:\n            if not (end <= block_start or start >= block_end):\n                helen_available = False\n                break\n        if not helen_available:\n            continue\n        if start >= helen_no_meet_after:\n            continue\n\n        # If all checks passed, return the time slot\n        start_hour = start // 60\n        start_min = start % 60\n        end_hour = end // 60\n        end_min = end % 60\n        return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_17"
        },
        {
            "final_program_time": "{15:30:16:00}",
            "expected_time": "{15:30:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Convert all schedules to minutes since midnight\n    # Each person's busy times are represented as a list of (start, end) tuples in minutes\n    schedules = {\n        'Shirley': [(10*60 + 30, 11*60), (12*60, 12*60 + 30)],\n        'Jacob': [(9*60, 9*60 + 30), (10*60, 10*60 + 30), (11*60, 11*60 + 30), \n                  (12*60 + 30, 13*60 + 30), (14*60 + 30, 15*60)],\n        'Stephen': [(11*60 + 30, 12*60), (12*60 + 30, 13*60)],\n        'Margaret': [(9*60, 9*60 + 30), (10*60 + 30, 12*60 + 30), (13*60, 13*60 + 30), \n                     (15*60, 15*60 + 30), (16*60 + 30, 17*60)],\n        'Mason': [(9*60, 10*60), (10*60 + 30, 11*60), (11*60 + 30, 12*60 + 30), \n                  (13*60, 13*60 + 30), (14*60, 14*60 + 30), (16*60 + 30, 17*60)],\n    }\n    \n    # Margaret's constraint: not before 14:30\n    margaret_constraint = 14 * 60 + 30\n    \n    # Generate all busy intervals for all participants\n    all_busy = []\n    for person, busy_times in schedules.items():\n        all_busy.extend(busy_times)\n    \n    # Add Margaret's constraint as a busy time before 14:30\n    all_busy.append((work_start, margaret_constraint))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Find the first available 30-minute slot\n    meeting_duration = 30\n    previous_end = work_start\n    \n    for start, end in merged_busy:\n        if start - previous_end >= meeting_duration:\n            # Found a slot\n            meeting_start = previous_end\n            meeting_end = meeting_start + meeting_duration\n            # Convert back to HH:MM format\n            return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n        previous_end = max(previous_end, end)\n    \n    # Check after the last busy interval\n    if work_end - previous_end >= meeting_duration:\n        meeting_start = previous_end\n        meeting_end = meeting_start + meeting_duration\n        return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n    \n    return \"No available time slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_206"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define each person's busy times in minutes (start, end)\n    stephanie_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    cheryl_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    bradley_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 11 * 60 + 30),\n        (13 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    steven_busy = [\n        (9 * 60, 12 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 17 * 60)\n    ]\n\n    # Combine all busy times\n    all_busy = stephanie_busy + cheryl_busy + bradley_busy + steven_busy\n\n    # Sort busy times by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = work_start\n\n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n\n    # Check the slot after the last busy time\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check each free slot for availability of all participants\n    meeting_duration = 60  # 1 hour in minutes\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Check if the slot is free for everyone\n            valid = True\n            # Stephanie\n            for s_start, s_end in stephanie_busy:\n                if not (slot_start >= s_end or slot_start + meeting_duration <= s_start):\n                    valid = False\n                    break\n            if not valid:\n                continue\n            # Cheryl\n            for c_start, c_end in cheryl_busy:\n                if not (slot_start >= c_end or slot_start + meeting_duration <= c_start):\n                    valid = False\n                    break\n            if not valid:\n                continue\n            # Bradley\n            for b_start, b_end in bradley_busy:\n                if not (slot_start >= b_end or slot_start + meeting_duration <= b_start):\n                    valid = False\n                    break\n            if not valid:\n                continue\n            # Steven\n            for st_start, st_end in steven_busy:\n                if not (slot_start >= st_end or slot_start + meeting_duration <= st_start):\n                    valid = False\n                    break\n            if valid:\n                # Convert minutes back to HH:MM format\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_hh = (slot_start + meeting_duration) // 60\n                end_mm = (slot_start + meeting_duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_114"
        },
        {
            "final_program_time": null,
            "expected_time": "{12:00:12:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 9 * 60  # Subtract 9:00 (540 minutes)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 9 * 60 + minutes\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    work_start, work_end = map(time_to_minutes, work_hours.split(':'))\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that fits the duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules in HH:MM format\nmichael_schedule = [\"09:30:10:30\", \"15:00:15:30\", \"16:00:16:30\"]\neric_schedule = []\narthur_schedule = [\"09:00:12:00\", \"13:00:15:00\", \"15:30:16:00\", \"16:30:17:00\"]\n\nparticipants_schedules = [michael_schedule, eric_schedule, arthur_schedule]\nmeeting_duration = 30  # minutes\nwork_hours = \"9:00:17:00\"\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, meeting_duration, work_hours))\n```",
            "count": "calendar_scheduling_example_82"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define busy intervals for each participant in minutes\n    busy = {\n        'Christine': [(570, 630), (720, 750), (780, 810), (870, 900), (960, 990)],\n        'Bobby': [(720, 750), (870, 900)],\n        'Elizabeth': [(540, 570), (690, 780), (810, 840), (900, 930), (960, 1020)],\n        'Tyler': [(540, 660), (720, 750), (780, 810), (930, 960), (990, 1020)],\n        'Edward': [(540, 570), (600, 660), (690, 840), (870, 930), (960, 1020)],\n    }\n    \n    # Janice's preference: not after 13:00 (780 minutes)\n    janice_preference_end = 13 * 60\n    \n    # Generate all busy intervals\n    all_busy = []\n    for person in busy:\n        all_busy.extend(busy[person])\n    \n    # Add Janice's preference as a \"busy\" interval after 13:00\n    all_busy.append((janice_preference_end, work_end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in all_busy:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_end = max(end, last_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots (gaps between busy intervals)\n    available = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available.append((prev_end, work_end))\n    \n    # Find the first available slot that is at least 30 minutes long\n    meeting_duration = 30\n    for start, end in available:\n        if end - start >= meeting_duration:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = (start + meeting_duration) // 60\n            end_mm = (start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_304"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 0 at 9:00\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours\n    start_min = time_to_minutes(start_work)\n    end_min = time_to_minutes(end_work)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = busy\n            busy_start = time_to_minutes(start)\n            busy_end = time_to_minutes(end)\n            busy_intervals.append((busy_start, busy_end))\n    \n    # Sort busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find free slots between merged busy intervals\n    free_slots = []\n    prev_end = start_min\n    for start, end in merged:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < end_min:\n        free_slots.append((prev_end, end_min))\n    \n    # Check each free slot for duration availability\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = minutes_to_time(slot_start)\n            meeting_end = minutes_to_time(slot_start + duration)\n            return f\"{meeting_start}:{meeting_end}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [(\"13:00\", \"13:30\"), (\"16:00\", \"16:30\")],  # Judy\n    [(\"10:00\", \"10:30\"), (\"12:00\", \"13:00\"), (\"14:00\", \"14:30\")],  # Olivia\n    [],  # Eric\n    [(\"10:00\", \"10:30\"), (\"15:00\", \"15:30\")],  # Jacqueline\n    [(\"09:00\", \"10:00\"), (\"10:30\", \"12:00\"), (\"13:00\", \"13:30\"), (\"14:30\", \"15:00\"), (\"15:30\", \"17:00\")],  # Laura\n    [(\"09:00\", \"10:00\"), (\"11:00\", \"11:30\"), (\"12:30\", \"13:00\"), (\"14:00\", \"14:30\"), (\"15:30\", \"17:00\")],  # Tyler\n    [(\"09:30\", \"10:30\"), (\"11:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"13:30\"), (\"14:00\", \"14:30\"), (\"16:00\", \"17:00\")],  # Lisa\n]\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\n# Work hours\nwork_hours = (\"09:00\", \"17:00\")\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, duration, work_hours))\n```",
            "count": "calendar_scheduling_example_429"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{13:00:13:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define John's constraints (no meetings after 14:30 on Monday)\n    john_constraints = {\n        'Monday': (14 * 60 + 30, work_end),  # After 14:30\n        'Tuesday': (work_start, work_end),    # Whole day\n        'Wednesday': (work_start, work_end)   # Whole day\n    }\n    \n    # Define Jennifer's meetings in minutes since midnight\n    jennifer_schedule = {\n        'Monday': [\n            (9 * 60, 11 * 60),\n            (11 * 60 + 30, 13 * 60),\n            (13 * 60 + 30, 14 * 60 + 30),\n            (15 * 60, 17 * 60)\n        ],\n        'Tuesday': [\n            (9 * 60, 11 * 60 + 30),\n            (12 * 60, 17 * 60)\n        ],\n        'Wednesday': [\n            (9 * 60, 11 * 60 + 30),\n            (12 * 60, 12 * 60 + 30),\n            (13 * 60, 14 * 60),\n            (14 * 60 + 30, 16 * 60),\n            (16 * 60 + 30, 17 * 60)\n        ]\n    }\n    \n    meeting_duration = 30  # minutes\n    \n    # Iterate through each day\n    for day in days:\n        # Get John's unavailable time for the day\n        john_unavailable_start, john_unavailable_end = john_constraints[day]\n        \n        # Jennifer's busy times for the day\n        jennifer_busy = jennifer_schedule[day]\n        \n        # Generate available slots for Jennifer\n        available_slots = []\n        prev_end = work_start\n        \n        for start, end in sorted(jennifer_busy):\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n        \n        # Check each available slot against John's constraints\n        for slot_start, slot_end in available_slots:\n            # Adjust slot to fit meeting duration\n            if slot_end - slot_start < meeting_duration:\n                continue\n            \n            # Check if slot is within John's constraints\n            if day == 'Monday' and slot_start >= john_unavailable_start:\n                continue  # John wants to avoid after 14:30 on Monday\n            \n            # Find the earliest possible start time in the slot\n            meeting_start = max(slot_start, work_start)\n            meeting_end = meeting_start + meeting_duration\n            \n            if meeting_end <= slot_end:\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_776"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all times to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Initialize the free slots for the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's busy times\n    for busy_times in participants_busy_times:\n        new_free_slots = []\n        for busy_start, busy_end in busy_times:\n            busy_start_min = time_to_minutes(busy_start)\n            busy_end_min = time_to_minutes(busy_end)\n            updated_free_slots = []\n            for slot_start, slot_end in free_slots:\n                if busy_end_min <= slot_start or busy_start_min >= slot_end:\n                    # No overlap, keep the slot as is\n                    updated_free_slots.append((slot_start, slot_end))\n                else:\n                    # There is an overlap, split the slot\n                    if slot_start < busy_start_min:\n                        updated_free_slots.append((slot_start, busy_start_min))\n                    if busy_end_min < slot_end:\n                        updated_free_slots.append((busy_end_min, slot_end))\n            free_slots = updated_free_slots\n        if not free_slots:\n            return None  # No possible slot\n    \n    # Find the first slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    return None\n\n# Define the busy times for each participant\nparticipants_busy_times = [\n    # Jacob's busy times\n    [(\"13:30\", \"14:00\"), (\"14:30\", \"15:00\")],\n    # Diana's busy times\n    [(\"09:30\", \"10:00\"), (\"11:30\", \"12:00\"), (\"13:00\", \"13:30\"), (\"16:00\", \"16:30\")],\n    # Adam's busy times\n    [(\"09:30\", \"10:30\"), (\"11:00\", \"12:30\"), (\"15:30\", \"16:00\")],\n    # Angela's busy times\n    [(\"09:30\", \"10:00\"), (\"10:30\", \"12:00\"), (\"13:00\", \"15:30\"), (\"16:00\", \"16:30\")],\n    # Dennis's busy times\n    [(\"09:00\", \"09:30\"), (\"10:30\", \"11:30\"), (\"13:00\", \"15:00\"), (\"16:30\", \"17:00\")],\n]\n\n# Find a meeting time\nmeeting_time = find_meeting_time(participants_busy_times, \"09:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_246"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_hours):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by merging all busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Check each free interval for availability\n    duration_minutes = duration_hours * 60\n    for start, end in free_intervals:\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            return (minutes_to_time(meeting_start), minutes_to_time(meeting_end))\n    \n    return None\n\n# Define participants' schedules\ndanielle_schedule = [\n    \"9:00 to 10:00\",\n    \"10:30 to 11:00\",\n    \"14:30 to 15:00\",\n    \"15:30 to 16:00\",\n    \"16:30 to 17:00\"\n]\n\nbruce_schedule = [\n    \"11:00 to 11:30\",\n    \"12:30 to 13:00\",\n    \"14:00 to 14:30\",\n    \"15:30 to 16:00\"\n]\n\neric_schedule = [\n    \"9:00 to 9:30\",\n    \"10:00 to 11:00\",\n    \"11:30 to 13:00\",\n    \"14:30 to 15:30\"\n]\n\nparticipants_schedules = [danielle_schedule, bruce_schedule, eric_schedule]\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_hours = 1\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_hours)\nprint(f\"{meeting_time[0]}:{meeting_time[1]}\")\n```",
            "count": "calendar_scheduling_example_91"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    duration = 30         # meeting duration in minutes\n\n    # Convert each person's busy slots to minutes\n    busy_slots = {\n        'Jose': [(11 * 60, 11 * 60 + 30), (12 * 60 + 30, 13 * 60)],\n        'Keith': [(14 * 60, 14 * 60 + 30), (15 * 60, 15 * 60 + 30)],\n        'Logan': [(9 * 60, 10 * 60), (12 * 60, 12 * 60 + 30), (15 * 60, 15 * 60 + 30)],\n        'Megan': [(9 * 60, 10 * 60 + 30), (11 * 60, 12 * 60), (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 16 * 60 + 30)],\n        'Gary': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (11 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 16 * 60 + 30)],\n        'Bobby': [(11 * 60, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (13 * 60, 16 * 60)],\n    }\n\n    # Jose's constraint: no meetings after 15:30\n    jose_constraint = 15 * 60 + 30\n\n    # Combine all busy slots\n    all_busy = []\n    for person in busy_slots:\n        for start, end in busy_slots[person]:\n            all_busy.append((start, end))\n    all_busy.sort()\n\n    # Find free slots by inverting busy slots\n    free_slots = []\n    prev_end = work_start\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n\n    # Filter free slots that meet duration and Jose's constraint\n    valid_slots = []\n    for start, end in free_slots:\n        if end - start >= duration and start + duration <= jose_constraint:\n            valid_slots.append((start, end))\n\n    # Find the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No valid slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_325"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:00:14:30}",
            "type_error": "TypeError",
            "full_response": "```python\nfrom datetime import time\n\ndef find_meeting_time(daniel_busy, bradley_busy, work_hours_start, work_hours_end, duration, preferences):\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n    time_slots = []\n    \n    for day in days:\n        if day in preferences['Daniel']['avoid_days'] or day in preferences['Bradley']['avoid_days']:\n            continue\n        \n        daniel_day_busy = daniel_busy.get(day, [])\n        bradley_day_busy = bradley_busy.get(day, [])\n        \n        current_time = work_hours_start\n        while current_time < work_hours_end:\n            slot_end = current_time + duration\n            if slot_end > work_hours_end:\n                break\n            \n            # Check Daniel's availability\n            daniel_available = True\n            for busy_start, busy_end in daniel_day_busy:\n                if not (slot_end <= busy_start or current_time >= busy_end):\n                    daniel_available = False\n                    break\n            \n            # Check Bradley's availability\n            bradley_available = True\n            for busy_start, busy_end in bradley_day_busy:\n                if not (slot_end <= busy_start or current_time >= busy_end):\n                    bradley_available = False\n                    break\n            \n            if daniel_available and bradley_available:\n                if day == 'Tuesday' and current_time < preferences['Bradley']['tuesday_before']:\n                    pass\n                else:\n                    time_slots.append((day, current_time, slot_end))\n            \n            current_time += duration\n    \n    return time_slots[0] if time_slots else None\n\n# Define work hours and meeting duration\nwork_hours_start = time(9, 0)\nwork_hours_end = time(17, 0)\nduration = 30  # minutes\n\n# Define busy schedules\ndaniel_busy = {\n    'Monday': [(time(9, 30), time(10, 30)), (time(12, 0), time(12, 30)), (time(13, 0), time(14, 0)), \n               (time(14, 30), time(15, 0)), (time(15, 30), time(16, 0))],\n    'Tuesday': [(time(11, 0), time(12, 0)), (time(13, 0), time(13, 30)), (time(15, 30), time(16, 0)),\n                (time(16, 30), time(17, 0))],\n    'Wednesday': [(time(9, 0), time(10, 0)), (time(14, 0), time(14, 30))],\n    'Thursday': [(time(10, 30), time(11, 0)), (time(12, 0), time(13, 0)), (time(14, 30), time(15, 0)),\n                 (time(15, 30), time(16, 0))],\n    'Friday': [(time(9, 0), time(9, 30)), (time(11, 30), time(12, 0)), (time(13, 0), time(13, 30)),\n               (time(16, 30), time(17, 0))]\n}\n\nbradley_busy = {\n    'Monday': [(time(9, 30), time(11, 0)), (time(11, 30), time(12, 0)), (time(12, 30), time(13, 0)),\n               (time(14, 0), time(15, 0))],\n    'Tuesday': [(time(10, 30), time(11, 0)), (time(12, 0), time(13, 0)), (time(13, 30), time(14, 0)),\n                (time(15, 30), time(16, 30))],\n    'Wednesday': [(time(9, 0), time(10, 0)), (time(11, 0), time(13, 0)), (time(13, 30), time(14, 0)),\n                  (time(14, 30), time(17, 0))],\n    'Thursday': [(time(9, 0), time(12, 30)), (time(13, 30), time(14, 0)), (time(14, 30), time(15, 0)),\n                 (time(15, 30), time(16, 30))],\n    'Friday': [(time(9, 0), time(9, 30)), (time(10, 0), time(12, 30)), (time(13, 0), time(13, 30)),\n               (time(14, 0), time(14, 30)), (time(15, 30), time(16, 30))]\n}\n\n# Define preferences\npreferences = {\n    'Daniel': {\n        'avoid_days': ['Wednesday', 'Thursday']\n    },\n    'Bradley': {\n        'avoid_days': ['Monday', 'Friday'],\n        'tuesday_before': time(12, 0)\n    }\n}\n\n# Find meeting time\nmeeting_time = find_meeting_time(daniel_busy, bradley_busy, work_hours_start, work_hours_end, duration, preferences)\n\n# Output the result\nif meeting_time:\n    day, start, end = meeting_time\n    print(f\"{start.hour:02d}:{start.minute:02d}:{end.hour:02d}:{end.minute:02d}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_904"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    bradley_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    teresa_busy = [\n        (10 * 60 + 30, 11 * 60),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60)\n    ]\n    elizabeth_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 11 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    christian_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60 + 30, 17 * 60)\n    ]\n\n    # Combine all busy slots\n    all_busy = bradley_busy + teresa_busy + elizabeth_busy + christian_busy\n\n    # Generate potential time slots\n    potential_slots = []\n    current_time = work_start\n\n    while current_time + meeting_duration <= work_end:\n        slot_start = current_time\n        slot_end = current_time + meeting_duration\n        conflict = False\n\n        # Check for conflicts with any busy slot\n        for busy_start, busy_end in all_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                conflict = True\n                break\n\n        if not conflict:\n            potential_slots.append((slot_start, slot_end))\n\n        current_time += 15  # Check every 15 minutes for efficiency\n\n    # Select the first available slot\n    if potential_slots:\n        meeting_start, meeting_end = potential_slots[0]\n    else:\n        return \"No available slot found\"\n\n    # Convert back to HH:MM format\n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n\n    start_time = minutes_to_time(meeting_start)\n    end_time = minutes_to_time(meeting_end)\n\n    return f\"{start_time}:{end_time}\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_113"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time slots to minutes since start of the day for easier calculation\n    start_min = work_hours_start * 60\n    end_min = work_hours_end * 60\n    duration = duration_minutes\n    \n    # Initialize the free slots for the entire work day\n    free_slots = [(start_min, end_min)]\n    \n    # Function to subtract busy slots from free slots\n    def subtract_busy(free_slots, busy_start, busy_end):\n        new_free_slots = []\n        for slot_start, slot_end in free_slots:\n            if busy_start >= slot_end or busy_end <= slot_start:\n                new_free_slots.append((slot_start, slot_end))\n            else:\n                if slot_start < busy_start:\n                    new_free_slots.append((slot_start, busy_start))\n                if slot_end > busy_end:\n                    new_free_slots.append((busy_end, slot_end))\n        return new_free_slots\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            busy_start_min = busy_start[0] * 60 + busy_start[1]\n            busy_end_min = busy_end[0] * 60 + busy_end[1]\n            free_slots = subtract_busy(free_slots, busy_start_min, busy_end_min)\n    \n    # Find the earliest slot that fits the duration\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Define participants' schedules in HH:MM format converted to tuples of (HH, MM)\nparticipants_schedules = [\n    # Joe's schedule\n    [((9, 30), (10, 00)), ((10, 30), (11, 00))],\n    # Keith's schedule\n    [((11, 30), (12, 00)), ((15, 00), (15, 30))],\n    # Patricia's schedule\n    [((9, 00), (9, 30)), ((13, 00), (13, 30))],\n    # Nancy's schedule\n    [((9, 00), (11, 00)), ((11, 30), (16, 30))],\n    # Pamela's schedule\n    [((9, 00), (10, 00)), ((10, 30), (11, 00)), ((11, 30), (12, 30)), \n     ((13, 00), (14, 00)), ((14, 30), (15, 00)), ((15, 30), (16, 00)), \n     ((16, 30), (17, 00))],\n]\n\n# Work hours from 9:00 to 17:00 (5:00 PM)\nwork_hours_start = 9\nwork_hours_end = 17\nmeeting_duration = 30  # minutes\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_266"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert each person's busy slots to minutes\n    emily_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    melissa_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (14 * 60 + 30, 15 * 60)\n    ]\n    frank_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (13 * 60 + 30, 14 * 60 + 30),\n        (15 * 60, 16 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    # Frank doesn't want to meet after 9:30, so his availability is only before 9:30\n    frank_constraint = 9 * 60 + 30\n\n    # Combine all busy times and constraints\n    all_busy = emily_busy + melissa_busy + frank_busy\n    all_busy.append((frank_constraint, work_end))  # Frank is unavailable after 9:30\n\n    # Sort all busy times by start time\n    all_busy.sort()\n\n    # Find free slots\n    free_slots = []\n    previous_end = work_start\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate 30 minutes\n    meeting_duration = 30\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_32"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday']\n    \n    # Define busy slots for Jean and Doris in minutes since midnight\n    jean_busy = {\n        'Tuesday': [(11 * 60 + 30, 12 * 60), (16 * 60, 16 * 60 + 30)]\n    }\n    \n    doris_busy = {\n        'Monday': [(9 * 60, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), \n                   (13 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60, 17 * 60)]\n    }\n    \n    # Doris prefers not to meet on Monday after 14:00\n    doris_preference = {\n        'Monday': (9 * 60, 14 * 60)\n    }\n    \n    meeting_duration = 30  # minutes\n    \n    # Iterate through each day\n    for day in days:\n        # Check if day is Tuesday for Jean's availability\n        if day == 'Tuesday' and day not in jean_busy:\n            continue\n        \n        # Get Doris's preference for the day\n        day_start, day_end = doris_preference.get(day, (work_start, work_end))\n        \n        # Get busy slots for Jean and Doris on this day\n        jean_slots = jean_busy.get(day, [])\n        doris_slots = doris_busy.get(day, [])\n        \n        # Combine and sort all busy slots\n        all_busy = jean_slots + doris_slots\n        all_busy.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = day_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < day_end:\n            free_slots.append((prev_end, day_end))\n        \n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= meeting_duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_669"
        },
        {
            "final_program_time": "{10:30:11:30}",
            "expected_time": "{10:30:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n    \n    # Nicole's schedule: {day: [(start, end), ...]}\n    nicole_schedule = {\n        'Tuesday': [(16 * 60, 16 * 60 + 30)],\n        'Wednesday': [(15 * 60, 15 * 60 + 30)],\n        'Friday': [(12 * 60, 12 * 60 + 30), (15 * 60 + 30, 16 * 60)]\n    }\n    \n    # Daniel's schedule: {day: [(start, end), ...]}\n    daniel_schedule = {\n        'Monday': [(9 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60, 16 * 60 + 30)],\n        'Tuesday': [(9 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), \n                    (15 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Wednesday': [(9 * 60, 10 * 60), (11 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), \n                      (14 * 60, 14 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n        'Thursday': [(11 * 60, 12 * 60), (13 * 60, 14 * 60), (15 * 60, 15 * 60 + 30)],\n        'Friday': [(10 * 60, 11 * 60), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 14 * 60 + 30), \n                   (15 * 60, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)]\n    }\n    \n    meeting_duration = 60  # 1 hour\n    \n    for day in days:\n        # Collect all busy intervals for Nicole and Daniel on this day\n        nicole_busy = nicole_schedule.get(day, [])\n        daniel_busy = daniel_schedule.get(day, [])\n        \n        # Merge and sort all busy intervals\n        all_busy = nicole_busy + daniel_busy\n        all_busy.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            available_start = slot_start\n            available_end = slot_end\n            \n            if available_end - available_start >= meeting_duration:\n                # Convert minutes back to HH:MM format\n                start_hh = available_start // 60\n                start_mm = available_start % 60\n                end_hh = (available_start + meeting_duration) // 60\n                end_mm = (available_start + meeting_duration) % 60\n                \n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found.\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_975"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Arthur's schedule: day -> list of (start, end) in minutes\n    arthur_schedule = {\n        'Monday': [(11 * 60, 11 * 60 + 30), (13 * 60 + 30, 14 * 60), (15 * 60, 15 * 60 + 30)],\n        'Tuesday': [(13 * 60, 13 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n        'Wednesday': [(10 * 60, 10 * 60 + 30), (11 * 60, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (14 * 60, 14 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n    }\n    \n    # Michael's schedule: day -> list of (start, end) in minutes\n    michael_schedule = {\n        'Monday': [(9 * 60, 12 * 60), (12 * 60 + 30, 13 * 60), (14 * 60, 14 * 60 + 30), (15 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60 + 30, 11 * 60 + 30), (12 * 60, 13 * 60 + 30), (14 * 60, 15 * 60 + 30)],\n        'Wednesday': [(10 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30)],\n    }\n    \n    # Arthur cannot meet on Tuesday\n    days_to_check = [day for day in days if day != 'Tuesday']\n    \n    for day in days_to_check:\n        # Collect all busy times for both participants\n        busy_times = arthur_schedule.get(day, []) + michael_schedule.get(day, [])\n        busy_times.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in busy_times:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for a 30-minute window\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= 30:\n                meeting_start = slot_start\n                meeting_end = meeting_start + 30\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_723"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define days to check\n    days = ['Monday', 'Tuesday']\n    \n    # Define Shirley's busy times in minutes since midnight\n    shirley_busy = {\n        'Monday': [\n            (10 * 60 + 30, 11 * 60),    # 10:30-11:00\n            (12 * 60, 12 * 60 + 30),    # 12:00-12:30\n            (16 * 60, 16 * 60 + 30)      # 16:00-16:30\n        ],\n        'Tuesday': [\n            (9 * 60 + 30, 10 * 60)      # 9:30-10:00\n        ]\n    }\n    \n    # Define Albert's busy times in minutes since midnight\n    albert_busy = {\n        'Monday': [\n            (9 * 60, 17 * 60)           # 9:00-17:00 (entire day)\n        ],\n        'Tuesday': [\n            (9 * 60 + 30, 11 * 60),     # 9:30-11:00\n            (11 * 60 + 30, 12 * 60 + 30), # 11:30-12:30\n            (13 * 60, 16 * 60),         # 13:00-16:00\n            (16 * 60 + 30, 17 * 60)      # 16:30-17:00\n        ]\n    }\n    \n    # Shirley's preference: not after 10:30 on Tuesday (i.e., before 10:30 + 30 min meeting)\n    # So the meeting must end by 10:30 on Tuesday, meaning start by 10:00\n    \n    # Check each day for available slots\n    for day in days:\n        if day == 'Monday':\n            # Albert is busy all day on Monday\n            continue\n        elif day == 'Tuesday':\n            # Check available slots on Tuesday\n            # Generate all possible 30-minute slots in work hours\n            for start in range(work_start, work_end - 30 + 1, 30):\n                end = start + 30\n                # Check Shirley's availability\n                shirley_available = True\n                for busy_start, busy_end in shirley_busy.get(day, []):\n                    if not (end <= busy_start or start >= busy_end):\n                        shirley_available = False\n                        break\n                if not shirley_available:\n                    continue\n                # Check Albert's availability\n                albert_available = True\n                for busy_start, busy_end in albert_busy.get(day, []):\n                    if not (end <= busy_start or start >= busy_end):\n                        albert_available = False\n                        break\n                if not albert_available:\n                    continue\n                # Check Shirley's preference (end by 10:30 on Tuesday)\n                if day == 'Tuesday' and end > 10 * 60 + 30:\n                    continue\n                # If all checks passed, return the slot\n                return f\"{start // 60:02d}:{start % 60:02d}:{end // 60:02d}:{end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_658"
        },
        {
            "final_program_time": "{16:00:16:30}",
            "expected_time": "{16:00:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each person's busy slots to minutes since midnight\n    busy_slots = {\n        'Katherine': [(12 * 60, 12 * 60 + 30), (13 * 60, 14 * 60 + 30)],\n        'Rebecca': [],\n        'Julie': [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 11 * 60), (13 * 60 + 30, 14 * 60), (15 * 60, 15 * 60 + 30)],\n        'Angela': [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60), (11 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60), (16 * 60 + 30, 17 * 60)],\n        'Nicholas': [(9 * 60 + 30, 11 * 60), (11 * 60 + 30, 13 * 60 + 30), (14 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Carl': [(9 * 60, 11 * 60), (11 * 60 + 30, 12 * 60 + 30), (13 * 60, 14 * 60 + 30), (15 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n    }\n    \n    # Angela prefers no meetings before 15:00\n    preferred_start = 15 * 60\n    \n    # Generate all possible 30-minute slots from preferred_start to work_end\n    possible_slots = []\n    current_time = preferred_start\n    while current_time + 30 <= work_end:\n        possible_slots.append((current_time, current_time + 30))\n        current_time += 30\n    \n    # Check each slot for availability\n    for slot_start, slot_end in possible_slots:\n        all_available = True\n        for person, slots in busy_slots.items():\n            for busy_start, busy_end in slots:\n                if not (slot_end <= busy_start or slot_start >= busy_end):\n                    all_available = False\n                    break\n            if not all_available:\n                break\n        if all_available:\n            # Format the time as HH:MM:HH:MM\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    # If no slot found after preferred_start, check before (though Angela prefers not)\n    current_time = work_start\n    while current_time + 30 <= work_end:\n        possible_slots.append((current_time, current_time + 30))\n        current_time += 30\n    \n    for slot_start, slot_end in possible_slots:\n        all_available = True\n        for person, slots in busy_slots.items():\n            for busy_start, busy_end in slots:\n                if not (slot_end <= busy_start or slot_start >= busy_end):\n                    all_available = False\n                    break\n            if not all_available:\n                break\n        if all_available:\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available slot found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_356"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:00:11:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert all time slots to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's busy slots to find common free slots\n    for person, busy_slots in participants_schedules.items():\n        person_busy = []\n        for slot in busy_slots:\n            start, end = map(time_to_minutes, slot.split(':'))\n            person_busy.append((start, end))\n        \n        # Merge overlapping or adjacent busy slots for the person\n        person_busy.sort()\n        merged_busy = []\n        for start, end in person_busy:\n            if not merged_busy:\n                merged_busy.append((start, end))\n            else:\n                last_start, last_end = merged_busy[-1]\n                if start <= last_end:\n                    new_start = last_start\n                    new_end = max(last_end, end)\n                    merged_busy[-1] = (new_start, new_end)\n                else:\n                    merged_busy.append((start, end))\n        \n        # Subtract the person's busy slots from the current free slots\n        new_free_slots = []\n        for free_start, free_end in free_slots:\n            current_start = free_start\n            for busy_start, busy_end in merged_busy:\n                if busy_start >= free_end:\n                    break\n                if busy_end <= current_start:\n                    continue\n                if busy_start > current_start:\n                    new_free_slots.append((current_start, busy_start))\n                current_start = max(current_start, busy_end)\n            if current_start < free_end:\n                new_free_slots.append((current_start, free_end))\n        free_slots = new_free_slots\n    \n    # Find the earliest slot that can fit the duration\n    duration_min = duration * 60\n    for start, end in free_slots:\n        if end - start >= duration_min:\n            meeting_end = start + duration_min\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nparticipants_schedules = {\n    \"Steven\": [],\n    \"Roy\": [],\n    \"Cynthia\": [\"9:30:10:30\", \"11:30:12:00\", \"13:00:13:30\", \"15:00:16:00\"],\n    \"Lauren\": [\"9:00:9:30\", \"10:30:11:00\", \"11:30:12:00\", \"13:00:13:30\", \"14:00:14:30\", \"15:00:15:30\", \"16:00:17:00\"],\n    \"Robert\": [\"10:30:11:00\", \"11:30:12:00\", \"12:30:13:30\", \"14:00:16:00\"]\n}\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, 30, \"9:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_215"
        },
        {
            "final_program_time": "{12:00:12:30}",
            "expected_time": "{12:00:12:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    # Eric has no meetings\n    eric_busy = []\n    \n    # Ashley's busy slots: 10:00-10:30, 11:00-12:00, 12:30-13:00, 15:00-16:00\n    ashley_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60, 12 * 60),\n        (12 * 60 + 30, 13 * 60),\n        (15 * 60, 16 * 60)\n    ]\n    \n    # Ronald's busy slots: 9:00-9:30, 10:00-11:30, 12:30-14:00, 14:30-17:00\n    ronald_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 14 * 60),\n        (14 * 60 + 30, 17 * 60)\n    ]\n    \n    # Larry's busy slots: 9:00-12:00, 13:00-17:00\n    larry_busy = [\n        (9 * 60, 12 * 60),\n        (13 * 60, 17 * 60)\n    ]\n    \n    # Combine all busy slots\n    all_busy = eric_busy + ashley_busy + ronald_busy + larry_busy\n    \n    # Sort busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots and work hours\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check if there's a free slot after the last busy slot\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_135"
        },
        {
            "final_program_time": null,
            "expected_time": "{14:30:15:00}",
            "type_error": "TypeError",
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    raymond_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (11 * 60 + 30, 12 * 60),\n        (13 * 60, 13 * 60 + 30),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    billy_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (12 * 60, 13 * 60),\n        (16 * 60 + 30, 17 * 60)\n    ]\n    # Billy prefers no meetings after 15:00\n    billy_preferred_end = 15 * 60\n    donald_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 11 * 60),\n        (12 * 60, 13 * 60),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60, 17 * 60)\n    ]\n\n    # Combine all busy slots and sort\n    all_busy = []\n    for slot in raymond_busy:\n        all_busy.append(('Raymond', slot))\n    for slot in billy_busy:\n        all_busy.append(('Billy', slot))\n    for slot in donald_busy:\n        all_busy.append(('Donald', slot))\n    all_busy.sort(key=lambda x: x[1])\n\n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    for person, (start, end) in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check each free slot for availability and Billy's preference\n    for start, end in free_slots:\n        slot_start = start\n        slot_end = start + meeting_duration\n        if slot_end > end:\n            continue  # Slot too short\n        # Check if all are free\n        raymond_free = all(slot_end <= busy_start or slot_start >= busy_end \n                          for _, (busy_start, busy_end) in raymond_busy)\n        billy_free = all(slot_end <= busy_start or slot_start >= busy_end \n                        for _, (busy_start, busy_end) in billy_busy)\n        donald_free = all(slot_end <= busy_start or slot_start >= busy_end \n                         for _, (busy_start, busy_end) in donald_busy)\n        if raymond_free and billy_free and donald_free:\n            # Check Billy's preference (before 15:00)\n            if slot_end <= billy_preferred_end:\n                # Format the time as HH:MM:HH:MM\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_hh = slot_end // 60\n                end_mm = slot_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    # If no preferred slot, find any slot (though task says solution exists)\n    for start, end in free_slots:\n        slot_start = start\n        slot_end = start + meeting_duration\n        if slot_end > end:\n            continue\n        raymond_free = all(slot_end <= busy_start or slot_start >= busy_end \n                          for _, (busy_start, busy_end) in raymond_busy)\n        billy_free = all(slot_end <= busy_start or slot_start >= busy_end \n                        for _, (busy_start, busy_end) in billy_busy)\n        donald_free = all(slot_end <= busy_start or slot_start >= busy_end \n                         for _, (busy_start, busy_end) in donald_busy)\n        if raymond_free and billy_free and donald_free:\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No time found\"  # Shouldn't happen per task\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_1"
        },
        {
            "final_program_time": "{13:00:13:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to check: Monday (0), Tuesday (1), Wednesday (2)\n    days = [0, 1, 2]\n\n    # Susan's schedule: {day: [(busy_start, busy_end), ...]}\n    susan_schedule = {\n        0: [(12 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60)],\n        1: [(11 * 60 + 30, 12 * 60)],\n        2: [(9 * 60 + 30, 10 * 60 + 30), (14 * 60, 14 * 60 + 30), (15 * 60 + 30, 16 * 60 + 30)]\n    }\n\n    # Sandra's schedule: {day: [(busy_start, busy_end), ...]}\n    sandra_schedule = {\n        0: [(9 * 60, 13 * 60), (14 * 60, 15 * 60), (16 * 60, 16 * 60 + 30)],\n        1: [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60 + 30), \n            (14 * 60, 14 * 60 + 30), (16 * 60, 17 * 60)],\n        2: [(9 * 60, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (13 * 60, 17 * 60)]\n    }\n\n    # Susan prefers not to meet on Tuesday (day 1)\n    preferred_days = [0, 2]\n\n    # Iterate through preferred days first\n    for day in preferred_days + [1]:\n        if day not in days:\n            continue\n\n        # Get busy times for both participants on this day\n        susan_busy = susan_schedule.get(day, [])\n        sandra_busy = sandra_schedule.get(day, [])\n\n        # Combine and sort all busy intervals\n        all_busy = susan_busy + sandra_busy\n        all_busy.sort()\n\n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n\n        for busy_start, busy_end in all_busy:\n            if busy_start > prev_end:\n                free_slots.append((prev_end, busy_start))\n            prev_end = max(prev_end, busy_end)\n\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n\n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= meeting_duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n\n                # Check Sandra's constraint for Monday after 16:00\n                if day == 0 and meeting_start >= 16 * 60:\n                    continue\n\n                # Convert minutes back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_778"
        },
        {
            "final_program_time": "{13:30:14:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define each person's busy times in minutes (start, end)\n    lisa_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    bobby_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    \n    randy_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    # Bobby's preference: avoid after 15:00\n    bobby_preference_end = 15 * 60\n    \n    # Meeting duration in minutes\n    meeting_duration = 30\n    \n    # Generate all possible 30-minute slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 1  # Check every minute for availability\n    \n    # Check each slot against everyone's schedule and Bobby's preference\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n        \n        # Check Bobby's preference\n        if slot_start >= bobby_preference_end:\n            continue\n        \n        # Check Lisa's availability\n        lisa_available = True\n        for busy_start, busy_end in lisa_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                lisa_available = False\n                break\n        if not lisa_available:\n            continue\n        \n        # Check Bobby's availability\n        bobby_available = True\n        for busy_start, busy_end in bobby_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                bobby_available = False\n                break\n        if not bobby_available:\n            continue\n        \n        # Check Randy's availability\n        randy_available = True\n        for busy_start, busy_end in randy_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                randy_available = False\n                break\n        if randy_available:\n            # Convert the slot back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_33"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration, days):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        h = minutes // 60\n        m = minutes % 60\n        return f\"{h:02d}:{m:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = meeting_duration * 60\n\n    # Check all possible days\n    for day in days:\n        # Collect all busy intervals for the day\n        busy_intervals = []\n        for participant in participants_schedules:\n            for entry in participant.get(day, []):\n                start, end = map(time_to_minutes, entry.split(' to '))\n                busy_intervals.append((start, end))\n        \n        # Sort busy intervals by start time\n        busy_intervals.sort()\n\n        # Merge overlapping or adjacent intervals\n        merged = []\n        for start, end in busy_intervals:\n            if not merged:\n                merged.append((start, end))\n            else:\n                last_start, last_end = merged[-1]\n                if start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged[-1] = (new_start, new_end)\n                else:\n                    merged.append((start, end))\n\n        # Find available slots\n        available_slots = []\n        prev_end = work_start\n\n        for start, end in merged:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy interval\n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n\n        # Find the first available slot that fits the meeting duration\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + duration\n                return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return \"No available time slot found\"\n\n# Define participants' schedules\nronald_schedule = {\n    \"Monday\": [\"10:30 to 11:00\", \"12:00 to 12:30\", \"15:30 to 16:00\"],\n    \"Tuesday\": [\"9:00 to 9:30\", \"12:00 to 12:30\", \"15:30 to 16:30\"],\n    \"Wednesday\": [\"9:30 to 10:30\", \"11:00 to 12:00\", \"12:30 to 13:00\", \"13:30 to 14:00\", \"16:30 to 17:00\"]\n}\n\namber_schedule = {\n    \"Monday\": [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:30 to 12:00\", \"12:30 to 14:00\", \"14:30 to 15:00\", \"15:30 to 17:00\"],\n    \"Tuesday\": [\"9:00 to 9:30\", \"10:00 to 11:30\", \"12:00 to 12:30\", \"13:30 to 15:30\", \"16:30 to 17:00\"],\n    \"Wednesday\": [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:00 to 13:30\", \"15:00 to 15:30\"]\n}\n\nparticipants = [ronald_schedule, amber_schedule]\nwork_hours = (\"9:00\", \"17:00\")\nmeeting_duration = 30  # minutes\ndays_to_check = [\"Monday\", \"Tuesday\", \"Wednesday\"]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants, work_hours[0], work_hours[1], meeting_duration, days_to_check)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_735"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 9:00 (0 minutes)\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Parse work hours\n    start_work, end_work = work_hours.split(' to ')\n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work)\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    busy_intervals = []\n    \n    for person, schedules in participants_schedules.items():\n        for schedule in schedules:\n            start, end = schedule.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            busy_intervals.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Check for a slot that can fit the meeting duration (30 minutes)\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"Patrick\": [\"13:30 to 14:00\", \"14:30 to 15:00\"],\n    \"Shirley\": [\"9:00 to 9:30\", \"11:00 to 11:30\", \"12:00 to 12:30\", \"14:30 to 15:00\", \"16:00 to 17:00\"],\n    \"Jeffrey\": [\"9:00 to 9:30\", \"10:30 to 11:00\", \"11:30 to 12:00\", \"13:00 to 13:30\", \"16:00 to 17:00\"],\n    \"Gloria\": [\"11:30 to 12:00\", \"15:00 to 15:30\"],\n    \"Nathan\": [\"9:00 to 9:30\", \"10:30 to 12:00\", \"14:00 to 17:00\"],\n    \"Angela\": [\"9:00 to 9:30\", \"10:00 to 11:00\", \"12:30 to 15:00\", \"15:30 to 16:30\"],\n    \"David\": [\"9:00 to 9:30\", \"10:00 to 10:30\", \"11:00 to 14:00\", \"14:30 to 16:30\"]\n}\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\nwork_hours = \"9:00 to 17:00\"\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_436"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef parse_time(time_str):\n    return datetime.strptime(time_str, \"%H:%M\")\n\ndef time_to_str(time_obj):\n    return time_obj.strftime(\"%H:%M\")\n\ndef find_meeting_time(bryan_schedule, nicholas_schedule, work_hours_start, work_hours_end, meeting_duration, avoid_days_bryan, avoid_days_nicholas):\n    days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"]\n    meeting_duration = timedelta(minutes=meeting_duration)\n    \n    for day in days:\n        if day in avoid_days_bryan or day in avoid_days_nicholas:\n            continue\n        \n        # Get all busy intervals for the day\n        bryan_busy = bryan_schedule.get(day, [])\n        nicholas_busy = nicholas_schedule.get(day, [])\n        all_busy = bryan_busy + nicholas_busy\n        all_busy.sort()\n        \n        # Initialize available slots\n        current_time = parse_time(work_hours_start)\n        end_time = parse_time(work_hours_end)\n        \n        for busy_start, busy_end in all_busy:\n            busy_start_time = parse_time(busy_start)\n            busy_end_time = parse_time(busy_end)\n            \n            if current_time < busy_start_time:\n                available_end = busy_start_time\n                if available_end - current_time >= meeting_duration:\n                    return day, time_to_str(current_time), time_to_str(current_time + meeting_duration)\n            \n            if busy_end_time > current_time:\n                current_time = busy_end_time\n        \n        if current_time + meeting_duration <= end_time:\n            return day, time_to_str(current_time), time_to_str(current_time + meeting_duration)\n    \n    return None\n\n# Define schedules\nbryan_schedule = {\n    \"Thursday\": [(\"09:30\", \"10:00\"), (\"12:30\", \"13:00\")],\n    \"Friday\": [(\"10:30\", \"11:00\"), (\"14:00\", \"14:30\")]\n}\n\nnicholas_schedule = {\n    \"Monday\": [(\"11:30\", \"12:00\"), (\"13:00\", \"15:30\")],\n    \"Tuesday\": [(\"09:00\", \"09:30\"), (\"11:00\", \"13:30\"), (\"14:00\", \"16:30\")],\n    \"Wednesday\": [(\"09:00\", \"09:30\"), (\"10:00\", \"11:00\"), (\"11:30\", \"13:30\"), (\"14:00\", \"14:30\"), (\"15:00\", \"16:30\")],\n    \"Thursday\": [(\"10:30\", \"11:30\"), (\"12:00\", \"12:30\"), (\"15:00\", \"15:30\"), (\"16:30\", \"17:00\")],\n    \"Friday\": [(\"09:00\", \"10:30\"), (\"11:00\", \"12:00\"), (\"12:30\", \"14:30\"), (\"15:30\", \"16:00\"), (\"16:30\", \"17:00\")]\n}\n\n# Constraints\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 60  # minutes\navoid_days_bryan = [\"Tuesday\"]\navoid_days_nicholas = [\"Monday\", \"Thursday\"]\n\n# Find meeting time\nresult = find_meeting_time(bryan_schedule, nicholas_schedule, work_hours_start, work_hours_end, meeting_duration, avoid_days_bryan, avoid_days_nicholas)\n\nif result:\n    day, start_time, end_time = result\n    print(f\"{start_time}:{end_time}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_910"
        },
        {
            "final_program_time": "{9:00:10:00}",
            "expected_time": "{9:00:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Define schedules for Megan and Daniel\n    megan_schedule = {\n        'Monday': [(13 * 60, 13 * 60 + 30), (14 * 60, 15 * 60 + 30)],\n        'Tuesday': [(9 * 60, 9 * 60 + 30), (12 * 60, 12 * 60 + 30), (16 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 11 * 60 + 30), (12 * 60 + 30, 14 * 60), (16 * 60, 16 * 60 + 30)],\n        'Thursday': [(13 * 60 + 30, 14 * 60 + 30), (15 * 60, 15 * 60 + 30)]\n    }\n    \n    daniel_schedule = {\n        'Monday': [(10 * 60, 11 * 60 + 30), (12 * 60 + 30, 15 * 60)],\n        'Tuesday': [(9 * 60, 10 * 60), (10 * 60 + 30, 17 * 60)],\n        'Wednesday': [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60 + 30), (12 * 60, 17 * 60)],\n        'Thursday': [(9 * 60, 12 * 60), (12 * 60 + 30, 14 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 17 * 60)]\n    }\n    \n    # Iterate through each day to find the earliest available slot\n    for day in days:\n        # Collect all busy intervals for both participants\n        busy_intervals = megan_schedule.get(day, []) + daniel_schedule.get(day, [])\n        busy_intervals.sort()\n        \n        # Merge overlapping or adjacent intervals\n        merged_intervals = []\n        for start, end in busy_intervals:\n            if not merged_intervals:\n                merged_intervals.append((start, end))\n            else:\n                last_start, last_end = merged_intervals[-1]\n                if start <= last_end:\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged_intervals[-1] = (new_start, new_end)\n                else:\n                    merged_intervals.append((start, end))\n        \n        # Check the available slots before the first busy interval, between intervals, and after last busy interval\n        prev_end = work_hours_start\n        for start, end in merged_intervals:\n            if start > prev_end:\n                available_start = prev_end\n                available_end = start\n                if available_end - available_start >= 60:  # 1 hour duration\n                    # Convert minutes back to HH:MM format\n                    start_hh = available_start // 60\n                    start_mm = available_start % 60\n                    end_hh = (available_start + 60) // 60\n                    end_mm = (available_start + 60) % 60\n                    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after the last busy interval\n        if prev_end < work_hours_end:\n            available_start = prev_end\n            available_end = work_hours_end\n            if available_end - available_start >= 60:\n                start_hh = available_start // 60\n                start_mm = available_start % 60\n                end_hh = (available_start + 60) // 60\n                end_mm = (available_start + 60) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_865"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert schedules to minutes since midnight for easier comparison\n    # Amanda's busy times (Monday and Tuesday)\n    amanda_busy = {\n        'Monday': [\n            (9 * 60, 10 * 60 + 30),    # 9:00-10:30\n            (11 * 60, 11 * 60 + 30),     # 11:00-11:30\n            (12 * 60 + 30, 13 * 60),    # 12:30-13:00\n            (13 * 60 + 30, 14 * 60),     # 13:30-14:00\n            (14 * 60 + 30, 15 * 60),    # 14:30-15:00\n        ],\n        'Tuesday': [\n            (9 * 60, 9 * 60 + 30),      # 9:00-9:30\n            (10 * 60, 10 * 60 + 30),     # 10:00-10:30\n            (11 * 60 + 30, 12 * 60),    # 11:30-12:00\n            (13 * 60 + 30, 14 * 60 + 30), # 13:30-14:30\n            (15 * 60 + 30, 16 * 60),     # 15:30-16:00\n            (16 * 60 + 30, 17 * 60),     # 16:30-17:00\n        ]\n    }\n    \n    # Nathan's busy times (Monday and Tuesday)\n    nathan_busy = {\n        'Monday': [\n            (10 * 60, 10 * 60 + 30),    # 10:00-10:30\n            (11 * 60, 11 * 60 + 30),    # 11:00-11:30\n            (13 * 60 + 30, 14 * 60 + 30), # 13:30-14:30\n            (16 * 60, 16 * 60 + 30),     # 16:00-16:30\n        ],\n        'Tuesday': [\n            (9 * 60, 10 * 60 + 30),     # 9:00-10:30\n            (11 * 60, 13 * 60),          # 11:00-13:00\n            (13 * 60 + 30, 14 * 60),     # 13:30-14:00\n            (14 * 60 + 30, 15 * 60 + 30), # 14:30-15:30\n            (16 * 60, 16 * 60 + 30),     # 16:00-16:30\n        ]\n    }\n    \n    # Constraints:\n    # Amanda doesn't want to meet on Tuesday after 11:00\n    # Nathan cannot meet on Monday\n    \n    # Since Nathan can't meet on Monday, we only check Tuesday\n    day = 'Tuesday'\n    \n    # Generate all possible 30-minute slots on Tuesday within work hours\n    meeting_duration = 30\n    possible_slots = []\n    current_time = work_start\n    \n    while current_time + meeting_duration <= work_end:\n        slot_start = current_time\n        slot_end = current_time + meeting_duration\n        \n        # Check Amanda's constraints (not after 11:00 on Tuesday)\n        if slot_start >= 11 * 60:\n            current_time += 1  # Move to next minute\n            continue\n        \n        # Check if the slot is free for both Amanda and Nathan\n        amanda_free = True\n        for busy_start, busy_end in amanda_busy[day]:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                amanda_free = False\n                break\n        \n        nathan_free = True\n        for busy_start, busy_end in nathan_busy[day]:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                nathan_free = False\n                break\n        \n        if amanda_free and nathan_free:\n            possible_slots.append((slot_start, slot_end))\n        \n        current_time += 1  # Move to next minute\n    \n    # Select the first available slot\n    if possible_slots:\n        best_slot = possible_slots[0]\n        start_h = best_slot[0] // 60\n        start_m = best_slot[0] % 60\n        end_h = best_slot[1] // 60\n        end_m = best_slot[1] % 60\n        return f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    else:\n        return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_682"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Convert each participant's busy slots to minutes\n    jacqueline_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    harold_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (15 * 60, 17 * 60)\n    ]\n    arthur_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 12 * 60 + 30),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    kelly_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 11 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n\n    # Harold's constraint: not after 13:00\n    harold_constraint = 13 * 60\n\n    # Generate all possible 30-minute slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + 30 <= work_end:\n        slot_end = current_time + 30\n        possible_slots.append((current_time, slot_end))\n        current_time += 30\n\n    # Check each slot against everyone's schedule and constraints\n    for slot in possible_slots:\n        start, end = slot\n\n        # Check Harold's constraint (not after 13:00)\n        if start >= harold_constraint:\n            continue\n\n        # Check Jacqueline's availability\n        jacqueline_available = True\n        for busy_start, busy_end in jacqueline_busy:\n            if not (end <= busy_start or start >= busy_end):\n                jacqueline_available = False\n                break\n        if not jacqueline_available:\n            continue\n\n        # Check Harold's availability\n        harold_available = True\n        for busy_start, busy_end in harold_busy:\n            if not (end <= busy_start or start >= busy_end):\n                harold_available = False\n                break\n        if not harold_available:\n            continue\n\n        # Check Arthur's availability\n        arthur_available = True\n        for busy_start, busy_end in arthur_busy:\n            if not (end <= busy_start or start >= busy_end):\n                arthur_available = False\n                break\n        if not arthur_available:\n            continue\n\n        # Check Kelly's availability\n        kelly_available = True\n        for busy_start, busy_end in kelly_busy:\n            if not (end <= busy_start or start >= busy_end):\n                kelly_available = False\n                break\n        if not kelly_available:\n            continue\n\n        # If all checks passed, return this slot\n        return f\"{start//60:02d}:{start%60:02d}:{end//60:02d}:{end%60:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_173"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:9:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for meeting in schedule:\n            start, end = map(time_to_minutes, meeting.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find free intervals by looking at gaps between busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    # Check the time after the last busy interval\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Find the first free interval that can accommodate the meeting\n    duration_minutes = duration * 60\n    for start, end in free_intervals:\n        if end - start >= duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + duration_minutes\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return None\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"10:00:10:30\", \"16:00:16:30\"],  # Emily\n    [],                               # Mason\n    [\"10:30:11:00\", \"14:00:14:30\"],   # Maria\n    [\"9:30:10:00\", \"10:30:12:30\", \"13:30:14:00\", \"14:30:15:30\", \"16:00:17:00\"],  # Carl\n    [\"9:30:11:00\", \"11:30:12:00\", \"12:30:13:30\", \"14:00:15:00\", \"16:00:17:00\"],  # David\n    [\"9:30:10:30\", \"11:00:11:30\", \"12:30:13:30\", \"14:30:17:00\"],  # Frank\n]\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, 0.5, \"9:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_360"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each participant's busy slots to minutes\n    jeffrey_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 11 * 60)\n    ]\n    virginia_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    melissa_busy = [\n        (9 * 60, 11 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 15 * 60),\n        (16 * 60, 17 * 60)\n    ]\n    melissa_preference_end = 14 * 60  # Prefers not to meet after 14:00\n\n    # Generate all possible slots within work hours\n    possible_slots = []\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        possible_slots.append((current_time, slot_end))\n        current_time += 15  # Check every 15 minutes for efficiency\n\n    # Check each slot against all constraints\n    for slot in possible_slots:\n        slot_start, slot_end = slot\n\n        # Check Melissa's preference (not after 14:00)\n        if slot_start >= melissa_preference_end:\n            continue\n\n        # Check if slot overlaps with any busy times for Jeffrey\n        jeffrey_available = True\n        for busy_start, busy_end in jeffrey_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                jeffrey_available = False\n                break\n        if not jeffrey_available:\n            continue\n\n        # Check if slot overlaps with any busy times for Virginia\n        virginia_available = True\n        for busy_start, busy_end in virginia_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                virginia_available = False\n                break\n        if not virginia_available:\n            continue\n\n        # Check if slot overlaps with any busy times for Melissa\n        melissa_available = True\n        for busy_start, busy_end in melissa_busy:\n            if not (slot_end <= busy_start or slot_start >= busy_end):\n                melissa_available = False\n                break\n        if not melissa_available:\n            continue\n\n        # If all checks passed, return this slot\n        start_hh = slot_start // 60\n        start_mm = slot_start % 60\n        end_hh = slot_end // 60\n        end_mm = slot_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_30"
        },
        {
            "final_program_time": "{14:30:15:30}",
            "expected_time": "{14:30:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Days to check\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Natalie's schedule: each entry is (day, start, end) in minutes\n    natalie_busy = [\n        ('Monday', 9*60, 9*60+30), ('Monday', 10*60, 12*60), ('Monday', 12*60+30, 13*60),\n        ('Monday', 14*60, 14*60+30), ('Monday', 15*60, 16*60+30),\n        ('Tuesday', 9*60, 9*60+30), ('Tuesday', 10*60, 10*60+30), ('Tuesday', 12*60+30, 14*60),\n        ('Tuesday', 16*60, 17*60),\n        ('Wednesday', 11*60, 11*60+30), ('Wednesday', 16*60, 16*60+30),\n        ('Thursday', 10*60, 11*60), ('Thursday', 11*60+30, 15*60), ('Thursday', 15*60+30, 16*60),\n        ('Thursday', 16*60+30, 17*60)\n    ]\n    \n    # William's schedule\n    william_busy = [\n        ('Monday', 9*60+30, 11*60), ('Monday', 11*60+30, 17*60),\n        ('Tuesday', 9*60, 13*60), ('Tuesday', 13*60+30, 16*60),\n        ('Wednesday', 9*60, 12*60+30), ('Wednesday', 13*60, 14*60+30), ('Wednesday', 15*60+30, 16*60),\n        ('Wednesday', 16*60+30, 17*60),\n        ('Thursday', 9*60, 10*60+30), ('Thursday', 11*60, 11*60+30), ('Thursday', 12*60, 12*60+30),\n        ('Thursday', 13*60, 14*60), ('Thursday', 15*60, 17*60)\n    ]\n    \n    # Check each day\n    for day in days:\n        # Get busy intervals for both on this day\n        natalie_day = [ (start, end) for (d, start, end) in natalie_busy if d == day ]\n        william_day = [ (start, end) for (d, start, end) in william_busy if d == day ]\n        \n        # Merge and sort busy intervals for both\n        merged_busy = natalie_day + william_day\n        merged_busy.sort()\n        \n        # Find free time\n        prev_end = work_start\n        for (start, end) in merged_busy:\n            if start > prev_end:\n                # Found a free slot\n                free_start = prev_end\n                free_end = start\n                if free_end - free_start >= 60:  # 1 hour available\n                    # Convert to HH:MM format\n                    start_hh = free_start // 60\n                    start_mm = free_start % 60\n                    end_hh = (free_start + 60) // 60\n                    end_mm = (free_start + 60) % 60\n                    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy interval\n        if work_end - prev_end >= 60:\n            start_hh = prev_end // 60\n            start_mm = prev_end % 60\n            end_hh = (prev_end + 60) // 60\n            end_mm = (prev_end + 60) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No time found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_875"
        },
        {
            "final_program_time": "{9:30:10:30}",
            "expected_time": "{9:30:10:30}",
            "type_error": null,
            "full_response": "```python\nfrom datetime import datetime, timedelta\n\ndef parse_time(time_str):\n    return datetime.strptime(time_str, \"%H:%M\")\n\ndef format_time(time_obj):\n    return time_obj.strftime(\"%H:%M\")\n\ndef get_available_slots(busy_slots, work_start, work_end, duration):\n    available_slots = []\n    busy_slots_sorted = sorted(busy_slots, key=lambda x: x[0])\n    current_time = work_start\n    \n    for busy_start, busy_end in busy_slots_sorted:\n        if current_time < busy_start:\n            available_end = min(busy_start, work_end)\n            if (available_end - current_time) >= duration:\n                available_slots.append((current_time, available_end))\n        current_time = max(current_time, busy_end)\n    \n    if current_time < work_end:\n        if (work_end - current_time) >= duration:\n            available_slots.append((current_time, work_end))\n    \n    return available_slots\n\ndef find_earliest_meeting_time(brian_busy, julia_busy, work_hours, days, duration, brian_preferences):\n    work_start = parse_time(work_hours[0])\n    work_end = parse_time(work_hours[1])\n    duration_delta = timedelta(minutes=duration)\n    \n    for day in days:\n        if day in brian_preferences:\n            continue\n        \n        brian_day_busy = brian_busy.get(day, [])\n        julia_day_busy = julia_busy.get(day, [])\n        \n        # Convert busy slots to datetime objects\n        brian_busy_slots = []\n        for start, end in brian_day_busy:\n            brian_busy_slots.append((parse_time(start), parse_time(end)))\n        \n        julia_busy_slots = []\n        for start, end in julia_day_busy:\n            julia_busy_slots.append((parse_time(start), parse_time(end)))\n        \n        # Get available slots for Brian and Julia\n        brian_available = get_available_slots(brian_busy_slots, work_start, work_end, duration_delta)\n        julia_available = get_available_slots(julia_busy_slots, work_start, work_end, duration_delta)\n        \n        # Find overlapping slots\n        for b_start, b_end in brian_available:\n            for j_start, j_end in julia_available:\n                overlap_start = max(b_start, j_start)\n                overlap_end = min(b_end, j_end)\n                if (overlap_end - overlap_start) >= duration_delta:\n                    return (day, overlap_start, overlap_start + duration_delta)\n    \n    return None\n\n# Define work hours and meeting duration\nwork_hours = (\"09:00\", \"17:00\")\nmeeting_duration = 60  # minutes\ndays = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"]\nbrian_preferences = [\"Monday\"]  # Brian wants to avoid Monday\n\n# Define busy slots for Brian and Julia\nbrian_busy = {\n    \"Monday\": [(\"09:30\", \"10:00\"), (\"12:30\", \"14:30\"), (\"15:30\", \"16:00\")],\n    \"Tuesday\": [(\"09:00\", \"09:30\")],\n    \"Wednesday\": [(\"12:30\", \"14:00\"), (\"16:30\", \"17:00\")],\n    \"Thursday\": [(\"11:00\", \"11:30\"), (\"13:00\", \"13:30\"), (\"16:30\", \"17:00\")],\n    \"Friday\": [(\"09:30\", \"10:00\"), (\"10:30\", \"11:00\"), (\"13:00\", \"13:30\"), (\"15:00\", \"16:00\"), (\"16:30\", \"17:00\")]\n}\n\njulia_busy = {\n    \"Monday\": [(\"09:00\", \"10:00\"), (\"11:00\", \"11:30\"), (\"12:30\", \"13:00\"), (\"15:30\", \"16:00\")],\n    \"Tuesday\": [(\"13:00\", \"14:00\"), (\"16:00\", \"16:30\")],\n    \"Wednesday\": [(\"09:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"17:00\")],\n    \"Thursday\": [(\"09:00\", \"10:30\"), (\"11:00\", \"17:00\")],\n    \"Friday\": [(\"09:00\", \"10:00\"), (\"10:30\", \"11:30\"), (\"12:30\", \"14:00\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:00\")]\n}\n\n# Find the earliest meeting time\nresult = find_earliest_meeting_time(brian_busy, julia_busy, work_hours, days, meeting_duration, brian_preferences)\n\nif result:\n    day, start_time, end_time = result\n    print(f\"{format_time(start_time)}:{format_time(end_time)}\")\nelse:\n    print(\"No available time slot found.\")\n```",
            "count": "calendar_scheduling_example_978"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_busy_slots, duration_minutes, work_start, work_end):\n    # Convert all time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration = duration_minutes\n    \n    # Initialize the list of busy slots for all participants\n    all_busy_slots = []\n    for person in participants_busy_slots:\n        for slot in person:\n            start_min = time_to_minutes(slot[0])\n            end_min = time_to_minutes(slot[1])\n            all_busy_slots.append((start_min, end_min))\n    \n    # Sort all busy slots by start time\n    all_busy_slots.sort()\n    \n    # Merge overlapping or adjacent busy slots\n    merged_slots = []\n    for start, end in all_busy_slots:\n        if not merged_slots:\n            merged_slots.append((start, end))\n        else:\n            last_start, last_end = merged_slots[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_slots[-1] = (new_start, new_end)\n            else:\n                merged_slots.append((start, end))\n    \n    # Find available slots by checking gaps between merged busy slots and work hours\n    available_slots = []\n    previous_end = work_start_min\n    for start, end in merged_slots:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end_min:\n        available_slots.append((previous_end, work_end_min))\n    \n    # Find the first available slot that can fit the duration\n    for slot in available_slots:\n        start, end = slot\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define the participants' busy slots in HH:MM format\nparticipants_busy_slots = [\n    [],  # Ronald is free all day\n    [(\"10:00\", \"10:30\"), (\"12:00\", \"12:30\")],  # Stephen\n    [(\"11:00\", \"11:30\"), (\"13:30\", \"14:00\"), (\"15:30\", \"16:00\"), (\"16:30\", \"17:00\")],  # Brittany\n    [(\"09:00\", \"09:30\"), (\"10:00\", \"10:30\"), (\"11:00\", \"12:30\"), (\"13:00\", \"15:00\"), (\"15:30\", \"17:00\")],  # Dorothy\n    [(\"09:30\", \"10:30\"), (\"11:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"17:00\")],  # Rebecca\n    [(\"09:00\", \"09:30\"), (\"10:00\", \"11:00\"), (\"11:30\", \"12:00\"), (\"13:00\", \"15:00\"), (\"15:30\", \"16:30\")],  # Jordan\n]\n\n# Find a 30-minute meeting slot between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_busy_slots, 30, \"09:00\", \"17:00\")\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_307"
        },
        {
            "final_program_time": "{16:00:17:00}",
            "expected_time": "{16:00:17:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals by merging busy intervals\n    free_intervals = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Find the first free interval that can accommodate the meeting duration\n    for start, end in free_intervals:\n        if end - start >= duration * 60:\n            meeting_start = start\n            meeting_end = meeting_start + duration * 60\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No suitable time found\"\n\n# Define the participants' schedules\nkayla_schedule = [\n    \"10:00 to 10:30\",\n    \"14:30 to 16:00\"\n]\n\nrebecca_schedule = [\n    \"9:00 to 13:00\",\n    \"13:30 to 15:00\",\n    \"15:30 to 16:00\"\n]\n\n# Combine all participants' schedules\nparticipants_schedules = [kayla_schedule, rebecca_schedule]\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration = 1  # in hours\n\n# Find and print the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_541"
        },
        {
            "final_program_time": null,
            "expected_time": "{11:30:12:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work_hours start at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = 9 + minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    start_work = time_to_minutes(work_hours[0])\n    end_work = time_to_minutes(work_hours[1])\n    duration_min = duration * 60\n\n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start = time_to_minutes(busy[0])\n            end = time_to_minutes(busy[1])\n            busy_intervals.append((start, end))\n\n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n\n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n\n    # Find available slots by checking gaps between merged intervals and work hours\n    available_slots = []\n    prev_end = start_work\n\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n\n    if prev_end < end_work:\n        available_slots.append((prev_end, end_work))\n\n    # Find the first available slot that can fit the meeting duration\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return (minutes_to_time(meeting_start), minutes_to_time(meeting_end))\n\n    return None\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 0.5  # 0.5 hours = 30 minutes\n\n# Define each participant's schedule as list of busy (start, end) times\nparticipants_schedules = [\n    [],  # Andrea's calendar is wide open\n    [(\"9:00\", \"9:30\"), (\"14:00\", \"14:30\")],  # Jack\n    [(\"9:30\", \"10:30\"), (\"13:00\", \"14:00\"), (\"15:00\", \"15:30\"), (\"16:30\", \"17:00\")],  # Madison\n    [(\"9:30\", \"10:30\"), (\"11:00\", \"11:30\"), (\"12:00\", \"13:30\"), (\"14:30\", \"15:30\"), (\"16:00\", \"17:00\")],  # Rachel\n    [(\"9:00\", \"11:30\"), (\"12:00\", \"16:30\")],  # Douglas\n    [(\"9:00\", \"9:30\"), (\"13:00\", \"14:00\"), (\"14:30\", \"17:00\")],  # Ryan\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nif meeting_time:\n    print(f\"{meeting_time[0]}:{meeting_time[1]}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_396"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' schedules and constraints\n    christine_busy = [\n        (11 * 60, 11 * 60 + 30),  # 11:00-11:30\n        (15 * 60, 15 * 60 + 30)    # 15:00-15:30\n    ]\n    \n    helen_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),  # 9:30-10:30\n        (11 * 60, 11 * 60 + 30),       # 11:00-11:30\n        (12 * 60, 12 * 60 + 30),       # 12:00-12:30\n        (13 * 60 + 30, 16 * 60),       # 13:30-16:00\n        (16 * 60 + 30, 17 * 60)        # 16:30-17:00\n    ]\n    helen_no_meet_after = 15 * 60  # 15:00\n    \n    # Combine all busy times and sort\n    all_busy = christine_busy + helen_busy\n    all_busy.sort()\n    \n    # Find available slots\n    available_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Filter slots based on duration (30 minutes) and Helen's constraint\n    meeting_duration = 30\n    valid_slots = []\n    \n    for start, end in available_slots:\n        if end - start >= meeting_duration:\n            latest_start = min(end - meeting_duration, helen_no_meet_after - meeting_duration)\n            if start <= latest_start:\n                valid_start = start\n                valid_end = valid_start + meeting_duration\n                valid_slots.append((valid_start, valid_end))\n    \n    # Select the first valid slot\n    if valid_slots:\n        meeting_start, meeting_end = valid_slots[0]\n        # Convert minutes back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return \"No available slot found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_579"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Define busy times for each participant per day in minutes since midnight\n    carl_busy = {\n        'Monday': [(11 * 60, 11 * 60 + 30)],\n        'Tuesday': [(14 * 60 + 30, 15 * 60)],\n        'Wednesday': [(10 * 60, 11 * 60 + 30), (13 * 60, 13 * 60 + 30)],\n        'Thursday': [(13 * 60 + 30, 14 * 60), (16 * 60, 16 * 60 + 30)]\n    }\n    \n    margaret_busy = {\n        'Monday': [(9 * 60, 10 * 60 + 30), (11 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60 + 30, 12 * 60), (13 * 60 + 30, 14 * 60), (15 * 60 + 30, 17 * 60)],\n        'Wednesday': [(9 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60 + 30), (15 * 60, 17 * 60)],\n        'Thursday': [(10 * 60, 12 * 60), (12 * 60 + 30, 14 * 60), (14 * 60 + 30, 17 * 60)]\n    }\n    \n    meeting_duration = 60  # minutes\n    \n    # Iterate through each day (excluding Thursday first due to Carl's preference)\n    preferred_days = ['Monday', 'Tuesday', 'Wednesday']\n    for day in preferred_days + ['Thursday']:\n        # Get busy times for both participants on this day\n        carl_busy_today = carl_busy.get(day, [])\n        margaret_busy_today = margaret_busy.get(day, [])\n        \n        # Merge and sort all busy intervals\n        all_busy = carl_busy_today + margaret_busy_today\n        all_busy.sort()\n        \n        # Find free slots by checking gaps between busy intervals\n        prev_end = work_hours_start\n        free_slots = []\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy interval\n        if prev_end < work_hours_end:\n            free_slots.append((prev_end, work_hours_end))\n        \n        # Check each free slot for availability of meeting duration\n        for slot_start, slot_end in free_slots:\n            available_start = slot_start\n            available_end = slot_end\n            \n            if available_end - available_start >= meeting_duration:\n                # Found a suitable slot\n                start_hour = available_start // 60\n                start_min = available_start % 60\n                end_hour = (available_start + meeting_duration) // 60\n                end_min = (available_start + meeting_duration) % 60\n                \n                return f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_858"
        },
        {
            "final_program_time": "{15:00:15:30}",
            "expected_time": "{15:00:15:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy times in minutes (start, end)\n    david_busy = [(11 * 60 + 30, 12 * 60), (14 * 60 + 30, 15 * 60)]\n    douglas_busy = [(9 * 60 + 30, 10 * 60), (11 * 60 + 30, 12 * 60), (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60)]\n    ralph_busy = [(9 * 60, 9 * 60 + 30), (10 * 60, 11 * 60), (11 * 60 + 30, 12 * 60 + 30), (13 * 60 + 30, 15 * 60), (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)]\n    jordan_busy = [(9 * 60, 10 * 60), (12 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60), (15 * 60 + 30, 17 * 60)]\n    \n    # David's constraint: not before 14:00\n    david_constraint = 14 * 60\n    \n    # Combine all busy times\n    all_busy = david_busy + douglas_busy + ralph_busy + jordan_busy\n    \n    # Generate free slots by inverting busy slots\n    free_slots = []\n    current_time = work_start\n    \n    # Sort all busy times by start time\n    all_busy_sorted = sorted(all_busy, key=lambda x: x[0])\n    \n    for busy_start, busy_end in all_busy_sorted:\n        if busy_start > current_time:\n            free_slots.append((current_time, busy_start))\n        current_time = max(current_time, busy_end)\n    if current_time < work_end:\n        free_slots.append((current_time, work_end))\n    \n    # Check free slots for a 30-minute window that fits David's constraint\n    meeting_duration = 30\n    for slot_start, slot_end in free_slots:\n        # Adjust slot_start to meet David's constraint\n        actual_start = max(slot_start, david_constraint)\n        if actual_start + meeting_duration <= slot_end:\n            # Convert minutes back to HH:MM format\n            start_hh = actual_start // 60\n            start_mm = actual_start % 60\n            end_hh = (actual_start + meeting_duration) // 60\n            end_mm = (actual_start + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_227"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday']\n\n    # Nicole's busy times in minutes since start of day\n    nicole_busy = {\n        'Monday': [(9 * 60, 9 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60 + 30)],\n        'Tuesday': [(9 * 60, 9 * 60 + 30), (11 * 60 + 30, 13 * 60 + 30), (14 * 60 + 30, 15 * 60 + 30)],\n        'Wednesday': [(10 * 60, 11 * 60), (12 * 60 + 30, 15 * 60), (16 * 60, 17 * 60)]\n    }\n\n    # Ruth's busy times in minutes since start of day\n    ruth_busy = {\n        'Monday': [(9 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 10 * 60 + 30), (11 * 60, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), \n                      (13 * 60 + 30, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)]\n    }\n\n    # Ruth's preference: not after 13:30 on Wednesday\n    ruth_preference = 13 * 60 + 30  # 13:30 in minutes\n\n    # Iterate through each day\n    for day in days:\n        if day == 'Wednesday':\n            # Adjust work_end for Wednesday based on Ruth's preference\n            current_work_end = min(work_end, ruth_preference)\n        else:\n            current_work_end = work_end\n\n        # Generate all possible slots for the day\n        slots = []\n        current_time = work_start\n        while current_time + meeting_duration <= current_work_end:\n            slots.append((current_time, current_time + meeting_duration))\n            current_time += meeting_duration\n\n        # Check each slot for availability\n        for slot_start, slot_end in slots:\n            # Check Nicole's availability\n            nicole_available = True\n            for busy_start, busy_end in nicole_busy[day]:\n                if not (slot_end <= busy_start or slot_start >= busy_end):\n                    nicole_available = False\n                    break\n\n            # Check Ruth's availability\n            ruth_available = True\n            for busy_start, busy_end in ruth_busy[day]:\n                if not (slot_end <= busy_start or slot_start >= busy_end):\n                    ruth_available = False\n                    break\n\n            # If both are available, return the slot\n            if nicole_available and ruth_available:\n                # Convert minutes back to HH:MM format\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_hh = slot_end // 60\n                end_mm = slot_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_791"
        },
        {
            "final_program_time": "{11:30:12:00}",
            "expected_time": "{11:30:12:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    start_work, end_work = work_hours\n    # Convert time strings to minutes since start of day\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(start_work)\n    work_end = time_to_minutes(end_work) - duration  # Latest possible start time\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules.values():\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort intervals by start time\n    busy_intervals.sort()\n    \n    # Find the earliest available slot\n    current_time = work_start\n    for start, end in busy_intervals:\n        if start > current_time:\n            # Check if there's enough time before the next busy interval\n            if start - current_time >= duration:\n                meeting_end = current_time + duration\n                return f\"{minutes_to_time(current_time)}:{minutes_to_time(meeting_end)}\"\n        # Update current_time to the end of this busy interval if it's later\n        if end > current_time:\n            current_time = end\n        # If we've gone past work hours, break\n        if current_time >= work_end:\n            break\n    \n    # Check the time after the last busy interval\n    if current_time <= work_end:\n        meeting_end = current_time + duration\n        return f\"{minutes_to_time(current_time)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available time slot found\"\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 30  # minutes\n\n# Define participants' schedules\nparticipants_schedules = {\n    \"Denise\": [\"12:00 to 12:30\", \"15:30 to 16:00\"],\n    \"Angela\": [],\n    \"Natalie\": [\"9:00 to 11:30\", \"12:00 to 13:00\", \"14:00 to 14:30\", \"15:00 to 17:00\"],\n}\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_70"
        },
        {
            "final_program_time": "{10:00:11:00}",
            "expected_time": "{10:00:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - 540  # Subtract 540 to start from 9:00 (540 minutes)\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_minutes = 540 + minutes  # Add back 540 to start from 9:00\n        hh = total_minutes // 60\n        mm = total_minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    # Parse work hours\n    work_start, work_end = work_hours.split(' to ')\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n\n    # Initialize all available slots as free\n    all_slots = [True] * (work_end_min - work_start_min)\n\n    # Mark busy slots for each participant\n    for schedule in participants_schedules:\n        busy_slots = [False] * (work_end_min - work_start_min)\n        for block in schedule:\n            start, end = block.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            for i in range(start_min, end_min):\n                if 0 <= i < len(busy_slots):\n                    busy_slots[i] = True\n        # Merge into all_slots\n        for i in range(len(all_slots)):\n            all_slots[i] = all_slots[i] and not busy_slots[i]\n\n    # Find the first available slot of duration\n    duration_min = duration * 60\n    current_start = -1\n    for i in range(len(all_slots)):\n        if all_slots[i]:\n            if current_start == -1:\n                current_start = i\n            if i - current_start + 1 >= duration_min:\n                return f\"{minutes_to_time(current_start)}:{minutes_to_time(current_start + duration_min)}\"\n        else:\n            current_start = -1\n\n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"12:30 to 13:30\", \"14:30 to 15:00\", \"16:30 to 17:00\"],  # Olivia\n    [],  # Anna\n    [\"9:00 to 10:00\", \"11:30 to 16:00\", \"16:30 to 17:00\"],  # Virginia\n    [\"9:00 to 9:30\", \"11:00 to 11:30\", \"13:00 to 14:00\", \"14:30 to 16:00\", \"16:30 to 17:00\"],  # Paul\n]\n\n# Define work hours and duration\nwork_hours = \"9:00 to 17:00\"\nduration = 1  # hour\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, work_hours, duration))\n```",
            "count": "calendar_scheduling_example_106"
        },
        {
            "final_program_time": "{14:00:14:30}",
            "expected_time": "{14:00:14:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define busy intervals for each participant in minutes\n    patrick_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (13 * 60 + 30, 14 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    kayla_busy = [\n        (12 * 60 + 30, 13 * 60 + 30),\n        (15 * 60, 15 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    \n    carl_busy = [\n        (10 * 60 + 30, 11 * 60),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 17 * 60)\n    ]\n    \n    christian_busy = [\n        (9 * 60, 12 * 60 + 30),\n        (13 * 60, 14 * 60),\n        (14 * 60 + 30, 17 * 60)\n    ]\n    \n    # Combine all busy intervals\n    all_busy = patrick_busy + kayla_busy + carl_busy + christian_busy\n    \n    # Sort busy intervals by start time\n    all_busy.sort()\n    \n    # Find free intervals by checking gaps between busy intervals\n    free_intervals = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_intervals.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        free_intervals.append((previous_end, work_end))\n    \n    # Check each free interval for a 30-minute slot\n    meeting_duration = 30\n    for start, end in free_intervals:\n        if end - start >= meeting_duration:\n            # Convert start time back to HH:MM format\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_172"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:00:9:30}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(adam_busy, roy_busy, work_hours, duration):\n    # Parse work hours\n    start, end = work_hours.split(' to ')\n    work_start = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n    work_end = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n    \n    # Parse busy slots\n    def parse_slots(slots):\n        parsed = []\n        for slot in slots:\n            start_time, end_time = slot.split(' to ')\n            start_min = int(start_time.split(':')[0]) * 60 + int(start_time.split(':')[1])\n            end_min = int(end_time.split(':')[0]) * 60 + int(end_time.split(':')[1])\n            parsed.append((start_min, end_min))\n        return parsed\n    \n    adam_slots = parse_slots(adam_busy)\n    roy_slots = parse_slots(roy_busy)\n    \n    # Combine and sort all busy slots\n    all_busy = adam_slots + roy_slots\n    all_busy.sort()\n    \n    # Find free slots\n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Find the earliest slot that fits the duration\n    duration_min = duration * 60\n    for slot in free_slots:\n        start, end = slot\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = start + duration_min\n            # Format the time as HH:MM:HH:MM\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return None\n\n# Given data\nadam_busy = ['9:30 to 10:00', '12:30 to 13:00', '14:30 to 15:00', '16:30 to 17:00']\nroy_busy = ['10:00 to 11:00', '11:30 to 13:00', '13:30 to 14:30', '16:30 to 17:00']\nwork_hours = '9:00 to 17:00'\nduration = 0.5  # half hour\n\n# Find meeting time\nmeeting_time = find_meeting_time(adam_busy, roy_busy, work_hours, duration)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_594"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Define blocked times for Eric and Henry in minutes\n    eric_blocked = [\n        (12 * 60, 13 * 60),  # 12:00-13:00\n        (14 * 60, 15 * 60)   # 14:00-15:00\n    ]\n    henry_blocked = [\n        (9 * 60 + 30, 10 * 60),      # 9:30-10:00\n        (10 * 60 + 30, 11 * 60),     # 10:30-11:00\n        (11 * 60 + 30, 12 * 60 + 30), # 11:30-12:30\n        (13 * 60, 13 * 60 + 30),      # 13:00-13:30\n        (14 * 60 + 30, 15 * 60),      # 14:30-15:00\n        (16 * 60, 17 * 60)            # 16:00-17:00\n    ]\n    henry_preference_end = 10 * 60  # Henry prefers not to meet after 10:00\n\n    # Combine all blocked times and sort\n    all_blocked = eric_blocked + henry_blocked\n    all_blocked_sorted = sorted(all_blocked, key=lambda x: x[0])\n\n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n\n    for start, end in all_blocked_sorted:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Check Henry's preference (before 10:00)\n    preferred_slots = []\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        # Check if slot starts before Henry's preference end (10:00)\n        if slot_start < henry_preference_end:\n            preferred_slots.append((slot_start, min(slot_end, henry_preference_end)))\n\n    # Find the first available 30-minute slot in preferred slots\n    meeting_duration = 30\n    for slot in preferred_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    # If no preferred slot is found, check other available slots (though the task says there's a solution)\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            # Format the output as HH:MM:HH:MM\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No available time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_553"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to check\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n\n    # Terry's schedule: each entry is (day, start, end) in minutes since midnight\n    terry_busy = [\n        ('Monday', 10*60+30, 11*60),\n        ('Monday', 12*60+30, 14*60),\n        ('Monday', 15*60, 17*60),\n        ('Tuesday', 9*60+30, 10*60),\n        ('Tuesday', 10*60+30, 11*60),\n        ('Tuesday', 14*60, 14*60+30),\n        ('Tuesday', 16*60, 16*60+30),\n        ('Wednesday', 9*60+30, 10*60+30),\n        ('Wednesday', 11*60, 12*60),\n        ('Wednesday', 13*60, 13*60+30),\n        ('Wednesday', 15*60, 16*60),\n        ('Wednesday', 16*60+30, 17*60),\n        ('Thursday', 9*60+30, 10*60),\n        ('Thursday', 12*60, 12*60+30),\n        ('Thursday', 13*60, 14*60+30),\n        ('Thursday', 16*60, 16*60+30),\n        ('Friday', 9*60, 11*60+30),\n        ('Friday', 12*60, 12*60+30),\n        ('Friday', 13*60+30, 16*60),\n        ('Friday', 16*60+30, 17*60)\n    ]\n\n    # Frances's schedule\n    frances_busy = [\n        ('Monday', 9*60+30, 11*60),\n        ('Monday', 11*60+30, 13*60),\n        ('Monday', 14*60, 14*60+30),\n        ('Monday', 15*60, 16*60),\n        ('Tuesday', 9*60, 9*60+30),\n        ('Tuesday', 10*60, 10*60+30),\n        ('Tuesday', 11*60, 12*60),\n        ('Tuesday', 13*60, 14*60+30),\n        ('Tuesday', 15*60+30, 16*60+30),\n        ('Wednesday', 9*60+30, 10*60),\n        ('Wednesday', 10*60+30, 11*60),\n        ('Wednesday', 11*60+30, 16*60),\n        ('Wednesday', 16*60+30, 17*60),\n        ('Thursday', 11*60, 12*60+30),\n        ('Thursday', 14*60+30, 17*60),\n        ('Friday', 9*60+30, 10*60+30),\n        ('Friday', 11*60, 12*60+30),\n        ('Friday', 13*60, 16*60),\n        ('Friday', 16*60+30, 17*60)\n    ]\n\n    # Convert busy times to blocked slots per day\n    def get_blocked_slots(busy_times):\n        blocked = {day: [] for day in days}\n        for day, start, end in busy_times:\n            blocked[day].append((start, end))\n        # Sort each day's busy slots\n        for day in blocked:\n            blocked[day].sort()\n        return blocked\n\n    terry_blocked = get_blocked_slots(terry_busy)\n    frances_blocked = get_blocked_slots(frances_busy)\n\n    # Find available slots for a person on a day\n    def find_available_slots(blocked_slots, day):\n        slots = []\n        prev_end = work_start\n        for start, end in blocked_slots[day]:\n            if start > prev_end:\n                slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            slots.append((prev_end, work_end))\n        return slots\n\n    # Find overlapping slots between two people on a day\n    def find_common_slots(day):\n        terry_slots = find_available_slots(terry_blocked, day)\n        frances_slots = find_available_slots(frances_blocked, day)\n        common = []\n        i = j = 0\n        while i < len(terry_slots) and j < len(frances_slots):\n            t_start, t_end = terry_slots[i]\n            f_start, f_end = frances_slots[j]\n            # Find overlap\n            start = max(t_start, f_start)\n            end = min(t_end, f_end)\n            if start < end:\n                common.append((start, end))\n            # Move the pointer which ends first\n            if t_end < f_end:\n                i += 1\n            else:\n                j += 1\n        return common\n\n    # Check days in order, avoiding Tuesday if possible\n    preferred_days = ['Monday', 'Wednesday', 'Thursday', 'Friday', 'Tuesday']\n    \n    for day in preferred_days:\n        common_slots = find_common_slots(day)\n        for start, end in common_slots:\n            if end - start >= meeting_duration:\n                # Found a slot, return the first possible one\n                meeting_start = start\n                meeting_end = meeting_start + meeting_duration\n                # Format as HH:MM:HH:MM\n                return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_935"
        },
        {
            "final_program_time": "{10:00:10:30}",
            "expected_time": "{10:00:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define busy slots for Bobby and Michael on Monday and Tuesday in minutes\n    bobby_busy = {\n        'Monday': [(14 * 60 + 30, 15 * 60)],\n        'Tuesday': [\n            (9 * 60, 11 * 60 + 30),\n            (12 * 60, 12 * 60 + 30),\n            (13 * 60, 15 * 60),\n            (15 * 60 + 30, 17 * 60)\n        ]\n    }\n    \n    michael_busy = {\n        'Monday': [\n            (9 * 60, 10 * 60),\n            (10 * 60 + 30, 13 * 60 + 30),\n            (14 * 60, 15 * 60),\n            (15 * 60 + 30, 17 * 60)\n        ],\n        'Tuesday': [\n            (9 * 60, 10 * 60 + 30),\n            (11 * 60, 11 * 60 + 30),\n            (12 * 60, 14 * 60),\n            (15 * 60, 16 * 60),\n            (16 * 60 + 30, 17 * 60)\n        ]\n    }\n\n    days = ['Monday', 'Tuesday']\n    meeting_duration = 30  # minutes\n\n    for day in days:\n        # Collect all busy slots for both participants on the current day\n        busy_slots = bobby_busy.get(day, []) + michael_busy.get(day, [])\n        busy_slots.sort()  # Sort by start time\n\n        # Merge overlapping or adjacent busy slots\n        merged_slots = []\n        for start, end in busy_slots:\n            if not merged_slots:\n                merged_slots.append((start, end))\n            else:\n                last_start, last_end = merged_slots[-1]\n                if start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged_slots[-1] = (new_start, new_end)\n                else:\n                    merged_slots.append((start, end))\n\n        # Check the available slots before the first busy slot, between busy slots, and after the last busy slot\n        prev_end = work_start\n        for start, end in merged_slots:\n            if start > prev_end:\n                available_start = prev_end\n                available_end = start\n                if available_end - available_start >= meeting_duration:\n                    # Found a suitable slot\n                    return f\"{day} {format_time(available_start)}:{format_time(available_start + meeting_duration)}\"\n            prev_end = max(prev_end, end)\n\n        # Check after the last busy slot\n        if work_end - prev_end >= meeting_duration:\n            return f\"{day} {format_time(prev_end)}:{format_time(prev_end + meeting_duration)}\"\n\n    return \"No suitable time found.\"\n\ndef format_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_640"
        },
        {
            "final_program_time": "{15:00:16:00}",
            "expected_time": "{15:00:16:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Days to check\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n    \n    # Define busy times for each person per day in minutes since midnight\n    diane_busy = {\n        'Monday': [(12 * 60, 12 * 60 + 30), (15 * 60, 15 * 60 + 30)],\n        'Tuesday': [(10 * 60, 11 * 60), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60), (16 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 9 * 60 + 30), (14 * 60 + 30, 15 * 60), (16 * 60 + 30, 17 * 60)],\n        'Thursday': [(15 * 60 + 30, 16 * 60 + 30)],\n        'Friday': [(9 * 60 + 30, 11 * 60 + 30), (14 * 60 + 30, 15 * 60), (16 * 60, 17 * 60)]\n    }\n    \n    matthew_busy = {\n        'Monday': [(9 * 60, 10 * 60), (10 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 11 * 60), (12 * 60, 14 * 60 + 30), (16 * 60, 17 * 60)],\n        'Thursday': [(9 * 60, 16 * 60)],\n        'Friday': [(9 * 60, 17 * 60)]\n    }\n    \n    # Meeting duration in minutes\n    duration = 60\n    \n    # Check each day for available slots\n    for day in days:\n        # Combine and sort all busy intervals for both participants\n        busy_intervals = diane_busy.get(day, []) + matthew_busy.get(day, [])\n        busy_intervals.sort()\n        \n        # Merge overlapping or adjacent intervals\n        merged = []\n        for start, end in busy_intervals:\n            if not merged:\n                merged.append((start, end))\n            else:\n                last_start, last_end = merged[-1]\n                if start <= last_end:\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged[-1] = (new_start, new_end)\n                else:\n                    merged.append((start, end))\n        \n        # Check available slots before the first busy interval\n        if not merged:\n            # No busy intervals, the whole day is free\n            start_time = work_start\n            end_time = work_start + duration\n            if end_time <= work_end:\n                return f\"{format_time(start_time)}:{format_time(end_time)}\"\n        else:\n            # Check before first busy interval\n            first_start, first_end = merged[0]\n            if work_start + duration <= first_start:\n                start_time = work_start\n                end_time = work_start + duration\n                if day == 'Wednesday' and start_time < 12 * 60 + 30:\n                    continue  # Skip Wednesday before 12:30 per Matthew's preference\n                return f\"{format_time(start_time)}:{format_time(end_time)}\"\n            \n            # Check between busy intervals\n            for i in range(1, len(merged)):\n                prev_end = merged[i-1][1]\n                curr_start = merged[i][0]\n                if prev_end + duration <= curr_start:\n                    start_time = prev_end\n                    end_time = prev_end + duration\n                    if day == 'Wednesday' and start_time < 12 * 60 + 30:\n                        continue  # Skip Wednesday before 12:30 per Matthew's preference\n                    return f\"{format_time(start_time)}:{format_time(end_time)}\"\n            \n            # Check after last busy interval\n            last_start, last_end = merged[-1]\n            if last_end + duration <= work_end:\n                start_time = last_end\n                end_time = last_end + duration\n                if day == 'Wednesday' and start_time < 12 * 60 + 30:\n                    continue  # Skip Wednesday before 12:30 per Matthew's preference\n                return f\"{format_time(start_time)}:{format_time(end_time)}\"\n    \n    return \"No suitable time found\"\n\ndef format_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Find and print the meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_985"
        },
        {
            "final_program_time": null,
            "expected_time": "{9:30:10:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(':'))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    # Check the slot after last busy interval until work_end\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Find the first available slot that can fit the meeting\n    duration = duration_minutes\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"11:30:12:00\", \"14:00:14:30\"],  # John\n    [\"12:00:12:30\", \"14:00:15:00\", \"15:30:16:00\"],  # Megan\n    [],  # Brandon\n    [\"9:00:9:30\", \"10:00:10:30\", \"11:00:14:30\", \"15:00:16:00\", \"16:30:17:00\"],  # Kimberly\n    [\"10:00:11:00\", \"11:30:14:00\", \"15:00:15:30\"],  # Sean\n    [\"9:00:9:30\", \"10:30:12:00\", \"13:00:14:30\", \"16:00:16:30\"],  # Lori\n]\n\n# Find a 30-minute meeting time between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, \"9:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_337"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{13:30:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert each person's busy slots to minutes since 9:00\n    juan_busy = [\n        (9 * 60, 10 * 60 + 30),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    marilyn_busy = [\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60)\n    ]\n    ronald_busy = [\n        (9 * 60, 10 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60, 16 * 60 + 30)\n    ]\n\n    # Juan cannot meet after 16:00, so adjust his availability\n    juan_max_end = 16 * 60\n\n    # Generate all possible slots within work hours\n    for start in range(work_start, work_end - meeting_duration + 1, 15):  # check every 15 minutes\n        end = start + meeting_duration\n        # Check if the slot is within Juan's max end time\n        if end > juan_max_end:\n            continue\n        # Check if the slot is free for all participants\n        juan_free = all(end <= busy_start or start >= busy_end for busy_start, busy_end in juan_busy)\n        marilyn_free = all(end <= busy_start or start >= busy_end for busy_start, busy_end in marilyn_busy)\n        ronald_free = all(end <= busy_start or start >= busy_end for busy_start, busy_end in ronald_busy)\n        if juan_free and marilyn_free and ronald_free:\n            # Convert back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = end // 60\n            end_mm = end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return \"No suitable time found\"\n\n# Run the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_98"
        },
        {
            "final_program_time": "{10:30:11:00}",
            "expected_time": "{10:30:11:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Evelyn's constraints: available all day but doesn't want to meet after 13:00\n    evelyn_start = work_start\n    evelyn_end = 13 * 60  # 13:00 in minutes\n    \n    # Randy's blocked times in minutes\n    randy_blocked = [\n        (9 * 60, 10 * 60 + 30),  # 9:00-10:30\n        (11 * 60, 15 * 60 + 30),  # 11:00-15:30\n        (16 * 60, 17 * 60)        # 16:00-17:00\n    ]\n    \n    meeting_duration = 30  # minutes\n    \n    # Find available slots for Randy outside blocked times\n    randy_available = []\n    previous_end = work_start\n    \n    for start, end in sorted(randy_blocked):\n        if start > previous_end:\n            randy_available.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if previous_end < work_end:\n        randy_available.append((previous_end, work_end))\n    \n    # Find overlapping slots between Evelyn and Randy\n    for r_start, r_end in randy_available:\n        # Adjust Randy's slot to fit within Evelyn's availability\n        slot_start = max(r_start, evelyn_start)\n        slot_end = min(r_end, evelyn_end)\n        \n        if slot_end - slot_start >= meeting_duration:\n            # Convert minutes back to HH:MM format\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            return f\"{meeting_start//60:02d}:{meeting_start%60:02d}:{meeting_end//60:02d}:{meeting_end%60:02d}\"\n    \n    return \"No suitable time found\"\n\n# Output the proposed meeting time\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_555"
        },
        {
            "final_program_time": "{14:00:15:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    meeting_duration = 60  # minutes\n    \n    # Define blocked times for each participant per day in minutes since midnight\n    blocked_times = {\n        'Judith': {\n            'Monday': [(12 * 60, 12 * 60 + 30)],\n            'Wednesday': [(11 * 60 + 30, 12 * 60)],\n        },\n        'Timothy': {\n            'Monday': [\n                (9 * 60 + 30, 10 * 60),\n                (10 * 60 + 30, 11 * 60 + 30),\n                (12 * 60 + 30, 14 * 60),\n                (15 * 60 + 30, 17 * 60)\n            ],\n            'Tuesday': [\n                (9 * 60 + 30, 13 * 60),\n                (13 * 60 + 30, 14 * 60),\n                (14 * 60 + 30, 17 * 60)\n            ],\n            'Wednesday': [\n                (9 * 60, 9 * 60 + 30),\n                (10 * 60 + 30, 11 * 60),\n                (13 * 60 + 30, 14 * 60 + 30),\n                (15 * 60, 15 * 60 + 30),\n                (16 * 60, 16 * 60 + 30)\n            ],\n        }\n    }\n    \n    # Judith's preferences: avoid Monday and Wednesday before 12:00\n    preferred_days = ['Tuesday', 'Wednesday']\n    \n    # Iterate through each day in preferred order\n    for day in preferred_days:\n        if day == 'Monday':\n            continue  # Judith prefers to avoid Monday\n        \n        # Get all blocked times for both participants on this day\n        judith_blocked = blocked_times['Judith'].get(day, [])\n        timothy_blocked = blocked_times['Timothy'].get(day, [])\n        \n        # Combine and sort all blocked times\n        all_blocked = sorted(judith_blocked + timothy_blocked, key=lambda x: x[0])\n        \n        # Check available slots\n        prev_end = work_start\n        for start, end in all_blocked:\n            if start > prev_end:\n                available_start = prev_end\n                available_end = start\n                if available_end - available_start >= meeting_duration:\n                    # Check Judith's preference for Wednesday before 12:00\n                    if day == 'Wednesday' and available_start < 12 * 60:\n                        continue\n                    # Found a suitable slot\n                    return f\"{minutes_to_time(available_start)}:{minutes_to_time(available_start + meeting_duration)}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after last blocked time\n        if work_end - prev_end >= meeting_duration:\n            # Check Judith's preference for Wednesday before 12:00\n            if day == 'Wednesday' and prev_end < 12 * 60:\n                continue\n            return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + meeting_duration)}\"\n    \n    # If no preferred day works, check Monday (though Judith prefers to avoid)\n    day = 'Monday'\n    judith_blocked = blocked_times['Judith'].get(day, [])\n    timothy_blocked = blocked_times['Timothy'].get(day, [])\n    all_blocked = sorted(judith_blocked + timothy_blocked, key=lambda x: x[0])\n    \n    prev_end = work_start\n    for start, end in all_blocked:\n        if start > prev_end:\n            available_start = prev_end\n            available_end = start\n            if available_end - available_start >= meeting_duration:\n                return f\"{minutes_to_time(available_start)}:{minutes_to_time(available_start + meeting_duration)}\"\n        prev_end = max(prev_end, end)\n    \n    if work_end - prev_end >= meeting_duration:\n        return f\"{minutes_to_time(prev_end)}:{minutes_to_time(prev_end + meeting_duration)}\"\n    \n    return \"No suitable time found\"\n\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Execute and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_784"
        },
        {
            "final_program_time": "{12:00:13:00}",
            "expected_time": "{12:00:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Days to consider: Monday (0), Tuesday (1), Wednesday (2), Thursday (3)\n    days = [0, 1, 2, 3]\n    \n    # Laura's busy times in minutes since midnight for each day\n    laura_busy = {\n        0: [(10 * 60 + 30, 11 * 60), (12 * 60 + 30, 13 * 60), (14 * 60 + 30, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        1: [(9 * 60 + 30, 10 * 60), (11 * 60, 11 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60), (16 * 60, 17 * 60)],\n        2: [(11 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60), (15 * 60 + 30, 16 * 60 + 30)],\n        3: [(10 * 60 + 30, 11 * 60), (12 * 60, 13 * 60 + 30), (15 * 60, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)],\n    }\n    \n    # Philip's busy times in minutes since midnight for each day\n    philip_busy = {\n        0: [(9 * 60, 17 * 60)],\n        1: [(9 * 60, 11 * 60), (11 * 60 + 30, 12 * 60), (13 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30), (15 * 60, 16 * 60 + 30)],\n        2: [(9 * 60, 10 * 60), (11 * 60, 12 * 60), (12 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        3: [(9 * 60, 10 * 60 + 30), (11 * 60, 12 * 60 + 30), (13 * 60, 17 * 60)],\n    }\n    \n    # Philip cannot meet on Wednesday (day 2)\n    available_days = [day for day in days if day != 2]\n    \n    meeting_duration = 60  # 1 hour\n    \n    for day in available_days:\n        # Combine and sort all busy intervals for both participants\n        all_busy = laura_busy.get(day, []) + philip_busy.get(day, [])\n        all_busy.sort()\n        \n        # Merge overlapping or adjacent intervals\n        merged = []\n        for start, end in all_busy:\n            if not merged:\n                merged.append((start, end))\n            else:\n                last_start, last_end = merged[-1]\n                if start <= last_end:\n                    merged[-1] = (last_start, max(end, last_end))\n                else:\n                    merged.append((start, end))\n        \n        # Check the time before the first busy interval\n        if len(merged) == 0:\n            # No busy intervals, the whole day is free\n            proposed_start = work_start\n            proposed_end = proposed_start + meeting_duration\n            if proposed_end <= work_end:\n                return f\"{proposed_start // 60:02d}:{proposed_start % 60:02d}:{proposed_end // 60:02d}:{proposed_end % 60:02d}\"\n        else:\n            first_start, first_end = merged[0]\n            if work_start + meeting_duration <= first_start:\n                proposed_start = work_start\n                proposed_end = proposed_start + meeting_duration\n                return f\"{proposed_start // 60:02d}:{proposed_start % 60:02d}:{proposed_end // 60:02d}:{proposed_end % 60:02d}\"\n        \n        # Check the time between busy intervals\n        for i in range(len(merged) - 1):\n            current_end = merged[i][1]\n            next_start = merged[i + 1][0]\n            if next_start - current_end >= meeting_duration:\n                proposed_start = current_end\n                proposed_end = proposed_start + meeting_duration\n                if proposed_end <= work_end:\n                    return f\"{proposed_start // 60:02d}:{proposed_start % 60:02d}:{proposed_end // 60:02d}:{proposed_end % 60:02d}\"\n        \n        # Check the time after the last busy interval\n        if len(merged) > 0:\n            last_start, last_end = merged[-1]\n            if last_end + meeting_duration <= work_end:\n                proposed_start = last_end\n                proposed_end = proposed_start + meeting_duration\n                return f\"{proposed_start // 60:02d}:{proposed_start % 60:02d}:{proposed_end // 60:02d}:{proposed_end % 60:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_825"
        },
        {
            "final_program_time": "{12:30:13:00}",
            "expected_time": "{12:30:13:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    meeting_duration = 30  # minutes\n\n    # Define busy times for Joshua and Joyce in minutes since midnight\n    joshua_busy = {\n        'Monday': [(15 * 60, 15 * 60 + 30)],\n        'Tuesday': [(11 * 60 + 30, 12 * 60), (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60)],\n        'Wednesday': []\n    }\n    \n    joyce_busy = {\n        'Monday': [(9 * 60, 9 * 60 + 30), (10 * 60, 11 * 60), (11 * 60 + 30, 12 * 60 + 30),\n                   (13 * 60, 15 * 60), (15 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 9 * 60 + 30), (10 * 60, 11 * 60), (12 * 60 + 30, 15 * 60 + 30),\n                     (16 * 60, 16 * 60 + 30)]\n    }\n\n    # Iterate through each day to find a suitable time\n    for day in days:\n        if day == 'Monday':\n            # Joyce prefers not to meet before 12:00 on Monday\n            start_time = max(work_start, 12 * 60)\n        else:\n            start_time = work_start\n\n        # Generate all possible slots for the day\n        current_time = start_time\n        while current_time + meeting_duration <= work_end:\n            slot_end = current_time + meeting_duration\n            # Check if the slot is free for both\n            joshua_free = True\n            for busy_start, busy_end in joshua_busy[day]:\n                if not (slot_end <= busy_start or current_time >= busy_end):\n                    joshua_free = False\n                    break\n            joyce_free = True\n            for busy_start, busy_end in joyce_busy[day]:\n                if not (slot_end <= busy_start or current_time >= busy_end):\n                    joyce_free = False\n                    break\n            if joshua_free and joyce_free:\n                # Format the time as HH:MM:HH:MM\n                start_hh = current_time // 60\n                start_mm = current_time % 60\n                end_hh = slot_end // 60\n                end_mm = slot_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n            current_time += 15  # Check in 15-minute increments\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_765"
        },
        {
            "final_program_time": null,
            "expected_time": "{16:30:17:00}",
            "type_error": "ValueError",
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all times to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        personal_busy = []\n        for block in schedule:\n            start, end = map(time_to_minutes, block.split(':'))\n            personal_busy.append((start, end))\n        busy_intervals.append(personal_busy)\n    \n    # Find all possible meeting start times in 15-minute increments within work hours\n    possible_starts = []\n    for start in range(work_start, work_end - duration + 1, 15):\n        end = start + duration\n        valid = True\n        # Check against each participant's busy intervals\n        for participant in busy_intervals:\n            for (busy_start, busy_end) in participant:\n                if not (end <= busy_start or start >= busy_end):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            possible_starts.append(start)\n    \n    if not possible_starts:\n        return None\n    \n    # Convert the first valid start time back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    meeting_start = possible_starts[0]\n    meeting_end = meeting_start + duration\n    return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n# Define the participants' schedules\ndiane_schedule = [\"9:30:10:00\", \"14:30:15:00\"]\njack_schedule = [\"13:30:14:00\", \"14:30:15:00\"]\neugene_schedule = [\"9:00:10:00\", \"10:30:11:30\", \"12:00:14:30\", \"15:00:16:30\"]\npatricia_schedule = [\"9:30:10:30\", \"11:00:12:00\", \"12:30:14:00\", \"15:00:16:30\"]\n\nparticipants_schedules = [diane_schedule, jack_schedule, eugene_schedule, patricia_schedule]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, \"9:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_103"
        },
        {
            "final_program_time": "{15:30:16:30}",
            "expected_time": "{15:30:16:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Define blocked times for each participant per day in minutes since midnight\n    martha_blocked = {\n        'Monday': [(16 * 60, 17 * 60)],\n        'Tuesday': [(15 * 60, 15 * 60 + 30)],\n        'Wednesday': [(10 * 60, 11 * 60), (14 * 60, 14 * 60 + 30)]\n    }\n\n    beverly_blocked = {\n        'Monday': [(9 * 60, 13 * 60 + 30), (14 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60 + 30, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)]\n    }\n\n    # Iterate through each day to find a suitable time slot\n    for day in days:\n        # Collect all blocked times for both participants on this day\n        blocked_times = martha_blocked.get(day, []) + beverly_blocked.get(day, [])\n        blocked_times.sort()  # Sort by start time\n\n        # Check available slots before the first blocked time\n        prev_end = work_start\n        for start, end in blocked_times:\n            if start > prev_end:\n                available_start = prev_end\n                available_end = start\n                if available_end - available_start >= meeting_duration:\n                    # Found a suitable slot\n                    meeting_start = available_start\n                    meeting_end = meeting_start + meeting_duration\n                    # Format the time as HH:MM:HH:MM\n                    return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n            prev_end = max(prev_end, end)\n\n        # Check after the last blocked time\n        if prev_end < work_end and work_end - prev_end >= meeting_duration:\n            meeting_start = prev_end\n            meeting_end = meeting_start + meeting_duration\n            return f\"{meeting_start // 60:02d}:{meeting_start % 60:02d}:{meeting_end // 60:02d}:{meeting_end % 60:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_767"
        },
        {
            "final_program_time": "{11:00:11:30}",
            "expected_time": "{11:00:11:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for meeting in schedule:\n            start, end = map(time_to_minutes, meeting.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals_sorted = sorted(busy_intervals, key=lambda x: x[0])\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals_sorted:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = last_start\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find the earliest available slot\n    previous_end = work_start\n    for start, end in merged:\n        if start - previous_end >= duration_minutes:\n            # Found a slot\n            meeting_start = previous_end\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n        previous_end = max(previous_end, end)\n    \n    # Check after the last meeting\n    if work_end - previous_end >= duration_minutes:\n        meeting_start = previous_end\n        meeting_end = meeting_start + duration_minutes\n        def minutes_to_time(minutes):\n            hh = minutes // 60\n            mm = minutes % 60\n            return f\"{hh:02d}:{mm:02d}\"\n        return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return \"No available slot found\"\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"11:30 to 12:00\", \"14:30 to 15:00\"],  # Joan\n    [\"09:00 to 10:00\", \"14:00 to 14:30\", \"16:00 to 16:30\"],  # Megan\n    [],  # Austin\n    [\"09:30 to 10:00\", \"11:30 to 12:00\", \"13:30 to 14:00\", \"16:00 to 16:30\"],  # Betty\n    [\"09:00 to 11:00\", \"12:00 to 13:00\", \"14:00 to 15:00\"],  # Judith\n    [\"09:30 to 10:00\", \"11:30 to 12:30\", \"13:00 to 14:00\", \"15:00 to 15:30\", \"16:00 to 17:00\"],  # Terry\n    [\"09:30 to 10:00\", \"10:30 to 11:00\", \"11:30 to 13:00\", \"14:00 to 16:00\", \"16:30 to 17:00\"],  # Kathryn\n]\n\n# Find a 30-minute meeting between 9:00 and 17:00\nmeeting_time = find_meeting_time(participants_schedules, \"09:00\", \"17:00\", 30)\nprint(meeting_time)\n```",
            "count": "calendar_scheduling_example_441"
        },
        {
            "final_program_time": "{13:00:14:00}",
            "expected_time": "{13:00:14:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time(gary_schedule, david_schedule, work_hours_start, work_hours_end, days, duration_hours):\n    for day in days:\n        # Initialize available slots for the day\n        day_start = work_hours_start\n        day_end = work_hours_end\n        \n        # Get blocked times for Gary and David on the current day\n        gary_blocked = gary_schedule.get(day, [])\n        david_blocked = david_schedule.get(day, [])\n        \n        # Combine and sort all blocked times\n        all_blocked = gary_blocked + david_blocked\n        all_blocked.sort()\n        \n        # Merge overlapping or adjacent blocked times\n        merged_blocked = []\n        for start, end in all_blocked:\n            if not merged_blocked:\n                merged_blocked.append([start, end])\n            else:\n                last_start, last_end = merged_blocked[-1]\n                if start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged_blocked[-1] = [new_start, new_end]\n                else:\n                    merged_blocked.append([start, end])\n        \n        # Find available slots by subtracting blocked times from work hours\n        available_slots = []\n        prev_end = day_start\n        \n        for start, end in merged_blocked:\n            if start > prev_end:\n                available_slots.append([prev_end, start])\n            prev_end = max(prev_end, end)\n        \n        if prev_end < day_end:\n            available_slots.append([prev_end, day_end])\n        \n        # Check each available slot for sufficient duration\n        for slot_start, slot_end in available_slots:\n            slot_duration = (slot_end - slot_start).total_seconds() / 3600\n            if slot_duration >= duration_hours:\n                meeting_start = slot_start\n                meeting_end = meeting_start + timedelta(hours=duration_hours)\n                return f\"{meeting_start.strftime('%H:%M')}:{meeting_end.strftime('%H:%M')}\"\n    \n    return \"No suitable time found\"\n\nfrom datetime import datetime, timedelta\n\n# Define work hours\nwork_hours_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_hours_end = datetime.strptime(\"17:00\", \"%H:%M\")\n\n# Define days to check\ndays = [\"Monday\", \"Tuesday\"]\n\n# Define duration in hours\nduration_hours = 1\n\n# Define Gary's schedule\ngary_schedule = {\n    \"Monday\": [\n        (datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"10:00\", \"%H:%M\")),\n        (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n        (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\")),\n        (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))\n    ],\n    \"Tuesday\": [\n        (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n        (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:00\", \"%H:%M\")),\n        (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\"))\n    ]\n}\n\n# Define David's schedule\ndavid_schedule = {\n    \"Monday\": [\n        (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n        (datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n        (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))\n    ],\n    \"Tuesday\": [\n        (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"09:30\", \"%H:%M\")),\n        (datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"10:30\", \"%H:%M\")),\n        (datetime.strptime(\"11:00\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n        (datetime.strptime(\"13:00\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\")),\n        (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\")),\n        (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))\n    ]\n}\n\n# Find meeting time\nresult = find_meeting_time(gary_schedule, david_schedule, work_hours_start, work_hours_end, days, duration_hours)\nprint(result)\n```",
            "count": "calendar_scheduling_example_662"
        },
        {
            "final_program_time": "{9:30:10:30}",
            "expected_time": "{9:30:10:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    meeting_duration = 60  # minutes\n    \n    # Define each person's schedule as blocked times in minutes since midnight\n    stephanie_schedule = {\n        'Monday': [(9*60 + 30, 10*60), (10*60 + 30, 11*60), (11*60 + 30, 12*60), (14*60, 14*60 + 30)],\n        'Tuesday': [(12*60, 13*60)],\n        'Wednesday': [(9*60, 10*60), (13*60, 14*60)]\n    }\n    \n    betty_schedule = {\n        'Monday': [(9*60, 10*60), (11*60, 11*60 + 30), (14*60 + 30, 15*60), (15*60 + 30, 16*60)],\n        'Tuesday': [(9*60, 9*60 + 30), (11*60 + 30, 12*60), (12*60 + 30, 14*60 + 30), (15*60 + 30, 16*60)],\n        'Wednesday': [(10*60, 11*60 + 30), (12*60, 14*60), (14*60 + 30, 17*60)]\n    }\n    \n    # Check each day for available slots\n    for day in days:\n        if day == 'Monday' and 'Stephanie would like to avoid more meetings on Monday':\n            continue\n        \n        # Combine and sort all busy times for the day\n        busy_times = []\n        if day in stephanie_schedule:\n            busy_times.extend(stephanie_schedule[day])\n        if day in betty_schedule:\n            busy_times.extend(betty_schedule[day])\n        \n        # Handle Betty's Tuesday constraint\n        if day == 'Tuesday':\n            # Remove Betty's times after 12:30\n            betty_tuesday = betty_schedule['Tuesday']\n            filtered_betty_tuesday = [slot for slot in betty_tuesday if slot[1] <= 12*60 + 30]\n            # Rebuild busy_times for Tuesday\n            busy_times = []\n            if day in stephanie_schedule:\n                busy_times.extend(stephanie_schedule[day])\n            busy_times.extend(filtered_betty_tuesday)\n        \n        # Sort all busy times by start time\n        busy_times.sort()\n        \n        # Find free slots by checking gaps between busy times\n        prev_end = work_start\n        for start, end in busy_times:\n            if start > prev_end:\n                # Found a free slot\n                free_slot_start = prev_end\n                free_slot_end = start\n                if free_slot_end - free_slot_start >= meeting_duration:\n                    # Convert minutes back to HH:MM format\n                    start_hh = free_slot_start // 60\n                    start_mm = free_slot_start % 60\n                    end_hh = (free_slot_start + meeting_duration) // 60\n                    end_mm = (free_slot_start + meeting_duration) % 60\n                    return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n            prev_end = max(prev_end, end)\n        \n        # Check after last meeting\n        if work_end - prev_end >= meeting_duration:\n            start_hh = prev_end // 60\n            start_mm = prev_end % 60\n            end_hh = (prev_end + meeting_duration) // 60\n            end_mm = (prev_end + meeting_duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_703"
        },
        {
            "final_program_time": "{9:30:10:00}",
            "expected_time": "{9:30:10:00}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to consider (Monday to Thursday)\n    days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\"]\n    \n    # Cheryl's preferences: avoid Wednesday and Thursday\n    preferred_days = [\"Monday\", \"Tuesday\"]\n    \n    # James's schedule: each day's busy slots in minutes\n    james_schedule = {\n        \"Monday\": [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 11 * 60), \n                   (12 * 60 + 30, 13 * 60), (14 * 60 + 30, 15 * 60 + 30), \n                   (16 * 60 + 30, 17 * 60)],\n        \"Tuesday\": [(9 * 60, 11 * 60), (11 * 60 + 30, 12 * 60), \n                    (12 * 60 + 30, 15 * 60 + 30), (16 * 60, 17 * 60)],\n        \"Wednesday\": [(10 * 60, 11 * 60), (12 * 60, 13 * 60), \n                      (13 * 60 + 30, 16 * 60)],\n        \"Thursday\": [(9 * 60 + 30, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), \n                     (13 * 60, 13 * 60 + 30), (14 * 60, 14 * 60 + 30), \n                     (16 * 60 + 30, 17 * 60)]\n    }\n    \n    meeting_duration = 30  # minutes\n    \n    # Iterate over preferred days first (Monday, Tuesday)\n    for day in preferred_days:\n        busy_slots = james_schedule[day]\n        free_slots = []\n        \n        # Find free slots before first busy slot\n        if busy_slots[0][0] > work_start:\n            free_slots.append((work_start, busy_slots[0][0]))\n        \n        # Find free slots between busy slots\n        for i in range(1, len(busy_slots)):\n            prev_end = busy_slots[i-1][1]\n            curr_start = busy_slots[i][0]\n            if curr_start > prev_end:\n                free_slots.append((prev_end, curr_start))\n        \n        # Find free slots after last busy slot\n        if busy_slots[-1][1] < work_end:\n            free_slots.append((busy_slots[-1][1], work_end))\n        \n        # Check each free slot for availability\n        for slot in free_slots:\n            start, end = slot\n            if end - start >= meeting_duration:\n                # Found earliest available slot\n                meeting_start = start\n                meeting_end = meeting_start + meeting_duration\n                # Convert back to HH:MM format\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    # If no slot found in preferred days, check other days (though Cheryl prefers not)\n    for day in [\"Wednesday\", \"Thursday\"]:\n        busy_slots = james_schedule[day]\n        free_slots = []\n        \n        if busy_slots[0][0] > work_start:\n            free_slots.append((work_start, busy_slots[0][0]))\n        \n        for i in range(1, len(busy_slots)):\n            prev_end = busy_slots[i-1][1]\n            curr_start = busy_slots[i][0]\n            if curr_start > prev_end:\n                free_slots.append((prev_end, curr_start))\n        \n        if busy_slots[-1][1] < work_end:\n            free_slots.append((busy_slots[-1][1], work_end))\n        \n        for slot in free_slots:\n            start, end = slot\n            if end - start >= meeting_duration:\n                meeting_start = start\n                meeting_end = meeting_start + meeting_duration\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No available slot found\"\n\n# Output the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_826"
        },
        {
            "final_program_time": "{9:00:9:30}",
            "expected_time": "{9:00:9:30}",
            "type_error": null,
            "full_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define days to consider\n    days = ['Monday', 'Tuesday', 'Wednesday']\n\n    # Define Samuel's busy times in minutes since midnight\n    samuel_busy = {\n        'Monday': [\n            (10 * 60 + 30, 11 * 60),    # 10:30-11:00\n            (12 * 60, 12 * 60 + 30),     # 12:00-12:30\n            (13 * 60, 15 * 60),          # 13:00-15:00\n            (15 * 60 + 30, 16 * 60 + 30) # 15:30-16:30\n        ],\n        'Tuesday': [\n            (9 * 60, 12 * 60),          # 9:00-12:00\n            (14 * 60, 15 * 60 + 30),     # 14:00-15:30\n            (16 * 60 + 30, 17 * 60)      # 16:30-17:00\n        ],\n        'Wednesday': [\n            (10 * 60 + 30, 11 * 60),    # 10:30-11:00\n            (11 * 60 + 30, 12 * 60),     # 11:30-12:00\n            (12 * 60 + 30, 13 * 60),     # 12:30-13:00\n            (14 * 60, 14 * 60 + 30),     # 14:00-14:30\n            (15 * 60, 16 * 60)           # 15:00-16:00\n        ]\n    }\n\n    # Duration of the meeting in minutes\n    duration = 30\n\n    # Preferences: avoid Wednesday for Larry, avoid Tuesday for Samuel\n    preferred_days_order = ['Monday', 'Wednesday', 'Tuesday']\n\n    # Iterate through days in preferred order\n    for day in preferred_days_order:\n        if day not in days:\n            continue\n\n        # Get Samuel's busy times for the day\n        busy_times = samuel_busy.get(day, [])\n        \n        # Find all available slots in the day\n        available_slots = []\n        prev_end = work_start\n\n        # Sort busy times by start time\n        busy_times_sorted = sorted(busy_times, key=lambda x: x[0])\n\n        for busy_start, busy_end in busy_times_sorted:\n            if busy_start > prev_end:\n                available_slots.append((prev_end, busy_start))\n            prev_end = max(prev_end, busy_end)\n\n        # Check after last busy time\n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n\n        # Find the first available slot that fits the duration\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= duration:\n                # Convert minutes back to HH:MM format\n                start_hh = slot_start // 60\n                start_mm = slot_start % 60\n                end_hh = (slot_start + duration) // 60\n                end_mm = (slot_start + duration) % 60\n                return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\n# Execute and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_704"
        }
    ]
}