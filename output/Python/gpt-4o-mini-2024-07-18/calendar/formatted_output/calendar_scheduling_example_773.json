{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "10:00",
                "end_time": "11:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "9:00",
                "end_time": "10:00"
            },
            "has_error": false,
            "raw_model_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participant_schedules, meeting_duration, available_days):\n    work_hours = (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))\n    \n    # Store availability for each day\n    availability = {}\n    \n    for day in available_days:\n        availability[day] = []\n        for start, end in participant_schedules[day]:\n            available_start = max(work_hours[0], start)\n            available_end = min(work_hours[1], end)\n            if available_start < available_end:\n                availability[day].append((available_start, available_end))\n    \n    # Check for times in each day\n    for day, times in availability.items():\n        merged_times = merge_intervals(times)\n\n        for start, end in merged_times:\n            if end - start >= meeting_duration:\n                meeting_start = start\n                meeting_end = start + meeting_duration\n                if meeting_end <= end:\n                    return day, meeting_start.strftime(\"%H:%M\"), meeting_end.strftime(\"%H:%M\")\n    \n    return None\n\ndef merge_intervals(intervals):\n    if not intervals:\n        return []\n    \n    # Sort intervals based on the starting time\n    intervals.sort(key=lambda x: x[0])\n    \n    merged = []\n    current_start, current_end = intervals[0]\n    \n    for start, end in intervals[1:]:\n        if start <= current_end:  # Overlapping intervals\n            current_end = max(current_end, end)\n        else:\n            merged.append((current_start, current_end))\n            current_start, current_end = start, end\n            \n    merged.append((current_start, current_end))\n    return merged\n\n# Participant schedules\nschedules = {\n    \"Monday\": [\n        (datetime.strptime(\"10:00\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n        (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"13:00\", \"%H:%M\")),\n        (datetime.strptime(\"14:00\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\")),\n        (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))\n    ],\n    \"Tuesday\": [\n        (datetime.strptime(\"10:30\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n        (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"14:30\", \"%H:%M\")),\n        (datetime.strptime(\"15:00\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\")),\n        (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))\n    ],\n    \"Wednesday\": [\n        (datetime.strptime(\"09:30\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n        (datetime.strptime(\"12:30\", \"%H:%M\"), datetime.strptime(\"14:00\", \"%H:%M\")),\n        (datetime.strptime(\"14:30\", \"%H:%M\"), datetime.strptime(\"15:30\", \"%H:%M\")),\n        (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))\n    ]\n}\n\nmeeting_time = find_meeting_time(schedules, timedelta(hours=1), [\"Monday\", \"Tuesday\", \"Wednesday\"])\nif meeting_time:\n    print(f\"{meeting_time[1]}:{meeting_time[2]}:{meeting_time[0]}\")\n```",
            "count": "calendar_scheduling_example_773"
        }
    ]
}