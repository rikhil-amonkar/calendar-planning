[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Ryan and Adam for half an hour between the work hours of 9:00 to 17:00 on either Monday, Tuesday or Wednesday. \n\nHere are the existing schedules for everyone during the days: \nRyan has meetings on Monday during 9:30 to 10:00, 11:00 to 12:00, 13:00 to 13:30, 15:30 to 16:00, Tuesday during 11:30 to 12:30, 15:30 to 16:00, Wednesday during 12:00 to 13:00, 15:30 to 16:00, 16:30 to 17:00; \nAdam is busy on Monday during 9:00 to 10:30, 11:00 to 13:30, 14:00 to 16:00, 16:30 to 17:00, Tuesday during 9:00 to 10:00, 10:30 to 15:30, 16:00 to 17:00, Wednesday during 9:00 to 9:30, 10:00 to 11:00, 11:30 to 14:30, 15:00 to 15:30, 16:00 to 16:30; \n\nRyan can not meet on Wednesday. Adam would like to avoid more meetings on Monday before 14:30. Tuesday. Find a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(ryan_schedule, adam_schedule, meeting_duration, preferred_days):\n    # Convert schedules to datetime objects\n    ryan_schedule = {datetime.strptime(key, '%H:%M'): datetime.strptime(value, '%H:%M') for key, value in ryan_schedule.items()}\n    adam_schedule = {datetime.strptime(key, '%H:%M'): datetime.strptime(value, '%H:%M') for key, value in adam_schedule.items()}\n\n    # Sort schedules by start time\n    ryan_schedule = dict(sorted(ryan_schedule.items()))\n    adam_schedule = dict(sorted(adam_schedule.items()))\n\n    # Find available time slots for both participants\n    available_time_slots = []\n    for day in preferred_days:\n        if day == 'Monday':\n            start_time = datetime.strptime('09:00', '%H:%M')\n            end_time = datetime.strptime('17:00', '%H:%M')\n        elif day == 'Tuesday':\n            start_time = datetime.strptime('09:00', '%H:%M')\n            end_time = datetime.strptime('17:00', '%H:%M')\n        elif day == 'Wednesday':\n            start_time = datetime.strptime('09:00', '%H:%M')\n            end_time = datetime.strptime('17:00', '%H:%M')\n\n        while start_time < end_time:\n            # Check if Ryan is available\n            if start_time not in ryan_schedule and (start_time + timedelta(minutes=meeting_duration)) not in ryan_schedule:\n                # Check if Adam is available\n                if start_time not in adam_schedule and (start_time + timedelta(minutes=meeting_duration)) not in adam_schedule:\n                    available_time_slots.append((start_time.strftime('%H:%M'), (start_time + timedelta(minutes=meeting_duration)).strftime('%H:%M'), day))\n\n            start_time += timedelta(minutes=1)\n\n    # Find the first available time slot that meets all constraints\n    for time_slot in available_time_slots:\n        start_time = time_slot[0]\n        end_time = time_slot[1]\n        day = time_slot[2]\n\n        if day == 'Monday':\n            if int(start_time[:2]) >= 14 and int(end_time[:2]) <= 15:\n                return f'{start_time}:{end_time} on {day}'\n        elif day == 'Tuesday':\n            return f'{start_time}:{end_time} on {day}'\n        elif day == 'Wednesday':\n            return f'{start_time}:{end_time} on {day}'\n\n    return \"No available time slot found\"\n\n# Example usage:\nryan_schedule = {\n    '09:30': '10:00',\n    '11:00': '12:00',\n    '13:00': '13:30',\n    '15:30': '16:00',\n    '11:30': '12:30',\n    '15:30': '16:00',\n    '12:00': '13:00',\n    '15:30': '16:00',\n    '16:30': '17:00'\n}\nadam_schedule = {\n    '09:00': '10:30',\n    '11:00': '13:30',\n    '14:00': '16:00',\n    '16:30': '17:00',\n    '09:00': '10:00',\n    '10:30': '15:30',\n    '16:00': '17:00',\n    '09:00': '09:30',\n    '10:00': '11:00',\n    '11:30': '14:30',\n    '15:00': '15:30',\n    '16:00': '16:30'\n}\nmeeting_duration = 30\npreferred_days = ['Monday', 'Tuesday', 'Wednesday']\n\nprint(find_meeting_time(ryan_schedule, adam_schedule, meeting_duration, preferred_days))\n```\n\nThe script first converts the schedules to datetime objects and sorts them by start time. It then finds available time slots for both participants by iterating over the preferred days. For each time slot, it checks if both participants are available. If they are, it adds the time slot to the list of available time slots. Finally, it finds the first available time slot that meets all constraints and returns it in the format HH:MM:HH:MM on Day of the week."
    }
]