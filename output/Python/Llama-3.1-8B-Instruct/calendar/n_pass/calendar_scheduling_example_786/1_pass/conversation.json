[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Amy and Pamela for half an hour between the work hours of 9:00 to 17:00 on either Monday, Tuesday or Wednesday. \n\nHere are the existing schedules for everyone during the days: \nAmy is busy on Wednesday during 11:00 to 11:30, 13:30 to 14:00; \nPamela is busy on Monday during 9:00 to 10:30, 11:00 to 16:30, Tuesday during 9:00 to 9:30, 10:00 to 17:00, Wednesday during 9:00 to 9:30, 10:00 to 11:00, 11:30 to 13:30, 14:30 to 15:00, 16:00 to 16:30; \n\nPamela would like to avoid more meetings on Monday. Tuesday. Wednesday before 16:00. Find a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(amy_schedule, pamela_schedule, meeting_duration, preferences):\n    \"\"\"\n    Find a suitable time for a meeting between Amy and Pamela.\n\n    Args:\n    amy_schedule (dict): Amy's schedule with busy times as tuples of (start, end).\n    pamela_schedule (dict): Pamela's schedule with busy times as tuples of (start, end).\n    meeting_duration (int): The duration of the meeting in minutes.\n    preferences (dict): Preferences for meeting time, e.g., 'avoid_monday', 'avoid_tuesday', 'avoid_before_16:00'.\n\n    Returns:\n    tuple: A proposed meeting time as (day, start_time, end_time) and a boolean indicating whether the time is valid.\n    \"\"\"\n\n    # Define the work hours and days\n    work_hours = (9, 17)\n    work_days = ['Monday', 'Tuesday', 'Wednesday']\n\n    # Initialize the proposed meeting time\n    proposed_time = None\n\n    # Iterate over each day\n    for day in work_days:\n        # Iterate over each hour in the work hours\n        for hour in range(work_hours[0], work_hours[1]):\n            # Convert the hour to a datetime object\n            start_time = datetime.strptime(f'{day} {hour}:00', '%A %H:%M')\n            end_time = start_time + timedelta(minutes=meeting_duration)\n\n            # Check if the time is within the work hours\n            if start_time.hour >= work_hours[0] and end_time.hour <= work_hours[1]:\n                # Check if the time is not busy for Amy\n                if not any(start_time >= amy_start and end_time <= amy_end for amy_start, amy_end in amy_schedule.get(day, [])):\n                    # Check if the time is not busy for Pamela\n                    if not any(start_time >= pamela_start and end_time <= pamela_end for pamela_start, pamela_end in pamela_schedule.get(day, [])):\n                        # Check if the time meets the preferences\n                        if not (preferences.get('avoid_monday') and day == 'Monday') and \\\n                           not (preferences.get('avoid_tuesday') and day == 'Tuesday') and \\\n                           not (preferences.get('avoid_before_16:00') and start_time.hour < 16):\n                            # If all conditions are met, propose this time\n                            proposed_time = (day, start_time.strftime('%H:%M'), end_time.strftime('%H:%M'))\n                            break\n\n        # If a proposed time is found, break the loop\n        if proposed_time:\n            break\n\n    return proposed_time\n\n\n# Define the schedules and preferences\namy_schedule = {\n    'Monday': [],\n    'Tuesday': [],\n    'Wednesday': [(11, 11.5), (13.5, 14)]\n}\n\npamela_schedule = {\n    'Monday': [(9, 10.5), (11, 16.5)],\n    'Tuesday': [(9, 9.5), (10, 17)],\n    'Wednesday': [(9, 9.5), (10, 11), (11.5, 13.5), (14.5, 15), (16, 16.5)]\n}\n\npreferences = {\n    'avoid_monday': False,\n    'avoid_tuesday': False,\n    'avoid_before_16:00': False\n}\n\nmeeting_duration = 30  # minutes\n\n# Find and print the proposed meeting time\nproposed_time = find_meeting_time(amy_schedule, pamela_schedule, meeting_duration, preferences)\nif proposed_time:\n    print(f'{proposed_time[1]} - {proposed_time[2]} on {proposed_time[0]}')\nelse:\n    print('No proposed time found.')\n```\n\nThis script will output the proposed meeting time in the format `HH:MM - HH:MM on DAY`. If no proposed time is found, it will print `No proposed time found`."
    }
]