{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "11:30",
                "end_time": "12:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "12:30",
                "end_time": "13:00"
            },
            "has_error": false,
            "raw_model_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, meeting_duration, work_hours, days, preferences=None):\n    \"\"\"\n    Find a suitable time for a meeting based on the participants' schedules and constraints.\n\n    Args:\n    participants (dict): A dictionary of participants with their existing schedules.\n    meeting_duration (int): The duration of the meeting in minutes.\n    work_hours (tuple): A tuple representing the start and end time of work hours.\n    days (list): A list of days of the week.\n    preferences (dict): A dictionary of participants with their time preferences.\n\n    Returns:\n    str: A string representing the proposed meeting time in the format HH:MM:HH:MM and the day of the week.\n    \"\"\"\n\n    # Loop through each day\n    for day in days:\n        # Convert work hours to datetime objects\n        start_time = datetime.strptime(work_hours[0], '%H:%M')\n        end_time = datetime.strptime(work_hours[1], '%H:%M')\n\n        # Initialize the current time to the start of work hours\n        current_time = start_time\n\n        # Loop through each minute of the work hours\n        while current_time < end_time:\n            # Check if the current time slot is available for all participants\n            if is_time_slot_available(participants, current_time, meeting_duration, day):\n                # Check if the current time slot meets the preferences of all participants\n                if preferences is not None and not is_time_slot_preferred(preferences, current_time, day):\n                    # If not preferred, move to the next minute\n                    current_time += timedelta(minutes=1)\n                    continue\n                # If available and preferred, return the proposed meeting time\n                proposed_time = current_time.strftime('%H:%M') + ':' + (current_time + timedelta(minutes=meeting_duration)).strftime('%H:%M')\n                return proposed_time + ',' + day\n            # If not available, move to the next minute\n            current_time += timedelta(minutes=1)\n\ndef is_time_slot_available(participants, start_time, duration, day):\n    \"\"\"\n    Check if a time slot is available for all participants.\n\n    Args:\n    participants (dict): A dictionary of participants with their existing schedules.\n    start_time (datetime): The start time of the time slot.\n    duration (int): The duration of the time slot in minutes.\n    day (str): The day of the week.\n\n    Returns:\n    bool: True if the time slot is available for all participants, False otherwise.\n    \"\"\"\n\n    # Loop through each participant's schedule\n    for participant, schedule in participants.items():\n        # Check if the participant has a schedule for the given day\n        if day in schedule:\n            # Loop through each time slot in the participant's schedule\n            for time_slot in schedule[day]:\n                # Convert the time slot to datetime objects\n                time_slot_start = datetime.strptime(time_slot[0], '%H:%M')\n                time_slot_end = datetime.strptime(time_slot[1], '%H:%M')\n\n                # Check if the proposed time slot overlaps with the participant's schedule\n                if (start_time >= time_slot_start and start_time < time_slot_end) or (start_time + timedelta(minutes=duration) > time_slot_start and start_time + timedelta(minutes=duration) <= time_slot_end):\n                    # If overlapping, return False\n                    return False\n    # If no overlapping time slots found, return True\n    return True\n\ndef is_time_slot_preferred(preferences, start_time, day):\n    \"\"\"\n    Check if a time slot meets the preferences of all participants.\n\n    Args:\n    preferences (dict): A dictionary of participants with their time preferences.\n    start_time (datetime): The start time of the time slot.\n    day (str): The day of the week.\n\n    Returns:\n    bool: True if the time slot meets the preferences of all participants, False otherwise.\n    \"\"\"\n\n    # Loop through each participant's preferences\n    for participant, preference in preferences.items():\n        # Check if the start time meets the participant's preference\n        if preference['day'] == day and preference['end_time'] is not None and start_time > datetime.strptime(preference['end_time'], '%H:%M'):\n            # If not preferred, return False\n            return False\n    # If all preferences met, return True\n    return True\n\n# Define the participants' schedules\nparticipants = {\n    'Jean': {\n        'Tuesday': [('11:30', '12:00'), ('16:00', '16:30')]\n    },\n    'Doris': {\n        'Monday': [('09:00', '11:30'), ('12:00', '12:30'), ('13:30', '16:00'), ('16:30', '17:00')],\n        'Tuesday': [('09:00', '17:00')]\n    }\n}\n\n# Define the meeting duration and work hours\nmeeting_duration = 30\nwork_hours = ('09:00', '17:00')\n\n# Define the days of the week\ndays = ['Monday', 'Tuesday']\n\n# Define the participants' preferences\npreferences = {\n    'Doris': {'day': 'Monday', 'end_time': '14:00'}\n}\n\n# Find the proposed meeting time\nproposed_time = find_meeting_time(participants, meeting_duration, work_hours, days, preferences)\n\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_669"
        }
    ]
}