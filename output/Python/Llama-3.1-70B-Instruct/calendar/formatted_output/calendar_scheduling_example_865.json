{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": null,
                "end_time": null
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "9:00",
                "end_time": "10:00"
            },
            "has_error": false,
            "raw_model_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, meeting_duration, work_hours, days):\n    \"\"\"\n    Find a suitable time for a meeting based on the participants' schedules and constraints.\n\n    Args:\n    participants (dict): A dictionary where the keys are the participants' names and the values are dictionaries with days as keys and lists of tuples representing their busy time ranges as values.\n    meeting_duration (int): The duration of the meeting in minutes.\n    work_hours (tuple): A tuple representing the work hours (start, end) in minutes.\n    days (list): A list of days of the week.\n\n    Returns:\n    tuple: A tuple representing the proposed meeting time range (start, end) in minutes and the day of the week.\n    \"\"\"\n\n    # Convert work hours to minutes\n    work_start = work_hours[0].split(':')\n    work_start_minutes = int(work_start[0]) * 60 + int(work_start[1])\n    work_end = work_hours[1].split(':')\n    work_end_minutes = int(work_end[0]) * 60 + int(work_end[1])\n\n    # Initialize the proposed meeting time range\n    proposed_time = None\n\n    # Iterate over the days\n    for day in days:\n        # Initialize the earliest available time\n        earliest_available_time = work_start_minutes\n\n        # Iterate over the possible time ranges\n        for time in range(work_start_minutes, work_end_minutes - meeting_duration + 1):\n            # Assume the current time range is available\n            is_available = True\n\n            # Check if the current time range is available for all participants\n            for participant, schedule in participants.items():\n                if day in schedule:\n                    for busy_time in schedule[day]:\n                        busy_start = busy_time[0].split(':')\n                        busy_start_minutes = int(busy_start[0]) * 60 + int(busy_start[1])\n                        busy_end = busy_time[1].split(':')\n                        busy_end_minutes = int(busy_end[0]) * 60 + int(busy_end[1])\n\n                        # If the current time range overlaps with a busy time range, it's not available\n                        if (time >= busy_start_minutes and time < busy_end_minutes) or (time + meeting_duration > busy_start_minutes and time + meeting_duration <= busy_end_minutes):\n                            is_available = False\n                            break\n\n                        # Update the earliest available time\n                        if busy_end_minutes > earliest_available_time:\n                            earliest_available_time = busy_end_minutes\n\n                    # If the current time range is not available, break the loop\n                    if not is_available:\n                        break\n\n            # If the current time range is available, propose it\n            if is_available:\n                proposed_time = (time, time + meeting_duration)\n                break\n\n        # If a proposed time is found, break the loop\n        if proposed_time:\n            break\n\n        # If no proposed time is found, try the earliest available time\n        if earliest_available_time + meeting_duration <= work_end_minutes:\n            proposed_time = (earliest_available_time, earliest_available_time + meeting_duration)\n            break\n\n    # Convert the proposed meeting time range to HH:MM format\n    proposed_time_start = datetime.strptime(str(proposed_time[0] // 60) + ':' + str(proposed_time[0] % 60), '%H:%M')\n    proposed_time_end = datetime.strptime(str(proposed_time[1] // 60) + ':' + str(proposed_time[1] % 60), '%H:%M')\n\n    return proposed_time_start.strftime('%H:%M') + '-' + proposed_time_end.strftime('%H:%M'), day\n\n\n# Define the participants' schedules\nparticipants = {\n    'Megan': {\n        'Monday': [('13:00', '13:30'), ('14:00', '15:30')],\n        'Tuesday': [('9:00', '9:30'), ('12:00', '12:30'), ('16:00', '17:00')],\n        'Wednesday': [('9:30', '10:00'), ('10:30', '11:30'), ('12:30', '14:00'), ('16:00', '16:30')],\n        'Thursday': [('13:30', '14:30'), ('15:00', '15:30')]\n    },\n    'Daniel': {\n        'Monday': [('10:00', '11:30'), ('12:30', '15:00')],\n        'Tuesday': [('9:00', '10:00'), ('10:30', '17:00')],\n        'Wednesday': [('9:00', '10:00'), ('10:30', '11:30'), ('12:00', '17:00')],\n        'Thursday': [('9:00', '12:00'), ('12:30', '14:30'), ('15:00', '15:30'), ('16:00', '17:00')]\n    }\n}\n\n# Define the meeting duration, work hours, and days\nmeeting_duration = 60\nwork_hours = ('9:00', '17:00')\ndays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n\n# Find a suitable time for the meeting\nproposed_time, day = find_meeting_time(participants, meeting_duration, work_hours, days)\n\nprint(f'Proposed meeting time: {proposed_time} on {day}')\n```",
            "count": "calendar_scheduling_example_865"
        }
    ]
}