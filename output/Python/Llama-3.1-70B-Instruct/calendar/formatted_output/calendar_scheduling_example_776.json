{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "11:00",
                "end_time": "11:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "13:00",
                "end_time": "13:30"
            },
            "has_error": false,
            "raw_model_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, meeting_duration, work_hours, days):\n    \"\"\"\n    Find a suitable time for a meeting based on the participants' schedules and constraints.\n\n    Args:\n        participants (dict): A dictionary where the keys are the names of the participants and the values are dictionaries with days of the week as keys and lists of tuples representing the start and end times of their existing meetings as values.\n        meeting_duration (int): The duration of the meeting in minutes.\n        work_hours (tuple): A tuple representing the start and end times of the work hours.\n        days (list): A list of days of the week.\n\n    Returns:\n        str: A string representing the proposed time and day of the meeting in the format HH:MM:HH:MM, Day.\n    \"\"\"\n\n    # Convert the work hours to datetime objects\n    start_time = datetime.strptime(work_hours[0], \"%H:%M\")\n    end_time = datetime.strptime(work_hours[1], \"%H:%M\")\n\n    # Loop through the days of the week\n    for day in days:\n        # Initialize the current time to the start of the work hours\n        current_time = start_time\n\n        # Loop through the work hours\n        while current_time < end_time:\n            # Check if the current time is available for all participants\n            if all(is_time_available(participants[participant], day, current_time, meeting_duration) for participant in participants):\n                # If the current time is available, return it as the proposed meeting time\n                proposed_time = current_time.strftime(\"%H:%M\") + \":\" + (current_time + timedelta(minutes=meeting_duration)).strftime(\"%H:%M\")\n                return proposed_time + \", \" + day\n\n            # If the current time is not available, move to the next time slot\n            current_time += timedelta(minutes=1)\n\ndef is_time_available(participant_schedule, day, current_time, meeting_duration):\n    \"\"\"\n    Check if a given time is available for a participant.\n\n    Args:\n        participant_schedule (dict): A dictionary with days of the week as keys and lists of tuples representing the start and end times of the participant's existing meetings as values.\n        day (str): The current day of the week.\n        current_time (datetime): The current time to check.\n        meeting_duration (int): The duration of the meeting in minutes.\n\n    Returns:\n        bool: True if the current time is available, False otherwise.\n    \"\"\"\n\n    # Check if the participant has any meetings on this day\n    if day not in participant_schedule:\n        return True\n\n    # Convert the current time to a string\n    current_time_str = current_time.strftime(\"%H:%M\")\n\n    # Loop through the participant's existing meetings\n    for start, end in participant_schedule[day]:\n        # Convert the start and end times to datetime objects\n        start_time = datetime.strptime(start, \"%H:%M\")\n        end_time = datetime.strptime(end, \"%H:%M\")\n\n        # Check if the current time overlaps with the existing meeting\n        if start_time <= current_time < end_time or start_time < current_time + timedelta(minutes=meeting_duration) <= end_time:\n            # If the current time overlaps, return False\n            return False\n\n    # Check if John wants to avoid meetings on Monday after 14:30\n    if participant_schedule == {\"Monday\": [(\"09:00\", \"11:00\"), (\"11:30\", \"13:00\"), (\"13:30\", \"14:30\"), (\"15:00\", \"17:00\")], \"Tuesday\": [(\"09:00\", \"11:30\"), (\"12:00\", \"17:00\")], \"Wednesday\": [(\"09:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"14:00\"), (\"14:30\", \"16:00\"), (\"16:30\", \"17:00\")]} and day == \"Monday\" and current_time >= datetime.strptime(\"14:30\", \"%H:%M\"):\n        return False\n\n    # If the current time does not overlap with any existing meetings, return True\n    return True\n\n# Define the participants' schedules\nparticipants = {\n    \"John\": {\n        \"Monday\": [],\n        \"Tuesday\": [],\n        \"Wednesday\": []\n    },\n    \"Jennifer\": {\n        \"Monday\": [(\"09:00\", \"11:00\"), (\"11:30\", \"13:00\"), (\"13:30\", \"14:30\"), (\"15:00\", \"17:00\")],\n        \"Tuesday\": [(\"09:00\", \"11:30\"), (\"12:00\", \"17:00\")],\n        \"Wednesday\": [(\"09:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"14:00\"), (\"14:30\", \"16:00\"), (\"16:30\", \"17:00\")]\n    }\n}\n\n# Define the meeting duration and work hours\nmeeting_duration = 30\nwork_hours = (\"09:00\", \"17:00\")\n\n# Define the days of the week\ndays = [\"Monday\", \"Tuesday\", \"Wednesday\"]\n\n# Find the proposed meeting time\nproposed_time = find_meeting_time(participants, meeting_duration, work_hours, days)\n\n# Print the proposed meeting time\nprint(proposed_time)\n```",
            "count": "calendar_scheduling_example_776"
        }
    ]
}