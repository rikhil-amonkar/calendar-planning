{
    "0shot": [
        {
            "final_program_time": {
                "day": "Wednesday",
                "start_time": "16:30",
                "end_time": "17:00"
            },
            "expected_time": {
                "day": "Wednesday",
                "start_time": "16:30",
                "end_time": "17:00"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import time, timedelta, datetime\n\n# Define a helper function to convert a string \"HH:MM\" to a time object\ndef str_to_time(t_str):\n    return datetime.strptime(t_str, \"%H:%M\").time()\n\n# Define a helper function to check if a time interval (start, end) fits into a free slot interval (free_start, free_end)\ndef fits(free_start, free_end, meeting_start, meeting_end):\n    return free_start <= meeting_start and meeting_end <= free_end\n\n# Meeting duration in minutes\nMEETING_DURATION = 30\n\n# Define office hours\noffice_start = str_to_time(\"09:00\")\noffice_end   = str_to_time(\"17:00\")\n\n# Define participants' busy schedules as dictionaries with days as keys and a list of (start, end) busy intervals.\n# Times are in \"HH:MM\" format.\nschedules = {\n    \"Amy\": {\n        \"Monday\": [],\n        \"Tuesday\": [],\n        \"Wednesday\": [(\"11:00\", \"11:30\"), (\"13:30\", \"14:00\")]\n    },\n    \"Pamela\": {\n        \"Monday\": [(\"09:00\", \"10:30\"), (\"11:00\", \"16:30\")],\n        \"Tuesday\": [(\"09:00\", \"9:30\"), (\"10:00\", \"17:00\")],\n        \"Wednesday\": [(\"09:00\", \"9:30\"), (\"10:00\", \"11:00\"), (\"11:30\", \"13:30\"), (\"14:30\", \"15:00\"), (\"16:00\", \"16:30\")]\n    }\n}\n\n# Pamela's preference: she would like to avoid meetings on Monday,\n# and on Tuesday/Wednesday before 16:00.\ndef meet_satisfies_preference(day, meeting_start):\n    # If meeting is on Monday, avoid it.\n    if day == \"Monday\":\n        return False\n    # For Tuesday/Wednesday, meeting should not start before 16:00.\n    if day in [\"Tuesday\", \"Wednesday\"]:\n        if meeting_start < str_to_time(\"16:00\"):\n            return False\n    return True\n\n# Calculate the free intervals for a given participant on a particular day\ndef get_free_intervals(busy_intervals):\n    free_intervals = []\n    # start with office start\n    current_start = office_start\n    # Sort busy_intervals by start time\n    busy_intervals_sorted = sorted(busy_intervals, key=lambda x: str_to_time(x[0]))\n    for b_start, b_end in busy_intervals_sorted:\n        b_start_time = str_to_time(b_start)\n        b_end_time = str_to_time(b_end)\n        if current_start < b_start_time:\n            free_intervals.append((current_start, b_start_time))\n        current_start = max(current_start, b_end_time)\n    if current_start < office_end:\n        free_intervals.append((current_start, office_end))\n    return free_intervals\n\n# Check for overlapping free intervals between two sets of intervals\ndef intersect_intervals(intervals1, intervals2):\n    result = []\n    for s1, e1 in intervals1:\n        for s2, e2 in intervals2:\n            # The overlapping interval is between max(s1,s2) and min(e1,e2)\n            overlap_start = max(s1, s2)\n            overlap_end = min(e1, e2)\n            if overlap_start < overlap_end:\n                result.append((overlap_start, overlap_end))\n    return result\n\n# Convert a time object to minutes since midnight for easy arithmetic\ndef time_to_minutes(t):\n    return t.hour * 60 + t.minute\n\n# Convert minutes since midnight back to a time object\ndef minutes_to_time(m):\n    return time(m // 60, m % 60)\n\n# Given a free interval, check if a meeting of MEETING_DURATION can be scheduled within it.\ndef find_meeting_in_interval(interval):\n    start, end = interval\n    start_minutes = time_to_minutes(start)\n    end_minutes = time_to_minutes(end)\n    if end_minutes - start_minutes >= MEETING_DURATION:\n        return minutes_to_time(start_minutes), minutes_to_time(start_minutes + MEETING_DURATION)\n    return None\n\n# Days to consider\ndays = [\"Monday\", \"Tuesday\", \"Wednesday\"]\n\n# Try to schedule the meeting\nproposed_day = None\nproposed_start = None\nproposed_end = None\n\n# Loop through each day in order, preferring days that satisfy Pamela\u2019s preferences.\nfor day in days:\n    # Get free intervals for each participant\n    amy_busy = schedules[\"Amy\"].get(day, [])\n    pam_busy = schedules[\"Pamela\"].get(day, [])\n    amy_free = get_free_intervals(amy_busy)\n    pam_free = get_free_intervals(pam_busy)\n    # Get the intersection of free intervals\n    common_free = intersect_intervals(amy_free, pam_free)\n    \n    # For each free interval, try to find a slot that is at least 30 minutes\n    for interval in common_free:\n        meeting_slot = find_meeting_in_interval(interval)\n        if meeting_slot:\n            meeting_start, meeting_end = meeting_slot\n            # Check Pamela's meeting time preference for this day\n            if meet_satisfies_preference(day, meeting_start):\n                proposed_day = day\n                proposed_start = meeting_start\n                proposed_end = meeting_end\n                break\n    if proposed_day:\n        break\n\n# If no slot found that meets the preferences, then choose the earliest available slot\nif not proposed_day:\n    for day in days:\n        amy_busy = schedules[\"Amy\"].get(day, [])\n        pam_busy = schedules[\"Pamela\"].get(day, [])\n        amy_free = get_free_intervals(amy_busy)\n        pam_free = get_free_intervals(pam_busy)\n        common_free = intersect_intervals(amy_free, pam_free)\n        for interval in common_free:\n            meeting_slot = find_meeting_in_interval(interval)\n            if meeting_slot:\n                proposed_day = day\n                proposed_start, proposed_end = meeting_slot\n                break\n        if proposed_day:\n            break\n\n# Format time for output (HH:MM)\ndef format_time(t):\n    return t.strftime(\"%H:%M\")\n\nif proposed_day and proposed_start and proposed_end:\n    # Output in the desired format: day and time range HH:MM:HH:MM\n    output = f\"{proposed_day} {format_time(proposed_start)}:{format_time(proposed_end)}\"\n    print(output)\nelse:\n    print(\"No available meeting slot meets the criteria.\")\n'''",
            "count": "calendar_scheduling_example_786"
        }
    ]
}