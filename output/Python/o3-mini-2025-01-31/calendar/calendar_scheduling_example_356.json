{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "16:00",
                "end_time": "16:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "16:00",
                "end_time": "16:30"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import datetime, timedelta\n\ndef time_to_minutes(t):\n    \"\"\"Convert time string 'HH:MM' to minutes past midnight.\"\"\"\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    \"\"\"Convert minutes past midnight to time string 'HH:MM'.\"\"\"\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef get_free_intervals(busy_intervals, work_start, work_end):\n    \"\"\"Given a list of busy intervals (tuple of start and end minutes), return free intervals tuple list within work day.\"\"\"\n    free_intervals = []\n    current = work_start\n    for start, end in sorted(busy_intervals):\n        if current < start:\n            free_intervals.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free_intervals.append((current, work_end))\n    return free_intervals\n\ndef intersect_intervals(intervals_list):\n    \"\"\"Intersect a list of free interval lists. Each free interval list is a list of (start, end) tuples.\n       Returns a list of intervals that are common to all lists.\"\"\"\n    # Start with intervals that cover the entire day\n    common = intervals_list[0]\n    for intervals in intervals_list[1:]:\n        new_common = []\n        for s1, e1 in common:\n            for s2, e2 in intervals:\n                low = max(s1, s2)\n                high = min(e1, e2)\n                if low + meeting_duration <= high:\n                    new_common.append((low, high))\n        common = new_common\n        if not common:\n            return []\n    return common\n\n# Meeting parameters\nmeeting_duration = 30  # minutes\nwork_day_start = time_to_minutes(\"09:00\")\nwork_day_end = time_to_minutes(\"17:00\")\nday_of_week = \"Monday\"\n\n# Busy schedules for each participant (time strings)\nschedules = {\n    \"Katherine\": [(\"12:00\", \"12:30\"), (\"13:00\", \"14:30\")],\n    \"Rebecca\":  [], # no meetings\n    \"Julie\": [(\"09:00\", \"09:30\"), (\"10:30\", \"11:00\"), (\"13:30\", \"14:00\"), (\"15:00\", \"15:30\")],\n    \"Angela\": [(\"09:00\", \"10:00\"), (\"10:30\", \"11:00\"), (\"11:30\", \"14:00\"), (\"14:30\", \"15:00\"), (\"16:30\", \"17:00\")],\n    \"Nicholas\": [(\"09:30\", \"11:00\"), (\"11:30\", \"13:30\"), (\"14:00\", \"16:00\"), (\"16:30\", \"17:00\")],\n    \"Carl\": [(\"09:00\", \"11:00\"), (\"11:30\", \"12:30\"), (\"13:00\", \"14:30\"), (\"15:00\", \"16:00\"), (\"16:30\", \"17:00\")]\n}\n\n# Convert busy times to intervals in minutes\nbusy_minutes = {}\nfor person, intervals in schedules.items():\n    busy_minutes[person] = [(time_to_minutes(start), time_to_minutes(end)) for start, end in intervals]\n\n# Convert busy intervals to free intervals for each person\nfree_intervals = {}\n\nfor person, busy in busy_minutes.items():\n    free = get_free_intervals(busy, work_day_start, work_day_end)\n    # For Angela, she would like to avoid meetings before 15:00 -> adjust her free intervals\n    if person == \"Angela\":\n        # Filter/free only after 15:00 (15:00 is 900 minutes)\n        new_free = []\n        for start, end in free:\n            if end <= time_to_minutes(\"15:00\"):\n                continue\n            new_free.append((max(start, time_to_minutes(\"15:00\")), end))\n        free = new_free\n    free_intervals[person] = free\n\n# Now, we need to intersect all free intervals\nall_free_lists = list(free_intervals.values())\ncommon_free = intersect_intervals(all_free_lists)\n\n# Select the first interval that can accommodate the meeting duration\nproposed_meeting = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        proposed_meeting = (start, start + meeting_duration)\n        break\n\nif proposed_meeting:\n    meeting_start, meeting_end = proposed_meeting\n    meeting_time_str = f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    print(f\"{meeting_time_str} {day_of_week}\")\nelse:\n    print(\"No meeting time available.\")\n'''",
            "count": "calendar_scheduling_example_356"
        }
    ]
}