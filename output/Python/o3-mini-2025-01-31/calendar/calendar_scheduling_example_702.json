{
    "0shot": [
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "9:30",
                "end_time": "10:00"
            },
            "expected_time": {
                "day": "Tuesday",
                "start_time": "9:30",
                "end_time": "10:00"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import datetime, timedelta\n\n# Helper function: convert time string \"HH:MM\" to minutes since midnight.\ndef time_to_minutes(t):\n    h, m = map(int, t.split(':'))\n    return h * 60 + m\n\n# Helper function: convert minutes since midnight back to \"HH:MM\" format.\ndef minutes_to_time(m):\n    return f\"{m // 60:02d}:{m % 60:02d}\"\n\n# Meeting duration in minutes\nMEETING_DURATION = 30\n\n# Workday boundaries (9:00 to 17:00) in minutes since midnight.\nWORK_START = time_to_minutes(\"09:00\")\nWORK_END = time_to_minutes(\"17:00\")\n\n# Busy schedules per participant per day.\n# Times are given as (start, end) in HH:MM.\nschedules = {\n    \"Robert\": {\n        \"Monday\": [(\"11:00\", \"11:30\"), (\"14:00\", \"14:30\"), (\"15:30\", \"16:00\")],\n        \"Tuesday\": [(\"10:30\", \"11:00\"), (\"15:00\", \"15:30\")],\n        \"Wednesday\": [(\"10:00\", \"11:00\"), (\"11:30\", \"12:00\"),\n                      (\"12:30\", \"13:00\"), (\"13:30\", \"14:00\"),\n                      (\"15:00\", \"15:30\"), (\"16:00\", \"16:30\")]\n    },\n    \"Ralph\": {\n        \"Monday\": [(\"10:00\", \"13:30\"), (\"14:00\", \"14:30\"), (\"15:00\", \"17:00\")],\n        \"Tuesday\": [(\"9:00\", \"9:30\"), (\"10:00\", \"10:30\"), \n                    (\"11:00\", \"11:30\"), (\"12:00\", \"13:00\"),\n                    (\"14:00\", \"15:30\"), (\"16:00\", \"17:00\")],\n        \"Wednesday\": [(\"10:30\", \"11:00\"), (\"11:30\", \"12:00\"), \n                      (\"13:00\", \"14:30\"), (\"16:30\", \"17:00\")]\n    }\n}\n\n# Define the days available for scheduling\n# Robert would like to avoid more meetings on Monday if possible.\n# So we order by preference: Tuesday, Wednesday, then Monday.\npreferred_days = [\"Tuesday\", \"Wednesday\", \"Monday\"]\n\n# Merge busy intervals for a given day from all participants and merge overlapping intervals.\ndef merge_intervals(intervals):\n    if not intervals:\n        return []\n    # sort intervals by start time (in minutes)\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        last = merged[-1]\n        # if current interval starts before or exactly when the last one ends, merge them\n        if current[0] <= last[1]:\n            merged[-1] = (last[0], max(last[1], current[1]))\n        else:\n            merged.append(current)\n    return merged\n\n# Find a free time slot on a particular day given the merged busy intervals\ndef find_free_slot(busy_intervals):\n    free_slots = []\n    # Check interval between work start and first busy interval\n    if busy_intervals:\n        if WORK_START < busy_intervals[0][0]:\n            free_slots.append((WORK_START, busy_intervals[0][0]))\n    else:\n        free_slots.append((WORK_START, WORK_END))\n    # Check between busy intervals\n    for i in range(len(busy_intervals) - 1):\n        end_current = busy_intervals[i][1]\n        start_next = busy_intervals[i+1][0]\n        if start_next - end_current >= MEETING_DURATION:\n            free_slots.append((end_current, start_next))\n    # Check interval between last busy interval and work end\n    if busy_intervals:\n        if WORK_END > busy_intervals[-1][1]:\n            free_slots.append((busy_intervals[-1][1], WORK_END))\n    # Look for the earliest free slot that satisfies the meeting duration\n    for start, end in free_slots:\n        if end - start >= MEETING_DURATION:\n            return start, start + MEETING_DURATION\n    return None\n\n# Main scheduling function. It will check days in the preferred order.\ndef schedule_meeting():\n    for day in preferred_days:\n        all_busy = []\n        for person in schedules:\n            # Get busy intervals for this day, if any.\n            intervals = schedules[person].get(day, [])\n            for start_str, end_str in intervals:\n                start = time_to_minutes(start_str)\n                end   = time_to_minutes(end_str)\n                # Only consider intervals that fall within work hours.\n                # They should, but we'll clip them if needed.\n                start = max(start, WORK_START)\n                end   = min(end, WORK_END)\n                if start < end:\n                    all_busy.append((start, end))\n        # Merge all busy intervals for the day.\n        merged_busy = merge_intervals(all_busy)\n        slot = find_free_slot(merged_busy)\n        if slot:\n            meeting_start, meeting_end = slot\n            # Format the meeting time as required: HH:MM:HH:MM and output the day.\n            meeting_time = f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n            print(f\"{day} {meeting_time}\")\n            return\n    print(\"No available slot found.\")\n\nif __name__ == \"__main__\":\n    schedule_meeting()'''",
            "count": "calendar_scheduling_example_702"
        }
    ]
}