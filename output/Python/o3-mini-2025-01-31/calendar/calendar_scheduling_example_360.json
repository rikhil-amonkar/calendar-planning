{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "9:00",
                "end_time": "9:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "9:00",
                "end_time": "9:30"
            },
            "has_error": false,
            "raw_model_response": "'''python\ndef time_to_minutes(t):\n    # convert a \"HH:MM\" string into minutes from midnight\n    hours, minutes = map(int, t.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(m):\n    # convert minutes from midnight to a \"HH:MM\" string (zero padded)\n    return f\"{m//60:02}:{m%60:02}\"\n\ndef invert_intervals(busy, work_start, work_end):\n    # Given a sorted list of busy intervals [(start, end), ...],\n    # return the free intervals within [work_start, work_end]\n    free = []\n    prev_end = work_start\n    for start, end in busy:\n        if start > prev_end:\n            free.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free.append((prev_end, work_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    # Given two sets of intervals, return their intersection\n    intersection = []\n    i, j = 0, 0\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        start = max(start1, start2)\n        end = min(end1, end2)\n        if start < end:\n            intersection.append((start, end))\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\n# Work day parameters (in minutes from midnight)\nwork_day_start = time_to_minutes(\"09:00\")\nwork_day_end   = time_to_minutes(\"17:00\")\nmeeting_duration = 30  # in minutes\n\n# Busy intervals for each participant (each as tuple (start, end) in minutes)\n# Times are given in HH:MM format.\nparticipants_busy = {\n    \"Emily\": [(time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n              (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))],\n    \"Mason\": [],  # free all day\n    \"Maria\": [(time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n              (time_to_minutes(\"14:00\"), time_to_minutes(\"14:30\"))],\n    \"Carl\":  [(time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n              (time_to_minutes(\"10:30\"), time_to_minutes(\"12:30\")),\n              (time_to_minutes(\"13:30\"), time_to_minutes(\"14:00\")),\n              (time_to_minutes(\"14:30\"), time_to_minutes(\"15:30\")),\n              (time_to_minutes(\"16:00\"), time_to_minutes(\"17:00\"))],\n    \"David\": [(time_to_minutes(\"09:30\"), time_to_minutes(\"11:00\")),\n              (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n              (time_to_minutes(\"12:30\"), time_to_minutes(\"13:30\")),\n              (time_to_minutes(\"14:00\"), time_to_minutes(\"15:00\")),\n              (time_to_minutes(\"16:00\"), time_to_minutes(\"17:00\"))],\n    \"Frank\": [(time_to_minutes(\"09:30\"), time_to_minutes(\"10:30\")),\n              (time_to_minutes(\"11:00\"), time_to_minutes(\"11:30\")),\n              (time_to_minutes(\"12:30\"), time_to_minutes(\"13:30\")),\n              (time_to_minutes(\"14:30\"), time_to_minutes(\"17:00\"))]\n}\n\n# First, compute free intervals for each participant within the work day\nparticipants_free = {}\nfor person, busy in participants_busy.items():\n    # Ensure busy intervals are sorted\n    busy_sorted = sorted(busy, key=lambda interval: interval[0])\n    free = invert_intervals(busy_sorted, work_day_start, work_day_end)\n    participants_free[person] = free\n\n# Now, compute the intersection of free intervals among all participants\ncommon_free = [(work_day_start, work_day_end)]\nfor free in participants_free.values():\n    common_free = intersect_intervals(common_free, free)\n\n# Find a common free interval that is at least meeting_duration minutes long\nproposed_meeting = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        proposed_meeting = (start, start + meeting_duration)\n        break\n\nif proposed_meeting:\n    meeting_start = minutes_to_time(proposed_meeting[0])\n    meeting_end   = minutes_to_time(proposed_meeting[1])\n    day_of_week = \"Monday\"\n    # Output in the requested format: HH:MM:HH:MM and the day of the week\n    print(f\"{day_of_week} {meeting_start}:{meeting_end}\")\nelse:\n    print(\"No suitable meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_360"
        }
    ]
}