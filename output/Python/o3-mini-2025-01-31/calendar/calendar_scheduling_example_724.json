{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "16:00",
                "end_time": "16:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "16:00",
                "end_time": "16:30"
            },
            "has_error": false,
            "raw_model_response": "'''python\ndef time_to_minutes(time_str):\n    # Convert \"HH:MM\" to number of minutes since midnight.\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    # Convert minutes since midnight to \"HH:MM\"\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\ndef get_free_intervals(busy, work_start, work_end):\n    # busy: list of tuples (start, end) in minutes, assumed sorted and non-overlapping\n    free = []\n    current = work_start\n    for start, end in busy:\n        if current < start:\n            free.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_intervals(ints1, ints2):\n    # Given two lists of intervals, compute intersection intervals.\n    intersection = []\n    i, j = 0, 0\n    while i < len(ints1) and j < len(ints2):\n        start1, end1 = ints1[i]\n        start2, end2 = ints2[j]\n        start = max(start1, start2)\n        end = min(end1, end2)\n        if start < end:  # non zero interval\n            intersection.append((start, end))\n        # Move the interval that ends first\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\ndef find_meeting_slot():\n    # Meeting duration in minutes\n    meeting_duration = 30\n    \n    # Define working hours (in minutes since midnight)\n    work_start = time_to_minutes(\"09:00\")\n    work_end   = time_to_minutes(\"17:00\")\n    \n    # Allowed days in order of preference\n    days = [\"Monday\", \"Tuesday\", \"Wednesday\"]\n    \n    # Schedules for participants in each day.\n    # Times are in \"HH:MM\" format.\n    # Tyler's busy schedule\n    tyler_schedule = {\n        \"Monday\": [ ],\n        \"Tuesday\": [(\"09:00\", \"09:30\"), (\"14:30\", \"15:00\")],\n        \"Wednesday\": [(\"10:30\", \"11:00\"), (\"12:30\", \"13:00\"), (\"13:30\", \"14:00\"), (\"16:30\", \"17:00\")]\n    }\n    \n    # Ruth's busy schedule\n    ruth_schedule = {\n        \"Monday\": [(\"09:00\", \"10:00\"), (\"10:30\", \"12:00\"), (\"12:30\", \"14:30\"), (\"15:00\", \"16:00\"), (\"16:30\", \"17:00\")],\n        \"Tuesday\": [(\"09:00\", \"17:00\")],\n        \"Wednesday\": [(\"09:00\", \"17:00\")]\n    }\n    \n    # Convert schedule times to minutes\n    for schedule in (tyler_schedule, ruth_schedule):\n        for day, intervals in schedule.items():\n            schedule[day] = [(time_to_minutes(start), time_to_minutes(end)) for start, end in intervals]\n            # Ensure intervals are sorted\n            schedule[day].sort()\n    \n    # Tyler's preference: avoid meetings before 16:00 on Monday\n    tyler_pref_monday_min = time_to_minutes(\"16:00\")\n    \n    # For each day, determine free intervals for both participants and look for a slot\n    for day in days:\n        # Get free intervals for Tyler and Ruth\n        tyler_free = get_free_intervals(tyler_schedule.get(day, []), work_start, work_end)\n        ruth_free = get_free_intervals(ruth_schedule.get(day, []), work_start, work_end)\n        \n        # Compute common free intervals\n        common_free = intersect_intervals(tyler_free, ruth_free)\n        \n        # If this is Monday, enforce Tyler's meeting preference:\n        if day == \"Monday\":\n            # For each free interval, bump the start time to max(interval_start, 16:00)\n            adjusted = []\n            for s, e in common_free:\n                new_start = max(s, tyler_pref_monday_min)\n                if new_start < e:\n                    adjusted.append((new_start, e))\n            common_free = adjusted\n\n        # Check if any of these free intervals can host the meeting\n        for start, end in common_free:\n            if end - start >= meeting_duration:\n                meeting_start = start\n                meeting_end = meeting_start + meeting_duration\n                # Format the result as HH:MM:HH:MM and day of the week.\n                start_str = minutes_to_time(meeting_start)\n                end_str = minutes_to_time(meeting_end)\n                print(f\"{day} {start_str}:{end_str}\")\n                return\n\n# Execute the scheduler\nif __name__ == '__main__':\n    find_meeting_slot()  \n'''",
            "count": "calendar_scheduling_example_724"
        }
    ]
}