{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "11:30",
                "end_time": "12:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "12:30",
                "end_time": "13:00"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import datetime, timedelta\n\n# Define meeting duration in minutes\nmeeting_duration = timedelta(minutes=30)\n\n# Work hours: 9:00 to 17:00\nwork_start = datetime.strptime(\"09:00\", \"%H:%M\")\nwork_end = datetime.strptime(\"17:00\", \"%H:%M\")\n\n# Define busy intervals for each participant (for Monday and Tuesday)\n# We'll represent an interval as a tuple (start_time, end_time)\n# Note: Only Monday busy intervals for Doris matter (Tuesday is completely busy for Doris)\n\n# Jean's busy intervals (none on Monday, but Tuesday has busy times)\njean_busy = {\n    \"Monday\": [],  \n    \"Tuesday\": [\n        (datetime.strptime(\"11:30\", \"%H:%M\"), datetime.strptime(\"12:00\", \"%H:%M\")),\n        (datetime.strptime(\"16:00\", \"%H:%M\"), datetime.strptime(\"16:30\", \"%H:%M\"))\n    ]\n}\n\n# Doris's busy intervals\ndoris_busy = {\n    \"Monday\": [\n        (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"11:30\", \"%H:%M\")),\n        (datetime.strptime(\"12:00\", \"%H:%M\"), datetime.strptime(\"12:30\", \"%H:%M\")),\n        (datetime.strptime(\"13:30\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\")),\n        (datetime.strptime(\"16:30\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))\n    ],\n    \"Tuesday\": [\n        (datetime.strptime(\"09:00\", \"%H:%M\"), datetime.strptime(\"17:00\", \"%H:%M\"))\n    ]\n}\n\n# Doris's preference: would rather not meet on Monday after 14:00.\n# So on Monday, any meeting must finish by 14:00.\n\ndef invert_busy_times(busy, day_start, day_end):\n    \"\"\"Return the free intervals given the busy intervals within the day.\"\"\"\n    free = []\n    current_start = day_start\n    for start, end in sorted(busy):\n        if current_start < start:\n            free.append((current_start, start))\n        current_start = max(current_start, end)\n    if current_start < day_end:\n        free.append((current_start, day_end))\n    return free\n\ndef find_slot(free_intervals, meeting_duration, latest_end=None):\n    \"\"\"\n    Find the first available slot within free intervals that can\n    accommodate the meeting_duration. If latest_end is provided, the meeting must finish before or at latest_end.\n    \"\"\"\n    for start, end in free_intervals:\n        # If there's a constraint on the latest finish time, adjust the interval.\n        if latest_end is not None and end > latest_end:\n            end = min(end, latest_end)\n        if end - start >= meeting_duration:\n            return start, start + meeting_duration\n    return None\n\n# Function to get overall free intervals for all participants (intersection of their free slots)\ndef intersect_intervals(intervals_list):\n    \"\"\"\n    intervals_list: list of lists, each containing free intervals (tuples)\n    Returns the intersection of these intervals.\n    \"\"\"\n    if not intervals_list:\n        return []\n    # Start by taking the free intervals of the first participant.\n    result = intervals_list[0]\n    for other in intervals_list[1:]:\n        new_result = []\n        for (start1, end1) in result:\n            for (start2, end2) in other:\n                # Find overlap\n                start_overlap = max(start1, start2)\n                end_overlap = min(end1, end2)\n                if start_overlap < end_overlap:\n                    new_result.append((start_overlap, end_overlap))\n        result = new_result\n    return result\n\n# Store work day free intervals for Jean and Doris on both days\navailable_days = [\"Monday\", \"Tuesday\"]\nmeeting_proposal = None\nproposal_day = None\n\nfor day in available_days:\n    # For Jean, free time is the work hours minus his busy intervals for that day\n    jean_free = invert_busy_times(jean_busy.get(day, []), work_start, work_end)\n    # For Doris, free time is the work hours minus her busy intervals for that day\n    doris_free = invert_busy_times(doris_busy.get(day, []), work_start, work_end)\n    \n    # Consider Doris's preference: on Monday, do not schedule after 14:00.\n    latest_end = None\n    if day == \"Monday\":\n        # Meeting must end by 14:00\n        latest_end = datetime.strptime(\"14:00\", \"%H:%M\")\n    \n    # Intersection of free intervals for both participants\n    combined_free = intersect_intervals([jean_free, doris_free])\n    \n    # If there's a preference for latest meeting end, trim intervals accordingly.\n    if latest_end is not None:\n        trimmed = []\n        for s, e in combined_free:\n            if s >= latest_end:\n                continue\n            trimmed.append((s, min(e, latest_end)))\n        combined_free = trimmed\n\n    slot = find_slot(combined_free, meeting_duration)\n    if slot is not None:\n        meeting_proposal = slot\n        proposal_day = day\n        break\n\nif meeting_proposal:\n    start, end = meeting_proposal\n    meeting_time = f\"{start.strftime('%H:%M')}:{end.strftime('%H:%M')}\"\n    print(meeting_time, proposal_day)\nelse:\n    print(\"No available slot found.\")\n'''",
            "count": "calendar_scheduling_example_669"
        }
    ]
}