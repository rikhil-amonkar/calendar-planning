{
    "0shot": [
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "10:30",
                "end_time": "11:00"
            },
            "expected_time": {
                "day": "Tuesday",
                "start_time": "10:30",
                "end_time": "11:00"
            },
            "has_error": false,
            "raw_model_response": "'''python\ndef time_to_minutes(time_str):\n    \"\"\"Convert HH:MM string to minutes since midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    \"\"\"Convert minutes since midnight to HH:MM string.\"\"\"\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\ndef subtract_busy(time_interval, busy_intervals):\n    \"\"\"\n    Given a free time_interval [start, end] (in minutes) and a list of busy_intervals,\n    subtract the busy times and return a list of free intervals.\n    \"\"\"\n    free = []\n    current_start = time_interval[0]\n    for b_start, b_end in sorted(busy_intervals):\n        if b_start > current_start:\n            free.append((current_start, min(b_start, time_interval[1])))\n        current_start = max(current_start, b_end)\n        if current_start >= time_interval[1]:\n            break\n    if current_start < time_interval[1]:\n        free.append((current_start, time_interval[1]))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Find intersections between two lists of intervals.\"\"\"\n    i, j = 0, 0\n    intersection = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find overlap\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap < end_overlap:\n            intersection.append((start_overlap, end_overlap))\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\n# Meeting parameters\nmeeting_duration = 30  # minutes\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nwork_period = (work_start, work_end)\n\n# Schedule for Tuesday for Amanda and Nathan based on the given constraints:\n# Amanda's busy intervals (Tuesday)\namanda_busy_times = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"13:30\"), time_to_minutes(\"14:30\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\")),\n    (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))\n]\n\n# Nathan's busy intervals (Tuesday)\nnathan_busy_times = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"11:00\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"13:30\"), time_to_minutes(\"14:00\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"15:30\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))\n]\n\n# Constraint: Amanda does not want to meet on Tuesday after 11:00.\n# So for Tuesday, Amanda's effective meeting window becomes from available free times that start before 11:00.\n# Compute free intervals for both on Tuesday\namanda_free = subtract_busy(work_period, amanda_busy_times)\nnathan_free = subtract_busy(work_period, nathan_busy_times)\n\n# Intersect the free times\ncommon_free = intersect_intervals(amanda_free, nathan_free)\n\n# Filter the intersections that allow a meeting of at least meeting_duration minutes \n# and also satisfy Amanda's Tuesday constraint (meeting must end by 11:00, i.e., must start early enough)\nvalid_slots = []\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        # For Amanda, if meeting is on Tuesday, meeting start must be such that the meeting ends by 11:00\n        # So, meeting start must be no later than 10:30.\n        latest_start = min(end - meeting_duration, time_to_minutes(\"10:30\"))\n        if start <= latest_start:\n            # Choose the earliest possible start time that satisfies both conditions\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Make sure meeting_end does not exceed 11:00\n            if meeting_end <= time_to_minutes(\"11:00\"):\n                valid_slots.append((meeting_start, meeting_end))\n                break\n\nif valid_slots:\n    slot_start, slot_end = valid_slots[0]\n    day = \"Tuesday\"\n    output = f\"{minutes_to_time(slot_start)}:{minutes_to_time(slot_end)} on {day}\"\n    print(output)\nelse:\n    print(\"No valid meeting slot found.\")\n'''",
            "count": "calendar_scheduling_example_682"
        }
    ]
}