{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "13:00",
                "end_time": "13:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "13:00",
                "end_time": "13:30"
            },
            "has_error": false,
            "raw_model_response": "'''python\ndef to_minutes(time_str):\n    \"\"\"Convert HH:MM to minutes since midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef to_time_str(minutes):\n    \"\"\"Convert minutes since midnight to HH:MM format.\"\"\"\n    return f\"{minutes//60:02}:{minutes%60:02}\"\n\ndef subtract_busy(free, busy):\n    \"\"\"Subtract busy interval from a free interval (both as [start, end]).\"\"\"\n    free_start, free_end = free\n    busy_start, busy_end = busy\n    result = []\n    # if busy interval does not overlap with free interval, return free\n    if busy_end <= free_start or busy_start >= free_end:\n        return [free]\n    # if there is a free portion before the busy interval:\n    if busy_start > free_start:\n        result.append([free_start, busy_start])\n    # if there is free portion after the busy interval:\n    if busy_end < free_end:\n        result.append([busy_end, free_end])\n    return result\n\ndef merge_intervals(intervals):\n    \"\"\"Merge overlapping intervals if needed (assumed sorted by start).\"\"\"\n    if not intervals:\n        return []\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        last = merged[-1]\n        if current[0] <= last[1]:\n            merged[-1] = [last[0], max(last[1], current[1])]\n        else:\n            merged.append(current)\n    return merged\n\ndef compute_free_intervals(busy_intervals, work_start, work_end):\n    \"\"\"Compute free intervals given busy intervals within work hours.\"\"\"\n    # Sort busy intervals by start time\n    busy_intervals.sort(key=lambda x: x[0])\n    free_intervals = [[work_start, work_end]]\n    for busy in busy_intervals:\n        new_free = []\n        for free in free_intervals:\n            new_free.extend(subtract_busy(free, busy))\n        free_intervals = new_free\n    return free_intervals\n\ndef intersect_intervals(list1, list2):\n    \"\"\"Intersect two lists of intervals.\"\"\"\n    i, j = 0, 0\n    res = []\n    while i < len(list1) and j < len(list2):\n        # Find overlap between intervals\n        start = max(list1[i][0], list2[j][0])\n        end = min(list1[i][1], list2[j][1])\n        if start < end:\n            res.append([start, end])\n        # Move to next interval\n        if list1[i][1] < list2[j][1]:\n            i += 1\n        else:\n            j += 1\n    return res\n\ndef find_common_free_interval(free_lists, duration):\n    \"\"\"Find the earliest common free interval of at least 'duration' minutes from a list of free intervals lists.\"\"\"\n    # Intersect all free intervals\n    common = free_lists[0]\n    for free in free_lists[1:]:\n        common = intersect_intervals(common, free)\n        if not common:\n            return None\n    # Look for an interval that fits the duration\n    for interval in common:\n        if interval[1] - interval[0] >= duration:\n            return interval[0], interval[0] + duration\n    return None\n\ndef main():\n    # Work hours on Monday: 9:00 (540 minutes) to 17:00 (1020 minutes)\n    work_start = to_minutes(\"09:00\")\n    work_end = to_minutes(\"17:00\")\n    meeting_duration = 30\n\n    # Busy schedules for each participant on Monday (times in HH:MM strings, converted to minutes)\n    schedules = {\n        \"Doris\": [(\"09:00\", \"11:00\"), (\"13:30\", \"14:00\"), (\"16:00\", \"16:30\")],\n        \"Theresa\": [(\"10:00\", \"12:00\")],\n        \"Christian\": [],  # No meetings\n        \"Terry\": [(\"09:30\", \"10:00\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:00\"),\n                  (\"13:30\", \"14:00\"), (\"14:30\", \"15:00\"), (\"15:30\", \"17:00\")],\n        \"Carolyn\": [(\"09:00\", \"10:30\"), (\"11:00\", \"11:30\"), (\"12:00\", \"13:00\"),\n                    (\"13:30\", \"14:30\"), (\"15:00\", \"17:00\")],\n        \"Kyle\": [(\"09:00\", \"09:30\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"14:30\", \"17:00\")]\n    }\n\n    # Compute free intervals for each participant\n    free_intervals_list = []\n    for person, busy_times in schedules.items():\n        busy_minutes = []\n        for start, end in busy_times:\n            busy_minutes.append([to_minutes(start), to_minutes(end)])\n        free_intervals = compute_free_intervals(busy_minutes, work_start, work_end)\n        # Ensure intervals are merged (though they should not overlap in each individual's schedule)\n        free_intervals = merge_intervals(free_intervals)\n        free_intervals_list.append(free_intervals)\n\n    meeting_time = find_common_free_interval(free_intervals_list, meeting_duration)\n    if meeting_time:\n        start_time_str = to_time_str(meeting_time[0])\n        end_time_str = to_time_str(meeting_time[1])\n        day = \"Monday\"\n        print(f\"{day} {start_time_str}:{end_time_str}\")\n    else:\n        print(\"No available meeting time found.\")\n\nif __name__ == \"__main__\":\n    main()\n'''",
            "count": "calendar_scheduling_example_398"
        }
    ]
}