{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "11:30",
                "end_time": "12:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "11:30",
                "end_time": "12:00"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import datetime, timedelta\n\ndef time_to_minutes(time_str):\n    # Convert \"HH:MM\" to minutes from midnight\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    # Convert minutes to \"HH:MM\" string (zero padded)\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\ndef invert_busy_intervals(busy_intervals, work_start, work_end):\n    \"\"\"\n    Given busy intervals (each as a tuple of (start, end) minutes)\n    and the working hours boundaries, return the free intervals.\n    Assumes busy_intervals are non-overlapping and sorted.\n    \"\"\"\n    free_intervals = []\n    current = work_start\n    for start, end in busy_intervals:\n        if start > current:\n            free_intervals.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free_intervals.append((current, work_end))\n    return free_intervals\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"\n    Given two lists of intervals, return the intersection as a list of intervals.\n    Each interval is represented as a tuple (start, end) in minutes.\n    \"\"\"\n    i, j = 0, 0\n    intersection = []\n    while i < len(intervals1) and j < len(intervals2):\n        a_start, a_end = intervals1[i]\n        b_start, b_end = intervals2[j]\n        # find overlapping section between the intervals\n        start = max(a_start, b_start)\n        end = min(a_end, b_end)\n        if start < end:  # valid intersection\n            intersection.append((start, end))\n        # Move forward in the list whose interval ends first\n        if a_end < b_end:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\ndef find_earliest_slot(intersected_intervals, duration):\n    \"\"\"\n    Find the earliest interval from the intersected intervals that can fit the meeting duration.\n    Duration is in minutes.\n    \"\"\"\n    for start, end in intersected_intervals:\n        if end - start >= duration:\n            return (start, start + duration)\n    return None\n\n# Define working hours in minutes (9:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Define busy intervals in minutes for each participant\n# Times are in \"HH:MM\" format and then converted to minutes.\n# Denise: busy during 12:00-12:30 and 15:30-16:00\ndenise_busy = [\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\"))\n]\n\n# Angela has no meetings\nangela_busy = []\n\n# Natalie: busy during 9:00-11:30, 12:00-13:00, 14:00-14:30, 15:00-17:00\nnatalie_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"11:30\")),\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"14:30\")),\n    (time_to_minutes(\"15:00\"), time_to_minutes(\"17:00\"))\n]\n\n# Generate free intervals for each participant\ndenise_free = invert_busy_intervals(denise_busy, work_start, work_end)\nangela_free = invert_busy_intervals(angela_busy, work_start, work_end)\nnatalie_free = invert_busy_intervals(natalie_busy, work_start, work_end)\n\n# Find common free intervals by intersecting the free intervals of all participants\ncommon_free = intersect_intervals(denise_free, angela_free)\ncommon_free = intersect_intervals(common_free, natalie_free)\n\n# Meeting duration in minutes (30 minutes)\nmeeting_duration = 30\n\n# Find the earliest available meeting slot that fits the required duration\nslot = find_earliest_slot(common_free, meeting_duration)\n\nif slot:\n    meeting_start, meeting_end = slot\n    # Format output in HH:MM:HH:MM format along with the day of the week (Monday)\n    result_time = f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    day_of_week = \"Monday\"\n    print(f\"{day_of_week} {result_time}\")\nelse:\n    print(\"No available slot found.\")\n'''",
            "count": "calendar_scheduling_example_70"
        }
    ]
}