{
    "0shot": [
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "10:30",
                "end_time": "11:00"
            },
            "expected_time": {
                "day": "Tuesday",
                "start_time": "15:00",
                "end_time": "15:30"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import datetime, timedelta\n\ndef time_to_minutes(t):\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\n# Define work day boundaries in minutes (9:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Duration of the meeting in minutes\nmeeting_duration = 30\n\n# Define the busy intervals for each person in minutes on each day.\n# For each interval, we represent it as a tuple (start, end) where times are in minutes.\n# Jesse's busy schedule:\njesse_busy = {\n    \"Monday\": [(time_to_minutes(\"13:30\"), time_to_minutes(\"14:00\")),\n               (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\"))],\n    \"Tuesday\": [(time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n                (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n                (time_to_minutes(\"14:00\"), time_to_minutes(\"15:00\"))]\n}\n\n# Lawrence's busy schedule:\nlawrence_busy = {\n    \"Monday\": [(time_to_minutes(\"09:00\"), time_to_minutes(\"17:00\"))],  # busy whole day\n    \"Tuesday\": [(time_to_minutes(\"09:30\"), time_to_minutes(\"10:30\")),\n                (time_to_minutes(\"11:30\"), time_to_minutes(\"12:30\")),\n                (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n                (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\")),\n                (time_to_minutes(\"15:30\"), time_to_minutes(\"16:30\"))]\n}\n# Additional constraint: Lawrence cannot meet on Tuesday after 16:30,\n# meaning the meeting must finish by 16:30; hence the meeting must start no later than 16:00.\nmax_meeting_start = time_to_minutes(\"16:00\")\n\ndef get_free_slots(busy, day):\n    \"\"\"Return available free slots within the work day for a given day's busy intervals.\"\"\"\n    free = []\n    busy_sorted = sorted(busy.get(day, []))\n    current_start = work_start\n    for interval in busy_sorted:\n        b_start, b_end = interval\n        if current_start < b_start:\n            free.append((current_start, b_start))\n        current_start = max(current_start, b_end)\n    if current_start < work_end:\n        free.append((current_start, work_end))\n    return free\n\ndef intersect_slots(slots1, slots2):\n    \"\"\"Return intersection of two lists of slots.\"\"\"\n    intersections = []\n    i, j = 0, 0\n    while i < len(slots1) and j < len(slots2):\n        start1, end1 = slots1[i]\n        start2, end2 = slots2[j]\n        start = max(start1, start2)\n        end = min(end1, end2)\n        if start + meeting_duration <= end:  # enough room for the meeting\n            intersections.append((start, end))\n        # Move the pointer which ends first\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersections\n\n# Try scheduling on Monday and Tuesday (Monday for Lawrence is entirely busy, so Tuesday is our only option)\nchosen_day = None\nchosen_start = None\n\nfor day in [\"Monday\", \"Tuesday\"]:\n    # Get free slots for both participants\n    jesse_free = get_free_slots(jesse_busy, day)\n    lawrence_free = get_free_slots(lawrence_busy, day)\n    # If it's Tuesday, honor Lawrence's extra constraint: meeting must start before or at 16:00.\n    if day == \"Tuesday\":\n        lawrence_free = [(s, min(e, time_to_minutes(\"16:30\"))) for s,e in lawrence_free if s <= max_meeting_start]\n    \n    # Find intersections of free slots between Jesse and Lawrence\n    common_slots = intersect_slots(jesse_free, lawrence_free)\n    for slot in common_slots:\n        slot_start, slot_end = slot\n        # Ensure meeting can be scheduled starting at slot_start within the slot and any extra constraints.\n        if day == \"Tuesday\" and slot_start > max_meeting_start:\n            continue\n        # Choose the earliest possible time that can accommodate the meeting.\n        chosen_day = day\n        chosen_start = slot_start\n        break\n    if chosen_day:\n        break\n\nif chosen_day and chosen_start is not None:\n    meeting_start = chosen_start\n    meeting_end = meeting_start + meeting_duration\n    meeting_time_str = f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    print(f\"{chosen_day} {meeting_time_str}\")\nelse:\n    print(\"No available meeting time could be found.\")\n'''",
            "count": "calendar_scheduling_example_652"
        }
    ]
}