{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "11:30",
                "end_time": "12:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "11:30",
                "end_time": "12:00"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import datetime, timedelta\n\ndef time_to_minutes(t_str):\n    \"\"\"Convert HH:MM string to minutes since midnight.\"\"\"\n    h, m = map(int, t_str.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    \"\"\"Convert minutes since midnight to HH:MM string.\"\"\"\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef compute_free_intervals(busy_intervals, work_start, work_end):\n    \"\"\"\n    Given a sorted list of busy intervals [(start, end), ...] in minutes,\n    return a list of free intervals within [work_start, work_end].\n    \"\"\"\n    free = []\n    current = work_start\n    for start, end in busy_intervals:\n        if start > current:\n            free.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"\n    Intersect two lists of intervals. Each interval is a tuple (start, end) in minutes.\n    Both lists are assumed to be sorted by start time.\n    Returns a sorted list of overlapping intervals.\n    \"\"\"\n    i, j = 0, 0\n    intersection = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find overlap between intervals, if any.\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap < end_overlap:\n            intersection.append((start_overlap, end_overlap))\n        # Move to the next interval in the list which ends first.\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\ndef find_common_free_intervals(free_intervals_dict):\n    \"\"\"\n    Given a dictionary of participant:free_interval_list, compute the common free intervals.\n    \"\"\"\n    participants = list(free_intervals_dict.keys())\n    if not participants:\n        return []\n        \n    common = free_intervals_dict[participants[0]]\n    for participant in participants[1:]:\n        common = intersect_intervals(common, free_intervals_dict[participant])\n        if not common:\n            break\n    return common\n\ndef schedule_meeting(common_intervals, duration):\n    \"\"\"\n    Given a list of intervals (in minutes) and meeting duration in minutes,\n    return the first interval (start, end) that fits the meeting.\n    \"\"\"\n    for start, end in common_intervals:\n        if end - start >= duration:\n            return start, start + duration\n    return None\n\n# Define work hours in minutes (9:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Meeting duration: 30 minutes\nmeeting_duration = 30\n\n# Busy schedules for each participant on Monday (in HH:MM format)\nschedules = {\n    \"Walter\": [],  # No busy intervals\n    \"Cynthia\": [(\"09:00\", \"09:30\"), (\"10:00\", \"10:30\"), (\"13:30\", \"14:30\"), (\"15:00\", \"16:00\")],\n    \"Ann\": [(\"10:00\", \"11:00\"), (\"13:00\", \"13:30\"), (\"14:00\", \"15:00\"), (\"16:00\", \"16:30\")],\n    \"Catherine\": [(\"09:00\", \"11:30\"), (\"12:30\", \"13:30\"), (\"14:30\", \"17:00\")],\n    \"Kyle\": [(\"09:00\", \"09:30\"), (\"10:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"14:30\"), (\"15:00\", \"16:00\")]\n}\n\n# Convert busy intervals to minutes and sort them for each participant\nbusy_intervals_minutes = {}\nfor person, intervals in schedules.items():\n    busy = []\n    for start_str, end_str in intervals:\n        start = time_to_minutes(start_str)\n        end = time_to_minutes(end_str)\n        busy.append((start, end))\n    busy.sort()\n    busy_intervals_minutes[person] = busy\n\n# Compute free intervals for each participant within work hours\nfree_intervals = {}\nfor person, busy in busy_intervals_minutes.items():\n    free_intervals[person] = compute_free_intervals(busy, work_start, work_end)\n\n# Find common free intervals across all participants\ncommon_free = find_common_free_intervals(free_intervals)\n\n# Select a meeting time from the common free intervals that fits the duration\nmeeting_slot = schedule_meeting(common_free, meeting_duration)\n\nday_of_week = \"Monday\"\n\nif meeting_slot:\n    meeting_start, meeting_end = meeting_slot\n    start_str = minutes_to_time(meeting_start)\n    end_str = minutes_to_time(meeting_end)\n    # Output format: HH:MM:HH:MM and the day of the week\n    print(f\"{start_str}:{end_str} {day_of_week}\")\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_244"
        }
    ]
}