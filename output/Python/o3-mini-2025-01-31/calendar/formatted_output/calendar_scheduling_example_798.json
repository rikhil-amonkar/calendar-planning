{
    "0shot": [
        {
            "final_program_time": {
                "day": "Wednesday",
                "start_time": "9:30",
                "end_time": "10:00"
            },
            "expected_time": {
                "day": "Wednesday",
                "start_time": "9:30",
                "end_time": "10:00"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import datetime, timedelta\n\n# Meeting duration in minutes\nMEETING_DURATION = 30\n\n# Work hours (in minutes from midnight)\nWORK_START = 9 * 60   # 9:00 AM in minutes\nWORK_END = 17 * 60    # 17:00 (5:00 PM) in minutes\n\n# Helper functions\ndef time_to_minutes(time_str):\n    \"\"\"Convert a time string 'HH:MM' to minutes since midnight.\"\"\"\n    h, m = map(int, time_str.split(':'))\n    return h * 60 + m\n\ndef minutes_to_time(minutes):\n    \"\"\"Convert minutes since midnight to a time string 'HH:MM'.\"\"\"\n    h = minutes // 60\n    m = minutes % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef invert_busy(busy_intervals):\n    \"\"\"\n    Given a list of busy intervals (start, end) in minutes,\n    return a list of free intervals within the work hours.\n    \"\"\"\n    free_intervals = []\n    current_start = WORK_START\n    # sort the busy intervals by start time\n    busy_intervals.sort(key=lambda interval: interval[0])\n    for bstart, bend in busy_intervals:\n        if current_start < bstart:\n            free_intervals.append((current_start, bstart))\n        current_start = max(current_start, bend)\n    if current_start < WORK_END:\n        free_intervals.append((current_start, WORK_END))\n    return free_intervals\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"\n    Given two lists of intervals, return the intersection intervals.\n    \"\"\"\n    i, j = 0, 0\n    intersections = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # find overlapping interval\n        start = max(start1, start2)\n        end = min(end1, end2)\n        if start + MEETING_DURATION <= end:\n            intersections.append((start, end))\n        # move the pointer which ends earlier\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersections\n\n# Participant busy schedules in minutes from midnight\n# Format: { day: [ (busy_start, busy_end), ... ] }\nnancy_busy = {\n    \"Monday\": [(\"10:00\", \"10:30\"), (\"11:30\", \"12:30\"), (\"13:30\", \"14:00\"), (\"14:30\", \"15:30\"), (\"16:00\", \"17:00\")],\n    \"Tuesday\": [(\"9:30\", \"10:30\"), (\"11:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"13:30\"), (\"15:30\", \"16:00\")],\n    \"Wednesday\": [(\"10:00\", \"11:30\"), (\"13:30\", \"16:00\")]\n}\n\njose_busy = {\n    \"Monday\": [(\"09:00\", \"17:00\")],\n    \"Tuesday\": [(\"09:00\", \"17:00\")],\n    \"Wednesday\": [(\"09:00\", \"09:30\"), (\"10:00\", \"12:30\"), (\"13:30\", \"14:30\"), (\"15:00\", \"17:00\")]\n}\n\n# Convert the time strings to minutes\nfor day in nancy_busy:\n    nancy_busy[day] = [(time_to_minutes(s), time_to_minutes(e)) for s, e in nancy_busy[day]]\nfor day in jose_busy:\n    jose_busy[day] = [(time_to_minutes(s), time_to_minutes(e)) for s, e in jose_busy[day]]\n\ndays = [\"Monday\", \"Tuesday\", \"Wednesday\"]\n\n# Scan days in order to find the earliest available meeting slot\nfound_slot = False\nmeeting_day = None\nmeeting_start = None\n\nfor day in days:\n    # Calculate free intervals for each participant, given the work hours\n    nancy_free = invert_busy(nancy_busy.get(day, []))\n    jose_free = invert_busy(jose_busy.get(day, []))\n    \n    # Find intersections between free time slots\n    common_free = intersect_intervals(nancy_free, jose_free)\n    \n    # Look for the earliest common interval that can accommodate the meeting duration\n    if common_free:\n        # Take the first interval's start time that fits the meeting duration\n        for interval in common_free:\n            start, end = interval\n            if start + MEETING_DURATION <= end:\n                meeting_day = day\n                meeting_start = start\n                found_slot = True\n                break\n    if found_slot:\n        break\n\nif found_slot:\n    start_time_str = minutes_to_time(meeting_start)\n    end_time_str = minutes_to_time(meeting_start + MEETING_DURATION)\n    # Output in the required format: day and time range HH:MM:HH:MM\n    print(f\"{meeting_day}, {start_time_str}:{end_time_str}\")\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_798"
        }
    ]
}