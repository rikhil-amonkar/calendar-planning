{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "9:30",
                "end_time": "10:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "9:30",
                "end_time": "10:00"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import datetime, timedelta\n\n# Define time format helper functions\ndef str_to_minutes(time_str):\n    \"\"\"Convert HH:MM string to minutes from midnight.\"\"\"\n    h, m = map(int, time_str.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_str(minutes):\n    \"\"\"Convert minutes from midnight to HH:MM string.\"\"\"\n    h = minutes // 60\n    m = minutes % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef find_free_slot(busy_periods, work_start, work_end, meeting_duration):\n    \"\"\"\n    Given a sorted list of busy intervals (each as (start, end) in minutes),\n    find the earliest free interval in [work_start, work_end] with at least meeting_duration minutes.\n    \"\"\"\n    # Check free time before first meeting\n    if busy_periods:\n        if busy_periods[0][0] - work_start >= meeting_duration:\n            return work_start, work_start + meeting_duration\n    else:\n        if work_end - work_start >= meeting_duration:\n            return work_start, work_start + meeting_duration\n\n    # Check free times between meetings\n    for i in range(len(busy_periods) - 1):\n        end_current = busy_periods[i][1]\n        start_next = busy_periods[i+1][0]\n        if start_next - end_current >= meeting_duration:\n            return end_current, end_current + meeting_duration\n\n    # Check free time after last meeting\n    if work_end - busy_periods[-1][1] >= meeting_duration:\n        return busy_periods[-1][1], busy_periods[-1][1] + meeting_duration\n\n    return None\n\n# Work hours (in minutes after midnight)\nwork_start = str_to_minutes(\"09:00\")\nwork_end   = str_to_minutes(\"17:00\")\nmeeting_duration = 30  # minutes\n\n# James's busy schedules given as lists of (start, end) times on each day.\n# Times are in HH:MM format and will be converted to minutes.\nschedules = {\n    \"Monday\": [\n        (\"09:00\", \"09:30\"),\n        (\"10:30\", \"11:00\"),\n        (\"12:30\", \"13:00\"),\n        (\"14:30\", \"15:30\"),\n        (\"16:30\", \"17:00\")\n    ],\n    \"Tuesday\": [\n        (\"09:00\", \"11:00\"),\n        (\"11:30\", \"12:00\"),\n        (\"12:30\", \"15:30\"),\n        (\"16:00\", \"17:00\")\n    ],\n    \"Wednesday\": [\n        (\"10:00\", \"11:00\"),\n        (\"12:00\", \"13:00\"),\n        (\"13:30\", \"16:00\")\n    ],\n    \"Thursday\": [\n        (\"09:30\", \"11:30\"),\n        (\"12:00\", \"12:30\"),\n        (\"13:00\", \"13:30\"),\n        (\"14:00\", \"14:30\"),\n        (\"16:30\", \"17:00\")\n    ]\n}\n\n# Cheryl's calendar is wide open, but she prefers not to meet on Wednesday.\n# So we choose the following day priority order: Monday, Tuesday, Thursday, Wednesday.\nday_priority = [\"Monday\", \"Tuesday\", \"Thursday\", \"Wednesday\"]\n\nmeeting_day = None\nmeeting_start = None\nmeeting_end = None\n\nfor day in day_priority:\n    busy_periods = schedules.get(day, [])\n    # Convert busy intervals to minutes and sort them\n    busy_periods = sorted([(str_to_minutes(start), str_to_minutes(end)) for start, end in busy_periods])\n    free_slot = find_free_slot(busy_periods, work_start, work_end, meeting_duration)\n    if free_slot:\n        meeting_day = day\n        meeting_start, meeting_end = free_slot\n        break\n\nif meeting_day:\n    # Format the meeting start and end times\n    start_str = minutes_to_str(meeting_start)\n    end_str = minutes_to_str(meeting_end)\n    # Output in the format: HH:MM:HH:MM and day of the week\n    print(f\"{meeting_day} {start_str}:{end_str}\")\nelse:\n    print(\"No available meeting slot found.\")\n'''",
            "count": "calendar_scheduling_example_826"
        }
    ]
}