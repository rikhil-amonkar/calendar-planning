{
    "0shot": [
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "15:00",
                "end_time": "15:30"
            },
            "expected_time": {
                "day": "Thursday",
                "start_time": "16:00",
                "end_time": "16:30"
            },
            "has_error": false,
            "raw_model_response": "'''python\ndef time_to_minutes(t):\n    # Convert \"HH:MM\" to total minutes since midnight.\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    # Convert minutes since midnight to \"HH:MM\" string.\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\n# Define working hours (in minutes)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nmeeting_duration = 30\n\n# Busy schedules for each participant.\n# Each busy interval is given as [start, end] in \"HH:MM\" format.\nschedules = {\n    \"Betty\": {\n        \"Monday\": [[\"10:00\", \"10:30\"],\n                   [\"13:30\", \"14:00\"],\n                   [\"15:00\", \"15:30\"],\n                   [\"16:00\", \"16:30\"]],\n        \"Tuesday\": [[\"09:00\", \"09:30\"],\n                    [\"11:30\", \"12:00\"],\n                    [\"12:30\", \"13:00\"],\n                    [\"13:30\", \"14:00\"],\n                    [\"16:30\", \"17:00\"]],\n        \"Wednesday\": [[\"09:30\", \"10:30\"],\n                      [\"13:00\", \"13:30\"],\n                      [\"14:00\", \"14:30\"]],\n        \"Thursday\": [[\"09:30\", \"10:00\"],\n                     [\"11:30\", \"12:00\"],\n                     [\"14:00\", \"14:30\"],\n                     [\"15:00\", \"15:30\"],\n                     [\"16:30\", \"17:00\"]]\n    },\n    \"Scott\": {\n        \"Monday\": [[\"09:30\", \"15:00\"],\n                   [\"15:30\", \"16:00\"],\n                   [\"16:30\", \"17:00\"]],\n        \"Tuesday\": [[\"09:00\", \"09:30\"],\n                    [\"10:00\", \"11:00\"],\n                    [\"11:30\", \"12:00\"],\n                    [\"12:30\", \"13:30\"],\n                    [\"14:00\", \"15:00\"],\n                    [\"16:00\", \"16:30\"]],\n        \"Wednesday\": [[\"09:30\", \"12:30\"],\n                      [\"13:00\", \"13:30\"],\n                      [\"14:00\", \"14:30\"],\n                      [\"15:00\", \"15:30\"],\n                      [\"16:00\", \"16:30\"]],\n        \"Thursday\": [[\"09:00\", \"09:30\"],\n                     [\"10:00\", \"10:30\"],\n                     [\"11:00\", \"12:00\"],\n                     [\"12:30\", \"13:00\"],\n                     [\"15:00\", \"16:00\"],\n                     [\"16:30\", \"17:00\"]]\n    }\n}\n\n# Additional constraints:\n# 1. Betty cannot meet on Monday.\n# 2. On Tuesday and Thursday, Betty cannot meet before 15:00.\n# 3. Scott would like to avoid Wednesday if possible.\n# Priority: try Tuesday and Thursday first, then Wednesday if needed.\ncandidate_days = [\"Tuesday\", \"Thursday\", \"Wednesday\"]\n\ndef get_free_intervals(busy_intervals):\n    \"\"\"Compute free intervals within working hours given busy intervals.\n       busy_intervals: list of [start, end] in minutes.\n    \"\"\"\n    free = []\n    current = work_start\n    # Sort the busy intervals by start time.\n    busy_intervals = sorted(busy_intervals, key=lambda x: x[0])\n    for interval in busy_intervals:\n        start, end = interval\n        if start > current:\n            free.append([current, start])\n        current = max(current, end)\n    if current < work_end:\n        free.append([current, work_end])\n    return free\n\ndef intervals_intersection(intervals1, intervals2):\n    \"\"\"Find intersection of two list of intervals.\"\"\"\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        start = max(intervals1[i][0], intervals2[j][0])\n        end = min(intervals1[i][1], intervals2[j][1])\n        if start + meeting_duration <= end:\n            result.append([start, end])\n        if intervals1[i][1] < intervals2[j][1]:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef convert_busy_list(busy_list):\n    \"\"\"Convert list of busy intervals from string to minutes.\"\"\"\n    return [[time_to_minutes(start), time_to_minutes(end)] for start, end in busy_list]\n\n# Try each candidate day\nfor day in candidate_days:\n    # Skip Monday because Betty cannot meet on Monday.\n    if day == \"Monday\":\n        continue\n\n    # Get busy intervals for Betty and Scott\n    betty_busy = convert_busy_list(schedules[\"Betty\"].get(day, []))\n    scott_busy = convert_busy_list(schedules[\"Scott\"].get(day, []))\n\n    # Compute free intervals within working hours.\n    betty_free = get_free_intervals(betty_busy)\n    scott_free = get_free_intervals(scott_busy)\n\n    # On Tuesday and Thursday, add constraint: meeting can start only at or after 15:00.\n    constraint_start = work_start\n    if day in [\"Tuesday\", \"Thursday\"]:\n        constraint_start = max(work_start, time_to_minutes(\"15:00\"))\n    # Adjust free intervals for Betty to account for her constraint if needed.\n    betty_free_adjusted = []\n    for interval in betty_free:\n        # If the interval ends before the constraint, skip it.\n        if interval[1] <= constraint_start:\n            continue\n        # Adjust start if needed.\n        start = max(interval[0], constraint_start)\n        betty_free_adjusted.append([start, interval[1]])\n\n    # Similarly adjust Scott's free intervals (though only Betty has explicit constraint).\n    scott_free_adjusted = []\n    for interval in scott_free:\n        if interval[1] <= constraint_start:\n            continue\n        start = max(interval[0], constraint_start)\n        scott_free_adjusted.append([start, interval[1]])\n\n    # Find common free intervals between Betty and Scott.\n    common_free = intervals_intersection(betty_free_adjusted, scott_free_adjusted)\n\n    # Check if any free interval has enough duration for the meeting.\n    for interval in common_free:\n        start, end = interval\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Output in the required format.\n            time_range = f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n            print(f\"{day} {time_range}\")\n            exit(0)\n\n# If no slot found (but the problem guarantees a solution)\nprint(\"No available slot\")\n'''",
            "count": "calendar_scheduling_example_867"
        }
    ]
}