{
    "0shot": [
        {
            "final_program_time": {
                "day": "Friday",
                "start_time": "11:00",
                "end_time": "11:30"
            },
            "expected_time": {
                "day": "Friday",
                "start_time": "11:00",
                "end_time": "11:30"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import timedelta, datetime\n\n# Helper functions\ndef time_to_minutes(t):\n    # t in \"HH:MM\" format\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    h = m // 60\n    minute = m % 60\n    return f\"{h:02d}:{minute:02d}\"\n\ndef merge_intervals(intervals):\n    \"\"\"Merge overlapping intervals; each interval is a tuple (start, end) in minutes.\"\"\"\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        prev = merged[-1]\n        if current[0] <= prev[1]:\n            merged[-1] = (prev[0], max(prev[1], current[1]))\n        else:\n            merged.append(current)\n    return merged\n\ndef invert_intervals(busy, start, end):\n    \"\"\"Given busy intervals (merged) in [start, end], return free intervals.\"\"\"\n    free = []\n    current = start\n    for b_start, b_end in busy:\n        if b_start > current:\n            free.append((current, b_start))\n        current = max(current, b_end)\n    if current < end:\n        free.append((current, end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Return intersections of two lists of intervals.\"\"\"\n    i, j = 0, 0\n    intersections = []\n    while i < len(intervals1) and j < len(intervals2):\n        start = max(intervals1[i][0], intervals2[j][0])\n        end = min(intervals1[i][1], intervals2[j][1])\n        if start < end:\n            intersections.append((start, end))\n        if intervals1[i][1] < intervals2[j][1]:\n            i += 1\n        else:\n            j += 1\n    return intersections\n\n# Define business hours and meeting duration in minutes\nbusiness_start = time_to_minutes(\"09:00\")\nbusiness_end = time_to_minutes(\"17:00\")\nmeeting_duration = 30\n\n# Busy schedules for each participant defined by day.\n# Each busy interval is defined as (start, end) in \"HH:MM\" string format.\nschedules = {\n    \"Eugene\": {\n        \"Monday\": [(\"11:00\", \"12:00\"), (\"13:30\", \"14:00\"), (\"14:30\", \"15:00\"), (\"16:00\", \"16:30\")],\n        \"Tuesday\": [],  # No busy intervals mentioned for Tuesday for Eugene.\n        \"Wednesday\": [(\"09:00\", \"09:30\"), (\"11:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:30\", \"15:00\")],\n        \"Thursday\": [(\"09:30\", \"10:00\"), (\"11:00\", \"12:30\")],\n        \"Friday\": [(\"10:30\", \"11:00\"), (\"12:00\", \"12:30\"), (\"13:00\", \"13:30\")]\n    },\n    \"Eric\": {\n        \"Monday\": [(\"09:00\", \"17:00\")],\n        \"Tuesday\": [(\"09:00\", \"17:00\")],\n        \"Wednesday\": [(\"09:00\", \"11:30\"), (\"12:00\", \"14:00\"), (\"14:30\", \"16:30\")],\n        \"Thursday\": [(\"09:00\", \"17:00\")],\n        \"Friday\": [(\"09:00\", \"11:00\"), (\"11:30\", \"17:00\")]\n    }\n}\n\n# Days of week in the acceptable order.\ndays = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"]\n\n# Eric's preference is to avoid Wednesday if possible.\n# So we'll check non-Wednesday days first.\npreferred_days = [d for d in days if d != \"Wednesday\"] + [\"Wednesday\"]\n\n# Candidate meeting slots: list of (day, start, end)\ncandidates = []\n\nfor day in preferred_days:\n    # Get Eugene's busy intervals and convert to minutes\n    e_segments = []\n    for start_str, end_str in schedules[\"Eugene\"].get(day, []):\n        start = time_to_minutes(start_str)\n        end = time_to_minutes(end_str)\n        e_segments.append((start, end))\n    e_busy = merge_intervals(e_segments)\n    e_free = invert_intervals(e_busy, business_start, business_end)\n    \n    # Get Eric's busy intervals and convert to minutes\n    er_segments = []\n    for start_str, end_str in schedules[\"Eric\"].get(day, []):\n        start = time_to_minutes(start_str)\n        end = time_to_minutes(end_str)\n        er_segments.append((start, end))\n    er_busy = merge_intervals(er_segments)\n    er_free = invert_intervals(er_busy, business_start, business_end)\n    \n    # Find common free intervals\n    common_free = intersect_intervals(e_free, er_free)\n    \n    # Check if any common free interval can accommodate the meeting\n    for free_start, free_end in common_free:\n        if free_end - free_start >= meeting_duration:\n            # Use the first available slot in that free interval\n            meeting_start = free_start\n            meeting_end = meeting_start + meeting_duration\n            candidates.append((day, meeting_start, meeting_end))\n            break  # Stop after finding the first valid slot for this day\n\n# Select the first candidate in the ordered preferred_days list.\nif candidates:\n    day, start, end = candidates[0]\n    meeting_time = f\"{minutes_to_time(start)}:{minutes_to_time(end)}\"\n    print(f\"{day}, {meeting_time}\")\nelse:\n    print(\"No suitable meeting slot found.\")\n'''",
            "count": "calendar_scheduling_example_938"
        }
    ]
}