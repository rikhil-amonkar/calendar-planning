{
    "0shot": [
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "11:00",
                "end_time": "12:00"
            },
            "expected_time": {
                "day": "Tuesday",
                "start_time": "11:00",
                "end_time": "12:00"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import datetime, timedelta\n\ndef time_to_minutes(t_str):\n    # t_str format \"HH:MM\"\n    h, m = map(int, t_str.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef get_free_slots(busy_slots, work_start, work_end):\n    \"\"\"Return free time intervals (in minutes) given busy slots (list of (start, end) in minutes).\"\"\"\n    free = []\n    current = work_start\n    # Sort busy slots by their starting times\n    busy_slots.sort()\n    for start, end in busy_slots:\n        if start > current:\n            free.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_slots(slots1, slots2):\n    \"\"\"Return list of intersections between two lists of intervals (in minutes).\"\"\"\n    intersections = []\n    i, j = 0, 0\n    while i < len(slots1) and j < len(slots2):\n        a_start, a_end = slots1[i]\n        b_start, b_end = slots2[j]\n        start = max(a_start, b_start)\n        end = min(a_end, b_end)\n        if start < end:\n            intersections.append((start, end))\n        # move pointer with the earlier ending slot\n        if a_end < b_end:\n            i += 1\n        else:\n            j += 1\n    return intersections\n\n# Define work hours in minutes (9:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nmeeting_duration = 60  # in minutes\n\n# Define busy schedules as dictionaries by day for Betty and Megan.\n# Times are in HH:MM format and will be converted to minutes.\nbusy_betty = {\n    \"Monday\": [(\"10:00\", \"10:30\"), (\"11:30\", \"12:30\"), (\"16:00\", \"16:30\")],\n    \"Tuesday\": [(\"9:30\", \"10:00\"), (\"10:30\", \"11:00\"), (\"12:00\", \"12:30\"), (\"13:30\", \"15:00\"), (\"16:30\", \"17:00\")],\n    # Betty cannot meet on Wednesday, so we omit it.\n    # Skip Thursday as Betty cannot meet.\n    \"Friday\": [(\"9:00\", \"10:00\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"14:30\", \"15:00\")]\n}\n\nbusy_megan = {\n    \"Monday\": [(\"09:00\", \"17:00\")],\n    \"Tuesday\": [(\"09:00\", \"9:30\"), (\"10:00\", \"10:30\"), (\"12:00\", \"14:00\"), (\"15:00\", \"15:30\"), (\"16:00\", \"16:30\")],\n    # Wednesday is not an option because Betty is unavailable.\n    \"Thursday\": [(\"09:00\", \"10:30\"), (\"11:30\", \"14:00\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:30\")],\n    \"Friday\": [(\"09:00\", \"17:00\")]\n}\n\n# We consider possible days: Monday, Tuesday, Friday.\n# (Monday and Friday are ruled out for Megan, Monday and Friday Megan is busy all day.)\n# Only Tuesday remains a candidate where both can meet.\ncandidate_days = [\"Monday\", \"Tuesday\", \"Friday\"]\n\nmeeting_day = None\nmeeting_start_min = None\nmeeting_end_min = None\n\nfor day in candidate_days:\n    # Skip days that are not allowed for Betty\n    if day in [\"Wednesday\", \"Thursday\"]:\n        continue\n        \n    # Get free slots for Betty\n    betty_busy = busy_betty.get(day, [])\n    betty_busy_minutes = [(time_to_minutes(s), time_to_minutes(e)) for s, e in betty_busy]\n    betty_free = get_free_slots(betty_busy_minutes, work_start, work_end)\n    \n    # Get free slots for Megan\n    megan_busy = busy_megan.get(day, [])\n    megan_busy_minutes = [(time_to_minutes(s), time_to_minutes(e)) for s, e in megan_busy]\n    megan_free = get_free_slots(megan_busy_minutes, work_start, work_end)\n    \n    # Find intersections between Betty's free slots and Megan's free slots\n    common_free = intersect_slots(betty_free, megan_free)\n    \n    # Check if any intersection can accommodate meeting duration\n    for start, end in common_free:\n        if end - start >= meeting_duration:\n            meeting_day = day\n            meeting_start_min = start\n            meeting_end_min = start + meeting_duration\n            break\n    if meeting_day:\n        break\n\nif meeting_day:\n    meeting_start_str = minutes_to_time(meeting_start_min)\n    meeting_end_str = minutes_to_time(meeting_end_min)\n    # Output format: HH:MM:HH:MM and day of week\n    print(f\"{meeting_day} {meeting_start_str}:{meeting_end_str}\")\nelse:\n    print(\"No available meeting slot found.\")\n'''",
            "count": "calendar_scheduling_example_964"
        }
    ]
}