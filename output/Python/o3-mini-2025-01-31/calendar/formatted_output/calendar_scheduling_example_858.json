{
    "0shot": [
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "12:00",
                "end_time": "13:00"
            },
            "expected_time": {
                "day": "Tuesday",
                "start_time": "12:00",
                "end_time": "13:00"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import datetime, timedelta\n\n# Define constants for workday start, workday end (in minutes from midnight)\nWORK_START = 9 * 60       # 9:00 in minutes (540)\nWORK_END = 17 * 60        # 17:00 in minutes (1020)\nMEETING_DURATION = 60     # meeting duration in minutes\n\n# Helper function to convert HH:MM string to minutes\ndef time_to_minutes(time_str):\n    hours, minutes = map(int, time_str.split(':'))\n    return hours * 60 + minutes\n\n# Helper function to convert minutes to HH:MM string\ndef minutes_to_time(minutes):\n    return f\"{minutes // 60:02d}:{minutes % 60:02d}\"\n\n# Helper function to merge intervals and then find free slots from busy slots\ndef get_free_intervals(busy_intervals):\n    # busy_intervals assumed sorted by start time and non-overlapping\n    free_intervals = []\n    start = WORK_START\n    for b in busy_intervals:\n        b_start, b_end = b\n        if start < b_start:\n            free_intervals.append((start, b_start))\n        start = max(start, b_end)\n    if start < WORK_END:\n        free_intervals.append((start, WORK_END))\n    return free_intervals\n\n# Helper function to intersect two lists of intervals\ndef intersect_intervals(intervals1, intervals2):\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        a_start, a_end = intervals1[i]\n        b_start, b_end = intervals2[j]\n        # Find overlap if it exists\n        start = max(a_start, b_start)\n        end = min(a_end, b_end)\n        if start < end:\n            result.append((start, end))\n        # Move the interval that ends first\n        if a_end <= b_end:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Define participant schedules.\n# Each schedule is a dictionary where keys are days and values are lists of busy time intervals (in minutes)\n# Intervals are represented as tuples (start, end) in minutes.\nschedules = {\n    \"Monday\": {\n        \"Carl\": [(time_to_minutes(\"11:00\"), time_to_minutes(\"11:30\"))],\n        \"Margaret\": [(time_to_minutes(\"09:00\"), time_to_minutes(\"10:30\")),\n                     (time_to_minutes(\"11:00\"), time_to_minutes(\"17:00\"))]\n    },\n    \"Tuesday\": {\n        \"Carl\": [(time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\"))],\n        \"Margaret\": [(time_to_minutes(\"09:30\"), time_to_minutes(\"12:00\")),\n                     (time_to_minutes(\"13:30\"), time_to_minutes(\"14:00\")),\n                     (time_to_minutes(\"15:30\"), time_to_minutes(\"17:00\"))]\n    },\n    \"Wednesday\": {\n        \"Carl\": [(time_to_minutes(\"10:00\"), time_to_minutes(\"11:30\")),\n                 (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\"))],\n        \"Margaret\": [(time_to_minutes(\"09:30\"), time_to_minutes(\"12:00\")),\n                     (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\")),\n                     (time_to_minutes(\"13:30\"), time_to_minutes(\"14:30\")),\n                     (time_to_minutes(\"15:00\"), time_to_minutes(\"17:00\"))]\n    },\n    \"Thursday\": {\n        \"Carl\": [(time_to_minutes(\"13:30\"), time_to_minutes(\"14:00\")),\n                 (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))],\n        \"Margaret\": [(time_to_minutes(\"10:00\"), time_to_minutes(\"12:00\")),\n                     (time_to_minutes(\"12:30\"), time_to_minutes(\"14:00\")),\n                     (time_to_minutes(\"14:30\"), time_to_minutes(\"17:00\"))]\n    },\n}\n\n# Preferred order of days. Carl prefers to avoid Thursday if possible.\npreferred_days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\"]\n\ndef find_meeting_slot():\n    for day in preferred_days:\n        # Calculate free intervals for each participant on this day.\n        day_schedules = schedules.get(day, {})\n        # For each participant, start with full work hours as a free interval, then subtract busy times.\n        participant_free = []\n        for participant in [\"Carl\", \"Margaret\"]:\n            busy_times = day_schedules.get(participant, [])\n            # Sort busy intervals (they are assumed not overlapping)\n            busy_times.sort(key=lambda x: x[0])\n            free = get_free_intervals(busy_times)\n            participant_free.append(free)\n        # Intersect free intervals among all participants\n        common_free = participant_free[0]\n        for i in range(1, len(participant_free)):\n            common_free = intersect_intervals(common_free, participant_free[i])\n        # Check if any free interval is long enough for the meeting\n        for interval in common_free:\n            start, end = interval\n            if end - start >= MEETING_DURATION:\n                meeting_start = start\n                meeting_end = start + MEETING_DURATION\n                return day, meeting_start, meeting_end\n    return None, None, None\n\nday, start_minutes, end_minutes = find_meeting_slot()\n\nif day:\n    start_time = minutes_to_time(start_minutes)\n    end_time = minutes_to_time(end_minutes)\n    # Output in the requested format: HH:MM:HH:MM and day of the week.\n    print(f\"Meeting Time: {start_time}:{end_time} on {day}\")\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_858"
        }
    ]
}