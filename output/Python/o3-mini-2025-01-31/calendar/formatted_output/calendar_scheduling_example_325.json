{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "10:30",
                "end_time": "11:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "10:30",
                "end_time": "11:00"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import timedelta, datetime\n\n# Helper function: convert HH:MM string to minutes from midnight\ndef to_minutes(time_str):\n    dt = datetime.strptime(time_str, \"%H:%M\")\n    return dt.hour * 60 + dt.minute\n\n# Helper function: convert minutes from midnight to HH:MM string\ndef to_time_str(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Given the work day and constraints:\n# Work hours: 09:00 (540 minutes) to 17:00 (1020 minutes)\n# But Jose does not want to meet after 15:30 so effectively his window is 09:00 to 15:30 (930 minutes).\n# Meeting duration in minutes:\nmeeting_duration = 30\n\n# For each participant we've been given busy intervals.\n# We will first define each participant's busy intervals (in minutes) for Monday.\n# Note: Times are in the format [start, end) in minutes.\nschedules = {\n    \"Jose\": [\n        (to_minutes(\"11:00\"), to_minutes(\"11:30\")),\n        (to_minutes(\"12:30\"), to_minutes(\"13:00\"))\n    ],\n    \"Keith\": [\n        (to_minutes(\"14:00\"), to_minutes(\"14:30\")),\n        (to_minutes(\"15:00\"), to_minutes(\"15:30\"))\n    ],\n    \"Logan\": [\n        (to_minutes(\"09:00\"), to_minutes(\"10:00\")),\n        (to_minutes(\"12:00\"), to_minutes(\"12:30\")),\n        (to_minutes(\"15:00\"), to_minutes(\"15:30\"))\n    ],\n    \"Megan\": [\n        (to_minutes(\"09:00\"), to_minutes(\"10:30\")),\n        (to_minutes(\"11:00\"), to_minutes(\"12:00\")),\n        (to_minutes(\"13:00\"), to_minutes(\"13:30\")),\n        (to_minutes(\"14:30\"), to_minutes(\"16:30\"))\n    ],\n    \"Gary\": [\n        (to_minutes(\"09:00\"), to_minutes(\"09:30\")),\n        (to_minutes(\"10:00\"), to_minutes(\"10:30\")),\n        (to_minutes(\"11:30\"), to_minutes(\"13:00\")),\n        (to_minutes(\"13:30\"), to_minutes(\"14:00\")),\n        (to_minutes(\"14:30\"), to_minutes(\"16:30\"))\n    ],\n    \"Bobby\": [\n        (to_minutes(\"11:00\"), to_minutes(\"11:30\")),\n        (to_minutes(\"12:00\"), to_minutes(\"12:30\")),\n        (to_minutes(\"13:00\"), to_minutes(\"16:00\"))\n    ]\n}\n\n# Work window for each participant.\n# For everyone except Jose, the work window is 09:00 (540) to 17:00 (1020),\n# but for scheduling the meeting we must consider only slots that also respect Jose's constraint: meeting end before or at 15:30 (930).\nwork_window_start = to_minutes(\"09:00\")\nwork_window_end = to_minutes(\"17:00\")\njose_latest_end = to_minutes(\"15:30\")\n# For meeting scheduling, the effective overall time window becomes:\neffective_start = work_window_start\neffective_end = min(work_window_end, jose_latest_end)  # 15:30 = 930\n\n# Function to compute free intervals given a list of busy intervals and a work window.\ndef compute_free_intervals(busy_intervals, window_start, window_end):\n    # Sort busy intervals by start time\n    busy_intervals = sorted(busy_intervals, key=lambda x: x[0])\n    free_intervals = []\n    \n    # Start with the time from window_start to the first busy interval\n    current = window_start\n    for start, end in busy_intervals:\n        if start > current:\n            free_intervals.append((current, start))\n        # Move current pointer to the maximum of current or end of the busy interval\n        current = max(current, end)\n    # Add remaining time after last busy event\n    if current < window_end:\n        free_intervals.append((current, window_end))\n    return free_intervals\n\n# Compute free intervals for each participant within their effective window.\n# Note: For Jose we restrict his window to effective_start to jose_latest_end.\nfree_times = {}\nfor person, busy in schedules.items():\n    if person == \"Jose\":\n        free_times[person] = compute_free_intervals(busy, effective_start, jose_latest_end)\n    else:\n        free_times[person] = compute_free_intervals(busy, effective_start, effective_end)\n\n# For debugging, you can print each person's free intervals in HH:MM format.\n# for person, intervals in free_times.items():\n#     print(person, [(to_time_str(start), to_time_str(end)) for start, end in intervals])\n\n# Function to intersect two lists of intervals.\ndef intersect_intervals(list1, list2):\n    result = []\n    i, j = 0, 0\n    while i < len(list1) and j < len(list2):\n        a_start, a_end = list1[i]\n        b_start, b_end = list2[j]\n        # Calculate the overlap between intervals:\n        start = max(a_start, b_start)\n        end = min(a_end, b_end)\n        if start < end:  # There is an overlap\n            result.append((start, end))\n        # Move to the next interval in the list that finishes first.\n        if a_end <= b_end:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Compute the overall intersection of free intervals for all participants.\nparticipants = list(free_times.keys())\ncommon_free = free_times[participants[0]]\nfor person in participants[1:]:\n    common_free = intersect_intervals(common_free, free_times[person])\n\n# Find a common free interval that is at least meeting_duration long.\nproposed_interval = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        proposed_interval = (start, start + meeting_duration)\n        break\n\nif proposed_interval is not None:\n    start_time_str = to_time_str(proposed_interval[0])\n    end_time_str = to_time_str(proposed_interval[1])\n    # Make sure the output format is as required: HH:MM:HH:MM and include the day of the week.\n    print(f\"Monday {start_time_str}:{end_time_str}\")\nelse:\n    print(\"No available slot found.\")\n'''",
            "count": "calendar_scheduling_example_325"
        }
    ]
}