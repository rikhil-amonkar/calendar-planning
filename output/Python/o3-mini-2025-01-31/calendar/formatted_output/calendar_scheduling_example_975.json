{
    "0shot": [
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "10:30",
                "end_time": "11:30"
            },
            "expected_time": {
                "day": "Tuesday",
                "start_time": "10:30",
                "end_time": "11:30"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import datetime, timedelta\n\n# Helper function: convert HH:MM string to minutes since midnight\ndef time_to_minutes(t):\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\n# Helper function: convert minutes since midnight to HH:MM format\ndef minutes_to_time(m):\n    return f\"{m//60:02d}:{m%60:02d}\"\n\n# Work day boundaries (in minutes since midnight)\nwork_start = time_to_minutes(\"09:00\")\nwork_end   = time_to_minutes(\"17:00\")\nmeeting_duration = 60  # in minutes\n\n# Participant schedules represented as dictionary mapping day -> list of (start, end) in minutes\n# Nicole's schedule\nnicole_schedule = {\n    \"Tuesday\": [(time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))],\n    \"Wednesday\": [(time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\"))],\n    \"Friday\": [(time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n               (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\"))]\n}\n\n# Daniel's schedule\ndaniel_schedule = {\n    \"Monday\": [(time_to_minutes(\"09:00\"), time_to_minutes(\"12:30\")),\n               (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n               (time_to_minutes(\"14:00\"), time_to_minutes(\"16:30\"))],\n    \"Tuesday\": [(time_to_minutes(\"09:00\"), time_to_minutes(\"10:30\")),\n                (time_to_minutes(\"11:30\"), time_to_minutes(\"12:30\")),\n                (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n                (time_to_minutes(\"15:00\"), time_to_minutes(\"16:00\")),\n                (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))],\n    \"Wednesday\": [(time_to_minutes(\"09:00\"), time_to_minutes(\"10:00\")),\n                  (time_to_minutes(\"11:00\"), time_to_minutes(\"12:30\")),\n                  (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n                  (time_to_minutes(\"14:00\"), time_to_minutes(\"14:30\")),\n                  (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))],\n    \"Thursday\": [(time_to_minutes(\"11:00\"), time_to_minutes(\"12:00\")),\n                 (time_to_minutes(\"13:00\"), time_to_minutes(\"14:00\")),\n                 (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\"))],\n    \"Friday\": [(time_to_minutes(\"10:00\"), time_to_minutes(\"11:00\")),\n               (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n               (time_to_minutes(\"12:30\"), time_to_minutes(\"14:30\")),\n               (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\")),\n               (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))]\n}\n\n# List of days in order\ndays = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"]\n\ndef merge_intervals(intervals):\n    \"\"\"Merge overlapping intervals.\"\n    \"\"\"\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        last = merged[-1]\n        if current[0] <= last[1]:\n            merged[-1] = (last[0], max(last[1], current[1]))\n        else:\n            merged.append(current)\n    return merged\n\ndef find_free_interval(busy_intervals, day_start, day_end, duration):\n    \"\"\"\n    Given busy_intervals (merged and sorted), find the earliest free interval\n    of at least 'duration' minutes between day_start and day_end.\n    Returns the start time if found, else None.\n    \"\"\"\n    # Check before the first busy interval\n    if not busy_intervals:\n        if day_end - day_start >= duration:\n            return day_start\n        else:\n            return None\n\n    if busy_intervals[0][0] - day_start >= duration:\n        return day_start\n\n    # Check gaps between busy intervals\n    for i in range(len(busy_intervals) - 1):\n        end_current = busy_intervals[i][1]\n        start_next = busy_intervals[i+1][0]\n        if start_next - end_current >= duration:\n            return end_current\n\n    # Check after the last busy interval\n    if day_end - busy_intervals[-1][1] >= duration:\n        return busy_intervals[-1][1]\n\n    return None\n\n# Find earliest meeting time across days\nscheduled_day = None\nmeeting_start = None\n\nfor day in days:\n    # Gather busy intervals for both participants on this day\n    intervals = []\n    if day in nicole_schedule:\n        intervals.extend(nicole_schedule[day])\n    if day in daniel_schedule:\n        intervals.extend(daniel_schedule[day])\n    # Merge intervals to handle any overlapping intervals\n    busy = merge_intervals(intervals)\n    # Find a free time slot on this day\n    free_start = find_free_interval(busy, work_start, work_end, meeting_duration)\n    if free_start is not None:\n        scheduled_day = day\n        meeting_start = free_start\n        break  # found the earliest day and time\n\nif scheduled_day is not None:\n    meeting_end = meeting_start + meeting_duration\n    # Format output as HH:MM:HH:MM and day\n    meeting_time_str = f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    print(f\"Meeting scheduled on {scheduled_day} at {meeting_time_str}\")\nelse:\n    print(\"No available time slot found for the meeting.\")\n'''",
            "count": "calendar_scheduling_example_975"
        }
    ]
}