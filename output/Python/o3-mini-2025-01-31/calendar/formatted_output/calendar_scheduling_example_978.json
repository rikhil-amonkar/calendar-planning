{
    "0shot": [
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "9:30",
                "end_time": "10:30"
            },
            "expected_time": {
                "day": "Tuesday",
                "start_time": "9:30",
                "end_time": "10:30"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import datetime, timedelta\n\n# Convert time string HH:MM to minutes from midnight.\ndef time_to_minutes(time_str):\n    h, m = map(int, time_str.split(':'))\n    return h * 60 + m\n\n# Convert minutes from midnight to time string in HH:MM format.\ndef minutes_to_time(minutes):\n    h = minutes // 60\n    m = minutes % 60\n    return f\"{h:02d}:{m:02d}\"\n\n# Work hours in minutes (09:00 to 17:00)\nWORK_START = time_to_minutes(\"09:00\")\nWORK_END = time_to_minutes(\"17:00\")\nMEETING_DURATION = 60  # in minutes\n\n# Busy schedules for each participant per day.\n# Times are represented as tuples of (start, end) in minutes.\n# Monday, Tuesday, Wednesday, Thursday, Friday ordering.\nbrian_busy = {\n    \"Monday\": [\n        (time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n        (time_to_minutes(\"12:30\"), time_to_minutes(\"14:30\")),\n        (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\"))\n    ],\n    \"Tuesday\": [\n        (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\"))\n    ],\n    \"Wednesday\": [\n        (time_to_minutes(\"12:30\"), time_to_minutes(\"14:00\")),\n        (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))\n    ],\n    \"Thursday\": [\n        (time_to_minutes(\"11:00\"), time_to_minutes(\"11:30\")),\n        (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n        (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))\n    ],\n    \"Friday\": [\n        (time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n        (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n        (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n        (time_to_minutes(\"15:00\"), time_to_minutes(\"16:00\")),\n        (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))\n    ]\n}\n\njulia_busy = {\n    \"Monday\": [\n        (time_to_minutes(\"09:00\"), time_to_minutes(\"10:00\")),\n        (time_to_minutes(\"11:00\"), time_to_minutes(\"11:30\")),\n        (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\")),\n        (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\"))\n    ],\n    \"Tuesday\": [\n        (time_to_minutes(\"13:00\"), time_to_minutes(\"14:00\")),\n        (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))\n    ],\n    \"Wednesday\": [\n        (time_to_minutes(\"09:00\"), time_to_minutes(\"11:30\")),\n        (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n        (time_to_minutes(\"13:00\"), time_to_minutes(\"17:00\"))\n    ],\n    \"Thursday\": [\n        (time_to_minutes(\"09:00\"), time_to_minutes(\"10:30\")),\n        (time_to_minutes(\"11:00\"), time_to_minutes(\"17:00\"))\n    ],\n    \"Friday\": [\n        (time_to_minutes(\"09:00\"), time_to_minutes(\"10:00\")),\n        (time_to_minutes(\"10:30\"), time_to_minutes(\"11:30\")),\n        (time_to_minutes(\"12:30\"), time_to_minutes(\"14:00\")),\n        (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\")),\n        (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\"))\n    ]\n}\n\n# List of weekdays. Given Brian prefers to avoid Monday, we try other days first.\nweekdays_ordered = [\"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Monday\"]\n\ndef merge_intervals(intervals):\n    \"\"\"Merge overlapping intervals.\"\"\"\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        prev = merged[-1]\n        if current[0] <= prev[1]:\n            merged[-1] = (prev[0], max(prev[1], current[1]))\n        else:\n            merged.append(current)\n    return merged\n\ndef find_free_slots(busy_intervals):\n    \"\"\"Based on busy intervals, compute free intervals within work hours.\"\"\"\n    free = []\n    # Ensure the busy intervals are merged\n    busy_intervals = merge_intervals(busy_intervals)\n    start = WORK_START\n    for interval in busy_intervals:\n        if start < interval[0]:\n            free.append((start, interval[0]))\n        start = max(start, interval[1])\n    if start < WORK_END:\n        free.append((start, WORK_END))\n    return free\n\ndef find_meeting_slot():\n    for day in weekdays_ordered:\n        # Get busy intervals for both participants on this day\n        busy = []\n        if day in brian_busy:\n            busy.extend(brian_busy[day])\n        if day in julia_busy:\n            busy.extend(julia_busy[day])\n        # Merge busy intervals and calculate free slots in work hours.\n        free_slots = find_free_slots(busy)\n        # Check for an available slot that is at least MEETING_DURATION long.\n        for start, end in free_slots:\n            if end - start >= MEETING_DURATION:\n                # Return the earliest meeting slot (from start to start + duration)\n                meeting_start = start\n                meeting_end = start + MEETING_DURATION\n                return day, minutes_to_time(meeting_start), minutes_to_time(meeting_end)\n    return None, None, None\n\nday, start_time, end_time = find_meeting_slot()\nif day:\n    # Output in the required format: HH:MM:HH:MM and day of the week.\n    print(f\"{start_time}:{end_time} on {day}\")\nelse:\n    print(\"No available slot found.\")\n'''",
            "count": "calendar_scheduling_example_978"
        }
    ]
}