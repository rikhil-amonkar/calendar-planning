{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "11:00",
                "end_time": "11:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "11:00",
                "end_time": "11:30"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import datetime, timedelta\n\n# Helper functions to convert time from string to minutes and vice versa.\ndef time_to_minutes(t):\n    # t in \"HH:MM\"\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    return f\"{m//60:02d}:{m%60:02d}\"\n\n# Compute free intervals given working hours and busy intervals.\ndef get_free_intervals(busy, work_start, work_end):\n    # Busy intervals is a list of tuples (start, end) in minutes\n    # Sort busy intervals by start time\n    busy = sorted(busy, key=lambda x: x[0])\n    free = []\n    # Start from work_start\n    current = work_start\n    for b_start, b_end in busy:\n        if b_start > current:\n            free.append((current, b_start))\n        current = max(current, b_end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\n# Intersect two lists of intervals.\ndef intersect_intervals(intervals1, intervals2):\n    result = []\n    i, j = 0, 0\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find the overlap between intervals1[i] and intervals2[j]\n        overlap_start = max(start1, start2)\n        overlap_end = min(end1, end2)\n        if overlap_start < overlap_end:\n            result.append((overlap_start, overlap_end))\n        # Move to the next interval in the list that ends first.\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Working hours: 09:00 to 17:00 in minutes.\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Busy schedules for each participant on Monday (time intervals in minutes).\nschedules = {\n    \"Joan\": [(\"11:30\", \"12:00\"), (\"14:30\", \"15:00\")],\n    \"Megan\": [(\"09:00\", \"10:00\"), (\"14:00\", \"14:30\"), (\"16:00\", \"16:30\")],\n    \"Austin\": [],\n    \"Betty\": [(\"09:30\", \"10:00\"), (\"11:30\", \"12:00\"), (\"13:30\", \"14:00\"), (\"16:00\", \"16:30\")],\n    \"Judith\": [(\"09:00\", \"11:00\"), (\"12:00\", \"13:00\"), (\"14:00\", \"15:00\")],\n    \"Terry\": [(\"09:30\", \"10:00\"), (\"11:30\", \"12:30\"), (\"13:00\", \"14:00\"), (\"15:00\", \"15:30\"), (\"16:00\", \"17:00\")],\n    \"Kathryn\": [(\"09:30\", \"10:00\"), (\"10:30\", \"11:00\"), (\"11:30\", \"13:00\"), (\"14:00\", \"16:00\"), (\"16:30\", \"17:00\")]\n}\n\n# Convert all busy times to minutes.\nfor person in schedules:\n    schedules[person] = [(time_to_minutes(s), time_to_minutes(e)) for s, e in schedules[person]]\n\n# Compute free intervals for each participant.\nfree_intervals = {}\nfor person, busy in schedules.items():\n    free_intervals[person] = get_free_intervals(busy, work_start, work_end)\n\n# Compute common free intervals across all participants.\ncommon_free = list(free_intervals.values())[0]\nfor person in list(free_intervals.keys())[1:]:\n    common_free = intersect_intervals(common_free, free_intervals[person])\n\n# Meeting duration: 30 minutes.\nmeeting_duration = 30\n\n# Find the first interval which can accommodate the meeting.\nmeeting_time = None\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        meeting_time = (start, start + meeting_duration)\n        break\n\nif meeting_time:\n    meeting_start = minutes_to_time(meeting_time[0])\n    meeting_end = minutes_to_time(meeting_time[1])\n    print(f\"Monday {meeting_start}:{meeting_end}\")\nelse:\n    print(\"No common free interval available.\")\n'''",
            "count": "calendar_scheduling_example_441"
        }
    ]
}