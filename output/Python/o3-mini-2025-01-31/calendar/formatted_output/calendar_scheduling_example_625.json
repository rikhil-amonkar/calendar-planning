{
    "0shot": [
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "9:30",
                "end_time": "10:00"
            },
            "expected_time": {
                "day": "Tuesday",
                "start_time": "15:30",
                "end_time": "16:00"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import timedelta, datetime\n\ndef time_to_minutes(t):\n    return t.hour * 60 + t.minute\n\ndef minutes_to_time(m):\n    return datetime(2020, 1, 1, m // 60, m % 60).strftime(\"%H:%M\")\n\n# Meeting duration in minutes\nmeeting_duration = 30\n\n# Work hours in minutes from 9:00 to 17:00\nwork_start = 9 * 60\nwork_end = 17 * 60\n\n# Harold's busy slots in minutes\n# Monday busy: 9:00-10:00 and 10:30-17:00\nharold_busy_monday = [(9 * 60, 10 * 60), (10 * 60 + 30, work_end)]\n# Tuesday busy: 9:00-9:30, 10:30-11:30, 12:30-13:30, 14:30-15:30, and 16:00-17:00\nharold_busy_tuesday = [\n    (9 * 60, 9 * 60 + 30),\n    (10 * 60 + 30, 11 * 60 + 30),\n    (12 * 60 + 30, 13 * 60 + 30),\n    (14 * 60 + 30, 15 * 60 + 30),\n    (16 * 60, work_end)\n]\n\n# Jeffrey is free the entire week so no busy intervals.\n# We also incorporate Harold's preferences:\n#    1. Avoid Monday (i.e., prefer Tuesday if possible)\n#    2. For Tuesday, the meeting should be scheduled before 14:30\n\ndef find_free_slot(busy_slots, working_start, working_end, meeting_duration, latest_end=None):\n    # Sort busy slots by start time\n    busy_slots.sort()\n    free_ranges = []\n    # Start with time before first busy interval if available.\n    current_start = working_start\n    for start, end in busy_slots:\n        if current_start < start:\n            free_ranges.append((current_start, start))\n        current_start = max(current_start, end)\n    # Check after last busy interval.\n    if current_start < working_end:\n        free_ranges.append((current_start, working_end))\n    \n    # Filter free ranges by meeting duration\n    for free_start, free_end in free_ranges:\n        if free_end - free_start >= meeting_duration:\n            # If a latest_end constraint is provided, ensure the meeting is before that time.\n            # We require that the meeting end (start + meeting_duration) is <= latest_end.\n            if latest_end is not None:\n                # Find the earliest time in this free slot that fits the meeting and ends before latest_end.\n                # The meeting can start at free_start at the earliest.\n                meeting_start = free_start\n                # if meeting_start + meeting_duration goes beyond latest_end, then skip this slot.\n                if meeting_start + meeting_duration > latest_end:\n                    # check if a later start in the interval could still yield an end time <= latest_end\n                    # i.e. meeting_start must be <= latest_end - meeting_duration.\n                    if free_end > latest_end - meeting_duration:\n                        # we can set meeting_start = free_start if free_start is within allowed range\n                        if free_start <= latest_end - meeting_duration:\n                            meeting_start = free_start\n                        else:\n                            continue\n                    else:\n                        continue\n                # Return meeting start and end times\n                return meeting_start, meeting_start + meeting_duration\n            else:\n                return free_start, free_start + meeting_duration\n    return None\n\n# We prefer Tuesday given Harold's preference.\n# Tuesday working time: 9:00 to 17:00, with additional constraint: meeting must finish before 14:30.\nlatest_end_tuesday = 14 * 60 + 30  # 14:30 in minutes\n\ntuesday_slot = find_free_slot(\n    harold_busy_tuesday,\n    work_start,\n    work_end,\n    meeting_duration,\n    latest_end=latest_end_tuesday\n)\n\nif tuesday_slot:\n    meeting_day = \"Tuesday\"\n    start_minutes, end_minutes = tuesday_slot\n    meeting_time = f\"{minutes_to_time(start_minutes)}:{minutes_to_time(end_minutes)}\"\nelse:\n    # fallback to Monday, if needed (though the problem assures a solution exists)\n    monday_slot = find_free_slot(\n        harold_busy_monday,\n        work_start,\n        work_end,\n        meeting_duration\n    )\n    meeting_day = \"Monday\"\n    start_minutes, end_minutes = monday_slot\n    meeting_time = f\"{minutes_to_time(start_minutes)}:{minutes_to_time(end_minutes)}\"\n\nprint(f\"{meeting_day} {meeting_time}\")\n'''",
            "count": "calendar_scheduling_example_625"
        }
    ]
}