{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "12:30",
                "end_time": "13:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "12:30",
                "end_time": "13:00"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import timedelta, datetime\n\n# Define working day start and end times (using datetime objects for ease)\nWORK_DAY = \"09:00\", \"17:00\"\nmeeting_duration = timedelta(minutes=30)\nday_of_week = \"Monday\"\n\n# Convert time strings to datetime objects (the specific date is arbitrary, we use a dummy date)\ndef to_datetime(time_str):\n    return datetime.strptime(time_str, \"%H:%M\")\n\nwork_start = to_datetime(WORK_DAY[0])\nwork_end   = to_datetime(WORK_DAY[1])\n\n# Each participant's busy intervals (as tuples of start and end times)\n# Times are given as strings in \"HH:MM\" format\nbusy_times = {\n    \"Ronald\": [],  # Wide open\n    \"Stephen\": [(\"10:00\", \"10:30\"), (\"12:00\", \"12:30\")],\n    \"Brittany\": [(\"11:00\", \"11:30\"), (\"13:30\", \"14:00\"), (\"15:30\", \"16:00\"), (\"16:30\", \"17:00\")],\n    \"Dorothy\": [(\"09:00\", \"09:30\"), (\"10:00\", \"10:30\"), (\"11:00\", \"12:30\"), (\"13:00\", \"15:00\"), (\"15:30\", \"17:00\")],\n    \"Rebecca\": [(\"09:30\", \"10:30\"), (\"11:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"17:00\")],\n    \"Jordan\": [(\"09:00\", \"09:30\"), (\"10:00\", \"11:00\"), (\"11:30\", \"12:00\"), (\"13:00\", \"15:00\"), (\"15:30\", \"16:30\")]\n}\n\n# Helper function: Convert an interval from strings to datetime objects\ndef parse_interval(interval):\n    start, end = interval\n    return to_datetime(start), to_datetime(end)\n\n# For a given list of busy intervals (as datetime tuples), compute free intervals within the work day\ndef compute_free_intervals(busy_list):\n    # First, sort busy intervals by start time\n    busy_list = sorted([parse_interval(interval) for interval in busy_list], key=lambda x: x[0])\n    free = []\n    current = work_start\n    for bstart, bend in busy_list:\n        if current < bstart:\n            free.append((current, bstart))\n        # Move current pointer to the later of current or bend\n        if bend > current:\n            current = bend\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\n# Compute free intervals for each participant\nfree_intervals = {}\nfor participant, busy in busy_times.items():\n    free_intervals[participant] = compute_free_intervals(busy)\n\n# Function to intersect two lists of intervals\ndef intersect_intervals(list1, list2):\n    i, j = 0, 0\n    result = []\n    while i < len(list1) and j < len(list2):\n        start1, end1 = list1[i]\n        start2, end2 = list2[j]\n        # Find overlap\n        latest_start = max(start1, start2)\n        earliest_end = min(end1, end2)\n        if latest_start < earliest_end:\n            result.append((latest_start, earliest_end))\n        # Move to the next interval in the list with the earlier end time\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Intersect free intervals for all participants\nall_free = list(free_intervals.values())[0]\nfor intervals in list(free_intervals.values())[1:]:\n    all_free = intersect_intervals(all_free, intervals)\n\n# Find the first interval that can accommodate the meeting duration\nproposed_time = None\nfor start, end in all_free:\n    if end - start >= meeting_duration:\n        proposed_time = (start, start + meeting_duration)\n        break\n\nif proposed_time:\n    start_time, end_time = proposed_time\n    # Format the output in HH:MM:HH:MM\n    output = f\"{start_time.strftime('%H:%M')}:{end_time.strftime('%H:%M')}\"\n    print(f\"Day: {day_of_week}, Meeting Time: {output}\")\nelse:\n    print(\"No suitable time slot found.\")\n    \n# In this specific case, the meeting is scheduled on Monday from 12:30 to 13:00.\n'''",
            "count": "calendar_scheduling_example_307"
        }
    ]
}