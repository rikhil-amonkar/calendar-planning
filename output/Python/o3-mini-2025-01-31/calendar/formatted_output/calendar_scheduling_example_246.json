{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "12:30",
                "end_time": "13:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "12:30",
                "end_time": "13:00"
            },
            "has_error": false,
            "raw_model_response": "'''python\ndef minutes_to_time(minutes):\n    \"\"\"Convert minutes since midnight to a HH:MM string.\"\"\"\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\ndef merge_intervals(intervals):\n    \"\"\"Merge overlapping intervals. Assumes intervals is a list of (start, end) tuples.\"\"\"\n    if not intervals:\n        return []\n    # Sort intervals by start time\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        last = merged[-1]\n        # if overlapping or contiguous, merge them\n        if current[0] <= last[1]:\n            merged[-1] = (last[0], max(last[1], current[1]))\n        else:\n            merged.append(current)\n    return merged\n\ndef find_meeting_slot(busy_intervals, meeting_duration, work_start, work_end):\n    \"\"\"\n    Given busy intervals, meeting duration (in minutes), work_start and work_end in minutes,\n    find a free time slot that can fit the meeting.\n    Returns (start, end) in minutes.\n    \"\"\"\n    # Merge all busy intervals\n    merged_busy = merge_intervals(busy_intervals)\n    \n    # Check for free time before the first busy interval after work_start.\n    if work_start < merged_busy[0][0]:\n        if merged_busy[0][0] - work_start >= meeting_duration:\n            return (work_start, work_start + meeting_duration)\n    \n    # Check between busy intervals.\n    for i in range(len(merged_busy) - 1):\n        end_current = merged_busy[i][1]\n        start_next = merged_busy[i+1][0]\n        if start_next - end_current >= meeting_duration:\n            return (end_current, end_current + meeting_duration)\n    \n    # Check after the last busy interval within work hours.\n    if work_end - merged_busy[-1][1] >= meeting_duration:\n        return (merged_busy[-1][1], merged_busy[-1][1] + meeting_duration)\n    \n    return None  # In case there is no available slot.\n\ndef main():\n    # Define work hours in minutes from midnight: 9:00 to 17:00.\n    work_start = 9 * 60   # 540 minutes (9:00)\n    work_end = 17 * 60    # 1020 minutes (17:00)\n    meeting_duration = 30  # 30 minutes\n    \n    # Busy intervals for each participant (in minutes since midnight)\n    # Jacob: 13:30-14:00, 14:30-15:00\n    busy_jacob = [(13 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60)]\n    # Diana: 09:30-10:00, 11:30-12:00, 13:00-13:30, 16:00-16:30\n    busy_diana = [(9 * 60 + 30, 10 * 60), (11 * 60 + 30, 12 * 60), (13 * 60, 13 * 60 + 30), (16 * 60, 16 * 60 + 30)]\n    # Adam: 09:30-10:30, 11:00-12:30, 15:30-16:00\n    busy_adam = [(9 * 60 + 30, 10 * 60 + 30), (11 * 60, 12 * 60 + 30), (15 * 60 + 30, 16 * 60)]\n    # Angela: 09:30-10:00, 10:30-12:00, 13:00-15:30, 16:00-16:30\n    busy_angela = [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 12 * 60), (13 * 60, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)]\n    # Dennis: 09:00-09:30, 10:30-11:30, 13:00-15:00, 16:30-17:00\n    busy_dennis = [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 11 * 60 + 30), (13 * 60, 15 * 60), (16 * 60 + 30, 17 * 60)]\n    \n    # Combine all busy intervals into one list.\n    all_busy = busy_jacob + busy_diana + busy_adam + busy_angela + busy_dennis\n\n    # To ensure only busy slots within work hours are considered,\n    # we can clip intervals to within [work_start, work_end].\n    clipped_busy = []\n    for start, end in all_busy:\n        if end <= work_start or start >= work_end:\n            continue  # Skip intervals outside working hours.\n        clipped_start = max(start, work_start)\n        clipped_end = min(end, work_end)\n        clipped_busy.append((clipped_start, clipped_end))\n    \n    # Find a free slot for the meeting\n    meeting_slot = find_meeting_slot(clipped_busy, meeting_duration, work_start, work_end)\n    \n    if meeting_slot:\n        start_time = minutes_to_time(meeting_slot[0])\n        end_time = minutes_to_time(meeting_slot[1])\n        day = \"Monday\"\n        # Output in the format HH:MM:HH:MM and day of the week.\n        print(f\"{day} {start_time}:{end_time}\")\n    else:\n        print(\"No available time slot found.\")\n\nif __name__ == \"__main__\":\n    main()\n'''",
            "count": "calendar_scheduling_example_246"
        }
    ]
}