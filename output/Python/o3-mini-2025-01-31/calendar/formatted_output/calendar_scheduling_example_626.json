{
    "0shot": [
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "9:00",
                "end_time": "10:00"
            },
            "expected_time": {
                "day": "Tuesday",
                "start_time": "9:00",
                "end_time": "10:00"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import time, datetime, timedelta\n\n# Helper function to convert HH:MM string to minutes from midnight.\ndef time_to_minutes(t_str):\n    t = datetime.strptime(t_str, \"%H:%M\")\n    return t.hour * 60 + t.minute\n\n# Helper function to convert minutes to HH:MM format string.\ndef minutes_to_time(m):\n    return f\"{m // 60:02d}:{m % 60:02d}\"\n\n# Define the working hours in minutes (09:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nmeeting_duration = 60  # in minutes\n\n# Busy intervals for each participant per day (in minutes from midnight)\n# Format: { day: { participant: [(start, end), ...] } }\n\nschedules = {\n    \"Monday\": {\n        \"Patricia\": [\n            (time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n            (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n            (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n            (time_to_minutes(\"14:30\"), time_to_minutes(\"15:30\")),\n            (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\")),\n        ],\n        \"Jesse\": [\n            (time_to_minutes(\"09:00\"), time_to_minutes(\"17:00\")),  # entire day busy\n        ],\n    },\n    \"Tuesday\": {\n        \"Patricia\": [\n            (time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n            (time_to_minutes(\"11:00\"), time_to_minutes(\"12:00\")),\n            (time_to_minutes(\"14:00\"), time_to_minutes(\"16:00\")),\n            (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\")),\n        ],\n        \"Jesse\": [\n            (time_to_minutes(\"11:00\"), time_to_minutes(\"11:30\")),\n            (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n            (time_to_minutes(\"13:00\"), time_to_minutes(\"14:00\")),\n            (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\")),\n            (time_to_minutes(\"15:30\"), time_to_minutes(\"17:00\")),\n        ],\n    }\n}\n\n# Function to compute free intervals given busy intervals over a working period.\ndef compute_free_intervals(busy_intervals, start=work_start, end=work_end):\n    # Sort intervals by start time.\n    busy_intervals = sorted(busy_intervals, key=lambda x: x[0])\n    free_intervals = []\n    current_start = start\n    for b_start, b_end in busy_intervals:\n        if current_start < b_start:\n            free_intervals.append((current_start, b_start))\n        current_start = max(current_start, b_end)\n    if current_start < end:\n        free_intervals.append((current_start, end))\n    return free_intervals\n\n# Find common free intervals between two participants on a given day.\ndef find_common_free_intervals(day, participants):\n    # Compute free intervals for each participant.\n    free = {}\n    for person in participants:\n        busy = schedules[day].get(person, [])\n        free[person] = compute_free_intervals(busy)\n    \n    # Intersect free intervals across participants.\n    # We'll use a two interval list intersection method.\n    def intersect_intervals(intervals1, intervals2):\n        i, j = 0, 0\n        common = []\n        while i < len(intervals1) and j < len(intervals2):\n            start1, end1 = intervals1[i]\n            start2, end2 = intervals2[j]\n            # Find overlap.\n            overlap_start = max(start1, start2)\n            overlap_end = min(end1, end2)\n            if overlap_start < overlap_end:\n                common.append((overlap_start, overlap_end))\n            # Move to the next interval in the list which ends first.\n            if end1 <= end2:\n                i += 1\n            else:\n                j += 1\n        return common\n\n    # Start with the free intervals of the first participant.\n    common_free = free[participants[0]]\n    # Intersect with the remaining participant's free intervals.\n    for person in participants[1:]:\n        common_free = intersect_intervals(common_free, free[person])\n    return common_free\n\n# Try each day (Monday and Tuesday) and pick the first slot that can accommodate a meeting of meeting_duration minutes.\nchosen_day = None\nchosen_interval = None\n\nfor day in [\"Monday\", \"Tuesday\"]:\n    # We need the meeting for both Patricia and Jesse.\n    common_free = find_common_free_intervals(day, [\"Patricia\", \"Jesse\"])\n    for interval in common_free:\n        start, end = interval\n        if end - start >= meeting_duration:\n            chosen_day = day\n            chosen_interval = (start, start + meeting_duration)\n            break\n    if chosen_day:\n        break\n\nif chosen_day and chosen_interval:\n    meeting_start = minutes_to_time(chosen_interval[0])\n    meeting_end = minutes_to_time(chosen_interval[1])\n    print(f\"{chosen_day} {meeting_start}:{meeting_end}\")\nelse:\n    print(\"No common free slot found.\")\n'''",
            "count": "calendar_scheduling_example_626"
        }
    ]
}