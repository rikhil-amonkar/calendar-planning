{
    "0shot": [
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "10:00",
                "end_time": "10:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "16:00",
                "end_time": "16:30"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import datetime, timedelta\n\n# Utility functions to convert between \"HH:MM\" and minutes past midnight\ndef time_to_minutes(t):\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    return f\"{m//60:02}:{m%60:02}\"\n\n# Function to get free intervals from busy intervals within work hours\ndef get_free_intervals(busy_intervals, work_start, work_end):\n    free_intervals = []\n    # Start with the beginning of work hours\n    current = work_start\n    for start, end in sorted(busy_intervals):\n        if start > current:\n            free_intervals.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free_intervals.append((current, work_end))\n    return free_intervals\n\n# Function to intersect two lists of intervals\ndef intersect_intervals(intervals1, intervals2):\n    result = []\n    for start1, end1 in intervals1:\n        for start2, end2 in intervals2:\n            start = max(start1, start2)\n            end = min(end1, end2)\n            if end - start >= 0:\n                result.append((start, end))\n    # Merge overlapping intervals if needed (not necessary in this simple use-case)\n    return result\n\n# Meeting information\nmeeting_duration = 30  # minutes\nwork_start = time_to_minutes(\"09:00\")\nwork_end   = time_to_minutes(\"17:00\")\n\n# Schedules for each participant\n# Times are given as tuples (start, end) in \"HH:MM\" strings\nschedules = {\n    \"Ryan\": {\n        \"Monday\": [(\"09:30\", \"10:00\"), (\"11:00\", \"12:00\"), (\"13:00\", \"13:30\"), (\"15:30\", \"16:00\")],\n        \"Tuesday\": [(\"11:30\", \"12:30\"), (\"15:30\", \"16:00\")],\n        \"Wednesday\": [(\"12:00\", \"13:00\"), (\"15:30\", \"16:00\"), (\"16:30\", \"17:00\")]\n    },\n    \"Adam\": {\n        \"Monday\": [(\"09:00\", \"10:30\"), (\"11:00\", \"13:30\"), (\"14:00\", \"16:00\"), (\"16:30\", \"17:00\")],\n        \"Tuesday\": [(\"09:00\", \"10:00\"), (\"10:30\", \"15:30\"), (\"16:00\", \"17:00\")],\n        \"Wednesday\": [(\"09:00\", \"9:30\"), (\"10:00\", \"11:00\"), (\"11:30\", \"14:30\"), (\"15:00\", \"15:30\"), (\"16:00\", \"16:30\")]\n    }\n}\n\n# Additional constraints:\n# - Ryan cannot meet on Wednesday.\n# - Adam would like to avoid more meetings on Monday before 14:30.\n#   (We interpret this as preferring a meeting time on Monday not starting before 14:30,\n#    if a solution is available on another day, we'll choose that.)\n\n# Candidate days and apply hard constraints\ncandidate_days = [\"Monday\", \"Tuesday\", \"Wednesday\"]\n# Remove Wednesday because Ryan cannot meet on Wednesday.\ncandidate_days = [day for day in candidate_days if day != \"Wednesday\"]\n\ndef convert_schedule(day, person):\n    \"\"\"Converts schedule time intervals to minutes for a given day.\"\"\"\n    busy = []\n    for start, end in schedules[person].get(day, []):\n        busy.append((time_to_minutes(start), time_to_minutes(end)))\n    return busy\n\nmeeting_slot = None\nmeeting_day = None\n\n# We try candidate days. We'll prefer days that satisfy preferences.\n# First check Tuesday, then Monday. (Because Adam prefers to avoid Monday before 14:30.)\npreferred_order = [\"Tuesday\", \"Monday\"]\n\nfor day in preferred_order:\n    ryan_busy = convert_schedule(day, \"Ryan\")\n    adam_busy = convert_schedule(day, \"Adam\")\n    \n    ryan_free = get_free_intervals(ryan_busy, work_start, work_end)\n    adam_free = get_free_intervals(adam_busy, work_start, work_end)\n    \n    # Intersect free intervals between Ryan and Adam\n    common_free = intersect_intervals(ryan_free, adam_free)\n    \n    # Sort common free intervals by start time\n    common_free.sort(key=lambda x: x[0])\n    \n    # Try to find a common interval that can accommodate meeting_duration \n    for start, end in common_free:\n        if end - start >= meeting_duration:\n            # For Monday, check Adam's preference: avoid meetings before 14:30\n            if day == \"Monday\" and start < time_to_minutes(\"14:30\"):\n                # Try to adjust start time if possible within the interval\n                adjusted_start = max(start, time_to_minutes(\"14:30\"))\n                if end - adjusted_start >= meeting_duration:\n                    start = adjusted_start\n                else:\n                    # Skip this interval since it doesn't satisfy Adam's preference.\n                    continue\n            meeting_slot = (start, start + meeting_duration)\n            meeting_day = day\n            break\n    if meeting_slot:\n        break\n\nif meeting_slot:\n    start_str = minutes_to_time(meeting_slot[0])\n    end_str = minutes_to_time(meeting_slot[1])\n    print(f\"{meeting_day}: {start_str}:{end_str}\")\nelse:\n    print(\"No suitable meeting slot found.\")\n'''",
            "count": "calendar_scheduling_example_707"
        }
    ]
}