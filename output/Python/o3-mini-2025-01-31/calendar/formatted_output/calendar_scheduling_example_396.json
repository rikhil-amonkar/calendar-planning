{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "11:30",
                "end_time": "12:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "11:30",
                "end_time": "12:00"
            },
            "has_error": false,
            "raw_model_response": "'''python\ndef time_to_minutes(t):\n    \"\"\"Converts a time string 'HH:MM' to minutes since midnight.\"\"\"\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    \"\"\"Converts minutes since midnight to a time string 'HH:MM'.\"\"\"\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Finds the intersection of two lists of intervals.\n       Each interval is a tuple (start, end) where times are in minutes.\"\"\"\n    result = []\n    i, j = 0, 0\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find overlap\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap < end_overlap:\n            result.append((start_overlap, end_overlap))\n        # Move to next interval in the list that finishes earlier\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Workday start and end (09:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end   = time_to_minutes(\"17:00\")\n\n# Each participant's free intervals (in minutes) within the work hours.\n# For those with busy intervals provided, we calculate their free intervals.\n# If the participant is free all day, then free interval is the whole period.\n# Busy intervals are half-open: start inclusive, end exclusive.\n\n# Andrea: free all day.\nandrea_free = [(work_start, work_end)]\n\n# Jack busy: 09:00-09:30, 14:00-14:30.\n# So free: 09:30-14:00 and 14:30-17:00.\njack_free = [\n    (time_to_minutes(\"09:30\"), time_to_minutes(\"14:00\")),\n    (time_to_minutes(\"14:30\"), work_end)\n]\n\n# Madison busy: 09:30-10:30, 13:00-14:00, 15:00-15:30, 16:30-17:00.\n# So free: 09:00-09:30, 10:30-13:00, 14:00-15:00, 15:30-16:30.\nmadison_free = [\n    (work_start, time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"10:30\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"16:30\"))\n]\n\n# Rachel busy: 09:30-10:30, 11:00-11:30, 12:00-13:30, 14:30-15:30, 16:00-17:00.\n# So free: 09:00-09:30, 10:30-11:00, 11:30-12:00, 13:30-14:30, 15:30-16:00.\nrachel_free = [\n    (work_start, time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"13:30\"), time_to_minutes(\"14:30\")),\n    (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\"))\n]\n\n# Douglas busy: 09:00-11:30, 12:00-16:30.\n# So free: 11:30-12:00, 16:30-17:00.\ndouglas_free = [\n    (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n    (time_to_minutes(\"16:30\"), work_end)\n]\n\n# Ryan busy: 09:00-09:30, 13:00-14:00, 14:30-17:00.\n# So free: 09:30-13:00, 14:00-14:30.\nryan_free = [\n    (time_to_minutes(\"09:30\"), time_to_minutes(\"13:00\")),\n    (time_to_minutes(\"14:00\"), time_to_minutes(\"14:30\"))\n]\n\n# List of free intervals for all participants.\nparticipants_free = [andrea_free, jack_free, madison_free, rachel_free, douglas_free, ryan_free]\n\n# Compute the intersection of free intervals across all participants.\ncommon_free = participants_free[0]\nfor free in participants_free[1:]:\n    common_free = intersect_intervals(common_free, free)\n\n# Looking for an interval that is at least 30 minutes long.\nmeeting_duration = 30\nproposed_start = None\n\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        proposed_start = start\n        break\n\nif proposed_start is not None:\n    proposed_end = proposed_start + meeting_duration\n    meeting_day = \"Monday\"\n    print(f\"{minutes_to_time(proposed_start)}:{minutes_to_time(proposed_end)} on {meeting_day}\")\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_396"
        }
    ]
}