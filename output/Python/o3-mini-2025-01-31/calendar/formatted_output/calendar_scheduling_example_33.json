{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "13:30",
                "end_time": "14:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "13:30",
                "end_time": "14:00"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import datetime, timedelta\n\n# Helper function to convert time string (HH:MM) to minutes since midnight\ndef time_to_minutes(t_str):\n    h, m = map(int, t_str.split(\":\"))\n    return h * 60 + m\n\n# Helper function to convert minutes since midnight to time string (HH:MM)\ndef minutes_to_time(m):\n    return f\"{m//60:02d}:{m%60:02d}\"\n\n# Meeting duration in minutes and work day boundaries (in minutes)\nmeeting_duration = 30\nday_start = time_to_minutes(\"09:00\")\nday_end = time_to_minutes(\"17:00\")\navoid_after = time_to_minutes(\"15:00\")  # Bobby wants to avoid meetings after 15:00\n\n# Busy schedules for each participant on Monday: list of (start, end) time in minutes\nschedules = {\n    \"Lisa\": [\n        (time_to_minutes(\"09:00\"), time_to_minutes(\"10:00\")),\n        (time_to_minutes(\"10:30\"), time_to_minutes(\"11:30\")),\n        (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\")),\n        (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))\n    ],\n    \"Bobby\": [\n        (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n        (time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n        (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n        (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\"))\n    ],\n    \"Randy\": [\n        (time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n        (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n        (time_to_minutes(\"11:30\"), time_to_minutes(\"12:30\")),\n        (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n        (time_to_minutes(\"14:30\"), time_to_minutes(\"15:30\")),\n        (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))\n    ]\n}\n\n# This function returns the free intervals for a person given the busy intervals,\n# constrained to be within the work day hours.\ndef get_free_intervals(busy_intervals):\n    free_intervals = []\n    # Start with the beginning of the day\n    current_start = day_start\n    for start, end in sorted(busy_intervals):\n        if current_start < start:\n            free_intervals.append((current_start, start))\n        current_start = max(current_start, end)\n    if current_start < day_end:\n        free_intervals.append((current_start, day_end))\n    return free_intervals\n\n# Get free intervals for all participants\nfree_intervals_all = {}\nfor person, busy in schedules.items():\n    free_intervals_all[person] = get_free_intervals(busy)\n\n# Function to intersect two sets of intervals\ndef intersect_intervals(intervals1, intervals2):\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # find overlap between intervals\n        overlap_start = max(start1, start2)\n        overlap_end = min(end1, end2)\n        if overlap_end - overlap_start >= meeting_duration:\n            result.append((overlap_start, overlap_end))\n        # Move next based on which interval ends earlier\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Calculate the common free intervals for all participants\ncommon_free = free_intervals_all[\"Lisa\"]\nfor person in [\"Bobby\", \"Randy\"]:\n    common_free = intersect_intervals(common_free, free_intervals_all[person])\n\n# Also, Bobby prefers to avoid meetings after 15:00,\n# so we need to restrict the available intervals to end by 15:00.\nadjusted_free = []\nfor start, end in common_free:\n    # If the interval starts after or at 15:00, skip it\n    if start >= avoid_after:\n        continue\n    # Adjust end to the minimum of original end and Bobby's avoid_after time\n    adjusted_end = min(end, avoid_after)\n    if adjusted_end - start >= meeting_duration:\n        adjusted_free.append((start, adjusted_end))\n\n# Select the earliest possible interval that can accommodate the meeting\nmeeting_start = None\nfor start, end in adjusted_free:\n    if end - start >= meeting_duration:\n        meeting_start = start\n        break\n\nif meeting_start is None:\n    print(\"No available meeting slot found within the constraints.\")\nelse:\n    meeting_end = meeting_start + meeting_duration\n    # Format the meeting time in HH:MM:HH:MM\n    meeting_time_str = f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    # Print the proposed meeting time and day of the week\n    day_of_week = \"Monday\"\n    print(meeting_time_str, day_of_week)\n'''",
            "count": "calendar_scheduling_example_33"
        }
    ]
}