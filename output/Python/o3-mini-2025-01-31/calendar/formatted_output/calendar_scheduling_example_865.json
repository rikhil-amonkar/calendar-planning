{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "9:00",
                "end_time": "10:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "9:00",
                "end_time": "10:00"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import timedelta, datetime\n\n# Convert a time string \"HH:MM\" to minutes since midnight.\ndef time_to_minutes(t):\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\n# Convert minutes to a time string \"HH:MM\"\ndef minutes_to_time(m):\n    return f\"{m//60:02d}:{m%60:02d}\"\n\n# Merge overlapping intervals.\ndef merge_intervals(intervals):\n    if not intervals:\n        return []\n    # sort intervals by start time\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        last = merged[-1]\n        if current[0] <= last[1]:\n            merged[-1] = (last[0], max(last[1], current[1]))\n        else:\n            merged.append(current)\n    return merged\n\n# Find free time intervals within the given working hours based on busy intervals.\ndef find_free_intervals(busy_intervals, work_start, work_end):\n    free = []\n    current = work_start\n    for start, end in busy_intervals:\n        if current < start:\n            free.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\n# Define working hours (minutes) and meeting duration\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nmeeting_duration = 60  # in minutes\n\n# Define the schedules for each participant (times in HH:MM format)\nschedules = {\n    \"Megan\": {\n        \"Monday\": [(\"13:00\", \"13:30\"), (\"14:00\", \"15:30\")],\n        \"Tuesday\": [(\"09:00\", \"09:30\"), (\"12:00\", \"12:30\"), (\"16:00\", \"17:00\")],\n        \"Wednesday\": [(\"09:30\", \"10:00\"), (\"10:30\", \"11:30\"), (\"12:30\", \"14:00\"), (\"16:00\", \"16:30\")],\n        \"Thursday\": [(\"13:30\", \"14:30\"), (\"15:00\", \"15:30\")]\n    },\n    \"Daniel\": {\n        \"Monday\": [(\"10:00\", \"11:30\"), (\"12:30\", \"15:00\")],\n        \"Tuesday\": [(\"09:00\", \"10:00\"), (\"10:30\", \"17:00\")],\n        \"Wednesday\": [(\"09:00\", \"10:00\"), (\"10:30\", \"11:30\"), (\"12:00\", \"17:00\")],\n        \"Thursday\": [(\"09:00\", \"12:00\"), (\"12:30\", \"14:30\"), (\"15:00\", \"15:30\"), (\"16:00\", \"17:00\")]\n    }\n}\n\n# Order of days to consider.\ndays = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\"]\n\nfound = False\n\nfor day in days:\n    # Collect busy intervals for all participants for a given day.\n    busy_intervals = []\n    for person in schedules:\n        if day in schedules[person]:\n            for interval in schedules[person][day]:\n                start, end = interval\n                busy_intervals.append((time_to_minutes(start), time_to_minutes(end)))\n    # Merge the busy intervals.\n    merged_busy = merge_intervals(busy_intervals)\n    # Find free intervals within working hours.\n    free_intervals = find_free_intervals(merged_busy, work_start, work_end)\n    # Check if any free interval can accommodate the meeting.\n    for free_start, free_end in free_intervals:\n        if free_end - free_start >= meeting_duration:\n            meeting_start = free_start\n            meeting_end = meeting_start + meeting_duration\n            print(f\"{day} {minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\")\n            found = True\n            break\n    if found:\n        break\n\nif not found:\n    print(\"No available meeting slot found.\")\n'''",
            "count": "calendar_scheduling_example_865"
        }
    ]
}