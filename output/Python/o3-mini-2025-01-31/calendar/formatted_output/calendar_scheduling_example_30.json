{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "11:30",
                "end_time": "12:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "12:30",
                "end_time": "13:00"
            },
            "has_error": false,
            "raw_model_response": "'''python\ndef time_to_minutes(t):\n    \"\"\"Converts time string \"HH:MM\" to minutes since midnight.\"\"\"\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    \"\"\"Converts minutes since midnight to time string \"HH:MM\".\"\"\"\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef invert_intervals(busy, start, end):\n    \"\"\"Given a list of busy intervals (in minutes) within [start, end],\n    returns the list of free intervals in that window.\"\"\"\n    free = []\n    current = start\n    for bstart, bend in sorted(busy):\n        if current < bstart:\n            free.append((current, bstart))\n        current = max(current, bend)\n    if current < end:\n        free.append((current, end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Intersect two lists of intervals. Each interval is a tuple (start, end).\"\"\"\n    result = []\n    i, j = 0, 0\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Intersection of intervals if they overlap:\n        start_inter = max(start1, start2)\n        end_inter = min(end1, end2)\n        if start_inter < end_inter:\n            result.append((start_inter, end_inter))\n        # Move the pointer that ends first:\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Meeting parameters\nmeeting_duration = 30  # minutes\nworkday_start = time_to_minutes(\"09:00\")\nworkday_end = time_to_minutes(\"17:00\")\nmeeting_day = \"Monday\"\n\n# Participants' busy intervals in minutes on Monday\n# Jeffrey busy: 9:30-10:00, 10:30-11:00\njeffrey_busy = [\n    (time_to_minutes(\"09:30\"), time_to_minutes(\"10:00\")),\n    (time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n]\n\n# Virginia busy: 9:00-9:30, 10:00-10:30, 14:30-15:00, 16:00-16:30\nvirginia_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n    (time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n    (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\")),\n]\n\n# Melissa busy: 9:00-11:30, 12:00-12:30, 13:00-15:00, 16:00-17:00\nmelissa_busy = [\n    (time_to_minutes(\"09:00\"), time_to_minutes(\"11:30\")),\n    (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n    (time_to_minutes(\"13:00\"), time_to_minutes(\"15:00\")),\n    (time_to_minutes(\"16:00\"), time_to_minutes(\"17:00\")),\n]\n# Additionally, Melissa prefers not to meet after 14:00.\nmelissa_latest_end = time_to_minutes(\"14:00\")\n\n# Compute free intervals for each participant within workday hours\njeffrey_free = invert_intervals(jeffrey_busy, workday_start, workday_end)\nvirginia_free = invert_intervals(virginia_busy, workday_start, workday_end)\nmelissa_free = invert_intervals(melissa_busy, workday_start, workday_end)\n\n# Intersect free intervals for Jeffrey and Virginia\ncommon_free = intersect_intervals(jeffrey_free, virginia_free)\n# Then intersect with Melissa's free intervals\ncommon_free = intersect_intervals(common_free, melissa_free)\n\n# Since Melissa prefers not to have a meeting after 14:00, we further restrict the intervals.\nadjusted_common_free = []\nfor start, end in common_free:\n    # Restrict the end time to not pass the latest acceptable end for Melissa.\n    end = min(end, melissa_latest_end)\n    if end - start >= meeting_duration:\n        adjusted_common_free.append((start, end))\n\n# Now search for an interval of meeting_duration in the adjusted common free intervals.\nmeeting_start = None\nfor start, end in adjusted_common_free:\n    if end - start >= meeting_duration:\n        meeting_start = start\n        break\n\nif meeting_start is not None:\n    meeting_end = meeting_start + meeting_duration\n    # Format the meeting time as \"HH:MM:HH:MM\" along with the day.\n    result = f\"{meeting_day} {minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    print(result)\nelse:\n    print(\"No available time slot found.\")\n'''",
            "count": "calendar_scheduling_example_30"
        }
    ]
}