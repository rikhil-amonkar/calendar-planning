{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "11:00",
                "end_time": "11:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "11:00",
                "end_time": "11:30"
            },
            "has_error": false,
            "raw_model_response": "'''python\ndef minutes(time_str):\n    \"\"\"Converts time in HH:MM format to minutes past midnight.\"\"\"\n    h, m = map(int, time_str.split(\":\"))\n    return h * 60 + m\n\ndef time_str(minutes_val):\n    \"\"\"Converts minutes past midnight to HH:MM string format.\"\"\"\n    h = minutes_val // 60\n    m = minutes_val % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef subtract_intervals(working, busy):\n    \"\"\"Subtract busy intervals from a working interval.\n       working: a tuple (start, end) in minutes.\n       busy: a list of (start, end) busy times in minutes.\n       Returns a list of free intervals (start, end).\n    \"\"\"\n    free = []\n    current_start = working[0]\n    for bstart, bend in sorted(busy):\n        if bstart > current_start:\n            free.append((current_start, min(bstart, working[1])))\n        current_start = max(current_start, bend)\n    if current_start < working[1]:\n        free.append((current_start, working[1]))\n    return free\n\ndef intersect_intervals(int1, int2):\n    \"\"\"Intersects two lists of intervals.\n       Each interval is a tuple (start,end).\n       Returns the list of overlapping intervals.\n    \"\"\"\n    res = []\n    i, j = 0, 0\n    while i < len(int1) and j < len(int2):\n        start = max(int1[i][0], int2[j][0])\n        end = min(int1[i][1], int2[j][1])\n        if start < end:\n            res.append((start, end))\n        if int1[i][1] < int2[j][1]:\n            i += 1\n        else:\n            j += 1\n    return res\n\n# Define working hours in minutes (Monday work hours: 09:00 to 17:00)\nwork_start = minutes(\"09:00\")\nwork_end = minutes(\"17:00\")\nworking_interval = (work_start, work_end)\n\n# Busy times for each participant in minutes\nschedules = {\n    \"Gregory\": [(\"09:00\", \"09:30\"), (\"11:30\", \"12:00\")],\n    \"Jonathan\": [(\"09:00\", \"09:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"13:30\"), (\"15:00\", \"16:00\"), (\"16:30\", \"17:00\")],\n    \"Barbara\": [(\"10:00\", \"10:30\"), (\"13:30\", \"14:00\")],\n    \"Jesse\": [(\"10:00\", \"11:00\"), (\"12:30\", \"14:30\")],\n    \"Alan\": [(\"09:30\", \"11:00\"), (\"11:30\", \"12:30\"), (\"13:00\", \"15:30\"), (\"16:00\", \"17:00\")],\n    \"Nicole\": [(\"09:00\", \"10:30\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:30\"), (\"14:00\", \"17:00\")],\n    \"Catherine\": [(\"09:00\", \"10:30\"), (\"12:00\", \"13:30\"), (\"15:00\", \"15:30\"), (\"16:00\", \"16:30\")]\n}\n\n# Convert schedule times to minutes\nfor person in schedules:\n    schedules[person] = [(minutes(start), minutes(end)) for start, end in schedules[person]]\n\n# Calculate free intervals for each participant within working hours\nfree_intervals = {}\nfor person, busy in schedules.items():\n    free_intervals[person] = subtract_intervals(working_interval, busy)\n\n# Intersect free intervals of all participants\n# Start with the full working hours as the initial available intervals list\ncommon_free = [working_interval]\n\nfor person in free_intervals:\n    common_free = intersect_intervals(common_free, free_intervals[person])\n\n# We need a meeting of duration 30 minutes.\nmeeting_duration = 30\nproposed_slot = None\n\nfor start, end in common_free:\n    if end - start >= meeting_duration:\n        proposed_slot = (start, start + meeting_duration)\n        break\n\nif proposed_slot:\n    start_time = time_str(proposed_slot[0])\n    end_time = time_str(proposed_slot[1])\n    # Day of week is Monday as given in the task\n    day = \"Monday\"\n    print(f\"{day} {start_time}:{end_time}\")\nelse:\n    print(\"No available slot found.\")\n'''",
            "count": "calendar_scheduling_example_473"
        }
    ]
}