{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "9:00",
                "end_time": "9:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "9:00",
                "end_time": "9:30"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import datetime, timedelta\n\n# Define meeting duration in minutes\nMEETING_DURATION = 30\n\n# Define working hours (in minutes since midnight)\nWORK_START = 9 * 60    # 9:00 in minutes\nWORK_END = 17 * 60     # 17:00 in minutes\n\n# Weekly schedule for each participant.\n# Times are expressed in minutes since midnight.\nschedules = {\n    \"Terry\": {\n        \"Monday\": [(10*60+30, 11*60), (12*60+30, 14*60), (15*60, 17*60)],\n        \"Tuesday\": [(9*60+30, 10*60), (10*60+30, 11*60), (14*60, 14*60+30), (16*60, 16*60+30)],\n        \"Wednesday\": [(9*60+30, 10*60+30), (11*60, 12*60), (13*60, 13*60+30), (15*60, 16*60), (16*60+30, 17*60)],\n        \"Thursday\": [(9*60+30, 10*60), (12*60, 12*60+30), (13*60, 14*60+30), (16*60, 16*60+30)],\n        \"Friday\": [(9*60, 11*60+30), (12*60, 12*60+30), (13*60+30, 16*60), (16*60+30, 17*60)],\n    },\n    \"Frances\": {\n        \"Monday\": [(9*60+30, 11*60), (11*60+30, 13*60), (14*60, 14*60+30), (15*60, 16*60)],\n        \"Tuesday\": [(9*60, 9*60+30), (10*60, 10*60+30), (11*60, 12*60), (13*60, 14*60+30), (15*60+30, 16*60+30)],\n        \"Wednesday\": [(9*60+30, 10*60), (10*60+30, 11*60), (11*60+30, 16*60), (16*60+30, 17*60)],\n        \"Thursday\": [(11*60, 12*60+30), (14*60+30, 17*60)],\n        \"Friday\": [(9*60+30, 10*60+30), (11*60, 12*60+30), (13*60, 16*60), (16*60+30, 17*60)],\n    }\n}\n\n# The days order.\n# Frances prefers to avoid Tuesday, so we check Monday, Wednesday, Thursday, Friday first and then Tuesday.\ndays_order = [\"Monday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Tuesday\"]\n\ndef merge_intervals(intervals):\n    \"\"\"Merge overlapping intervals.\"\"\"\n    if not intervals:\n        return []\n    intervals.sort()\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        prev = merged[-1]\n        # if the current interval overlaps with the previous one, merge them\n        if current[0] <= prev[1]:\n            merged[-1] = (prev[0], max(prev[1], current[1]))\n        else:\n            merged.append(current)\n    return merged\n\ndef find_free_slot(busy_intervals):\n    \"\"\"Given busy intervals, find the earliest free slot within working hours.\"\"\"\n    # Start with the beginning of working hours.\n    start = WORK_START\n    \n    # Check free time before first busy interval.\n    for b_start, b_end in busy_intervals:\n        if start + MEETING_DURATION <= b_start:\n            # Found free slot\n            return start, start + MEETING_DURATION\n        # Move start to the later of current start and busy end\n        start = max(start, b_end)\n    \n    # After all busy intervals, check if there's enough time before work end.\n    if start + MEETING_DURATION <= WORK_END:\n        return start, start + MEETING_DURATION\n    \n    return None\n\ndef minutes_to_HHMM(minutes):\n    hrs = minutes // 60\n    mins = minutes % 60\n    return f\"{hrs:02d}:{mins:02d}\"\n\n# Main scheduling logic:\ndef schedule_meeting():\n    for day in days_order:\n        combined_busy = []\n        # Combine busy intervals for both participants for the given day.\n        for person in schedules:\n            intervals = schedules[person].get(day, [])\n            combined_busy.extend(intervals)\n        \n        # Merge intervals for a clear picture of busy times.\n        merged_busy = merge_intervals(combined_busy)\n        \n        slot = find_free_slot(merged_busy)\n        if slot:\n            start, end = slot\n            start_str = minutes_to_HHMM(start)\n            end_str = minutes_to_HHMM(end)\n            return day, f\"{{{start_str}:{end_str}}}\"\n    \n    return None\n\nresult = schedule_meeting()\nif result:\n    day, time_range = result\n    print(day, time_range)\nelse:\n    print(\"No valid meeting slot found within the working hours.\")\n\nif __name__ == \"__main__\":\n    pass\n'''",
            "count": "calendar_scheduling_example_935"
        }
    ]
}