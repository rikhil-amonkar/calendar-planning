{
    "0shot": [
        {
            "final_program_time": {
                "day": "Wednesday",
                "start_time": "14:30",
                "end_time": "15:30"
            },
            "expected_time": {
                "day": "Wednesday",
                "start_time": "14:30",
                "end_time": "15:30"
            },
            "has_error": false,
            "raw_model_response": "'''python\ndef to_minutes(time_str):\n    # Convert \"HH:MM\" to minutes since midnight.\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours * 60 + minutes\n\ndef to_time_str(minutes):\n    # Convert minutes since midnight back to \"HH:MM\"\n    h = minutes // 60\n    m = minutes % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef get_free_slots(busy_slots, work_start, work_end):\n    # busy_slots is a list of tuples (start, end) in minutes, assumed sorted and non-overlapping.\n    free = []\n    current = work_start\n    for start, end in busy_slots:\n        if current < start:\n            free.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    # Given two lists of intervals, returns list of intersections\n    i, j = 0, 0\n    intersection = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        start_int = max(start1, start2)\n        end_int = min(end1, end2)\n        if start_int < end_int:\n            intersection.append((start_int, end_int))\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\n# Define working hours in minutes (9:00 to 17:00)\nwork_start = to_minutes(\"09:00\")\nwork_end = to_minutes(\"17:00\")\nmeeting_duration = 60  # meeting length in minutes\n\n# Busy schedules in minutes for each participant on each day.\n# Format: day: list of (start, end) times in minutes.\nnatalie_busy = {\n    \"Monday\": [(to_minutes(\"09:00\"), to_minutes(\"09:30\")),\n               (to_minutes(\"10:00\"), to_minutes(\"12:00\")),\n               (to_minutes(\"12:30\"), to_minutes(\"13:00\")),\n               (to_minutes(\"14:00\"), to_minutes(\"14:30\")),\n               (to_minutes(\"15:00\"), to_minutes(\"16:30\"))],\n    \"Tuesday\": [(to_minutes(\"09:00\"), to_minutes(\"09:30\")),\n                (to_minutes(\"10:00\"), to_minutes(\"10:30\")),\n                (to_minutes(\"12:30\"), to_minutes(\"14:00\")),\n                (to_minutes(\"16:00\"), to_minutes(\"17:00\"))],\n    \"Wednesday\": [(to_minutes(\"11:00\"), to_minutes(\"11:30\")),\n                  (to_minutes(\"16:00\"), to_minutes(\"16:30\"))],\n    \"Thursday\": [(to_minutes(\"10:00\"), to_minutes(\"11:00\")),\n                 (to_minutes(\"11:30\"), to_minutes(\"15:00\")),\n                 (to_minutes(\"15:30\"), to_minutes(\"16:00\")),\n                 (to_minutes(\"16:30\"), to_minutes(\"17:00\"))]\n}\n\nwilliam_busy = {\n    \"Monday\": [(to_minutes(\"09:30\"), to_minutes(\"11:00\")),\n               (to_minutes(\"11:30\"), to_minutes(\"17:00\"))],\n    \"Tuesday\": [(to_minutes(\"09:00\"), to_minutes(\"13:00\")),\n                (to_minutes(\"13:30\"), to_minutes(\"16:00\"))],\n    \"Wednesday\": [(to_minutes(\"09:00\"), to_minutes(\"12:30\")),\n                  (to_minutes(\"13:00\"), to_minutes(\"14:30\")),\n                  (to_minutes(\"15:30\"), to_minutes(\"16:00\")),\n                  (to_minutes(\"16:30\"), to_minutes(\"17:00\"))],\n    \"Thursday\": [(to_minutes(\"09:00\"), to_minutes(\"10:30\")),\n                 (to_minutes(\"11:00\"), to_minutes(\"11:30\")),\n                 (to_minutes(\"12:00\"), to_minutes(\"12:30\")),\n                 (to_minutes(\"13:00\"), to_minutes(\"14:00\")),\n                 (to_minutes(\"15:00\"), to_minutes(\"17:00\"))]\n}\n\n# Ensure each busy list is sorted (they should be already by the given schedule)\nfor day in natalie_busy:\n    natalie_busy[day].sort()\nfor day in william_busy:\n    william_busy[day].sort()\n\n# Try to find a valid meeting slot day by day.\nfor day in [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\"]:\n    natalie_free = get_free_slots(natalie_busy.get(day, []), work_start, work_end)\n    william_free = get_free_slots(william_busy.get(day, []), work_start, work_end)\n    \n    common_free = intersect_intervals(natalie_free, william_free)\n    \n    # Look for an interval with at least the meeting duration\n    for start, end in common_free:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = start + meeting_duration\n            print(f\"{day} {to_time_str(meeting_start)}:{to_time_str(meeting_end)}\")\n            exit(0)\n\nprint(\"No meeting slot available.\")\n'''",
            "count": "calendar_scheduling_example_875"
        }
    ]
}