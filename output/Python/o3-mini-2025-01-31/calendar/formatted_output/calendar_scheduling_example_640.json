{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "10:00",
                "end_time": "10:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "10:00",
                "end_time": "10:30"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import datetime, timedelta\n\ndef time_to_minutes(time_str):\n    # time_str format: \"HH:MM\"\n    h, m = map(int, time_str.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(minutes):\n    h = minutes // 60\n    m = minutes % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef subtract_busy(free_interval, busy_interval):\n    # free_interval and busy_interval are tuples (start, end) in minutes.\n    free_start, free_end = free_interval\n    busy_start, busy_end = busy_interval\n    result = []\n    # Case when the busy interval doesn't overlap the free interval:\n    if busy_end <= free_start or busy_start >= free_end:\n        return [free_interval]\n    # If there's a free block before the busy time:\n    if busy_start > free_start:\n        result.append((free_start, busy_start))\n    # If there's a free block after the busy time:\n    if busy_end < free_end:\n        result.append((busy_end, free_end))\n    return result\n\ndef subtract_busy_intervals(working_interval, busy_intervals):\n    free_intervals = [working_interval]\n    for busy in busy_intervals:\n        new_free = []\n        for interval in free_intervals:\n            new_free.extend(subtract_busy(interval, busy))\n        free_intervals = new_free\n    # sort intervals by start time\n    free_intervals.sort(key=lambda x: x[0])\n    return free_intervals\n\ndef intersect_intervals(interval1, interval2):\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start < end:\n        return (start, end)\n    return None\n\ndef intersect_free_intervals(free1, free2):\n    result = []\n    i, j = 0, 0\n    while i < len(free1) and j < len(free2):\n        inter = intersect_intervals(free1[i], free2[j])\n        if inter:\n            result.append(inter)\n        # Move the pointer with the earlier ending interval\n        if free1[i][1] < free2[j][1]:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef find_slot_in_intervals(intervals, duration):\n    for start, end in intervals:\n        if end - start >= duration:\n            return start, start + duration\n    return None\n\n# Meeting parameters\nmeeting_duration = 30  # minutes\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nworking_interval = (work_start, work_end)\n\n# Schedules for participants (each busy interval is a tuple (start, end) in minutes)\n# Provided times are within work hours.\nschedules = {\n    \"Monday\": {\n        \"Bobby\": [(\"14:30\", \"15:00\")],\n        \"Michael\": [(\"09:00\", \"10:00\"), \n                    (\"10:30\", \"13:30\"), \n                    (\"14:00\", \"15:00\"), \n                    (\"15:30\", \"17:00\")]\n    },\n    \"Tuesday\": {\n        \"Bobby\": [(\"09:00\", \"11:30\"), \n                  (\"12:00\", \"12:30\"), \n                  (\"13:00\", \"15:00\"), \n                  (\"15:30\", \"17:00\")],\n        \"Michael\": [(\"09:00\", \"10:30\"), \n                    (\"11:00\", \"11:30\"), \n                    (\"12:00\", \"14:00\"), \n                    (\"15:00\", \"16:00\"), \n                    (\"16:30\", \"17:00\")]\n    }\n}\n\ndef convert_schedule_times(schedule):\n    # Convert schedule time strings to minutes tuples\n    converted = []\n    for start, end in schedule:\n        converted.append((time_to_minutes(start), time_to_minutes(end)))\n    return converted\n\n# Calculate free intervals for each person per day\navailable_meeting = None\nmeeting_day = None\n\nfor day in [\"Monday\", \"Tuesday\"]:\n    # Get free intervals for each participant on this day\n    day_schedule = schedules[day]\n    free_intervals = {}\n    for person, busy_times in day_schedule.items():\n        busy_times_min = convert_schedule_times(busy_times)\n        free_intervals[person] = subtract_busy_intervals(working_interval, busy_times_min)\n    # Intersection of free intervals between Bobby and Michael\n    common_free = intersect_free_intervals(free_intervals[\"Bobby\"], free_intervals[\"Michael\"])\n    # Look for earliest free slot with required duration\n    slot = find_slot_in_intervals(common_free, meeting_duration)\n    if slot:\n        available_meeting = slot\n        meeting_day = day\n        break\n\nif available_meeting:\n    start_time, end_time = available_meeting\n    formatted_start = minutes_to_time(start_time)\n    formatted_end = minutes_to_time(end_time)\n    # Output in the format \"HH:MM:HH:MM\" and include the day of the week.\n    print(f\"{formatted_start}:{formatted_end} {meeting_day}\")\nelse:\n    print(\"No available meeting slot found.\")\n'''",
            "count": "calendar_scheduling_example_640"
        }
    ]
}