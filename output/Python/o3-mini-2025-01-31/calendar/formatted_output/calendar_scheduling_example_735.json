{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "9:30",
                "end_time": "10:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "9:30",
                "end_time": "10:00"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import datetime, timedelta\n\n# Define working hours in minutes (9:00 -> 540, 17:00 -> 1020)\nWORK_START = 9 * 60      # 540\nWORK_END = 17 * 60       # 1020\nMEETING_DURATION = 30    # minutes\n\n# Define the schedules in minutes past midnight for each day.\n# Each participant schedule is a dictionary where key is the day and value is a list of (start, end) busy intervals.\n# Times are converted to minutes, e.g., 10:30 -> 10*60+30 = 630.\ndef time_to_minutes(time_str):\n    \"\"\"Convert HH:MM string to minutes since midnight.\"\"\"\n    t = datetime.strptime(time_str, \"%H:%M\")\n    return t.hour * 60 + t.minute\n\nschedules = {\n    \"Ronald\": {\n        \"Monday\": [(time_to_minutes(\"10:30\"), time_to_minutes(\"11:00\")),\n                   (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n                   (time_to_minutes(\"15:30\"), time_to_minutes(\"16:00\"))],\n        \"Tuesday\": [(time_to_minutes(\"9:00\"), time_to_minutes(\"9:30\")),\n                    (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n                    (time_to_minutes(\"15:30\"), time_to_minutes(\"16:30\"))],\n        \"Wednesday\": [(time_to_minutes(\"9:30\"), time_to_minutes(\"10:30\")),\n                      (time_to_minutes(\"11:00\"), time_to_minutes(\"12:00\")),\n                      (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\")),\n                      (time_to_minutes(\"13:30\"), time_to_minutes(\"14:00\")),\n                      (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))]\n    },\n    \"Amber\": {\n        \"Monday\": [(time_to_minutes(\"9:00\"), time_to_minutes(\"9:30\")),\n                   (time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n                   (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n                   (time_to_minutes(\"12:30\"), time_to_minutes(\"14:00\")),\n                   (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\")),\n                   (time_to_minutes(\"15:30\"), time_to_minutes(\"17:00\"))],\n        \"Tuesday\": [(time_to_minutes(\"9:00\"), time_to_minutes(\"9:30\")),\n                    (time_to_minutes(\"10:00\"), time_to_minutes(\"11:30\")),\n                    (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n                    (time_to_minutes(\"13:30\"), time_to_minutes(\"15:30\")),\n                    (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))],\n        \"Wednesday\": [(time_to_minutes(\"9:00\"), time_to_minutes(\"9:30\")),\n                      (time_to_minutes(\"10:00\"), time_to_minutes(\"10:30\")),\n                      (time_to_minutes(\"11:00\"), time_to_minutes(\"13:30\")),\n                      (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\"))]\n    }\n}\n\n# List of days in order.\ndays = [\"Monday\", \"Tuesday\", \"Wednesday\"]\n\ndef merge_intervals(intervals):\n    \"\"\"Merge overlapping intervals.\"\"\"\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        last = merged[-1]\n        if current[0] <= last[1]:\n            merged[-1] = (last[0], max(last[1], current[1]))\n        else:\n            merged.append(current)\n    return merged\n\ndef find_free_slot(merged_intervals):\n    \"\"\"Find the earliest free slot of meeting duration in working hours given merged busy intervals.\"\"\"\n    # Check gap from WORK_START to first busy interval start\n    prev_end = WORK_START\n    for interval in merged_intervals:\n        start, end = interval\n        if start - prev_end >= MEETING_DURATION:\n            return prev_end, prev_end + MEETING_DURATION\n        prev_end = max(prev_end, end)\n    # Check gap after the last busy interval until WORK_END\n    if WORK_END - prev_end >= MEETING_DURATION:\n        return prev_end, prev_end + MEETING_DURATION\n    return None\n\ndef minutes_to_time(minutes):\n    \"\"\"Convert minutes since midnight to HH:MM string.\"\"\"\n    hour = minutes // 60\n    minute = minutes % 60\n    return f\"{hour:02d}:{minute:02d}\"\n\ndef schedule_meeting():\n    for day in days:\n        # Gather all busy intervals for this day across participants\n        busy = []\n        for person in schedules:\n            busy.extend(schedules[person].get(day, []))\n        # Merge overlapping busy intervals\n        merged_busy = merge_intervals(busy)\n        # Find an available free slot on this day\n        slot = find_free_slot(merged_busy)\n        if slot:\n            start, end = slot\n            start_time = minutes_to_time(start)\n            end_time = minutes_to_time(end)\n            print(f\"{day} {start_time}:{end_time}\")\n            return\n    print(\"No available meeting slot found.\")\n\nif __name__ == \"__main__\":\n    schedule_meeting() \n'''",
            "count": "calendar_scheduling_example_735"
        }
    ]
}