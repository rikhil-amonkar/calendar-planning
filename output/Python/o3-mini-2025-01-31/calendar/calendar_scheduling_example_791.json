{
    "0shot": [
        {
            "final_program_time": {
                "day": "Wednesday",
                "start_time": "11:30",
                "end_time": "12:00"
            },
            "expected_time": {
                "day": "Wednesday",
                "start_time": "11:30",
                "end_time": "12:00"
            },
            "has_error": false,
            "raw_model_response": "'''python\ndef time_to_minutes(t_str):\n    # Convert HH:MM string to minutes from midnight\n    h, m = map(int, t_str.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    # Convert minutes from midnight to HH:MM string\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef get_free_intervals(work_start, work_end, busy_intervals):\n    # busy_intervals: list of tuples (start, end) in minutes\n    busy_intervals = sorted(busy_intervals, key=lambda x: x[0])\n    free_intervals = []\n    current = work_start\n    for b_start, b_end in busy_intervals:\n        if b_start > current:\n            free_intervals.append((current, b_start))\n        current = max(current, b_end)\n    if current < work_end:\n        free_intervals.append((current, work_end))\n    return free_intervals\n\ndef intersect_intervals(list1, list2):\n    # Compute intersection of two lists of intervals.\n    result = []\n    i, j = 0, 0\n    while i < len(list1) and j < len(list2):\n        start1, end1 = list1[i]\n        start2, end2 = list2[j]\n        inter_start = max(start1, start2)\n        inter_end = min(end1, end2)\n        if inter_start < inter_end:\n            result.append((inter_start, inter_end))\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Define work hours in minutes (9:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nmeeting_duration = 30  # in minutes\n\n# Busy schedules for each participant (in minutes)\n# Nicole's busy intervals by day\nbusy_nicole = {\n    \"Monday\": [(time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n               (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n               (time_to_minutes(\"14:30\"), time_to_minutes(\"15:30\"))],\n    \"Tuesday\": [(time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n                (time_to_minutes(\"11:30\"), time_to_minutes(\"13:30\")),\n                (time_to_minutes(\"14:30\"), time_to_minutes(\"15:30\"))],\n    \"Wednesday\": [(time_to_minutes(\"10:00\"), time_to_minutes(\"11:00\")),\n                  (time_to_minutes(\"12:30\"), time_to_minutes(\"15:00\")),\n                  (time_to_minutes(\"16:00\"), time_to_minutes(\"17:00\"))]\n}\n\n# Ruth's busy intervals by day\nbusy_ruth = {\n    \"Monday\": [(time_to_minutes(\"09:00\"), time_to_minutes(\"17:00\"))],\n    \"Tuesday\": [(time_to_minutes(\"09:00\"), time_to_minutes(\"17:00\"))],\n    \"Wednesday\": [(time_to_minutes(\"09:00\"), time_to_minutes(\"10:30\")),\n                  (time_to_minutes(\"11:00\"), time_to_minutes(\"11:30\")),\n                  (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n                  (time_to_minutes(\"13:30\"), time_to_minutes(\"15:30\")),\n                  (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))]\n}\n\n# Additional constraint:\n# Ruth does not want to meet on Wednesday after 13:30, so restrict any meeting on Wednesday to end by 13:30.\n# We can enforce this by adding a \"busy\" block from 13:30 to work_end for Ruth on Wednesday.\nadditional_ruth = {\n    \"Wednesday\": [(time_to_minutes(\"13:30\"), work_end)]\n}\n\n# Merge Ruth's busy intervals with additional constraint on Wednesday\nfor day in additional_ruth:\n    busy_ruth[day].extend(additional_ruth[day])\n    busy_ruth[day] = sorted(busy_ruth[day], key=lambda x: x[0])\n\n# Days to consider\ndays = [\"Monday\", \"Tuesday\", \"Wednesday\"]\n\nscheduled_day = None\nscheduled_start = None\nscheduled_end = None\n\nfor day in days:\n    # Get free intervals for each participant for the day.\n    free_nicole = get_free_intervals(work_start, work_end, busy_nicole.get(day, []))\n    free_ruth = get_free_intervals(work_start, work_end, busy_ruth.get(day, []))\n    # Get common free intervals\n    common_free = intersect_intervals(free_nicole, free_ruth)\n    # Check if any common interval can accommodate the meeting_duration.\n    for interval in common_free:\n        start, end = interval\n        if end - start >= meeting_duration:\n            scheduled_day = day\n            scheduled_start = start\n            scheduled_end = start + meeting_duration\n            break\n    if scheduled_day:\n        break\n\nif scheduled_day:\n    meeting_time = f\"{minutes_to_time(scheduled_start)}:{minutes_to_time(scheduled_end)}\"\n    print(f\"{scheduled_day} {meeting_time}\")\nelse:\n    print(\"No suitable meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_791"
        }
    ]
}