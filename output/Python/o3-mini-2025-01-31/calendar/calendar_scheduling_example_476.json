{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "13:30",
                "end_time": "14:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "13:30",
                "end_time": "14:00"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import datetime, timedelta\n\n# Helper function to convert minutes since midnight to \"HH:MM\" string format.\ndef minutes_to_str(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Check if two time intervals [start1, end1) and [start2, end2) overlap.\ndef intervals_overlap(start1, end1, start2, end2):\n    return start1 < end2 and start2 < end1\n\n# Function to check if a meeting starting at 'start' (in minutes) for 'duration' minutes is free for a participant's schedule.\ndef is_free(busy_intervals, meeting_start, meeting_end):\n    for interval in busy_intervals:\n        busy_start, busy_end = interval\n        # If the meeting overlaps with a busy interval, then it's not free.\n        if intervals_overlap(meeting_start, meeting_end, busy_start, busy_end):\n            return False\n    return True\n\n# Define the meeting duration in minutes\nmeeting_duration = 30\n\n# Define workday boundaries (in minutes since midnight) for Monday: 9:00 (540) to 17:00 (1020)\nworkday_start = 9 * 60  # 540\nworkday_end   = 17 * 60 # 1020\n\n# Participant schedules represented as lists of busy intervals (start, end) in minutes\n# Daniel: free all day\ndaniel_busy = []\n\n# Kathleen: busy during 14:30 to 15:30\nkathleen_busy = [(14 * 60 + 30, 15 * 60 + 30)]  # (870,930)\n\n# Carolyn: busy during 12:00 to 12:30 and 13:00 to 13:30\ncarolyn_busy = [(12 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30)]  # (720,750) and (780,810)\n\n# Roger: free all day, but prefers no meeting before 12:30.\nroger_busy = []  # No busy intervals; we'll enforce preference separately.\nroger_preference_start = 12 * 60 + 30  # 750 minutes\n\n# Cheryl: busy during 9:00-9:30, 10:00-11:30, 12:30-13:30, and 14:00-17:00.\ncheryl_busy = [(9 * 60, 9 * 60 + 30), (10 * 60, 11 * 60 + 30),\n                (12 * 60 + 30, 13 * 60 + 30), (14 * 60, 17 * 60)]  # (540,570), (600,690), (750,810), (840,1020)\n\n# Virginia: busy during 9:30-11:30, 12:00-12:30, 13:00-13:30, 14:30-15:30, and 16:00-17:00.\nvirginia_busy = [(9 * 60 + 30, 11 * 60 + 30), (12 * 60, 12 * 60 + 30),\n                   (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60 + 30), (16 * 60, 17 * 60)]\n# (570,690), (720,750), (780,810), (870,930), (960,1020)\n\n# Angela: busy during 9:30-10:00, 10:30-11:30, 12:00-12:30, 13:00-13:30, and 14:00-16:30.\nangela_busy = [(9 * 60 + 30, 10 * 60), (10 * 60 + 30, 11 * 60 + 30),\n                (12 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60, 16 * 60 + 30)]\n# (570,600), (630,690), (720,750), (780,810), (840,990)\n\n# Consolidate all busy schedules in a list for iteration.\nschedules = [\n    daniel_busy,\n    kathleen_busy,\n    carolyn_busy,\n    roger_busy,   # Roger's busy is empty; his preference is handled separately.\n    cheryl_busy,\n    virginia_busy,\n    angela_busy\n]\n\n# The meeting must be scheduled on Monday.\nday_of_week = \"Monday\"\n\n# We'll start checking candidate times from the maximum of workday_start and Roger's preferred start.\ncandidate_start = max(workday_start, roger_preference_start)\nfound = False\nmeeting_time = None\n\nwhile candidate_start + meeting_duration <= workday_end:\n    candidate_end = candidate_start + meeting_duration\n    available_for_all = True\n    \n    # Check every participant's schedule.\n    for busy in schedules:\n        if not is_free(busy, candidate_start, candidate_end):\n            available_for_all = False\n            break\n\n    if available_for_all:\n        # We found a valid slot.\n        meeting_time = (candidate_start, candidate_end)\n        found = True\n        break\n    \n    candidate_start += 1  # check next minute\n\nif found:\n    start_str = minutes_to_str(meeting_time[0])\n    end_str = minutes_to_str(meeting_time[1])\n    print(f\"{day_of_week} {start_str}:{end_str}\")\nelse:\n    print(\"No available meeting slot found.\")\n'''",
            "count": "calendar_scheduling_example_476"
        }
    ]
}