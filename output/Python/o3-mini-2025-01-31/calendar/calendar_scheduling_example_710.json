{
    "0shot": [
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "9:00",
                "end_time": "9:30"
            },
            "expected_time": {
                "day": "Tuesday",
                "start_time": "9:00",
                "end_time": "9:30"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import timedelta, datetime\n\n# Define working hours: 9 am to 5 pm in minutes since midnight\nWORK_START = 9 * 60    # 540 minutes (09:00)\nWORK_END = 17 * 60     # 1020 minutes (17:00)\nMEETING_DURATION = 30  # in minutes\n\n# Define calendars as dictionaries: each key is a day and value is a list of busy intervals (in minutes)\n# Busy intervals are represented as tuples (start, end) in minutes from midnight.\n# Days considered: Monday, Tuesday, Wednesday\ncalendars = {\n    \"Cheryl\": {\n        \"Monday\": [(9 * 60, 9 * 60 + 30),    # 09:00-09:30\n                   (11 * 60 + 30, 13 * 60),  # 11:30-13:00\n                   (15 * 60 + 30, 16 * 60)], # 15:30-16:00\n        \"Tuesday\": [(15 * 60, 15 * 60 + 30)],  # 15:00-15:30\n        # Cheryl cannot meet on Wednesday\n    },\n    \"Kyle\": {\n        \"Monday\": [(9 * 60, 17 * 60)],         # 09:00-17:00 (entire day busy)\n        \"Tuesday\": [(9 * 60 + 30, 17 * 60)],     # 09:30-17:00\n        \"Wednesday\": [(9 * 60, 9 * 60 + 30),     # 09:00-09:30\n                      (10 * 60, 13 * 60),         # 10:00-13:00\n                      (13 * 60 + 30, 14 * 60),    # 13:30-14:00\n                      (14 * 60 + 30, 17 * 60)]    # 14:30-17:00\n    }\n}\n\n# Allowed days for the meeting\nallowed_days = [\"Monday\", \"Tuesday\", \"Wednesday\"]\n\ndef get_free_intervals(busy_intervals, work_start=WORK_START, work_end=WORK_END):\n    \"\"\"Given a list of busy intervals, return the list of free intervals within work hours.\"\"\"\n    free_intervals = []\n    # Sort intervals by start time\n    busy_intervals.sort(key=lambda x: x[0])\n    current_start = work_start\n\n    for busy in busy_intervals:\n        busy_start, busy_end = busy\n        if busy_start > current_start:\n            free_intervals.append((current_start, busy_start))\n        current_start = max(current_start, busy_end)\n    # Check if there's free time after the last busy interval until end of work day.\n    if current_start < work_end:\n        free_intervals.append((current_start, work_end))\n    return free_intervals\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Given two lists of intervals, return the intersection intervals.\"\"\"\n    intersection = []\n    i, j = 0, 0\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # find the overlap between intervals\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap < end_overlap:\n            intersection.append((start_overlap, end_overlap))\n        # Move the pointer for the interval which ends first\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\ndef minutes_to_time_str(minutes):\n    \"\"\"Convert minutes since midnight to HH:MM format with zero padded hours/minutes.\"\"\"\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\ndef schedule_meeting():\n    # We have two participants to schedule: Cheryl and Kyle.\n    participants = [\"Cheryl\", \"Kyle\"]\n    \n    # Try each allowed day, taking into account individual constraints\n    for day in allowed_days:\n        # Skip if Cheryl can't meet on Wednesday.\n        if day == \"Wednesday\" and \"Cheryl\" in calendars and day not in calendars[\"Cheryl\"]:\n            continue  # Cheryl has no available data for Wednesday due to constraint\n        \n        # Build free intervals for each participant for the given day.\n        participant_free = []\n        for person in participants:\n            # Get busy intervals within working hours; if no entry for a day, assume free all day.\n            busy = calendars.get(person, {}).get(day, [])\n            free = get_free_intervals(busy)\n            participant_free.append(free)\n        \n        # Compute the common free intervals across all participants.\n        common_intervals = participant_free[0]\n        for i in range(1, len(participant_free)):\n            common_intervals = intersect_intervals(common_intervals, participant_free[i])\n        \n        # Check if any common interval can accommodate the meeting duration.\n        for interval in common_intervals:\n            start, end = interval\n            if end - start >= MEETING_DURATION:\n                meeting_start = start\n                meeting_end = start + MEETING_DURATION\n                # Format the meeting time in HH:MM:HH:MM and output day.\n                meeting_time_str = f\"{minutes_to_time_str(meeting_start)}:{minutes_to_time_str(meeting_end)}\"\n                print(f\"Day: {day}, Time: {meeting_time_str}\")\n                return\n\n# Run scheduling function\nschedule_meeting()\n'''",
            "count": "calendar_scheduling_example_710"
        }
    ]
}