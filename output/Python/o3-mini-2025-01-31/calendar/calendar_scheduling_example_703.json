{
    "0shot": [
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "9:30",
                "end_time": "10:30"
            },
            "expected_time": {
                "day": "Tuesday",
                "start_time": "9:30",
                "end_time": "10:30"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import time, timedelta, datetime\n\n# Helper function to convert HH:MM string to minutes since midnight\ndef time_to_minutes(t):\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\n# Helper function to convert minutes since midnight to HH:MM string\ndef minutes_to_time(m):\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\n# Define work hours in minutes\nwork_start = time_to_minutes(\"09:00\")\nwork_end   = time_to_minutes(\"17:00\")\n\n# Meeting duration in minutes (60 minutes)\nmeeting_duration = 60\n\n# Define the weekly schedule for participants as a dictionary.\n# Each key is a day and the value is another dict with participant names mapping to a list of (start, end) meeting intervals.\nschedules = {\n    \"Monday\": {\n        \"Stephanie\": [(\"09:30\", \"10:00\"), (\"10:30\", \"11:00\"), (\"11:30\", \"12:00\"), (\"14:00\", \"14:30\")],\n        \"Betty\":     [(\"09:00\", \"10:00\"), (\"11:00\", \"11:30\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:00\")]\n    },\n    \"Tuesday\": {\n        \"Stephanie\": [(\"12:00\", \"13:00\")],\n        \"Betty\":     [(\"09:00\", \"09:30\"), (\"11:30\", \"12:00\"), (\"12:30\", \"14:30\"), (\"15:30\", \"16:00\")]\n    },\n    \"Wednesday\": {\n        \"Stephanie\": [(\"09:00\", \"10:00\"), (\"13:00\", \"14:00\")],\n        \"Betty\":     [(\"10:00\", \"11:30\"), (\"12:00\", \"14:00\"), (\"14:30\", \"17:00\")]\n    }\n}\n\n# Additional participant constraints:\n# Stephanie prefers to avoid Monday meetings if possible.\n# Betty cannot meet on Tuesday after 12:30.\n# We will try to schedule the meeting on a day considering these preferences.\n\n# Function to get free intervals for a participant on a given day.\ndef get_free_intervals(meetings):\n    # Convert meeting times to minutes and sort\n    busy = []\n    for start, end in meetings:\n        busy.append((time_to_minutes(start), time_to_minutes(end)))\n    busy.sort()\n    \n    free_intervals = []\n    # begin with the work start\n    current = work_start\n    for s, e in busy:\n        if current < s:\n            free_intervals.append((current, s))\n        current = max(current, e)\n    if current < work_end:\n        free_intervals.append((current, work_end))\n    return free_intervals\n\n# Function to compute the intersection of two lists of intervals.\ndef intersect_intervals(intervals1, intervals2):\n    i, j = 0, 0\n    intersection = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        start_int = max(start1, start2)\n        end_int = min(end1, end2)\n        if start_int + meeting_duration <= end_int:\n            intersection.append((start_int, end_int))\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\n# Try days in order: Tuesday and Wednesday are preferred because Stephanie wants to avoid Monday if possible.\npreferred_days = [\"Tuesday\", \"Wednesday\", \"Monday\"]\n\nmeeting_day = None\nmeeting_start = None\nmeeting_end = None\n\nfor day in preferred_days:\n    # Check additional constraint specific for Tuesday: Betty cannot meet after 12:30 on Tuesday.\n    # This means the meeting must finish by 12:30. We'll adjust Tuesday's work_end if needed.\n    day_work_end = work_end\n    if day == \"Tuesday\":\n        day_work_end = min(day_work_end, time_to_minutes(\"12:30\"))\n    \n    # For each participant, get free intervals but restricted to the day's work interval (possibly modified for Tuesday).\n    meeting_possible = True\n    common_free = [(work_start, day_work_end)]\n    \n    for participant in schedules[day]:\n        free = get_free_intervals(schedules[day][participant])\n        # If day is Tuesday, restrict each free interval to end at day_work_end.\n        if day == \"Tuesday\":\n            free = [(max(start, work_start), min(end, day_work_end)) for start, end in free if start < day_work_end]\n        # Update common_free with the intersection\n        common_free = intersect_intervals(common_free, free)\n        if not common_free:\n            meeting_possible = False\n            break\n\n    if meeting_possible:\n        # Now, search in common_free for an interval that can fit the meeting_duration.\n        for start, end in common_free:\n            if start + meeting_duration <= end:\n                meeting_day = day\n                meeting_start = start\n                meeting_end = start + meeting_duration\n                break\n    if meeting_day:\n        break\n\nif meeting_day and meeting_start is not None:\n    start_str = minutes_to_time(meeting_start)\n    end_str = minutes_to_time(meeting_end)\n    print(f\"{meeting_day} {start_str}:{end_str}\")\nelse:\n    print(\"No available meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_703"
        }
    ]
}