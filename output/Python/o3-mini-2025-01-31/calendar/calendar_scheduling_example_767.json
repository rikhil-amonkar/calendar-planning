{
    "0shot": [
        {
            "final_program_time": {
                "day": "Wednesday",
                "start_time": "15:30",
                "end_time": "16:30"
            },
            "expected_time": {
                "day": "Wednesday",
                "start_time": "15:30",
                "end_time": "16:30"
            },
            "has_error": false,
            "raw_model_response": "'''python\ndef time_to_minutes(time_str):\n    # Converts \"HH:MM\" to minutes since midnight\n    hours, minutes = map(int, time_str.split(':'))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    # Converts minutes since midnight to \"HH:MM\" formatted time string\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\ndef subtract_busy_times(free_intervals, busy_intervals):\n    result = []\n    for free_start, free_end in free_intervals:\n        current_start = free_start\n        for busy_start, busy_end in busy_intervals:\n            # If there is no intersection, continue.\n            if busy_end <= current_start or busy_start >= free_end:\n                continue\n            # If there is an overlap, add free time before the busy block if exists\n            if busy_start > current_start:\n                result.append((current_start, busy_start))\n            current_start = max(current_start, busy_end)\n        # Add remaining part of free interval if any\n        if current_start < free_end:\n            result.append((current_start, free_end))\n    return result\n\ndef intersect_intervals(intervals_a, intervals_b):\n    intersection = []\n    i, j = 0, 0\n    while i < len(intervals_a) and j < len(intervals_b):\n        start_a, end_a = intervals_a[i]\n        start_b, end_b = intervals_b[j]\n        # Find overlapping interval\n        start_overlap = max(start_a, start_b)\n        end_overlap = min(end_a, end_b)\n        if start_overlap < end_overlap:\n            intersection.append((start_overlap, end_overlap))\n        # Move the pointer for the interval that ends first\n        if end_a < end_b:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\ndef find_meeting_time(meeting_duration):\n    # Working hours: 09:00 to 17:00 in minutes from midnight\n    work_start = time_to_minutes(\"09:00\")\n    work_end = time_to_minutes(\"17:00\")\n    working_interval = [(work_start, work_end)]\n    \n    # Define busy intervals for each participant per day in minutes.\n    # Format: { \"Day\": [(start, end), ...] }\n    martha_busy = {\n        \"Monday\": [(time_to_minutes(\"16:00\"), time_to_minutes(\"17:00\"))],\n        \"Tuesday\": [(time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\"))],\n        \"Wednesday\": [(time_to_minutes(\"10:00\"), time_to_minutes(\"11:00\")),\n                      (time_to_minutes(\"14:00\"), time_to_minutes(\"14:30\"))]\n    }\n    \n    beverly_busy = {\n        \"Monday\": [(time_to_minutes(\"09:00\"), time_to_minutes(\"13:30\")),\n                   (time_to_minutes(\"14:00\"), time_to_minutes(\"17:00\"))],\n        \"Tuesday\": [(time_to_minutes(\"09:00\"), time_to_minutes(\"17:00\"))],\n        \"Wednesday\": [(time_to_minutes(\"09:30\"), time_to_minutes(\"15:30\")),\n                      (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))]\n    }\n    \n    # Try days in the order: Monday, Tuesday, Wednesday\n    for day in [\"Monday\", \"Tuesday\", \"Wednesday\"]:\n        # Compute free intervals by subtracting busy times from working hours\n        martha_free = subtract_busy_times(working_interval, martha_busy.get(day, []))\n        beverly_free = subtract_busy_times(working_interval, beverly_busy.get(day, []))\n        \n        # Find intersection of free times between Martha and Beverly\n        common_free = intersect_intervals(martha_free, beverly_free)\n        \n        # Check each intersected interval for a slot that can fit the meeting_duration\n        for start, end in common_free:\n            if end - start >= meeting_duration:\n                meeting_start = start\n                meeting_end = start + meeting_duration\n                # Output in HH:MM:HH:MM format along with the day\n                print(f\"{day} {minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\")\n                return\n\n# Meeting duration 60 minutes\nfind_meeting_time(60)\n'''",
            "count": "calendar_scheduling_example_767"
        }
    ]
}