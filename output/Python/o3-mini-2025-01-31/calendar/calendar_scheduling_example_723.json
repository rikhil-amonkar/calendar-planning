{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "12:00",
                "end_time": "12:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "12:00",
                "end_time": "12:30"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import timedelta, datetime\n\n# Utility functions to convert between \"HH:MM\" and minutes since midnight.\ndef time_to_minutes(t):\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(m):\n    h = m // 60\n    m = m % 60\n    return f\"{h:02d}:{m:02d}\"\n\n# Function to compute free intervals given busy intervals and working range.\ndef get_free_intervals(busy, work_start, work_end):\n    free = []\n    current = work_start\n    # Sort busy intervals by start time.\n    for start, end in sorted(busy):\n        if start > current:\n            free.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\n# Function to intersect two lists of intervals.\ndef intersect_intervals(intervals1, intervals2):\n    i, j = 0, 0\n    intersection = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find overlap between intervals.\n        start_overlap = max(start1, start2)\n        end_overlap = min(end1, end2)\n        if start_overlap < end_overlap:\n            intersection.append((start_overlap, end_overlap))\n        # Advance the pointer with the smaller end time.\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\n# Meeting parameters\nmeeting_duration = 30  # in minutes\n\n# Work day start and end times in minutes (9:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# Define schedules (in \"HH:MM\" format) for Arthur and Michael.\nschedules = {\n    \"Arthur\": {\n        \"Monday\": [(\"11:00\", \"11:30\"), (\"13:30\", \"14:00\"), (\"15:00\", \"15:30\")],\n        # Arthur cannot meet on Tuesday, so we skip Tuesday for him.\n        \"Wednesday\": [(\"10:00\", \"10:30\"), (\"11:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"14:00\", \"14:30\"), (\"16:00\", \"16:30\")]\n    },\n    \"Michael\": {\n        \"Monday\": [(\"09:00\", \"12:00\"), (\"12:30\", \"13:00\"), (\"14:00\", \"14:30\"), (\"15:00\", \"17:00\")],\n        \"Tuesday\": [(\"09:30\", \"11:30\"), (\"12:00\", \"13:30\"), (\"14:00\", \"15:30\")],\n        \"Wednesday\": [(\"10:00\", \"12:30\"), (\"13:00\", \"13:30\")]\n    }\n}\n\n# Days to consider\ndays = [\"Monday\", \"Tuesday\", \"Wednesday\"]\n\n# Since Arthur cannot meet on Tuesday, we remove Tuesday from his schedule.\nif \"Tuesday\" in days:\n    # Only include Tuesday if all participants can attend.\n    # Arthur is not available on Tuesday so we remove that day.\n    days = [day for day in days if day != \"Tuesday\"]\n\n# Find earliest available meeting slot that works for all.\nfound_slot = False\nfor day in days:\n    # For each day, get the free intervals for each participant.\n    free_intervals_all = []\n    \n    for person, person_sched in schedules.items():\n        # If the person doesn't have any schedule on this day, they're free the whole workday.\n        busy_intervals = []\n        if day in person_sched:\n            # Convert busy times into minutes tuples.\n            busy_intervals = [(time_to_minutes(start), time_to_minutes(end)) for start, end in person_sched[day]]\n        \n        free_intervals = get_free_intervals(busy_intervals, work_start, work_end)\n        free_intervals_all.append(free_intervals)\n    \n    # Intersect free intervals of all participants.\n    common_free = free_intervals_all[0]\n    for other in free_intervals_all[1:]:\n        common_free = intersect_intervals(common_free, other)\n        if not common_free:\n            break  # No common free time on this day.\n    \n    # Check for a slot at least meeting_duration long.\n    for start, end in common_free:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = start + meeting_duration\n            print(f\"{day} {minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\")\n            found_slot = True\n            break\n    if found_slot:\n        break\n\nif not found_slot:\n    print(\"No available meeting slot found.\")\n'''",
            "count": "calendar_scheduling_example_723"
        }
    ]
}