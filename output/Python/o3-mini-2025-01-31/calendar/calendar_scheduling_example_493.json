{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "12:00",
                "end_time": "12:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "12:00",
                "end_time": "12:30"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import datetime, timedelta\n\n# Utility functions to work with time in minutes and string formatting\ndef time_to_minutes(time_str):\n    # time_str is \"HH:MM\"\n    h, m = map(int, time_str.split(':'))\n    return h * 60 + m\n\ndef minutes_to_time_str(minutes):\n    h = minutes // 60\n    m = minutes % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef subtract_busy_from_interval(free_interval, busy_intervals):\n    \"\"\"Given a free_interval (start, end) and a list of busy_intervals (tuples),\n    subtracts the busy intervals from the free_interval and returns list of resulting free intervals.\n    Assumes busy_intervals are sorted and non overlapping.\"\"\"\n    free_parts = []\n    current_start, current_end = free_interval\n    for b_start, b_end in busy_intervals:\n        # if busy interval doesn't overlap at all, continue\n        if b_end <= current_start or b_start >= current_end:\n            continue\n        # if there's free time before the busy interval, add it\n        if b_start > current_start:\n            free_parts.append((current_start, b_start))\n        # update current_start to the end of busy interval\n        current_start = max(current_start, b_end)\n    if current_start < current_end:\n        free_parts.append((current_start, current_end))\n    return free_parts\n\ndef compute_free_intervals(busy_intervals, work_interval):\n    \"\"\"Calculates free intervals given busy intervals and a working interval.\n    busy_intervals: list of (start, end) in minutes.\n    work_interval: (start, end) in minutes.\"\"\"\n    busy_intervals_sorted = sorted(busy_intervals, key=lambda x: x[0])\n    free = subtract_busy_from_interval(work_interval, busy_intervals_sorted)\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    \"\"\"Given two lists of intervals, compute their intersection.\"\"\"\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        a_start, a_end = intervals1[i]\n        b_start, b_end = intervals2[j]\n        # Find overlapping part\n        start = max(a_start, b_start)\n        end = min(a_end, b_end)\n        if start < end:\n            result.append((start, end))\n        # Move forward in the list that ends earlier\n        if a_end < b_end:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef find_common_free_interval(participants_free, meeting_duration):\n    # participants_free: list of free interval lists for each participant\n    # reduce pairwise intersection of all free intervals\n    common_free = participants_free[0]\n    for free in participants_free[1:]:\n        common_free = intersect_intervals(common_free, free)\n        if not common_free:\n            break\n    # now, choose the earliest interval with enough duration for meeting_duration\n    for start, end in common_free:\n        if end - start >= meeting_duration:\n            return start, start + meeting_duration\n    return None\n\n# Define working hours (9:00 to 17:00 in minutes since midnight)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nwork_interval = (work_start, work_end)\n\nmeeting_duration = 30  # in minutes\n\n# Busy schedules for each participant on Monday\n# Each busy interval is (start, end) in minutes. Times are given in HH:MM.\nschedules_busy = {\n    \"Tyler\": [],  # free all day\n    \"Kelly\": [],  # free all day\n    \"Stephanie\": [\n        (time_to_minutes(\"11:00\"), time_to_minutes(\"11:30\")),\n        (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\"))\n    ],\n    \"Hannah\": [],  # free all day\n    \"Joe\": [\n        (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n        (time_to_minutes(\"10:00\"), time_to_minutes(\"12:00\")),\n        (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\")),\n        (time_to_minutes(\"14:00\"), time_to_minutes(\"17:00\"))\n    ],\n    \"Diana\": [\n        (time_to_minutes(\"09:00\"), time_to_minutes(\"10:30\")),\n        (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n        (time_to_minutes(\"13:00\"), time_to_minutes(\"14:00\")),\n        (time_to_minutes(\"14:30\"), time_to_minutes(\"15:30\")),\n        (time_to_minutes(\"16:00\"), time_to_minutes(\"17:00\"))\n    ],\n    \"Deborah\": [\n        (time_to_minutes(\"09:00\"), time_to_minutes(\"10:00\")),\n        (time_to_minutes(\"10:30\"), time_to_minutes(\"12:00\")),\n        (time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\")),\n        (time_to_minutes(\"13:30\"), time_to_minutes(\"14:00\")),\n        (time_to_minutes(\"14:30\"), time_to_minutes(\"15:30\")),\n        (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))\n    ]\n}\n\n# Compute free intervals for each participant\nparticipants_free = []\nfor name, busy in schedules_busy.items():\n    free_intervals = compute_free_intervals(busy, work_interval)\n    participants_free.append(free_intervals)\n\n# Find a common free interval of meeting_duration minutes\nresult = find_common_free_interval(participants_free, meeting_duration)\n\nday_of_week = \"Monday\"\nif result:\n    start, end = result\n    start_str = minutes_to_time_str(start)\n    end_str = minutes_to_time_str(end)\n    # Format as requested: HH:MM:HH:MM with the day of the week\n    print(f\"{day_of_week} {start_str}:{end_str}\")\nelse:\n    print(\"No common free interval found.\")\n'''",
            "count": "calendar_scheduling_example_493"
        }
    ]
}