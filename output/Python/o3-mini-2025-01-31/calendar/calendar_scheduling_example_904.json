{
    "0shot": [
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "14:00",
                "end_time": "14:30"
            },
            "expected_time": {
                "day": "Tuesday",
                "start_time": "14:00",
                "end_time": "14:30"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import datetime, timedelta\n\n# Utility functions to convert time strings to minutes and back.\ndef time_to_minutes(time_str):\n    # time_str format \"HH:MM\"\n    h, m = map(int, time_str.split(\":\"))\n    return h * 60 + m\n\ndef minutes_to_time(minutes):\n    h = minutes // 60\n    m = minutes % 60\n    return f\"{h:02d}:{m:02d}\"\n\n# Working hours (9:00 to 17:00) as minutes\nWORK_START = time_to_minutes(\"09:00\")\nWORK_END   = time_to_minutes(\"17:00\")\nMEETING_DURATION = 30  # meeting duration in minutes\n\n# Schedules for each participant.\n# Each schedule is a dict with keys as days and values as list of busy intervals.\n# Each busy interval is represented as a tuple (start, end) in minutes.\ndaniel_busy = {\n    \"Monday\":    [(\"09:30\", \"10:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"14:00\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:00\")],\n    \"Tuesday\":   [(\"11:00\", \"12:00\"), (\"13:00\", \"13:30\"), (\"15:30\", \"16:00\"), (\"16:30\", \"17:00\")],\n    \"Wednesday\": [(\"09:00\", \"10:00\"), (\"14:00\", \"14:30\")],\n    \"Thursday\":  [(\"10:30\", \"11:00\"), (\"12:00\", \"13:00\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:00\")],\n    \"Friday\":    [(\"09:00\", \"09:30\"), (\"11:30\", \"12:00\"), (\"13:00\", \"13:30\"), (\"16:30\", \"17:00\")]\n}\nbradley_busy = {\n    \"Monday\":    [(\"09:30\", \"11:00\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"14:00\", \"15:00\")],\n    \"Tuesday\":   [(\"10:30\", \"11:00\"), (\"12:00\", \"13:00\"), (\"13:30\", \"14:00\"), (\"15:30\", \"16:30\")],\n    \"Wednesday\": [(\"09:00\", \"10:00\"), (\"11:00\", \"13:00\"), (\"13:30\", \"14:00\"), (\"14:30\", \"17:00\")],\n    \"Thursday\":  [(\"09:00\", \"12:30\"), (\"13:30\", \"14:00\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:30\")],\n    \"Friday\":    [(\"09:00\", \"09:30\"), (\"10:00\", \"12:30\"), (\"13:00\", \"13:30\"), (\"14:00\", \"14:30\"), (\"15:30\", \"16:30\")]\n}\n\n# Preferences:\n# Daniel: would rather not meet on Wednesday or Thursday.\n# Bradley: does not want to meet on Monday, not before 12:00 on Tuesday, and not on Friday.\n# Allowed days given these preferences: Only Tuesday is acceptable.\nallowed_days = [\"Tuesday\"]\n\n# Function to compute free intervals given a list of busy intervals on a day.\ndef compute_free_intervals(busy_times):\n    # Convert busy intervals into minutes\n    intervals = []\n    for start, end in busy_times:\n        intervals.append((time_to_minutes(start), time_to_minutes(end)))\n    # Sort intervals by start time\n    intervals.sort()\n    free_intervals = []\n    current_start = WORK_START\n    for bstart, bend in intervals:\n        if bstart > current_start:\n            free_intervals.append((current_start, bstart))\n        current_start = max(current_start, bend)\n    if current_start < WORK_END:\n        free_intervals.append((current_start, WORK_END))\n    return free_intervals\n\n# Function to get the intersection of two lists of intervals.\ndef intersect_intervals(intervals1, intervals2):\n    i, j = 0, 0\n    intersections = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find the overlap interval\n        start_overlap = max(start1, start2)\n        end_overlap   = min(end1, end2)\n        if start_overlap + MEETING_DURATION <= end_overlap:\n            intersections.append((start_overlap, end_overlap))\n        # Move to the next interval in the list with the earlier end time\n        if end1 <= end2:\n            i += 1\n        else:\n            j += 1\n    return intersections\n\nproposed_meeting = None\nproposed_day = None\n\nfor day in allowed_days:\n    # Compute free intervals for Daniel and Bradley on this day.\n    daniel_free = compute_free_intervals(daniel_busy.get(day, []))\n    bradley_free = compute_free_intervals(bradley_busy.get(day, []))\n    \n    # Apply Bradley's additional constraint for Tuesday:\n    # \"Tuesday before 12:00\" is not allowed. So adjust Bradley's free intervals if day is Tuesday.\n    if day == \"Tuesday\":\n        adjusted = []\n        for start, end in bradley_free:\n            if end <= time_to_minutes(\"12:00\"):\n                # skip intervals finishing before 12:00\n                continue\n            # Ensure the interval starts at least at 12:00\n            adjusted.append((max(start, time_to_minutes(\"12:00\")), end))\n        bradley_free = adjusted\n\n    # Find overlapping free intervals.\n    common_free = intersect_intervals(daniel_free, bradley_free)\n    # Check if any interval is long enough for the meeting\n    for start, end in common_free:\n        if end - start >= MEETING_DURATION:\n            proposed_meeting = (start, start + MEETING_DURATION)\n            proposed_day = day\n            break\n    if proposed_meeting:\n        break\n\nif proposed_meeting and proposed_day:\n    meeting_start = minutes_to_time(proposed_meeting[0])\n    meeting_end   = minutes_to_time(proposed_meeting[1])\n    print(f\"{proposed_day} {meeting_start}:{meeting_end}\")\nelse:\n    print(\"No available meeting slot found within the constraints.\")\n'''",
            "count": "calendar_scheduling_example_904"
        }
    ]
}