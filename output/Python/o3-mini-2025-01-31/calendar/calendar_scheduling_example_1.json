{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "9:30",
                "end_time": "10:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "14:30",
                "end_time": "15:00"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import datetime, timedelta\n\ndef time_to_minutes(time_str):\n    # time_str is in HH:MM format\n    dt = datetime.strptime(time_str, \"%H:%M\")\n    return dt.hour * 60 + dt.minute\n\ndef minutes_to_time(minutes):\n    # convert minutes (integer) to HH:MM formatted string\n    hours = minutes // 60\n    mins = minutes % 60\n    return \"{:02d}:{:02d}\".format(hours, mins)\n\n# Define working hours and meeting duration (in minutes)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nmeeting_duration = 30\n\n# Billy's preference: avoid meetings after 15:00.\nlatest_meeting_end = time_to_minutes(\"15:00\")\n\n# Define each participant's busy intervals on Monday in (start, end) format (in minutes)\n# (Note: times are in 24-hour HH:MM format.)\nschedules = {\n    \"Raymond\": [(\"09:00\", \"09:30\"), (\"11:30\", \"12:00\"), (\"13:00\", \"13:30\"), (\"15:00\", \"15:30\")],\n    \"Billy\":   [(\"10:00\", \"10:30\"), (\"12:00\", \"13:00\"), (\"16:30\", \"17:00\")],\n    \"Donald\":  [(\"09:00\", \"09:30\"), (\"10:00\", \"11:00\"), (\"12:00\", \"13:00\"), (\"14:00\", \"14:30\"), (\"16:00\", \"17:00\")]\n}\n\n# Convert schedules to minutes\nfor person, intervals in schedules.items():\n    schedules[person] = [(time_to_minutes(start), time_to_minutes(end)) for start, end in intervals]\n\n# Function to compute free intervals from busy intervals within working hours\ndef compute_free_intervals(busy_intervals, start, end):\n    free = []\n    # sort the busy intervals\n    busy_intervals.sort()\n    current = start\n    for b_start, b_end in busy_intervals:\n        if b_start > current:\n            free.append((current, b_start))\n        current = max(current, b_end)\n    if current < end:\n        free.append((current, end))\n    return free\n\n# Compute free intervals for each participant\nfree_times = {}\nfor person, busy in schedules.items():\n    free_times[person] = compute_free_intervals(busy, work_start, work_end)\n\n# Function to intersect two lists of intervals\ndef intersect_intervals(ints1, ints2):\n    i, j = 0, 0\n    result = []\n    while i < len(ints1) and j < len(ints2):\n        start1, end1 = ints1[i]\n        start2, end2 = ints2[j]\n        inter_start = max(start1, start2)\n        inter_end = min(end1, end2)\n        if inter_start < inter_end:\n            result.append((inter_start, inter_end))\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Intersect free intervals for all participants\ncommon_free = free_times[\"Raymond\"]\nfor person in [\"Billy\", \"Donald\"]:\n    common_free = intersect_intervals(common_free, free_times[person])\n\n# From the common free intervals, choose an interval that fits the meeting duration\n# and satisfies Billy's preference that the meeting ends by 15:00.\nproposed_meeting = None\nfor start, end in common_free:\n    # Adjust end if exceeding Billy's preference (meeting must finish by 15:00)\n    latest_possible_end = min(end, latest_meeting_end)\n    if latest_possible_end - start >= meeting_duration:\n        proposed_meeting = (start, start + meeting_duration)\n        break\n\nif proposed_meeting:\n    start_time, end_time = proposed_meeting\n    meeting_time_str = f\"{minutes_to_time(start_time)}:{minutes_to_time(end_time)}\"\n    day = \"Monday\"\n    print(f\"{meeting_time_str} {day}\")\nelse:\n    print(\"No suitable meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_1"
        }
    ]
}