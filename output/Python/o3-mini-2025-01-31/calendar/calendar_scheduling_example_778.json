{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "13:00",
                "end_time": "13:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "15:00",
                "end_time": "15:30"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import timedelta, datetime\n\n# Helper function to convert time string \"HH:MM\" to minutes since midnight.\ndef time_to_minutes(t):\n    h, m = map(int, t.split(\":\"))\n    return h * 60 + m\n\n# Helper function to convert minutes since midnight to time string \"HH:MM\"\ndef minutes_to_time(m):\n    return f\"{m // 60:02d}:{m % 60:02d}\"\n\n# Function to compute free intervals based on working hours and booked intervals\ndef get_free_intervals(booked, work_start, work_end):\n    free = []\n    start = work_start\n    for b in sorted(booked, key=lambda x: x[0]):\n        if b[0] > start:\n            free.append((start, b[0]))\n        start = max(start, b[1])\n    if start < work_end:\n        free.append((start, work_end))\n    return free\n\n# Function to compute the intersection between two lists of intervals\ndef intersect_intervals(intervals1, intervals2):\n    intersections = []\n    i, j = 0, 0\n    while i < len(intervals1) and j < len(intervals2):\n        a_start, a_end = intervals1[i]\n        b_start, b_end = intervals2[j]\n        # Find overlap\n        start = max(a_start, b_start)\n        end = min(a_end, b_end)\n        if start < end:\n            intersections.append((start, end))\n        if a_end < b_end:\n            i += 1\n        else:\n            j += 1\n    return intersections\n\n# Parameters\nmeeting_duration = 30  # minutes\nwork_start = time_to_minutes(\"09:00\")\nwork_end   = time_to_minutes(\"17:00\")\n\n# Booked intervals for each participant by day (times in 24-hour format, as minutes).\n# Each booked interval is a tuple (start, end) in minutes.\nsusan_schedule = {\n    \"Monday\": [(time_to_minutes(\"12:30\"), time_to_minutes(\"13:00\")),\n               (time_to_minutes(\"13:30\"), time_to_minutes(\"14:00\"))],\n    \"Tuesday\": [(time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\"))],\n    \"Wednesday\": [(time_to_minutes(\"09:30\"), time_to_minutes(\"10:30\")),\n                  (time_to_minutes(\"14:00\"), time_to_minutes(\"14:30\")),\n                  (time_to_minutes(\"15:30\"), time_to_minutes(\"16:30\"))]\n}\n\nsandra_schedule = {\n    \"Monday\": [(time_to_minutes(\"09:00\"), time_to_minutes(\"13:00\")),\n               (time_to_minutes(\"14:00\"), time_to_minutes(\"15:00\")),\n               (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))],\n    \"Tuesday\": [(time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n               (time_to_minutes(\"10:30\"), time_to_minutes(\"12:00\")),\n               (time_to_minutes(\"12:30\"), time_to_minutes(\"13:30\")),\n               (time_to_minutes(\"14:00\"), time_to_minutes(\"14:30\")),\n               (time_to_minutes(\"16:00\"), time_to_minutes(\"17:00\"))],\n    \"Wednesday\": [(time_to_minutes(\"09:00\"), time_to_minutes(\"11:30\")),\n                  (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n                  (time_to_minutes(\"13:00\"), time_to_minutes(\"17:00\"))]\n}\n\n# Participant constraints\n# Susan would rather not meet on Tuesday.\n# Sandra cannot meet on Monday after 16:00 (i.e. meeting must end by 16:00 on Monday).\npreferred_days = [\"Monday\", \"Wednesday\", \"Tuesday\"]\n\ndef find_meeting_time():\n    for day in preferred_days:\n        # Skip Tuesday for Susan's preference: only consider Tuesday if no other option is found.\n        # We try days in the order: Monday, Wednesday, then Tuesday.\n        \n        # Get free intervals for Susan and Sandra on this day\n        susan_booked = susan_schedule.get(day, [])\n        sandra_booked = sandra_schedule.get(day, [])\n        \n        susan_free = get_free_intervals(susan_booked, work_start, work_end)\n        sandra_free = get_free_intervals(sandra_booked, work_start, work_end)\n        \n        # Calculate common free intervals\n        common_free = intersect_intervals(susan_free, sandra_free)\n        \n        # Try to find a common slot that fits the meeting duration\n        for start, end in common_free:\n            if end - start >= meeting_duration:\n                meeting_start = start\n                meeting_end = start + meeting_duration\n                \n                # Apply additional constraints: \n                # Sandra cannot meet on Monday after 16:00.\n                if day == \"Monday\" and meeting_start >= time_to_minutes(\"16:00\"):\n                    continue\n                return day, meeting_start, meeting_end\n    return None\n\nresult = find_meeting_time()\nif result:\n    day, meeting_start, meeting_end = result\n    print(f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)} on {day}\")\nelse:\n    print(\"No available meeting time found.\")\n\n# Expected Output (according to the constraints, a valid meeting time is):\n# \"13:00:13:30 on Monday\"\n'''",
            "count": "calendar_scheduling_example_778"
        }
    ]
}