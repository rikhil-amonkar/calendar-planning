{
    "0shot": [
        {
            "final_program_time": {
                "day": "Friday",
                "start_time": "14:30",
                "end_time": "15:30"
            },
            "expected_time": {
                "day": "Friday",
                "start_time": "14:30",
                "end_time": "15:30"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import timedelta, datetime\n\n# Helper functions to convert times to minutes and back\ndef time_to_minutes(t_str):\n    # t_str in \"H:MM\" or \"HH:MM\", assume 24-hour format\n    t = datetime.strptime(t_str, \"%H:%M\")\n    return t.hour * 60 + t.minute\n\ndef minutes_to_time(m):\n    hours = m // 60\n    mins = m % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Define working day boundaries in minutes (9:00 to 17:00)\nWORK_START = time_to_minutes(\"09:00\")\nWORK_END = time_to_minutes(\"17:00\")\nMEETING_DURATION = 60  # minutes\n\n# Busy schedules for each participant, keyed by day of week.\n# Times are in HH:MM string format.\nbryan_busy = {\n    \"Monday\": [],\n    \"Tuesday\": [],\n    \"Wednesday\": [],\n    \"Thursday\": [(\"09:30\", \"10:00\"), (\"12:30\", \"13:00\")],\n    \"Friday\": [(\"10:30\", \"11:00\"), (\"14:00\", \"14:30\")]\n}\n\nnicholas_busy = {\n    \"Monday\": [(\"11:30\", \"12:00\"), (\"13:00\", \"15:30\")],\n    \"Tuesday\": [(\"09:00\", \"09:30\"), (\"11:00\", \"13:30\"), (\"14:00\", \"16:30\")],\n    \"Wednesday\": [(\"09:00\", \"09:30\"), (\"10:00\", \"11:00\"), (\"11:30\", \"13:30\"),\n                  (\"14:00\", \"14:30\"), (\"15:00\", \"16:30\")],\n    \"Thursday\": [(\"10:30\", \"11:30\"), (\"12:00\", \"12:30\"), (\"15:00\", \"15:30\"), (\"16:30\", \"17:00\")],\n    \"Friday\": [(\"09:00\", \"10:30\"), (\"11:00\", \"12:00\"), (\"12:30\", \"14:30\"),\n               (\"15:30\", \"16:00\"), (\"16:30\", \"17:00\")]\n}\n\n# Preferences: Bryan would like to avoid Tuesday; Nicholas would rather not meet on Monday or Thursday.\navoid_day = {\n    \"Bryan\": {\"Tuesday\"},\n    \"Nicholas\": {\"Monday\", \"Thursday\"}\n}\n\n# Function to compute free time intervals given busy periods on a day.\ndef compute_free_intervals(busy, start=WORK_START, end=WORK_END):\n    # Convert busy times to minutes and sort them\n    busy_minutes = []\n    for period in busy:\n        busy_minutes.append((time_to_minutes(period[0]), time_to_minutes(period[1])))\n    busy_minutes.sort()\n\n    free = []\n    current = start\n    for b_start, b_end in busy_minutes:\n        if current < b_start:\n            free.append((current, b_start))\n        current = max(current, b_end)\n    if current < end:\n        free.append((current, end))\n    return free\n\n# Function to compute intersection of two lists of intervals.\ndef intersect_intervals(intervals1, intervals2):\n    i, j = 0, 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # Find overlap\n        overlap_start = max(start1, start2)\n        overlap_end = min(end1, end2)\n        if overlap_start < overlap_end:\n            result.append((overlap_start, overlap_end))\n        # Move the pointer which ends first\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\n# Days of week to check in order.\ndays = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"]\n\n# Collect candidate meeting slots per day; store tuples (day, start, end)\ncandidates = []\nfor day in days:\n    bryan_free = compute_free_intervals(bryan_busy.get(day, []))\n    nicholas_free = compute_free_intervals(nicholas_busy.get(day, []))\n    common = intersect_intervals(bryan_free, nicholas_free)\n    # Check for any common interval that can accommodate MEETING_DURATION minutes.\n    for start, end in common:\n        if end - start >= MEETING_DURATION:\n            candidates.append((day, start, start + MEETING_DURATION))\n            break  # We choose the earliest available block on that day\n\n# Now apply preferences:\n# We prefer days that are not in the avoid sets.\ndef preference_score(day):\n    score = 0\n    if day in avoid_day[\"Bryan\"]:\n        score += 1\n    if day in avoid_day[\"Nicholas\"]:\n        score += 1\n    return score\n\n# Among candidates, we select the one with the lowest preference score.\ncandidates_sorted = sorted(candidates, key=lambda c: (preference_score(c[0]), days.index(c[0])))\nif candidates_sorted:\n    chosen_day, meeting_start, meeting_end = candidates_sorted[0]\n    meeting_time_str = f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    print(f\"{chosen_day} {meeting_time_str}\")\nelse:\n    print(\"No possible meeting time found.\")\n'''",
            "count": "calendar_scheduling_example_910"
        }
    ]
}