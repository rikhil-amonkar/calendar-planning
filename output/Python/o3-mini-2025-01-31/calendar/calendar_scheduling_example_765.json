{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "12:30",
                "end_time": "13:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "12:30",
                "end_time": "13:00"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import timedelta\n\n# Convert HH:MM string to minutes since midnight\ndef time_to_minutes(t):\n    hh, mm = map(int, t.split(\":\"))\n    return hh * 60 + mm\n\n# Convert minutes since midnight to HH:MM format\ndef minutes_to_time(m):\n    hh = m // 60\n    mm = m % 60\n    return f\"{hh:02d}:{mm:02d}\"\n\n# Work hours: 09:00 to 17:00\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\nmeeting_duration = 30  # in minutes\n\n# Busy schedules in minutes for each participant per day.\n# Each busy interval is a tuple: (start, end)\n# Days: Monday, Tuesday, Wednesday\n\nschedules = {\n    \"Monday\": {\n        \"Joshua\": [\n            (time_to_minutes(\"15:00\"), time_to_minutes(\"15:30\"))\n        ],\n        \"Joyce\": [\n            (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n            (time_to_minutes(\"10:00\"), time_to_minutes(\"11:00\")),\n            (time_to_minutes(\"11:30\"), time_to_minutes(\"12:30\")),\n            (time_to_minutes(\"13:00\"), time_to_minutes(\"15:00\")),\n            (time_to_minutes(\"15:30\"), time_to_minutes(\"17:00\"))\n        ]\n    },\n    \"Tuesday\": {\n        \"Joshua\": [\n            (time_to_minutes(\"11:30\"), time_to_minutes(\"12:00\")),\n            (time_to_minutes(\"13:00\"), time_to_minutes(\"13:30\")),\n            (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\"))\n        ],\n        \"Joyce\": [\n            (work_start, work_end)  # Busy whole day\n        ]\n    },\n    \"Wednesday\": {\n        \"Joshua\": [\n            # No meetings for Joshua on Wednesday\n        ],\n        \"Joyce\": [\n            (time_to_minutes(\"09:00\"), time_to_minutes(\"09:30\")),\n            (time_to_minutes(\"10:00\"), time_to_minutes(\"11:00\")),\n            (time_to_minutes(\"12:30\"), time_to_minutes(\"15:30\")),\n            (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))\n        ]\n    }\n}\n\n# For Monday, Joyce prefers not to meet before 12:00\ndef apply_preferences(day, start_min):\n    if day == \"Monday\":\n        preferred_start = time_to_minutes(\"12:00\")\n        return max(start_min, preferred_start)\n    return start_min\n\n# Function to compute free intervals in [work_start, work_end] given busy intervals\ndef get_free_intervals(busy_intervals):\n    free_intervals = []\n    current = work_start\n    # Sort busy intervals based on start times\n    for bstart, bend in sorted(busy_intervals):\n        if current < bstart:\n            free_intervals.append((current, bstart))\n        current = max(current, bend)\n    if current < work_end:\n        free_intervals.append((current, work_end))\n    return free_intervals\n\n# Function to compute intersection of intervals from two persons\ndef intersect_intervals(intervals1, intervals2):\n    intersections = []\n    i, j = 0, 0\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        # compute the intersection\n        start_int = max(start1, start2)\n        end_int = min(end1, end2)\n        if start_int < end_int:\n            intersections.append((start_int, end_int))\n        # Move to next interval from one of the lists\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return intersections\n\n# Find a meeting slot across the days (Monday, Tuesday, Wednesday)\nfound_slot = False\n\nfor day in [\"Monday\", \"Tuesday\", \"Wednesday\"]:\n    # Get free intervals for each person\n    joshua_free = get_free_intervals(schedules[day].get(\"Joshua\", []))\n    joyce_free = get_free_intervals(schedules[day].get(\"Joyce\", []))\n    \n    # Get overlapping free intervals\n    common_free = intersect_intervals(joshua_free, joyce_free)\n\n    # Check common free intervals for a slot of meeting_duration\n    for start, end in common_free:\n        # Apply day-specific preference. For example, Joyce doesn't prefer Monday before 12:00.\n        adjusted_start = apply_preferences(day, start)\n        if adjusted_start + meeting_duration <= end:\n            meeting_start = adjusted_start\n            meeting_end = meeting_start + meeting_duration\n            print(f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)} on {day}\")\n            found_slot = True\n            break\n    if found_slot:\n        break\n\nif not found_slot:\n    print(\"No available meeting slot found.\")\n'''",
            "count": "calendar_scheduling_example_765"
        }
    ]
}