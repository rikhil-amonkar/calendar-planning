{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "11:00",
                "end_time": "11:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "13:00",
                "end_time": "13:30"
            },
            "has_error": false,
            "raw_model_response": "'''python\nfrom datetime import timedelta, datetime\n\n# Helper functions to convert time strings and minutes.\ndef time_to_minutes(time_str):\n    \"\"\"Convert a time string 'HH:MM' to minutes since midnight.\"\"\"\n    t = datetime.strptime(time_str, \"%H:%M\")\n    return t.hour * 60 + t.minute\n\ndef minutes_to_time(m):\n    \"\"\"Convert minutes since midnight to a time string 'HH:MM'.\"\"\"\n    return f\"{m//60:02d}:{m%60:02d}\"\n\ndef merge_intervals(intervals):\n    \"\"\"Merge overlapping intervals. Each interval is (start, end) in minutes.\"\"\"\n    if not intervals:\n        return []\n    intervals = sorted(intervals, key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        last = merged[-1]\n        if current[0] <= last[1]:\n            merged[-1] = (last[0], max(last[1], current[1]))\n        else:\n            merged.append(current)\n    return merged\n\ndef find_free_intervals(busy_intervals, work_start, work_end):\n    \"\"\"Given busy time intervals (in minutes) during the work day, return free intervals.\"\"\"\n    free_intervals = []\n    # Start with the beginning of the work day.\n    current = work_start\n    for start, end in busy_intervals:\n        if start > current:\n            free_intervals.append((current, start))\n        current = max(current, end)\n    if current < work_end:\n        free_intervals.append((current, work_end))\n    return free_intervals\n\n# Meeting duration in minutes\nmeeting_duration = 30\n\n# Workday start/end in minutes (9:00 to 17:00)\nwork_start = time_to_minutes(\"09:00\")\nwork_end = time_to_minutes(\"17:00\")\n\n# John's schedule:\n# John has no meetings, but on Monday he prefers NOT to have meetings after 14:30.\n# We'll treat that as an additional constraint: for Monday, the meeting must end by 14:30.\njohn_monday_limit = time_to_minutes(\"14:30\")\n\n# Jennifer's existing schedules per day with busy intervals (times in minutes)\nschedules = {\n    \"Monday\": [\n        (time_to_minutes(\"09:00\"), time_to_minutes(\"11:00\")),\n        (time_to_minutes(\"11:30\"), time_to_minutes(\"13:00\")),\n        (time_to_minutes(\"13:30\"), time_to_minutes(\"14:30\")),\n        (time_to_minutes(\"15:00\"), time_to_minutes(\"17:00\"))\n    ],\n    \"Tuesday\": [\n        (time_to_minutes(\"09:00\"), time_to_minutes(\"11:30\")),\n        (time_to_minutes(\"12:00\"), time_to_minutes(\"17:00\"))\n    ],\n    \"Wednesday\": [\n        (time_to_minutes(\"09:00\"), time_to_minutes(\"11:30\")),\n        (time_to_minutes(\"12:00\"), time_to_minutes(\"12:30\")),\n        (time_to_minutes(\"13:00\"), time_to_minutes(\"14:00\")),\n        (time_to_minutes(\"14:30\"), time_to_minutes(\"16:00\")),\n        (time_to_minutes(\"16:30\"), time_to_minutes(\"17:00\"))\n    ]\n}\n\n# Candidate days in order of preference: Monday, Tuesday, Wednesday\ncandidate_days = [\"Monday\", \"Tuesday\", \"Wednesday\"]\n\nproposed_time = None\nproposed_day = None\n\nfor day in candidate_days:\n    # Merge Jennifer's busy intervals for the day\n    busy = merge_intervals(schedules.get(day, []))\n    \n    # For Monday, if John's condition applies, we restrict the effective work_end to 14:30.\n    effective_work_end = work_end\n    if day == \"Monday\":\n        effective_work_end = min(work_end, john_monday_limit)\n        \n    # Find free intervals within the effective work hours\n    free_intervals = find_free_intervals(busy, work_start, effective_work_end)\n    \n    # Search for a free interval that can accommodate meeting_duration minutes.\n    for start, end in free_intervals:\n        if end - start >= meeting_duration:\n            proposed_day = day\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            proposed_time = (meeting_start, meeting_end)\n            break\n    if proposed_time is not None:\n        break\n\nif proposed_time and proposed_day:\n    start_time_str = minutes_to_time(proposed_time[0])\n    end_time_str = minutes_to_time(proposed_time[1])\n    # Output format: HH:MM:HH:MM and day of the week.\n    print(f\"{start_time_str}:{end_time_str} on {proposed_day}\")\nelse:\n    print(\"No suitable time found.\")\n'''",
            "count": "calendar_scheduling_example_776"
        }
    ]
}