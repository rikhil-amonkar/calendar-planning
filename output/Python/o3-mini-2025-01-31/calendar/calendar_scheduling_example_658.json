{
    "0shot": [
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "9:00",
                "end_time": "9:30"
            },
            "expected_time": {
                "day": "Tuesday",
                "start_time": "9:00",
                "end_time": "9:30"
            },
            "has_error": false,
            "raw_model_response": "'''python\ndef find_meeting_time():\n    # Define meeting duration in minutes\n    duration = 30\n\n    # Constraints:\n    # Work hours: 09:00-17:00 on both days\n    # Shirley's busy slots:\n    shirley_busy = {\n        \"Monday\": [(\"10:30\", \"11:00\"), (\"12:00\", \"12:30\"), (\"16:00\", \"16:30\")],\n        \"Tuesday\": [(\"09:30\", \"10:00\")]\n    }\n    # Albert's busy slots:\n    albert_busy = {\n        \"Monday\": [(\"09:00\", \"17:00\")],\n        \"Tuesday\": [(\"09:30\", \"11:00\"), (\"11:30\", \"12:30\"), (\"13:00\", \"16:00\"), (\"16:30\", \"17:00\")]\n    }\n    # Preference: Shirley would rather not meet on Tuesday after 10:30.\n    \n    # We'll represent times in minutes after midnight for easier computation.\n    def time_to_minutes(t):\n        h, m = map(int, t.split(\":\"))\n        return h * 60 + m\n\n    def minutes_to_time(m):\n        h = m // 60\n        m = m % 60\n        return f\"{h:02d}:{m:02d}\"\n\n    work_start = time_to_minutes(\"09:00\")\n    work_end = time_to_minutes(\"17:00\")\n\n    days = [\"Monday\", \"Tuesday\"]\n    \n    # Function to get free intervals for a participant given their busy slots within work hours.\n    def free_intervals(busy_slots):\n        intervals = []\n        current_start = work_start\n        # sort busy slots by start time\n        busy_slots_sorted = sorted(busy_slots, key=lambda x: time_to_minutes(x[0]))\n        for start, end in busy_slots_sorted:\n            busy_start, busy_end = time_to_minutes(start), time_to_minutes(end)\n            if busy_start > current_start:\n                intervals.append((current_start, busy_start))\n            current_start = max(current_start, busy_end)\n        if current_start < work_end:\n            intervals.append((current_start, work_end))\n        return intervals\n\n    # Check if an interval can accommodate the meeting\n    def interval_fits(interval, duration):\n        start, end = interval\n        return (end - start) >= duration\n\n    found_day = None\n    found_start = None\n\n    # We need a time slot that fits for both participants.\n    # For each day, compute the free intervals for both and find the intersection.\n    for day in days:\n        # Get free intervals for Shirley and Albert on the day\n        shirley_free = free_intervals(shirley_busy.get(day, []))\n        albert_free = free_intervals(albert_busy.get(day, []))\n        \n        # Find common free intervals (intersection)\n        for s_start, s_end in shirley_free:\n            for a_start, a_end in albert_free:\n                interval_start = max(s_start, a_start)\n                interval_end = min(s_end, a_end)\n                if interval_end - interval_start >= duration:\n                    # For Tuesday, check preference: Shirley would rather not meet after 10:30.\n                    # So if day is Tuesday, try to choose a start time not later than 10:30 if possible.\n                    if day == \"Tuesday\":\n                        pref_latest_start = time_to_minutes(\"10:30\")\n                        if interval_start > pref_latest_start:\n                            continue\n                        # If interval_start is before pref_latest_start but the meeting would extend beyond it,\n                        # still use interval_start if available, as it's meeting early in the slot.\n                    found_day = day\n                    found_start = interval_start\n                    break\n            if found_day is not None:\n                break\n        if found_day is not None:\n            break\n\n    if found_day is None or found_start is None:\n        return \"No suitable meeting time found.\"\n    \n    meeting_start = found_start\n    meeting_end = meeting_start + duration\n\n    # Format the time as \"HH:MM:HH:MM\" and include the day.\n    result_time = f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    result = f\"{result_time} on {found_day}\"\n    return result\n\nif __name__ == \"__main__\":\n    meeting_time = find_meeting_time()\n    print(meeting_time)\n'''",
            "count": "calendar_scheduling_example_658"
        }
    ]
}