{
    "0shot": [
        {
            "final_program_time": {
                "day": null,
                "start_time": null,
                "end_time": null
            },
            "expected_time": {
                "day": "Wednesday",
                "start_time": "9:30",
                "end_time": "10:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(nancy_schedule, jose_schedule, days, work_hours, duration):\n    start_work, end_work = work_hours\n    duration_minutes = duration * 60\n    \n    for day in days:\n        # Initialize free slots for the day\n        nancy_free = get_free_slots(nancy_schedule.get(day, []), start_work, end_work)\n        jose_free = get_free_slots(jose_schedule.get(day, []), start_work, end_work)\n        \n        # Find overlapping free slots\n        overlapping = find_overlapping_slots(nancy_free, jose_free, duration_minutes)\n        \n        if overlapping:\n            # Return the earliest possible slot\n            start, end = overlapping[0]\n            return day, start, end\n    \n    return None\n\ndef get_free_slots(busy_slots, work_start, work_end):\n    # Convert time to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Process busy slots\n    busy_intervals = []\n    for slot in busy_slots:\n        start, end = slot.split(' to ')\n        start_min = time_to_minutes(start)\n        end_min = time_to_minutes(end)\n        busy_intervals.append((start_min, end_min))\n    \n    # Sort busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find free intervals\n    free_intervals = []\n    prev_end = work_start_min\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n    \n    # Convert back to time strings\n    free_slots = []\n    for start, end in free_intervals:\n        free_slots.append((minutes_to_time(start), minutes_to_time(end)))\n    \n    return free_slots\n\ndef find_overlapping_slots(slots1, slots2, duration):\n    # Convert time to minutes for comparison\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    overlapping = []\n    \n    for s1_start, s1_end in slots1:\n        s1_start_min = time_to_minutes(s1_start)\n        s1_end_min = time_to_minutes(s1_end)\n        \n        for s2_start, s2_end in slots2:\n            s2_start_min = time_to_minutes(s2_start)\n            s2_end_min = time_to_minutes(s2_end)\n            \n            # Find overlap\n            overlap_start = max(s1_start_min, s2_start_min)\n            overlap_end = min(s1_end_min, s2_end_min)\n            \n            if overlap_start < overlap_end and (overlap_end - overlap_start) >= duration:\n                overlapping.append((overlap_start, overlap_end))\n    \n    # Sort overlapping slots by start time\n    overlapping.sort()\n    \n    # Convert back to time strings\n    result = []\n    for start, end in overlapping:\n        start_time = minutes_to_time(start)\n        end_time = minutes_to_time(start + duration)\n        result.append((start_time, end_time))\n    \n    return result\n\ndef minutes_to_time(minutes):\n    hh = minutes // 60\n    mm = minutes % 60\n    return f\"{hh:02d}:{mm:02d}\"\n\n# Define schedules\nnancy_schedule = {\n    'Monday': ['10:00 to 10:30', '11:30 to 12:30', '13:30 to 14:00', '14:30 to 15:30', '16:00 to 17:00'],\n    'Tuesday': ['9:30 to 10:30', '11:00 to 11:30', '12:00 to 12:30', '13:00 to 13:30', '15:30 to 16:00'],\n    'Wednesday': ['10:00 to 11:30', '13:30 to 16:00']\n}\n\njose_schedule = {\n    'Monday': ['9:00 to 17:00'],\n    'Tuesday': ['9:00 to 17:00'],\n    'Wednesday': ['9:00 to 9:30', '10:00 to 12:30', '13:30 to 14:30', '15:00 to 17:00']\n}\n\n# Define parameters\ndays = ['Monday', 'Tuesday', 'Wednesday']\nwork_hours = ('9:00', '17:00')\nduration = 30  # minutes\n\n# Find meeting time\nresult = find_meeting_time(nancy_schedule, jose_schedule, days, work_hours, duration)\n\nif result:\n    day, start, end = result\n    print(f\"{day}: {start}:{end}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_798"
        }
    ]
}