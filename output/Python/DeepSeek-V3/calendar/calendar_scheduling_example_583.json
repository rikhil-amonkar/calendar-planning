{
    "0shot": [
        {
            "final_program_time": {
                "day": null,
                "start_time": null,
                "end_time": null
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "9:30",
                "end_time": "10:00"
            },
            "has_error": true,
            "raw_model_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration, day):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    start_work, end_work = work_hours\n    start_work_min = time_to_minutes(start_work)\n    end_work_min = time_to_minutes(end_work)\n    duration_min = duration * 60\n\n    # Generate all busy intervals in minutes for each participant\n    busy_intervals = []\n    for busy_slots in participents_busy:\n        participant_busy = []\n        for slot in busy_slots:\n            start, end = slot\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            participant_busy.append((start_min, end_min))\n        busy_intervals.append(participant_busy)\n\n    # Find all free intervals for each participant\n    free_intervals = []\n    for participant in busy_intervals:\n        participant_free = []\n        previous_end = start_work_min\n        for start, end in sorted(participant):\n            if start > previous_end:\n                participant_free.append((previous_end, start))\n            previous_end = max(previous_end, end)\n        if previous_end < end_work_min:\n            participant_free.append((previous_end, end_work_min))\n        free_intervals.append(participant_free)\n\n    # Find overlapping free intervals across all participants\n    common_free = free_intervals[0]\n    for participant in free_intervals[1:]:\n        new_common_free = []\n        i = j = 0\n        while i < len(common_free) and j < len(participant):\n            start1, end1 = common_free[i]\n            start2, end2 = participant[j]\n            overlap_start = max(start1, start2)\n            overlap_end = min(end1, end2)\n            if overlap_start < overlap_end:\n                new_common_free.append((overlap_start, overlap_end))\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free = new_common_free\n\n    # Find the earliest slot that fits the duration\n    for start, end in common_free:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return (\n                f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\",\n                day\n            )\n    return None\n\n# Define the task parameters\nparticipants_busy = [\n    [(\"9:00\", \"9:30\"), (\"10:30\", \"11:00\"), (\"14:00\", \"16:00\")],  # Lisa's schedule\n    [(\"9:00\", \"9:30\"), (\"11:00\", \"11:30\"), (\"12:30\", \"13:30\"), \n     (\"14:00\", \"15:00\"), (\"15:30\", \"16:00\"), (\"16:30\", \"17:00\")]  # Anthony's schedule\n]\nwork_hours = (\"9:00\", \"17:00\")\nduration = 30  # minutes\nday = \"Monday\"\n\n# Find the meeting time\nmeeting_time, day = find_meeting_time(participants_busy, work_hours, duration, day)\nprint(f\"{meeting_time}:{day}\")\n```",
            "count": "calendar_scheduling_example_583"
        }
    ]
}