{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "13:00",
                "end_time": "13:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "15:00",
                "end_time": "15:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define participants' schedules and constraints\n    susan_schedule = {\n        'Monday': [(12 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60)],\n        'Tuesday': [(11 * 60 + 30, 12 * 60)],\n        'Wednesday': [(9 * 60 + 30, 10 * 60 + 30), (14 * 60, 14 * 60 + 30), (15 * 60 + 30, 16 * 60 + 30)]\n    }\n    \n    sandra_schedule = {\n        'Monday': [(9 * 60, 13 * 60), (14 * 60, 15 * 60), (16 * 60, 16 * 60 + 30)],\n        'Tuesday': [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60 + 30), \n                    (14 * 60, 14 * 60 + 30), (16 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (13 * 60, 17 * 60)]\n    }\n    \n    # Susan prefers not to meet on Tuesday\n    preferred_days = ['Monday', 'Wednesday']\n    \n    # Iterate through each day in preferred order\n    for day in preferred_days:\n        # Get both participants' busy times for the day\n        susan_busy = susan_schedule.get(day, [])\n        sandra_busy = sandra_schedule.get(day, [])\n        \n        # Combine and sort all busy intervals\n        all_busy = susan_busy + sandra_busy\n        all_busy.sort()\n        \n        # Find available slots\n        available_slots = []\n        prev_end = work_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy interval\n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n        \n        # Find first available 30-minute slot\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= 30:\n                meeting_start = slot_start\n                meeting_end = meeting_start + 30\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                time_str = f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n                return day, time_str\n    \n    # If no slot found in preferred days, check Tuesday (though Susan prefers not)\n    day = 'Tuesday'\n    susan_busy = susan_schedule.get(day, [])\n    sandra_busy = sandra_schedule.get(day, [])\n    all_busy = susan_busy + sandra_busy\n    all_busy.sort()\n    \n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= 30:\n            meeting_start = slot_start\n            meeting_end = meeting_start + 30\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            time_str = f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n            return day, time_str\n    \n    return None, None\n\nday, time_slot = find_meeting_time()\nprint(f\"{day}: {time_slot}\")\n```",
            "count": "calendar_scheduling_example_778"
        }
    ]
}