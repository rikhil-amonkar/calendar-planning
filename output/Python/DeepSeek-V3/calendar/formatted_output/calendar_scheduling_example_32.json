{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "9:00",
                "end_time": "9:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "9:00",
                "end_time": "9:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours, day, preferences=None):\n    \"\"\"\n    Finds a meeting time that fits all participants' schedules and constraints.\n    \n    Args:\n        participants_schedules: List of lists of busy time ranges for each participant.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        day: Day of the week.\n        preferences: Optional constraints (e.g., no meetings after a certain time).\n    \n    Returns:\n        A tuple of (start_time, end_time) in HH:MM format, or None if no time found.\n    \"\"\"\n    # Convert all times to minutes since midnight for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Generate all possible time slots within work hours\n    slots = []\n    current_time = work_start\n    while current_time + duration <= work_end:\n        slots.append((current_time, current_time + duration))\n        current_time += 15  # Check in 15-minute increments\n    \n    # Apply Frank's preference: no meetings after 9:30 (570 minutes)\n    if preferences and \"no_meeting_after\" in preferences:\n        no_meeting_after = preferences[\"no_meeting_after\"] * 60\n        slots = [slot for slot in slots if slot[0] < no_meeting_after]\n    \n    # Check each slot against all participants' schedules\n    for slot in slots:\n        slot_start, slot_end = slot\n        valid = True\n        \n        for schedule in participants_schedules:\n            for busy_start, busy_end in schedule:\n                busy_start_min = busy_start[0] * 60 + busy_start[1]\n                busy_end_min = busy_end[0] * 60 + busy_end[1]\n                \n                # Check if slot overlaps with any busy time\n                if not (slot_end <= busy_start_min or slot_start >= busy_end_min):\n                    valid = False\n                    break\n            \n            if not valid:\n                break\n        \n        if valid:\n            # Convert back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return (f\"{start_hh:02d}:{start_mm:02d}\", f\"{end_hh:02d}:{end_mm:02d}\")\n    \n    return None\n\n# Define participants' schedules in (HH, MM) format\nemily_schedule = [\n    ((10, 0), (10, 30)),\n    ((11, 30), (12, 30)),\n    ((14, 0), (15, 0)),\n    ((16, 0), (16, 30))\n]\n\nmelissa_schedule = [\n    ((9, 30), (10, 0)),\n    ((14, 30), (15, 0))\n]\n\nfrank_schedule = [\n    ((10, 0), (10, 30)),\n    ((11, 0), (11, 30)),\n    ((12, 30), (13, 0)),\n    ((13, 30), (14, 30)),\n    ((15, 0), (16, 0)),\n    ((16, 30), (17, 0))\n]\n\nparticipants_schedules = [emily_schedule, melissa_schedule, frank_schedule]\nduration = 30  # minutes\nwork_hours = (9, 17)  # 9:00 to 17:00\nday = \"Monday\"\npreferences = {\"no_meeting_after\": 9.5}  # 9:30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours, day, preferences)\n\nif meeting_time:\n    start_time, end_time = meeting_time\n    print(f\"{day}: {start_time}:{end_time}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_32"
        }
    ]
}