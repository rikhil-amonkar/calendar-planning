{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "12:30",
                "end_time": "13:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "12:30",
                "end_time": "13:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, day, work_hours_start, work_hours_end, duration_minutes):\n    # Convert work hours to minutes since midnight for easier calculation\n    work_start = work_hours_start[0] * 60 + work_hours_start[1]\n    work_end = work_hours_end[0] * 60 + work_hours_end[1]\n    \n    # Initialize the free slots for all participants\n    free_slots = []\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start_h, start_m = busy[0]\n            end_h, end_m = busy[1]\n            busy_start = start_h * 60 + start_m\n            busy_end = end_h * 60 + end_m\n            busy_slots.append((busy_start, busy_end))\n        \n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Calculate free slots based on busy slots\n        free = []\n        prev_end = work_start\n        for busy_start, busy_end in busy_slots:\n            if busy_start > prev_end:\n                free.append((prev_end, busy_start))\n            prev_end = max(prev_end, busy_end)\n        if prev_end < work_end:\n            free.append((prev_end, work_end))\n        \n        free_slots.append(free)\n    \n    # Find intersection of all free slots\n    common_free = free_slots[0]\n    for free in free_slots[1:]:\n        new_common_free = []\n        i = j = 0\n        while i < len(common_free) and j < len(free):\n            start1, end1 = common_free[i]\n            start2, end2 = free[j]\n            \n            # Find the overlapping interval\n            start = max(start1, start2)\n            end = min(end1, end2)\n            \n            if start < end:\n                new_common_free.append((start, end))\n            \n            # Move the pointer which ends first\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free = new_common_free\n    \n    # Find the first slot that can fit the meeting duration\n    duration = duration_minutes\n    for start, end in common_free:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_h = meeting_start // 60\n            start_m = meeting_start % 60\n            end_h = meeting_end // 60\n            end_m = meeting_end % 60\n            return (f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\", day)\n    \n    return None\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [((13, 30), (14, 00)), ((14, 30), (15, 00))],  # Jacob\n    [((9, 30), (10, 00)), ((11, 30), (12, 00)), ((13, 00), (13, 30)), ((16, 00), (16, 30))],  # Diana\n    [((9, 30), (10, 30)), ((11, 00), (12, 30)), ((15, 30), (16, 00))],  # Adam\n    [((9, 30), (10, 00)), ((10, 30), (12, 00)), ((13, 00), (15, 30)), ((16, 00), (16, 30))],  # Angela\n    [((9, 00), (9, 30)), ((10, 30), (11, 30)), ((13, 00), (15, 00)), ((16, 30), (17, 00))],  # Dennis\n]\n\n# Define meeting parameters\nday = \"Monday\"\nwork_hours_start = (9, 00)\nwork_hours_end = (17, 00)\nduration_minutes = 30\n\n# Find the meeting time\nresult = find_meeting_time(participants_schedules, day, work_hours_start, work_hours_end, duration_minutes)\nif result:\n    time_range, day = result\n    print(f\"{time_range} {day}\")\nelse:\n    print(\"No suitable time found.\")\n'''python\ndef find_meeting_time(participants_schedules, day, work_hours_start, work_hours_end, duration_minutes):\n    # Convert work hours to minutes since midnight for easier calculation\n    work_start = work_hours_start[0] * 60 + work_hours_start[1]\n    work_end = work_hours_end[0] * 60 + work_hours_end[1]\n    \n    # Initialize the free slots for all participants\n    free_slots = []\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start_h, start_m = busy[0]\n            end_h, end_m = busy[1]\n            busy_start = start_h * 60 + start_m\n            busy_end = end_h * 60 + end_m\n            busy_slots.append((busy_start, busy_end))\n        \n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Calculate free slots based on busy slots\n        free = []\n        prev_end = work_start\n        for busy_start, busy_end in busy_slots:\n            if busy_start > prev_end:\n                free.append((prev_end, busy_start))\n            prev_end = max(prev_end, busy_end)\n        if prev_end < work_end:\n            free.append((prev_end, work_end))\n        \n        free_slots.append(free)\n    \n    # Find intersection of all free slots\n    common_free = free_slots[0]\n    for free in free_slots[1:]:\n        new_common_free = []\n        i = j = 0\n        while i < len(common_free) and j < len(free):\n            start1, end1 = common_free[i]\n            start2, end2 = free[j]\n            \n            # Find the overlapping interval\n            start = max(start1, start2)\n            end = min(end1, end2)\n            \n            if start < end:\n                new_common_free.append((start, end))\n            \n            # Move the pointer which ends first\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free = new_common_free\n    \n    # Find the first slot that can fit the meeting duration\n    duration = duration_minutes\n    for start, end in common_free:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_h = meeting_start // 60\n            start_m = meeting_start % 60\n            end_h = meeting_end // 60\n            end_m = meeting_end % 60\n            return (f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\", day)\n    \n    return None\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [((13, 30), (14, 00)), ((14, 30), (15, 00))],  # Jacob\n    [((9, 30), (10, 00)), ((11, 30), (12, 00)), ((13, 00), (13, 30)), ((16, 00), (16, 30))],  # Diana\n    [((9, 30), (10, 30)), ((11, 00), (12, 30)), ((15, 30), (16, 00))],  # Adam\n    [((9, 30), (10, 00)), ((10, 30), (12, 00)), ((13, 00), (15, 30)), ((16, 00), (16, 30))],  # Angela\n    [((9, 00), (9, 30)), ((10, 30), (11, 30)), ((13, 00), (15, 00)), ((16, 30), (17, 00))],  # Dennis\n]\n\n# Define meeting parameters\nday = \"Monday\"\nwork_hours_start = (9, 00)\nwork_hours_end = (17, 00)\nduration_minutes = 30\n\n# Find the meeting time\nresult = find_meeting_time(participants_schedules, day, work_hours_start, work_hours_end, duration_minutes)\nif result:\n    time_range, day = result\n    print(f\"{time_range} {day}\")\nelse:\n    print(\"No suitable time found.\")\n'''",
            "count": "calendar_scheduling_example_246"
        }
    ]
}