{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "9:30",
                "end_time": "10:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "9:30",
                "end_time": "10:00"
            },
            "has_error": false,
            "raw_model_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_earliest_meeting_time(participants_schedules, work_hours, meeting_duration, days):\n    # Convert work hours to minutes since start of day\n    work_start = int(work_hours[0].split(':')[0]) * 60 + int(work_hours[0].split(':')[1])\n    work_end = int(work_hours[1].split(':')[0]) * 60 + int(work_hours[1].split(':')[1])\n    \n    # Preprocess blocked times into minutes since start of day for each day\n    blocked_times = {}\n    for day in days:\n        blocked_times[day] = []\n        for participant in participants_schedules:\n            for block in participants_schedules[participant].get(day, []):\n                start_time = block[0].split(':')\n                end_time = block[1].split(':')\n                start_min = int(start_time[0]) * 60 + int(start_time[1])\n                end_min = int(end_time[0]) * 60 + int(end_time[1])\n                blocked_times[day].append((start_min, end_min))\n    \n    # Check each day in order for the earliest available slot\n    for day in days:\n        # Merge and sort all blocked intervals for the day\n        intervals = blocked_times[day]\n        if not intervals:\n            # No blocked times, entire work day is available\n            return day, (work_hours[0], f\"{int(work_start//60):02d}:{int(work_start%60):02d}\", \n                         f\"{int((work_start + meeting_duration)//60):02d}:{int((work_start + meeting_duration)%60):02d}\")\n        \n        merged = []\n        for start, end in sorted(intervals):\n            if not merged:\n                merged.append((start, end))\n            else:\n                last_start, last_end = merged[-1]\n                if start <= last_end:\n                    merged[-1] = (last_start, max(end, last_end))\n                else:\n                    merged.append((start, end))\n        \n        # Check before first interval\n        first_start, first_end = merged[0]\n        if first_start - work_start >= meeting_duration:\n            return day, (f\"{int(work_start//60):02d}:{int(work_start%60):02d}\", \n                          f\"{int((work_start + meeting_duration)//60):02d}:{int((work_start + meeting_duration)%60):02d}\")\n        \n        # Check between intervals\n        for i in range(1, len(merged)):\n            prev_end = merged[i-1][1]\n            curr_start = merged[i][0]\n            if curr_start - prev_end >= meeting_duration:\n                return day, (f\"{int(prev_end//60):02d}:{int(prev_end%60):02d}\", \n                            f\"{int((prev_end + meeting_duration)//60):02d}:{int((prev_end + meeting_duration)%60):02d}\")\n        \n        # Check after last interval\n        last_start, last_end = merged[-1]\n        if work_end - last_end >= meeting_duration:\n            return day, (f\"{int(last_end//60):02d}:{int(last_end%60):02d}\", \n                         f\"{int((last_end + meeting_duration)//60):02d}:{int((last_end + meeting_duration)%60):02d}\")\n    \n    return None, None\n\n# Define the problem constraints\nparticipants_schedules = {\n    \"Ronald\": {\n        \"Monday\": [(\"10:30\", \"11:00\"), (\"12:00\", \"12:30\"), (\"15:30\", \"16:00\")],\n        \"Tuesday\": [(\"9:00\", \"9:30\"), (\"12:00\", \"12:30\"), (\"15:30\", \"16:30\")],\n        \"Wednesday\": [(\"9:30\", \"10:30\"), (\"11:00\", \"12:00\"), (\"12:30\", \"13:00\"), (\"13:30\", \"14:00\"), (\"16:30\", \"17:00\")],\n    },\n    \"Amber\": {\n        \"Monday\": [(\"9:00\", \"9:30\"), (\"10:00\", \"10:30\"), (\"11:30\", \"12:00\"), (\"12:30\", \"14:00\"), (\"14:30\", \"15:00\"), (\"15:30\", \"17:00\")],\n        \"Tuesday\": [(\"9:00\", \"9:30\"), (\"10:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:30\", \"15:30\"), (\"16:30\", \"17:00\")],\n        \"Wednesday\": [(\"9:00\", \"9:30\"), (\"10:00\", \"10:30\"), (\"11:00\", \"13:30\"), (\"15:00\", \"15:30\")],\n    }\n}\n\nwork_hours = (\"9:00\", \"17:00\")\nmeeting_duration = 30  # minutes\ndays = [\"Monday\", \"Tuesday\", \"Wednesday\"]\n\n# Find the earliest meeting time\nday, time_range = find_earliest_meeting_time(participants_schedules, work_hours, meeting_duration, days)\n\n# Output the result\nif day and time_range:\n    start_time, end_time = time_range\n    print(f\"{day}: {start_time}:{end_time}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_735"
        }
    ]
}