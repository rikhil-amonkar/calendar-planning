{
    "0shot": [
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "9:30",
                "end_time": "10:30"
            },
            "expected_time": {
                "day": "Tuesday",
                "start_time": "9:30",
                "end_time": "10:30"
            },
            "has_error": false,
            "raw_model_response": "```python\nfrom typing import List, Dict, Tuple\n\ndef find_meeting_time(\n    participants: List[str],\n    schedules: Dict[str, Dict[str, List[Tuple[str, str]]]],\n    preferences: Dict[str, Dict[str, str]],\n    work_hours: Tuple[str, str],\n    meeting_duration: int,\n    days: List[str]\n) -> Tuple[str, Tuple[str, str]]:\n    \"\"\"\n    Find a meeting time that fits all participants' schedules and constraints.\n    \n    Args:\n        participants: List of participant names.\n        schedules: Dictionary with participant names as keys and their schedules as values.\n                  Schedules are dictionaries with days as keys and list of (start, end) time tuples as values.\n        preferences: Dictionary with participant names as keys and their preferences as values.\n                    Preferences are dictionaries with keys like \"avoid_day\" or \"cannot_meet_after\".\n        work_hours: Tuple of (start, end) time for work hours.\n        meeting_duration: Duration of the meeting in minutes.\n        days: List of days to consider for the meeting.\n    \n    Returns:\n        Tuple of (day, (start_time, end_time)) if a slot is found, otherwise (None, (None, None)).\n    \"\"\"\n    # Convert all time strings to minutes since midnight for easier calculations\n    def time_to_minutes(time_str: str) -> int:\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes: int) -> str:\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = map(time_to_minutes, work_hours)\n    duration_minutes = meeting_duration\n    \n    for day in days:\n        # Check if day is avoided by any participant\n        avoid_day = False\n        for participant in participants:\n            if preferences.get(participant, {}).get(\"avoid_day\") == day:\n                avoid_day = True\n                break\n        if avoid_day:\n            continue\n        \n        # Collect all busy intervals for the day\n        busy_intervals = []\n        for participant in participants:\n            for interval in schedules[participant].get(day, []):\n                start, end = map(time_to_minutes, interval)\n                busy_intervals.append((start, end))\n        \n        # Also add constraints like \"cannot meet after\"\n        for participant in participants:\n            cannot_meet_after = preferences.get(participant, {}).get(\"cannot_meet_after\")\n            if cannot_meet_after and day in preferences.get(participant, {}).get(\"cannot_meet_after_day\", day):\n                cutoff = time_to_minutes(cannot_meet_after)\n                busy_intervals.append((cutoff, work_end))\n        \n        # Sort intervals by start time\n        busy_intervals.sort()\n        \n        # Find free slots\n        prev_end = work_start\n        free_slots = []\n        for start, end in busy_intervals:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check if any free slot can fit the meeting\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= duration_minutes:\n                meeting_start = slot_start\n                meeting_end = meeting_start + duration_minutes\n                return (day, (minutes_to_time(meeting_start), minutes_to_time(meeting_end)))\n    \n    return (None, (None, None))\n\n# Define the problem\nparticipants = [\"Stephanie\", \"Betty\"]\nschedules = {\n    \"Stephanie\": {\n        \"Monday\": [(\"9:30\", \"10:00\"), (\"10:30\", \"11:00\"), (\"11:30\", \"12:00\"), (\"14:00\", \"14:30\")],\n        \"Tuesday\": [(\"12:00\", \"13:00\")],\n        \"Wednesday\": [(\"9:00\", \"10:00\"), (\"13:00\", \"14:00\")],\n    },\n    \"Betty\": {\n        \"Monday\": [(\"9:00\", \"10:00\"), (\"11:00\", \"11:30\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:00\")],\n        \"Tuesday\": [(\"9:00\", \"9:30\"), (\"11:30\", \"12:00\"), (\"12:30\", \"14:30\"), (\"15:30\", \"16:00\")],\n        \"Wednesday\": [(\"10:00\", \"11:30\"), (\"12:00\", \"14:00\"), (\"14:30\", \"17:00\")],\n    },\n}\npreferences = {\n    \"Stephanie\": {\"avoid_day\": \"Monday\"},\n    \"Betty\": {\"cannot_meet_after\": \"12:30\", \"cannot_meet_after_day\": \"Tuesday\"},\n}\nwork_hours = (\"9:00\", \"17:00\")\nmeeting_duration = 60  # minutes\ndays = [\"Monday\", \"Tuesday\", \"Wednesday\"]\n\n# Find the meeting time\nday, (start_time, end_time) = find_meeting_time(participants, schedules, preferences, work_hours, meeting_duration, days)\n\n# Output the result\nif day:\n    print(f\"{day}:{start_time}:{end_time}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_703"
        }
    ]
}