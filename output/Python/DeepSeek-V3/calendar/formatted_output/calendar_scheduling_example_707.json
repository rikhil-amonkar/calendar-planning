{
    "0shot": [
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "10:00",
                "end_time": "10:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "16:00",
                "end_time": "16:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define constraints and busy times for each participant\n    ryan_busy = {\n        'Monday': [(9*60 + 30, 10*60), (11*60, 12*60), (13*60, 13*60 + 30), (15*60 + 30, 16*60)],\n        'Tuesday': [(11*60 + 30, 12*60 + 30), (15*60 + 30, 16*60)],\n        'Wednesday': [(12*60, 13*60), (15*60 + 30, 16*60), (16*60 + 30, 17*60)]\n    }\n    \n    adam_busy = {\n        'Monday': [(9*60, 10*60 + 30), (11*60, 13*60 + 30), (14*60, 16*60), (16*60 + 30, 17*60)],\n        'Tuesday': [(9*60, 10*60), (10*60 + 30, 15*60 + 30), (16*60, 17*60)],\n        'Wednesday': [(9*60, 9*60 + 30), (10*60, 11*60), (11*60 + 30, 14*60 + 30), (15*60, 15*60 + 30), (16*60, 16*60 + 30)]\n    }\n    \n    # Apply constraints: Ryan cannot meet on Wednesday, Adam avoids Monday before 14:30\n    days_to_check = ['Monday', 'Tuesday']  # Wednesday is excluded due to Ryan's constraint\n    \n    meeting_duration = 30  # minutes\n    \n    for day in days_to_check:\n        # Combine and sort busy times for both participants\n        combined_busy = ryan_busy[day] + adam_busy[day]\n        combined_busy.sort()\n        \n        # Merge overlapping or adjacent busy intervals\n        merged_busy = []\n        for start, end in combined_busy:\n            if not merged_busy:\n                merged_busy.append((start, end))\n            else:\n                last_start, last_end = merged_busy[-1]\n                if start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged_busy[-1] = (new_start, new_end)\n                else:\n                    merged_busy.append((start, end))\n        \n        # Check available slots\n        prev_end = work_start\n        for start, end in merged_busy:\n            if start > prev_end:\n                # Found a potential slot\n                slot_start = prev_end\n                slot_end = start\n                if slot_end - slot_start >= meeting_duration:\n                    # Check Adam's Monday before 14:30 constraint\n                    if day == 'Monday' and slot_start < 14*60 + 30:\n                        continue  # Skip this slot\n                    # Found a valid slot\n                    meeting_start = slot_start\n                    meeting_end = meeting_start + meeting_duration\n                    # Format the time as HH:MM:HH:MM\n                    start_hh = meeting_start // 60\n                    start_mm = meeting_start % 60\n                    end_hh = meeting_end // 60\n                    end_mm = meeting_end % 60\n                    time_str = f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n                    return day, time_str\n            prev_end = max(prev_end, end)\n        \n        # Check after the last busy interval\n        if work_end - prev_end >= meeting_duration:\n            # Check Adam's Monday before 14:30 constraint\n            if day == 'Monday' and prev_end < 14*60 + 30:\n                continue  # Skip this slot\n            meeting_start = prev_end\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            time_str = f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n            return day, time_str\n    \n    return None, None\n\nday, time_slot = find_meeting_time()\nprint(f\"{day}: {time_slot}\")\n```",
            "count": "calendar_scheduling_example_707"
        }
    ]
}