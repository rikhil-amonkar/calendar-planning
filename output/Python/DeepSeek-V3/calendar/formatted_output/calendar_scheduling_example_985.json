{
    "0shot": [
        {
            "final_program_time": {
                "day": "Wednesday",
                "start_time": "15:00",
                "end_time": "16:00"
            },
            "expected_time": {
                "day": "Wednesday",
                "start_time": "15:00",
                "end_time": "16:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours and days\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n    \n    # Define busy intervals for each person per day in minutes since midnight\n    diane_busy = {\n        'Monday': [(12 * 60, 12 * 60 + 30), (15 * 60, 15 * 60 + 30)],\n        'Tuesday': [(10 * 60, 11 * 60), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60), (16 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 9 * 60 + 30), (14 * 60 + 30, 15 * 60), (16 * 60 + 30, 17 * 60)],\n        'Thursday': [(15 * 60 + 30, 16 * 60 + 30)],\n        'Friday': [(9 * 60 + 30, 11 * 60 + 30), (14 * 60 + 30, 15 * 60), (16 * 60, 17 * 60)]\n    }\n    \n    matthew_busy = {\n        'Monday': [(9 * 60, 10 * 60), (10 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 11 * 60), (12 * 60, 14 * 60 + 30), (16 * 60, 17 * 60)],\n        'Thursday': [(9 * 60, 16 * 60)],\n        'Friday': [(9 * 60, 17 * 60)]\n    }\n    \n    # Matthew's preference: not before 12:30 on Wednesday\n    matthew_preference = {\n        'Wednesday': 12 * 60 + 30\n    }\n    \n    meeting_duration = 60  # 1 hour in minutes\n    \n    for day in days:\n        # Check if day is Wednesday and apply Matthew's preference\n        if day == 'Wednesday':\n            start_candidate = max(work_start, matthew_preference.get(day, work_start))\n        else:\n            start_candidate = work_start\n        \n        # Collect all busy intervals for the day\n        busy_intervals = []\n        if day in diane_busy:\n            busy_intervals.extend(diane_busy[day])\n        if day in matthew_busy:\n            busy_intervals.extend(matthew_busy[day])\n        \n        # Sort busy intervals by start time\n        busy_intervals.sort()\n        \n        # Find free slots\n        current_time = start_candidate\n        for interval in busy_intervals:\n            if interval[0] > current_time:\n                # Check if there's enough time before the next busy interval\n                if interval[0] - current_time >= meeting_duration:\n                    # Found a suitable slot\n                    start_time = current_time\n                    end_time = start_time + meeting_duration\n                    # Format the time as HH:MM\n                    start_str = f\"{start_time // 60:02d}:{start_time % 60:02d}\"\n                    end_str = f\"{end_time // 60:02d}:{end_time % 60:02d}\"\n                    print(f\"{start_str}:{end_str}\")\n                    print(day)\n                    return\n            # Update current_time to the end of the current busy interval\n            current_time = max(current_time, interval[1])\n        \n        # Check after the last busy interval\n        if work_end - current_time >= meeting_duration:\n            start_time = current_time\n            end_time = start_time + meeting_duration\n            start_str = f\"{start_time // 60:02d}:{start_time % 60:02d}\"\n            end_str = f\"{end_time // 60:02d}:{end_time % 60:02d}\"\n            print(f\"{start_str}:{end_str}\")\n            print(day)\n            return\n    \n    print(\"No suitable time found.\")\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_985"
        }
    ]
}