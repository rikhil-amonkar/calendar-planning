{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "13:30",
                "end_time": "14:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "13:30",
                "end_time": "14:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes, day):\n    \"\"\"\n    Finds a meeting time that fits all participants' schedules.\n    \n    Args:\n        participants_schedules: List of lists of busy time ranges for each participant.\n        work_hours_start: Start of work hours in minutes from midnight (e.g., 9:00 AM is 540).\n        work_hours_end: End of work hours in minutes from midnight (e.g., 5:00 PM is 1020).\n        duration_minutes: Duration of the meeting in minutes.\n        day: Day of the week (e.g., \"Monday\").\n    \n    Returns:\n        A tuple of (start_time_str, end_time_str, day) if a slot is found, else None.\n    \"\"\"\n    # Convert all busy times to minutes and merge overlapping or adjacent ranges\n    def parse_time(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def to_time_str(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Collect all busy time ranges from all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy_range in schedule:\n            start, end = map(parse_time, busy_range.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy ranges by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy ranges\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Check the available slots between work hours and busy times\n    available_slots = []\n    prev_end = work_hours_start\n    \n    for start, end in merged_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_hours_end:\n        available_slots.append((prev_end, work_hours_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            return (to_time_str(meeting_start), to_time_str(meeting_end), day)\n    \n    return None\n\n# Define the participants' schedules\njames_schedule = [\n    \"11:30 to 12:00\",\n    \"14:30 to 15:00\"\n]\n\njohn_schedule = [\n    \"09:30 to 11:00\",\n    \"11:30 to 12:00\",\n    \"12:30 to 13:30\",\n    \"14:30 to 16:30\"\n]\n\n# Combine all participants' schedules\nparticipants_schedules = [james_schedule, john_schedule]\n\n# Define work hours and meeting duration\nwork_hours_start = 9 * 60  # 9:00 AM\nwork_hours_end = 17 * 60    # 5:00 PM\nduration_minutes = 60\nday = \"Monday\"\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes, day)\n\nif meeting_time:\n    start_time, end_time, day = meeting_time\n    print(f\"{start_time}:{end_time}:{day}\")\nelse:\n    print(\"No suitable meeting time found.\")\n```",
            "count": "calendar_scheduling_example_543"
        }
    ]
}