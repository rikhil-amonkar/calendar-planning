{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "13:30",
                "end_time": "14:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "13:30",
                "end_time": "14:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    participants = {\n        'Daniel': [],\n        'Kathleen': [('14:30', '15:30')],\n        'Carolyn': [('12:00', '12:30'), ('13:00', '13:30')],\n        'Roger': [],\n        'Cheryl': [('09:00', '09:30'), ('10:00', '11:30'), ('12:30', '13:30'), ('14:00', '17:00')],\n        'Virginia': [('09:30', '11:30'), ('12:00', '12:30'), ('13:00', '13:30'), ('14:30', '15:30'), ('16:00', '17:00')],\n        'Angela': [('09:30', '10:00'), ('10:30', '11:30'), ('12:00', '12:30'), ('13:00', '13:30'), ('14:00', '16:30')]\n    }\n    \n    # Roger's constraint: not before 12:30\n    roger_constraint = ('12:30', '17:00')\n    \n    # Work hours\n    work_start = '09:00'\n    work_end = '17:00'\n    \n    # Meeting duration in minutes\n    meeting_duration = 30\n    \n    # Convert time string to minutes since 00:00 for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Generate all busy intervals for all participants\n    busy_intervals = []\n    for person, intervals in participants.items():\n        for start, end in intervals:\n            busy_intervals.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Add Roger's constraint as a busy interval before 12:30\n    roger_constraint_start = time_to_minutes(roger_constraint[0])\n    busy_intervals.append((time_to_minutes(work_start), roger_constraint_start))\n    \n    # Sort intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_end = max(end, last_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find free slots between merged busy intervals\n    free_slots = []\n    previous_end = time_to_minutes(work_start)\n    for start, end in merged:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < time_to_minutes(work_end):\n        free_slots.append((previous_end, time_to_minutes(work_end)))\n    \n    # Filter free slots that can accommodate the meeting duration\n    possible_slots = []\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            possible_slots.append((start, end))\n    \n    # Select the earliest possible slot\n    if possible_slots:\n        meeting_start = possible_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        meeting_time = (minutes_to_time(meeting_start), minutes_to_time(meeting_end))\n        print(f\"{meeting_time[0]}:{meeting_time[1]}\")\n        print(\"Monday\")\n    else:\n        print(\"No suitable time found\")\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_476"
        }
    ]
}