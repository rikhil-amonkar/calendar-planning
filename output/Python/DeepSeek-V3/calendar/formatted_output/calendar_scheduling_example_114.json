{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "12:00",
                "end_time": "13:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "12:00",
                "end_time": "13:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - work_hours_start * 60\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_hh = (minutes + work_hours_start * 60) // 60\n        total_mm = (minutes + work_hours_start * 60) % 60\n        return f\"{total_hh:02d}:{total_mm:02d}\"\n\n    # Initialize the busy slots for all participants\n    busy_slots = []\n    for schedule in participants_schedules:\n        person_busy = []\n        for busy_range in schedule:\n            start, end = busy_range\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            person_busy.append((start_min, end_min))\n        busy_slots.append(person_busy)\n\n    # Find all possible free slots for each person\n    free_slots_per_person = []\n    for person_busy in busy_slots:\n        person_free = []\n        # Start from work hours start (0 in minutes since we subtracted work_hours_start)\n        prev_end = 0\n        # Sort busy slots by start time\n        sorted_busy = sorted(person_busy, key=lambda x: x[0])\n        for busy_start, busy_end in sorted_busy:\n            if busy_start > prev_end:\n                person_free.append((prev_end, busy_start))\n            prev_end = max(prev_end, busy_end)\n        # Check the slot after last busy slot until work hours end\n        work_end_min = (work_hours_end - work_hours_start) * 60\n        if prev_end < work_end_min:\n            person_free.append((prev_end, work_end_min))\n        free_slots_per_person.append(person_free)\n\n    # Find intersection of all free slots\n    common_free_slots = free_slots_per_person[0]\n    for person_free in free_slots_per_person[1:]:\n        new_common_free = []\n        i = j = 0\n        while i < len(common_free_slots) and j < len(person_free):\n            slot1_start, slot1_end = common_free_slots[i]\n            slot2_start, slot2_end = person_free[j]\n            # Find the overlap\n            overlap_start = max(slot1_start, slot2_start)\n            overlap_end = min(slot1_end, slot2_end)\n            if overlap_start < overlap_end:\n                new_common_free.append((overlap_start, overlap_end))\n            # Move the pointer which ends first\n            if slot1_end < slot2_end:\n                i += 1\n            else:\n                j += 1\n        common_free_slots = new_common_free\n\n    # Find the first slot that can fit the duration\n    duration_min = duration * 60\n    for slot_start, slot_end in common_free_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = minutes_to_time(slot_start)\n            meeting_end = minutes_to_time(slot_start + duration_min)\n            return meeting_start, meeting_end\n\n    return None, None\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [(\"10:00\", \"10:30\"), (\"16:00\", \"16:30\")],  # Stephanie\n    [(\"10:00\", \"10:30\"), (\"11:30\", \"12:00\"), (\"13:30\", \"14:00\"), (\"16:30\", \"17:00\")],  # Cheryl\n    [(\"09:30\", \"10:00\"), (\"10:30\", \"11:30\"), (\"13:30\", \"14:00\"), (\"14:30\", \"15:00\"), (\"15:30\", \"17:00\")],  # Bradley\n    [(\"09:00\", \"12:00\"), (\"13:00\", \"13:30\"), (\"14:30\", \"17:00\")],  # Steven\n]\n\n# Define meeting parameters\nmeeting_duration = 1  # in hours\nwork_hours_start = 9\nwork_hours_end = 17\nday_of_week = \"Monday\"\n\n# Find the meeting time\nmeeting_start, meeting_end = find_meeting_time(participants_schedules, meeting_duration, work_hours_start, work_hours_end)\n\n# Output the result\nif meeting_start and meeting_end:\n    print(f\"{meeting_start}:{meeting_end}\")\n    print(day_of_week)\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_114"
        }
    ]
}