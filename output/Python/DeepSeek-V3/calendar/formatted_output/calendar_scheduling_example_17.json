{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "12:00",
                "end_time": "12:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "12:00",
                "end_time": "12:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours, preferences):\n    # Parse work hours\n    work_start, work_end = work_hours.split(' to ')\n    work_start = int(work_start.split(':')[0]) * 60 + int(work_start.split(':')[1])\n    work_end = int(work_end.split(':')[0]) * 60 + int(work_end.split(':')[1])\n    \n    # Initialize available slots for each participant\n    available_slots = {}\n    for participant in participants_schedules:\n        # Start with the entire work day as available\n        available = [(work_start, work_end)]\n        # Subtract blocked times\n        for block in participants_schedules[participant]:\n            start, end = block.split(' to ')\n            start = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n            end = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n            new_available = []\n            for slot in available:\n                if slot[1] <= start or slot[0] >= end:\n                    new_available.append(slot)\n                else:\n                    if slot[0] < start:\n                        new_available.append((slot[0], start))\n                    if slot[1] > end:\n                        new_available.append((end, slot[1]))\n            available = new_available\n        available_slots[participant] = available\n    \n    # Apply Helen's preference (no meetings after 13:30)\n    if 'Helen' in preferences:\n        pref_start, pref_end = preferences['Helen'].split(' to ')\n        pref_end = int(pref_end.split(':')[0]) * 60 + int(pref_end.split(':')[1])\n        new_available = []\n        for slot in available_slots['Helen']:\n            if slot[0] >= pref_end:\n                continue\n            if slot[1] > pref_end:\n                new_available.append((slot[0], pref_end))\n            else:\n                new_available.append(slot)\n        available_slots['Helen'] = new_available\n    \n    # Find overlapping slots\n    common_slots = []\n    # Start with Helen's slots (as she has the most constraints)\n    for helen_slot in available_slots['Helen']:\n        # Check if Margaret and Donna are available during this slot\n        for margaret_slot in available_slots['Margaret']:\n            if margaret_slot[0] >= helen_slot[1] or margaret_slot[1] <= helen_slot[0]:\n                continue\n            margaret_overlap = (max(helen_slot[0], margaret_slot[0]), min(helen_slot[1], margaret_slot[1]))\n            for donna_slot in available_slots['Donna']:\n                if donna_slot[0] >= margaret_overlap[1] or donna_slot[1] <= margaret_overlap[0]:\n                    continue\n                donna_overlap = (max(margaret_overlap[0], donna_slot[0]), min(margaret_overlap[1], donna_slot[1]))\n                if donna_overlap[1] - donna_overlap[0] >= duration:\n                    common_slots.append(donna_overlap)\n    \n    # Select the first available slot that fits the duration\n    for slot in common_slots:\n        if slot[1] - slot[0] >= duration:\n            # Convert back to HH:MM format\n            start_hh = slot[0] // 60\n            start_mm = slot[0] % 60\n            end_hh = (slot[0] + duration) // 60\n            end_mm = (slot[0] + duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return None\n\n# Input data\nparticipants_schedules = {\n    'Margaret': ['9:00 to 10:00', '10:30 to 11:00', '11:30 to 12:00', '13:00 to 13:30', '15:00 to 15:30'],\n    'Donna': ['14:30 to 15:00', '16:00 to 16:30'],\n    'Helen': ['9:00 to 9:30', '10:00 to 11:30', '13:00 to 14:00', '14:30 to 15:00', '15:30 to 17:00']\n}\nduration = 30  # minutes\nwork_hours = '9:00 to 17:00'\npreferences = {'Helen': '9:00 to 13:30'}\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours, preferences)\nprint(f\"Monday:{meeting_time}\")\n```",
            "count": "calendar_scheduling_example_17"
        }
    ]
}