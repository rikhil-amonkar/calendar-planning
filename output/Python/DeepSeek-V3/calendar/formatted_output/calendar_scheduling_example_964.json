{
    "0shot": [
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "11:00",
                "end_time": "12:00"
            },
            "expected_time": {
                "day": "Tuesday",
                "start_time": "11:00",
                "end_time": "12:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(betty_busy, megan_busy, days, duration_hours=1, work_start=9, work_end=17):\n    for day in days:\n        # Initialize available time for the day\n        betty_available = [(work_start * 60, work_end * 60)]\n        megan_available = [(work_start * 60, work_end * 60)]\n        \n        # Subtract busy times for Betty\n        for busy in betty_busy.get(day, []):\n            start, end = busy\n            start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n            end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n            new_available = []\n            for slot in betty_available:\n                if end_min <= slot[0] or start_min >= slot[1]:\n                    new_available.append(slot)\n                else:\n                    if slot[0] < start_min:\n                        new_available.append((slot[0], start_min))\n                    if slot[1] > end_min:\n                        new_available.append((end_min, slot[1]))\n            betty_available = new_available\n        \n        # Subtract busy times for Megan\n        for busy in megan_busy.get(day, []):\n            start, end = busy\n            start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n            end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n            new_available = []\n            for slot in megan_available:\n                if end_min <= slot[0] or start_min >= slot[1]:\n                    new_available.append(slot)\n                else:\n                    if slot[0] < start_min:\n                        new_available.append((slot[0], start_min))\n                    if slot[1] > end_min:\n                        new_available.append((end_min, slot[1]))\n            megan_available = new_available\n        \n        # Find overlapping slots\n        for b_slot in betty_available:\n            for m_slot in megan_available:\n                overlap_start = max(b_slot[0], m_slot[0])\n                overlap_end = min(b_slot[1], m_slot[1])\n                if overlap_end - overlap_start >= duration_hours * 60:\n                    # Convert back to HH:MM format\n                    start_hh = overlap_start // 60\n                    start_mm = overlap_start % 60\n                    end_hh = (overlap_start + duration_hours * 60) // 60\n                    end_mm = (overlap_start + duration_hours * 60) % 60\n                    return day, f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return None, None\n\n# Define busy times\nbetty_busy = {\n    'Monday': [('10:00', '10:30'), ('11:30', '12:30'), ('16:00', '16:30')],\n    'Tuesday': [('9:30', '10:00'), ('10:30', '11:00'), ('12:00', '12:30'), ('13:30', '15:00'), ('16:30', '17:00')],\n    'Wednesday': [('13:30', '14:00'), ('14:30', '15:00')],\n    'Friday': [('9:00', '10:00'), ('11:30', '12:00'), ('12:30', '13:00'), ('14:30', '15:00')]\n}\n\nmegan_busy = {\n    'Monday': [('9:00', '17:00')],\n    'Tuesday': [('9:00', '9:30'), ('10:00', '10:30'), ('12:00', '14:00'), ('15:00', '15:30'), ('16:00', '16:30')],\n    'Wednesday': [('9:30', '10:30'), ('11:00', '11:30'), ('12:30', '13:00'), ('13:30', '14:30'), ('15:30', '17:00')],\n    'Thursday': [('9:00', '10:30'), ('11:30', '14:00'), ('14:30', '15:00'), ('15:30', '16:30')],\n    'Friday': [('9:00', '17:00')]\n}\n\n# Days to check (excluding Wednesday and Thursday as per Betty's constraint)\ndays_to_check = ['Tuesday']\n\nday, time_slot = find_meeting_time(betty_busy, megan_busy, days_to_check)\nif day and time_slot:\n    print(f\"{day}, {time_slot}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_964"
        }
    ]
}