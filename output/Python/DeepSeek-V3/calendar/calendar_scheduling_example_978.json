{
    "0shot": [
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "9:30",
                "end_time": "10:30"
            },
            "expected_time": {
                "day": "Tuesday",
                "start_time": "9:30",
                "end_time": "10:30"
            },
            "has_error": false,
            "raw_model_response": "```python\nfrom typing import Dict, List, Tuple\n\ndef find_meeting_time(brian_busy: Dict[str, List[Tuple[str, str]]], \n                     julia_busy: Dict[str, List[Tuple[str, str]]], \n                     duration: int = 60,\n                     work_hours: Tuple[str, str] = ('09:00', '17:00'),\n                     days_order: List[str] = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'],\n                     brian_avoid_days: List[str] = ['Monday']) -> Tuple[str, str]:\n    \"\"\"\n    Finds the earliest available meeting time for Brian and Julia.\n    \n    Args:\n        brian_busy: Dictionary mapping days to list of busy time ranges for Brian.\n        julia_busy: Dictionary mapping days to list of busy time ranges for Julia.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of start and end time of work hours in 'HH:MM' format.\n        days_order: List of days in order to check.\n        brian_avoid_days: List of days Brian wants to avoid.\n    \n    Returns:\n        A tuple of (day, time_range) where time_range is in 'HH:MM-HH:MM' format.\n    \"\"\"\n    def time_to_minutes(time_str: str) -> int:\n        \"\"\"Converts 'HH:MM' time string to minutes since midnight.\"\"\"\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes: int) -> str:\n        \"\"\"Converts minutes since midnight to 'HH:MM' time string.\"\"\"\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    def merge_busy_slots(busy_slots: List[Tuple[str, str]]) -> List[Tuple[int, int]]:\n        \"\"\"Merges overlapping or adjacent busy slots and converts to minutes.\"\"\"\n        if not busy_slots:\n            return []\n        # Convert to minutes and sort\n        slots = [(time_to_minutes(start), time_to_minutes(end)) for start, end in busy_slots]\n        slots.sort()\n        merged = [slots[0]]\n        for current_start, current_end in slots[1:]:\n            last_start, last_end = merged[-1]\n            if current_start <= last_end:\n                # Overlapping or adjacent, merge them\n                merged[-1] = (last_start, max(last_end, current_end))\n            else:\n                merged.append((current_start, current_end))\n        return merged\n    \n    work_start, work_end = map(time_to_minutes, work_hours)\n    \n    for day in days_order:\n        if day in brian_avoid_days:\n            continue\n        \n        # Get busy slots for both participants\n        brian_day_slots = brian_busy.get(day, [])\n        julia_day_slots = julia_busy.get(day, [])\n        \n        # Merge and combine busy slots\n        brian_merged = merge_busy_slots(brian_day_slots)\n        julia_merged = merge_busy_slots(julia_day_slots)\n        \n        # Combine all busy slots and sort\n        all_busy = brian_merged + julia_merged\n        all_busy.sort()\n        \n        # Find available slots\n        prev_end = work_start\n        available_slots = []\n        for busy_start, busy_end in all_busy:\n            if busy_start > prev_end:\n                available_slots.append((prev_end, busy_start))\n            prev_end = max(prev_end, busy_end)\n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n        \n        # Check for a slot that can fit the meeting\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + duration\n                time_range = f\"{minutes_to_time(meeting_start)}-{minutes_to_time(meeting_end)}\"\n                return (day, time_range)\n    \n    return (\"No day found\", \"\")\n\n# Define busy schedules\nbrian_busy = {\n    'Monday': [('9:30', '10:00'), ('12:30', '14:30'), ('15:30', '16:00')],\n    'Tuesday': [('9:00', '9:30')],\n    'Wednesday': [('12:30', '14:00'), ('16:30', '17:00')],\n    'Thursday': [('11:00', '11:30'), ('13:00', '13:30'), ('16:30', '17:00')],\n    'Friday': [('9:30', '10:00'), ('10:30', '11:00'), ('13:00', '13:30'), ('15:00', '16:00'), ('16:30', '17:00')]\n}\n\njulia_busy = {\n    'Monday': [('9:00', '10:00'), ('11:00', '11:30'), ('12:30', '13:00'), ('15:30', '16:00')],\n    'Tuesday': [('13:00', '14:00'), ('16:00', '16:30')],\n    'Wednesday': [('9:00', '11:30'), ('12:00', '12:30'), ('13:00', '17:00')],\n    'Thursday': [('9:00', '10:30'), ('11:00', '17:00')],\n    'Friday': [('9:00', '10:00'), ('10:30', '11:30'), ('12:30', '14:00'), ('14:30', '15:00'), ('15:30', '16:00')]\n}\n\n# Find meeting time\nday, time_range = find_meeting_time(brian_busy, julia_busy, duration=60, brian_avoid_days=['Monday'])\n\n# Output the result\nstart_time, end_time = time_range.split('-')\nprint(f\"{day} {start_time}:{end_time}\")\n```",
            "count": "calendar_scheduling_example_978"
        }
    ]
}