{
    "0shot": [
        {
            "final_program_time": {
                "day": "Wednesday",
                "start_time": "12:00",
                "end_time": "13:00"
            },
            "expected_time": {
                "day": "Wednesday",
                "start_time": "12:00",
                "end_time": "13:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    meeting_duration = 60  # minutes\n    \n    # Define blocked times for each participant per day in minutes since midnight\n    blocked_times = {\n        'Judith': {\n            'Monday': [(12 * 60, 12 * 60 + 30)],  # 12:00-12:30\n            'Wednesday': [(11 * 60 + 30, 12 * 60)]  # 11:30-12:00\n        },\n        'Timothy': {\n            'Monday': [\n                (9 * 60 + 30, 10 * 60),        # 9:30-10:00\n                (10 * 60 + 30, 11 * 60 + 30),  # 10:30-11:30\n                (12 * 60 + 30, 14 * 60),       # 12:30-14:00\n                (15 * 60 + 30, 17 * 60)        # 15:30-17:00\n            ],\n            'Tuesday': [\n                (9 * 60 + 30, 13 * 60),        # 9:30-13:00\n                (13 * 60 + 30, 14 * 60),       # 13:30-14:00\n                (14 * 60 + 30, 17 * 60)        # 14:30-17:00\n            ],\n            'Wednesday': [\n                (9 * 60, 9 * 60 + 30),         # 9:00-9:30\n                (10 * 60 + 30, 11 * 60),      # 10:30-11:00\n                (13 * 60 + 30, 14 * 60 + 30),  # 13:30-14:30\n                (15 * 60, 15 * 60 + 30),       # 15:00-15:30\n                (16 * 60, 16 * 60 + 30)        # 16:00-16:30\n            ]\n        }\n    }\n    \n    # Judith's preferences: avoid Monday and Wednesday before 12:00\n    preferred_days = ['Tuesday', 'Wednesday']\n    \n    # Iterate through days in preferred order\n    for day in preferred_days:\n        if day == 'Wednesday':\n            # On Wednesday, Judith prefers after 12:00\n            start_time = max(work_start, 12 * 60)\n        else:\n            start_time = work_start\n        \n        # Generate all possible slots for the day\n        current_time = start_time\n        while current_time + meeting_duration <= work_end:\n            slot_end = current_time + meeting_duration\n            conflict = False\n            \n            # Check Judith's availability\n            for block_start, block_end in blocked_times['Judith'].get(day, []):\n                if not (slot_end <= block_start or current_time >= block_end):\n                    conflict = True\n                    break\n            \n            # Check Timothy's availability if no conflict yet\n            if not conflict:\n                for block_start, block_end in blocked_times['Timothy'].get(day, []):\n                    if not (slot_end <= block_start or current_time >= block_end):\n                        conflict = True\n                        break\n            \n            if not conflict:\n                # Format the time as HH:MM:HH:MM\n                start_str = f\"{current_time // 60:02d}:{current_time % 60:02d}\"\n                end_str = f\"{slot_end // 60:02d}:{slot_end % 60:02d}\"\n                return f\"{day}: {start_str}:{end_str}\"\n            \n            current_time += 15  # Check in 15-minute increments\n    \n    # If no preferred day works, check Monday (though Judith prefers to avoid)\n    day = 'Monday'\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        conflict = False\n        \n        # Check Judith's availability\n        for block_start, block_end in blocked_times['Judith'].get(day, []):\n            if not (slot_end <= block_start or current_time >= block_end):\n                conflict = True\n                break\n        \n        # Check Timothy's availability if no conflict yet\n        if not conflict:\n            for block_start, block_end in blocked_times['Timothy'].get(day, []):\n                if not (slot_end <= block_start or current_time >= block_end):\n                    conflict = True\n                    break\n        \n        if not conflict:\n            # Format the time as HH:MM:HH:MM\n            start_str = f\"{current_time // 60:02d}:{current_time % 60:02d}\"\n            end_str = f\"{slot_end // 60:02d}:{slot_end % 60:02d}\"\n            return f\"{day}: {start_str}:{end_str}\"\n        \n        current_time += 15  # Check in 15-minute increments\n    \n    return \"No suitable time found.\"\n\n# Run the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_784"
        }
    ]
}