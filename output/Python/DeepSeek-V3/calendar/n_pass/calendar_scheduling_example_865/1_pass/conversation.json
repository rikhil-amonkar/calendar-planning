[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Megan and Daniel for one hour between the work hours of 9:00 to 17:00 on either Monday, Tuesday, Wednesday or Thursday. \n\nHere are the existing schedules for everyone during the days: \nMegan has meetings on Monday during 13:00 to 13:30, 14:00 to 15:30, Tuesday during 9:00 to 9:30, 12:00 to 12:30, 16:00 to 17:00, Wednesday during 9:30 to 10:00, 10:30 to 11:30, 12:30 to 14:00, 16:00 to 16:30, Thursday during 13:30 to 14:30, 15:00 to 15:30; \nDaniel is busy on Monday during 10:00 to 11:30, 12:30 to 15:00, Tuesday during 9:00 to 10:00, 10:30 to 17:00, Wednesday during 9:00 to 10:00, 10:30 to 11:30, 12:00 to 17:00, Thursday during 9:00 to 12:00, 12:30 to 14:30, 15:00 to 15:30, 16:00 to 17:00; \n\nThe group would like to meet at their earlist availability.\nFind a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\nfrom typing import List, Dict, Tuple\n\ndef parse_time(time_str: str) -> int:\n    \"\"\"Convert time string in HH:MM format to minutes since 9:00.\"\"\"\n    hh, mm = map(int, time_str.split(':'))\n    return (hh - 9) * 60 + mm\n\ndef format_time(minutes: int) -> str:\n    \"\"\"Convert minutes since 9:00 back to HH:MM format.\"\"\"\n    hh = 9 + minutes // 60\n    mm = minutes % 60\n    return f\"{hh:02d}:{mm:02d}\"\n\ndef find_earliest_meeting_time(\n    participants: List[Dict[str, List[Tuple[int, int]]]],\n    days: List[str],\n    duration: int,\n    work_start: str = \"9:00\",\n    work_end: str = \"17:00\"\n) -> Tuple[str, str]:\n    \"\"\"Find the earliest available meeting time for all participants.\"\"\"\n    work_start_min = parse_time(work_start)\n    work_end_min = parse_time(work_end)\n    total_slots = work_end_min - work_start_min\n    \n    for day_idx, day in enumerate(days):\n        # Initialize a list to track availability for each minute (True means available)\n        availability = [True] * total_slots\n        \n        for participant in participants:\n            # Get the participant's busy slots for the current day\n            busy_slots = participant.get(day, [])\n            for start, end in busy_slots:\n                # Mark the busy slots as unavailable\n                for minute in range(start, end):\n                    if minute < work_start_min or minute >= work_end_min:\n                        continue  # Outside work hours\n                    idx = minute - work_start_min\n                    if idx < len(availability):\n                        availability[idx] = False\n        \n        # Find the earliest available slot of the required duration\n        consecutive = 0\n        for minute in range(total_slots):\n            if availability[minute]:\n                consecutive += 1\n                if consecutive >= duration:\n                    start_minute = minute - duration + 1\n                    start_time = start_minute + work_start_min\n                    end_time = start_time + duration\n                    return day, f\"{format_time(start_time)}:{format_time(end_time)}\"\n            else:\n                consecutive = 0\n    return None, None\n\ndef main():\n    # Define work hours and meeting duration\n    work_start = \"9:00\"\n    work_end = \"17:00\"\n    duration = 60  # minutes\n    \n    # Define days to consider\n    days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\"]\n    \n    # Parse participants' schedules into minutes since 9:00\n    megan_schedule = {\n        \"Monday\": [(parse_time(\"13:00\"), parse_time(\"13:30\")),\n                   (parse_time(\"14:00\"), parse_time(\"15:30\"))],\n        \"Tuesday\": [(parse_time(\"9:00\"), parse_time(\"9:30\")),\n                    (parse_time(\"12:00\"), parse_time(\"12:30\")),\n                    (parse_time(\"16:00\"), parse_time(\"17:00\"))],\n        \"Wednesday\": [(parse_time(\"9:30\"), parse_time(\"10:00\")),\n                      (parse_time(\"10:30\"), parse_time(\"11:30\")),\n                      (parse_time(\"12:30\"), parse_time(\"14:00\")),\n                      (parse_time(\"16:00\"), parse_time(\"16:30\"))],\n        \"Thursday\": [(parse_time(\"13:30\"), parse_time(\"14:30\")),\n                      (parse_time(\"15:00\"), parse_time(\"15:30\"))]\n    }\n    \n    daniel_schedule = {\n        \"Monday\": [(parse_time(\"10:00\"), parse_time(\"11:30\")),\n                   (parse_time(\"12:30\"), parse_time(\"15:00\"))],\n        \"Tuesday\": [(parse_time(\"9:00\"), parse_time(\"10:00\")),\n                    (parse_time(\"10:30\"), parse_time(\"17:00\"))],\n        \"Wednesday\": [(parse_time(\"9:00\"), parse_time(\"10:00\")),\n                      (parse_time(\"10:30\"), parse_time(\"11:30\")),\n                      (parse_time(\"12:00\"), parse_time(\"17:00\"))],\n        \"Thursday\": [(parse_time(\"9:00\"), parse_time(\"12:00\")),\n                     (parse_time(\"12:30\"), parse_time(\"14:30\")),\n                     (parse_time(\"15:00\"), parse_time(\"15:30\")),\n                     (parse_time(\"16:00\"), parse_time(\"17:00\"))]\n    }\n    \n    participants = [megan_schedule, daniel_schedule]\n    \n    day, time_range = find_earliest_meeting_time(participants, days, duration, work_start, work_end)\n    \n    if day and time_range:\n        print(f\"{day}: {time_range}\")\n    else:\n        print(\"No suitable meeting time found.\")\n\nif __name__ == \"__main__\":\n    main()\n```"
    }
]