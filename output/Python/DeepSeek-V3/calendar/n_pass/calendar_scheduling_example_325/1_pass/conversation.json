[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Jose, Keith, Logan, Megan, Gary and Bobby for half an hour between the work hours of 9:00 to 17:00 on Monday. \n\nHere are the existing schedules for everyone during the day: \nJose has meetings on Monday during 11:00 to 11:30, 12:30 to 13:00; \nKeith has meetings on Monday during 14:00 to 14:30, 15:00 to 15:30; \nLogan is busy on Monday during 9:00 to 10:00, 12:00 to 12:30, 15:00 to 15:30; \nMegan has blocked their calendar on Monday during 9:00 to 10:30, 11:00 to 12:00, 13:00 to 13:30, 14:30 to 16:30; \nGary has blocked their calendar on Monday during 9:00 to 9:30, 10:00 to 10:30, 11:30 to 13:00, 13:30 to 14:00, 14:30 to 16:30; \nBobby is busy on Monday during 11:00 to 11:30, 12:00 to 12:30, 13:00 to 16:00; \n\nJose do not want to meet on Monday after 15:30. Find a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end, day, constraints=None):\n    \"\"\"\n    Find a meeting time that fits all participants' schedules and constraints.\n    \n    Args:\n        participants_schedules (dict): Dictionary with participant names as keys and list of busy time slots as values.\n        duration (int): Duration of the meeting in minutes.\n        work_hours_start (str): Start of work hours in 'HH:MM' format.\n        work_hours_end (str): End of work hours in 'HH:MM' format.\n        day (str): Day of the week for the meeting.\n        constraints (dict, optional): Additional constraints like 'not after' time. Defaults to None.\n    \n    Returns:\n        tuple: (start_time, end_time) in 'HH:MM' format, or None if no slot found.\n    \"\"\"\n    # Convert work hours to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Convert all busy slots to minutes\n    busy_slots = []\n    for participant, slots in participants_schedules.items():\n        for slot in slots:\n            start, end = map(time_to_minutes, slot.split(' to '))\n            busy_slots.append((start, end))\n    \n    # Add constraints (e.g., Jose doesn't want to meet after 15:30)\n    if constraints:\n        for name, constraint in constraints.items():\n            if name in participants_schedules:\n                constraint_time = time_to_minutes(constraint['not_after'])\n                # Add a busy slot from constraint_time to work_end for the participant\n                busy_slots.append((constraint_time, work_end))\n    \n    # Sort all busy slots by start time\n    busy_slots.sort()\n    \n    # Find free slots by merging busy slots and checking gaps\n    free_slots = []\n    prev_end = work_start\n    \n    for start, end in busy_slots:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    # Check the last slot after all busy slots\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n    \n    # Find the first free slot that can fit the meeting duration\n    duration_minutes = duration * 60  # Convert hours to minutes (assuming duration is in hours)\n    for start, end in free_slots:\n        if end - start >= duration_minutes:\n            # Convert back to 'HH:MM' format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            \n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration_minutes)\n            return (meeting_start, meeting_end)\n    \n    return None\n\n# Define participants' schedules\nparticipants_schedules = {\n    'Jose': ['11:00 to 11:30', '12:30 to 13:00'],\n    'Keith': ['14:00 to 14:30', '15:00 to 15:30'],\n    'Logan': ['09:00 to 10:00', '12:00 to 12:30', '15:00 to 15:30'],\n    'Megan': ['09:00 to 10:30', '11:00 to 12:00', '13:00 to 13:30', '14:30 to 16:30'],\n    'Gary': ['09:00 to 09:30', '10:00 to 10:30', '11:30 to 13:00', '13:30 to 14:00', '14:30 to 16:30'],\n    'Bobby': ['11:00 to 11:30', '12:00 to 12:30', '13:00 to 16:00']\n}\n\n# Define constraints\nconstraints = {\n    'Jose': {'not_after': '15:30'}\n}\n\n# Find meeting time\nmeeting_time = find_meeting_time(\n    participants_schedules,\n    duration=0.5,  # 30 minutes\n    work_hours_start='09:00',\n    work_hours_end='17:00',\n    day='Monday',\n    constraints=constraints\n)\n\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{{{start}:{end}}} {day}\")\nelse:\n    print(\"No suitable time found.\")\n```"
    }
]