[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Amy and Pamela for half an hour between the work hours of 9:00 to 17:00 on either Monday, Tuesday or Wednesday. \n\nHere are the existing schedules for everyone during the days: \nAmy is busy on Wednesday during 11:00 to 11:30, 13:30 to 14:00; \nPamela is busy on Monday during 9:00 to 10:30, 11:00 to 16:30, Tuesday during 9:00 to 9:30, 10:00 to 17:00, Wednesday during 9:00 to 9:30, 10:00 to 11:00, 11:30 to 13:30, 14:30 to 15:00, 16:00 to 16:30; \n\nPamela would like to avoid more meetings on Monday. Tuesday. Wednesday before 16:00. Find a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, days, work_hours_start, work_hours_end, duration, preferences):\n    \"\"\"\n    Find a suitable meeting time based on participants' schedules and preferences.\n    \n    Args:\n        participants: Dict of participant names to their busy times per day.\n        days: List of days to consider (e.g., ['Monday', 'Tuesday', 'Wednesday']).\n        work_hours_start: Start of workday in 'HH:MM' format.\n        work_hours_end: End of workday in 'HH:MM' format.\n        duration: Meeting duration in minutes.\n        preferences: Dict of participant names to their time preferences (avoidance rules).\n    \n    Returns:\n        Tuple of (day, start_time, end_time) or None if no time found.\n    \"\"\"\n    duration = timedelta(minutes=duration)\n    work_start = datetime.strptime(work_hours_start, '%H:%M').time()\n    work_end = datetime.strptime(work_hours_end, '%H:%M').time()\n    \n    for day in days:\n        # Collect all busy intervals for the day across participants\n        busy_intervals = []\n        for name, schedule in participants.items():\n            if day in schedule:\n                busy_intervals.extend(schedule[day])\n        \n        # Add preferences as busy intervals (e.g., avoid before 16:00)\n        for name, pref in preferences.items():\n            if day in pref.get('avoid_days', []):\n                # Entire day is avoided\n                busy_intervals.append((work_start, work_end))\n            if 'before' in pref and day in pref.get('avoid_days_before', []):\n                avoid_until = datetime.strptime(pref['before'], '%H:%M').time()\n                busy_intervals.append((work_start, avoid_until))\n        \n        # Sort busy intervals by start time\n        busy_intervals.sort()\n        \n        # Find free slots by checking gaps between busy intervals\n        prev_end = work_start\n        for start, end in busy_intervals:\n            if start > prev_end:\n                # Check if the gap is long enough\n                gap_start = prev_end\n                gap_end = start\n                if (datetime.combine(datetime.today(), gap_end) - \n                    datetime.combine(datetime.today(), gap_start) >= duration):\n                    return day, gap_start, gap_end\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy interval\n        if prev_end < work_end:\n            gap_start = prev_end\n            gap_end = work_end\n            if (datetime.combine(datetime.today(), gap_end) - \n                datetime.combine(datetime.today(), gap_start) >= duration):\n                return day, gap_start, gap_end\n    \n    return None\n\n# Define participants' schedules\nparticipants = {\n    'Amy': {\n        'Wednesday': [\n            (datetime.strptime('11:00', '%H:%M').time(), datetime.strptime('11:30', '%H:%M').time()),\n            (datetime.strptime('13:30', '%H:%M').time(), datetime.strptime('14:00', '%H:%M').time()),\n        ]\n    },\n    'Pamela': {\n        'Monday': [\n            (datetime.strptime('9:00', '%H:%M').time(), datetime.strptime('10:30', '%H:%M').time()),\n            (datetime.strptime('11:00', '%H:%M').time(), datetime.strptime('16:30', '%H:%M').time()),\n        ],\n        'Tuesday': [\n            (datetime.strptime('9:00', '%H:%M').time(), datetime.strptime('9:30', '%H:%M').time()),\n            (datetime.strptime('10:00', '%H:%M').time(), datetime.strptime('17:00', '%H:%M').time()),\n        ],\n        'Wednesday': [\n            (datetime.strptime('9:00', '%H:%M').time(), datetime.strptime('9:30', '%H:%M').time()),\n            (datetime.strptime('10:00', '%H:%M').time(), datetime.strptime('11:00', '%H:%M').time()),\n            (datetime.strptime('11:30', '%H:%M').time(), datetime.strptime('13:30', '%H:%M').time()),\n            (datetime.strptime('14:30', '%H:%M').time(), datetime.strptime('15:00', '%H:%M').time()),\n            (datetime.strptime('16:00', '%H:%M').time(), datetime.strptime('16:30', '%H:%M').time()),\n        ]\n    }\n}\n\n# Define preferences\npreferences = {\n    'Pamela': {\n        'avoid_days': ['Monday'],  # Avoid more meetings on Monday\n        'avoid_days_before': ['Tuesday', 'Wednesday'],  # Avoid before 16:00 on these days\n        'before': '16:00'\n    }\n}\n\n# Define meeting parameters\ndays = ['Monday', 'Tuesday', 'Wednesday']\nwork_hours_start = '9:00'\nwork_hours_end = '17:00'\nduration = 30  # minutes\n\n# Find meeting time\nresult = find_meeting_time(participants, days, work_hours_start, work_hours_end, duration, preferences)\n\nif result:\n    day, start_time, end_time = result\n    # Format output as HH:MM:HH:MM and day\n    start_str = start_time.strftime('%H:%M')\n    end_str = end_time.strftime('%H:%M')\n    print(f\"{day}: {{{start_str}:{end_str}}}\")\nelse:\n    print(\"No suitable time found.\")\n```"
    }
]