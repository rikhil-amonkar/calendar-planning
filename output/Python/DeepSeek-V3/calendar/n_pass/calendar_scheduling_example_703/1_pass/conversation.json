[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Stephanie and Betty for one hour between the work hours of 9:00 to 17:00 on either Monday, Tuesday or Wednesday. \n\nHere are the existing schedules for everyone during the days: \nStephanie has meetings on Monday during 9:30 to 10:00, 10:30 to 11:00, 11:30 to 12:00, 14:00 to 14:30, Tuesday during 12:00 to 13:00, Wednesday during 9:00 to 10:00, 13:00 to 14:00; \nBetty has meetings on Monday during 9:00 to 10:00, 11:00 to 11:30, 14:30 to 15:00, 15:30 to 16:00, Tuesday during 9:00 to 9:30, 11:30 to 12:00, 12:30 to 14:30, 15:30 to 16:00, Wednesday during 10:00 to 11:30, 12:00 to 14:00, 14:30 to 17:00; \n\nStephanie would like to avoid more meetings on Monday. Betty can not meet on Tuesday after 12:30. Find a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\nfrom typing import List, Dict, Tuple\n\ndef schedule_meeting(participants: List[str], \n                    days: List[str], \n                    work_hours: Tuple[str, str], \n                    duration: int, \n                    schedules: Dict[str, Dict[str, List[Tuple[str, str]]]], \n                    constraints: Dict[str, Dict[str, str]]) -> Tuple[str, str]:\n    # Parse work hours\n    work_start, work_end = work_hours\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Iterate through each day to find a suitable time\n    for day in days:\n        # Check Stephanie's preference to avoid Monday\n        if day == \"Monday\" and \"Stephanie\" in constraints and constraints[\"Stephanie\"].get(\"avoid_day\") == \"Monday\":\n            continue\n        \n        # Collect all busy intervals for the day for all participants\n        busy_intervals = []\n        for participant in participants:\n            if day in schedules[participant]:\n                for interval in schedules[participant][day]:\n                    start, end = interval\n                    busy_intervals.append((time_to_minutes(start), time_to_minutes(end)))\n        \n        # Add additional constraints (e.g., Betty cannot meet on Tuesday after 12:30)\n        if day == \"Tuesday\" and \"Betty\" in constraints and constraints[\"Betty\"].get(\"cannot_meet_after\") is not None:\n            cutoff_time = time_to_minutes(constraints[\"Betty\"][\"cannot_meet_after\"])\n            busy_intervals.append((cutoff_time, work_end_min))\n        \n        # Sort busy intervals by start time\n        busy_intervals.sort()\n        \n        # Find available slots\n        available_slots = []\n        prev_end = work_start_min\n        \n        for start, end in busy_intervals:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy interval\n        if prev_end < work_end_min:\n            available_slots.append((prev_end, work_end_min))\n        \n        # Check for a slot that can fit the duration\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + duration\n                return day, f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return None, None\n\ndef time_to_minutes(time_str: str) -> int:\n    hours, minutes = map(int, time_str.split(':'))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes: int) -> str:\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Input data\nparticipants = [\"Stephanie\", \"Betty\"]\ndays = [\"Monday\", \"Tuesday\", \"Wednesday\"]\nwork_hours = (\"9:00\", \"17:00\")\nduration = 60  # minutes\n\nschedules = {\n    \"Stephanie\": {\n        \"Monday\": [(\"9:30\", \"10:00\"), (\"10:30\", \"11:00\"), (\"11:30\", \"12:00\"), (\"14:00\", \"14:30\")],\n        \"Tuesday\": [(\"12:00\", \"13:00\")],\n        \"Wednesday\": [(\"9:00\", \"10:00\"), (\"13:00\", \"14:00\")],\n    },\n    \"Betty\": {\n        \"Monday\": [(\"9:00\", \"10:00\"), (\"11:00\", \"11:30\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:00\")],\n        \"Tuesday\": [(\"9:00\", \"9:30\"), (\"11:30\", \"12:00\"), (\"12:30\", \"14:30\"), (\"15:30\", \"16:00\")],\n        \"Wednesday\": [(\"10:00\", \"11:30\"), (\"12:00\", \"14:00\"), (\"14:30\", \"17:00\")],\n    }\n}\n\nconstraints = {\n    \"Stephanie\": {\"avoid_day\": \"Monday\"},\n    \"Betty\": {\"cannot_meet_after\": \"12:30\"}\n}\n\n# Find the meeting time\nday, time_range = schedule_meeting(participants, days, work_hours, duration, schedules, constraints)\n\n# Output the result\nif day and time_range:\n    start_time, end_time = time_range.split(':')\n    print(f\"{day}: {start_time}:{end_time}\")\nelse:\n    print(\"No suitable time found.\")\n```"
    }
]