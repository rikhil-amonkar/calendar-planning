[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Shirley and Albert for half an hour between the work hours of 9:00 to 17:00 on either Monday or Tuesday. \n\nHere are the existing schedules for everyone during the days: \nShirley has blocked their calendar on Monday during 10:30 to 11:00, 12:00 to 12:30, 16:00 to 16:30, Tuesday during 9:30 to 10:00; \nAlbert is busy on Monday during 9:00 to 17:00, Tuesday during 9:30 to 11:00, 11:30 to 12:30, 13:00 to 16:00, 16:30 to 17:00; \n\nShirley would rather not meet on Tuesday after 10:30. Find a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\nfrom typing import List, Dict, Tuple\n\ndef find_meeting_time(\n    participants: Dict[str, Dict[str, List[Tuple[str, str]]]],\n    work_hours: Tuple[str, str],\n    meeting_duration: int,\n    preferences: Dict[str, Dict[str, List[Tuple[str, str]]]] = None\n) -> Tuple[str, str]:\n    \"\"\"\n    Finds a suitable meeting time for all participants based on their schedules and preferences.\n    \n    Args:\n        participants: A dictionary where keys are participant names and values are dictionaries\n                      with days as keys and lists of busy time slots (as tuples of start and end times) as values.\n        work_hours: A tuple representing the start and end of work hours (e.g., (\"9:00\", \"17:00\").\n        meeting_duration: Duration of the meeting in minutes.\n        preferences: Optional dictionary of preferences similar to the participants' schedules.\n    \n    Returns:\n        A tuple containing the day and the meeting time slot (e.g., (\"Monday\", \"14:30:15:30\")).\n    \"\"\"\n    \n    def time_to_minutes(time_str: str) -> int:\n        \"\"\"Converts a time string (HH:MM) to minutes since midnight.\"\"\"\n        hours, minutes = map(int, time_str.split(':'))\n        return hours * 60 + minutes\n    \n    def minutes_to_time(minutes: int) -> str:\n        \"\"\"Converts minutes since midnight to a time string (HH:MM).\"\"\"\n        hours = minutes // 60\n        minutes = minutes % 60\n        return f\"{hours:02d}:{minutes:02d}\"\n    \n    work_start, work_end = work_hours\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    days = [\"Monday\", \"Tuesday\"]  # Only Monday and Tuesday as per the task\n    \n    for day in days:\n        # Collect all busy slots for all participants on this day\n        busy_slots = []\n        for participant, schedule in participants.items():\n            if day in schedule:\n                busy_slots.extend(schedule[day])\n        \n        # Convert busy slots to minutes and merge overlapping/adjacent slots\n        busy_minutes = []\n        for start, end in busy_slots:\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            busy_minutes.append((start_min, end_min))\n        \n        # Sort and merge busy slots\n        busy_minutes.sort()\n        merged_busy = []\n        for start, end in busy_minutes:\n            if not merged_busy:\n                merged_busy.append([start, end])\n            else:\n                last_start, last_end = merged_busy[-1]\n                if start <= last_end:\n                    merged_busy[-1][1] = max(end, last_end)\n                else:\n                    merged_busy.append([start, end])\n        \n        # Find available slots by inverting busy slots\n        available_slots = []\n        prev_end = work_start_min\n        for start, end in merged_busy:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end_min:\n            available_slots.append((prev_end, work_end_min))\n        \n        # Check each available slot for meeting duration\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= meeting_duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                \n                # Check preferences (if any)\n                valid = True\n                if preferences:\n                    for participant, pref in preferences.items():\n                        if day in pref:\n                            for pref_start, pref_end in pref[day]:\n                                pref_start_min = time_to_minutes(pref_start)\n                                pref_end_min = time_to_minutes(pref_end)\n                                if not (meeting_end <= pref_start_min or meeting_start >= pref_end_min):\n                                    valid = False\n                                    break\n                            if not valid:\n                                break\n                \n                if valid:\n                    time_slot = f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n                    return (day, time_slot)\n    \n    return (\"No day found\", \"No time found\")\n\n# Define participants' schedules\nparticipants = {\n    \"Shirley\": {\n        \"Monday\": [(\"10:30\", \"11:00\"), (\"12:00\", \"12:30\"), (\"16:00\", \"16:30\")],\n        \"Tuesday\": [(\"9:30\", \"10:00\")],\n    },\n    \"Albert\": {\n        \"Monday\": [(\"9:00\", \"17:00\")],\n        \"Tuesday\": [(\"9:30\", \"11:00\"), (\"11:30\", \"12:30\"), (\"13:00\", \"16:00\"), (\"16:30\", \"17:00\")],\n    },\n}\n\n# Define Shirley's preference (not after 10:30 on Tuesday)\npreferences = {\n    \"Shirley\": {\n        \"Tuesday\": [(\"10:30\", \"17:00\")],  # Prefers not to meet after 10:30\n    },\n}\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nmeeting_duration = 30  # minutes\n\n# Find meeting time\nday, time_slot = find_meeting_time(participants, work_hours, meeting_duration, preferences)\n\n# Output the result\nprint(f\"{day}, {time_slot}\")\n```"
    }
]