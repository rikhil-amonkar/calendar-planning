[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Eugene and Eric for half an hour between the work hours of 9:00 to 17:00 on either Monday, Tuesday, Wednesday, Thursday or Friday. \n\nHere are the existing schedules for everyone during the days: \nEugene is busy on Monday during 11:00 to 12:00, 13:30 to 14:00, 14:30 to 15:00, 16:00 to 16:30, Wednesday during 9:00 to 9:30, 11:00 to 11:30, 12:00 to 12:30, 13:30 to 15:00, Thursday during 9:30 to 10:00, 11:00 to 12:30, Friday during 10:30 to 11:00, 12:00 to 12:30, 13:00 to 13:30; \nEric is busy on Monday during 9:00 to 17:00, Tuesday during 9:00 to 17:00, Wednesday during 9:00 to 11:30, 12:00 to 14:00, 14:30 to 16:30, Thursday during 9:00 to 17:00, Friday during 9:00 to 11:00, 11:30 to 17:00; \n\nEric would like to avoid more meetings on Wednesday. Find a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\nfrom typing import List, Dict, Tuple\nimport datetime\n\ndef parse_time(time_str: str) -> datetime.time:\n    \"\"\"Parse a time string in HH:MM format into a datetime.time object.\"\"\"\n    return datetime.datetime.strptime(time_str, \"%H:%M\").time()\n\ndef time_to_minutes(time: datetime.time) -> int:\n    \"\"\"Convert a datetime.time object to total minutes since midnight.\"\"\"\n    return time.hour * 60 + time.minute\n\ndef minutes_to_time(minutes: int) -> datetime.time:\n    \"\"\"Convert total minutes since midnight to a datetime.time object.\"\"\"\n    return datetime.time(hour=minutes // 60, minute=minutes % 60)\n\ndef get_available_slots(busy_slots: List[Tuple[datetime.time, datetime.time]], \n                       work_start: datetime.time, \n                       work_end: datetime.time, \n                       duration: int) -> List[Tuple[datetime.time, datetime.time]]:\n    \"\"\"Calculate available time slots given busy slots, work hours, and meeting duration.\"\"\"\n    # Convert all times to minutes for easier calculation\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    busy_slots_min = [(time_to_minutes(start), time_to_minutes(end)) for start, end in busy_slots]\n    \n    # Initialize available slots\n    available_slots = []\n    \n    # Sort busy slots by start time\n    busy_slots_min.sort()\n    \n    # Check before first busy slot\n    first_busy_start = busy_slots_min[0][0] if busy_slots_min else work_end_min\n    if first_busy_start - work_start_min >= duration:\n        available_slots.append((work_start_min, first_busy_start))\n    \n    # Check between busy slots\n    for i in range(1, len(busy_slots_min)):\n        prev_end = busy_slots_min[i-1][1]\n        curr_start = busy_slots_min[i][0]\n        if curr_start - prev_end >= duration:\n            available_slots.append((prev_end, curr_start))\n    \n    # Check after last busy slot\n    if busy_slots_min:\n        last_busy_end = busy_slots_min[-1][1]\n        if work_end_min - last_busy_end >= duration:\n            available_slots.append((last_busy_end, work_end_min))\n    else:\n        if work_end_min - work_start_min >= duration:\n            available_slots.append((work_start_min, work_end_min))\n    \n    # Convert back to time objects\n    return [(minutes_to_time(start), minutes_to_time(end)) for start, end in available_slots]\n\ndef find_meeting_time(eugene_busy: Dict[str, List[Tuple[str, str]]], \n                      eric_busy: Dict[str, List[Tuple[str, str]]], \n                      days: List[str], \n                      work_start: str, \n                      work_end: str, \n                      duration: int,\n                      eric_preferred_days: List[str] = None) -> Tuple[str, Tuple[datetime.time, datetime.time]]:\n    \"\"\"Find a meeting time that works for both Eugene and Eric, considering their busy slots and preferences.\"\"\"\n    work_start_time = parse_time(work_start)\n    work_end_time = parse_time(work_end)\n    \n    # Convert busy slots to datetime.time objects\n    eugene_busy_converted = {}\n    for day, slots in eugene_busy.items():\n        eugene_day_slots = [(parse_time(start), parse_time(end)) for start, end in slots]\n        eugene_busy_converted[day] = eugene_day_slots\n    \n    eric_busy_converted = {}\n    for day, slots in eric_busy.items():\n        eric_day_slots = [(parse_time(start), parse_time(end)) for start, end in slots]\n        eric_busy_converted[day] = eric_day_slots\n    \n    # Check each day in order, prioritizing non-preferred days first if specified\n    if eric_preferred_days:\n        days_to_check = [day for day in days if day not in eric_preferred_days] + \\\n                       [day for day in days if day in eric_preferred_days]\n    else:\n        days_to_check = days\n    \n    for day in days_to_check:\n        # Get Eugene's available slots\n        eugene_busy_slots = eugene_busy_converted.get(day, [])\n        eugene_available = get_available_slots(eugene_busy_slots, work_start_time, work_end_time, duration)\n        \n        # Get Eric's available slots\n        eric_busy_slots = eric_busy_converted.get(day, [])\n        eric_available = get_available_slots(eric_busy_slots, work_start_time, work_end_time, duration)\n        \n        # Find overlapping slots\n        for eugene_slot in eugene_available:\n            for eric_slot in eric_available:\n                # Check if slots overlap\n                overlap_start = max(time_to_minutes(eugene_slot[0]), time_to_minutes(eric_slot[0]))\n                overlap_end = min(time_to_minutes(eugene_slot[1]), time_to_minutes(eric_slot[1]))\n                \n                if overlap_end - overlap_start >= duration:\n                    meeting_start = minutes_to_time(overlap_start)\n                    meeting_end = minutes_to_time(overlap_start + duration)\n                    return day, (meeting_start, meeting_end)\n    \n    raise ValueError(\"No suitable meeting time found.\")\n\n# Define the input data\neugene_busy = {\n    \"Monday\": [(\"11:00\", \"12:00\"), (\"13:30\", \"14:00\"), (\"14:30\", \"15:00\"), (\"16:00\", \"16:30\")],\n    \"Wednesday\": [(\"9:00\", \"9:30\"), (\"11:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:30\", \"15:00\")],\n    \"Thursday\": [(\"9:30\", \"10:00\"), (\"11:00\", \"12:30\")],\n    \"Friday\": [(\"10:30\", \"11:00\"), (\"12:00\", \"12:30\"), (\"13:00\", \"13:30\")],\n}\n\neric_busy = {\n    \"Monday\": [(\"9:00\", \"17:00\")],\n    \"Tuesday\": [(\"9:00\", \"17:00\")],\n    \"Wednesday\": [(\"9:00\", \"11:30\"), (\"12:00\", \"14:00\"), (\"14:30\", \"16:30\")],\n    \"Thursday\": [(\"9:00\", \"17:00\")],\n    \"Friday\": [(\"9:00\", \"11:00\"), (\"11:30\", \"17:00\")],\n}\n\ndays = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"]\nwork_start = \"9:00\"\nwork_end = \"17:00\"\nduration = 30  # minutes\neric_preferred_days = [\"Wednesday\"]  # Days to avoid (since Eric wants to avoid more meetings on Wednesday)\n\n# Find the meeting time\ntry:\n    day, (start_time, end_time) = find_meeting_time(\n        eugene_busy, eric_busy, days, work_start, work_end, duration, eric_preferred_days\n    )\n    # Format the output as HH:MM:HH:MM and day of the week\n    print(f\"{day}, {start_time.strftime('%H:%M')}:{end_time.strftime('%H:%M')}\")\nexcept ValueError as e:\n    print(e)\n```"
    }
]