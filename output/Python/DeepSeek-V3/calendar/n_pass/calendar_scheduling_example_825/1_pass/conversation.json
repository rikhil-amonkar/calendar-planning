[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Laura and Philip for one hour between the work hours of 9:00 to 17:00 on either Monday, Tuesday, Wednesday or Thursday. \n\nHere are the existing schedules for everyone during the days: \nLaura is busy on Monday during 10:30 to 11:00, 12:30 to 13:00, 14:30 to 15:30, 16:00 to 17:00, Tuesday during 9:30 to 10:00, 11:00 to 11:30, 13:00 to 13:30, 14:30 to 15:00, 16:00 to 17:00, Wednesday during 11:30 to 12:00, 12:30 to 13:00, 15:30 to 16:30, Thursday during 10:30 to 11:00, 12:00 to 13:30, 15:00 to 15:30, 16:00 to 16:30; \nPhilip has meetings on Monday during 9:00 to 17:00, Tuesday during 9:00 to 11:00, 11:30 to 12:00, 13:00 to 13:30, 14:00 to 14:30, 15:00 to 16:30, Wednesday during 9:00 to 10:00, 11:00 to 12:00, 12:30 to 16:00, 16:30 to 17:00, Thursday during 9:00 to 10:30, 11:00 to 12:30, 13:00 to 17:00; \n\nPhilip can not meet on Wednesday. Find a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\nfrom typing import List, Dict, Tuple\n\ndef parse_time(time_str: str) -> int:\n    \"\"\"Convert time string in format HH:MM to minutes since midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(':'))\n    return hours * 60 + minutes\n\ndef format_time(minutes: int) -> str:\n    \"\"\"Convert minutes since midnight to time string in format HH:MM.\"\"\"\n    hours = minutes // 60\n    minutes = minutes % 60\n    return f\"{hours:02d}:{minutes:02d}\"\n\ndef find_available_slot(\n    participants: List[Dict[str, List[Tuple[int, int]]]],\n    work_hours: Tuple[int, int],\n    duration: int,\n    days: List[str],\n    constraints: Dict[str, List[str]] = None\n) -> Tuple[str, Tuple[int, int]]:\n    \"\"\"\n    Find an available meeting slot that fits all participants' schedules.\n    \n    Args:\n        participants: List of participants' busy slots per day in minutes.\n        work_hours: Tuple of (start, end) in minutes.\n        duration: Meeting duration in minutes.\n        days: List of days to consider.\n        constraints: Optional constraints per participant (e.g., cannot meet on certain days).\n    \n    Returns:\n        Tuple of (day, (start, end)) in minutes if found, else (None, None).\n    \"\"\"\n    if constraints is None:\n        constraints = {}\n    \n    for day_idx, day in enumerate(days):\n        # Check if day is constrained for any participant\n        skip_day = False\n        for participant in participants:\n            name = participant.get('name', '')\n            if name in constraints and day in constraints[name]:\n                skip_day = True\n                break\n        if skip_day:\n            continue\n        \n        # Collect all busy slots for the day\n        busy_slots = []\n        for participant in participants:\n            busy_slots.extend(participant['busy_slots'][day_idx])\n        \n        # Sort and merge overlapping busy slots\n        busy_slots.sort()\n        merged = []\n        for start, end in busy_slots:\n            if not merged:\n                merged.append([start, end])\n            else:\n                last_start, last_end = merged[-1]\n                if start <= last_end:\n                    merged[-1][1] = max(end, last_end)\n                else:\n                    merged.append([start, end])\n        \n        # Find available slots between work hours\n        prev_end = work_hours[0]\n        for start, end in merged:\n            if start > prev_end and start - prev_end >= duration:\n                return day, (prev_end, prev_end + duration)\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy slot\n        if work_hours[1] - prev_end >= duration:\n            return day, (prev_end, prev_end + duration)\n    \n    return None, None\n\ndef main():\n    # Define work hours (9:00 to 17:00)\n    work_start = parse_time(\"09:00\")\n    work_end = parse_time(\"17:00\")\n    work_hours = (work_start, work_end)\n    \n    # Define meeting duration (1 hour)\n    duration = 60\n    \n    # Define days to consider\n    days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\"]\n    \n    # Define participants' busy slots (in minutes since midnight)\n    laura_busy = {\n        \"Monday\": [\n            (parse_time(\"10:30\"), parse_time(\"11:00\")),\n            (parse_time(\"12:30\"), parse_time(\"13:00\")),\n            (parse_time(\"14:30\"), parse_time(\"15:30\")),\n            (parse_time(\"16:00\"), parse_time(\"17:00\"))\n        ],\n        \"Tuesday\": [\n            (parse_time(\"09:30\"), parse_time(\"10:00\")),\n            (parse_time(\"11:00\"), parse_time(\"11:30\")),\n            (parse_time(\"13:00\"), parse_time(\"13:30\")),\n            (parse_time(\"14:30\"), parse_time(\"15:00\")),\n            (parse_time(\"16:00\"), parse_time(\"17:00\"))\n        ],\n        \"Wednesday\": [\n            (parse_time(\"11:30\"), parse_time(\"12:00\")),\n            (parse_time(\"12:30\"), parse_time(\"13:00\")),\n            (parse_time(\"15:30\"), parse_time(\"16:30\"))\n        ],\n        \"Thursday\": [\n            (parse_time(\"10:30\"), parse_time(\"11:00\")),\n            (parse_time(\"12:00\"), parse_time(\"13:30\")),\n            (parse_time(\"15:00\"), parse_time(\"15:30\")),\n            (parse_time(\"16:00\"), parse_time(\"16:30\"))\n        ]\n    }\n    \n    philip_busy = {\n        \"Monday\": [\n            (parse_time(\"09:00\"), parse_time(\"17:00\"))\n        ],\n        \"Tuesday\": [\n            (parse_time(\"09:00\"), parse_time(\"11:00\")),\n            (parse_time(\"11:30\"), parse_time(\"12:00\")),\n            (parse_time(\"13:00\"), parse_time(\"13:30\")),\n            (parse_time(\"14:00\"), parse_time(\"14:30\")),\n            (parse_time(\"15:00\"), parse_time(\"16:30\"))\n        ],\n        \"Wednesday\": [\n            (parse_time(\"09:00\"), parse_time(\"10:00\")),\n            (parse_time(\"11:00\"), parse_time(\"12:00\")),\n            (parse_time(\"12:30\"), parse_time(\"16:00\")),\n            (parse_time(\"16:30\"), parse_time(\"17:00\"))\n        ],\n        \"Thursday\": [\n            (parse_time(\"09:00\"), parse_time(\"10:30\")),\n            (parse_time(\"11:00\"), parse_time(\"12:30\")),\n            (parse_time(\"13:00\"), parse_time(\"17:00\"))\n        ]\n    }\n    \n    # Convert busy slots to list format per day\n    laura_slots = []\n    philip_slots = []\n    for day in days:\n        laura_slots.append(laura_busy.get(day, []))\n        philip_slots.append(philip_busy.get(day, []))\n    \n    participants = [\n        {\"name\": \"Laura\", \"busy_slots\": laura_slots},\n        {\"name\": \"Philip\", \"busy_slots\": philip_slots}\n    ]\n    \n    # Define constraints (Philip cannot meet on Wednesday)\n    constraints = {\n        \"Philip\": [\"Wednesday\"]\n    }\n    \n    # Find available slot\n    day, (start, end) = find_available_slot(\n        participants, work_hours, duration, days, constraints\n    )\n    \n    if day:\n        start_str = format_time(start)\n        end_str = format_time(end)\n        print(f\"{day}: {start_str}:{end_str}\")\n    else:\n        print(\"No available slot found.\")\n\nif __name__ == \"__main__\":\n    main()\n```"
    }
]