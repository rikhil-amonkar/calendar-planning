[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Terry and Frances for half an hour between the work hours of 9:00 to 17:00 on either Monday, Tuesday, Wednesday, Thursday or Friday. \n\nHere are the existing schedules for everyone during the days: \nTerry is busy on Monday during 10:30 to 11:00, 12:30 to 14:00, 15:00 to 17:00, Tuesday during 9:30 to 10:00, 10:30 to 11:00, 14:00 to 14:30, 16:00 to 16:30, Wednesday during 9:30 to 10:30, 11:00 to 12:00, 13:00 to 13:30, 15:00 to 16:00, 16:30 to 17:00, Thursday during 9:30 to 10:00, 12:00 to 12:30, 13:00 to 14:30, 16:00 to 16:30, Friday during 9:00 to 11:30, 12:00 to 12:30, 13:30 to 16:00, 16:30 to 17:00; \nFrances has blocked their calendar on Monday during 9:30 to 11:00, 11:30 to 13:00, 14:00 to 14:30, 15:00 to 16:00, Tuesday during 9:00 to 9:30, 10:00 to 10:30, 11:00 to 12:00, 13:00 to 14:30, 15:30 to 16:30, Wednesday during 9:30 to 10:00, 10:30 to 11:00, 11:30 to 16:00, 16:30 to 17:00, Thursday during 11:00 to 12:30, 14:30 to 17:00, Friday during 9:30 to 10:30, 11:00 to 12:30, 13:00 to 16:00, 16:30 to 17:00; \n\nFrances would like to avoid more meetings on Tuesday. You would like to schedule the meeting at their earlist availability.\nFind a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\nfrom datetime import datetime, timedelta\n\ndef parse_time(time_str):\n    return datetime.strptime(time_str, \"%H:%M\").time()\n\ndef time_to_minutes(time_obj):\n    return time_obj.hour * 60 + time_obj.minute\n\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    minutes = minutes % 60\n    return datetime.strptime(f\"{hours:02d}:{minutes:02d}\", \"%H:%M\").time()\n\ndef get_available_slots(busy_slots, work_start, work_end, duration):\n    available = []\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Sort busy slots by start time\n    busy_slots.sort(key=lambda x: x[0])\n    \n    # Check before first busy slot\n    first_busy_start = busy_slots[0][0] if busy_slots else work_end_min\n    if first_busy_start - work_start_min >= duration:\n        available.append((work_start_min, first_busy_start))\n    \n    # Check between busy slots\n    for i in range(1, len(busy_slots)):\n        prev_end = busy_slots[i-1][1]\n        curr_start = busy_slots[i][0]\n        if curr_start - prev_end >= duration:\n            available.append((prev_end, curr_start))\n    \n    # Check after last busy slot\n    if busy_slots:\n        last_busy_end = busy_slots[-1][1]\n        if work_end_min - last_busy_end >= duration:\n            available.append((last_busy_end, work_end_min))\n    else:\n        available.append((work_start_min, work_end_min))\n    \n    return available\n\ndef find_earliest_meeting_time(terry_busy, frances_busy, days, duration, work_start, work_end, avoid_day=None):\n    work_start_time = parse_time(work_start)\n    work_end_time = parse_time(work_end)\n    duration_min = duration\n    \n    for day in days:\n        if avoid_day and day == avoid_day:\n            continue\n        \n        # Get Terry's busy slots for the day\n        terry_day_busy = []\n        for slot in terry_busy.get(day, []):\n            start = time_to_minutes(parse_time(slot[0]))\n            end = time_to_minutes(parse_time(slot[1]))\n            terry_day_busy.append((start, end))\n        \n        # Get Frances's busy slots for the day\n        frances_day_busy = []\n        for slot in frances_busy.get(day, []):\n            start = time_to_minutes(parse_time(slot[0]))\n            end = time_to_minutes(parse_time(slot[1]))\n            frances_day_busy.append((start, end))\n        \n        # Get available slots for Terry\n        terry_available = get_available_slots(terry_day_busy, work_start_time, work_end_time, duration_min)\n        \n        # Get available slots for Frances\n        frances_available = get_available_slots(frances_day_busy, work_start_time, work_end_time, duration_min)\n        \n        # Find overlapping slots\n        for t_start, t_end in terry_available:\n            for f_start, f_end in frances_available:\n                overlap_start = max(t_start, f_start)\n                overlap_end = min(t_end, f_end)\n                if overlap_end - overlap_start >= duration_min:\n                    meeting_start = minutes_to_time(overlap_start)\n                    meeting_end = minutes_to_time(overlap_start + duration_min)\n                    return day, meeting_start, meeting_end\n    \n    return None, None, None\n\n# Define work hours and meeting duration\nwork_start = \"09:00\"\nwork_end = \"17:00\"\nduration = 30  # minutes\navoid_day = \"Tuesday\"  # Frances prefers to avoid Tuesday\n\n# Define busy slots for Terry and Frances\nterry_busy = {\n    \"Monday\": [(\"10:30\", \"11:00\"), (\"12:30\", \"14:00\"), (\"15:00\", \"17:00\")],\n    \"Tuesday\": [(\"9:30\", \"10:00\"), (\"10:30\", \"11:00\"), (\"14:00\", \"14:30\"), (\"16:00\", \"16:30\")],\n    \"Wednesday\": [(\"9:30\", \"10:30\"), (\"11:00\", \"12:00\"), (\"13:00\", \"13:30\"), (\"15:00\", \"16:00\"), (\"16:30\", \"17:00\")],\n    \"Thursday\": [(\"9:30\", \"10:00\"), (\"12:00\", \"12:30\"), (\"13:00\", \"14:30\"), (\"16:00\", \"16:30\")],\n    \"Friday\": [(\"9:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:30\", \"16:00\"), (\"16:30\", \"17:00\")]\n}\n\nfrances_busy = {\n    \"Monday\": [(\"9:30\", \"11:00\"), (\"11:30\", \"13:00\"), (\"14:00\", \"14:30\"), (\"15:00\", \"16:00\")],\n    \"Tuesday\": [(\"9:00\", \"9:30\"), (\"10:00\", \"10:30\"), (\"11:00\", \"12:00\"), (\"13:00\", \"14:30\"), (\"15:30\", \"16:30\")],\n    \"Wednesday\": [(\"9:30\", \"10:00\"), (\"10:30\", \"11:00\"), (\"11:30\", \"16:00\"), (\"16:30\", \"17:00\")],\n    \"Thursday\": [(\"11:00\", \"12:30\"), (\"14:30\", \"17:00\")],\n    \"Friday\": [(\"9:30\", \"10:30\"), (\"11:00\", \"12:30\"), (\"13:00\", \"16:00\"), (\"16:30\", \"17:00\")]\n}\n\ndays = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"]\n\n# Find the earliest meeting time\nday, start_time, end_time = find_earliest_meeting_time(\n    terry_busy, frances_busy, days, duration, work_start, work_end, avoid_day\n)\n\n# Output the result\nif day and start_time and end_time:\n    print(f\"{day}: {start_time.strftime('%H:%M')}:{end_time.strftime('%H:%M')}\")\nelse:\n    print(\"No suitable meeting time found.\")\n```"
    }
]