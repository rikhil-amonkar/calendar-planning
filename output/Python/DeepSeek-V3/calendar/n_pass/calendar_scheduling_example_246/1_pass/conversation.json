[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Jacob, Diana, Adam, Angela and Dennis for half an hour between the work hours of 9:00 to 17:00 on Monday. \n\nHere are the existing schedules for everyone during the day: \nJacob is busy on Monday during 13:30 to 14:00, 14:30 to 15:00; \nDiana has blocked their calendar on Monday during 9:30 to 10:00, 11:30 to 12:00, 13:00 to 13:30, 16:00 to 16:30; \nAdam has meetings on Monday during 9:30 to 10:30, 11:00 to 12:30, 15:30 to 16:00; \nAngela is busy on Monday during 9:30 to 10:00, 10:30 to 12:00, 13:00 to 15:30, 16:00 to 16:30; \nDennis has meetings on Monday during 9:00 to 9:30, 10:30 to 11:30, 13:00 to 15:00, 16:30 to 17:00; \n\nFind a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\ndef find_meeting_time(participants_schedules, day, work_hours_start, work_hours_end, duration_minutes):\n    # Convert work hours to minutes since midnight for easier calculation\n    work_start = work_hours_start[0] * 60 + work_hours_start[1]\n    work_end = work_hours_end[0] * 60 + work_hours_end[1]\n    \n    # Initialize the free slots for all participants\n    free_slots = []\n    \n    # Generate busy slots for each participant and find their free slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start = busy[0][0] * 60 + busy[0][1]\n            end = busy[1][0] * 60 + busy[1][1]\n            busy_slots.append((start, end))\n        \n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Find free slots by checking gaps between busy slots and work hours\n        free = []\n        previous_end = work_start\n        for busy_start, busy_end in busy_slots:\n            if busy_start > previous_end:\n                free.append((previous_end, busy_start))\n            previous_end = max(previous_end, busy_end)\n        if previous_end < work_end:\n            free.append((previous_end, work_end))\n        \n        free_slots.append(free)\n    \n    # Find common free slots across all participants\n    common_free_slots = free_slots[0]\n    for participant_free in free_slots[1:]:\n        new_common = []\n        i = j = 0\n        while i < len(common_free_slots) and j < len(participant_free):\n            slot1 = common_free_slots[i]\n            slot2 = participant_free[j]\n            # Find overlap between slot1 and slot2\n            overlap_start = max(slot1[0], slot2[0])\n            overlap_end = min(slot1[1], slot2[1])\n            if overlap_start < overlap_end:\n                new_common.append((overlap_start, overlap_end))\n            # Move the pointer which ends first\n            if slot1[1] < slot2[1]:\n                i += 1\n            else:\n                j += 1\n        common_free_slots = new_common\n    \n    # Find the first common free slot that can fit the meeting duration\n    for slot in common_free_slots:\n        if slot[1] - slot[0] >= duration_minutes:\n            # Convert back to HH:MM format\n            start_hh = slot[0] // 60\n            start_mm = slot[0] % 60\n            end_hh = (slot[0] + duration_minutes) // 60\n            end_mm = (slot[0] + duration_minutes) % 60\n            return f\"{day}: {start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found.\"\n\n# Define the participants' schedules in the format [((HH, MM), (HH, MM)), ...]\nparticipants_schedules = [\n    [((13, 30), (14, 00)), ((14, 30), (15, 00))],  # Jacob\n    [((9, 30), (10, 00)), ((11, 30), (12, 00)), ((13, 00), (13, 30)), ((16, 00), (16, 30))],  # Diana\n    [((9, 30), (10, 30)), ((11, 00), (12, 30)), ((15, 30), (16, 00))],  # Adam\n    [((9, 30), (10, 00)), ((10, 30), (12, 00)), ((13, 00), (15, 30)), ((16, 00), (16, 30))],  # Angela\n    [((9, 00), (9, 30)), ((10, 30), (11, 30)), ((13, 00), (15, 00)), ((16, 30), (17, 00))],  # Dennis\n]\n\n# Define meeting parameters\nday = \"Monday\"\nwork_hours_start = (9, 0)  # 9:00\nwork_hours_end = (17, 0)    # 17:00\nduration_minutes = 30\n\n# Find and print the meeting time\nprint(find_meeting_time(participants_schedules, day, work_hours_start, work_hours_end, duration_minutes))\n```"
    }
]