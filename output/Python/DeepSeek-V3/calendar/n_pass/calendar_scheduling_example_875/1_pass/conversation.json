[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Natalie and William for one hour between the work hours of 9:00 to 17:00 on either Monday, Tuesday, Wednesday or Thursday. \n\nHere are the existing schedules for everyone during the days: \nNatalie is busy on Monday during 9:00 to 9:30, 10:00 to 12:00, 12:30 to 13:00, 14:00 to 14:30, 15:00 to 16:30, Tuesday during 9:00 to 9:30, 10:00 to 10:30, 12:30 to 14:00, 16:00 to 17:00, Wednesday during 11:00 to 11:30, 16:00 to 16:30, Thursday during 10:00 to 11:00, 11:30 to 15:00, 15:30 to 16:00, 16:30 to 17:00; \nWilliam is busy on Monday during 9:30 to 11:00, 11:30 to 17:00, Tuesday during 9:00 to 13:00, 13:30 to 16:00, Wednesday during 9:00 to 12:30, 13:00 to 14:30, 15:30 to 16:00, 16:30 to 17:00, Thursday during 9:00 to 10:30, 11:00 to 11:30, 12:00 to 12:30, 13:00 to 14:00, 15:00 to 17:00; \n\nFind a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\nfrom typing import List, Dict, Tuple\n\ndef parse_time(time_str: str) -> int:\n    \"\"\"Convert time string in HH:MM format to minutes since 9:00.\"\"\"\n    hh, mm = map(int, time_str.split(':'))\n    return (hh - 9) * 60 + mm\n\ndef format_time(minutes: int) -> str:\n    \"\"\"Convert minutes since 9:00 back to HH:MM format.\"\"\"\n    hh = 9 + minutes // 60\n    mm = minutes % 60\n    return f\"{hh:02d}:{mm:02d}\"\n\ndef find_available_slot(\n    schedules: Dict[str, List[Tuple[int, int]]],\n    duration: int,\n    days: List[str],\n    work_start: str = \"9:00\",\n    work_end: str = \"17:00\"\n) -> Tuple[str, str]:\n    \"\"\"Find the first available meeting slot that fits all participants' schedules.\n    \n    Args:\n        schedules: Dictionary where keys are participant names and values are lists of busy intervals (in HH:MM format).\n        duration: Meeting duration in minutes.\n        days: List of days to consider (e.g., [\"Monday\", \"Tuesday\"]).\n        work_start: Start of workday in HH:MM format.\n        work_end: End of workday in HH:MM format.\n    \n    Returns:\n        Tuple of (day, time_range) where time_range is in \"HH:MM-HH:MM\" format.\n    \"\"\"\n    work_start_min = parse_time(work_start)\n    work_end_min = parse_time(work_end)\n    \n    for day in days:\n        # Collect all busy intervals for the day\n        all_busy = []\n        for participant in schedules.values():\n            all_busy.extend(participant.get(day, []))\n        \n        # Merge overlapping or adjacent busy intervals\n        if not all_busy:\n            # No busy intervals, entire day is free\n            return (day, f\"{work_start}-{format_time(parse_time(work_start) + duration)}\")\n        \n        # Sort intervals by start time\n        all_busy.sort()\n        merged = [all_busy[0]]\n        for current in all_busy[1:]:\n            last = merged[-1]\n            if current[0] <= last[1]:\n                # Overlapping or adjacent, merge them\n                merged[-1] = (last[0], max(last[1], current[1]))\n            else:\n                merged.append(current)\n        \n        # Check for available slots between busy intervals\n        prev_end = work_start_min\n        for busy_start, busy_end in merged:\n            if busy_start - prev_end >= duration:\n                # Found a slot\n                start_time = format_time(prev_end)\n                end_time = format_time(prev_end + duration)\n                return (day, f\"{start_time}-{end_time}\")\n            prev_end = max(prev_end, busy_end)\n        \n        # Check after last busy interval\n        if work_end_min - prev_end >= duration:\n            start_time = format_time(prev_end)\n            end_time = format_time(prev_end + duration)\n            return (day, f\"{start_time}-{end_time}\")\n    \n    raise ValueError(\"No available slot found\")\n\ndef main():\n    # Define schedules for each participant\n    natalie_schedule = {\n        \"Monday\": [(\"9:00\", \"9:30\"), (\"10:00\", \"12:00\"), (\"12:30\", \"13:00\"), (\"14:00\", \"14:30\"), (\"15:00\", \"16:30\")],\n        \"Tuesday\": [(\"9:00\", \"9:30\"), (\"10:00\", \"10:30\"), (\"12:30\", \"14:00\"), (\"16:00\", \"17:00\")],\n        \"Wednesday\": [(\"11:00\", \"11:30\"), (\"16:00\", \"16:30\")],\n        \"Thursday\": [(\"10:00\", \"11:00\"), (\"11:30\", \"15:00\"), (\"15:30\", \"16:00\"), (\"16:30\", \"17:00\")],\n    }\n    \n    william_schedule = {\n        \"Monday\": [(\"9:30\", \"11:00\"), (\"11:30\", \"17:00\")],\n        \"Tuesday\": [(\"9:00\", \"13:00\"), (\"13:30\", \"16:00\")],\n        \"Wednesday\": [(\"9:00\", \"12:30\"), (\"13:00\", \"14:30\"), (\"15:30\", \"16:00\"), (\"16:30\", \"17:00\")],\n        \"Thursday\": [(\"9:00\", \"10:30\"), (\"11:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"14:00\"), (\"15:00\", \"17:00\")],\n    }\n    \n    # Convert schedules to minutes since 9:00 for easier processing\n    def convert_schedule(schedule):\n        converted = {}\n        for day, intervals in schedule.items():\n            converted[day] = [(parse_time(start), parse_time(end)) for start, end in intervals]\n        return converted\n    \n    natalie_converted = convert_schedule(natalie_schedule)\n    william_converted = convert_schedule(william_schedule)\n    \n    schedules = {\n        \"Natalie\": natalie_converted,\n        \"William\": william_converted,\n    }\n    \n    # Find available slot\n    days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\"]\n    duration = 60  # 1 hour\n    \n    day, time_range = find_available_slot(schedules, duration, days)\n    print(f\"{day}: {time_range}\")\n\nif __name__ == \"__main__\":\n    main()\n```"
    }
]