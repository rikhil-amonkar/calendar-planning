[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Diane and Matthew for one hour between the work hours of 9:00 to 17:00 on either Monday, Tuesday, Wednesday, Thursday or Friday. \n\nHere are the existing schedules for everyone during the days: \nDiane is busy on Monday during 12:00 to 12:30, 15:00 to 15:30, Tuesday during 10:00 to 11:00, 11:30 to 12:00, 12:30 to 13:00, 16:00 to 17:00, Wednesday during 9:00 to 9:30, 14:30 to 15:00, 16:30 to 17:00, Thursday during 15:30 to 16:30, Friday during 9:30 to 11:30, 14:30 to 15:00, 16:00 to 17:00; \nMatthew has meetings on Monday during 9:00 to 10:00, 10:30 to 17:00, Tuesday during 9:00 to 17:00, Wednesday during 9:00 to 11:00, 12:00 to 14:30, 16:00 to 17:00, Thursday during 9:00 to 16:00, Friday during 9:00 to 17:00; \n\nMatthew would rather not meet on Wednesday before 12:30. Find a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\nfrom typing import List, Dict, Tuple\nimport datetime\n\ndef parse_time(time_str: str) -> datetime.time:\n    \"\"\"Parse a time string in HH:MM format into a datetime.time object.\"\"\"\n    return datetime.datetime.strptime(time_str, \"%H:%M\").time()\n\ndef time_to_minutes(time: datetime.time) -> int:\n    \"\"\"Convert a datetime.time object to total minutes since midnight.\"\"\"\n    return time.hour * 60 + time.minute\n\ndef minutes_to_time(minutes: int) -> datetime.time:\n    \"\"\"Convert total minutes since midnight to a datetime.time object.\"\"\"\n    return datetime.time(hour=minutes // 60, minute=minutes % 60)\n\ndef get_available_slots(busy_slots: List[Tuple[datetime.time, datetime.time]], \n                       work_start: datetime.time, work_end: datetime.time, \n                       duration: int) -> List[Tuple[datetime.time, datetime.time]]:\n    \"\"\"Calculate available time slots given busy slots, work hours, and meeting duration.\"\"\"\n    # Convert all times to minutes for easier calculation\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration\n    \n    # Process busy slots: convert to minutes and sort\n    busy_minutes = []\n    for start, end in busy_slots:\n        start_min = time_to_minutes(start)\n        end_min = time_to_minutes(end)\n        busy_minutes.append((start_min, end_min))\n    busy_minutes.sort()\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start_min\n    \n    for start, end in busy_minutes:\n        if start > prev_end:\n            available_duration = start - prev_end\n            if available_duration >= duration_min:\n                available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    # Check after last busy slot\n    if work_end_min > prev_end:\n        available_duration = work_end_min - prev_end\n        if available_duration >= duration_min:\n            available_slots.append((prev_end, work_end_min))\n    \n    # Convert back to time objects\n    available_slots_time = []\n    for start, end in available_slots:\n        start_time = minutes_to_time(start)\n        end_time = minutes_to_time(end)\n        available_slots_time.append((start_time, end_time))\n    \n    return available_slots_time\n\ndef find_common_meeting_time(diane_schedule: Dict[str, List[Tuple[str, str]]], \n                            matthew_schedule: Dict[str, List[Tuple[str, str]]], \n                            work_hours: Tuple[str, str], \n                            duration: int, \n                            matthew_preferences: Dict[str, List[Tuple[str, str]] = None) -> Tuple[str, str, str]:\n    \"\"\"Find a common meeting time for Diane and Matthew considering their schedules and preferences.\"\"\"\n    days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"]\n    work_start = parse_time(work_hours[0])\n    work_end = parse_time(work_hours[1])\n    \n    for day in days:\n        # Get busy slots for Diane and Matthew\n        diane_busy = diane_schedule.get(day, [])\n        matthew_busy = matthew_schedule.get(day, [])\n        \n        # Parse busy slots into time objects\n        diane_busy_slots = [(parse_time(start), parse_time(end)) for start, end in diane_busy]\n        matthew_busy_slots = [(parse_time(start), parse_time(end)) for start, end in matthew_busy]\n        \n        # Get available slots for Diane and Matthew\n        diane_available = get_available_slots(diane_busy_slots, work_start, work_end, duration)\n        matthew_available = get_available_slots(matthew_busy_slots, work_start, work_end, duration)\n        \n        # Find intersection of available slots\n        common_slots = []\n        for d_start, d_end in diane_available:\n            for m_start, m_end in matthew_available:\n                latest_start = max(d_start, m_start)\n                earliest_end = min(d_end, m_end)\n                if earliest_end > latest_start:\n                    overlap_duration = (earliest_end.hour * 60 + earliest_end.minute) - (latest_start.hour * 60 + latest_start.minute)\n                    if overlap_duration >= duration:\n                        common_slots.append((latest_start, earliest_end))\n        \n        # Apply Matthew's preferences if any\n        if matthew_preferences and day in matthew_preferences:\n            preferred_times = [(parse_time(start), parse_time(end)) for start, end in matthew_preferences[day]]\n            preferred_slots = []\n            for start, end in common_slots:\n                for p_start, p_end in preferred_times:\n                    latest_start = max(start, p_start)\n                    earliest_end = min(end, p_end)\n                    if earliest_end > latest_start:\n                        preferred_slots.append((latest_start, earliest_end))\n            common_slots = preferred_slots\n        \n        if common_slots:\n            # Return the first available slot\n            start_time = common_slots[0][0].strftime(\"%H:%M\")\n            end_time = common_slots[0][1].strftime(\"%H:%M\")\n            return day, start_time, end_time\n    \n    return None, None, None\n\n# Define schedules\ndiane_schedule = {\n    \"Monday\": [(\"12:00\", \"12:30\"), (\"15:00\", \"15:30\")],\n    \"Tuesday\": [(\"10:00\", \"11:00\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"16:00\", \"17:00\")],\n    \"Wednesday\": [(\"9:00\", \"9:30\"), (\"14:30\", \"15:00\"), (\"16:30\", \"17:00\")],\n    \"Thursday\": [(\"15:30\", \"16:30\")],\n    \"Friday\": [(\"9:30\", \"11:30\"), (\"14:30\", \"15:00\"), (\"16:00\", \"17:00\")]\n}\n\nmatthew_schedule = {\n    \"Monday\": [(\"9:00\", \"10:00\"), (\"10:30\", \"17:00\")],\n    \"Tuesday\": [(\"9:00\", \"17:00\")],\n    \"Wednesday\": [(\"9:00\", \"11:00\"), (\"12:00\", \"14:30\"), (\"16:00\", \"17:00\")],\n    \"Thursday\": [(\"9:00\", \"16:00\")],\n    \"Friday\": [(\"9:00\", \"17:00\")]\n}\n\n# Matthew's preference: not Wednesday before 12:30\nmatthew_preferences = {\n    \"Wednesday\": [(\"12:30\", \"17:00\")]\n}\n\n# Find meeting time\nday, start_time, end_time = find_common_meeting_time(\n    diane_schedule, \n    matthew_schedule, \n    (\"9:00\", \"17:00\"), \n    60,\n    matthew_preferences\n)\n\n# Output the result\nif day:\n    print(f\"{day}: {start_time}:{end_time}\")\nelse:\n    print(\"No suitable meeting time found.\")\n```"
    }
]