[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Lisa and Anthony for half an hour between the work hours of 9:00 to 17:00 on Monday. \n\nHere are the existing schedules for everyone during the day: \nLisa is busy on Monday during 9:00 to 9:30, 10:30 to 11:00, 14:00 to 16:00; \nAnthony is busy on Monday during 9:00 to 9:30, 11:00 to 11:30, 12:30 to 13:30, 14:00 to 15:00, 15:30 to 16:00, 16:30 to 17:00; \n\nYou would like to schedule the meeting at their earlist availability.\nFind a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\ndef find_meeting_time(lisa_busy, anthony_busy, work_hours, duration_minutes):\n    # Convert busy times to minutes since start of day\n    def parse_time(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def to_time_str(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = map(parse_time, work_hours.split(' to '))\n    duration = duration_minutes\n    \n    # Generate free slots for Lisa\n    lisa_free = []\n    prev_end = start_work\n    for busy in lisa_busy:\n        busy_start, busy_end = map(parse_time, busy.split(' to '))\n        if busy_start > prev_end:\n            lisa_free.append((prev_end, busy_start))\n        prev_end = busy_end\n    if prev_end < end_work:\n        lisa_free.append((prev_end, end_work))\n    \n    # Generate free slots for Anthony\n    anthony_free = []\n    prev_end = start_work\n    for busy in anthony_busy:\n        busy_start, busy_end = map(parse_time, busy.split(' to '))\n        if busy_start > prev_end:\n            anthony_free.append((prev_end, busy_start))\n        prev_end = busy_end\n    if prev_end < end_work:\n        anthony_free.append((prev_end, end_work))\n    \n    # Find overlapping free slots\n    for lisa_start, lisa_end in lisa_free:\n        for anthony_start, anthony_end in anthony_free:\n            start = max(lisa_start, anthony_start)\n            end = min(lisa_end, anthony_end)\n            if end - start >= duration:\n                return (start, start + duration)\n    \n    return None\n\n# Input data\nday = \"Monday\"\nwork_hours = \"9:00 to 17:00\"\nduration_minutes = 30\nlisa_busy = [\"9:00 to 9:30\", \"10:30 to 11:00\", \"14:00 to 16:00\"]\nanthony_busy = [\n    \"9:00 to 9:30\", \"11:00 to 11:30\", \"12:30 to 13:30\",\n    \"14:00 to 15:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"\n]\n\n# Find meeting time\nmeeting_time = find_meeting_time(lisa_busy, anthony_busy, work_hours, duration_minutes)\n\nif meeting_time:\n    start, end = meeting_time\n    start_str = f\"{start // 60:02d}:{start % 60:02d}\"\n    end_str = f\"{end // 60:02d}:{end % 60:02d}\"\n    print(f\"{day}: {start_str}:{end_str}\")\nelse:\n    print(\"No suitable meeting time found.\")\n```"
    }
]