[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Amanda and Nathan for half an hour between the work hours of 9:00 to 17:00 on either Monday or Tuesday. \n\nHere are the existing schedules for everyone during the days: \nAmanda is busy on Monday during 9:00 to 10:30, 11:00 to 11:30, 12:30 to 13:00, 13:30 to 14:00, 14:30 to 15:00, Tuesday during 9:00 to 9:30, 10:00 to 10:30, 11:30 to 12:00, 13:30 to 14:30, 15:30 to 16:00, 16:30 to 17:00; \nNathan is busy on Monday during 10:00 to 10:30, 11:00 to 11:30, 13:30 to 14:30, 16:00 to 16:30, Tuesday during 9:00 to 10:30, 11:00 to 13:00, 13:30 to 14:00, 14:30 to 15:30, 16:00 to 16:30; \n\nAmanda do not want to meet on Tuesday after 11:00. Nathan can not meet on Monday. Find a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Amanda's busy times in minutes (Monday and Tuesday)\n    amanda_busy = {\n        'Monday': [\n            (9 * 60, 10 * 60 + 30),    # 9:00-10:30\n            (11 * 60, 11 * 60 + 30),    # 11:00-11:30\n            (12 * 60 + 30, 13 * 60),    # 12:30-13:00\n            (13 * 60 + 30, 14 * 60),    # 13:30-14:00\n            (14 * 60 + 30, 15 * 60),    # 14:30-15:00\n        ],\n        'Tuesday': [\n            (9 * 60, 9 * 60 + 30),     # 9:00-9:30\n            (10 * 60, 10 * 60 + 30),    # 10:00-10:30\n            (11 * 60 + 30, 12 * 60),    # 11:30-12:00\n            (13 * 60 + 30, 14 * 60 + 30),  # 13:30-14:30\n            (15 * 60 + 30, 16 * 60),    # 15:30-16:00\n            (16 * 60 + 30, 17 * 60),    # 16:30-17:00\n        ]\n    }\n\n    # Nathan's busy times in minutes (Monday and Tuesday)\n    nathan_busy = {\n        'Monday': [\n            (10 * 60, 10 * 60 + 30),    # 10:00-10:30\n            (11 * 60, 11 * 60 + 30),    # 11:00-11:30\n            (13 * 60 + 30, 14 * 60 + 30),  # 13:30-14:30\n            (16 * 60, 16 * 60 + 30),    # 16:00-16:30\n        ],\n        'Tuesday': [\n            (9 * 60, 10 * 60 + 30),     # 9:00-10:30\n            (11 * 60, 13 * 60),         # 11:00-13:00\n            (13 * 60 + 30, 14 * 60),    # 13:30-14:00\n            (14 * 60 + 30, 15 * 60 + 30),  # 14:30-15:30\n            (16 * 60, 16 * 60 + 30),    # 16:00-16:30\n        ]\n    }\n\n    # Constraints:\n    # Amanda does not want to meet on Tuesday after 11:00\n    # Nathan cannot meet on Monday\n\n    # Since Nathan cannot meet on Monday, we only check Tuesday\n    day = 'Tuesday'\n\n    # Get busy intervals for Amanda and Nathan on Tuesday\n    amanda_busy_tuesday = amanda_busy[day]\n    nathan_busy_tuesday = nathan_busy[day]\n\n    # Combine and sort all busy intervals\n    all_busy = amanda_busy_tuesday + nathan_busy_tuesday\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy intervals\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Check Amanda's constraint: not after 11:00 on Tuesday\n    # So we only consider slots that start before 11:00\n    valid_slots = []\n    for start, end in free_slots:\n        if start < 11 * 60:  # Before 11:00\n            slot_start = start\n            slot_end = min(end, 11 * 60)  # Cap at 11:00\n            if slot_end - slot_start >= meeting_duration:\n                valid_slots.append((slot_start, slot_end))\n\n    # Find the first valid slot that fits the meeting duration\n    for start, end in valid_slots:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Convert minutes back to HH:MM format\n            def minutes_to_time(minutes):\n                hours = minutes // 60\n                mins = minutes % 60\n                return f\"{hours:02d}:{mins:02d}\"\n            start_time = minutes_to_time(meeting_start)\n            end_time = minutes_to_time(meeting_end)\n            return f\"{day}: {start_time}:{end_time}\"\n\n    return \"No suitable time found.\"\n\n# Run the function and print the result\nprint(find_meeting_time())\n```"
    }
]