[
    {
        "role": "user",
        "content": "You are an expert computational meeting planner. Your task is to write a Python program that algorithmically calculates the optimal meeting schedule based on the participants' constraints.\nThe program must actually compute the plan using the given parameters, not just print a pre-determined answer.\nInput parameters:\nYou are visiting San Francisco for the day and want to meet as many friends as possible. Solve the problem by considering various different schedules and picking the best one to optimize your goals.\n\nTravel distances (in minutes):\nBayview to Pacific Heights: 23.\nBayview to Mission District: 13.\nBayview to Haight-Ashbury: 19.\nBayview to Financial District: 19.\nPacific Heights to Bayview: 22.\nPacific Heights to Mission District: 15.\nPacific Heights to Haight-Ashbury: 11.\nPacific Heights to Financial District: 13.\nMission District to Bayview: 15.\nMission District to Pacific Heights: 16.\nMission District to Haight-Ashbury: 12.\nMission District to Financial District: 17.\nHaight-Ashbury to Bayview: 18.\nHaight-Ashbury to Pacific Heights: 12.\nHaight-Ashbury to Mission District: 11.\nHaight-Ashbury to Financial District: 21.\nFinancial District to Bayview: 19.\nFinancial District to Pacific Heights: 13.\nFinancial District to Mission District: 17.\nFinancial District to Haight-Ashbury: 19.\n\nCONSTRAINTS: You arrive at Bayview at 9:00AM. Mary will be at Pacific Heights from 10:00AM to 7:00PM. You'd like to meet Mary for a minimum of 45 minutes. Lisa will be at Mission District from 8:30PM to 10:00PM. You'd like to meet Lisa for a minimum of 75 minutes. Betty will be at Haight-Ashbury from 7:15AM to 5:15PM. You'd like to meet Betty for a minimum of 90 minutes. Charles will be at Financial District from 11:15AM to 3:00PM. You'd like to meet Charles for a minimum of 120 minutes.\n\nYour response should start with 'SOLUTION:'.\n\nGenerate a complete, self-contained Python program that:\n1. Takes the above meeting constraints as input variables\n2. Computes the optimal meeting schedule using logical rules and calculations\n3. Outputs the result as a JSON-formatted dictionary with the following structure:\n{\n  \"itinerary\": [\n    {\"action\": \"meet\", \"location\": \"Location Name\", \"person\": \"Person Name\", \"start_time\": \"H:MM\", \"end_time\": \"H:MM\"},\n    {\"action\": \"meet\", \"location\": \"Location Name\", \"person\": \"Person Name\", \"start_time\": \"H:MM\", \"end_time\": \"H:MM\"}\n  ]\n}\nRules for the program:\n- Times should be in 24-hour format like '9:00' or '13:30' (no leading zero)\n- The schedule must account for all travel times and constraints\n- The program must actually compute the schedule, not just print a static answer\n\nOutput only the complete Python code with no additional text or explanation.\nThe code must run independently and output valid JSON when executed."
    },
    {
        "role": "assistant",
        "content": "To solve this problem, we need to compute an optimal meeting schedule that maximizes the number of friends met while respecting their availability constraints and accounting for travel times between different locations. The solution involves generating all possible permutations of meeting orders for subsets of friends, simulating the schedule for each permutation, and selecting the one that allows meeting the maximum number of friends.\n\n### Approach\n1. **Problem Analysis**: The problem requires scheduling meetings with friends located in different parts of San Francisco, considering their availability windows and minimum meeting durations. Travel times between locations are asymmetric and must be accounted for in the schedule.\n2. **Key Insight**: The optimal schedule must start from Bayview at 9:00 AM and sequence meetings such that each meeting fits within the friend's availability window after accounting for travel time from the previous location.\n3. **Algorithm Selection**: \n   - **Generate Subsets and Permutations**: For all possible subsets of friends (including all sizes from 0 to 4), generate every permutation of each subset to explore different meeting orders.\n   - **Simulate Schedule**: For each permutation, simulate the schedule by:\n     - Calculating travel time from the current location to the next friend's location.\n     - Determining the earliest possible start time for the meeting (considering arrival time and friend's availability).\n     - Ensuring the meeting duration fits within the friend's availability window.\n   - **Track Best Schedule**: Keep track of the schedule that includes the maximum number of friends. If multiple schedules meet the same number of friends, any one can be selected.\n4. **Complexity Analysis**: With 4 friends, there are 16 subsets and 24 permutations per subset (for size 4), resulting in 384 permutations. This is computationally feasible given the small input size.\n\n### Solution Code\n```python\nimport json\nfrom itertools import combinations, permutations\n\ndef minutes_to_time(m):\n    hours = m // 60\n    minutes = m % 60\n    return f\"{hours}:{minutes:02d}\"\n\ndef main():\n    mary = {\"name\": \"Mary\", \"location\": \"Pacific Heights\", \"start\": 10*60, \"end\": 19*60, \"min_duration\": 45}\n    lisa = {\"name\": \"Lisa\", \"location\": \"Mission District\", \"start\": 20*60+30, \"end\": 22*60, \"min_duration\": 75}\n    betty = {\"name\": \"Betty\", \"location\": \"Haight-Ashbury\", \"start\": 7*60+15, \"end\": 17*60+15, \"min_duration\": 90}\n    charles = {\"name\": \"Charles\", \"location\": \"Financial District\", \"start\": 11*60+15, \"end\": 15*60, \"min_duration\": 120}\n    friends = [mary, lisa, betty, charles]\n    \n    travel_times = {\n        \"Bayview\": {\n            \"Pacific Heights\": 23,\n            \"Mission District\": 13,\n            \"Haight-Ashbury\": 19,\n            \"Financial District\": 19\n        },\n        \"Pacific Heights\": {\n            \"Bayview\": 22,\n            \"Mission District\": 15,\n            \"Haight-Ashbury\": 11,\n            \"Financial District\": 13\n        },\n        \"Mission District\": {\n            \"Bayview\": 15,\n            \"Pacific Heights\": 16,\n            \"Haight-Ashbury\": 12,\n            \"Financial District\": 17\n        },\n        \"Haight-Ashbury\": {\n            \"Bayview\": 18,\n            \"Pacific Heights\": 12,\n            \"Mission District\": 11,\n            \"Financial District\": 21\n        },\n        \"Financial District\": {\n            \"Bayview\": 19,\n            \"Pacific Heights\": 13,\n            \"Mission District\": 17,\n            \"Haight-Ashbury\": 19\n        }\n    }\n    \n    start_time_val = 9 * 60\n    start_location = \"Bayview\"\n    \n    n = len(friends)\n    indices = list(range(n))\n    all_subsets = []\n    for r in range(0, n+1):\n        for subset in combinations(indices, r):\n            all_subsets.append(subset)\n    \n    best_count = -1\n    best_itinerary = None\n    \n    for subset in all_subsets:\n        for order in permutations(subset):\n            current_location = start_location\n            current_time = start_time_val\n            itinerary = []\n            valid = True\n            for idx in order:\n                friend = friends[idx]\n                try:\n                    t = travel_times[current_location][friend['location']]\n                except KeyError:\n                    valid = False\n                    break\n                    \n                arrival_time = current_time + t\n                start_meeting = max(arrival_time, friend['start'])\n                end_meeting = start_meeting + friend['min_duration']\n                \n                if end_meeting > friend['end']:\n                    valid = False\n                    break\n                    \n                itinerary.append({\n                    \"action\": \"meet\",\n                    \"location\": friend['location'],\n                    \"person\": friend['name'],\n                    \"start_time\": minutes_to_time(start_meeting),\n                    \"end_time\": minutes_to_time(end_meeting)\n                })\n                \n                current_time = end_meeting\n                current_location = friend['location']\n                \n            if valid:\n                if len(subset) > best_count:\n                    best_count = len(subset)\n                    best_itinerary = itinerary\n                    \n    if best_itinerary is None:\n        best_itinerary = []\n        \n    result = {\"itinerary\": best_itinerary}\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Time Conversion**: The `minutes_to_time` function converts minutes since midnight into a time string in 24-hour format (e.g., 540 minutes becomes \"9:00\").\n2. **Friend Data**: Each friend's data (name, location, availability window, and minimum meeting duration) is stored in dictionaries.\n3. **Travel Times**: A nested dictionary stores travel times between all pairs of locations.\n4. **Subset Generation**: All possible subsets of friends are generated to explore different combinations of meetings.\n5. **Schedule Simulation**: For each permutation of each subset, the schedule is simulated:\n   - **Travel Calculation**: Travel time from the current location to the next friend's location is added to the current time.\n   - **Meeting Scheduling**: The meeting starts at the later of the arrival time or the friend's available start time, ensuring it ends before the friend's availability ends.\n6. **Optimal Schedule Selection**: The valid schedule with the highest number of meetings is selected and printed in JSON format. If no valid schedule is found, an empty itinerary is printed."
    }
]