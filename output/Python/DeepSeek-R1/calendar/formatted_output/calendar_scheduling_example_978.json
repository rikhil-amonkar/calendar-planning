{
    "0shot": [
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "9:30",
                "end_time": "10:30"
            },
            "expected_time": {
                "day": "Tuesday",
                "start_time": "9:30",
                "end_time": "10:30"
            },
            "has_error": false,
            "raw_model_response": "'''python\ndef main():\n    work_start = 9 * 60  # 540 minutes (9:00)\n    work_end = 17 * 60   # 1020 minutes (17:00)\n    days_order = ['Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Monday']\n\n    # Define busy intervals in minutes since midnight\n    brian_busy = {\n        'Monday': [\n            (9*60+30, 10*60),\n            (12*60+30, 14*60+30),\n            (15*60+30, 16*60),\n            (16*60+30, 17*60)\n        ],\n        'Tuesday': [\n            (9*60, 9*60+30)\n        ],\n        'Wednesday': [\n            (12*60+30, 14*60),\n            (16*60+30, 17*60)\n        ],\n        'Thursday': [\n            (11*60, 11*60+30),\n            (13*60, 13*60+30),\n            (16*60+30, 17*60)\n        ],\n        'Friday': [\n            (9*60+30, 10*60),\n            (10*60+30, 11*60),\n            (13*60, 13*60+30),\n            (15*60, 16*60),\n            (16*60+30, 17*60)\n        ]\n    }\n\n    julia_busy = {\n        'Monday': [\n            (9*60, 10*60),\n            (11*60, 11*60+30),\n            (12*60+30, 13*60),\n            (15*60+30, 16*60)\n        ],\n        'Tuesday': [\n            (13*60, 14*60),\n            (16*60, 16*60+30)\n        ],\n        'Wednesday': [\n            (9*60, 11*60+30),\n            (12*60, 12*60+30),\n            (13*60, 17*60)\n        ],\n        'Thursday': [\n            (9*60, 10*60+30),\n            (11*60, 17*60)\n        ],\n        'Friday': [\n            (9*60, 10*60),\n            (10*60+30, 11*60+30),\n            (12*60+30, 14*60),\n            (14*60+30, 15*60),\n            (15*60+30, 16*60)\n        ]\n    }\n\n    def merge_intervals(intervals):\n        if not intervals:\n            return []\n        sorted_intervals = sorted(intervals, key=lambda x: x[0])\n        merged = [list(sorted_intervals[0])]\n        for current in sorted_intervals[1:]:\n            last = merged[-1]\n            if current[0] <= last[1]:\n                if current[1] > last[1]:\n                    merged[-1][1] = current[1]\n            else:\n                merged.append(list(current))\n        return merged\n\n    def get_free_intervals(busy_intervals, work_start, work_end):\n        merged = merge_intervals(busy_intervals)\n        free = []\n        current_start = work_start\n        for start, end in merged:\n            if start > current_start:\n                free.append((current_start, start))\n            current_start = max(current_start, end)\n        if current_start < work_end:\n            free.append((current_start, work_end))\n        return free\n\n    def find_overlap(a_start, a_end, b_start, b_end):\n        start = max(a_start, b_start)\n        end = min(a_end, b_end)\n        if start < end:\n            return (start, end)\n        return None\n\n    for day in days_order:\n        brian_busy_day = brian_busy.get(day, [])\n        julia_busy_day = julia_busy.get(day, [])\n\n        brian_free = get_free_intervals(brian_busy_day, work_start, work_end)\n        julia_free = get_free_intervals(julia_busy_day, work_start, work_end)\n\n        overlapping = []\n        i = j = 0\n        while i < len(brian_free) and j < len(julia_free):\n            a_start, a_end = brian_free[i]\n            b_start, b_end = julia_free[j]\n\n            overlap = find_overlap(a_start, a_end, b_start, b_end)\n            if overlap:\n                overlapping.append(overlap)\n                if a_end < b_end:\n                    i += 1\n                else:\n                    j += 1\n            else:\n                if a_start < b_start:\n                    i += 1\n                else:\n                    j += 1\n\n        for start, end in overlapping:\n            if end - start >= 60:\n                def format_time(minutes):\n                    hours = minutes // 60\n                    mins = minutes % 60\n                    return f\"{hours:02d}:{mins:02d}\"\n                start_str = format_time(start)\n                end_str = format_time(start + 60)\n                print(f\"{day}:{start_str}:{end_str}\")\n                return\n\nif __name__ == \"__main__\":\n    main()\n'''",
            "count": "calendar_scheduling_example_978"
        }
    ]
}