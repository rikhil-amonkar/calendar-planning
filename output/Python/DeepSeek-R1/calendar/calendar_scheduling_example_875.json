{
    "0shot": [
        {
            "final_program_time": {
                "day": "Wednesday",
                "start_time": null,
                "end_time": null
            },
            "expected_time": {
                "day": "Wednesday",
                "start_time": "{14:30",
                "end_time": "15:30}"
            },
            "has_error": false,
            "raw_model_response": "'''python\ndef find_meeting_time():\n    # Define work hours and days\n    work_hours = (9, 17)\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Define schedules in 24h format as (start_h, start_m, end_h, end_m)\n    schedules = {\n        'Natalie': {\n            'Monday': [(9, 0, 9, 30), (10, 0, 12, 0), (12, 30, 13, 0), (14, 0, 14, 30), (15, 0, 16, 30)],\n            'Tuesday': [(9, 0, 9, 30), (10, 0, 10, 30), (12, 30, 14, 0), (16, 0, 17, 0)],\n            'Wednesday': [(11, 0, 11, 30), (16, 0, 16, 30)],\n            'Thursday': [(10, 0, 11, 0), (11, 30, 15, 0), (15, 30, 16, 0), (16, 30, 17, 0)]\n        },\n        'William': {\n            'Monday': [(9, 30, 11, 0), (11, 30, 17, 0)],\n            'Tuesday': [(9, 0, 13, 0), (13, 30, 16, 0)],\n            'Wednesday': [(9, 0, 12, 30), (13, 0, 14, 30), (15, 30, 16, 0), (16, 30, 17, 0)],\n            'Thursday': [(9, 0, 10, 30), (11, 0, 11, 30), (12, 0, 12, 30), (13, 0, 14, 0), (15, 0, 17, 0)]\n        }\n    }\n\n    # Convert schedules to minutes for easier comparison\n    for day in days:\n        for person in schedules:\n            converted = []\n            for block in schedules[person].get(day, []):\n                start = block[0] * 60 + block[1]\n                end = block[2] * 60 + block[3]\n                converted.append((start, end))\n            schedules[person][day] = converted\n\n    # Check each day for available slot\n    for day in days:\n        # Get all busy blocks for both participants\n        natalie_busy = schedules['Natalie'][day]\n        william_busy = schedules['William'][day]\n        \n        # Create merged busy timeline (union of both schedules)\n        merged_busy = []\n        current_idx = 0\n        all_blocks = sorted(natalie_busy + william_busy, key=lambda x: x[0])\n        for block in all_blocks:\n            if not merged_busy:\n                merged_busy.append(block)\n            else:\n                last = merged_busy[-1]\n                if block[0] <= last[1]:\n                    merged_busy[-1] = (last[0], max(last[1], block[1]))\n                else:\n                    merged_busy.append(block)\n        \n        # Add work hours boundaries\n        day_start = work_hours[0] * 60\n        day_end = work_hours[1] * 60\n        timeline = [(day_start, day_start)]  # Initial dummy entry\n        \n        if merged_busy:\n            timeline.extend(merged_busy)\n        else:\n            # Entire day is free\n            return f\"{day}: {work_hours[0]:02d}:00-{work_hours[0]+1:02d}:00\"\n        \n        # Find first gap of at least 60 minutes\n        for i in range(1, len(timeline)):\n            prev_end = timeline[i-1][1]\n            curr_start = timeline[i][0]\n            if curr_start - prev_end >= 60:\n                # Found suitable gap\n                start_h, start_m = divmod(prev_end, 60)\n                end_h, end_m = divmod(prev_end + 60, 60)\n                return f\"{day}: {start_h:02d}:{start_m:02d}-{end_h:02d}:{end_m:02d}\"\n        \n        # Check after last meeting\n        last_end = timeline[-1][1]\n        if day_end - last_end >= 60:\n            start_h, start_m = divmod(last_end, 60)\n            end_h, end_m = divmod(last_end + 60, 60)\n            return f\"{day}: {start_h:02d}:{start_m:02d}-{end_h:02d}:{end_m:02d}\"\n\n    return \"No suitable time found\"\n\n# Execute and print result\nprint(find_meeting_time())\n'''",
            "count": "calendar_scheduling_example_875"
        }
    ]
}