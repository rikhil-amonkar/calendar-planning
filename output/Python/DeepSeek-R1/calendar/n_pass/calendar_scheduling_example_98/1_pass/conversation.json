[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Juan, Marilyn and Ronald for half an hour between the work hours of 9:00 to 17:00 on Monday. \n\nHere are the existing schedules for everyone during the day: \nJuan is busy on Monday during 9:00 to 10:30, 15:30 to 16:00; \nMarilyn has blocked their calendar on Monday during 11:00 to 11:30, 12:30 to 13:00; \nRonald has blocked their calendar on Monday during 9:00 to 10:30, 12:00 to 12:30, 13:00 to 13:30, 14:00 to 16:30; \n\nJuan can not meet on Monday after 16:00. Find a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\ndef get_free_intervals(busy_intervals, work_start, work_end):\n    if not busy_intervals:\n        return [(work_start, work_end)]\n    sorted_busy = sorted(busy_intervals, key=lambda x: x[0])\n    free = []\n    current_start = work_start\n    for s, e in sorted_busy:\n        if current_start < s:\n            free.append((current_start, s))\n        current_start = max(current_start, e)\n    if current_start < work_end:\n        free.append((current_start, work_end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    i = j = 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        low = max(intervals1[i][0], intervals2[j][0])\n        high = min(intervals1[i][1], intervals2[j][1])\n        if low < high:\n            result.append((low, high))\n        if intervals1[i][1] < intervals2[j][1]:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef min_to_time(minutes):\n    h = minutes // 60\n    m = minutes % 60\n    return f\"{h:02d}:{m:02d}\"\n\n# Work hours: 9:00 to 17:00 (in minutes from midnight)\nwork_start = 9 * 60  # 540 minutes\nwork_end = 17 * 60   # 1020 minutes\n\n# Busy intervals for each participant (in minutes from midnight)\njuan_busy = [(9*60, 10*60+30), (15*60+30, 16*60)]\nmarilyn_busy = [(11*60, 11*60+30), (12*60+30, 13*60)]\nronald_busy = [(9*60, 10*60+30), (12*60, 12*60+30), (13*60, 13*60+30), (14*60, 16*60+30)]\n\n# Juan cannot meet after 16:00, so adjust his work_end to 16:00 (960 minutes)\nfree_juan = get_free_intervals(juan_busy, work_start, 16*60)\nfree_marilyn = get_free_intervals(marilyn_busy, work_start, work_end)\nfree_ronald = get_free_intervals(ronald_busy, work_start, work_end)\n\n# Find common free intervals\ncommon = intersect_intervals(free_juan, free_marilyn)\ncommon = intersect_intervals(common, free_ronald)\n\n# Meeting duration in minutes\nduration = 30\nmeeting_start = None\nmeeting_end = None\n\n# Find the first available slot of at least 'duration' minutes\nfor start, end in common:\n    if end - start >= duration:\n        meeting_start = start\n        meeting_end = start + duration\n        break\n\nif meeting_start is not None:\n    start_str = min_to_time(meeting_start)\n    end_str = min_to_time(meeting_end)\n    print(f\"{start_str}:{end_str}\")\n    print(\"Monday\")\nelse:\n    print(\"No suitable time found\")\n```"
    }
]