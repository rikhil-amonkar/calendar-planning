[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Margaret, Donna and Helen for half an hour between the work hours of 9:00 to 17:00 on Monday. \n\nHere are the existing schedules for everyone during the day: \nMargaret has blocked their calendar on Monday during 9:00 to 10:00, 10:30 to 11:00, 11:30 to 12:00, 13:00 to 13:30, 15:00 to 15:30; \nDonna has blocked their calendar on Monday during 14:30 to 15:00, 16:00 to 16:30; \nHelen has meetings on Monday during 9:00 to 9:30, 10:00 to 11:30, 13:00 to 14:00, 14:30 to 15:00, 15:30 to 17:00; \n\nHelen do not want to meet on Monday after 13:30. Find a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\ndef main():\n    # Convert time string to minutes since 00:00 for easier calculations, then adjust relative to 9:00\n    def to_minutes(time_str):\n        h, m = time_str.split(':')\n        return int(h) * 60 + int(m)\n    \n    work_start_min = to_minutes('9:00')  # 540 minutes (from 00:00)\n    work_end_min = to_minutes('17:00')   # 1020 minutes (from 00:00)\n    \n    # Adjust to minutes relative to 9:00 (so 9:00 becomes 0)\n    def adjust(minutes):\n        return minutes - work_start_min\n    \n    # Convert minutes (relative to 9:00) back to absolute time string\n    def to_time_str(minutes):\n        total_minutes = work_start_min + minutes\n        h = total_minutes // 60\n        m = total_minutes % 60\n        return f\"{h:02d}:{m:02d}\"\n    \n    # Define busy intervals for each participant (in absolute times)\n    margaret_busy = [\n        (\"9:00\", \"10:00\"),\n        (\"10:30\", \"11:00\"),\n        (\"11:30\", \"12:00\"),\n        (\"13:00\", \"13:30\"),\n        (\"15:00\", \"15:30\")\n    ]\n    \n    donna_busy = [\n        (\"14:30\", \"15:00\"),\n        (\"16:00\", \"16:30\")\n    ]\n    \n    helen_busy = [\n        (\"9:00\", \"9:30\"),\n        (\"10:00\", \"11:30\"),\n        (\"13:00\", \"14:00\"),\n        (\"14:30\", \"15:00\"),\n        (\"15:30\", \"17:00\"),\n        (\"13:30\", \"17:00\")   # Additional constraint: Helen not available after 13:30\n    ]\n    \n    # Convert all busy intervals to adjusted minutes (relative to 9:00)\n    all_busy = []\n    for start, end in margaret_busy:\n        s = adjust(to_minutes(start))\n        e = adjust(to_minutes(end))\n        all_busy.append((s, e))\n    \n    for start, end in donna_busy:\n        s = adjust(to_minutes(start))\n        e = adjust(to_minutes(end))\n        all_busy.append((s, e))\n    \n    for start, end in helen_busy:\n        s = adjust(to_minutes(start))\n        e = adjust(to_minutes(end))\n        all_busy.append((s, e))\n    \n    # Sort intervals by start time\n    all_busy.sort(key=lambda x: x[0])\n    \n    # Merge overlapping intervals\n    merged = []\n    current_start, current_end = all_busy[0]\n    for s, e in all_busy[1:]:\n        if s <= current_end:\n            current_end = max(current_end, e)\n        else:\n            merged.append((current_start, current_end))\n            current_start, current_end = s, e\n    merged.append((current_start, current_end))\n    \n    # Find free intervals within working hours (0 to 480 minutes relative to 9:00)\n    free_intervals = []\n    last_end = 0\n    for start, end in merged:\n        if start > last_end:\n            free_intervals.append((last_end, start))\n        last_end = end\n    if last_end < 480:\n        free_intervals.append((last_end, 480))\n    \n    # Find the first free interval that can accommodate 30 minutes and starts by 13:30 (270 minutes)\n    meeting_start = None\n    for start, end in free_intervals:\n        duration_needed = 30\n        # Check if the interval is long enough\n        if end - start >= duration_needed:\n            # The meeting must start by 13:30 (270 minutes)\n            latest_start = min(end - duration_needed, 270)\n            if start <= latest_start:\n                meeting_start = start\n                break\n    \n    if meeting_start is None:\n        print(\"No suitable time found\")\n    else:\n        meeting_end = meeting_start + 30\n        # Convert to absolute time strings\n        start_time_abs = to_time_str(meeting_start)\n        end_time_abs = to_time_str(meeting_end)\n        # Format as HH:MM:HH:MM\n        time_range_str = f\"{start_time_abs[:5].replace(':', '')}:{end_time_abs[:5].replace(':', '')}\"\n        # Output day and time range\n        print(\"Monday\")\n        print(time_range_str)\n\nif __name__ == \"__main__\":\n    main()\n```"
    }
]