[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Walter, Cynthia, Ann, Catherine and Kyle for half an hour between the work hours of 9:00 to 17:00 on Monday. \n\nHere are the existing schedules for everyone during the day: \nWalterhas no meetings the whole day.\nCynthia has blocked their calendar on Monday during 9:00 to 9:30, 10:00 to 10:30, 13:30 to 14:30, 15:00 to 16:00; \nAnn is busy on Monday during 10:00 to 11:00, 13:00 to 13:30, 14:00 to 15:00, 16:00 to 16:30; \nCatherine has meetings on Monday during 9:00 to 11:30, 12:30 to 13:30, 14:30 to 17:00; \nKyle is busy on Monday during 9:00 to 9:30, 10:00 to 11:30, 12:00 to 12:30, 13:00 to 14:30, 15:00 to 16:00; \n\nFind a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\ndef time_str_to_minutes(time_str):\n    parts = time_str.split(':')\n    return int(parts[0]) * 60 + int(parts[1])\n\ndef minutes_to_time_str(minutes):\n    hour = minutes // 60\n    minute = minutes % 60\n    return f\"{hour}:{minute:02d}\"\n\ndef compute_free_intervals(busy_intervals, work_start, work_end):\n    if not busy_intervals:\n        return [[work_start, work_end]]\n    busy_sorted = sorted(busy_intervals, key=lambda x: x[0])\n    free = []\n    current = work_start\n    for interval in busy_sorted:\n        s, e = interval\n        if current < s:\n            free.append([current, s])\n        current = max(current, e)\n    if current < work_end:\n        free.append([current, work_end])\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    if not intervals1 or not intervals2:\n        return []\n    i = j = 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        a_start, a_end = intervals1[i]\n        b_start, b_end = intervals2[j]\n        low = max(a_start, b_start)\n        high = min(a_end, b_end)\n        if low < high:\n            result.append([low, high])\n        if a_end < b_end:\n            i += 1\n        else:\n            j += 1\n    return result\n\nwork_start = time_str_to_minutes(\"9:00\")\nwork_end = time_str_to_minutes(\"17:00\")\nduration = 30\n\nparticipants_busy = {\n    'Walter': [],\n    'Cynthia': [[\"9:00\", \"9:30\"], [\"10:00\", \"10:30\"], [\"13:30\", \"14:30\"], [\"15:00\", \"16:00\"]],\n    'Ann': [[\"10:00\", \"11:00\"], [\"13:00\", \"13:30\"], [\"14:00\", \"15:00\"], [\"16:00\", \"16:30\"]],\n    'Catherine': [[\"9:00\", \"11:30\"], [\"12:30\", \"13:30\"], [\"14:30\", \"17:00\"]],\n    'Kyle': [[\"9:00\", \"9:30\"], [\"10:00\", \"11:30\"], [\"12:00\", \"12:30\"], [\"13:00\", \"14:30\"], [\"15:00\", \"16:00\"]]\n}\n\nfree_intervals_list = []\nfor person, busy_list in participants_busy.items():\n    busy_minutes = []\n    for interval in busy_list:\n        start_min = time_str_to_minutes(interval[0])\n        end_min = time_str_to_minutes(interval[1])\n        busy_minutes.append([start_min, end_min])\n    free_intervals = compute_free_intervals(busy_minutes, work_start, work_end)\n    free_intervals_list.append(free_intervals)\n\ncommon = free_intervals_list[0]\nfor i in range(1, len(free_intervals_list)):\n    common = intersect_intervals(common, free_intervals_list[i])\n\nmeeting_start = None\nfor interval in common:\n    start, end = interval\n    if end - start >= duration:\n        meeting_start = start\n        break\n\nif meeting_start is None:\n    print(\"No suitable time found\")\nelse:\n    meeting_end = meeting_start + duration\n    start_hour = meeting_start // 60\n    start_minute = meeting_start % 60\n    end_hour = meeting_end // 60\n    end_minute = meeting_end % 60\n    time_str = f\"{start_hour}:{start_minute:02d}:{end_hour}:{end_minute:02d}\"\n    print(\"Monday\")\n    print(time_str)\n```"
    }
]