[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Diane and Matthew for one hour between the work hours of 9:00 to 17:00 on either Monday, Tuesday, Wednesday, Thursday or Friday. \n\nHere are the existing schedules for everyone during the days: \nDiane is busy on Monday during 12:00 to 12:30, 15:00 to 15:30, Tuesday during 10:00 to 11:00, 11:30 to 12:00, 12:30 to 13:00, 16:00 to 17:00, Wednesday during 9:00 to 9:30, 14:30 to 15:00, 16:30 to 17:00, Thursday during 15:30 to 16:30, Friday during 9:30 to 11:30, 14:30 to 15:00, 16:00 to 17:00; \nMatthew has meetings on Monday during 9:00 to 10:00, 10:30 to 17:00, Tuesday during 9:00 to 17:00, Wednesday during 9:00 to 11:00, 12:00 to 14:30, 16:00 to 17:00, Thursday during 9:00 to 16:00, Friday during 9:00 to 17:00; \n\nMatthew would rather not meet on Wednesday before 12:30. Find a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\ndef merge_intervals(intervals):\n    if not intervals:\n        return []\n    sorted_intervals = sorted(intervals, key=lambda x: x[0])\n    merged = []\n    current_start, current_end = sorted_intervals[0]\n    for i in range(1, len(sorted_intervals)):\n        s, e = sorted_intervals[i]\n        if s <= current_end:\n            current_end = max(current_end, e)\n        else:\n            merged.append((current_start, current_end))\n            current_start, current_end = s, e\n    merged.append((current_start, current_end))\n    return merged\n\ndef compute_free_intervals(work_start, work_end, busy_intervals):\n    merged_busy = merge_intervals(busy_intervals)\n    free = []\n    current = work_start\n    for s, e in merged_busy:\n        if current < s:\n            free.append((current, s))\n            current = e\n        else:\n            if e > current:\n                current = e\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef compute_common_free(intervals1, intervals2):\n    i = j = 0\n    common = []\n    while i < len(intervals1) and j < len(intervals2):\n        low = max(intervals1[i][0], intervals2[j][0])\n        high = min(intervals1[i][1], intervals2[j][1])\n        if low < high:\n            common.append((low, high))\n        if intervals1[i][1] < intervals2[j][1]:\n            i += 1\n        else:\n            j += 1\n    return common\n\ndef main():\n    work_start = 540  # 9:00 in minutes\n    work_end = 1020   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n    \n    diane_busy = {\n        'Monday': [(720, 750), (900, 930)],\n        'Tuesday': [(600, 660), (690, 720), (750, 780), (960, 1020)],\n        'Wednesday': [(540, 570), (870, 900), (990, 1020)],\n        'Thursday': [(930, 990)],\n        'Friday': [(570, 690), (870, 900), (960, 1020)]\n    }\n    \n    matthew_busy = {\n        'Monday': [(540, 600), (630, 1020)],\n        'Tuesday': [(540, 1020)],\n        'Wednesday': [(540, 660), (720, 870), (960, 1020)],\n        'Thursday': [(540, 960)],\n        'Friday': [(540, 1020)]\n    }\n    \n    # Add Matthew's Wednesday constraint: not available before 12:30 (750 minutes)\n    matthew_busy['Wednesday'].append((540, 750))\n    \n    for day in days:\n        diane_busy_today = diane_busy.get(day, [])\n        matthew_busy_today = matthew_busy.get(day, [])\n        \n        free_diane = compute_free_intervals(work_start, work_end, diane_busy_today)\n        free_matthew = compute_free_intervals(work_start, work_end, matthew_busy_today)\n        \n        common_free = compute_common_free(free_diane, free_matthew)\n        \n        for start, end in common_free:\n            if end - start >= 60:\n                meeting_start = start\n                meeting_end = start + 60\n                # Format meeting times\n                start_hour = meeting_start // 60\n                start_min = meeting_start % 60\n                end_hour = meeting_end // 60\n                end_min = meeting_end % 60\n                time_str = f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n                print(day)\n                print(time_str)\n                return\n    \n    # If no suitable time found (though problem states there is a solution)\n    print(\"No suitable time found\")\n\nif __name__ == \"__main__\":\n    main()\n```"
    }
]