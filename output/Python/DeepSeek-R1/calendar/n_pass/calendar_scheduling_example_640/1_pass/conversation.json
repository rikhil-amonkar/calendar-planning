[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Bobby and Michael for half an hour between the work hours of 9:00 to 17:00 on either Monday or Tuesday. \n\nHere are the existing schedules for everyone during the days: \nBobby is busy on Monday during 14:30 to 15:00, Tuesday during 9:00 to 11:30, 12:00 to 12:30, 13:00 to 15:00, 15:30 to 17:00; \nMichael is busy on Monday during 9:00 to 10:00, 10:30 to 13:30, 14:00 to 15:00, 15:30 to 17:00, Tuesday during 9:00 to 10:30, 11:00 to 11:30, 12:00 to 14:00, 15:00 to 16:00, 16:30 to 17:00; \n\nThe group would like to meet at their earlist availability.\nFind a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\ndef time_str_to_minutes(time_str):\n    h, m = time_str.split(':')\n    total_minutes = int(h) * 60 + int(m)\n    return total_minutes - 540  # 540 minutes is 9:00\n\ndef minutes_to_time_str(minutes_since_9am):\n    total_minutes = 540 + minutes_since_9am\n    h = total_minutes // 60\n    m = total_minutes % 60\n    return f\"{h:02d}:{m:02d}\"\n\ndef merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = []\n    start, end = intervals[0]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] <= end:\n            if intervals[i][1] > end:\n                end = intervals[i][1]\n        else:\n            merged.append((start, end))\n            start, end = intervals[i]\n    merged.append((start, end))\n    return merged\n\ndef main():\n    bobby_busy = {\n        'Monday': [('14:30', '15:00')],\n        'Tuesday': [('9:00', '11:30'), ('12:00', '12:30'), ('13:00', '15:00'), ('15:30', '17:00')]\n    }\n    \n    michael_busy = {\n        'Monday': [('9:00', '10:00'), ('10:30', '13:30'), ('14:00', '15:00'), ('15:30', '17:00')],\n        'Tuesday': [('9:00', '10:30'), ('11:00', '11:30'), ('12:00', '14:00'), ('15:00', '16:00'), ('16:30', '17:00')]\n    }\n    \n    duration = 30  # minutes\n    days = ['Monday', 'Tuesday']\n    found = False\n    day_found = None\n    slot_start = None\n    \n    for day in days:\n        intervals = []\n        if day in bobby_busy:\n            for interval in bobby_busy[day]:\n                start_min = time_str_to_minutes(interval[0])\n                end_min = time_str_to_minutes(interval[1])\n                intervals.append((start_min, end_min))\n                \n        if day in michael_busy:\n            for interval in michael_busy[day]:\n                start_min = time_str_to_minutes(interval[0])\n                end_min = time_str_to_minutes(interval[1])\n                intervals.append((start_min, end_min))\n                \n        if not intervals:\n            free_interval = (0, 480)\n            if free_interval[1] - free_interval[0] >= duration:\n                day_found = day\n                slot_start = free_interval[0]\n                found = True\n                break\n        else:\n            merged = merge_intervals(intervals)\n            free_intervals = []\n            current = 0\n            for interval in merged:\n                if current < interval[0]:\n                    free_intervals.append((current, interval[0]))\n                current = interval[1]\n            if current < 480:\n                free_intervals.append((current, 480))\n                \n            for free in free_intervals:\n                if free[1] - free[0] >= duration:\n                    day_found = day\n                    slot_start = free[0]\n                    found = True\n                    break\n            if found:\n                break\n                \n    if found:\n        start_time = minutes_to_time_str(slot_start)\n        end_time = minutes_to_time_str(slot_start + duration)\n        time_output = f\"{start_time}:{end_time}\"\n        print(day_found)\n        print(time_output)\n    else:\n        print(\"No suitable time found\")\n\nif __name__ == \"__main__\":\n    main()\n```"
    }
]