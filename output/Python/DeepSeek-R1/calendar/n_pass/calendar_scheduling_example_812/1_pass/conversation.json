[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Mary and Alexis for half an hour between the work hours of 9:00 to 17:00 on either Monday, Tuesday, Wednesday or Thursday. \n\nHere are the existing schedules for everyone during the days: \nMary has meetings on Tuesday during 10:00 to 10:30, 15:30 to 16:00, Wednesday during 9:30 to 10:00, 15:00 to 15:30, Thursday during 9:00 to 10:00, 10:30 to 11:30; \nAlexis has blocked their calendar on Monday during 9:00 to 10:00, 10:30 to 12:00, 12:30 to 16:30, Tuesday during 9:00 to 10:00, 10:30 to 11:30, 12:00 to 15:30, 16:00 to 17:00, Wednesday during 9:00 to 11:00, 11:30 to 17:00, Thursday during 10:00 to 12:00, 14:00 to 14:30, 15:30 to 16:00, 16:30 to 17:00; \n\nThe group would like to meet at their earlist availability.\nFind a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\ndef get_free_intervals(busy, day_start=540, day_end=1020):\n    if not busy:\n        return [(day_start, day_end)]\n    busy_sorted = sorted(busy, key=lambda x: x[0])\n    free = []\n    current = day_start\n    for interval in busy_sorted:\n        start, end = interval\n        if current < start:\n            free.append((current, start))\n        current = max(current, end)\n    if current < day_end:\n        free.append((current, day_end))\n    return free\n\nmary_busy = {\n    'Tuesday': [(600, 630), (930, 960)],\n    'Wednesday': [(570, 600), (900, 930)],\n    'Thursday': [(540, 600), (630, 690)]\n}\n\nalexis_busy = {\n    'Monday': [(540, 600), (630, 720), (750, 990)],\n    'Tuesday': [(540, 600), (630, 690), (720, 930), (960, 1020)],\n    'Wednesday': [(540, 660), (690, 1020)],\n    'Thursday': [(600, 720), (840, 870), (930, 960), (990, 1020)]\n}\n\ndays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\nduration = 30\n\nfor day in days:\n    mary_free = get_free_intervals(mary_busy.get(day, []))\n    alexis_free = get_free_intervals(alexis_busy.get(day, []))\n    found = False\n    for m_int in mary_free:\n        for a_int in alexis_free:\n            start_overlap = max(m_int[0], a_int[0])\n            end_overlap = min(m_int[1], a_int[1])\n            if end_overlap - start_overlap >= duration:\n                meeting_start = start_overlap\n                meeting_end = meeting_start + duration\n                h1 = meeting_start // 60\n                m1 = meeting_start % 60\n                h2 = meeting_end // 60\n                m2 = meeting_end % 60\n                time_str = f\"{h1:02d}:{m1:02d}:{h2:02d}:{m2:02d}\"\n                print(day)\n                print(time_str)\n                found = True\n                break\n        if found:\n            break\n    if found:\n        break\n```"
    }
]