[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Christine and Helen for half an hour between the work hours of 9:00 to 17:00 on Monday. \n\nHere are the existing schedules for everyone during the day: \nChristine has meetings on Monday during 11:00 to 11:30, 15:00 to 15:30; \nHelen has blocked their calendar on Monday during 9:30 to 10:30, 11:00 to 11:30, 12:00 to 12:30, 13:30 to 16:00, 16:30 to 17:00; \n\nHelen can not meet on Monday after 15:00. Find a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\ndef get_available_intervals(blocked_intervals, start, end):\n    if not blocked_intervals:\n        return [(start, end)]\n    blocked_sorted = sorted(blocked_intervals, key=lambda x: x[0])\n    available = []\n    current = start\n    for block in blocked_sorted:\n        if current < block[0]:\n            available.append((current, block[0]))\n        current = max(current, block[1])\n    if current < end:\n        available.append((current, end))\n    return available\n\nmeeting_duration = 30\nwork_start = 0\nwork_end = 360\n\nchristine_blocked = [(120, 150)]\nhelen_blocked = [(30, 90), (120, 150), (180, 210), (270, 360)]\n\nchristine_avail = get_available_intervals(christine_blocked, work_start, work_end)\nhelen_avail = get_available_intervals(helen_blocked, work_start, work_end)\n\nfor c_avail in christine_avail:\n    for h_avail in helen_avail:\n        low = max(c_avail[0], h_avail[0])\n        high = min(c_avail[1], h_avail[1])\n        if low < high and high - low >= meeting_duration:\n            meeting_start = low\n            meeting_end = low + meeting_duration\n            start_hour = 9 + meeting_start // 60\n            start_minute = meeting_start % 60\n            end_hour = 9 + meeting_end // 60\n            end_minute = meeting_end % 60\n            time_str = f\"{start_hour:02d}:{start_minute:02d}:{end_hour:02d}:{end_minute:02d}\"\n            print(f\"Monday {time_str}\")\n            exit()\n```"
    }
]