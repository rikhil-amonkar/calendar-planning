[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Megan and Daniel for one hour between the work hours of 9:00 to 17:00 on either Monday, Tuesday, Wednesday or Thursday. \n\nHere are the existing schedules for everyone during the days: \nMegan has meetings on Monday during 13:00 to 13:30, 14:00 to 15:30, Tuesday during 9:00 to 9:30, 12:00 to 12:30, 16:00 to 17:00, Wednesday during 9:30 to 10:00, 10:30 to 11:30, 12:30 to 14:00, 16:00 to 16:30, Thursday during 13:30 to 14:30, 15:00 to 15:30; \nDaniel is busy on Monday during 10:00 to 11:30, 12:30 to 15:00, Tuesday during 9:00 to 10:00, 10:30 to 17:00, Wednesday during 9:00 to 10:00, 10:30 to 11:30, 12:00 to 17:00, Thursday during 9:00 to 12:00, 12:30 to 14:30, 15:00 to 15:30, 16:00 to 17:00; \n\nThe group would like to meet at their earlist availability.\nFind a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\nimport re\n\ndef time_str_to_minutes(time_str):\n    parts = time_str.split(':')\n    return int(parts[0]) * 60 + int(parts[1])\n\ndef parse_schedule(s, days):\n    pattern = '(' + '|'.join(days) + ')'\n    parts = re.split(pattern, s)\n    schedule = {day: [] for day in days}\n    for i in range(1, len(parts), 2):\n        if i + 1 >= len(parts):\n            break\n        day_name = parts[i]\n        if day_name not in days:\n            continue\n        meeting_str = parts[i + 1].strip()\n        if meeting_str.startswith('during '):\n            meeting_str = meeting_str[7:]\n        meetings = meeting_str.split(',')\n        intervals = []\n        for meet in meetings:\n            meet = meet.strip()\n            if not meet:\n                continue\n            if ' to ' not in meet:\n                continue\n            times = meet.split(' to ')\n            if len(times) < 2:\n                continue\n            start_str = times[0].strip()\n            end_str = times[1].strip()\n            try:\n                start_min_abs = time_str_to_minutes(start_str)\n                end_min_abs = time_str_to_minutes(end_str)\n            except:\n                continue\n            start_min = start_min_abs - 540\n            end_min = end_min_abs - 540\n            if start_min < 0:\n                start_min = 0\n            if end_min > 480:\n                end_min = 480\n            if start_min < end_min:\n                intervals.append((start_min, end_min))\n        schedule[day_name] = intervals\n    return schedule\n\ndef merge_intervals(intervals):\n    if not intervals:\n        return []\n    sorted_intervals = sorted(intervals, key=lambda x: x[0])\n    merged = []\n    start, end = sorted_intervals[0]\n    for i in range(1, len(sorted_intervals)):\n        s, e = sorted_intervals[i]\n        if s <= end:\n            if e > end:\n                end = e\n        else:\n            merged.append((start, end))\n            start, end = s, e\n    merged.append((start, end))\n    return merged\n\ndef get_free_intervals(merged_busy, total_start=0, total_end=480):\n    free = []\n    current = total_start\n    for start, end in merged_busy:\n        if current < start:\n            free.append((current, start))\n        current = end\n    if current < total_end:\n        free.append((current, total_end))\n    return free\n\ndef main():\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    megan_str = \"Monday during 13:00 to 13:30, 14:00 to 15:30, Tuesday during 9:00 to 9:30, 12:00 to 12:30, 16:00 to 17:00, Wednesday during 9:30 to 10:00, 10:30 to 11:30, 12:30 to 14:00, 16:00 to 16:30, Thursday during 13:30 to 14:30, 15:00 to 15:30\"\n    daniel_str = \"Monday during 10:00 to 11:30, 12:30 to 15:00, Tuesday during 9:00 to 10:00, 10:30 to 17:00, Wednesday during 9:00 to 10:00, 10:30 to 11:30, 12:00 to 17:00, Thursday during 9:00 to 12:00, 12:30 to 14:30, 15:00 to 15:30, 16:00 to 17:00\"\n    megan_schedule = parse_schedule(megan_str, days)\n    daniel_schedule = parse_schedule(daniel_str, days)\n    for day in days:\n        busy_intervals = megan_schedule[day] + daniel_schedule[day]\n        merged_busy = merge_intervals(busy_intervals)\n        free_intervals = get_free_intervals(merged_busy)\n        for interval in free_intervals:\n            start, end = interval\n            duration = end - start\n            if duration >= 60:\n                abs_start_min = 540 + start\n                abs_end_min = abs_start_min + 60\n                start_hour = abs_start_min // 60\n                start_minute = abs_start_min % 60\n                end_hour = abs_end_min // 60\n                end_minute = abs_end_min % 60\n                time_str = f\"{start_hour:02d}:{start_minute:02d}:{end_hour:02d}:{end_minute:02d}\"\n                print(day)\n                print(time_str)\n                return\n\nif __name__ == \"__main__\":\n    main()\n```"
    }
]