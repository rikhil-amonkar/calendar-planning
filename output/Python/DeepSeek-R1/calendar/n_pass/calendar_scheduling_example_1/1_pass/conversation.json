[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Raymond, Billy and Donald for half an hour between the work hours of 9:00 to 17:00 on Monday. \n\nHere are the existing schedules for everyone during the day: \nRaymond has blocked their calendar on Monday during 9:00 to 9:30, 11:30 to 12:00, 13:00 to 13:30, 15:00 to 15:30; \nBilly has meetings on Monday during 10:00 to 10:30, 12:00 to 13:00, 16:30 to 17:00; \nDonald has meetings on Monday during 9:00 to 9:30, 10:00 to 11:00, 12:00 to 13:00, 14:00 to 14:30, 16:00 to 17:00; \n\nBilly would like to avoid more meetings on Monday after 15:00. Find a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\ndef invert_intervals(busy_intervals, start, end):\n    if not busy_intervals:\n        return [(start, end)]\n    busy_intervals.sort(key=lambda x: x[0])\n    free = []\n    current = start\n    for interval in busy_intervals:\n        if current < interval[0]:\n            free.append((current, interval[0]))\n        current = max(current, interval[1])\n    if current < end:\n        free.append((current, end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    if not intervals1 or not intervals2:\n        return []\n    i = j = 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        start1, end1 = intervals1[i]\n        start2, end2 = intervals2[j]\n        low = max(start1, start2)\n        high = min(end1, end2)\n        if low < high:\n            result.append((low, high))\n        if end1 < end2:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef main():\n    # Work day: 9:00 to 17:00 represented in minutes from 9:00 (0 minutes = 9:00, 480 minutes = 17:00)\n    work_start = 0\n    work_end = 480\n    meeting_duration = 30\n    # Billy's preference: avoid meetings after 15:00 (360 minutes from 9:00), so meeting must end by 360 (15:00) if possible\n    billy_cutoff = 360\n    \n    # Busy intervals for each participant (each interval is (start_minute, end_minute), end exclusive)\n    raymond_busy = [(0, 30), (150, 180), (240, 270), (360, 390)]\n    billy_busy = [(60, 90), (180, 240), (450, 480)]\n    donald_busy = [(0, 30), (60, 120), (180, 240), (300, 330), (420, 480)]\n    \n    # Calculate free intervals for each\n    raymond_free = invert_intervals(raymond_busy, work_start, work_end)\n    billy_free = invert_intervals(billy_busy, work_start, work_end)\n    donald_free = invert_intervals(donald_busy, work_start, work_end)\n    \n    # Find common free intervals\n    common_free = intersect_intervals(raymond_free, billy_free)\n    common_free = intersect_intervals(common_free, donald_free)\n    \n    candidate_start = None\n    # First, try to find a slot that ends by 15:00 (360 minutes)\n    for start, end in common_free:\n        slot_end = start + meeting_duration\n        if slot_end > end:  # Not enough time in this interval\n            continue\n        if slot_end <= billy_cutoff:  # Ends by 15:00\n            candidate_start = start\n            break\n    \n    # If no candidate found that ends by 15:00, take the first available slot of sufficient length\n    if candidate_start is None:\n        for start, end in common_free:\n            if end - start >= meeting_duration:\n                candidate_start = start\n                break\n    \n    # Convert candidate_start to time string\n    total_minutes_start = candidate_start\n    hours_start = 9 + total_minutes_start // 60\n    minutes_start = total_minutes_start % 60\n    total_minutes_end = candidate_start + meeting_duration\n    hours_end = 9 + total_minutes_end // 60\n    minutes_end = total_minutes_end % 60\n    \n    time_str = f\"{hours_start:02d}:{minutes_start:02d}:{hours_end:02d}:{minutes_end:02d}\"\n    print(\"Monday\")\n    print(time_str)\n\nif __name__ == \"__main__\":\n    main()\n```"
    }
]