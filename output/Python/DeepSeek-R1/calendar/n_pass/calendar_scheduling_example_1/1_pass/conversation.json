[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Raymond, Billy and Donald for half an hour between the work hours of 9:00 to 17:00 on Monday. \n\nHere are the existing schedules for everyone during the day: \nRaymond has blocked their calendar on Monday during 9:00 to 9:30, 11:30 to 12:00, 13:00 to 13:30, 15:00 to 15:30; \nBilly has meetings on Monday during 10:00 to 10:30, 12:00 to 13:00, 16:30 to 17:00; \nDonald has meetings on Monday during 9:00 to 9:30, 10:00 to 11:00, 12:00 to 13:00, 14:00 to 14:30, 16:00 to 17:00; \n\nBilly would like to avoid more meetings on Monday after 15:00. Find a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\ndef main():\n    # Define work hours: 9:00 to 17:00 (8 hours = 480 minutes)\n    work_start = 0   # 9:00 in minutes from 9:00\n    work_end = 480   # 17:00\n\n    # Busy intervals in minutes (relative to 9:00)\n    raymond_busy = [[0, 30], [150, 180], [240, 270], [360, 390]]\n    billy_busy = [[60, 90], [180, 240], [450, 480]]\n    donald_busy = [[0, 30], [60, 120], [180, 240], [300, 330], [420, 480]]\n\n    # Function to compute free intervals given busy intervals and work hours\n    def get_free_intervals(busy_intervals, start, end):\n        if not busy_intervals:\n            return [[start, end]]\n        sorted_busy = sorted(busy_intervals, key=lambda x: x[0])\n        free = []\n        current = start\n        for interval in sorted_busy:\n            s, e = interval\n            if current < s:\n                free.append([current, s])\n            current = max(current, e)\n        if current < end:\n            free.append([current, end])\n        return free\n\n    # Function to intersect two sets of intervals\n    def intersect_intervals(intervals1, intervals2):\n        if not intervals1 or not intervals2:\n            return []\n        i, j = 0, 0\n        result = []\n        while i < len(intervals1) and j < len(intervals2):\n            a1, a2 = intervals1[i]\n            b1, b2 = intervals2[j]\n            start = max(a1, b1)\n            end = min(a2, b2)\n            if start < end:\n                result.append([start, end])\n            if a2 < b2:\n                i += 1\n            else:\n                j += 1\n        return result\n\n    # Calculate free intervals for each person\n    raymond_free = get_free_intervals(raymond_busy, work_start, work_end)\n    billy_free = get_free_intervals(billy_busy, work_start, work_end)\n    donald_free = get_free_intervals(donald_busy, work_start, work_end)\n\n    # Find common free intervals\n    common_free = intersect_intervals(raymond_free, billy_free)\n    common_free = intersect_intervals(common_free, donald_free)\n\n    # Find the earliest 30-minute slot that starts before 15:00 (360 minutes) if available\n    candidate = None\n    for interval in common_free:\n        start, end = interval\n        if start + 30 <= end:\n            if start < 360:  # Meeting starts before 15:00\n                candidate = [start, start + 30]\n                break\n    if candidate is None:\n        for interval in common_free:\n            start, end = interval\n            if start + 30 <= end:\n                candidate = [start, start + 30]\n                break\n\n    # Convert candidate from minutes to time strings\n    def minutes_to_time(minutes):\n        total_minutes = minutes\n        hours = 9 + total_minutes // 60\n        mins = total_minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n\n    start_time = minutes_to_time(candidate[0])\n    end_time = minutes_to_time(candidate[1])\n    \n    # Output the time range and day\n    print(f\"{start_time}:{end_time}\")\n    print(\"Monday\")\n\nif __name__ == \"__main__\":\n    main()\n```"
    }
]