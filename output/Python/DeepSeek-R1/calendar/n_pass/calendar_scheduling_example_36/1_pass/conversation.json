[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Ryan, Ruth and Denise for one hour between the work hours of 9:00 to 17:00 on Monday. \n\nHere are the existing schedules for everyone during the day: \nRyan is busy on Monday during 9:00 to 9:30, 12:30 to 13:00; \nRuthhas no meetings the whole day.\nDenise has blocked their calendar on Monday during 9:30 to 10:30, 12:00 to 13:00, 14:30 to 16:30; \n\nDenise do not want to meet on Monday after 12:30. Find a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\ndef main():\n    # Convert time to minutes for easier calculations (using half-open intervals [start, end))\n    work_start = 9 * 60  # 9:00\n    work_end = 17 * 60   # 17:00\n    duration = 60         # 1 hour in minutes\n\n    # Denise constraint: available until 12:30 inclusive -> represented as [start, 751) to include 12:30\n    denise_available_end = 12 * 60 + 30 + 1  # 751 minutes (12:31 is excluded)\n\n    # Define busy intervals (half-open: [start, end))\n    ryan_busy = [\n        (9 * 60, 9 * 60 + 30),   # 9:00-9:30\n        (12 * 60 + 30, 13 * 60)  # 12:30-13:00\n    ]\n    ruth_busy = []  # No meetings\n    denise_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),  # 9:30-10:30\n        (12 * 60, 13 * 60),            # 12:00-13:00\n        (14 * 60 + 30, 16 * 60 + 30)   # 14:30-16:30\n    ]\n\n    # Participants with their available times and busy slots\n    participants = [\n        {\n            'name': 'Ryan',\n            'available_start': work_start,\n            'available_end': work_end,\n            'busy': ryan_busy\n        },\n        {\n            'name': 'Ruth',\n            'available_start': work_start,\n            'available_end': work_end,\n            'busy': ruth_busy\n        },\n        {\n            'name': 'Denise',\n            'available_start': work_start,\n            'available_end': denise_available_end,  # Until 12:30 inclusive (751 minutes)\n            'busy': denise_busy\n        }\n    ]\n\n    # Calculate free intervals for each participant\n    free_intervals = []\n    for participant in participants:\n        free = [(participant['available_start'], participant['available_end'])]\n        for (busy_start, busy_end) in participant['busy']:\n            new_free = []\n            for (start, end) in free:\n                # If busy interval doesn't overlap, keep the free interval\n                if busy_end <= start or busy_start >= end:\n                    new_free.append((start, end))\n                else:\n                    # Split the free interval around the busy block\n                    if start < busy_start:\n                        new_free.append((start, busy_start))\n                    if busy_end < end:\n                        new_free.append((busy_end, end))\n            free = new_free\n        free_intervals.append(free)\n\n    # Find intersection of free intervals across participants\n    current_free = free_intervals[0]\n    for i in range(1, len(free_intervals)):\n        next_free = free_intervals[i]\n        new_current = []\n        for (s1, e1) in current_free:\n            for (s2, e2) in next_free:\n                low = max(s1, s2)\n                high = min(e1, e2)\n                if low < high:\n                    new_current.append((low, high))\n        current_free = new_current\n\n    # Find first slot with sufficient duration\n    meeting_start = None\n    meeting_end = None\n    for (start, end) in current_free:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = start + duration\n            break\n\n    # Convert minutes back to time strings (HH:MM)\n    def format_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours}:{mins:02d}\"\n\n    start_str = format_time(meeting_start)\n    end_str = format_time(meeting_end)\n\n    # Output day and time range\n    print(\"Monday\")\n    print(f\"{start_str}:{end_str}\")\n\nif __name__ == \"__main__\":\n    main()\n```"
    }
]