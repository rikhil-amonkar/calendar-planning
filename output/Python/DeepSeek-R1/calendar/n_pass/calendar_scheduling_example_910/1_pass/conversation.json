[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Bryan and Nicholas for one hour between the work hours of 9:00 to 17:00 on either Monday, Tuesday, Wednesday, Thursday or Friday. \n\nHere are the existing schedules for everyone during the days: \nBryan has meetings on Thursday during 9:30 to 10:00, 12:30 to 13:00, Friday during 10:30 to 11:00, 14:00 to 14:30; \nNicholas has meetings on Monday during 11:30 to 12:00, 13:00 to 15:30, Tuesday during 9:00 to 9:30, 11:00 to 13:30, 14:00 to 16:30, Wednesday during 9:00 to 9:30, 10:00 to 11:00, 11:30 to 13:30, 14:00 to 14:30, 15:00 to 16:30, Thursday during 10:30 to 11:30, 12:00 to 12:30, 15:00 to 15:30, 16:30 to 17:00, Friday during 9:00 to 10:30, 11:00 to 12:00, 12:30 to 14:30, 15:30 to 16:00, 16:30 to 17:00; \n\nBryan would like to avoid more meetings on Tuesday. Nicholas would rather not meet on Monday. Thursday. Find a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\ndef time_to_minutes(time_str):\n    parts = time_str.split(':')\n    hours = int(parts[0])\n    minutes = int(parts[1])\n    total_minutes_since_midnight = hours * 60 + minutes\n    return total_minutes_since_midnight - 540  # 540 = 9*60 (minutes from midnight to 9:00)\n\ndef minutes_to_time(m):\n    total_minutes_since_midnight = 540 + m\n    hours = total_minutes_since_midnight // 60\n    minutes = total_minutes_since_midnight % 60\n    return f\"{hours}:{minutes:02d}\"\n\n# Define busy times for Bryan and Nicholas\nbryan_busy = {\n    'Thursday': [('9:30', '10:00'), ('12:30', '13:00')],\n    'Friday': [('10:30', '11:00'), ('14:00', '14:30')]\n}\n\nnicholas_busy = {\n    'Monday': [('11:30', '12:00'), ('13:00', '15:30')],\n    'Tuesday': [('9:00', '9:30'), ('11:00', '13:30'), ('14:00', '16:30')],\n    'Wednesday': [('9:00', '9:30'), ('10:00', '11:00'), ('11:30', '13:30'), ('14:00', '14:30'), ('15:00', '16:30')],\n    'Thursday': [('10:30', '11:30'), ('12:00', '12:30'), ('15:00', '15:30'), ('16:30', '17:00')],\n    'Friday': [('9:00', '10:30'), ('11:00', '12:00'), ('12:30', '14:30'), ('15:30', '16:00'), ('16:30', '17:00')]\n}\n\n# Preferred order of days to try: Wednesday, Friday, Tuesday, Monday, Thursday\ndays_to_try = ['Wednesday', 'Friday', 'Tuesday', 'Monday', 'Thursday']\nmeeting_duration = 60  # 60 minutes\n\nfor day in days_to_try:\n    busy_intervals = []\n    \n    # Add Bryan's meetings for the day\n    if day in bryan_busy:\n        for interval in bryan_busy[day]:\n            start_min = time_to_minutes(interval[0])\n            end_min = time_to_minutes(interval[1])\n            busy_intervals.append((start_min, end_min))\n    \n    # Add Nicholas's meetings for the day\n    if day in nicholas_busy:\n        for interval in nicholas_busy[day]:\n            start_min = time_to_minutes(interval[0])\n            end_min = time_to_minutes(interval[1])\n            busy_intervals.append((start_min, end_min))\n    \n    # If no meetings, the whole day is free\n    if not busy_intervals:\n        start_time = minutes_to_time(0)\n        end_time = minutes_to_time(60)\n        print(day)\n        print(f\"{start_time}:{end_time}\")\n        break\n    \n    # Sort intervals by start time\n    busy_intervals.sort(key=lambda x: x[0])\n    \n    # Merge overlapping intervals\n    merged = []\n    current_start, current_end = busy_intervals[0]\n    for i in range(1, len(busy_intervals)):\n        s, e = busy_intervals[i]\n        if s <= current_end:\n            current_end = max(current_end, e)\n        else:\n            merged.append((current_start, current_end))\n            current_start, current_end = s, e\n    merged.append((current_start, current_end))\n    \n    # Check for gaps: from start of day (0) to first meeting, between meetings, and from last meeting to end (480 minutes)\n    gaps = []\n    # Gap before first meeting\n    first_start = merged[0][0]\n    if first_start > 0:\n        gaps.append((0, first_start))\n    \n    # Gaps between meetings\n    for i in range(len(merged) - 1):\n        current_end = merged[i][1]\n        next_start = merged[i+1][0]\n        if next_start > current_end:\n            gaps.append((current_end, next_start))\n    \n    # Gap after last meeting\n    last_end = merged[-1][1]\n    if last_end < 480:\n        gaps.append((last_end, 480))\n    \n    # Find the first gap that can fit the meeting\n    found = False\n    for gap in gaps:\n        gap_start, gap_end = gap\n        if gap_end - gap_start >= meeting_duration:\n            meeting_start = gap_start\n            meeting_end = meeting_start + meeting_duration\n            start_time_str = minutes_to_time(meeting_start)\n            end_time_str = minutes_to_time(meeting_end)\n            print(day)\n            print(f\"{start_time_str}:{end_time_str}\")\n            found = True\n            break\n    \n    if found:\n        break\n```"
    }
]