[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Natalie, David, Douglas, Ralph and Jordan for half an hour between the work hours of 9:00 to 17:00 on Monday. \n\nHere are the existing schedules for everyone during the day: \nNatalie's calendar is wide open the entire day.\nDavid is busy on Monday during 11:30 to 12:00, 14:30 to 15:00; \nDouglas has blocked their calendar on Monday during 9:30 to 10:00, 11:30 to 12:00, 13:00 to 13:30, 14:30 to 15:00; \nRalph has meetings on Monday during 9:00 to 9:30, 10:00 to 11:00, 11:30 to 12:30, 13:30 to 15:00, 15:30 to 16:00, 16:30 to 17:00; \nJordan is busy on Monday during 9:00 to 10:00, 12:00 to 12:30, 13:00 to 13:30, 14:30 to 15:00, 15:30 to 17:00; \n\nDavid do not want to meet on Monday before 14:00. Find a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\ndef time_str_to_minutes(time_str):\n    h, m = time_str.split(':')\n    return (int(h) - 9) * 60 + int(m)\n\ndef get_free_intervals(busy_intervals, start, end):\n    if not busy_intervals:\n        return [(start, end)]\n    intervals_in_range = []\n    for s, e in busy_intervals:\n        low = max(s, start)\n        high = min(e, end)\n        if low < high:\n            intervals_in_range.append((low, high))\n    if not intervals_in_range:\n        return [(start, end)]\n    intervals_in_range.sort(key=lambda x: x[0])\n    free = []\n    current = start\n    for s, e in intervals_in_range:\n        if current < s:\n            free.append((current, s))\n        current = e\n    if current < end:\n        free.append((current, end))\n    return free\n\ndef intersect_intervals(intervals1, intervals2):\n    i = j = 0\n    result = []\n    while i < len(intervals1) and j < len(intervals2):\n        a1, a2 = intervals1[i]\n        b1, b2 = intervals2[j]\n        low = max(a1, b1)\n        high = min(a2, b2)\n        if low < high:\n            result.append((low, high))\n        if a2 < b2:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef main():\n    work_start = 0\n    work_end = 480  # 9:00 to 17:00 is 8 hours = 480 minutes\n    \n    # Define busy intervals in minutes (relative to 9:00)\n    natalie_busy = []\n    david_busy = [(time_str_to_minutes(\"11:30\"), time_str_to_minutes(\"12:00\")), \n                  (time_str_to_minutes(\"14:30\"), time_str_to_minutes(\"15:00\"))]\n    douglas_busy = [(time_str_to_minutes(\"9:30\"), time_str_to_minutes(\"10:00\")),\n                    (time_str_to_minutes(\"11:30\"), time_str_to_minutes(\"12:00\")),\n                    (time_str_to_minutes(\"13:00\"), time_str_to_minutes(\"13:30\")),\n                    (time_str_to_minutes(\"14:30\"), time_str_to_minutes(\"15:00\"))]\n    ralph_busy = [(time_str_to_minutes(\"9:00\"), time_str_to_minutes(\"9:30\")),\n                  (time_str_to_minutes(\"10:00\"), time_str_to_minutes(\"11:00\")),\n                  (time_str_to_minutes(\"11:30\"), time_str_to_minutes(\"12:30\")),\n                  (time_str_to_minutes(\"13:30\"), time_str_to_minutes(\"15:00\")),\n                  (time_str_to_minutes(\"15:30\"), time_str_to_minutes(\"16:00\")),\n                  (time_str_to_minutes(\"16:30\"), time_str_to_minutes(\"17:00\"))]\n    jordan_busy = [(time_str_to_minutes(\"9:00\"), time_str_to_minutes(\"10:00\")),\n                   (time_str_to_minutes(\"12:00\"), time_str_to_minutes(\"12:30\")),\n                   (time_str_to_minutes(\"13:00\"), time_str_to_minutes(\"13:30\")),\n                   (time_str_to_minutes(\"14:30\"), time_str_to_minutes(\"15:00\")),\n                   (time_str_to_minutes(\"15:30\"), time_str_to_minutes(\"17:00\"))]\n    \n    # David's constraint: only available after 14:00 (300 minutes)\n    david_constraint_start = time_str_to_minutes(\"14:00\")\n    \n    # Get free intervals for each participant\n    natalie_free = get_free_intervals(natalie_busy, work_start, work_end)\n    david_free = get_free_intervals(david_busy, david_constraint_start, work_end)\n    douglas_free = get_free_intervals(douglas_busy, work_start, work_end)\n    ralph_free = get_free_intervals(ralph_busy, work_start, work_end)\n    jordan_free = get_free_intervals(jordan_busy, work_start, work_end)\n    \n    # Compute common free intervals\n    common_free = natalie_free\n    for free_intervals in [david_free, douglas_free, ralph_free, jordan_free]:\n        common_free = intersect_intervals(common_free, free_intervals)\n    \n    # Find the first 30-minute slot\n    meeting_duration = 30\n    meeting_start = None\n    for start, end in common_free:\n        if end - start >= meeting_duration:\n            meeting_start = start\n            break\n    \n    if meeting_start is None:\n        # According to the problem, there is a solution, so this should not happen.\n        print(\"Monday\")\n        print(\"00:00:00:00\")\n        return\n    \n    meeting_end = meeting_start + meeting_duration\n    \n    # Convert meeting_start and meeting_end to time strings\n    def minutes_to_time(minutes):\n        total_minutes = minutes\n        hour = 9 + total_minutes // 60\n        minute = total_minutes % 60\n        return f\"{hour:02d}:{minute:02d}\"\n    \n    start_time_str = minutes_to_time(meeting_start)\n    end_time_str = minutes_to_time(meeting_end)\n    \n    # Format the output as HH:MM:HH:MM\n    time_range_str = f\"{start_time_str}:{end_time_str}\"\n    \n    print(\"Monday\")\n    print(time_range_str)\n\nif __name__ == \"__main__\":\n    main()\n```"
    }
]