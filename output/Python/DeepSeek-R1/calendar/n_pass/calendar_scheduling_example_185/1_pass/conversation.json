[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Kimberly, Megan, Marie and Diana for half an hour between the work hours of 9:00 to 17:00 on Monday. \n\nHere are the existing schedules for everyone during the day: \nKimberly has meetings on Monday during 10:00 to 10:30, 11:00 to 12:00, 16:00 to 16:30; \nMeganhas no meetings the whole day.\nMarie is busy on Monday during 10:00 to 11:00, 11:30 to 15:00, 16:00 to 16:30; \nDiana is busy on Monday during 9:30 to 10:00, 10:30 to 14:30, 15:30 to 17:00; \n\nMegan would like to avoid more meetings on Monday before 10:00. Find a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\ndef main():\n    # Convert time string to minutes from 9:00\n    def time_to_min(time_str):\n        hours, minutes = map(int, time_str.split(':'))\n        return (hours - 9) * 60 + minutes\n\n    # Convert minutes back to time string\n    def min_to_time(m):\n        total_minutes = 9 * 60 + m\n        hours = total_minutes // 60\n        minutes = total_minutes % 60\n        return f\"{hours:02d}:{minutes:02d}\"\n\n    # Meeting parameters\n    day = \"Monday\"\n    duration_min = 30\n    work_start = time_to_min(\"9:00\")\n    work_end = time_to_min(\"17:00\")\n    available_start = time_to_min(\"10:00\")  # Megan's constraint\n    available_end = work_end\n\n    # Define busy intervals (each as [start, end) in minutes from 9:00)\n    kimberly_busy = [\n        (time_to_min(\"10:00\"), time_to_min(\"10:30\")),\n        (time_to_min(\"11:00\"), time_to_min(\"12:00\")),\n        (time_to_min(\"16:00\"), time_to_min(\"16:30\"))\n    ]\n    megan_busy = []  # No meetings, but constraint handled via available_start\n    marie_busy = [\n        (time_to_min(\"10:00\"), time_to_min(\"11:00\")),\n        (time_to_min(\"11:30\"), time_to_min(\"15:00\")),\n        (time_to_min(\"16:00\"), time_to_min(\"16:30\"))\n    ]\n    diana_busy = [\n        (time_to_min(\"9:30\"), time_to_min(\"10:00\")),\n        (time_to_min(\"10:30\"), time_to_min(\"14:30\")),\n        (time_to_min(\"15:30\"), time_to_min(\"17:00\"))\n    ]\n\n    # Combine all busy intervals\n    all_busy = kimberly_busy + megan_busy + marie_busy + diana_busy\n    \n    # Sort by start time\n    all_busy.sort(key=lambda x: x[0])\n    \n    # Merge overlapping intervals\n    merged = []\n    if all_busy:\n        current_start, current_end = all_busy[0]\n        for s, e in all_busy[1:]:\n            if s <= current_end:\n                current_end = max(current_end, e)\n            else:\n                merged.append((current_start, current_end))\n                current_start, current_end = s, e\n        merged.append((current_start, current_end))\n    \n    # Find free intervals within available hours\n    free_intervals = []\n    current = available_start\n    for s, e in merged:\n        if s > current:\n            gap = s - current\n            if gap >= duration_min:\n                free_intervals.append((current, s))\n            current = e\n        else:\n            if e > current:\n                current = e\n    if current < available_end:\n        gap = available_end - current\n        if gap >= duration_min:\n            free_intervals.append((current, available_end))\n    \n    # Select the first available slot\n    if free_intervals:\n        start_min, _ = free_intervals[0]\n        end_min = start_min + duration_min\n        start_str = min_to_time(start_min)\n        end_str = min_to_time(end_min)\n        time_range_str = f\"{start_str}:{end_str}\"\n        print(day)\n        print(time_range_str)\n    else:\n        print(\"No suitable time found\")\n\nif __name__ == \"__main__\":\n    main()\n```"
    }
]