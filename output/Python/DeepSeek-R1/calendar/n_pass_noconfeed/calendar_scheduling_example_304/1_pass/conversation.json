[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Christine, Janice, Bobby, Elizabeth, Tyler and Edward for half an hour between the work hours of 9:00 to 17:00 on Monday. \n\nHere are the existing schedules for everyone during the day: \nChristine is busy on Monday during 9:30 to 10:30, 12:00 to 12:30, 13:00 to 13:30, 14:30 to 15:00, 16:00 to 16:30; \nJanice's calendar is wide open the entire day.\nBobby is busy on Monday during 12:00 to 12:30, 14:30 to 15:00; \nElizabeth is busy on Monday during 9:00 to 9:30, 11:30 to 13:00, 13:30 to 14:00, 15:00 to 15:30, 16:00 to 17:00; \nTyler is busy on Monday during 9:00 to 11:00, 12:00 to 12:30, 13:00 to 13:30, 15:30 to 16:00, 16:30 to 17:00; \nEdward is busy on Monday during 9:00 to 9:30, 10:00 to 11:00, 11:30 to 14:00, 14:30 to 15:30, 16:00 to 17:00; \n\nJanice would rather not meet on Monday after 13:00. Find a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\ndef min_to_time(mins):\n    h = mins // 60\n    m = mins % 60\n    return f\"{h:02d}:{m:02d}\"\n\n# Work hours and day\nwork_start = 9 * 60   # 540\nwork_end = 17 * 60    # 1020\nmeeting_duration = 30\npreference_cutoff = 13 * 60  # 780 (1 PM)\n\n# Busy intervals for each participant in minutes (each as (start, end))\n# Christine\nchristine_busy = [\n    (9*60+30, 10*60+30),\n    (12*60, 12*60+30),\n    (13*60, 13*60+30),\n    (14*60+30, 15*60),\n    (16*60, 16*60+30)\n]\n# Janice: none\njanice_busy = []\n# Bobby\nbobby_busy = [\n    (12*60, 12*60+30),\n    (14*60+30, 15*60)\n]\n# Elizabeth\nelizabeth_busy = [\n    (9*60, 9*60+30),\n    (11*60+30, 13*60),\n    (13*60+30, 14*60),\n    (15*60, 15*60+30),\n    (16*60, 17*60)\n]\n# Tyler\ntyler_busy = [\n    (9*60, 11*60),\n    (12*60, 12*60+30),\n    (13*60, 13*60+30),\n    (15*60+30, 16*60),\n    (16*60+30, 17*60)\n]\n# Edward\nedward_busy = [\n    (9*60, 9*60+30),\n    (10*60, 11*60),\n    (11*60+30, 14*60),\n    (14*60+30, 15*60+30),\n    (16*60, 17*60)\n]\n\n# Combine all busy intervals\nall_busy = []\nall_busy.extend(christine_busy)\nall_busy.extend(janice_busy)\nall_busy.extend(bobby_busy)\nall_busy.extend(elizabeth_busy)\nall_busy.extend(tyler_busy)\nall_busy.extend(edward_busy)\n\n# Sort by start time\nall_busy.sort(key=lambda x: x[0])\n\n# Merge intervals\nmerged_busy = []\nif all_busy:\n    merged_busy = [all_busy[0]]\n    for i in range(1, len(all_busy)):\n        current = all_busy[i]\n        last = merged_busy[-1]\n        if current[0] <= last[1]:\n            if current[1] > last[1]:\n                merged_busy[-1] = (last[0], current[1])\n        else:\n            merged_busy.append(current)\n\n# Now compute free intervals\nfree_intervals = []\ncurrent_start = work_start\nfor busy in merged_busy:\n    if busy[0] > current_start:\n        free_intervals.append((current_start, busy[0]))\n    current_start = max(current_start, busy[1])\nif current_start < work_end:\n    free_intervals.append((current_start, work_end))\n\n# Now, look for a meeting slot\nmeeting_slot = None\n# First, try to find a slot that ends by preference_cutoff (780)\nfor interval in free_intervals:\n    start, end = interval\n    if end - start >= meeting_duration:\n        if start + meeting_duration <= preference_cutoff:\n            meeting_slot = (start, start + meeting_duration)\n            break\n\nif meeting_slot is None:\n    for interval in free_intervals:\n        start, end = interval\n        if end - start >= meeting_duration:\n            meeting_slot = (start, start + meeting_duration)\n            break\n\n# Convert meeting_slot to time string\nif meeting_slot is not None:\n    day = \"Monday\"\n    start_time_str = min_to_time(meeting_slot[0])\n    end_time_str = min_to_time(meeting_slot[1])\n    time_range_str = f\"{start_time_str}:{end_time_str}\"\n    print(f\"{day} {time_range_str}\")\n```"
    }
]