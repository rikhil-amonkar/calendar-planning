[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Ryan, Ruth and Denise for one hour between the work hours of 9:00 to 17:00 on Monday. \n\nHere are the existing schedules for everyone during the day: \nRyan is busy on Monday during 9:00 to 9:30, 12:30 to 13:00; \nRuthhas no meetings the whole day.\nDenise has blocked their calendar on Monday during 9:30 to 10:30, 12:00 to 13:00, 14:30 to 16:30; \n\nDenise do not want to meet on Monday after 12:30. Find a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\ndef time_str_to_minutes(time_str):\n    parts = time_str.split(':')\n    hour = int(parts[0])\n    minute = int(parts[1])\n    return hour * 60 + minute\n\ndef minutes_to_time_str(minutes):\n    hour = minutes // 60\n    minute = minutes % 60\n    return f\"{hour:02d}:{minute:02d}\"\n\ndef compute_free_intervals(busy_intervals, work_start, work_end):\n    if not busy_intervals:\n        return [(work_start, work_end)]\n    sorted_busy = sorted(busy_intervals, key=lambda x: x[0])\n    free = []\n    current = work_start\n    for s, e in sorted_busy:\n        if current < s:\n            free.append((current, s))\n        current = max(current, e)\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef intersect_intervals(intervals_a, intervals_b):\n    i = j = 0\n    result = []\n    while i < len(intervals_a) and j < len(intervals_b):\n        low = max(intervals_a[i][0], intervals_b[j][0])\n        high = min(intervals_a[i][1], intervals_b[j][1])\n        if low < high:\n            result.append((low, high))\n        if intervals_a[i][1] < intervals_b[j][1]:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef main():\n    work_start_min = time_str_to_minutes(\"9:00\")\n    work_end_min = time_str_to_minutes(\"12:30\")  # meeting must end by 12:30\n    duration_min = 60\n\n    ryan_busy_str = [(\"9:00\", \"9:30\"), (\"12:30\", \"13:00\")]\n    ruth_busy_str = []\n    denise_busy_str = [(\"9:30\", \"10:30\"), (\"12:00\", \"13:00\"), (\"14:30\", \"16:30\")]\n\n    ryan_busy_min = []\n    for s, e in ryan_busy_str:\n        s_min = time_str_to_minutes(s)\n        e_min = time_str_to_minutes(e)\n        s_min = max(s_min, work_start_min)\n        e_min = min(e_min, work_end_min)\n        if s_min < e_min:\n            ryan_busy_min.append((s_min, e_min))\n\n    ruth_busy_min = []\n    for s, e in ruth_busy_str:\n        s_min = time_str_to_minutes(s)\n        e_min = time_str_to_minutes(e)\n        s_min = max(s_min, work_start_min)\n        e_min = min(e_min, work_end_min)\n        if s_min < e_min:\n            ruth_busy_min.append((s_min, e_min))\n\n    denise_busy_min = []\n    for s, e in denise_busy_str:\n        s_min = time_str_to_minutes(s)\n        e_min = time_str_to_minutes(e)\n        s_min = max(s_min, work_start_min)\n        e_min = min(e_min, work_end_min)\n        if s_min < e_min:\n            denise_busy_min.append((s_min, e_min))\n\n    free_ryan = compute_free_intervals(ryan_busy_min, work_start_min, work_end_min)\n    free_ruth = compute_free_intervals(ruth_busy_min, work_start_min, work_end_min)\n    free_denise = compute_free_intervals(denise_busy_min, work_start_min, work_end_min)\n\n    common = intersect_intervals(free_ryan, free_ruth)\n    common = intersect_intervals(common, free_denise)\n\n    meeting_start = None\n    for s, e in common:\n        if e - s >= duration_min:\n            meeting_start = s\n            break\n\n    if meeting_start is None:\n        print(\"No solution found\")\n        return\n\n    meeting_end = meeting_start + duration_min\n    start_str = minutes_to_time_str(meeting_start)\n    end_str = minutes_to_time_str(meeting_end)\n    time_range_str = start_str + ':' + end_str\n\n    print(\"Monday\")\n    print(time_range_str)\n\nif __name__ == \"__main__\":\n    main()\n```"
    }
]