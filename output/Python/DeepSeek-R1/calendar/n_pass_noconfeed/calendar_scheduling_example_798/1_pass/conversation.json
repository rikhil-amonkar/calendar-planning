[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Nancy and Jose for half an hour between the work hours of 9:00 to 17:00 on either Monday, Tuesday or Wednesday. \n\nHere are the existing schedules for everyone during the days: \nNancy has blocked their calendar on Monday during 10:00 to 10:30, 11:30 to 12:30, 13:30 to 14:00, 14:30 to 15:30, 16:00 to 17:00, Tuesday during 9:30 to 10:30, 11:00 to 11:30, 12:00 to 12:30, 13:00 to 13:30, 15:30 to 16:00, Wednesday during 10:00 to 11:30, 13:30 to 16:00; \nJose is busy on Monday during 9:00 to 17:00, Tuesday during 9:00 to 17:00, Wednesday during 9:00 to 9:30, 10:00 to 12:30, 13:30 to 14:30, 15:00 to 17:00; \n\nThe group would like to meet at their earlist availability.\nFind a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\nimport re\n\ndef parse_busy_for_participant(s, day_list):\n    pattern = '(' + '|'.join(day_list) + ')'\n    tokens = re.split(pattern, s)\n    result = {}\n    i = 1\n    while i < len(tokens):\n        day_name = tokens[i]\n        if i+1 < len(tokens):\n            time_str = tokens[i+1].strip()\n            if time_str.startswith('during'):\n                time_str = time_str[6:].strip()\n            time_str = time_str.rstrip(';,').strip()\n            intervals = []\n            if time_str != '':\n                parts = time_str.split(',')\n                for part in parts:\n                    part = part.strip()\n                    if part == '':\n                        continue\n                    if 'to' not in part:\n                        continue\n                    times = part.split('to')\n                    if len(times) < 2:\n                        continue\n                    start_time_str = times[0].strip()\n                    end_time_str = times[1].strip()\n                    try:\n                        start_h, start_m = start_time_str.split(':')\n                        end_h, end_m = end_time_str.split(':')\n                        start_minutes = int(start_h)*60 + int(start_m)\n                        end_minutes = int(end_h)*60 + int(end_m)\n                        intervals.append((start_minutes, end_minutes))\n                    except:\n                        pass\n            result[day_name] = intervals\n        i += 2\n    return result\n\ndef merge_intervals(intervals):\n    if not intervals:\n        return []\n    sorted_intervals = sorted(intervals, key=lambda x: x[0])\n    merged = []\n    start, end = sorted_intervals[0]\n    for i in range(1, len(sorted_intervals)):\n        s, e = sorted_intervals[i]\n        if s <= end:\n            end = max(end, e)\n        else:\n            merged.append((start, end))\n            start, end = s, e\n    merged.append((start, end))\n    return merged\n\ndef compute_free_intervals(busy_intervals, work_start, work_end):\n    merged_busy = merge_intervals(busy_intervals)\n    free = []\n    current = work_start\n    for s, e in merged_busy:\n        if current < s:\n            free.append((current, s))\n        current = max(current, e)\n        if current >= work_end:\n            break\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef interval_intersection(intervals1, intervals2):\n    i, j = 0, 0\n    common = []\n    while i < len(intervals1) and j < len(intervals2):\n        a1, b1 = intervals1[i]\n        a2, b2 = intervals2[j]\n        low = max(a1, a2)\n        high = min(b1, b2)\n        if low < high:\n            common.append((low, high))\n        if b1 < b2:\n            i += 1\n        else:\n            j += 1\n    return common\n\ndef main():\n    nancy_str = \"Monday during 10:00 to 10:30, 11:30 to 12:30, 13:30 to 14:00, 14:30 to 15:30, 16:00 to 17:00, Tuesday during 9:30 to 10:30, 11:00 to 11:30, 12:00 to 12:30, 13:00 to 13:30, 15:30 to 16:00, Wednesday during 10:00 to 11:30, 13:30 to 16:00;\"\n    jose_str = \"Monday during 9:00 to 17:00, Tuesday during 9:00 to 17:00, Wednesday during 9:00 to 9:30, 10:00 to 12:30, 13:30 to 14:30, 15:00 to 17:00;\"\n    \n    days_of_week = ['Monday', 'Tuesday', 'Wednesday']\n    work_start = 9 * 60\n    work_end = 17 * 60\n    duration = 30\n    \n    nancy_busy_dict = parse_busy_for_participant(nancy_str, days_of_week)\n    jose_busy_dict = parse_busy_for_participant(jose_str, days_of_week)\n    \n    for day in days_of_week:\n        nancy_busy = nancy_busy_dict.get(day, [])\n        jose_busy = jose_busy_dict.get(day, [])\n        \n        free_nancy = compute_free_intervals(nancy_busy, work_start, work_end)\n        free_jose = compute_free_intervals(jose_busy, work_start, work_end)\n        common_free = interval_intersection(free_nancy, free_jose)\n        \n        for start, end in common_free:\n            if end - start >= duration:\n                meeting_start = start\n                meeting_end = meeting_start + duration\n                start_hour = meeting_start // 60\n                start_minute = meeting_start % 60\n                end_hour = meeting_end // 60\n                end_minute = meeting_end % 60\n                start_str = f\"{start_hour:02d}:{start_minute:02d}\"\n                end_str = f\"{end_hour:02d}:{end_minute:02d}\"\n                time_range_str = f\"{start_str}:{end_str}\"\n                print(day)\n                print(time_range_str)\n                return\n\nif __name__ == \"__main__\":\n    main()\n```"
    }
]