[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Amy and Pamela for half an hour between the work hours of 9:00 to 17:00 on either Monday, Tuesday or Wednesday. \n\nHere are the existing schedules for everyone during the days: \nAmy is busy on Wednesday during 11:00 to 11:30, 13:30 to 14:00; \nPamela is busy on Monday during 9:00 to 10:30, 11:00 to 16:30, Tuesday during 9:00 to 9:30, 10:00 to 17:00, Wednesday during 9:00 to 9:30, 10:00 to 11:00, 11:30 to 13:30, 14:30 to 15:00, 16:00 to 16:30; \n\nPamela would like to avoid more meetings on Monday. Tuesday. Wednesday before 16:00. Find a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\ndef time_to_minutes(time_str):\n    hours, minutes = map(int, time_str.split(':'))\n    return hours * 60 + minutes\n\ndef minutes_to_time(total_minutes):\n    hours = total_minutes // 60\n    minutes = total_minutes % 60\n    return f\"{hours:02d}:{minutes:02d}\"\n\ndef get_free_intervals(busy_intervals, work_start, work_end):\n    if not busy_intervals:\n        return [(work_start, work_end)]\n    sorted_busy = sorted(busy_intervals, key=lambda x: x[0])\n    free = []\n    current_start = work_start\n    for start, end in sorted_busy:\n        if current_start < start:\n            free.append((current_start, start))\n        current_start = max(current_start, end)\n    if current_start < work_end:\n        free.append((current_start, work_end))\n    return free\n\ndef intersect_intervals(intervals_a, intervals_b):\n    i, j = 0, 0\n    common = []\n    while i < len(intervals_a) and j < len(intervals_b):\n        a_start, a_end = intervals_a[i]\n        b_start, b_end = intervals_b[j]\n        start = max(a_start, b_start)\n        end = min(a_end, b_end)\n        if start < end:\n            common.append((start, end))\n        if a_end < b_end:\n            i += 1\n        else:\n            j += 1\n    return common\n\ndef main():\n    work_start_min = time_to_minutes(\"9:00\")\n    work_end_min = time_to_minutes(\"17:00\")\n    meeting_duration = 30\n\n    amy_busy = {\n        'Wednesday': [\n            (time_to_minutes(\"11:00\"), time_to_minutes(\"11:30\")),\n            (time_to_minutes(\"13:30\"), time_to_minutes(\"14:00\"))\n        ]\n    }\n\n    pamela_busy = {\n        'Wednesday': [\n            (time_to_minutes(\"9:00\"), time_to_minutes(\"9:30\")),\n            (time_to_minutes(\"10:00\"), time_to_minutes(\"11:00\")),\n            (time_to_minutes(\"11:30\"), time_to_minutes(\"13:30\")),\n            (time_to_minutes(\"14:30\"), time_to_minutes(\"15:00\")),\n            (time_to_minutes(\"16:00\"), time_to_minutes(\"16:30\"))\n        ]\n    }\n\n    # Only consider Wednesday due to preference\n    day = \"Wednesday\"\n    \n    # Get free intervals for Amy and Pamela on Wednesday\n    amy_free = get_free_intervals(amy_busy.get(day, []), work_start_min, work_end_min)\n    pamela_free = get_free_intervals(pamela_busy[day], work_start_min, work_end_min)\n    \n    # Find common free intervals\n    common_free = intersect_intervals(amy_free, pamela_free)\n    \n    # Filter for intervals starting at or after 16:00 (960 minutes)\n    preferred_start_min = time_to_minutes(\"16:00\")\n    candidate = None\n    for start, end in common_free:\n        if start >= preferred_start_min and (end - start) >= meeting_duration:\n            candidate = (start, start + meeting_duration)\n            break\n    \n    if candidate:\n        start_min, end_min = candidate\n        start_time = minutes_to_time(start_min)\n        end_time = minutes_to_time(end_min)\n        print(day)\n        print(f\"{start_time}:{end_time}\")\n\nif __name__ == \"__main__\":\n    main()\n```"
    }
]