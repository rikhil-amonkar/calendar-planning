[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Jack and Charlotte for half an hour between the work hours of 9:00 to 17:00 on Monday. \n\nHere are the existing schedules for everyone during the day: \nJack is busy on Monday during 9:30 to 10:30, 11:00 to 11:30, 12:30 to 13:00, 14:00 to 14:30, 16:00 to 16:30; \nCharlotte has meetings on Monday during 9:30 to 10:00, 10:30 to 12:00, 12:30 to 13:30, 14:00 to 16:00; \n\nJack would like to avoid more meetings on Monday after 12:30. Find a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\ndef get_free_intervals(busy_list, work_start, work_end):\n    busy_list.sort(key=lambda x: x[0])\n    free = []\n    current = work_start\n    for s, e in busy_list:\n        if s >= work_end:\n            continue\n        if current < s:\n            free.append((current, s))\n        current = max(current, e + 1)\n        if current >= work_end:\n            break\n    if current < work_end:\n        free.append((current, work_end))\n    return free\n\ndef main():\n    # Work hours and constraint: 9:00 to 17:00, but Jack avoids after 12:30\n    work_start = 9 * 60  # 9:00 in minutes\n    constraint_end = 12 * 60 + 30  # 12:30 in minutes\n    work_end = constraint_end  # scheduling only until 12:30\n\n    # Busy intervals (inclusive)\n    jack_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),  # 9:30-10:30\n        (11 * 60, 11 * 60 + 30),      # 11:00-11:30\n        (12 * 60 + 30, 13 * 60)       # 12:30-13:00 (starts at constraint_end, skip)\n    ]\n    charlotte_busy = [\n        (9 * 60 + 30, 10 * 60),       # 9:30-10:00\n        (10 * 60 + 30, 12 * 60),      # 10:30-12:00\n        (12 * 60 + 30, 13 * 60 + 30)  # 12:30-13:30 (skip)\n    ]\n    \n    # Filter out intervals starting at or after work_end\n    jack_busy = [(s, e) for s, e in jack_busy if s < work_end]\n    charlotte_busy = [(s, e) for s, e in charlotte_busy if s < work_end]\n    \n    # Compute free intervals\n    free_jack = get_free_intervals(jack_busy, work_start, work_end)\n    free_charlotte = get_free_intervals(charlotte_busy, work_start, work_end)\n    \n    # Find the earliest overlapping free interval of at least 30 minutes\n    candidate = None\n    for j_start, j_end in free_jack:\n        for c_start, c_end in free_charlotte:\n            start_overlap = max(j_start, c_start)\n            end_overlap = min(j_end, c_end)\n            if end_overlap - start_overlap >= 30:\n                meeting_start = start_overlap\n                meeting_end = meeting_start + 30\n                candidate = (meeting_start, meeting_end)\n                break\n        if candidate is not None:\n            break\n    \n    # Format and output the result\n    if candidate is None:\n        print(\"No suitable time found\")\n    else:\n        def format_time(minutes):\n            h = minutes // 60\n            m = minutes % 60\n            return f\"{h:02d}:{m:02d}\"\n        \n        start_str = format_time(candidate[0])\n        end_str = format_time(candidate[1])\n        print(\"Monday\")\n        print(f\"{start_str}:{end_str}\")\n\nif __name__ == \"__main__\":\n    main()\n```"
    }
]