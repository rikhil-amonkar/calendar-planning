[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Raymond, Billy and Donald for half an hour between the work hours of 9:00 to 17:00 on Monday. \n\nHere are the existing schedules for everyone during the day: \nRaymond has blocked their calendar on Monday during 9:00 to 9:30, 11:30 to 12:00, 13:00 to 13:30, 15:00 to 15:30; \nBilly has meetings on Monday during 10:00 to 10:30, 12:00 to 13:00, 16:30 to 17:00; \nDonald has meetings on Monday during 9:00 to 9:30, 10:00 to 11:00, 12:00 to 13:00, 14:00 to 14:30, 16:00 to 17:00; \n\nBilly would like to avoid more meetings on Monday after 15:00. Find a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\ndef main():\n    # Convert time string to minutes since 9:00\n    def time_to_minutes(time_str):\n        parts = time_str.split(':')\n        hour = int(parts[0])\n        minute = int(parts[1])\n        return (hour - 9) * 60 + minute\n\n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        total_minutes = minutes\n        hour = 9 + total_minutes // 60\n        minute = total_minutes % 60\n        return f\"{hour:02d}:{minute:02d}\"\n\n    # Work day: 9:00 (0 min) to 17:00 (480 min)\n    day_end = 480\n\n    # Billy's constraint: meeting must end by 15:00 (360 min)\n    constraint_end = 360\n\n    # Busy intervals in minutes (each as [start, end), exclusive end)\n    raymond_busy = [\n        [time_to_minutes('9:00'), time_to_minutes('9:30')],\n        [time_to_minutes('11:30'), time_to_minutes('12:00')],\n        [time_to_minutes('13:00'), time_to_minutes('13:30')],\n        [time_to_minutes('15:00'), time_to_minutes('15:30')]\n    ]\n    billy_busy = [\n        [time_to_minutes('10:00'), time_to_minutes('10:30')],\n        [time_to_minutes('12:00'), time_to_minutes('13:00')],\n        [time_to_minutes('16:30'), time_to_minutes('17:00')]\n    ]\n    donald_busy = [\n        [time_to_minutes('9:00'), time_to_minutes('9:30')],\n        [time_to_minutes('10:00'), time_to_minutes('11:00')],\n        [time_to_minutes('12:00'), time_to_minutes('13:00')],\n        [time_to_minutes('14:00'), time_to_minutes('14:30')],\n        [time_to_minutes('16:00'), time_to_minutes('17:00')]\n    ]\n\n    # Compute free intervals for a participant\n    def get_free_intervals(busy_intervals):\n        busy_intervals.sort(key=lambda x: x[0])\n        free = []\n        current_start = 0\n        for interval in busy_intervals:\n            if current_start < interval[0]:\n                free.append([current_start, interval[0]])\n            current_start = interval[1]\n        if current_start < day_end:\n            free.append([current_start, day_end])\n        return free\n\n    # Compute free intervals for each participant\n    free_raymond = get_free_intervals(raymond_busy)\n    free_billy = get_free_intervals(billy_busy)\n    free_donald = get_free_intervals(donald_busy)\n\n    # Find common free intervals between two sets\n    def intersect_intervals(intervals1, intervals2):\n        i, j = 0, 0\n        result = []\n        while i < len(intervals1) and j < len(intervals2):\n            low = max(intervals1[i][0], intervals2[j][0])\n            high = min(intervals1[i][1], intervals2[j][1])\n            if low < high:\n                result.append([low, high])\n            if intervals1[i][1] < intervals2[j][1]:\n                i += 1\n            else:\n                j += 1\n        return result\n\n    # Common free for all three\n    common_raymond_billy = intersect_intervals(free_raymond, free_billy)\n    common_all = intersect_intervals(common_raymond_billy, free_donald)\n\n    # Find the earliest 30-minute slot that ends by constraint_end (360 min)\n    meeting_duration = 30\n    slot_found = None\n    for interval in common_all:\n        start, end = interval\n        # The latest start time to meet the constraint\n        max_start = constraint_end - meeting_duration\n        if max_start < start:\n            continue\n        # The available start range in this interval\n        slot_start = start\n        slot_end = slot_start + meeting_duration\n        if slot_end <= end and slot_end <= constraint_end:\n            slot_found = (slot_start, slot_end)\n            break\n\n    if slot_found:\n        start_min, end_min = slot_found\n        start_time = minutes_to_time(start_min)\n        end_time = minutes_to_time(end_min)\n        # Format as HH:MM:HH:MM\n        time_range_str = f\"{start_time.replace(':', '')[:2]}:{start_time[-2:]}:{end_time.replace(':', '')[:2]}:{end_time[-2:]}\"\n        print(time_range_str)\n        print(\"Monday\")\n\nif __name__ == \"__main__\":\n    main()\n```"
    }
]