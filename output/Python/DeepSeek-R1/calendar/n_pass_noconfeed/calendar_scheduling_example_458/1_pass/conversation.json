[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Wayne, Melissa, Catherine, Gregory, Victoria, Thomas and Jennifer for half an hour between the work hours of 9:00 to 17:00 on Monday. \n\nHere are the existing schedules for everyone during the day: \nWayne is free the entire day.\nMelissa has meetings on Monday during 10:00 to 11:00, 12:30 to 14:00, 15:00 to 15:30; \nCatherine is free the entire day.\nGregory has blocked their calendar on Monday during 12:30 to 13:00, 15:30 to 16:00; \nVictoria is busy on Monday during 9:00 to 9:30, 10:30 to 11:30, 13:00 to 14:00, 14:30 to 15:00, 15:30 to 16:30; \nThomas has meetings on Monday during 10:00 to 12:00, 12:30 to 13:00, 14:30 to 16:00; \nJennifer has blocked their calendar on Monday during 9:00 to 9:30, 10:00 to 10:30, 11:00 to 13:00, 13:30 to 14:30, 15:00 to 15:30, 16:00 to 16:30; \n\nWayne would like to avoid more meetings on Monday before 14:00. Find a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\ndef time_to_minutes(time_str):\n    h, m = time_str.split(':')\n    return int(h) * 60 + int(m)\n\ndef minutes_to_time(m):\n    h = m // 60\n    mm = m % 60\n    return f\"{h:02d}:{mm:02d}\"\n\ndef main():\n    # Work hours and constraints\n    work_start = time_to_minutes(\"9:00\")\n    work_end = time_to_minutes(\"17:00\")\n    constraint_start = time_to_minutes(\"14:00\")  # Wayne's constraint\n\n    # Participants' busy schedules (each meeting as (start, end) in time strings)\n    wayne_busy = []\n    melissa_busy = [(\"10:00\", \"11:00\"), (\"12:30\", \"14:00\"), (\"15:00\", \"15:30\")]\n    catherine_busy = []\n    gregory_busy = [(\"12:30\", \"13:00\"), (\"15:30\", \"16:00\")]\n    victoria_busy = [(\"9:00\", \"9:30\"), (\"10:30\", \"11:30\"), (\"13:00\", \"14:00\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:30\")]\n    thomas_busy = [(\"10:00\", \"12:00\"), (\"12:30\", \"13:00\"), (\"14:30\", \"16:00\")]\n    jennifer_busy = [(\"9:00\", \"9:30\"), (\"10:00\", \"10:30\"), (\"11:00\", \"13:00\"), (\"13:30\", \"14:30\"), (\"15:00\", \"15:30\"), (\"16:00\", \"16:30\")]\n\n    # Combine all busy intervals\n    all_busy = []\n    schedules = [wayne_busy, melissa_busy, catherine_busy, gregory_busy, victoria_busy, thomas_busy, jennifer_busy]\n    \n    for schedule in schedules:\n        for (s_str, e_str) in schedule:\n            s_min = time_to_minutes(s_str)\n            e_min = time_to_minutes(e_str)\n            # Clip to constraint_start and work_end\n            if e_min <= constraint_start or s_min >= work_end:\n                continue\n            s_clip = max(s_min, constraint_start)\n            e_clip = min(e_min, work_end)\n            if e_clip > s_clip:\n                all_busy.append((s_clip, e_clip))\n    \n    # If no busy intervals, entire constraint period is free\n    if not all_busy:\n        # Check if the constraint period is long enough\n        if work_end - constraint_start >= 30:\n            start_time = constraint_start\n            end_time = start_time + 30\n            print(\"Monday\")\n            print(f\"{minutes_to_time(start_time)}:{minutes_to_time(end_time)}\")\n            return\n        else:\n            # Should not happen per problem statement\n            print(\"Monday\\nNo suitable time found\")\n            return\n    \n    # Sort and merge busy intervals\n    all_busy.sort(key=lambda x: x[0])\n    merged_busy = []\n    current_start, current_end = all_busy[0]\n    for i in range(1, len(all_busy)):\n        s, e = all_busy[i]\n        if s <= current_end:\n            if e > current_end:\n                current_end = e\n        else:\n            merged_busy.append((current_start, current_end))\n            current_start, current_end = s, e\n    merged_busy.append((current_start, current_end))\n    \n    # Find free intervals in [constraint_start, work_end]\n    free_intervals = []\n    # Before first busy interval\n    if constraint_start < merged_busy[0][0]:\n        free_intervals.append((constraint_start, merged_busy[0][0]))\n    # Between busy intervals\n    for i in range(len(merged_busy) - 1):\n        free_start = merged_busy[i][1]\n        free_end = merged_busy[i+1][0]\n        if free_end > free_start:\n            free_intervals.append((free_start, free_end))\n    # After last busy interval\n    if merged_busy[-1][1] < work_end:\n        free_intervals.append((merged_busy[-1][1], work_end))\n    \n    # Find the first free interval of at least 30 minutes\n    for s, e in free_intervals:\n        if e - s >= 30:\n            start_meeting = s\n            end_meeting = s + 30\n            print(\"Monday\")\n            print(f\"{minutes_to_time(start_meeting)}:{minutes_to_time(end_meeting)}\")\n            return\n    \n    # Should not happen per problem statement\n    print(\"Monday\\nNo suitable time found\")\n\nif __name__ == \"__main__\":\n    main()\n```"
    }
]