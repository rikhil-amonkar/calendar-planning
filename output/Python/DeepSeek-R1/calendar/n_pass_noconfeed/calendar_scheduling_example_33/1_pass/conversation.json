[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Lisa, Bobby and Randy for half an hour between the work hours of 9:00 to 17:00 on Monday. \n\nHere are the existing schedules for everyone during the day: \nLisa has meetings on Monday during 9:00 to 10:00, 10:30 to 11:30, 12:30 to 13:00, 16:00 to 16:30; \nBobby is busy on Monday during 9:00 to 9:30, 10:00 to 10:30, 11:30 to 12:00, 15:00 to 15:30; \nRandy has meetings on Monday during 9:30 to 10:00, 10:30 to 11:00, 11:30 to 12:30, 13:00 to 13:30, 14:30 to 15:30, 16:00 to 16:30; \n\nBobby would like to avoid more meetings on Monday after 15:00. Find a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\ndef main():\n    # Convert time string to minutes\n    def time_to_minutes(time_str):\n        hours, minutes = map(int, time_str.split(':'))\n        return hours * 60 + minutes\n\n    # Convert minutes back to HH:MM format\n    def minutes_to_time(total_minutes):\n        hours = total_minutes // 60\n        minutes = total_minutes % 60\n        return f\"{hours:02d}:{minutes:02d}\"\n\n    # Function to compute free intervals given busy intervals and work hours\n    def free_intervals(busy_list, work_start, work_end):\n        if not busy_list:\n            return [(work_start, work_end)]\n        sorted_busy = sorted(busy_list, key=lambda x: x[0])\n        free = []\n        current = work_start\n        for start, end in sorted_busy:\n            if current < start:\n                free.append((current, start))\n            current = end\n        if current < work_end:\n            free.append((current, work_end))\n        return free\n\n    # Function to intersect two sets of intervals\n    def intersect_two(intervals1, intervals2):\n        if not intervals1 or not intervals2:\n            return []\n        res = []\n        i = j = 0\n        while i < len(intervals1) and j < len(intervals2):\n            low = max(intervals1[i][0], intervals2[j][0])\n            high = min(intervals1[i][1], intervals2[j][1])\n            if low < high:\n                res.append((low, high))\n            if intervals1[i][1] < intervals2[j][1]:\n                i += 1\n            else:\n                j += 1\n        return res\n\n    # Work hours and meeting duration\n    work_start_min = time_to_minutes(\"09:00\")\n    work_end_min = time_to_minutes(\"17:00\")\n    duration = 30\n    avoid_after_min = time_to_minutes(\"15:00\")  # Bobby's preference\n\n    # Busy intervals in minutes for each participant\n    lisa_busy = [\n        (\"09:00\", \"10:00\"),\n        (\"10:30\", \"11:30\"),\n        (\"12:30\", \"13:00\"),\n        (\"16:00\", \"16:30\")\n    ]\n    bobby_busy = [\n        (\"09:00\", \"09:30\"),\n        (\"10:00\", \"10:30\"),\n        (\"11:30\", \"12:00\"),\n        (\"15:00\", \"15:30\")\n    ]\n    randy_busy = [\n        (\"09:30\", \"10:00\"),\n        (\"10:30\", \"11:00\"),\n        (\"11:30\", \"12:30\"),\n        (\"13:00\", \"13:30\"),\n        (\"14:30\", \"15:30\"),\n        (\"16:00\", \"16:30\")\n    ]\n\n    # Convert busy times to minutes\n    def convert_busy(busy_times):\n        return [(time_to_minutes(s), time_to_minutes(e)) for s, e in busy_times]\n\n    lisa_busy_min = convert_busy(lisa_busy)\n    bobby_busy_min = convert_busy(bobby_busy)\n    randy_busy_min = convert_busy(randy_busy)\n\n    # Compute free intervals for each\n    lisa_free = free_intervals(lisa_busy_min, work_start_min, work_end_min)\n    bobby_free = free_intervals(bobby_busy_min, work_start_min, work_end_min)\n    randy_free = free_intervals(randy_busy_min, work_start_min, work_end_min)\n\n    # Find common free intervals\n    common_free = intersect_two(lisa_free, bobby_free)\n    common_free = intersect_two(common_free, randy_free)\n\n    # Find the earliest 30-minute slot that ends by 15:00\n    meeting_slot = None\n    for start, end in common_free:\n        if end - start >= duration:\n            meeting_end = start + duration\n            # Check if the meeting ends by 15:00 (Bobby's preference)\n            if meeting_end <= avoid_after_min:\n                meeting_slot = (start, meeting_end)\n                break\n\n    # If no preferred slot found, find any 30-minute slot\n    if meeting_slot is None:\n        for start, end in common_free:\n            if end - start >= duration:\n                meeting_slot = (start, start + duration)\n                break\n\n    # Format the result\n    day = \"Monday\"\n    start_time = minutes_to_time(meeting_slot[0])\n    end_time = minutes_to_time(meeting_slot[1])\n    time_range = f\"{start_time}:{end_time}\"\n\n    print(day)\n    print(time_range)\n\nif __name__ == \"__main__\":\n    main()\n```"
    }
]