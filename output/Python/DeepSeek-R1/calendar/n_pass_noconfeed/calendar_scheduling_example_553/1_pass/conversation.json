[
    {
        "role": "user",
        "content": "You are an expert at scheduling meetings. Your task is to find a suitable time for a meeting based on the participants' schedules and constraints. In this case:\nYou are an expert at scheduling meetings. You are given a few constraints on the existing schedule of each participant, the meeting duration, and possibly some preferences on the meeting time. Note there exists a solution that works with existing schedule of every participant. Here are a few example tasks and solutions:\n\nTASK: You need to schedule a meeting for Eric and Henry for half an hour between the work hours of 9:00 to 17:00 on Monday. \n\nHere are the existing schedules for everyone during the day: \nEric has blocked their calendar on Monday during 12:00 to 13:00, 14:00 to 15:00; \nHenry has meetings on Monday during 9:30 to 10:00, 10:30 to 11:00, 11:30 to 12:30, 13:00 to 13:30, 14:30 to 15:00, 16:00 to 17:00; \n\nHenry would rather not meet on Monday after 10:00. Find a time that works for everyone's schedule and constraints. \nSOLUTION: \nGenerate a fully working Python script with code that calculates a proposed time and outputs it in the format HH:MM:HH:MM. The script should also output the day of the week (e.g., Monday, Tuesday). The script should be clean, well-formatted, and enclosed within ```python and ```. The output of the generated code must include both the time range (like {14:30:15:30}) and the day of the week. Provide the response with only code."
    },
    {
        "role": "assistant",
        "content": "```python\ndef main():\n    work_start = 0  # 9:00 in minutes from 9:00\n    work_end = 480   # 17:00\n    eric_busy = [(180, 240), (300, 360)]\n    henry_busy = [(30, 60), (90, 120), (150, 210), (240, 270), (330, 360), (420, 480)]\n\n    def get_free_intervals(busy_intervals, start_time, end_time):\n        if not busy_intervals:\n            return [(start_time, end_time)]\n        sorted_busy = sorted(busy_intervals, key=lambda x: x[0])\n        free = []\n        current = start_time\n        for s, e in sorted_busy:\n            if current < s:\n                free.append((current, s))\n            current = e\n        if current < end_time:\n            free.append((current, end_time))\n        return free\n\n    free_eric = get_free_intervals(eric_busy, work_start, work_end)\n    free_henry = get_free_intervals(henry_busy, work_start, work_end)\n\n    candidate_slots = []\n    for e_int in free_eric:\n        for h_int in free_henry:\n            start_over = max(e_int[0], h_int[0])\n            end_over = min(e_int[1], h_int[1])\n            if start_over < end_over and (end_over - start_over) >= 30:\n                candidate_slots.append((start_over, end_over))\n\n    candidate_meetings = []\n    for s, e in candidate_slots:\n        meeting_end = s + 30\n        candidate_meetings.append((s, meeting_end))\n\n    preferred_meetings = [meeting for meeting in candidate_meetings if meeting[1] <= 60]\n\n    if preferred_meetings:\n        chosen_meeting = min(preferred_meetings, key=lambda x: x[0])\n    else:\n        chosen_meeting = min(candidate_meetings, key=lambda x: x[0])\n\n    def format_time(minutes):\n        total_minutes = minutes\n        hours = 9 + total_minutes // 60\n        minutes_part = total_minutes % 60\n        return f\"{hours:02d}:{minutes_part:02d}\"\n\n    start_str = format_time(chosen_meeting[0])\n    end_str = format_time(chosen_meeting[1])\n    time_range_str = f\"{start_str}:{end_str}\"\n\n    print(\"Monday\")\n    print(time_range_str)\n\nif __name__ == \"__main__\":\n    main()\n```"
    }
]