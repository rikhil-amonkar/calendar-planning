{
    "0shot": [
        {
            "final_program_time": {
                "day": "Wednesday",
                "start_time": "{12:00",
                "end_time": "13:00}"
            },
            "expected_time": {
                "day": "Wednesday",
                "start_time": "{12:00",
                "end_time": "13:00}"
            },
            "has_error": false,
            "raw_model_response": "'''python\ndef time_to_min(t):\n    hours, minutes = map(int, t.split(':'))\n    return hours * 60 + minutes\n\ndef min_to_time(m):\n    return f\"{m // 60:02d}:{m % 60:02d}\"\n\ndef get_free_slots(busy_intervals, work_start, work_end, filter_start=None):\n    busy = sorted(busy_intervals, key=lambda x: x[0])\n    free = []\n    prev_end = work_start\n    for start, end in busy:\n        if start > prev_end:\n            free.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free.append((prev_end, work_end))\n    if filter_start is not None:\n        free = [(max(s, filter_start), e) for s, e in free if max(s, filter_start) < e]\n    return free\n\nwork_hours = (9 * 60, 17 * 60)\ndays_order = ['Wednesday', 'Tuesday', 'Monday']  # Priority based on Judith's preferences\n\njudith_busy = {\n    'Monday': [(time_to_min('12:00'), time_to_min('12:30'))],\n    'Wednesday': [(time_to_min('11:30'), time_to_min('12:00'))],\n    'Tuesday': []\n}\n\ntimothy_busy = {\n    'Monday': [(time_to_min('09:30'), time_to_min('10:00')),\n               (time_to_min('10:30'), time_to_min('11:30')),\n               (time_to_min('12:30'), time_to_min('14:00')),\n               (time_to_min('15:30'), time_to_min('17:00'))],\n    'Tuesday': [(time_to_min('09:30'), time_to_min('13:00')),\n                (time_to_min('13:30'), time_to_min('14:00')),\n                (time_to_min('14:30'), time_to_min('17:00'))],\n    'Wednesday': [(time_to_min('09:00'), time_to_min('09:30')),\n                  (time_to_min('10:30'), time_to_min('11:00')),\n                  (time_to_min('13:30'), time_to_min('14:30')),\n                  (time_to_min('15:00'), time_to_min('15:30')),\n                  (time_to_min('16:00'), time_to_min('16:30'))]\n}\n\nfor day in days_order:\n    j_filter = None\n    if day == 'Wednesday':\n        j_filter = time_to_min('12:00')  # Avoid Wednesday before 12:00\n    elif day == 'Monday':\n        continue  # Check Monday last\n    \n    # Get free slots for Judith\n    j_busy = judith_busy.get(day, [])\n    j_free = get_free_slots(j_busy, work_hours[0], work_hours[1], j_filter)\n    \n    # Get free slots for Timothy\n    t_busy = timothy_busy.get(day, [])\n    t_free = get_free_slots(t_busy, work_hours[0], work_hours[1], j_filter)\n    \n    # Find overlapping slots\n    overlap = []\n    j_idx = t_idx = 0\n    while j_idx < len(j_free) and t_idx < len(t_free):\n        j_start, j_end = j_free[j_idx]\n        t_start, t_end = t_free[t_idx]\n        \n        start = max(j_start, t_start)\n        end = min(j_end, t_end)\n        if start < end:\n            overlap.append((start, end))\n            if j_end < t_end:\n                j_idx += 1\n            else:\n                t_idx += 1\n        else:\n            if j_end < t_end:\n                j_idx += 1\n            else:\n                t_idx += 1\n    \n    # Check for 60-minute slot\n    for start, end in overlap:\n        if end - start >= 60:\n            print(f\"{day}:{min_to_time(start)}:{min_to_time(start + 60)}\")\n            exit()\n\n# Check Monday if no other days found\nj_filter = None\nj_free = get_free_slots(judith_busy['Monday'], work_hours[0], work_hours[1], j_filter)\nt_free = get_free_slots(timothy_busy['Monday'], work_hours[0], work_hours[1], j_filter)\n\noverlap = []\nj_idx = t_idx = 0\nwhile j_idx < len(j_free) and t_idx < len(t_free):\n    j_start, j_end = j_free[j_idx]\n    t_start, t_end = t_free[t_idx]\n    \n    start = max(j_start, t_start)\n    end = min(j_end, t_end)\n    if start < end:\n        overlap.append((start, end))\n        if j_end < t_end:\n            j_idx += 1\n        else:\n            t_idx += 1\n    else:\n        if j_end < t_end:\n            j_idx += 1\n        else:\n            t_idx += 1\n\nfor start, end in overlap:\n    if end - start >= 60:\n        print(f\"Monday:{min_to_time(start)}:{min_to_time(start + 60)}\")\n        exit()\n'''",
            "count": "calendar_scheduling_example_784"
        }
    ]
}