{
    "0shot": [
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "13:30",
                "end_time": "14:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "13:30",
                "end_time": "14:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes, day):\n    \"\"\"\n    Finds a meeting time that fits all participants' schedules.\n    \n    Args:\n        participants_schedules: List of lists of busy time ranges for each participant.\n        work_hours_start: Start of work hours in minutes from midnight (e.g., 9:00 AM is 540).\n        work_hours_end: End of work hours in minutes from midnight (e.g., 5:00 PM is 1020).\n        duration_minutes: Duration of the meeting in minutes.\n        day: Day of the week (e.g., \"Monday\").\n    \n    Returns:\n        A tuple of (start_time_str, end_time_str, day) if a slot is found, else None.\n    \"\"\"\n    # Convert all busy times to minutes and merge overlapping or adjacent ranges\n    def parse_time(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def to_time_str(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Collect all busy time ranges from all participants\n    all_busy = []\n    for schedule in participants_schedules:\n        for busy_range in schedule:\n            start, end = map(parse_time, busy_range.split(' to '))\n            all_busy.append((start, end))\n    \n    # Sort all busy ranges by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy ranges\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Check the available slots between work hours and busy times\n    available_slots = []\n    prev_end = work_hours_start\n    \n    for start, end in merged_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_hours_end:\n        available_slots.append((prev_end, work_hours_end))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            return (to_time_str(meeting_start), to_time_str(meeting_end), day)\n    \n    return None\n\n# Define the participants' schedules\njames_schedule = [\n    \"11:30 to 12:00\",\n    \"14:30 to 15:00\"\n]\n\njohn_schedule = [\n    \"09:30 to 11:00\",\n    \"11:30 to 12:00\",\n    \"12:30 to 13:30\",\n    \"14:30 to 16:30\"\n]\n\n# Combine all participants' schedules\nparticipants_schedules = [james_schedule, john_schedule]\n\n# Define work hours and meeting duration\nwork_hours_start = 9 * 60  # 9:00 AM\nwork_hours_end = 17 * 60    # 5:00 PM\nduration_minutes = 60\nday = \"Monday\"\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes, day)\n\nif meeting_time:\n    start_time, end_time, day = meeting_time\n    print(f\"{start_time}:{end_time}:{day}\")\nelse:\n    print(\"No suitable meeting time found.\")\n```",
            "count": "calendar_scheduling_example_543"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "10:00",
                "end_time": "10:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "10:00",
                "end_time": "10:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Participants' constraints\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30       # minutes\n    \n    # Albert's busy times in minutes since 9:00\n    albert_busy = [\n        (9 * 60, 10 * 60),      # 9:00-10:00\n        (10 * 60 + 30, 12 * 60), # 10:30-12:00\n        (15 * 60, 16 * 60 + 30)  # 15:00-16:30\n    ]\n    \n    # Albert cannot meet after 11:00\n    albert_cutoff = 11 * 60\n    \n    # Deborah is free all day, so only Albert's schedule matters\n    \n    # Find all possible slots\n    possible_slots = []\n    \n    # Check before Albert's first busy block\n    if work_hours_start + meeting_duration <= albert_busy[0][0]:\n        possible_slots.append((work_hours_start, work_hours_start + meeting_duration))\n    \n    # Check between Albert's busy blocks\n    for i in range(len(albert_busy) - 1):\n        end_previous = albert_busy[i][1]\n        start_next = albert_busy[i + 1][0]\n        if end_previous + meeting_duration <= start_next:\n            possible_slots.append((end_previous, end_previous + meeting_duration))\n    \n    # Check after Albert's last busy block but before his cutoff\n    end_last_busy = albert_busy[-1][1]\n    if end_last_busy + meeting_duration <= albert_cutoff:\n        possible_slots.append((end_last_busy, end_last_busy + meeting_duration))\n    \n    # Also check if there's time before cutoff but not covered by busy blocks\n    # For example, between 12:00 and 15:00, but Albert cannot meet after 11:00\n    # So this is not applicable here\n    \n    # Select the earliest possible slot\n    if possible_slots:\n        chosen_slot = possible_slots[0]\n        start_time = chosen_slot[0]\n        end_time = chosen_slot[1]\n        \n        # Convert minutes back to HH:MM format\n        start_hh = start_time // 60\n        start_mm = start_time % 60\n        end_hh = end_time // 60\n        end_mm = end_time % 60\n        \n        # Format as HH:MM:HH:MM\n        time_range = f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n        day = \"Monday\"\n        \n        print(f\"{time_range}\")\n        print(f\"{day}\")\n    else:\n        print(\"No suitable time found.\")\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_544"
        },
        {
            "final_program_time": {
                "day": null,
                "start_time": null,
                "end_time": null
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "13:00",
                "end_time": "13:30"
            },
            "has_error": true,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, day, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time slots to minutes since start of the day for easier calculation\n    start_min = work_hours_start * 60\n    end_min = work_hours_end * 60\n    duration = duration_minutes\n    \n    # Initialize the free slots for the entire work day\n    free_slots = [(start_min, end_min)]\n    \n    # Process each participant's schedule to find common free slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for slot in schedule:\n            start = slot[0] * 60\n            end = slot[1] * 60\n            busy_slots.append((start, end))\n        \n        # Sort the busy slots by start time\n        busy_slots.sort()\n        \n        # Subtract busy slots from current free slots\n        new_free_slots = []\n        for free_start, free_end in free_slots:\n            current_start = free_start\n            for busy_start, busy_end in busy_slots:\n                if busy_start >= free_end:\n                    break\n                if busy_end <= current_start:\n                    continue\n                if busy_start > current_start:\n                    new_free_slots.append((current_start, busy_start))\n                current_start = max(current_start, busy_end)\n            if current_start < free_end:\n                new_free_slots.append((current_start, free_end))\n        free_slots = new_free_slots\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot in free_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return (f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\", day)\n    \n    return None\n\n# Define the participants' schedules in 24-hour format (HH.HH)\nparticipants_schedules = [\n    [(9.00, 11.00), (13.50, 14.00), (16.00, 16.50)],  # Doris (13:30 is 13.50 in decimal)\n    [(10.00, 12.00)],  # Theresa\n    [],  # Christian\n    [(9.50, 10.00), (11.50, 12.00), (12.50, 13.00), (13.50, 14.00), (14.50, 15.00), (15.50, 17.00)],  # Terry\n    [(9.00, 10.50), (11.00, 11.50), (12.00, 13.00), (13.50, 14.50), (15.00, 17.00)],  # Carolyn\n    [(9.00, 9.50), (11.50, 12.00), (12.50, 13.00), (14.50, 17.00)],  # Kyle\n]\n\n# Convert schedules to consistent format (HH.HH)\n# Note: 30 minutes is 0.50 in decimal\nadjusted_schedules = []\nfor schedule in participants_schedules:\n    adjusted = []\n    for start, end in schedule:\n        # Convert HH:MM to HH.HH (e.g., 13:30 -> 13.50)\n        start_hh = int(start)\n        start_mm = round((start - start_hh) * 100)\n        start_decimal = start_hh + start_mm / 60\n        \n        end_hh = int(end)\n        end_mm = round((end - end_hh) * 100)\n        end_decimal = end_hh + end_mm / 60\n        \n        adjusted.append((start_decimal, end_decimal))\n    adjusted_schedules.append(adjusted)\n\n# Find the meeting time\nmeeting_time = find_meeting_time(\n    adjusted_schedules,\n    day=\"Monday\",\n    work_hours_start=9,\n    work_hours_end=17,\n    duration_minutes=30\n)\n\n# Output the result\nprint(f\"{{{meeting_time[0]}}} {meeting_time[1]}\")\n```",
            "count": "calendar_scheduling_example_398"
        },
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "15:30",
                "end_time": "16:00"
            },
            "expected_time": {
                "day": "Tuesday",
                "start_time": "15:30",
                "end_time": "16:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours and days\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday']\n    \n    # Harold's blocked times in minutes since midnight for each day\n    harold_blocked = {\n        'Monday': [\n            (9 * 60, 10 * 60),      # 9:00-10:00\n            (10 * 60 + 30, 17 * 60) # 10:30-17:00\n        ],\n        'Tuesday': [\n            (9 * 60, 9 * 60 + 30),      # 9:00-9:30\n            (10 * 60 + 30, 11 * 60 + 30), # 10:30-11:30\n            (12 * 60 + 30, 13 * 60 + 30), # 12:30-13:30\n            (14 * 60 + 30, 15 * 60 + 30), # 14:30-15:30\n            (16 * 60, 17 * 60)            # 16:00-17:00\n        ]\n    }\n    \n    # Harold's preferences: avoid Monday and Tuesday before 14:30\n    preferred_day = 'Tuesday'\n    preferred_time = 14 * 60 + 30  # 14:30\n    \n    meeting_duration = 30  # minutes\n    \n    # Check preferred day and time first (Tuesday after 14:30)\n    if preferred_day == 'Tuesday':\n        # Find gaps on Tuesday after 14:30\n        blocked_times = harold_blocked['Tuesday']\n        # Add work hours as boundaries\n        blocked_times_sorted = sorted(blocked_times + [(work_start, work_start), (work_end, work_end)])\n        \n        # Iterate through blocked times to find a gap\n        for i in range(len(blocked_times_sorted) - 1):\n            current_end = blocked_times_sorted[i][1]\n            next_start = blocked_times_sorted[i + 1][0]\n            if current_end >= preferred_time and next_start - current_end >= meeting_duration:\n                start_time = current_end\n                end_time = start_time + meeting_duration\n                return 'Tuesday', f\"{format_time(start_time)}:{format_time(end_time)}\"\n    \n    # If preferred time not available, check other times\n    for day in days:\n        if day == 'Monday' and preferred_day == 'Tuesday':\n            continue  # skip Monday if Harold prefers Tuesday\n        \n        blocked_times = harold_blocked[day]\n        blocked_times_sorted = sorted(blocked_times + [(work_start, work_start), (work_end, work_end)])\n        \n        for i in range(len(blocked_times_sorted) - 1):\n            current_end = blocked_times_sorted[i][1]\n            next_start = blocked_times_sorted[i + 1][0]\n            if next_start - current_end >= meeting_duration:\n                start_time = current_end\n                end_time = start_time + meeting_duration\n                # Check Harold's preference for Tuesday before 14:30\n                if day == 'Tuesday' and end_time <= preferred_time:\n                    continue  # skip if before 14:30 on Tuesday\n                return day, f\"{format_time(start_time)}:{format_time(end_time)}\"\n    \n    return None, \"00:00:00:00\"  # fallback (shouldn't reach here per problem statement)\n\ndef format_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\nday, time_range = find_meeting_time()\nprint(f\"{day}, {time_range}\")\n```",
            "count": "calendar_scheduling_example_625"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "9:00",
                "end_time": "9:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "12:00",
                "end_time": "12:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define busy intervals in minutes since midnight\n    jack_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (14 * 60, 14 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    charlotte_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 12 * 60),\n        (12 * 60 + 30, 13 * 60 + 30),\n        (14 * 60, 16 * 60)\n    ]\n\n    # Jack prefers no meetings after 12:30\n    jack_preference_cutoff = 12 * 60 + 30\n\n    # Combine and sort all busy intervals\n    all_busy = jack_busy + charlotte_busy\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy intervals\n    free_slots = []\n    previous_end = work_start\n\n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy interval\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Filter slots that are at least 30 minutes and before Jack's preference cutoff\n    suitable_slots = []\n    for start, end in free_slots:\n        if end <= jack_preference_cutoff and (end - start) >= 30:\n            suitable_slots.append((start, end))\n    \n    # If no suitable slots before cutoff, check all free slots\n    if not suitable_slots:\n        for start, end in free_slots:\n            if (end - start) >= 30:\n                suitable_slots.append((start, end))\n    \n    # Select the first suitable slot\n    if suitable_slots:\n        meeting_start = suitable_slots[0][0]\n        meeting_end = meeting_start + 30\n    else:\n        return \"No suitable time found.\"\n\n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n\n    start_time = minutes_to_time(meeting_start)\n    end_time = minutes_to_time(meeting_end)\n\n    return f\"{start_time}:{end_time}\", \"Monday\"\n\n# Execute and print the result\ntime_range, day = find_meeting_time()\nprint(f\"{time_range} {day}\")\n```",
            "count": "calendar_scheduling_example_502"
        },
        {
            "final_program_time": {
                "day": null,
                "start_time": null,
                "end_time": null
            },
            "expected_time": {
                "day": "Wednesday",
                "start_time": "9:30",
                "end_time": "10:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(nancy_schedule, jose_schedule, days, work_hours, duration):\n    start_work, end_work = work_hours\n    duration_minutes = duration * 60\n    \n    for day in days:\n        # Initialize free slots for the day\n        nancy_free = get_free_slots(nancy_schedule.get(day, []), start_work, end_work)\n        jose_free = get_free_slots(jose_schedule.get(day, []), start_work, end_work)\n        \n        # Find overlapping free slots\n        overlapping = find_overlapping_slots(nancy_free, jose_free, duration_minutes)\n        \n        if overlapping:\n            # Return the earliest possible slot\n            start, end = overlapping[0]\n            return day, start, end\n    \n    return None\n\ndef get_free_slots(busy_slots, work_start, work_end):\n    # Convert time to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Process busy slots\n    busy_intervals = []\n    for slot in busy_slots:\n        start, end = slot.split(' to ')\n        start_min = time_to_minutes(start)\n        end_min = time_to_minutes(end)\n        busy_intervals.append((start_min, end_min))\n    \n    # Sort busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find free intervals\n    free_intervals = []\n    prev_end = work_start_min\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        free_intervals.append((prev_end, work_end_min))\n    \n    # Convert back to time strings\n    free_slots = []\n    for start, end in free_intervals:\n        free_slots.append((minutes_to_time(start), minutes_to_time(end)))\n    \n    return free_slots\n\ndef find_overlapping_slots(slots1, slots2, duration):\n    # Convert time to minutes for comparison\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    overlapping = []\n    \n    for s1_start, s1_end in slots1:\n        s1_start_min = time_to_minutes(s1_start)\n        s1_end_min = time_to_minutes(s1_end)\n        \n        for s2_start, s2_end in slots2:\n            s2_start_min = time_to_minutes(s2_start)\n            s2_end_min = time_to_minutes(s2_end)\n            \n            # Find overlap\n            overlap_start = max(s1_start_min, s2_start_min)\n            overlap_end = min(s1_end_min, s2_end_min)\n            \n            if overlap_start < overlap_end and (overlap_end - overlap_start) >= duration:\n                overlapping.append((overlap_start, overlap_end))\n    \n    # Sort overlapping slots by start time\n    overlapping.sort()\n    \n    # Convert back to time strings\n    result = []\n    for start, end in overlapping:\n        start_time = minutes_to_time(start)\n        end_time = minutes_to_time(start + duration)\n        result.append((start_time, end_time))\n    \n    return result\n\ndef minutes_to_time(minutes):\n    hh = minutes // 60\n    mm = minutes % 60\n    return f\"{hh:02d}:{mm:02d}\"\n\n# Define schedules\nnancy_schedule = {\n    'Monday': ['10:00 to 10:30', '11:30 to 12:30', '13:30 to 14:00', '14:30 to 15:30', '16:00 to 17:00'],\n    'Tuesday': ['9:30 to 10:30', '11:00 to 11:30', '12:00 to 12:30', '13:00 to 13:30', '15:30 to 16:00'],\n    'Wednesday': ['10:00 to 11:30', '13:30 to 16:00']\n}\n\njose_schedule = {\n    'Monday': ['9:00 to 17:00'],\n    'Tuesday': ['9:00 to 17:00'],\n    'Wednesday': ['9:00 to 9:30', '10:00 to 12:30', '13:30 to 14:30', '15:00 to 17:00']\n}\n\n# Define parameters\ndays = ['Monday', 'Tuesday', 'Wednesday']\nwork_hours = ('9:00', '17:00')\nduration = 30  # minutes\n\n# Find meeting time\nresult = find_meeting_time(nancy_schedule, jose_schedule, days, work_hours, duration)\n\nif result:\n    day, start, end = result\n    print(f\"{day}: {start}:{end}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_798"
        },
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "9:00",
                "end_time": "9:30"
            },
            "expected_time": {
                "day": "Tuesday",
                "start_time": "9:00",
                "end_time": "9:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    meeting_duration = 30  # minutes\n\n    # Define busy slots for each participant per day in minutes since midnight\n    cheryl_busy = {\n        'Monday': [(9*60, 9*60 + 30), (11*60 + 30, 13*60), (15*60 + 30, 16*60)],\n        'Tuesday': [(15*60, 15*60 + 30)],\n        'Wednesday': []  # Cheryl cannot meet on Wednesday\n    }\n    \n    kyle_busy = {\n        'Monday': [(9*60, 17*60)],\n        'Tuesday': [(9*60 + 30, 17*60)],\n        'Wednesday': [(9*60, 9*60 + 30), (10*60, 13*60), (13*60 + 30, 14*60), (14*60 + 30, 17*60)]\n    }\n\n    # Iterate through each day to find a suitable time\n    for day in days:\n        if day == 'Wednesday':\n            continue  # Cheryl cannot meet on Wednesday\n        \n        # Combine and sort all busy slots for the day\n        all_busy = cheryl_busy[day] + kyle_busy[day]\n        all_busy.sort()\n\n        # Initialize previous end time as work start\n        prev_end = work_start\n\n        # Check gaps between busy slots\n        for busy_start, busy_end in all_busy:\n            if busy_start > prev_end:\n                # Found a gap, check if it's long enough\n                if busy_start - prev_end >= meeting_duration:\n                    # Format the time as HH:MM:HH:MM\n                    start_hh = prev_end // 60\n                    start_mm = prev_end % 60\n                    end_hh = (prev_end + meeting_duration) // 60\n                    end_mm = (prev_end + meeting_duration) % 60\n                    time_str = f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n                    return day, time_str\n            prev_end = max(prev_end, busy_end)\n\n        # Check after the last busy slot\n        if work_end - prev_end >= meeting_duration:\n            start_hh = prev_end // 60\n            start_mm = prev_end % 60\n            end_hh = (prev_end + meeting_duration) // 60\n            end_mm = (prev_end + meeting_duration) % 60\n            time_str = f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n            return day, time_str\n\n    return \"No meeting time found\", \"\"\n\nday, time_str = find_meeting_time()\nprint(f\"{day}: {time_str}\")\n```",
            "count": "calendar_scheduling_example_710"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "13:30",
                "end_time": "14:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "13:30",
                "end_time": "14:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' busy times in minutes since midnight\n    anthony_busy = [\n        (9 * 60 + 30, 10 * 60),      # 9:30-10:00\n        (12 * 60, 13 * 60),           # 12:00-13:00\n        (16 * 60, 16 * 60 + 30)      # 16:00-16:30\n    ]\n    pamela_busy = [\n        (9 * 60 + 30, 10 * 60),       # 9:30-10:00\n        (16 * 60 + 30, 17 * 60)       # 16:30-17:00\n    ]\n    zachary_busy = [\n        (9 * 60, 11 * 60 + 30),       # 9:00-11:30\n        (12 * 60, 12 * 60 + 30),      # 12:00-12:30\n        (13 * 60, 13 * 60 + 30),      # 13:00-13:30\n        (14 * 60 + 30, 15 * 60),      # 14:30-15:00\n        (16 * 60, 17 * 60)            # 16:00-17:00\n    ]\n\n    # Pamela's preference: not after 14:30\n    pamela_preference_end = 14 * 60 + 30\n\n    # Meeting duration in minutes\n    meeting_duration = 60\n\n    # Generate all possible slots\n    possible_slots = []\n    current_time = work_start\n\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        # Check if the slot is valid for all participants\n        anthony_free = all(not (start <= current_time < end or start < slot_end <= end) for start, end in anthony_busy)\n        pamela_free = all(not (start <= current_time < end or start < slot_end <= end) for start, end in pamela_busy)\n        zachary_free = all(not (start <= current_time < end or start < slot_end <= end) for start, end in zachary_busy)\n        # Check Pamela's preference\n        pamela_preference_ok = slot_end <= pamela_preference_end\n\n        if anthony_free and pamela_free and zachary_free and pamela_preference_ok:\n            possible_slots.append((current_time, slot_end))\n        \n        current_time += 15  # Check every 15 minutes for efficiency\n\n    if not possible_slots:\n        return None\n\n    # Select the first available slot\n    chosen_slot = possible_slots[0]\n    start_hour = chosen_slot[0] // 60\n    start_min = chosen_slot[0] % 60\n    end_hour = chosen_slot[1] // 60\n    end_min = chosen_slot[1] % 60\n\n    # Format the output\n    time_str = f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n    return time_str, \"Monday\"\n\n# Execute and print the result\ntime_range, day = find_meeting_time()\nprint(f\"{time_range} {day}\")\n```",
            "count": "calendar_scheduling_example_25"
        },
        {
            "final_program_time": {
                "day": null,
                "start_time": null,
                "end_time": null
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "12:00",
                "end_time": "12:30"
            },
            "has_error": true,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, meeting_duration, work_hours_start, work_hours_end):\n    # Convert all time slots to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n\n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n\n    # Process each participant's schedule to find common free times\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_slots.append((start, end))\n        \n        # Sort the busy slots by start time\n        busy_slots.sort()\n\n        # Merge overlapping or adjacent busy slots\n        merged_busy = []\n        for start, end in busy_slots:\n            if not merged_busy:\n                merged_busy.append((start, end))\n            else:\n                last_start, last_end = merged_busy[-1]\n                if start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = last_start\n                    new_end = max(last_end, end)\n                    merged_busy[-1] = (new_start, new_end)\n                else:\n                    merged_busy.append((start, end))\n        \n        # Calculate free slots for this participant by subtracting busy slots from work hours\n        participant_free = []\n        prev_end = work_start\n        for start, end in merged_busy:\n            if start > prev_end:\n                participant_free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            participant_free.append((prev_end, work_end))\n        \n        # Intersect participant's free slots with current common free slots\n        new_free_slots = []\n        i = j = 0\n        while i < len(free_slots) and j < len(participant_free):\n            slot_start, slot_end = free_slots[i]\n            part_start, part_end = participant_free[j]\n\n            # Find the overlapping interval\n            overlap_start = max(slot_start, part_start)\n            overlap_end = min(slot_end, part_end)\n\n            if overlap_start < overlap_end:\n                new_free_slots.append((overlap_start, overlap_end))\n            \n            # Move the pointer which ends first\n            if slot_end < part_end:\n                i += 1\n            else:\n                j += 1\n        \n        free_slots = new_free_slots\n        if not free_slots:\n            return None  # No common free time\n    \n    # Find the first free slot that can accommodate the meeting duration\n    meeting_duration_min = time_to_minutes(meeting_duration) - time_to_minutes(\"0:00\")\n    for start, end in free_slots:\n        if end - start >= meeting_duration_min:\n            meeting_end = start + meeting_duration_min\n            return (minutes_to_time(start), minutes_to_time(meeting_end))\n    \n    return None\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [],  # Tyler is free all day\n    [],  # Kelly is free all day\n    [\"11:00:11:30\", \"14:30:15:00\"],  # Stephanie\n    [],  # Hannah is free all day\n    [\"9:00:9:30\", \"10:00:12:00\", \"12:30:13:00\", \"14:00:17:00\"],  # Joe\n    [\"9:00:10:30\", \"11:30:12:00\", \"13:00:14:00\", \"14:30:15:30\", \"16:00:17:00\"],  # Diana\n    [\"9:00:10:00\", \"10:30:12:00\", \"12:30:13:00\", \"13:30:14:00\", \"14:30:15:30\", \"16:00:16:30\"],  # Deborah\n]\n\nmeeting_duration = \"0:30\"\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, meeting_duration, work_hours_start, work_hours_end)\n\nif meeting_time:\n    start_time, end_time = meeting_time\n    print(f\"{start_time}:{end_time}:Monday\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_493"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "16:30",
                "end_time": "17:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "16:30",
                "end_time": "17:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours and meeting duration\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Nicole's schedule and preferences\n    nicole_busy = [\n        (9 * 60, 10 * 60),    # 9:00-10:00\n        (10 * 60 + 30, 16 * 60 + 30)  # 10:30-16:30\n    ]\n    nicole_preferred_start = 16 * 60  # 16:00\n\n    # Judy is free all day, so only Nicole's schedule matters\n    potential_slots = []\n\n    # Check time after Nicole's last meeting and before work ends\n    last_busy_end = nicole_busy[-1][1]\n    if last_busy_end + meeting_duration <= work_end:\n        potential_slots.append((last_busy_end, last_busy_end + meeting_duration))\n\n    # Check if preferred time is available (after 16:00)\n    if nicole_preferred_start + meeting_duration <= work_end:\n        # Check if preferred time is not during a busy slot\n        preferred_available = True\n        for start, end in nicole_busy:\n            if (nicole_preferred_start < end and nicole_preferred_start + meeting_duration > start):\n                preferred_available = False\n                break\n        if preferred_available:\n            potential_slots.insert(0, (nicole_preferred_start, nicole_preferred_start + meeting_duration))\n\n    # Select the best available slot (preferred first, then others)\n    if potential_slots:\n        best_slot = potential_slots[0]\n        start_hour = best_slot[0] // 60\n        start_min = best_slot[0] % 60\n        end_hour = best_slot[1] // 60\n        end_min = best_slot[1] % 60\n        print(f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\")\n        print(\"Monday\")\n    else:\n        print(\"No available time slot found.\")\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_548"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "16:30",
                "end_time": "17:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "16:30",
                "end_time": "17:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, day, work_hours_start, work_hours_end, duration_minutes):\n    # Convert work hours to minutes since midnight for easier calculation\n    start_hour, start_minute = map(int, work_hours_start.split(':'))\n    end_hour, end_minute = map(int, work_hours_end.split(':'))\n    work_start = start_hour * 60 + start_minute\n    work_end = end_hour * 60 + end_minute\n    \n    # Initialize a list to keep track of busy times for all participants\n    busy_times = []\n    \n    for schedule in participants_schedules:\n        for busy_range in schedule:\n            start, end = busy_range.split(' to ')\n            start_h, start_m = map(int, start.split(':'))\n            end_h, end_m = map(int, end.split(':'))\n            busy_start = start_h * 60 + start_m\n            busy_end = end_h * 60 + end_m\n            busy_times.append((busy_start, busy_end))\n    \n    # Sort all busy times by start time\n    busy_times.sort()\n    \n    # Merge overlapping or adjacent busy times\n    merged_busy = []\n    for start, end in busy_times:\n        if not merged_busy:\n            merged_busy.append([start, end])\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                merged_busy[-1][1] = max(end, last_end)\n            else:\n                merged_busy.append([start, end])\n    \n    # Find the earliest available slot\n    prev_end = work_start\n    for start, end in merged_busy:\n        if start - prev_end >= duration_minutes:\n            # Found a suitable slot\n            meeting_start = prev_end\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\", day\n        prev_end = max(prev_end, end)\n    \n    # Check after the last busy time\n    if work_end - prev_end >= duration_minutes:\n        meeting_start = prev_end\n        meeting_end = meeting_start + duration_minutes\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\", day\n    \n    return None, day\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"9:00 to 9:30\", \"10:00 to 11:00\", \"12:00 to 12:30\"],  # Megan\n    [\"9:00 to 9:30\", \"11:30 to 12:00\", \"13:00 to 14:00\", \"15:30 to 16:30\"],  # Christine\n    [],  # Gabriel\n    [\"11:30 to 12:00\", \"14:30 to 15:00\"],  # Sara\n    [\"9:30 to 10:00\", \"10:30 to 12:00\", \"12:30 to 14:00\", \"14:30 to 15:00\", \"15:30 to 16:30\"],  # Bruce\n    [\"10:00 to 15:30\", \"16:00 to 16:30\"],  # Kathryn\n    [\"9:00 to 9:30\", \"11:00 to 11:30\", \"12:00 to 14:00\", \"14:30 to 15:30\"],  # Billy\n]\n\n# Find a meeting time\nmeeting_time, day = find_meeting_time(participants_schedules, \"Monday\", \"9:00\", \"17:00\", 30)\nprint(f\"{meeting_time}:{day}\")\n```",
            "count": "calendar_scheduling_example_446"
        },
        {
            "final_program_time": {
                "day": null,
                "start_time": null,
                "end_time": null
            },
            "expected_time": {
                "day": "Wednesday",
                "start_time": "16:30",
                "end_time": "17:00"
            },
            "has_error": true,
            "raw_model_response": "```python\nfrom datetime import time\n\ndef find_meeting_time(participants_busy, preferences, days, work_hours_start, work_hours_end, duration):\n    # Convert work hours to minutes for easier calculation\n    start_min = work_hours_start.hour * 60 + work_hours_start.minute\n    end_min = work_hours_end.hour * 60 + work_hours_end.minute\n    duration_min = duration * 60\n\n    for day in days:\n        # Skip if day is in preferences to avoid\n        if day in preferences.get('avoid_days', []):\n            continue\n        \n        # Collect all busy intervals for the day\n        busy_intervals = []\n        for person, schedule in participants_busy.items():\n            if day in schedule:\n                for interval in schedule[day]:\n                    start = interval[0].hour * 60 + interval[0].minute\n                    end = interval[1].hour * 60 + interval[1].minute\n                    busy_intervals.append((start, end))\n        \n        # Sort busy intervals by start time\n        busy_intervals.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = start_min\n        \n        for start, end in busy_intervals:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < end_min:\n            free_slots.append((prev_end, end_min))\n        \n        # Check each free slot for duration and preferences\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= duration_min:\n                proposed_start = slot_start\n                proposed_end = proposed_start + duration_min\n                \n                # Check if proposed time is before avoid_before time in preferences\n                avoid_before = preferences.get('avoid_before', {}).get(day, 0)\n                avoid_before_min = avoid_before.hour * 60 + avoid_before.minute if isinstance(avoid_before, time) else avoid_before * 60\n                \n                if proposed_start >= avoid_before_min:\n                    # Convert back to HH:MM format\n                    start_time = time(proposed_start // 60, proposed_start % 60)\n                    end_time = time(proposed_end // 60, proposed_end % 60)\n                    return day, start_time, end_time\n    \n    return None, None, None\n\n# Define participants' busy schedules\nparticipants_busy = {\n    'Amy': {\n        'Wednesday': [\n            (time(11, 0), time(11, 30)),\n            (time(13, 30), time(14, 0))\n        ]\n    },\n    'Pamela': {\n        'Monday': [\n            (time(9, 0), time(10, 30)),\n            (time(11, 0), time(16, 30))\n        ],\n        'Tuesday': [\n            (time(9, 0), time(9, 30)),\n            (time(10, 0), time(17, 0))\n        ],\n        'Wednesday': [\n            (time(9, 0), time(9, 30)),\n            (time(10, 0), time(11, 0)),\n            (time(11, 30), time(13, 30)),\n            (time(14, 30), time(15, 0)),\n            (time(16, 0), time(16, 30))\n        ]\n    }\n}\n\n# Define preferences\npreferences = {\n    'avoid_days': ['Monday', 'Tuesday'],\n    'avoid_before': {\n        'Monday': time(16, 0),\n        'Tuesday': time(16, 0),\n        'Wednesday': time(16, 0)\n    }\n}\n\n# Define meeting parameters\ndays_to_check = ['Monday', 'Tuesday', 'Wednesday']\nwork_start = time(9, 0)\nwork_end = time(17, 0)\nmeeting_duration = 0.5  # half hour\n\n# Find meeting time\nday, start_time, end_time = find_meeting_time(participants_busy, preferences, days_to_check, work_start, work_end, meeting_duration)\n\n# Output the result\nif day and start_time and end_time:\n    print(f\"{day}: {start_time.strftime('%H:%M')}:{end_time.strftime('%H:%M')}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_786"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "15:00",
                "end_time": "15:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "15:00",
                "end_time": "15:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours, preferences):\n    # Parse work hours\n    work_start, work_end = work_hours.split(' to ')\n    work_start = int(work_start.split(':')[0])\n    work_end = int(work_end.split(':')[0])\n    \n    # Initialize available slots (in minutes since 9:00)\n    slots = []\n    current_time = work_start * 60\n    \n    while current_time + duration <= work_end * 60:\n        slots.append((current_time, current_time + duration))\n        current_time += 30  # Assuming 30-minute increments for simplicity\n    \n    # Apply Megan's preference to avoid meetings before 10:00\n    preferred_start = 10 * 60  # 10:00 in minutes\n    slots = [slot for slot in slots if slot[0] >= preferred_start]\n    \n    # Check each slot against each participant's busy times\n    for slot_start, slot_end in slots:\n        slot_ok = True\n        for participant, meetings in participants_schedules.items():\n            for meeting in meetings:\n                meeting_start, meeting_end = meeting.split(' to ')\n                meeting_start = int(meeting_start.split(':')[0]) * 60 + int(meeting_start.split(':')[1])\n                meeting_end = int(meeting_end.split(':')[0]) * 60 + int(meeting_end.split(':')[1])\n                \n                # Check if slot overlaps with any meeting\n                if not (slot_end <= meeting_start or slot_start >= meeting_end):\n                    slot_ok = False\n                    break\n            if not slot_ok:\n                break\n        \n        if slot_ok:\n            # Convert slot back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return None\n\n# Define participants' schedules\nparticipants_schedules = {\n    'Kimberly': ['10:00 to 10:30', '11:00 to 12:00', '16:00 to 16:30'],\n    'Megan': [],\n    'Marie': ['10:00 to 11:00', '11:30 to 15:00', '16:00 to 16:30'],\n    'Diana': ['9:30 to 10:00', '10:30 to 14:30', '15:30 to 17:00']\n}\n\n# Meeting details\nduration = 30  # minutes\nwork_hours = '9:00 to 17:00'\npreferences = {'Megan': 'avoid before 10:00'}\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours, preferences)\n\n# Output the result\nprint(f\"{meeting_time}:Monday\")\n```",
            "count": "calendar_scheduling_example_185"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "16:00",
                "end_time": "16:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "16:00",
                "end_time": "16:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    meeting_duration = 30  # minutes\n\n    # Define busy times for each participant in minutes since midnight\n    tyler_busy = {\n        'Tuesday': [(9*60, 9*60 + 30), (14*60 + 30, 15*60)],\n        'Wednesday': [(10*60 + 30, 11*60), (12*60 + 30, 13*60), (13*60 + 30, 14*60), (16*60 + 30, 17*60)],\n    }\n    ruth_busy = {\n        'Monday': [(9*60, 10*60), (10*60 + 30, 12*60), (12*60 + 30, 14*60 + 30), (15*60, 16*60), (16*60 + 30, 17*60)],\n        'Tuesday': [(9*60, 17*60)],\n        'Wednesday': [(9*60, 17*60)],\n    }\n    # Tyler's preference: avoid Monday before 16:00\n    tyler_preference = {\n        'Monday': (9*60, 16*60)\n    }\n\n    # Iterate through each day\n    for day in days:\n        if day == 'Monday' and day in tyler_preference:\n            # On Monday, only consider times after 16:00 due to Tyler's preference\n            start_time = max(work_start, tyler_preference[day][1])\n        else:\n            start_time = work_start\n\n        # Generate all possible slots for the day\n        current_time = start_time\n        while current_time + meeting_duration <= work_end:\n            slot_end = current_time + meeting_duration\n            # Check if the slot is free for both Tyler and Ruth\n            tyler_free = True\n            ruth_free = True\n\n            # Check Tyler's busy times\n            if day in tyler_busy:\n                for busy_start, busy_end in tyler_busy[day]:\n                    if not (slot_end <= busy_start or current_time >= busy_end):\n                        tyler_free = False\n                        break\n\n            # Check Ruth's busy times\n            if day in ruth_busy:\n                for busy_start, busy_end in ruth_busy[day]:\n                    if not (slot_end <= busy_start or current_time >= busy_end):\n                        ruth_free = False\n                        break\n\n            if tyler_free and ruth_free:\n                # Format the time as HH:MM:HH:MM\n                start_hh = current_time // 60\n                start_mm = current_time % 60\n                end_hh = slot_end // 60\n                end_mm = slot_end % 60\n                return f\"{day}: {start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n            current_time += 15  # Check in 15-minute increments\n\n    return \"No suitable time found\"\n\n# Run the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_724"
        },
        {
            "final_program_time": {
                "day": null,
                "start_time": null,
                "end_time": null
            },
            "expected_time": {
                "day": "Thursday",
                "start_time": "14:30",
                "end_time": "15:00"
            },
            "has_error": true,
            "raw_model_response": "```python\n'''\nThis script schedules a meeting between Julie and Ruth based on their availability and constraints.\n'''",
            "count": "calendar_scheduling_example_819"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "12:00",
                "end_time": "12:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "12:00",
                "end_time": "12:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, day, work_start, work_end, duration_minutes):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration = duration_minutes\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = interval\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            busy_intervals.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for interval in busy_intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                new_end = max(last_end, current_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append(interval)\n    \n    # Find available slots by checking gaps between merged intervals and work hours\n    available_slots = []\n    prev_end = work_start_min\n    \n    for interval in merged:\n        start, end = interval\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        available_slots.append((prev_end, work_end_min))\n    \n    # Find the first available slot that can fit the meeting\n    for slot in available_slots:\n        start, end = slot\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return None\n\n# Define the participants' schedules\ngregory_schedule = [\n    (\"09:00\", \"10:00\"),\n    (\"10:30\", \"11:30\"),\n    (\"12:30\", \"13:00\"),\n    (\"13:30\", \"14:00\")\n]\n\nnatalie_schedule = []  # Wide open\n\nchristine_schedule = [\n    (\"09:00\", \"11:30\"),\n    (\"13:30\", \"17:00\")\n]\n\nvincent_schedule = [\n    (\"09:00\", \"09:30\"),\n    (\"10:30\", \"12:00\"),\n    (\"12:30\", \"14:00\"),\n    (\"14:30\", \"17:00\")\n]\n\n# Combine all schedules\nparticipants_schedules = [\n    gregory_schedule,\n    natalie_schedule,\n    christine_schedule,\n    vincent_schedule\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(\n    participants_schedules,\n    day=\"Monday\",\n    work_start=\"09:00\",\n    work_end=\"17:00\",\n    duration_minutes=30\n)\n\n# Output the result\nprint(f\"{meeting_time}:Monday\")\n```",
            "count": "calendar_scheduling_example_111"
        },
        {
            "final_program_time": {
                "day": null,
                "start_time": null,
                "end_time": null
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "14:00",
                "end_time": "15:00"
            },
            "has_error": true,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time strings to minutes since start of the day\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's schedule to find common free slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_slots.append((start, end))\n        \n        # Sort the busy slots by start time\n        busy_slots.sort()\n        \n        # Calculate free slots for this participant\n        current_free = []\n        prev_end = work_start\n        for start, end in busy_slots:\n            if start > prev_end:\n                current_free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            current_free.append((prev_end, work_end))\n        \n        # Intersect current_free with existing free_slots\n        new_free_slots = []\n        i = j = 0\n        while i < len(free_slots) and j < len(current_free):\n            start1, end1 = free_slots[i]\n            start2, end2 = current_free[j]\n            \n            # Find the overlap\n            start = max(start1, start2)\n            end = min(end1, end2)\n            if start < end:\n                new_free_slots.append((start, end))\n            \n            # Move the pointer which ends first\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        \n        free_slots = new_free_slots\n    \n    # Find the first slot that can fit the meeting duration\n    for start, end in free_slots:\n        if end - start >= duration_minutes:\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            \n            meeting_start = minutes_to_time(start)\n            meeting_end = minutes_to_time(start + duration_minutes)\n            return meeting_start, meeting_end\n    \n    return None\n\n# Define the participants' schedules\nparticipants_schedules = [\n    # Julie's schedule\n    [\"9:00:9:30\", \"11:00:11:30\", \"12:00:12:30\", \"13:30:14:00\", \"16:00:17:00\"],\n    # Sean's schedule\n    [\"9:00:9:30\", \"13:00:13:30\", \"15:00:15:30\", \"16:00:16:30\"],\n    # Lori's schedule\n    [\"10:00:10:30\", \"11:00:13:00\", \"15:30:17:00\"]\n]\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 60  # 1 hour\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes)\n\n# Output the result\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{start}:{end}\")\n    print(\"Monday\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_42"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "13:30",
                "end_time": "14:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "13:30",
                "end_time": "14:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    participants = {\n        'Daniel': [],\n        'Kathleen': [('14:30', '15:30')],\n        'Carolyn': [('12:00', '12:30'), ('13:00', '13:30')],\n        'Roger': [],\n        'Cheryl': [('09:00', '09:30'), ('10:00', '11:30'), ('12:30', '13:30'), ('14:00', '17:00')],\n        'Virginia': [('09:30', '11:30'), ('12:00', '12:30'), ('13:00', '13:30'), ('14:30', '15:30'), ('16:00', '17:00')],\n        'Angela': [('09:30', '10:00'), ('10:30', '11:30'), ('12:00', '12:30'), ('13:00', '13:30'), ('14:00', '16:30')]\n    }\n    \n    # Roger's constraint: not before 12:30\n    roger_constraint = ('12:30', '17:00')\n    \n    # Work hours\n    work_start = '09:00'\n    work_end = '17:00'\n    \n    # Meeting duration in minutes\n    meeting_duration = 30\n    \n    # Convert time string to minutes since 00:00 for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Generate all busy intervals for all participants\n    busy_intervals = []\n    for person, intervals in participants.items():\n        for start, end in intervals:\n            busy_intervals.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Add Roger's constraint as a busy interval before 12:30\n    roger_constraint_start = time_to_minutes(roger_constraint[0])\n    busy_intervals.append((time_to_minutes(work_start), roger_constraint_start))\n    \n    # Sort intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_end = max(end, last_end)\n                merged[-1] = (last_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find free slots between merged busy intervals\n    free_slots = []\n    previous_end = time_to_minutes(work_start)\n    for start, end in merged:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < time_to_minutes(work_end):\n        free_slots.append((previous_end, time_to_minutes(work_end)))\n    \n    # Filter free slots that can accommodate the meeting duration\n    possible_slots = []\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            possible_slots.append((start, end))\n    \n    # Select the earliest possible slot\n    if possible_slots:\n        meeting_start = possible_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        meeting_time = (minutes_to_time(meeting_start), minutes_to_time(meeting_end))\n        print(f\"{meeting_time[0]}:{meeting_time[1]}\")\n        print(\"Monday\")\n    else:\n        print(\"No suitable time found\")\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_476"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "16:30",
                "end_time": "17:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "16:30",
                "end_time": "17:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours and meeting duration\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Participants' schedules and constraints\n    schedules = {\n        'Wayne': [],\n        'Melissa': [(10 * 60, 11 * 60), (12.5 * 60, 14 * 60), (15 * 60, 15.5 * 60)],\n        'Catherine': [],\n        'Gregory': [(12.5 * 60, 13 * 60), (15.5 * 60, 16 * 60)],\n        'Victoria': [(9 * 60, 9.5 * 60), (10.5 * 60, 11.5 * 60), (13 * 60, 14 * 60), (14.5 * 60, 15 * 60), (15.5 * 60, 16.5 * 60)],\n        'Thomas': [(10 * 60, 12 * 60), (12.5 * 60, 13 * 60), (14.5 * 60, 16 * 60)],\n        'Jennifer': [(9 * 60, 9.5 * 60), (10 * 60, 10.5 * 60), (11 * 60, 13 * 60), (13.5 * 60, 14.5 * 60), (15 * 60, 15.5 * 60), (16 * 60, 16.5 * 60)],\n    }\n\n    # Wayne's preference: avoid before 14:00\n    wayne_preference_start = 14 * 60\n\n    # Generate busy intervals for all participants except Wayne\n    busy_intervals = []\n    for person, intervals in schedules.items():\n        if person != 'Wayne':\n            for interval in intervals:\n                busy_intervals.append(interval)\n\n    # Add Wayne's preference as a busy interval if before 14:00\n    busy_intervals.append((work_start, wayne_preference_start))\n\n    # Sort busy intervals by start time\n    busy_intervals.sort()\n\n    # Find free slots by checking gaps between busy intervals\n    free_slots = []\n    previous_end = work_start\n\n    for interval in busy_intervals:\n        start, end = interval\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n\n    # Check the remaining time after the last busy interval\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Find the first free slot that can accommodate the meeting\n    for slot in free_slots:\n        start, end = slot\n        if end - start >= meeting_duration:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            start_hh = int(meeting_start // 60)\n            start_mm = int(meeting_start % 60)\n            end_hh = int(meeting_end // 60)\n            end_mm = int(meeting_end % 60)\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nmeeting_time = find_meeting_time()\nprint(f\"Monday:{meeting_time}\")\n```",
            "count": "calendar_scheduling_example_458"
        },
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "11:00",
                "end_time": "12:00"
            },
            "expected_time": {
                "day": "Tuesday",
                "start_time": "11:00",
                "end_time": "12:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(betty_busy, megan_busy, days, duration_hours=1, work_start=9, work_end=17):\n    for day in days:\n        # Initialize available time for the day\n        betty_available = [(work_start * 60, work_end * 60)]\n        megan_available = [(work_start * 60, work_end * 60)]\n        \n        # Subtract busy times for Betty\n        for busy in betty_busy.get(day, []):\n            start, end = busy\n            start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n            end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n            new_available = []\n            for slot in betty_available:\n                if end_min <= slot[0] or start_min >= slot[1]:\n                    new_available.append(slot)\n                else:\n                    if slot[0] < start_min:\n                        new_available.append((slot[0], start_min))\n                    if slot[1] > end_min:\n                        new_available.append((end_min, slot[1]))\n            betty_available = new_available\n        \n        # Subtract busy times for Megan\n        for busy in megan_busy.get(day, []):\n            start, end = busy\n            start_min = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n            end_min = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n            new_available = []\n            for slot in megan_available:\n                if end_min <= slot[0] or start_min >= slot[1]:\n                    new_available.append(slot)\n                else:\n                    if slot[0] < start_min:\n                        new_available.append((slot[0], start_min))\n                    if slot[1] > end_min:\n                        new_available.append((end_min, slot[1]))\n            megan_available = new_available\n        \n        # Find overlapping slots\n        for b_slot in betty_available:\n            for m_slot in megan_available:\n                overlap_start = max(b_slot[0], m_slot[0])\n                overlap_end = min(b_slot[1], m_slot[1])\n                if overlap_end - overlap_start >= duration_hours * 60:\n                    # Convert back to HH:MM format\n                    start_hh = overlap_start // 60\n                    start_mm = overlap_start % 60\n                    end_hh = (overlap_start + duration_hours * 60) // 60\n                    end_mm = (overlap_start + duration_hours * 60) % 60\n                    return day, f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    return None, None\n\n# Define busy times\nbetty_busy = {\n    'Monday': [('10:00', '10:30'), ('11:30', '12:30'), ('16:00', '16:30')],\n    'Tuesday': [('9:30', '10:00'), ('10:30', '11:00'), ('12:00', '12:30'), ('13:30', '15:00'), ('16:30', '17:00')],\n    'Wednesday': [('13:30', '14:00'), ('14:30', '15:00')],\n    'Friday': [('9:00', '10:00'), ('11:30', '12:00'), ('12:30', '13:00'), ('14:30', '15:00')]\n}\n\nmegan_busy = {\n    'Monday': [('9:00', '17:00')],\n    'Tuesday': [('9:00', '9:30'), ('10:00', '10:30'), ('12:00', '14:00'), ('15:00', '15:30'), ('16:00', '16:30')],\n    'Wednesday': [('9:30', '10:30'), ('11:00', '11:30'), ('12:30', '13:00'), ('13:30', '14:30'), ('15:30', '17:00')],\n    'Thursday': [('9:00', '10:30'), ('11:30', '14:00'), ('14:30', '15:00'), ('15:30', '16:30')],\n    'Friday': [('9:00', '17:00')]\n}\n\n# Days to check (excluding Wednesday and Thursday as per Betty's constraint)\ndays_to_check = ['Tuesday']\n\nday, time_slot = find_meeting_time(betty_busy, megan_busy, days_to_check)\nif day and time_slot:\n    print(f\"{day}, {time_slot}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_964"
        },
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "16:30",
                "end_time": "17:00"
            },
            "expected_time": {
                "day": "Tuesday",
                "start_time": "16:30",
                "end_time": "17:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday']\n    \n    # Margaret's constraints (in minutes since midnight)\n    margaret_unavailable = {\n        'Monday': [\n            (10 * 60 + 30, 11 * 60 + 0),\n            (11 * 60 + 30, 12 * 60 + 0),\n            (13 * 60 + 0, 13 * 60 + 30),\n            (15 * 60 + 0, 17 * 60 + 0)\n        ],\n        'Tuesday': [\n            (12 * 60 + 0, 12 * 60 + 30)\n        ]\n    }\n    \n    # Alexis's constraints (in minutes since midnight)\n    alexis_unavailable = {\n        'Monday': [\n            (9 * 60 + 30, 11 * 60 + 30),\n            (12 * 60 + 30, 13 * 60 + 0),\n            (14 * 60 + 0, 17 * 60 + 0)\n        ],\n        'Tuesday': [\n            (9 * 60 + 0, 9 * 60 + 30),\n            (10 * 60 + 0, 10 * 60 + 30),\n            (14 * 60 + 0, 16 * 60 + 30)\n        ]\n    }\n    \n    # Margaret's preferences: not Monday, and Tuesday before 14:30\n    preferred_day = 'Tuesday'\n    margaret_preferred_start = 14 * 60 + 30  # 14:30\n    \n    meeting_duration = 30  # minutes\n    \n    # Check Tuesday first (preferred day)\n    day = preferred_day\n    # Generate available slots for Margaret and Alexis on Tuesday\n    margaret_slots = []\n    alexis_slots = []\n    \n    # Margaret's available times on Tuesday (after 14:30)\n    margaret_busy = margaret_unavailable.get(day, [])\n    margaret_busy.append((0, margaret_preferred_start))  # Block before 14:30\n    margaret_busy.sort()\n    \n    # Find Margaret's available slots\n    prev_end = work_start\n    for start, end in margaret_busy:\n        if start > prev_end:\n            margaret_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        margaret_slots.append((prev_end, work_end))\n    \n    # Alexis's available times on Tuesday\n    alexis_busy = alexis_unavailable.get(day, [])\n    alexis_busy.sort()\n    \n    prev_end = work_start\n    for start, end in alexis_busy:\n        if start > prev_end:\n            alexis_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        alexis_slots.append((prev_end, work_end))\n    \n    # Find overlapping slots\n    for m_start, m_end in margaret_slots:\n        for a_start, a_end in alexis_slots:\n            overlap_start = max(m_start, a_start)\n            overlap_end = min(m_end, a_end)\n            if overlap_end - overlap_start >= meeting_duration:\n                # Found a suitable slot\n                start_time = overlap_start\n                end_time = start_time + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                start_str = f\"{start_time // 60:02d}:{start_time % 60:02d}\"\n                end_str = f\"{end_time // 60:02d}:{end_time % 60:02d}\"\n                print(f\"{start_str}:{end_str}\")\n                print(day)\n                return\n    \n    # If no slot found on Tuesday (shouldn't happen per problem statement)\n    print(\"No suitable time found.\")\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_629"
        },
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "9:30",
                "end_time": "10:00"
            },
            "expected_time": {
                "day": "Tuesday",
                "start_time": "9:30",
                "end_time": "10:00"
            },
            "has_error": false,
            "raw_model_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time(participants, days, work_hours_start, work_hours_end, duration, preferences):\n    # Parse work hours\n    start_hour, start_minute = map(int, work_hours_start.split(':'))\n    end_hour, end_minute = map(int, work_hours_end.split(':'))\n    \n    # Convert duration to timedelta\n    duration = timedelta(minutes=duration)\n    \n    for day in days:\n        if day in preferences.get('avoid_days', []):\n            continue\n        \n        # Initialize current time to start of work day\n        current_time = datetime.strptime(f\"{day} {work_hours_start}\", \"%A %H:%M\")\n        end_time = datetime.strptime(f\"{day} {work_hours_end}\", \"%A %H:%M\")\n        \n        while current_time + duration <= end_time:\n            slot_end = current_time + duration\n            slot_ok = True\n            \n            # Check each participant's availability\n            for participant, meetings in participants.items():\n                for meeting in meetings.get(day, []):\n                    meeting_start = datetime.strptime(f\"{day} {meeting[0]}\", \"%A %H:%M\")\n                    meeting_end = datetime.strptime(f\"{day} {meeting[1]}\", \"%A %H:%M\")\n                    \n                    # Check for overlap\n                    if not (slot_end <= meeting_start or current_time >= meeting_end):\n                        slot_ok = False\n                        break\n                \n                if not slot_ok:\n                    break\n            \n            if slot_ok:\n                return day, current_time.time(), slot_end.time()\n            \n            # Move to next possible slot (in 15-minute increments for efficiency)\n            current_time += timedelta(minutes=15)\n    \n    return None\n\n# Define participants' schedules\nparticipants = {\n    \"Robert\": {\n        \"Monday\": [(\"11:00\", \"11:30\"), (\"14:00\", \"14:30\"), (\"15:30\", \"16:00\")],\n        \"Tuesday\": [(\"10:30\", \"11:00\"), (\"15:00\", \"15:30\")],\n        \"Wednesday\": [(\"10:00\", \"11:00\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:00\"), \n                     (\"13:30\", \"14:00\"), (\"15:00\", \"15:30\"), (\"16:00\", \"16:30\")]\n    },\n    \"Ralph\": {\n        \"Monday\": [(\"10:00\", \"13:30\"), (\"14:00\", \"14:30\"), (\"15:00\", \"17:00\")],\n        \"Tuesday\": [(\"09:00\", \"09:30\"), (\"10:00\", \"10:30\"), (\"11:00\", \"11:30\"), \n                    (\"12:00\", \"13:00\"), (\"14:00\", \"15:30\"), (\"16:00\", \"17:00\")],\n        \"Wednesday\": [(\"10:30\", \"11:00\"), (\"11:30\", \"12:00\"), (\"13:00\", \"14:30\"), (\"16:30\", \"17:00\")]\n    }\n}\n\n# Define meeting parameters\ndays_to_check = [\"Monday\", \"Tuesday\", \"Wednesday\"]\nwork_hours = (\"9:00\", \"17:00\")\nmeeting_duration = 30  # minutes\npreferences = {\n    \"avoid_days\": [\"Monday\"]  # Robert wants to avoid Monday\n}\n\n# Find meeting time\nresult = find_meeting_time(participants=participants,\n                          days=days_to_check,\n                          work_hours_start=work_hours[0],\n                          work_hours_end=work_hours[1],\n                          duration=meeting_duration,\n                          preferences=preferences)\n\nif result:\n    day, start_time, end_time = result\n    print(f\"{day}:{start_time.strftime('%H:%M')}:{end_time.strftime('%H:%M')}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_702"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "10:30",
                "end_time": "11:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "10:30",
                "end_time": "11:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours and meeting duration\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Define busy slots for each participant in minutes since midnight\n    ryan_busy = [\n        (9 * 60, 9 * 60 + 30),   # 9:00-9:30\n        (12 * 60 + 30, 13 * 60)  # 12:30-13:00\n    ]\n    ruth_busy = []  # No meetings\n    denise_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),  # 9:30-10:30\n        (12 * 60, 13 * 60),            # 12:00-13:00\n        (14 * 60 + 30, 16 * 60 + 30)   # 14:30-16:30\n    ]\n    denise_no_meet_after = 12 * 60 + 30  # 12:30\n\n    # Combine all busy slots\n    all_busy = ryan_busy + ruth_busy + denise_busy\n\n    # Sort busy slots by start time\n    all_busy.sort()\n\n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n\n    for busy_start, busy_end in all_busy:\n        if busy_start > prev_end:\n            available_slots.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Filter slots that meet duration and Denise's constraint\n    valid_slots = []\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Check if slot starts before Denise's no-meet-after time\n            if slot_start <= denise_no_meet_after:\n                valid_slots.append((slot_start, slot_end))\n\n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n    else:\n        return None\n\n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n\n    start_time = minutes_to_time(meeting_start)\n    end_time = minutes_to_time(meeting_end)\n\n    return f\"{start_time}:{end_time}\", \"Monday\"\n\n# Execute and print the result\nmeeting_time, day = find_meeting_time()\nprint(f\"{{{meeting_time}}} {day}\")\n'''python\ndef find_meeting_time():\n    # Define work hours and meeting duration\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 60  # 1 hour in minutes\n\n    # Define busy slots for each participant in minutes since midnight\n    ryan_busy = [\n        (9 * 60, 9 * 60 + 30),   # 9:00-9:30\n        (12 * 60 + 30, 13 * 60)  # 12:30-13:00\n    ]\n    ruth_busy = []  # No meetings\n    denise_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),  # 9:30-10:30\n        (12 * 60, 13 * 60),            # 12:00-13:00\n        (14 * 60 + 30, 16 * 60 + 30)   # 14:30-16:30\n    ]\n    denise_no_meet_after = 12 * 60 + 30  # 12:30\n\n    # Combine all busy slots\n    all_busy = ryan_busy + ruth_busy + denise_busy\n\n    # Sort busy slots by start time\n    all_busy.sort()\n\n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n\n    for busy_start, busy_end in all_busy:\n        if busy_start > prev_end:\n            available_slots.append((prev_end, busy_start))\n        prev_end = max(prev_end, busy_end)\n\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Filter slots that meet duration and Denise's constraint\n    valid_slots = []\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Check if slot starts before Denise's no-meet-after time\n            if slot_start <= denise_no_meet_after:\n                valid_slots.append((slot_start, slot_end))\n\n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n    else:\n        return None\n\n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n\n    start_time = minutes_to_time(meeting_start)\n    end_time = minutes_to_time(meeting_end)\n\n    return f\"{start_time}:{end_time}\", \"Monday\"\n\n# Execute and print the result\nmeeting_time, day = find_meeting_time()\nprint(f\"{{{meeting_time}}} {day}\")\n'''",
            "count": "calendar_scheduling_example_36"
        },
        {
            "final_program_time": {
                "day": null,
                "start_time": null,
                "end_time": null
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "11:30",
                "end_time": "12:00"
            },
            "has_error": true,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Function to subtract busy slots from free slots\n    def subtract_busy_slots(free_slots, busy_start, busy_end):\n        new_free_slots = []\n        for slot_start, slot_end in free_slots:\n            if busy_start >= slot_end or busy_end <= slot_start:\n                new_free_slots.append((slot_start, slot_end))\n            else:\n                if slot_start < busy_start:\n                    new_free_slots.append((slot_start, busy_start))\n                if slot_end > busy_end:\n                    new_free_slots.append((busy_end, slot_end))\n        return new_free_slots\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        for busy_start, busy_end in schedule:\n            busy_start_min = time_to_minutes(busy_start)\n            busy_end_min = time_to_minutes(busy_end)\n            free_slots = subtract_busy_slots(free_slots, busy_start_min, busy_end_min)\n    \n    # Find the first free slot that can accommodate the meeting\n    meeting_duration_min = meeting_duration * 60\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration_min:\n            meeting_end = slot_start + meeting_duration_min\n            return minutes_to_time(slot_start), minutes_to_time(meeting_end)\n    \n    return None, None\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [],  # Walter has no meetings\n    [(\"09:00\", \"09:30\"), (\"10:00\", \"10:30\"), (\"13:30\", \"14:30\"), (\"15:00\", \"16:00\")],  # Cynthia\n    [(\"10:00\", \"11:00\"), (\"13:00\", \"13:30\"), (\"14:00\", \"15:00\"), (\"16:00\", \"16:30\")],  # Ann\n    [(\"09:00\", \"11:30\"), (\"12:30\", \"13:30\"), (\"14:30\", \"17:00\")],  # Catherine\n    [(\"09:00\", \"09:30\"), (\"10:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"14:30\"), (\"15:00\", \"16:00\")],  # Kyle\n]\n\n# Find the meeting time\nmeeting_start, meeting_end = find_meeting_time(\n    participants_schedules=participants_schedules,\n    work_hours_start=\"09:00\",\n    work_hours_end=\"17:00\",\n    meeting_duration=0.5\n)\n\n# Output the result\nprint(f\"{meeting_start}:{meeting_end}:Monday\")\n```",
            "count": "calendar_scheduling_example_244"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "11:00",
                "end_time": "11:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "11:00",
                "end_time": "11:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, day, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time slots to minutes since start of day for easier comparison\n    start_time = work_hours_start * 60\n    end_time = work_hours_end * 60\n    duration = duration_minutes\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start = busy[0] * 60\n            end = busy[1] * 60\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find the first available slot outside busy intervals\n    previous_end = start_time\n    for start, end in merged:\n        if start > previous_end:\n            available_start = previous_end\n            available_end = start\n            if available_end - available_start >= duration:\n                # Found a suitable slot\n                meeting_start = available_start\n                meeting_end = meeting_start + duration\n                return (meeting_start, meeting_end)\n        previous_end = max(previous_end, end)\n    \n    # Check after the last busy interval\n    if previous_end + duration <= end_time:\n        meeting_start = previous_end\n        meeting_end = meeting_start + duration\n        return (meeting_start, meeting_end)\n    \n    # No available slot found (though the problem states one exists)\n    return None\n\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Define participants' schedules in 24-hour format as (start_hour, end_hour)\ngregory = [(9, 9.5), (11.5, 12)]\njonathan = [(9, 9.5), (12, 12.5), (13, 13.5), (15, 16), (16.5, 17)]\nbarbara = [(10, 10.5), (13.5, 14)]\njesse = [(10, 11), (12.5, 14.5)]\nalan = [(9.5, 11), (11.5, 12.5), (13, 15.5), (16, 17)]\nnicole = [(9, 10.5), (11.5, 12), (12.5, 13.5), (14, 17)]\ncatherine = [(9, 10.5), (12, 13.5), (15, 15.5), (16, 16.5)]\n\n# All participants' schedules\nparticipants_schedules = [gregory, jonathan, barbara, jesse, alan, nicole, catherine]\n\n# Find a meeting time\nmeeting_time = find_meeting_time(participants_schedules, \"Monday\", 9, 17, 30)\n\nif meeting_time:\n    start, end = meeting_time\n    start_time_str = minutes_to_time(start)\n    end_time_str = minutes_to_time(end)\n    print(f\"{start_time_str}:{end_time_str}\")\n    print(\"Monday\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_473"
        },
        {
            "final_program_time": {
                "day": null,
                "start_time": null,
                "end_time": null
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "9:30",
                "end_time": "10:00"
            },
            "has_error": true,
            "raw_model_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration, day):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    start_work, end_work = work_hours\n    start_work_min = time_to_minutes(start_work)\n    end_work_min = time_to_minutes(end_work)\n    duration_min = duration * 60\n\n    # Generate all busy intervals in minutes for each participant\n    busy_intervals = []\n    for busy_slots in participents_busy:\n        participant_busy = []\n        for slot in busy_slots:\n            start, end = slot\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            participant_busy.append((start_min, end_min))\n        busy_intervals.append(participant_busy)\n\n    # Find all free intervals for each participant\n    free_intervals = []\n    for participant in busy_intervals:\n        participant_free = []\n        previous_end = start_work_min\n        for start, end in sorted(participant):\n            if start > previous_end:\n                participant_free.append((previous_end, start))\n            previous_end = max(previous_end, end)\n        if previous_end < end_work_min:\n            participant_free.append((previous_end, end_work_min))\n        free_intervals.append(participant_free)\n\n    # Find overlapping free intervals across all participants\n    common_free = free_intervals[0]\n    for participant in free_intervals[1:]:\n        new_common_free = []\n        i = j = 0\n        while i < len(common_free) and j < len(participant):\n            start1, end1 = common_free[i]\n            start2, end2 = participant[j]\n            overlap_start = max(start1, start2)\n            overlap_end = min(end1, end2)\n            if overlap_start < overlap_end:\n                new_common_free.append((overlap_start, overlap_end))\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free = new_common_free\n\n    # Find the earliest slot that fits the duration\n    for start, end in common_free:\n        if end - start >= duration_min:\n            meeting_start = start\n            meeting_end = meeting_start + duration_min\n            return (\n                f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\",\n                day\n            )\n    return None\n\n# Define the task parameters\nparticipants_busy = [\n    [(\"9:00\", \"9:30\"), (\"10:30\", \"11:00\"), (\"14:00\", \"16:00\")],  # Lisa's schedule\n    [(\"9:00\", \"9:30\"), (\"11:00\", \"11:30\"), (\"12:30\", \"13:30\"), \n     (\"14:00\", \"15:00\"), (\"15:30\", \"16:00\"), (\"16:30\", \"17:00\")]  # Anthony's schedule\n]\nwork_hours = (\"9:00\", \"17:00\")\nduration = 30  # minutes\nday = \"Monday\"\n\n# Find the meeting time\nmeeting_time, day = find_meeting_time(participants_busy, work_hours, duration, day)\nprint(f\"{meeting_time}:{day}\")\n```",
            "count": "calendar_scheduling_example_583"
        },
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "10:30",
                "end_time": "11:00"
            },
            "expected_time": {
                "day": "Tuesday",
                "start_time": "15:00",
                "end_time": "15:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours and days\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday']\n    \n    # Define participants' busy slots in minutes since midnight\n    jesse_busy = {\n        'Monday': [(13 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60)],\n        'Tuesday': [(9 * 60, 9 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60, 15 * 60)]\n    }\n    \n    lawrence_busy = {\n        'Monday': [(9 * 60, 17 * 60)],  # Entire day busy\n        'Tuesday': [\n            (9 * 60 + 30, 10 * 60 + 30),\n            (11 * 60 + 30, 12 * 60 + 30),\n            (13 * 60, 13 * 60 + 30),\n            (14 * 60 + 30, 15 * 60),\n            (15 * 60 + 30, 16 * 60 + 30)\n        ]\n    }\n    \n    # Lawrence cannot meet on Tuesday after 16:30\n    lawrence_additional_constraint = {\n        'Tuesday': (16 * 60 + 30, work_hours_end)\n    }\n    \n    meeting_duration = 30  # minutes\n    \n    # Iterate through each day\n    for day in days:\n        # Skip Monday for Lawrence since he's busy all day\n        if day == 'Monday':\n            continue\n        \n        # Combine all busy slots for both participants\n        all_busy = jesse_busy[day] + lawrence_busy[day]\n        \n        # Add Lawrence's additional constraint if applicable\n        if day in lawrence_additional_constraint:\n            all_busy.append(lawrence_additional_constraint[day])\n        \n        # Sort all busy slots by start time\n        all_busy.sort()\n        \n        # Check for available slots\n        prev_end = work_hours_start\n        for busy_start, busy_end in all_busy:\n            if busy_start > prev_end:\n                available_start = prev_end\n                available_end = busy_start\n                if available_end - available_start >= meeting_duration:\n                    # Found a suitable slot\n                    start_h = available_start // 60\n                    start_m = available_start % 60\n                    end_h = (available_start + meeting_duration) // 60\n                    end_m = (available_start + meeting_duration) % 60\n                    return day, f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n            prev_end = max(prev_end, busy_end)\n        \n        # Check after the last busy slot\n        if work_hours_end - prev_end >= meeting_duration:\n            start_h = prev_end // 60\n            start_m = prev_end % 60\n            end_h = (prev_end + meeting_duration) // 60\n            end_m = (prev_end + meeting_duration) % 60\n            return day, f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n    \n    return None, None\n\nday, time_slot = find_meeting_time()\nprint(f\"{day}: {time_slot}\")\n```",
            "count": "calendar_scheduling_example_652"
        },
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "15:00",
                "end_time": "15:30"
            },
            "expected_time": {
                "day": "Thursday",
                "start_time": "16:00",
                "end_time": "16:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    meeting_duration = 30  # minutes\n\n    # Betty's busy times in minutes since midnight for each day\n    betty_busy = {\n        'Monday': [(10*60, 10*60+30), (13*60+30, 14*60), (15*60, 15*60+30), (16*60, 16*60+30)],\n        'Tuesday': [(9*60, 9*60+30), (11*60+30, 12*60), (12*60+30, 13*60), (13*60+30, 14*60), (16*60+30, 17*60)],\n        'Wednesday': [(9*60+30, 10*60+30), (13*60, 13*60+30), (14*60, 14*60+30)],\n        'Thursday': [(9*60+30, 10*60), (11*60+30, 12*60), (14*60, 14*60+30), (15*60, 15*60+30), (16*60+30, 17*60)]\n    }\n\n    # Scott's busy times in minutes since midnight for each day\n    scott_busy = {\n        'Monday': [(9*60+30, 15*60), (15*60+30, 16*60), (16*60+30, 17*60)],\n        'Tuesday': [(9*60, 9*60+30), (10*60, 11*60), (11*60+30, 12*60), (12*60+30, 13*60+30), (14*60, 15*60), (16*60, 16*60+30)],\n        'Wednesday': [(9*60+30, 12*60+30), (13*60, 13*60+30), (14*60, 14*60+30), (15*60, 15*60+30), (16*60, 16*60+30)],\n        'Thursday': [(9*60, 9*60+30), (10*60, 10*60+30), (11*60, 12*60), (12*60+30, 13*60), (15*60, 16*60), (16*60+30, 17*60)]\n    }\n\n    # Additional constraints\n    betty_no_days = ['Monday']  # Betty cannot meet on Monday\n    betty_no_before = {'Tuesday': 15*60, 'Thursday': 15*60}  # Betty cannot meet before 15:00 on Tuesday and Thursday\n    scott_avoid_day = 'Wednesday'  # Scott would like to avoid Wednesday\n\n    # Iterate through each day to find a suitable time\n    for day in days:\n        if day in betty_no_days:\n            continue\n        if day == scott_avoid_day:\n            continue\n\n        # Get busy times for both participants on this day\n        busy_times = betty_busy[day] + scott_busy[day]\n        busy_times.sort()  # Sort by start time\n\n        # Determine the earliest start time based on Betty's constraints\n        day_start = work_start\n        if day in betty_no_before:\n            day_start = max(day_start, betty_no_before[day])\n\n        # Initialize the previous end time as the start of the work day\n        prev_end = day_start\n\n        # Check for gaps between busy times\n        for busy_start, busy_end in busy_times:\n            if busy_start > prev_end:\n                # Found a gap, check if it's long enough\n                gap_start = prev_end\n                gap_end = busy_start\n                if gap_end - gap_start >= meeting_duration:\n                    # Found a suitable time\n                    start_time = gap_start\n                    end_time = start_time + meeting_duration\n                    # Format the time as HH:MM\n                    start_str = f\"{start_time // 60:02d}:{start_time % 60:02d}\"\n                    end_str = f\"{end_time // 60:02d}:{end_time % 60:02d}\"\n                    print(f\"{day}: {start_str}:{end_str}\")\n                    return\n            # Update prev_end to the end of the current busy period\n            prev_end = max(prev_end, busy_end)\n\n        # Check the gap after the last busy period until the end of the work day\n        if work_end - prev_end >= meeting_duration:\n            start_time = prev_end\n            end_time = start_time + meeting_duration\n            start_str = f\"{start_time // 60:02d}:{start_time % 60:02d}\"\n            end_str = f\"{end_time // 60:02d}:{end_time % 60:02d}\"\n            print(f\"{day}: {start_str}:{end_str}\")\n            return\n\n    print(\"No suitable time found.\")\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_867"
        },
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "9:00",
                "end_time": "10:00"
            },
            "expected_time": {
                "day": "Tuesday",
                "start_time": "9:00",
                "end_time": "10:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration, days):\n    for day in days:\n        # Initialize available time for the day\n        available_start = work_hours_start\n        available_end = work_hours_end\n        \n        # Collect all busy times for the day for all participants\n        busy_times = []\n        for participant in participants_schedules:\n            if day in participant:\n                busy_times.extend(participant[day])\n        \n        # Sort busy times by start time\n        busy_times.sort()\n        \n        # Find available slots\n        current_time = available_start\n        for busy_start, busy_end in busy_times:\n            if busy_start > current_time:\n                # Check if the slot is long enough\n                if busy_start - current_time >= meeting_duration:\n                    return day, (current_time, current_time + meeting_duration)\n            # Update current_time to the end of the busy slot\n            if busy_end > current_time:\n                current_time = busy_end\n        \n        # Check the remaining time after the last busy slot\n        if available_end - current_time >= meeting_duration:\n            return day, (current_time, current_time + meeting_duration)\n    \n    return None, None\n\ndef main():\n    # Define participants' schedules\n    patricia_schedule = {\n        'Monday': [(10.0, 10.5), (11.5, 12.0), (13.0, 13.5), (14.5, 15.5), (16.0, 16.5)],\n        'Tuesday': [(10.0, 10.5), (11.0, 12.0), (14.0, 16.0), (16.5, 17.0)]\n    }\n    \n    jesse_schedule = {\n        'Monday': [(9.0, 17.0)],\n        'Tuesday': [(11.0, 11.5), (12.0, 12.5), (13.0, 14.0), (14.5, 15.0), (15.5, 17.0)]\n    }\n    \n    participants_schedules = [patricia_schedule, jesse_schedule]\n    \n    # Define meeting constraints\n    work_hours_start = 9.0\n    work_hours_end = 17.0\n    meeting_duration = 1.0\n    days = ['Monday', 'Tuesday']\n    \n    # Find meeting time\n    day, time_range = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration, days)\n    \n    if day and time_range:\n        start_hour = int(time_range[0])\n        start_min = int((time_range[0] - start_hour) * 60)\n        end_hour = int(time_range[1])\n        end_min = int((time_range[1] - end_hour) * 60)\n        \n        print(f\"{day}, {{{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}}}\")\n    else:\n        print(\"No suitable time found.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
            "count": "calendar_scheduling_example_626"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "9:30",
                "end_time": "10:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "9:30",
                "end_time": "10:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Generate all possible slots within work hours\n    slots = []\n    current = work_start\n    while current + meeting_duration <= work_end:\n        slots.append((current, current + meeting_duration))\n        current += 1  # Check every minute\n    \n    # Check each slot against all participants' busy times\n    for slot_start, slot_end in slots:\n        slot_ok = True\n        for busy_times in participants_busy_times:\n            for busy_start, busy_end in busy_times:\n                busy_start_min = time_to_minutes(busy_start)\n                busy_end_min = time_to_minutes(busy_end)\n                # Check if slot overlaps with any busy time\n                if not (slot_end <= busy_start_min or slot_start >= busy_end_min):\n                    slot_ok = False\n                    break\n            if not slot_ok:\n                break\n        if slot_ok:\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return (minutes_to_time(slot_start), minutes_to_time(slot_end))\n    return None\n\n# Define work hours and meeting duration\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 60  # minutes\n\n# Participants' busy times in HH:MM format\nparticipants_busy_times = [\n    [(\"11:00\", \"12:30\"), (\"13:30\", \"14:30\"), (\"16:30\", \"17:00\")],  # Joshua\n    [],  # Kevin\n    [],  # Gerald\n    [(\"9:00\", \"9:30\"), (\"10:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"13:30\", \"14:00\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:00\")],  # Jerry\n    [(\"9:00\", \"9:30\"), (\"10:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:30\")],  # Jesse\n    [(\"10:30\", \"12:30\"), (\"13:30\", \"14:00\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:00\"), (\"16:30\", \"17:00\")],  # Kenneth\n]\n\n# Find a meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration)\n\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{start}:{end}\")\n    print(\"Monday\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_479"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "10:00",
                "end_time": "10:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "10:00",
                "end_time": "10:30"
            },
            "has_error": false,
            "raw_model_response": "```python\nfrom typing import List, Dict, Tuple\n\ndef find_earliest_meeting_time(\n    participants: Dict[str, Dict[str, List[Tuple[str, str]]]],\n    days: List[str],\n    work_hours: Tuple[str, str],\n    duration_minutes: int\n) -> Tuple[str, str]:\n    # Convert time string \"HH:MM\" to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str: str) -> int:\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to \"HH:MM\"\n    def minutes_to_time(minutes: int) -> str:\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = map(time_to_minutes, work_hours)\n    duration = duration_minutes\n    \n    for day in days:\n        # Collect all busy intervals for the day for all participants\n        busy_intervals = []\n        for person, schedule in participants.items():\n            if day in schedule:\n                for start, end in schedule[day]:\n                    start_min = time_to_minutes(start)\n                    end_min = time_to_minutes(end)\n                    busy_intervals.append((start_min, end_min))\n        \n        # Sort all busy intervals by start time\n        busy_intervals.sort()\n        \n        # Find available slots between work hours considering all busy intervals\n        available_slots = []\n        prev_end = work_start\n        \n        for start, end in busy_intervals:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n        \n        # Check each available slot for sufficient duration\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + duration\n                return day, f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return None, None\n\n# Define the participants' schedules\nparticipants = {\n    \"Mary\": {\n        \"Tuesday\": [(\"10:00\", \"10:30\"), (\"15:30\", \"16:00\")],\n        \"Wednesday\": [(\"9:30\", \"10:00\"), (\"15:00\", \"15:30\")],\n        \"Thursday\": [(\"9:00\", \"10:00\"), (\"10:30\", \"11:30\")],\n    },\n    \"Alexis\": {\n        \"Monday\": [(\"9:00\", \"10:00\"), (\"10:30\", \"12:00\"), (\"12:30\", \"16:30\")],\n        \"Tuesday\": [(\"9:00\", \"10:00\"), (\"10:30\", \"11:30\"), (\"12:00\", \"15:30\"), (\"16:00\", \"17:00\")],\n        \"Wednesday\": [(\"9:00\", \"11:00\"), (\"11:30\", \"17:00\")],\n        \"Thursday\": [(\"10:00\", \"12:00\"), (\"14:00\", \"14:30\"), (\"15:30\", \"16:00\"), (\"16:30\", \"17:00\")],\n    }\n}\n\n# Define the days to consider\ndays = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\"]\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration = 30  # minutes\n\n# Find the earliest meeting time\nday, time_range = find_earliest_meeting_time(participants, days, work_hours, duration)\n\n# Output the result\nprint(f\"{day}: {time_range}\")\n```",
            "count": "calendar_scheduling_example_812"
        },
        {
            "final_program_time": {
                "day": "Friday",
                "start_time": "11:00",
                "end_time": "11:30"
            },
            "expected_time": {
                "day": "Friday",
                "start_time": "11:00",
                "end_time": "11:30"
            },
            "has_error": false,
            "raw_model_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time():\n    # Define work hours\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    meeting_duration = timedelta(minutes=30)\n    \n    # Days to consider\n    days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"]\n    \n    # Eugene's busy slots\n    eugene_busy = {\n        \"Monday\": [\n            (\"11:00\", \"12:00\"), (\"13:30\", \"14:00\"), (\"14:30\", \"15:00\"), (\"16:00\", \"16:30\")\n        ],\n        \"Wednesday\": [\n            (\"09:00\", \"09:30\"), (\"11:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:30\", \"15:00\")\n        ],\n        \"Thursday\": [\n            (\"09:30\", \"10:00\"), (\"11:00\", \"12:30\")\n        ],\n        \"Friday\": [\n            (\"10:30\", \"11:00\"), (\"12:00\", \"12:30\"), (\"13:00\", \"13:30\")\n        ]\n    }\n    \n    # Eric's busy slots\n    eric_busy = {\n        \"Monday\": [(\"09:00\", \"17:00\")],\n        \"Tuesday\": [(\"09:00\", \"17:00\")],\n        \"Wednesday\": [\n            (\"09:00\", \"11:30\"), (\"12:00\", \"14:00\"), (\"14:30\", \"16:30\")\n        ],\n        \"Thursday\": [(\"09:00\", \"17:00\")],\n        \"Friday\": [\n            (\"09:00\", \"11:00\"), (\"11:30\", \"17:00\")\n        ]\n    }\n    \n    # Iterate through each day (excluding Wednesday first due to Eric's preference)\n    preferred_days = [day for day in days if day != \"Wednesday\"] + [\"Wednesday\"]\n    \n    for day in preferred_days:\n        # Collect all busy slots for both participants\n        busy_slots = []\n        \n        # Add Eugene's busy slots\n        for slot in eugene_busy.get(day, []):\n            start = datetime.strptime(slot[0], \"%H:%M\")\n            end = datetime.strptime(slot[1], \"%H:%M\")\n            busy_slots.append((start, end))\n        \n        # Add Eric's busy slots\n        for slot in eric_busy.get(day, []):\n            start = datetime.strptime(slot[0], \"%H:%M\")\n            end = datetime.strptime(slot[1], \"%H:%M\")\n            busy_slots.append((start, end))\n        \n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Find available slots\n        available_slots = []\n        prev_end = work_start\n        \n        for slot in busy_slots:\n            slot_start, slot_end = slot\n            if slot_start > prev_end:\n                available_slots.append((prev_end, slot_start))\n            prev_end = max(prev_end, slot_end)\n        \n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n        \n        # Check each available slot for sufficient duration\n        for slot in available_slots:\n            slot_start, slot_end = slot\n            if slot_end - slot_start >= meeting_duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                # Format the output\n                start_str = meeting_start.strftime(\"%H:%M\")\n                end_str = meeting_end.strftime(\"%H:%M\")\n                print(f\"{day}: {start_str}:{end_str}\")\n                return\n    \n    print(\"No suitable time found.\")\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_938"
        },
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "14:00",
                "end_time": "15:00"
            },
            "expected_time": {
                "day": "Tuesday",
                "start_time": "14:00",
                "end_time": "15:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours and days\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday']\n    \n    # Define busy slots for each person in minutes since midnight\n    # Format: (day_index, start_min, end_min)\n    russell_busy = [\n        (0, 10 * 60 + 30, 11 * 60),  # Monday 10:30-11:00\n        (1, 13 * 60, 13 * 60 + 30)    # Tuesday 13:00-13:30\n    ]\n    \n    alexander_busy = [\n        (0, 9 * 60, 11 * 60 + 30),    # Monday 9:00-11:30\n        (0, 12 * 60, 14 * 60 + 30),   # Monday 12:00-14:30\n        (0, 15 * 60, 17 * 60),        # Monday 15:00-17:00\n        (1, 9 * 60, 10 * 60),         # Tuesday 9:00-10:00\n        (1, 13 * 60, 14 * 60),        # Tuesday 13:00-14:00\n        (1, 15 * 60, 15 * 60 + 30),  # Tuesday 15:00-15:30\n        (1, 16 * 60, 16 * 60 + 30)    # Tuesday 16:00-16:30\n    ]\n    \n    meeting_duration = 60  # 1 hour in minutes\n    \n    # Check each day for available slots\n    for day_idx in range(2):\n        day = days[day_idx]\n        \n        # Collect all busy slots for both people on this day\n        busy_slots = []\n        \n        # Add Russell's busy slots for the day\n        for slot in russell_busy:\n            if slot[0] == day_idx:\n                busy_slots.append((slot[1], slot[2]))\n        \n        # Add Alexander's busy slots for the day\n        for slot in alexander_busy:\n            if slot[0] == day_idx:\n                busy_slots.append((slot[1], slot[2]))\n        \n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Find free slots between work hours\n        prev_end = work_start\n        free_slots = []\n        \n        for start, end in busy_slots:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy slot\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            available_start = slot_start\n            available_end = slot_end\n            \n            # Ensure the slot is at least meeting_duration long\n            if available_end - available_start >= meeting_duration:\n                # Apply Russell's preference: not Tuesday before 13:30\n                if day == 'Tuesday' and available_start < 13 * 60 + 30:\n                    continue\n                \n                # Found a suitable slot\n                start_hour = available_start // 60\n                start_min = available_start % 60\n                end_hour = (available_start + meeting_duration) // 60\n                end_min = (available_start + meeting_duration) % 60\n                \n                # Format the time as HH:MM:HH:MM\n                time_str = f\"{start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\"\n                return day, time_str\n    \n    return None, None\n\nday, time = find_meeting_time()\nprint(f\"{day}: {time}\")\n```",
            "count": "calendar_scheduling_example_678"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "16:00",
                "end_time": "16:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "16:00",
                "end_time": "16:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define each person's busy times in minutes (start, end)\n    adam_busy = [(14 * 60, 15 * 60)]\n    john_busy = [(13 * 60, 13 * 60 + 30),\n                 (14 * 60, 14 * 60 + 30),\n                 (15 * 60 + 30, 16 * 60),\n                 (16 * 60 + 30, 17 * 60)]\n    stephanie_busy = [(9 * 60 + 30, 10 * 60),\n                      (10 * 60 + 30, 11 * 60),\n                      (11 * 60 + 30, 16 * 60),\n                      (16 * 60 + 30, 17 * 60)]\n    anna_busy = [(9 * 60 + 30, 10 * 60),\n                 (12 * 60, 12 * 60 + 30),\n                 (13 * 60, 15 * 60 + 30),\n                 (16 * 60 + 30, 17 * 60)]\n    \n    # Anna's preference: not before 14:30\n    anna_preference_start = 14 * 60 + 30\n\n    # Combine all busy times\n    all_busy = adam_busy + john_busy + stephanie_busy + anna_busy\n\n    # Generate free slots by finding gaps between busy times\n    all_busy.sort()  # Sort by start time\n    free_slots = []\n    previous_end = work_start\n\n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    \n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Filter free slots that meet duration and Anna's preference\n    possible_slots = []\n    for slot_start, slot_end in free_slots:\n        if slot_start >= anna_preference_start and (slot_end - slot_start) >= meeting_duration:\n            possible_slots.append((slot_start, slot_end))\n\n    # Select the earliest possible slot\n    if possible_slots:\n        meeting_start = possible_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n        # Convert back to HH:MM format\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        print(f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\")\n        print(\"Monday\")\n    else:\n        print(\"No suitable time found.\")\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_116"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "10:30",
                "end_time": "11:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "10:30",
                "end_time": "11:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration, day):\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n\n    # Collect all busy times for all participants\n    all_busy = []\n    for busy_times in participants_busy_times:\n        for start, end in busy_times:\n            all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n\n    # Sort busy times by start time\n    all_busy.sort()\n\n    # Find free slots by checking gaps between busy times and work hours\n    free_slots = []\n    prev_end = work_start\n\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n\n    # Check each free slot for availability\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + meeting_duration\n            return (minutes_to_time(meeting_start), minutes_to_time(meeting_end))\n\n    return None\n\n# Define the participants' busy times\nandrew_busy = []\ngrace_busy = []\nsamuel_busy = [\n    (\"09:00\", \"10:30\"),\n    (\"11:30\", \"12:00\"),\n    (\"13:00\", \"13:30\"),\n    (\"14:00\", \"16:00\"),\n    (\"16:30\", \"17:00\")\n]\n\nparticipants_busy_times = [andrew_busy, grace_busy, samuel_busy]\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = 30  # minutes\nday = \"Monday\"\n\n# Find the earliest meeting time\nmeeting_time = find_meeting_time(participants_busy_times, work_hours_start, work_hours_end, meeting_duration, day)\n\nif meeting_time:\n    start_time, end_time = meeting_time\n    print(f\"{start_time}:{end_time}:{day}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_45"
        },
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "10:00",
                "end_time": "10:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "16:00",
                "end_time": "16:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define constraints and busy times for each participant\n    ryan_busy = {\n        'Monday': [(9*60 + 30, 10*60), (11*60, 12*60), (13*60, 13*60 + 30), (15*60 + 30, 16*60)],\n        'Tuesday': [(11*60 + 30, 12*60 + 30), (15*60 + 30, 16*60)],\n        'Wednesday': [(12*60, 13*60), (15*60 + 30, 16*60), (16*60 + 30, 17*60)]\n    }\n    \n    adam_busy = {\n        'Monday': [(9*60, 10*60 + 30), (11*60, 13*60 + 30), (14*60, 16*60), (16*60 + 30, 17*60)],\n        'Tuesday': [(9*60, 10*60), (10*60 + 30, 15*60 + 30), (16*60, 17*60)],\n        'Wednesday': [(9*60, 9*60 + 30), (10*60, 11*60), (11*60 + 30, 14*60 + 30), (15*60, 15*60 + 30), (16*60, 16*60 + 30)]\n    }\n    \n    # Apply constraints: Ryan cannot meet on Wednesday, Adam avoids Monday before 14:30\n    days_to_check = ['Monday', 'Tuesday']  # Wednesday is excluded due to Ryan's constraint\n    \n    meeting_duration = 30  # minutes\n    \n    for day in days_to_check:\n        # Combine and sort busy times for both participants\n        combined_busy = ryan_busy[day] + adam_busy[day]\n        combined_busy.sort()\n        \n        # Merge overlapping or adjacent busy intervals\n        merged_busy = []\n        for start, end in combined_busy:\n            if not merged_busy:\n                merged_busy.append((start, end))\n            else:\n                last_start, last_end = merged_busy[-1]\n                if start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged_busy[-1] = (new_start, new_end)\n                else:\n                    merged_busy.append((start, end))\n        \n        # Check available slots\n        prev_end = work_start\n        for start, end in merged_busy:\n            if start > prev_end:\n                # Found a potential slot\n                slot_start = prev_end\n                slot_end = start\n                if slot_end - slot_start >= meeting_duration:\n                    # Check Adam's Monday before 14:30 constraint\n                    if day == 'Monday' and slot_start < 14*60 + 30:\n                        continue  # Skip this slot\n                    # Found a valid slot\n                    meeting_start = slot_start\n                    meeting_end = meeting_start + meeting_duration\n                    # Format the time as HH:MM:HH:MM\n                    start_hh = meeting_start // 60\n                    start_mm = meeting_start % 60\n                    end_hh = meeting_end // 60\n                    end_mm = meeting_end % 60\n                    time_str = f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n                    return day, time_str\n            prev_end = max(prev_end, end)\n        \n        # Check after the last busy interval\n        if work_end - prev_end >= meeting_duration:\n            # Check Adam's Monday before 14:30 constraint\n            if day == 'Monday' and prev_end < 14*60 + 30:\n                continue  # Skip this slot\n            meeting_start = prev_end\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            time_str = f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n            return day, time_str\n    \n    return None, None\n\nday, time_slot = find_meeting_time()\nprint(f\"{day}: {time_slot}\")\n```",
            "count": "calendar_scheduling_example_707"
        },
        {
            "final_program_time": {
                "day": null,
                "start_time": null,
                "end_time": null
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "16:00",
                "end_time": "16:30"
            },
            "has_error": true,
            "raw_model_response": "```python\n'''\nThis script finds a suitable 30-minute meeting time for all participants on Monday between 9:00 and 17:00,\ngiven their individual busy schedules.\n'''",
            "count": "calendar_scheduling_example_457"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "9:00",
                "end_time": "10:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "9:00",
                "end_time": "10:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_earliest_meeting_time(participant_busy_times, work_hours, meeting_duration, days):\n    # Convert work hours to minutes since midnight for easier calculation\n    work_start = int(work_hours[0].split(':')[0]) * 60 + int(work_hours[0].split(':')[1])\n    work_end = int(work_hours[1].split(':')[0]) * 60 + int(work_hours[1].split(':')[1])\n    \n    for day in days:\n        # Get busy slots for the current day\n        busy_slots = participant_busy_times.get(day, [])\n        \n        # Convert busy slots to minutes since midnight and sort them\n        busy_minutes = []\n        for slot in busy_slots:\n            start = slot[0].split(':')\n            end = slot[1].split(':')\n            start_min = int(start[0]) * 60 + int(start[1])\n            end_min = int(end[0]) * 60 + int(end[1])\n            busy_minutes.append((start_min, end_min))\n        \n        # Sort busy slots by start time\n        busy_minutes.sort()\n        \n        # Check the time before the first busy slot\n        if len(busy_minutes) > 0:\n            first_busy_start = busy_minutes[0][0]\n            available_start = work_start\n            available_end = first_busy_start\n            if available_end - available_start >= meeting_duration:\n                return day, (available_start, available_start + meeting_duration)\n        \n        # Check the time between busy slots\n        for i in range(len(busy_minutes) - 1):\n            current_end = busy_minutes[i][1]\n            next_start = busy_minutes[i + 1][0]\n            if next_start - current_end >= meeting_duration:\n                return day, (current_end, current_end + meeting_duration)\n        \n        # Check the time after the last busy slot\n        if len(busy_minutes) > 0:\n            last_busy_end = busy_minutes[-1][1]\n            available_start = last_busy_end\n            available_end = work_end\n            if available_end - available_start >= meeting_duration:\n                return day, (available_start, available_start + meeting_duration)\n        else:\n            # No busy slots, the entire work day is available\n            return day, (work_start, work_start + meeting_duration)\n    \n    return None, None\n\ndef format_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Define the problem constraints\nwork_hours = ('9:00', '17:00')\nmeeting_duration = 60  # minutes\ndays = ['Monday', 'Tuesday', 'Wednesday']\n\n# Roy's busy times (Patrick is free all the time)\nroy_busy_times = {\n    'Monday': [('10:00', '11:30'), ('12:00', '13:00'), ('14:00', '14:30'), ('15:00', '17:00')],\n    'Tuesday': [('10:30', '11:30'), ('12:00', '14:30'), ('15:00', '15:30'), ('16:00', '17:00')],\n    'Wednesday': [('9:30', '11:30'), ('12:30', '14:00'), ('14:30', '15:30'), ('16:30', '17:00')]\n}\n\n# Find the earliest meeting time\nday, (start_min, end_min) = find_earliest_meeting_time(roy_busy_times, work_hours, meeting_duration, days)\n\n# Format the output\nstart_time = format_time(start_min)\nend_time = format_time(end_min)\nprint(f\"{day}:{start_time}:{end_time}\")\n```",
            "count": "calendar_scheduling_example_773"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "12:00",
                "end_time": "12:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "12:00",
                "end_time": "12:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours, preferences):\n    # Parse work hours\n    work_start, work_end = work_hours.split(' to ')\n    work_start = int(work_start.split(':')[0]) * 60 + int(work_start.split(':')[1])\n    work_end = int(work_end.split(':')[0]) * 60 + int(work_end.split(':')[1])\n    \n    # Initialize available slots for each participant\n    available_slots = {}\n    for participant in participants_schedules:\n        # Start with the entire work day as available\n        available = [(work_start, work_end)]\n        # Subtract blocked times\n        for block in participants_schedules[participant]:\n            start, end = block.split(' to ')\n            start = int(start.split(':')[0]) * 60 + int(start.split(':')[1])\n            end = int(end.split(':')[0]) * 60 + int(end.split(':')[1])\n            new_available = []\n            for slot in available:\n                if slot[1] <= start or slot[0] >= end:\n                    new_available.append(slot)\n                else:\n                    if slot[0] < start:\n                        new_available.append((slot[0], start))\n                    if slot[1] > end:\n                        new_available.append((end, slot[1]))\n            available = new_available\n        available_slots[participant] = available\n    \n    # Apply Helen's preference (no meetings after 13:30)\n    if 'Helen' in preferences:\n        pref_start, pref_end = preferences['Helen'].split(' to ')\n        pref_end = int(pref_end.split(':')[0]) * 60 + int(pref_end.split(':')[1])\n        new_available = []\n        for slot in available_slots['Helen']:\n            if slot[0] >= pref_end:\n                continue\n            if slot[1] > pref_end:\n                new_available.append((slot[0], pref_end))\n            else:\n                new_available.append(slot)\n        available_slots['Helen'] = new_available\n    \n    # Find overlapping slots\n    common_slots = []\n    # Start with Helen's slots (as she has the most constraints)\n    for helen_slot in available_slots['Helen']:\n        # Check if Margaret and Donna are available during this slot\n        for margaret_slot in available_slots['Margaret']:\n            if margaret_slot[0] >= helen_slot[1] or margaret_slot[1] <= helen_slot[0]:\n                continue\n            margaret_overlap = (max(helen_slot[0], margaret_slot[0]), min(helen_slot[1], margaret_slot[1]))\n            for donna_slot in available_slots['Donna']:\n                if donna_slot[0] >= margaret_overlap[1] or donna_slot[1] <= margaret_overlap[0]:\n                    continue\n                donna_overlap = (max(margaret_overlap[0], donna_slot[0]), min(margaret_overlap[1], donna_slot[1]))\n                if donna_overlap[1] - donna_overlap[0] >= duration:\n                    common_slots.append(donna_overlap)\n    \n    # Select the first available slot that fits the duration\n    for slot in common_slots:\n        if slot[1] - slot[0] >= duration:\n            # Convert back to HH:MM format\n            start_hh = slot[0] // 60\n            start_mm = slot[0] % 60\n            end_hh = (slot[0] + duration) // 60\n            end_mm = (slot[0] + duration) % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return None\n\n# Input data\nparticipants_schedules = {\n    'Margaret': ['9:00 to 10:00', '10:30 to 11:00', '11:30 to 12:00', '13:00 to 13:30', '15:00 to 15:30'],\n    'Donna': ['14:30 to 15:00', '16:00 to 16:30'],\n    'Helen': ['9:00 to 9:30', '10:00 to 11:30', '13:00 to 14:00', '14:30 to 15:00', '15:30 to 17:00']\n}\nduration = 30  # minutes\nwork_hours = '9:00 to 17:00'\npreferences = {'Helen': '9:00 to 13:30'}\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours, preferences)\nprint(f\"Monday:{meeting_time}\")\n```",
            "count": "calendar_scheduling_example_17"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "15:30",
                "end_time": "16:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "15:30",
                "end_time": "16:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Define participants' busy times in minutes since 9:00\n    # Each block is (start, end)\n    shirley_busy = [(10*60 + 30, 11*60), (12*60, 12*60 + 30)]\n    jacob_busy = [(9*60, 9*60 + 30), (10*60, 10*60 + 30), (11*60, 11*60 + 30),\n                  (12*60 + 30, 13*60 + 30), (14*60 + 30, 15*60)]\n    stephen_busy = [(11*60 + 30, 12*60), (12*60 + 30, 13*60)]\n    margaret_busy = [(9*60, 9*60 + 30), (10*60 + 30, 12*60 + 30),\n                     (13*60, 13*60 + 30), (15*60, 15*60 + 30), (16*60 + 30, 17*60)]\n    mason_busy = [(9*60, 10*60), (10*60 + 30, 11*60), (11*60 + 30, 12*60 + 30),\n                  (13*60, 13*60 + 30), (14*60, 14*60 + 30), (16*60 + 30, 17*60)]\n\n    # Margaret's preference: not before 14:30\n    margaret_pref_start = 14 * 60 + 30\n\n    # Combine all busy times\n    all_busy = []\n    for busy in [shirley_busy, jacob_busy, stephen_busy, margaret_busy, mason_busy]:\n        all_busy.extend(busy)\n\n    # Generate free slots by finding gaps between busy times\n    all_busy.sort()\n    free_slots = []\n    prev_end = work_start\n\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n\n    # Check each free slot for availability and Margaret's preference\n    meeting_duration = 30\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            actual_start = max(slot_start, margaret_pref_start)\n            if actual_start + meeting_duration <= slot_end:\n                # Convert minutes back to HH:MM format\n                start_hh = actual_start // 60\n                start_mm = actual_start % 60\n                end_hh = (actual_start + meeting_duration) // 60\n                end_mm = (actual_start + meeting_duration) % 60\n                return f\"Monday {start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n\n    return \"No suitable time found\"\n\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_206"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "12:00",
                "end_time": "13:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "12:00",
                "end_time": "13:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm - work_hours_start * 60\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        total_hh = (minutes + work_hours_start * 60) // 60\n        total_mm = (minutes + work_hours_start * 60) % 60\n        return f\"{total_hh:02d}:{total_mm:02d}\"\n\n    # Initialize the busy slots for all participants\n    busy_slots = []\n    for schedule in participants_schedules:\n        person_busy = []\n        for busy_range in schedule:\n            start, end = busy_range\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            person_busy.append((start_min, end_min))\n        busy_slots.append(person_busy)\n\n    # Find all possible free slots for each person\n    free_slots_per_person = []\n    for person_busy in busy_slots:\n        person_free = []\n        # Start from work hours start (0 in minutes since we subtracted work_hours_start)\n        prev_end = 0\n        # Sort busy slots by start time\n        sorted_busy = sorted(person_busy, key=lambda x: x[0])\n        for busy_start, busy_end in sorted_busy:\n            if busy_start > prev_end:\n                person_free.append((prev_end, busy_start))\n            prev_end = max(prev_end, busy_end)\n        # Check the slot after last busy slot until work hours end\n        work_end_min = (work_hours_end - work_hours_start) * 60\n        if prev_end < work_end_min:\n            person_free.append((prev_end, work_end_min))\n        free_slots_per_person.append(person_free)\n\n    # Find intersection of all free slots\n    common_free_slots = free_slots_per_person[0]\n    for person_free in free_slots_per_person[1:]:\n        new_common_free = []\n        i = j = 0\n        while i < len(common_free_slots) and j < len(person_free):\n            slot1_start, slot1_end = common_free_slots[i]\n            slot2_start, slot2_end = person_free[j]\n            # Find the overlap\n            overlap_start = max(slot1_start, slot2_start)\n            overlap_end = min(slot1_end, slot2_end)\n            if overlap_start < overlap_end:\n                new_common_free.append((overlap_start, overlap_end))\n            # Move the pointer which ends first\n            if slot1_end < slot2_end:\n                i += 1\n            else:\n                j += 1\n        common_free_slots = new_common_free\n\n    # Find the first slot that can fit the duration\n    duration_min = duration * 60\n    for slot_start, slot_end in common_free_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = minutes_to_time(slot_start)\n            meeting_end = minutes_to_time(slot_start + duration_min)\n            return meeting_start, meeting_end\n\n    return None, None\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [(\"10:00\", \"10:30\"), (\"16:00\", \"16:30\")],  # Stephanie\n    [(\"10:00\", \"10:30\"), (\"11:30\", \"12:00\"), (\"13:30\", \"14:00\"), (\"16:30\", \"17:00\")],  # Cheryl\n    [(\"09:30\", \"10:00\"), (\"10:30\", \"11:30\"), (\"13:30\", \"14:00\"), (\"14:30\", \"15:00\"), (\"15:30\", \"17:00\")],  # Bradley\n    [(\"09:00\", \"12:00\"), (\"13:00\", \"13:30\"), (\"14:30\", \"17:00\")],  # Steven\n]\n\n# Define meeting parameters\nmeeting_duration = 1  # in hours\nwork_hours_start = 9\nwork_hours_end = 17\nday_of_week = \"Monday\"\n\n# Find the meeting time\nmeeting_start, meeting_end = find_meeting_time(participants_schedules, meeting_duration, work_hours_start, work_hours_end)\n\n# Output the result\nif meeting_start and meeting_end:\n    print(f\"{meeting_start}:{meeting_end}\")\n    print(day_of_week)\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_114"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "12:00",
                "end_time": "12:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "12:00",
                "end_time": "12:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration_minutes, day):\n    # Convert all time slots to minutes since start of the day\n    work_start = work_hours[0]\n    work_end = work_hours[1]\n    \n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy)\n            busy_intervals.append((start, end))\n    \n    # Add boundaries as busy intervals to avoid scheduling outside work hours\n    busy_intervals.append((work_start_min - 60, work_start_min))  # before work starts\n    busy_intervals.append((work_end_min, work_end_min + 60))      # after work ends\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots between merged busy intervals\n    available_slots = []\n    prev_end = work_start_min\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    # Check for available slots after last busy interval\n    if prev_end < work_end_min:\n        available_slots.append((prev_end, work_end_min))\n    \n    # Find the first available slot that can fit the meeting\n    duration = duration_minutes\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            start_time = minutes_to_time(meeting_start)\n            end_time = minutes_to_time(meeting_end)\n            return f\"{start_time}:{end_time}\"\n    \n    return None\n\n# Define the participants' schedules\nmichael_schedule = [\n    (\"09:30\", \"10:30\"),\n    (\"15:00\", \"15:30\"),\n    (\"16:00\", \"16:30\"),\n]\n\neric_schedule = []\n\narthur_schedule = [\n    (\"09:00\", \"12:00\"),\n    (\"13:00\", \"15:00\"),\n    (\"15:30\", \"16:00\"),\n    (\"16:30\", \"17:00\"),\n]\n\nparticipants_schedules = [michael_schedule, eric_schedule, arthur_schedule]\nwork_hours = (\"09:00\", \"17:00\")\nduration_minutes = 30\nday = \"Monday\"\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration_minutes, day)\n\n# Output the result\nprint(f\"{day}:{meeting_time}\")\n```",
            "count": "calendar_scheduling_example_82"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "11:00",
                "end_time": "11:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "11:00",
                "end_time": "11:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Define participants' busy times in minutes since midnight\n    busy_times = {\n        'Christine': [(570, 630), (720, 750), (780, 810), (870, 900), (960, 990)],\n        'Bobby': [(720, 750), (870, 900)],\n        'Elizabeth': [(540, 570), (690, 780), (810, 840), (900, 930), (960, 1020)],\n        'Tyler': [(540, 660), (720, 750), (780, 810), (930, 960), (990, 1020)],\n        'Edward': [(540, 570), (600, 660), (690, 840), (870, 930), (960, 1020)],\n    }\n    \n    # Janice's preference: not after 13:00 (780 minutes)\n    janice_pref_end = 13 * 60\n    \n    # Collect all busy times and Janice's preference\n    all_busy = []\n    for person in busy_times:\n        all_busy.extend(busy_times[person])\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy times\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end)\n            else:\n                merged_busy.append((start, end))\n    \n    # Add Janice's preference as a \"busy\" time after 13:00\n    merged_busy.append((janice_pref_end, work_end))\n    merged_busy.sort()\n    \n    # Find the earliest available 30-minute slot\n    prev_end = work_start\n    meeting_duration = 30\n    \n    for start, end in merged_busy:\n        if start - prev_end >= meeting_duration:\n            # Found a slot\n            meeting_start = prev_end\n            meeting_end = meeting_start + meeting_duration\n            # Format the time as HH:MM:HH:MM\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            time_str = f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n            return time_str, \"Monday\"\n        prev_end = max(prev_end, end)\n    \n    return None, None\n\ntime_range, day = find_meeting_time()\nprint(f\"{{{time_range}}} {day}\")\n```",
            "count": "calendar_scheduling_example_304"
        },
        {
            "final_program_time": {
                "day": null,
                "start_time": null,
                "end_time": null
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "13:30",
                "end_time": "14:00"
            },
            "has_error": true,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, meeting_duration, work_start, work_end, day):\n    # Convert time strings to minutes since 9:00 (work_start)\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m - work_start_min\n\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Initialize a list to track busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = busy\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            busy_intervals.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots between work hours and busy intervals\n    available_slots = []\n    prev_end = work_start_min\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end_min:\n        available_slots.append((prev_end, work_end_min))\n    \n    # Check each available slot for sufficient duration\n    meeting_duration_min = meeting_duration * 60\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration_min:\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                total_min = work_start_min + minutes\n                h = total_min // 60\n                m = total_min % 60\n                return f\"{h:02d}:{m:02d}\"\n            \n            meeting_start = minutes_to_time(slot_start)\n            meeting_end = minutes_to_time(slot_start + meeting_duration_min)\n            return f\"{meeting_start}:{meeting_end}\", day\n    \n    return None, day\n\n# Define participants' schedules\nparticipants_schedules = [\n    [(\"13:00\", \"13:30\"), (\"16:00\", \"16:30\")],  # Judy\n    [(\"10:00\", \"10:30\"), (\"12:00\", \"13:00\"), (\"14:00\", \"14:30\")],  # Olivia\n    [],  # Eric\n    [(\"10:00\", \"10:30\"), (\"15:00\", \"15:30\")],  # Jacqueline\n    [(\"09:00\", \"10:00\"), (\"10:30\", \"12:00\"), (\"13:00\", \"13:30\"), (\"14:30\", \"15:00\"), (\"15:30\", \"17:00\")],  # Laura\n    [(\"09:00\", \"10:00\"), (\"11:00\", \"11:30\"), (\"12:30\", \"13:00\"), (\"14:00\", \"14:30\"), (\"15:30\", \"17:00\")],  # Tyler\n    [(\"09:30\", \"10:30\"), (\"11:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"13:30\"), (\"14:00\", \"14:30\"), (\"16:00\", \"17:00\")],  # Lisa\n]\n\n# Parameters\nmeeting_duration = 0.5  # 30 minutes\nwork_start = \"09:00\"\nwork_end = \"17:00\"\nday = \"Monday\"\n\n# Find meeting time\ntime_range, day = find_meeting_time(participants_schedules, meeting_duration, work_start, work_end, day)\nprint(f\"{time_range} {day}\")\n```",
            "count": "calendar_scheduling_example_429"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "11:00",
                "end_time": "11:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "13:00",
                "end_time": "13:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define participants' schedules and constraints\n    john_schedule = {\n        'Monday': [],\n        'Tuesday': [],\n        'Wednesday': []\n    }\n    \n    jennifer_schedule = {\n        'Monday': [(9*60, 11*60), (11*60 + 30, 13*60), (13*60 + 30, 14*60 + 30), (15*60, 17*60)],\n        'Tuesday': [(9*60, 11*60 + 30), (12*60, 17*60)],\n        'Wednesday': [(9*60, 11*60 + 30), (12*60, 12*60 + 30), (13*60, 14*60), (14*60 + 30, 16*60), (16*60 + 30, 17*60)]\n    }\n    \n    # John's constraints: avoid Monday after 14:30, avoid Tuesday and Wednesday\n    john_constraints = {\n        'Monday': (work_start, 14*60 + 30),\n        'Tuesday': None,  # No available time due to constraint\n        'Wednesday': None  # No available time due to constraint\n    }\n    \n    meeting_duration = 30  # minutes\n    \n    # Iterate through each day to find a suitable time\n    for day in days:\n        if john_constraints[day] is None:\n            continue  # Skip days John cannot attend\n        \n        # Get John's available time for the day\n        john_available_start, john_available_end = john_constraints[day]\n        \n        # Get Jennifer's busy times for the day\n        jennifer_busy = jennifer_schedule[day]\n        \n        # Find Jennifer's free slots within work hours\n        jennifer_free = []\n        prev_end = work_start\n        for start, end in sorted(jennifer_busy):\n            if start > prev_end:\n                jennifer_free.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            jennifer_free.append((prev_end, work_end))\n        \n        # Find overlapping slots between John and Jennifer\n        for j_start, j_end in jennifer_free:\n            # Intersect with John's available time\n            slot_start = max(j_start, john_available_start)\n            slot_end = min(j_end, john_available_end)\n            \n            if slot_end - slot_start >= meeting_duration:\n                # Found a suitable slot\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                \n                # Convert minutes back to HH:MM format\n                def format_time(minutes):\n                    hours = minutes // 60\n                    mins = minutes % 60\n                    return f\"{hours:02d}:{mins:02d}\"\n                \n                time_range = f\"{format_time(meeting_start)}:{format_time(meeting_end)}\"\n                return day, time_range\n    \n    return None, None  # No suitable time found (though problem states there is one)\n\nday, time_range = find_meeting_time()\nprint(f\"{day}: {time_range}\")\n```",
            "count": "calendar_scheduling_example_776"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "12:30",
                "end_time": "13:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "12:30",
                "end_time": "13:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, day, work_hours_start, work_hours_end, duration_minutes):\n    # Convert work hours to minutes since midnight for easier calculation\n    work_start = work_hours_start[0] * 60 + work_hours_start[1]\n    work_end = work_hours_end[0] * 60 + work_hours_end[1]\n    \n    # Initialize the free slots for all participants\n    free_slots = []\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start_h, start_m = busy[0]\n            end_h, end_m = busy[1]\n            busy_start = start_h * 60 + start_m\n            busy_end = end_h * 60 + end_m\n            busy_slots.append((busy_start, busy_end))\n        \n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Calculate free slots based on busy slots\n        free = []\n        prev_end = work_start\n        for busy_start, busy_end in busy_slots:\n            if busy_start > prev_end:\n                free.append((prev_end, busy_start))\n            prev_end = max(prev_end, busy_end)\n        if prev_end < work_end:\n            free.append((prev_end, work_end))\n        \n        free_slots.append(free)\n    \n    # Find intersection of all free slots\n    common_free = free_slots[0]\n    for free in free_slots[1:]:\n        new_common_free = []\n        i = j = 0\n        while i < len(common_free) and j < len(free):\n            start1, end1 = common_free[i]\n            start2, end2 = free[j]\n            \n            # Find the overlapping interval\n            start = max(start1, start2)\n            end = min(end1, end2)\n            \n            if start < end:\n                new_common_free.append((start, end))\n            \n            # Move the pointer which ends first\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free = new_common_free\n    \n    # Find the first slot that can fit the meeting duration\n    duration = duration_minutes\n    for start, end in common_free:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_h = meeting_start // 60\n            start_m = meeting_start % 60\n            end_h = meeting_end // 60\n            end_m = meeting_end % 60\n            return (f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\", day)\n    \n    return None\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [((13, 30), (14, 00)), ((14, 30), (15, 00))],  # Jacob\n    [((9, 30), (10, 00)), ((11, 30), (12, 00)), ((13, 00), (13, 30)), ((16, 00), (16, 30))],  # Diana\n    [((9, 30), (10, 30)), ((11, 00), (12, 30)), ((15, 30), (16, 00))],  # Adam\n    [((9, 30), (10, 00)), ((10, 30), (12, 00)), ((13, 00), (15, 30)), ((16, 00), (16, 30))],  # Angela\n    [((9, 00), (9, 30)), ((10, 30), (11, 30)), ((13, 00), (15, 00)), ((16, 30), (17, 00))],  # Dennis\n]\n\n# Define meeting parameters\nday = \"Monday\"\nwork_hours_start = (9, 00)\nwork_hours_end = (17, 00)\nduration_minutes = 30\n\n# Find the meeting time\nresult = find_meeting_time(participants_schedules, day, work_hours_start, work_hours_end, duration_minutes)\nif result:\n    time_range, day = result\n    print(f\"{time_range} {day}\")\nelse:\n    print(\"No suitable time found.\")\n'''python\ndef find_meeting_time(participants_schedules, day, work_hours_start, work_hours_end, duration_minutes):\n    # Convert work hours to minutes since midnight for easier calculation\n    work_start = work_hours_start[0] * 60 + work_hours_start[1]\n    work_end = work_hours_end[0] * 60 + work_hours_end[1]\n    \n    # Initialize the free slots for all participants\n    free_slots = []\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start_h, start_m = busy[0]\n            end_h, end_m = busy[1]\n            busy_start = start_h * 60 + start_m\n            busy_end = end_h * 60 + end_m\n            busy_slots.append((busy_start, busy_end))\n        \n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Calculate free slots based on busy slots\n        free = []\n        prev_end = work_start\n        for busy_start, busy_end in busy_slots:\n            if busy_start > prev_end:\n                free.append((prev_end, busy_start))\n            prev_end = max(prev_end, busy_end)\n        if prev_end < work_end:\n            free.append((prev_end, work_end))\n        \n        free_slots.append(free)\n    \n    # Find intersection of all free slots\n    common_free = free_slots[0]\n    for free in free_slots[1:]:\n        new_common_free = []\n        i = j = 0\n        while i < len(common_free) and j < len(free):\n            start1, end1 = common_free[i]\n            start2, end2 = free[j]\n            \n            # Find the overlapping interval\n            start = max(start1, start2)\n            end = min(end1, end2)\n            \n            if start < end:\n                new_common_free.append((start, end))\n            \n            # Move the pointer which ends first\n            if end1 < end2:\n                i += 1\n            else:\n                j += 1\n        common_free = new_common_free\n    \n    # Find the first slot that can fit the meeting duration\n    duration = duration_minutes\n    for start, end in common_free:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_h = meeting_start // 60\n            start_m = meeting_start % 60\n            end_h = meeting_end // 60\n            end_m = meeting_end % 60\n            return (f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\", day)\n    \n    return None\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [((13, 30), (14, 00)), ((14, 30), (15, 00))],  # Jacob\n    [((9, 30), (10, 00)), ((11, 30), (12, 00)), ((13, 00), (13, 30)), ((16, 00), (16, 30))],  # Diana\n    [((9, 30), (10, 30)), ((11, 00), (12, 30)), ((15, 30), (16, 00))],  # Adam\n    [((9, 30), (10, 00)), ((10, 30), (12, 00)), ((13, 00), (15, 30)), ((16, 00), (16, 30))],  # Angela\n    [((9, 00), (9, 30)), ((10, 30), (11, 30)), ((13, 00), (15, 00)), ((16, 30), (17, 00))],  # Dennis\n]\n\n# Define meeting parameters\nday = \"Monday\"\nwork_hours_start = (9, 00)\nwork_hours_end = (17, 00)\nduration_minutes = 30\n\n# Find the meeting time\nresult = find_meeting_time(participants_schedules, day, work_hours_start, work_hours_end, duration_minutes)\nif result:\n    time_range, day = result\n    print(f\"{time_range} {day}\")\nelse:\n    print(\"No suitable time found.\")\n'''",
            "count": "calendar_scheduling_example_246"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "13:00",
                "end_time": "14:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "13:00",
                "end_time": "14:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours_start, work_hours_end):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Function to subtract busy slots from free slots\n    def subtract_busy(free_slots, busy_start, busy_end):\n        new_free_slots = []\n        for slot_start, slot_end in free_slots:\n            if busy_end <= slot_start or busy_start >= slot_end:\n                new_free_slots.append((slot_start, slot_end))\n            else:\n                if slot_start < busy_start:\n                    new_free_slots.append((slot_start, busy_start))\n                if slot_end > busy_end:\n                    new_free_slots.append((busy_end, slot_end))\n        return new_free_slots\n    \n    # Process each participant's schedule\n    for schedule in participants_schedules:\n        for busy in schedule:\n            busy_start, busy_end = map(time_to_minutes, busy.split(' to '))\n            free_slots = subtract_busy(free_slots, busy_start, busy_end)\n    \n    # Find the first slot that fits the duration\n    duration_minutes = duration * 60\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            return minutes_to_time(meeting_start), minutes_to_time(meeting_end)\n    \n    return None, None\n\n# Define participants' schedules\nparticipants_schedules = [\n    # Danielle's schedule\n    [\"9:00 to 10:00\", \"10:30 to 11:00\", \"14:30 to 15:00\", \"15:30 to 16:00\", \"16:30 to 17:00\"],\n    # Bruce's schedule\n    [\"11:00 to 11:30\", \"12:30 to 13:00\", \"14:00 to 14:30\", \"15:30 to 16:00\"],\n    # Eric's schedule\n    [\"9:00 to 9:30\", \"10:00 to 11:00\", \"11:30 to 13:00\", \"14:30 to 15:30\"]\n]\n\n# Find meeting time\nmeeting_start, meeting_end = find_meeting_time(participants_schedules, 1, \"9:00\", \"17:00\")\n\n# Output the result\nprint(f\"{meeting_start}:{meeting_end}:Monday\")\n```",
            "count": "calendar_scheduling_example_91"
        },
        {
            "final_program_time": {
                "day": null,
                "start_time": null,
                "end_time": null
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "10:30",
                "end_time": "11:00"
            },
            "has_error": true,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define participants' busy times in minutes (start, end)\n    busy_times = {\n        'Jose': [(11 * 60, 11 * 60 + 30), (12 * 60 + 30, 13 * 60)],\n        'Keith': [(14 * 60, 14 * 60 + 30), (15 * 60, 15 * 60 + 30)],\n        'Logan': [(9 * 60, 10 * 60), (12 * 60, 12 * 60 + 30), (15 * 60, 15 * 60 + 30)],\n        'Megan': [(9 * 60, 10 * 60 + 30), (11 * 60, 12 * 60), (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 16 * 60 + 30)],\n        'Gary': [(9 * 60, 9 * 60 + 30), (10 * 60, 10 * 60 + 30), (11 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60), (14 * 60 + 30, 16 * 60 + 30)],\n        'Bobby': [(11 * 60, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (13 * 60, 16 * 60)],\n    }\n    \n    # Jose's constraint: not after 15:30\n    jose_constraint = 15 * 60 + 30\n    \n    # Meeting duration in minutes\n    meeting_duration = 30\n    \n    # Collect all busy intervals\n    all_busy = []\n    for person in busy_times:\n        all_busy.extend(busy_times[person])\n    \n    # Add Jose's constraint as a busy time for everyone\n    all_busy.append((jose_constraint, work_end))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged_busy = []\n    for start, end in all_busy:\n        if not merged_busy:\n            merged_busy.append((start, end))\n        else:\n            last_start, last_end = merged_busy[-1]\n            if start <= last_end:\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged_busy[-1] = (new_start, new_end))\n            else:\n                merged_busy.append((start, end))\n    \n    # Find available slots\n    available_slots = []\n    previous_end = work_start\n    for start, end in merged_busy:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Filter slots that are at least meeting_duration long\n    valid_slots = []\n    for start, end in available_slots:\n        if end - start >= meeting_duration:\n            valid_slots.append((start, end))\n    \n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n    else:\n        return None\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n    \n    start_time = minutes_to_time(meeting_start)\n    end_time = minutes_to_time(meeting_end)\n    \n    return f\"Monday {start_time}:{end_time}\"\n\n# Execute the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_325"
        },
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "14:00",
                "end_time": "14:30"
            },
            "expected_time": {
                "day": "Tuesday",
                "start_time": "14:00",
                "end_time": "14:30"
            },
            "has_error": false,
            "raw_model_response": "```python\nfrom datetime import datetime, timedelta\n\ndef parse_time(time_str):\n    return datetime.strptime(time_str, \"%H:%M\").time()\n\ndef time_to_minutes(time_obj):\n    return time_obj.hour * 60 + time_obj.minute\n\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return datetime.strptime(f\"{hours:02d}:{mins:02d}\", \"%H:%M\").time()\n\ndef is_available(person_busy, day, start_time, end_time):\n    for busy_block in person_busy.get(day, []):\n        busy_start = time_to_minutes(parse_time(busy_block[0]))\n        busy_end = time_to_minutes(parse_time(busy_block[1]))\n        if not (end_time <= busy_start or start_time >= busy_end):\n            return False\n    return True\n\ndef find_meeting_time(daniel_busy, bradley_busy, preferences, duration_minutes):\n    days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"]\n    work_start = time_to_minutes(parse_time(\"9:00\"))\n    work_end = time_to_minutes(parse_time(\"17:00\"))\n    \n    for day in days:\n        # Check preferences\n        if day in preferences.get(\"Daniel\", {}).get(\"avoid_days\", []):\n            continue\n        if day in preferences.get(\"Bradley\", {}).get(\"avoid_days\", []):\n            continue\n        \n        current_time = work_start\n        while current_time + duration_minutes <= work_end:\n            start_time = current_time\n            end_time = current_time + duration_minutes\n            \n            # Check Bradley's before 12:00 preference on Tuesday\n            if day == \"Tuesday\" and end_time <= time_to_minutes(parse_time(\"12:00\")):\n                if preferences.get(\"Bradley\", {}).get(\"avoid_tuesday_before_12\", False):\n                    current_time += 15  # Skip in 15-minute increments\n                    continue\n            \n            # Check both persons' availability\n            daniel_available = is_available(daniel_busy, day, start_time, end_time)\n            bradley_available = is_available(bradley_busy, day, start_time, end_time)\n            \n            if daniel_available and bradley_available:\n                start_str = minutes_to_time(start_time).strftime(\"%H:%M\")\n                end_str = minutes_to_time(end_time).strftime(\"%H:%M\")\n                return day, f\"{start_str}:{end_str}\"\n            \n            current_time += 15  # Check in 15-minute increments\n    \n    return None, None\n\n# Define busy schedules\ndaniel_busy = {\n    \"Monday\": [(\"9:30\", \"10:30\"), (\"12:00\", \"12:30\"), (\"13:00\", \"14:00\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:00\")],\n    \"Tuesday\": [(\"11:00\", \"12:00\"), (\"13:00\", \"13:30\"), (\"15:30\", \"16:00\"), (\"16:30\", \"17:00\")],\n    \"Wednesday\": [(\"9:00\", \"10:00\"), (\"14:00\", \"14:30\")],\n    \"Thursday\": [(\"10:30\", \"11:00\"), (\"12:00\", \"13:00\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:00\")],\n    \"Friday\": [(\"9:00\", \"9:30\"), (\"11:30\", \"12:00\"), (\"13:00\", \"13:30\"), (\"16:30\", \"17:00\")]\n}\n\nbradley_busy = {\n    \"Monday\": [(\"9:30\", \"11:00\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"14:00\", \"15:00\")],\n    \"Tuesday\": [(\"10:30\", \"11:00\"), (\"12:00\", \"13:00\"), (\"13:30\", \"14:00\"), (\"15:30\", \"16:30\")],\n    \"Wednesday\": [(\"9:00\", \"10:00\"), (\"11:00\", \"13:00\"), (\"13:30\", \"14:00\"), (\"14:30\", \"17:00\")],\n    \"Thursday\": [(\"9:00\", \"12:30\"), (\"13:30\", \"14:00\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:30\")],\n    \"Friday\": [(\"9:00\", \"9:30\"), (\"10:00\", \"12:30\"), (\"13:00\", \"13:30\"), (\"14:00\", \"14:30\"), (\"15:30\", \"16:30\")]\n}\n\n# Define preferences\npreferences = {\n    \"Daniel\": {\"avoid_days\": [\"Wednesday\", \"Thursday\"]},\n    \"Bradley\": {\"avoid_days\": [\"Monday\", \"Friday\"], \"avoid_tuesday_before_12\": True}\n}\n\n# Find meeting time\nday, time_range = find_meeting_time(daniel_busy, bradley_busy, preferences, 30)\n\nif day and time_range:\n    print(f\"{day}: {time_range}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_904"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "10:00",
                "end_time": "10:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "10:00",
                "end_time": "10:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, day, work_hours_start, work_hours_end, duration_minutes):\n    # Convert time to minutes since start of the day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = duration_minutes\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots\n    available_slots = []\n    prev_end = work_start\n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Check each available slot for sufficient duration\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            return (minutes_to_time(meeting_start), minutes_to_time(meeting_end))\n    \n    return None\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"9:30 to 10:00\", \"12:30 to 13:00\", \"13:30 to 14:00\", \"15:30 to 16:00\"],  # Bradley\n    [\"10:30 to 11:00\", \"12:00 to 12:30\", \"13:00 to 13:30\", \"14:30 to 15:00\"],  # Teresa\n    [\"9:00 to 9:30\", \"10:30 to 11:30\", \"13:00 to 13:30\", \"14:30 to 15:00\", \"15:30 to 17:00\"],  # Elizabeth\n    [\"9:00 to 9:30\", \"10:30 to 17:00\"],  # Christian\n]\n\n# Define meeting parameters\nday = \"Monday\"\nwork_hours_start = \"9:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, day, work_hours_start, work_hours_end, duration_minutes)\n\n# Output the result\nif meeting_time:\n    start_time, end_time = meeting_time\n    print(f\"{day}: {start_time}:{end_time}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_113"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "11:00",
                "end_time": "11:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "11:00",
                "end_time": "11:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, day, work_hours_start, work_hours_end, duration_minutes):\n    # Convert work hours to minutes since midnight for easier calculation\n    start_time = work_hours_start * 60\n    end_time = work_hours_end * 60\n    duration = duration_minutes\n    \n    # Initialize a list to keep track of busy intervals for all participants\n    busy_intervals = []\n    \n    # Collect all busy intervals from each participant's schedule\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = interval\n            busy_start = start[0] * 60 + start[1]\n            busy_end = end[0] * 60 + end[1]\n            busy_intervals.append((busy_start, busy_end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals_sorted = sorted(busy_intervals, key=lambda x: x[0])\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for interval in busy_intervals_sorted:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                # Overlapping or adjacent intervals, merge them\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append(interval)\n    \n    # Find available slots between merged busy intervals\n    available_slots = []\n    previous_end = start_time\n    \n    for interval in merged:\n        current_start, current_end = interval\n        if current_start > previous_end:\n            available_slots.append((previous_end, current_start))\n        previous_end = max(previous_end, current_end)\n    \n    # Check the slot after the last busy interval\n    if previous_end < end_time:\n        available_slots.append((previous_end, end_time))\n    \n    # Find the first available slot that can fit the meeting duration\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            return (f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\", day)\n    \n    return None\n\n# Define participants' schedules in HH:MM format converted to tuples of (HH, MM)\njoe_schedule = [\n    ((9, 30), (10, 0)),\n    ((10, 30), (11, 0))\n]\nkeith_schedule = [\n    ((11, 30), (12, 0)),\n    ((15, 0), (15, 30))\n]\npatricia_schedule = [\n    ((9, 0), (9, 30)),\n    ((13, 0), (13, 30))\n]\nnancy_schedule = [\n    ((9, 0), (11, 0)),\n    ((11, 30), (16, 30))\n]\npamela_schedule = [\n    ((9, 0), (10, 0)),\n    ((10, 30), (11, 0)),\n    ((11, 30), (12, 30)),\n    ((13, 0), (14, 0)),\n    ((14, 30), (15, 0)),\n    ((15, 30), (16, 0)),\n    ((16, 30), (17, 0))\n]\n\n# List of all participants' schedules\nparticipants_schedules = [\n    joe_schedule,\n    keith_schedule,\n    patricia_schedule,\n    nancy_schedule,\n    pamela_schedule\n]\n\n# Meeting parameters\nday = \"Monday\"\nwork_hours_start = 9\nwork_hours_end = 17\nduration_minutes = 30\n\n# Find the meeting time\nresult = find_meeting_time(participants_schedules, day, work_hours_start, work_hours_end, duration_minutes)\nif result:\n    time_range, day = result\n    print(f\"{time_range}:{day}\")\nelse:\n    print(\"No available time slot found.\")\n```",
            "count": "calendar_scheduling_example_266"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "9:00",
                "end_time": "9:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "9:00",
                "end_time": "9:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, duration, work_hours, day, preferences=None):\n    \"\"\"\n    Finds a meeting time that fits all participants' schedules and constraints.\n    \n    Args:\n        participants_schedules: List of lists of busy time ranges for each participant.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of (start_hour, end_hour) in 24-hour format.\n        day: Day of the week.\n        preferences: Optional constraints (e.g., no meetings after a certain time).\n    \n    Returns:\n        A tuple of (start_time, end_time) in HH:MM format, or None if no time found.\n    \"\"\"\n    # Convert all times to minutes since midnight for easier calculation\n    work_start = work_hours[0] * 60\n    work_end = work_hours[1] * 60\n    \n    # Generate all possible time slots within work hours\n    slots = []\n    current_time = work_start\n    while current_time + duration <= work_end:\n        slots.append((current_time, current_time + duration))\n        current_time += 15  # Check in 15-minute increments\n    \n    # Apply Frank's preference: no meetings after 9:30 (570 minutes)\n    if preferences and \"no_meeting_after\" in preferences:\n        no_meeting_after = preferences[\"no_meeting_after\"] * 60\n        slots = [slot for slot in slots if slot[0] < no_meeting_after]\n    \n    # Check each slot against all participants' schedules\n    for slot in slots:\n        slot_start, slot_end = slot\n        valid = True\n        \n        for schedule in participants_schedules:\n            for busy_start, busy_end in schedule:\n                busy_start_min = busy_start[0] * 60 + busy_start[1]\n                busy_end_min = busy_end[0] * 60 + busy_end[1]\n                \n                # Check if slot overlaps with any busy time\n                if not (slot_end <= busy_start_min or slot_start >= busy_end_min):\n                    valid = False\n                    break\n            \n            if not valid:\n                break\n        \n        if valid:\n            # Convert back to HH:MM format\n            start_hh = slot_start // 60\n            start_mm = slot_start % 60\n            end_hh = slot_end // 60\n            end_mm = slot_end % 60\n            return (f\"{start_hh:02d}:{start_mm:02d}\", f\"{end_hh:02d}:{end_mm:02d}\")\n    \n    return None\n\n# Define participants' schedules in (HH, MM) format\nemily_schedule = [\n    ((10, 0), (10, 30)),\n    ((11, 30), (12, 30)),\n    ((14, 0), (15, 0)),\n    ((16, 0), (16, 30))\n]\n\nmelissa_schedule = [\n    ((9, 30), (10, 0)),\n    ((14, 30), (15, 0))\n]\n\nfrank_schedule = [\n    ((10, 0), (10, 30)),\n    ((11, 0), (11, 30)),\n    ((12, 30), (13, 0)),\n    ((13, 30), (14, 30)),\n    ((15, 0), (16, 0)),\n    ((16, 30), (17, 0))\n]\n\nparticipants_schedules = [emily_schedule, melissa_schedule, frank_schedule]\nduration = 30  # minutes\nwork_hours = (9, 17)  # 9:00 to 17:00\nday = \"Monday\"\npreferences = {\"no_meeting_after\": 9.5}  # 9:30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, duration, work_hours, day, preferences)\n\nif meeting_time:\n    start_time, end_time = meeting_time\n    print(f\"{day}: {start_time}:{end_time}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_32"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "11:30",
                "end_time": "12:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "12:30",
                "end_time": "13:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours and days\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday']\n    \n    # Define busy slots for Jean and Doris in minutes since midnight\n    jean_busy = {\n        'Tuesday': [(11 * 60 + 30, 12 * 60), (16 * 60, 16 * 60 + 30)]\n    }\n    \n    doris_busy = {\n        'Monday': [(9 * 60, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), \n                   (13 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60, 17 * 60)]\n    }\n    \n    # Doris prefers not to meet on Monday after 14:00\n    doris_preference = {\n        'Monday': (9 * 60, 14 * 60)\n    }\n    \n    meeting_duration = 30  # minutes\n    \n    # Iterate through each day to find a suitable time\n    for day in days:\n        # Get busy slots for the day\n        jean_slots = jean_busy.get(day, [])\n        doris_slots = doris_busy.get(day, [])\n        \n        # Combine and sort all busy slots\n        all_busy = jean_slots + doris_slots\n        all_busy.sort()\n        \n        # Check Doris's preference for Monday\n        if day == 'Monday':\n            start, end = doris_preference[day]\n        else:\n            start, end = work_start, work_end\n        \n        # Find free slots\n        prev_end = start\n        free_slots = []\n        \n        for busy_start, busy_end in all_busy:\n            if busy_start > prev_end:\n                free_slots.append((prev_end, busy_start))\n            prev_end = max(prev_end, busy_end)\n        \n        if prev_end < end:\n            free_slots.append((prev_end, end))\n        \n        # Check for a slot that can fit the meeting\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= meeting_duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + meeting_duration\n                \n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                \n                time_str = f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n                print(f\"{day}, {time_str}\")\n                return\n    \n    print(\"No suitable time found.\")\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_669"
        },
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "10:30",
                "end_time": "11:30"
            },
            "expected_time": {
                "day": "Tuesday",
                "start_time": "10:30",
                "end_time": "11:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours and days\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n    \n    # Define busy times for Nicole and Daniel in minutes since midnight\n    nicole_busy = {\n        'Tuesday': [(16 * 60, 16 * 60 + 30)],\n        'Wednesday': [(15 * 60, 15 * 60 + 30)],\n        'Friday': [(12 * 60, 12 * 60 + 30), (15 * 60 + 30, 16 * 60)]\n    }\n    \n    daniel_busy = {\n        'Monday': [(9 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), (14 * 60, 16 * 60 + 30)],\n        'Tuesday': [(9 * 60, 10 * 60 + 30), (11 * 60 + 30, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), \n                    (15 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Wednesday': [(9 * 60, 10 * 60), (11 * 60, 12 * 60 + 30), (13 * 60, 13 * 60 + 30), \n                      (14 * 60, 14 * 60 + 30), (16 * 60 + 30, 17 * 60)],\n        'Thursday': [(11 * 60, 12 * 60), (13 * 60, 14 * 60), (15 * 60, 15 * 60 + 30)],\n        'Friday': [(10 * 60, 11 * 60), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 14 * 60 + 30), \n                   (15 * 60, 15 * 60 + 30), (16 * 60, 16 * 60 + 30)]\n    }\n    \n    meeting_duration = 60  # 1 hour in minutes\n    \n    for day in days:\n        # Collect all busy intervals for the day\n        busy_intervals = []\n        \n        # Add Nicole's busy times\n        if day in nicole_busy:\n            busy_intervals.extend(nicole_busy[day])\n        \n        # Add Daniel's busy times\n        if day in daniel_busy:\n            busy_intervals.extend(daniel_busy[day])\n        \n        # Sort busy intervals by start time\n        busy_intervals.sort()\n        \n        # Find free slots\n        prev_end = work_start\n        free_slots = []\n        \n        for start, end in busy_intervals:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy interval\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Find the first suitable slot\n        for start, end in free_slots:\n            if end - start >= meeting_duration:\n                meeting_start = start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                time_str = f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n                return day, time_str\n    \n    return None, None\n\nday, time = find_meeting_time()\nprint(f\"{day}, {time}\")\n```",
            "count": "calendar_scheduling_example_975"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "12:00",
                "end_time": "12:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "12:00",
                "end_time": "12:30"
            },
            "has_error": false,
            "raw_model_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\")\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\")\n    days = [\"Monday\", \"Tuesday\", \"Wednesday\"]\n    \n    # Define participants' schedules and constraints\n    arthur_schedule = {\n        \"Monday\": [\n            (\"11:00\", \"11:30\"),\n            (\"13:30\", \"14:00\"),\n            (\"15:00\", \"15:30\")\n        ],\n        \"Tuesday\": [\n            (\"13:00\", \"13:30\"),\n            (\"16:00\", \"16:30\")\n        ],\n        \"Wednesday\": [\n            (\"10:00\", \"10:30\"),\n            (\"11:00\", \"11:30\"),\n            (\"12:00\", \"12:30\"),\n            (\"14:00\", \"14:30\"),\n            (\"16:00\", \"16:30\")\n        ]\n    }\n    \n    michael_schedule = {\n        \"Monday\": [\n            (\"09:00\", \"12:00\"),\n            (\"12:30\", \"13:00\"),\n            (\"14:00\", \"14:30\"),\n            (\"15:00\", \"17:00\")\n        ],\n        \"Tuesday\": [\n            (\"09:30\", \"11:30\"),\n            (\"12:00\", \"13:30\"),\n            (\"14:00\", \"15:30\")\n        ],\n        \"Wednesday\": [\n            (\"10:00\", \"12:30\"),\n            (\"13:00\", \"13:30\")\n        ]\n    }\n    \n    # Arthur cannot meet on Tuesday\n    days_to_check = [day for day in days if day != \"Tuesday\"]\n    \n    # Iterate through each day to find the earliest available slot\n    for day in days_to_check:\n        # Combine and sort all meetings for the day for both participants\n        all_meetings = []\n        \n        # Add Arthur's meetings\n        for meeting in arthur_schedule.get(day, []):\n            start = datetime.strptime(meeting[0], \"%H:%M\")\n            end = datetime.strptime(meeting[1], \"%H:%M\")\n            all_meetings.append((start, end))\n        \n        # Add Michael's meetings\n        for meeting in michael_schedule.get(day, []):\n            start = datetime.strptime(meeting[0], \"%H:%M\")\n            end = datetime.strptime(meeting[1], \"%H:%M\")\n            all_meetings.append((start, end))\n        \n        # Sort meetings by start time\n        all_meetings.sort()\n        \n        # Check for available slots\n        prev_end = work_start\n        for meeting in all_meetings:\n            meeting_start, meeting_end = meeting\n            if meeting_start > prev_end:\n                # Check if the gap is at least 30 minutes\n                gap = (meeting_start - prev_end).total_seconds() / 60\n                if gap >= 30:\n                    # Found a suitable slot\n                    slot_start = prev_end\n                    slot_end = slot_start + timedelta(minutes=30)\n                    return day, slot_start.time(), slot_end.time()\n            # Update prev_end to the later of the two\n            prev_end = max(prev_end, meeting_end)\n        \n        # Check after the last meeting\n        if prev_end < work_end:\n            gap = (work_end - prev_end).total_seconds() / 60\n            if gap >= 30:\n                slot_start = prev_end\n                slot_end = slot_start + timedelta(minutes=30)\n                return day, slot_start.time(), slot_end.time()\n    \n    return None\n\n# Find the meeting time\nresult = find_meeting_time()\nif result:\n    day, start_time, end_time = result\n    # Format the output as HH:MM:HH:MM and day\n    start_str = start_time.strftime(\"%H:%M\")\n    end_str = end_time.strftime(\"%H:%M\")\n    print(f\"{day}: {start_str}:{end_str}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_723"
        },
        {
            "final_program_time": {
                "day": null,
                "start_time": null,
                "end_time": null
            },
            "expected_time": {
                "day": "Tuesday",
                "start_time": "9:00",
                "end_time": "9:30"
            },
            "has_error": true,
            "raw_model_response": "```python\n'''\nThis script finds a suitable meeting time for Shirley and Albert based on their schedules and preferences.\n'''",
            "count": "calendar_scheduling_example_658"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "16:00",
                "end_time": "16:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "16:00",
                "end_time": "16:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define each person's busy times in minutes since midnight\n    busy_slots = {\n        'Katherine': [(12 * 60, 12 * 60 + 30), (13 * 60, 14 * 60 + 30)],\n        'Rebecca': [],\n        'Julie': [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 11 * 60), (13 * 60 + 30, 14 * 60), (15 * 60, 15 * 60 + 30)],\n        'Angela': [(9 * 60, 10 * 60), (10 * 60 + 30, 11 * 60), (11 * 60 + 30, 14 * 60), (14 * 60 + 30, 15 * 60), (16 * 60 + 30, 17 * 60)],\n        'Nicholas': [(9 * 60 + 30, 11 * 60), (11 * 60 + 30, 13 * 60 + 30), (14 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n        'Carl': [(9 * 60, 11 * 60), (11 * 60 + 30, 12 * 60 + 30), (13 * 60, 14 * 60 + 30), (15 * 60, 16 * 60), (16 * 60 + 30, 17 * 60)],\n    }\n\n    # Angela's preference: avoid before 15:00\n    angela_preference_start = 15 * 60\n\n    # Combine all busy slots\n    all_busy = []\n    for person in busy_slots:\n        for start, end in busy_slots[person]:\n            all_busy.append((start, end))\n    all_busy.sort()\n\n    # Find free slots by merging busy intervals\n    free_slots = []\n    prev_end = work_start\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n\n    # Filter free slots that are >= meeting_duration and after Angela's preference\n    possible_slots = []\n    for start, end in free_slots:\n        if end - start >= meeting_duration and start >= angela_preference_start:\n            possible_slots.append((start, end))\n\n    # Select the earliest possible slot\n    if possible_slots:\n        meeting_start = possible_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n    else:\n        return \"No suitable time found.\"\n\n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n\n    start_time = minutes_to_time(meeting_start)\n    end_time = minutes_to_time(meeting_end)\n\n    return f\"{start_time}:{end_time}\"\n\n# Output the result\nprint(f\"{{{find_meeting_time()}}}\")\nprint(\"Monday\")\n```",
            "count": "calendar_scheduling_example_356"
        },
        {
            "final_program_time": {
                "day": null,
                "start_time": null,
                "end_time": null
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "11:00",
                "end_time": "11:30"
            },
            "has_error": true,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedule, duration, work_hours_start, work_hours_end):\n    # Convert all time slots to minutes since start of the day\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's busy slots\n    for participant, busy_slots in participants_schedule.items():\n        participant_busy = []\n        for slot in busy_slots:\n            start, end = map(time_to_minutes, slot.split(':'))\n            participant_busy.append((start, end))\n        \n        # Merge overlapping or adjacent busy slots for the participant\n        participant_busy.sort()\n        merged_busy = []\n        for start, end in participant_busy:\n            if not merged_busy:\n                merged_busy.append((start, end))\n            else:\n                last_start, last_end = merged_busy[-1]\n                if start <= last_end:\n                    merged_busy[-1] = (last_start, max(last_end, end))\n                else:\n                    merged_busy.append((start, end))\n        \n        # Subtract busy slots from free slots\n        new_free_slots = []\n        for free_start, free_end in free_slots:\n            current_start = free_start\n            for busy_start, busy_end in merged_busy:\n                if busy_start >= free_end:\n                    break\n                if busy_end <= current_start:\n                    continue\n                if busy_start > current_start:\n                    new_free_slots.append((current_start, busy_start))\n                current_start = max(current_start, busy_end)\n            if current_start < free_end:\n                new_free_slots.append((current_start, free_end))\n        free_slots = new_free_slots\n    \n    # Find the earliest slot that fits the duration\n    duration_min = time_to_minutes(duration)\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration_min:\n            return (minutes_to_time(slot_start), minutes_to_time(slot_start + duration_min))\n    return None\n\n# Define the participants' schedules\nparticipants_schedule = {\n    'Steven': [],\n    'Roy': [],\n    'Cynthia': ['9:30:10:30', '11:30:12:00', '13:00:13:30', '15:00:16:00'],\n    'Lauren': ['9:00:9:30', '10:30:11:00', '11:30:12:00', '13:00:13:30', '14:00:14:30', '15:00:15:30', '16:00:17:00'],\n    'Robert': ['10:30:11:00', '11:30:12:00', '12:30:13:30', '14:00:16:00']\n}\n\n# Define meeting parameters\nmeeting_duration = '0:30'  # half an hour\nwork_hours_start = '9:00'\nwork_hours_end = '17:00'\nday_of_week = 'Monday'\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedule, meeting_duration, work_hours_start, work_hours_end)\n\n# Output the result\nif meeting_time:\n    start_time, end_time = meeting_time\n    print(f\"{{{start_time}:{end_time}}} {day_of_week}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_215"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "12:00",
                "end_time": "12:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "12:00",
                "end_time": "12:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration_minutes, day):\n    # Convert time strings to minutes since 9:00 (start of work hours)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Assuming work_hours start at 9:00\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = 9 + (minutes // 60)\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    start_work = time_to_minutes(work_hours[0])\n    end_work = time_to_minutes(work_hours[1])\n    duration = duration_minutes\n\n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy)\n            busy_intervals.append((start, end))\n    \n    # Sort intervals by start time\n    busy_intervals.sort()\n\n    # Merge overlapping or adjacent intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append([start, end])\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                merged[-1][1] = max(end, last_end)\n            else:\n                merged.append([start, end])\n\n    # Find the first available slot\n    prev_end = start_work\n    for start, end in merged:\n        if start - prev_end >= duration:\n            available_start = prev_end\n            available_end = available_start + duration\n            return (minutes_to_time(available_start), minutes_to_time(available_end))\n        prev_end = max(prev_end, end)\n    \n    # Check after last busy interval\n    if end_work - prev_end >= duration:\n        available_start = prev_end\n        available_end = available_start + duration\n        return (minutes_to_time(available_start), minutes_to_time(available_end))\n    \n    return None\n\n# Define work hours and day\nwork_hours = (\"9:00\", \"17:00\")\nday = \"Monday\"\nduration_minutes = 30\n\n# Define each participant's busy times\nparticipants_schedules = [\n    [],  # Eric has no meetings\n    [(\"10:00\", \"10:30\"), (\"11:00\", \"12:00\"), (\"12:30\", \"13:00\"), (\"15:00\", \"16:00\")],  # Ashley\n    [(\"9:00\", \"9:30\"), (\"10:00\", \"11:30\"), (\"12:30\", \"14:00\"), (\"14:30\", \"17:00\")],  # Ronald\n    [(\"9:00\", \"12:00\"), (\"13:00\", \"17:00\")],  # Larry\n]\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours, duration_minutes, day)\n\n# Output the result\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{start}:{end}:{day}\")\nelse:\n    print(\"No available time slot found.\")\n```",
            "count": "calendar_scheduling_example_135"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "9:30",
                "end_time": "10:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "14:30",
                "end_time": "15:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, preferences, duration, work_hours_start, work_hours_end):\n    # Convert all time strings to minutes since 9:00 (work_hours_start)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # 9:00 is 0 minutes\n    \n    def minutes_to_time(minutes):\n        hh = 9 + (minutes // 60)\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for each participant\n    busy_intervals = []\n    for participant, schedules in participants_schedules.items():\n        for start, end in schedules:\n            busy_start = time_to_minutes(start)\n            busy_end = time_to_minutes(end)\n            busy_intervals.append((busy_start, busy_end))\n    \n    # Add preference constraints as busy intervals\n    for participant, pref in preferences.items():\n        if pref.get('avoid_after', None):\n            avoid_after = time_to_minutes(pref['avoid_after'])\n            busy_intervals.append((avoid_after, work_end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find all free intervals\n    free_intervals = []\n    prev_end = work_start\n    for start, end in busy_intervals:\n        if start > prev_end:\n            free_intervals.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        free_intervals.append((prev_end, work_end))\n    \n    # Find the first free interval that can accommodate the meeting\n    for start, end in free_intervals:\n        if end - start >= duration:\n            meeting_start = start\n            meeting_end = meeting_start + duration\n            return (minutes_to_time(meeting_start), minutes_to_time(meeting_end))\n    \n    return None\n\n# Define the participants' schedules\nparticipants_schedules = {\n    'Raymond': [('9:00', '9:30'), ('11:30', '12:00'), ('13:00', '13:30'), ('15:00', '15:30')],\n    'Billy': [('10:00', '10:30'), ('12:00', '13:00'), ('16:30', '17:00')],\n    'Donald': [('9:00', '9:30'), ('10:00', '11:00'), ('12:00', '13:00'), ('14:00', '14:30'), ('16:00', '17:00')]\n}\n\n# Define preferences\npreferences = {\n    'Billy': {'avoid_after': '15:00'}\n}\n\n# Meeting duration in minutes (30 minutes)\nduration = 30\n\n# Work hours\nwork_hours_start = '9:00'\nwork_hours_end = '17:00'\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, preferences, duration, work_hours_start, work_hours_end)\n\n# Output the result\nif meeting_time:\n    start_time, end_time = meeting_time\n    print(f\"{{{start_time}:{end_time}}} Monday\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_1"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "13:00",
                "end_time": "13:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "15:00",
                "end_time": "15:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Define participants' schedules and constraints\n    susan_schedule = {\n        'Monday': [(12 * 60 + 30, 13 * 60), (13 * 60 + 30, 14 * 60)],\n        'Tuesday': [(11 * 60 + 30, 12 * 60)],\n        'Wednesday': [(9 * 60 + 30, 10 * 60 + 30), (14 * 60, 14 * 60 + 30), (15 * 60 + 30, 16 * 60 + 30)]\n    }\n    \n    sandra_schedule = {\n        'Monday': [(9 * 60, 13 * 60), (14 * 60, 15 * 60), (16 * 60, 16 * 60 + 30)],\n        'Tuesday': [(9 * 60, 9 * 60 + 30), (10 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60 + 30), \n                    (14 * 60, 14 * 60 + 30), (16 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 11 * 60 + 30), (12 * 60, 12 * 60 + 30), (13 * 60, 17 * 60)]\n    }\n    \n    # Susan prefers not to meet on Tuesday\n    preferred_days = ['Monday', 'Wednesday']\n    \n    # Iterate through each day in preferred order\n    for day in preferred_days:\n        # Get both participants' busy times for the day\n        susan_busy = susan_schedule.get(day, [])\n        sandra_busy = sandra_schedule.get(day, [])\n        \n        # Combine and sort all busy intervals\n        all_busy = susan_busy + sandra_busy\n        all_busy.sort()\n        \n        # Find available slots\n        available_slots = []\n        prev_end = work_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        # Check after last busy interval\n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n        \n        # Find first available 30-minute slot\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= 30:\n                meeting_start = slot_start\n                meeting_end = meeting_start + 30\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                time_str = f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n                return day, time_str\n    \n    # If no slot found in preferred days, check Tuesday (though Susan prefers not)\n    day = 'Tuesday'\n    susan_busy = susan_schedule.get(day, [])\n    sandra_busy = sandra_schedule.get(day, [])\n    all_busy = susan_busy + sandra_busy\n    all_busy.sort()\n    \n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= 30:\n            meeting_start = slot_start\n            meeting_end = meeting_start + 30\n            start_hh = meeting_start // 60\n            start_mm = meeting_start % 60\n            end_hh = meeting_end // 60\n            end_mm = meeting_end % 60\n            time_str = f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n            return day, time_str\n    \n    return None, None\n\nday, time_slot = find_meeting_time()\nprint(f\"{day}: {time_slot}\")\n```",
            "count": "calendar_scheduling_example_778"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "13:30",
                "end_time": "14:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "13:30",
                "end_time": "14:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define each person's busy times in minutes since midnight\n    lisa_busy = [\n        (9 * 60, 10 * 60),\n        (10 * 60 + 30, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    bobby_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (11 * 60 + 30, 12 * 60),\n        (15 * 60, 15 * 60 + 30)\n    ]\n    randy_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 11 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (14 * 60 + 30, 15 * 60 + 30),\n        (16 * 60, 16 * 60 + 30)\n    ]\n\n    # Bobby's preference: avoid after 15:00\n    bobby_preference_end = 15 * 60\n\n    # Combine all busy times and sort\n    all_busy = lisa_busy + bobby_busy + randy_busy\n    all_busy.sort()\n\n    # Find free slots\n    free_slots = []\n    prev_end = work_start\n\n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n\n    if prev_end < work_end:\n        free_slots.append((prev_end, work_end))\n\n    # Filter slots that are >= meeting_duration and respect Bobby's preference\n    valid_slots = []\n    for start, end in free_slots:\n        if end - start >= meeting_duration:\n            # Check if the slot is before Bobby's preference end time or starts before it\n            if start < bobby_preference_end:\n                valid_start = start\n                valid_end = min(end, bobby_preference_end)\n                if valid_end - valid_start >= meeting_duration:\n                    valid_slots.append((valid_start, valid_end))\n\n    # Select the earliest valid slot\n    if valid_slots:\n        chosen_start, chosen_end = valid_slots[0]\n        # Convert minutes back to HH:MM format\n        start_hh = chosen_start // 60\n        start_mm = chosen_start % 60\n        end_hh = (chosen_start + meeting_duration) // 60\n        end_mm = (chosen_start + meeting_duration) % 60\n\n        # Format the output\n        time_range = f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n        day = \"Monday\"\n        print(f\"{time_range}:{day}\")\n    else:\n        print(\"No suitable time found.\")\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_33"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "9:30",
                "end_time": "10:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "9:30",
                "end_time": "10:00"
            },
            "has_error": false,
            "raw_model_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_earliest_meeting_time(participants_schedules, work_hours, meeting_duration, days):\n    # Convert work hours to minutes since start of day\n    work_start = int(work_hours[0].split(':')[0]) * 60 + int(work_hours[0].split(':')[1])\n    work_end = int(work_hours[1].split(':')[0]) * 60 + int(work_hours[1].split(':')[1])\n    \n    # Preprocess blocked times into minutes since start of day for each day\n    blocked_times = {}\n    for day in days:\n        blocked_times[day] = []\n        for participant in participants_schedules:\n            for block in participants_schedules[participant].get(day, []):\n                start_time = block[0].split(':')\n                end_time = block[1].split(':')\n                start_min = int(start_time[0]) * 60 + int(start_time[1])\n                end_min = int(end_time[0]) * 60 + int(end_time[1])\n                blocked_times[day].append((start_min, end_min))\n    \n    # Check each day in order for the earliest available slot\n    for day in days:\n        # Merge and sort all blocked intervals for the day\n        intervals = blocked_times[day]\n        if not intervals:\n            # No blocked times, entire work day is available\n            return day, (work_hours[0], f\"{int(work_start//60):02d}:{int(work_start%60):02d}\", \n                         f\"{int((work_start + meeting_duration)//60):02d}:{int((work_start + meeting_duration)%60):02d}\")\n        \n        merged = []\n        for start, end in sorted(intervals):\n            if not merged:\n                merged.append((start, end))\n            else:\n                last_start, last_end = merged[-1]\n                if start <= last_end:\n                    merged[-1] = (last_start, max(end, last_end))\n                else:\n                    merged.append((start, end))\n        \n        # Check before first interval\n        first_start, first_end = merged[0]\n        if first_start - work_start >= meeting_duration:\n            return day, (f\"{int(work_start//60):02d}:{int(work_start%60):02d}\", \n                          f\"{int((work_start + meeting_duration)//60):02d}:{int((work_start + meeting_duration)%60):02d}\")\n        \n        # Check between intervals\n        for i in range(1, len(merged)):\n            prev_end = merged[i-1][1]\n            curr_start = merged[i][0]\n            if curr_start - prev_end >= meeting_duration:\n                return day, (f\"{int(prev_end//60):02d}:{int(prev_end%60):02d}\", \n                            f\"{int((prev_end + meeting_duration)//60):02d}:{int((prev_end + meeting_duration)%60):02d}\")\n        \n        # Check after last interval\n        last_start, last_end = merged[-1]\n        if work_end - last_end >= meeting_duration:\n            return day, (f\"{int(last_end//60):02d}:{int(last_end%60):02d}\", \n                         f\"{int((last_end + meeting_duration)//60):02d}:{int((last_end + meeting_duration)%60):02d}\")\n    \n    return None, None\n\n# Define the problem constraints\nparticipants_schedules = {\n    \"Ronald\": {\n        \"Monday\": [(\"10:30\", \"11:00\"), (\"12:00\", \"12:30\"), (\"15:30\", \"16:00\")],\n        \"Tuesday\": [(\"9:00\", \"9:30\"), (\"12:00\", \"12:30\"), (\"15:30\", \"16:30\")],\n        \"Wednesday\": [(\"9:30\", \"10:30\"), (\"11:00\", \"12:00\"), (\"12:30\", \"13:00\"), (\"13:30\", \"14:00\"), (\"16:30\", \"17:00\")],\n    },\n    \"Amber\": {\n        \"Monday\": [(\"9:00\", \"9:30\"), (\"10:00\", \"10:30\"), (\"11:30\", \"12:00\"), (\"12:30\", \"14:00\"), (\"14:30\", \"15:00\"), (\"15:30\", \"17:00\")],\n        \"Tuesday\": [(\"9:00\", \"9:30\"), (\"10:00\", \"11:30\"), (\"12:00\", \"12:30\"), (\"13:30\", \"15:30\"), (\"16:30\", \"17:00\")],\n        \"Wednesday\": [(\"9:00\", \"9:30\"), (\"10:00\", \"10:30\"), (\"11:00\", \"13:30\"), (\"15:00\", \"15:30\")],\n    }\n}\n\nwork_hours = (\"9:00\", \"17:00\")\nmeeting_duration = 30  # minutes\ndays = [\"Monday\", \"Tuesday\", \"Wednesday\"]\n\n# Find the earliest meeting time\nday, time_range = find_earliest_meeting_time(participants_schedules, work_hours, meeting_duration, days)\n\n# Output the result\nif day and time_range:\n    start_time, end_time = time_range\n    print(f\"{day}: {start_time}:{end_time}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_735"
        },
        {
            "final_program_time": {
                "day": null,
                "start_time": null,
                "end_time": null
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "9:30",
                "end_time": "10:00"
            },
            "has_error": true,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Initialize the available slots as the entire work day\n    available_slots = [(work_start, work_end)]\n    \n    # Process each participant's schedule to find common free slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start, end = map(time_to_minutes, busy.split(':'))\n            busy_slots.append((start, end))\n        \n        # Sort busy slots by start time\n        busy_slots.sort()\n        \n        # Merge overlapping or adjacent busy slots\n        merged_busy = []\n        for start, end in busy_slots:\n            if not merged_busy:\n                merged_busy.append((start, end))\n            else:\n                last_start, last_end = merged_busy[-1]\n                if start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged_busy[-1] = (new_start, new_end)\n                else:\n                    merged_busy.append((start, end))\n        \n        # Subtract busy slots from available slots\n        new_available = []\n        for avail_start, avail_end in available_slots:\n            current_start = avail_start\n            for busy_start, busy_end in merged_busy:\n                if busy_start > current_start:\n                    # Add the free slot before the busy slot\n                    new_available.append((current_start, busy_start))\n                current_start = max(current_start, busy_end)\n            if current_start < avail_end:\n                new_available.append((current_start, avail_end))\n        available_slots = new_available\n    \n    # Find the first available slot that fits the meeting duration\n    meeting_duration_min = time_to_minutes(meeting_duration)\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= meeting_duration_min:\n            meeting_end = slot_start + meeting_duration_min\n            return (minutes_to_time(slot_start), minutes_to_time(meeting_end)\n    \n    return None\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"13:30:14:00\", \"14:30:15:00\"],  # Patrick\n    [\"09:00:09:30\", \"11:00:11:30\", \"12:00:12:30\", \"14:30:15:00\", \"16:00:17:00\"],  # Shirley\n    [\"09:00:09:30\", \"10:30:11:00\", \"11:30:12:00\", \"13:00:13:30\", \"16:00:17:00\"],  # Jeffrey\n    [\"11:30:12:00\", \"15:00:15:30\"],  # Gloria\n    [\"09:00:09:30\", \"10:30:12:00\", \"14:00:17:00\"],  # Nathan\n    [\"09:00:09:30\", \"10:00:11:00\", \"12:30:15:00\", \"15:30:16:30\"],  # Angela\n    [\"09:00:09:30\", \"10:00:10:30\", \"11:00:14:00\", \"14:30:16:30\"],  # David\n]\n\n# Define work hours and meeting duration\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nmeeting_duration = \"00:30\"\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration)\n\nif meeting_time:\n    start_time, end_time = meeting_time\n    print(f\"{start_time}:{end_time}\")\n    print(\"Monday\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_436"
        },
        {
            "final_program_time": {
                "day": "Friday",
                "start_time": "14:30",
                "end_time": "15:30"
            },
            "expected_time": {
                "day": "Friday",
                "start_time": "14:30",
                "end_time": "15:30"
            },
            "has_error": false,
            "raw_model_response": "```python\nfrom typing import Dict, List, Tuple\n\ndef find_meeting_time(\n    participants: Dict[str, Dict[str, List[Tuple[str, str]]]],\n    preferences: Dict[str, List[str]],\n    work_hours: Tuple[str, str],\n    duration: int,\n    days: List[str]\n) -> Tuple[str, str]:\n    # Convert time string \"HH:MM\" to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str: str) -> int:\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    # Convert minutes back to \"HH:MM\" format\n    def minutes_to_time(minutes: int) -> str:\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    # Parse work hours\n    work_start, work_end = time_to_minutes(work_hours[0]), time_to_minutes(work_hours[1])\n    duration_min = duration * 60\n\n    # Iterate through each day to find a suitable time slot\n    for day in days:\n        # Skip days based on preferences\n        skip_day = False\n        for participant, pref_days in preferences.items():\n            if day in pref_days:\n                skip_day = True\n                break\n        if skip_day:\n            continue\n\n        # Collect all busy intervals for the day\n        busy_intervals = []\n        for participant, schedule in participants.items():\n            if day in schedule:\n                for start, end in schedule[day]:\n                    busy_start = time_to_minutes(start)\n                    busy_end = time_to_minutes(end)\n                    busy_intervals.append((busy_start, busy_end))\n\n        # Sort busy intervals by start time\n        busy_intervals.sort()\n\n        # Find available slots\n        available_slots = []\n        prev_end = work_start\n\n        for start, end in busy_intervals:\n            if start > prev_end:\n                available_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n\n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n\n        # Check for a slot that can fit the meeting\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= duration_min:\n                meeting_start = slot_start\n                meeting_end = meeting_start + duration_min\n                return day, f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n\n    return None, None\n\n# Define participants' schedules\nparticipants = {\n    \"Bryan\": {\n        \"Thursday\": [(\"9:30\", \"10:00\"), (\"12:30\", \"13:00\")],\n        \"Friday\": [(\"10:30\", \"11:00\"), (\"14:00\", \"14:30\")],\n    },\n    \"Nicholas\": {\n        \"Monday\": [(\"11:30\", \"12:00\"), (\"13:00\", \"15:30\")],\n        \"Tuesday\": [(\"9:00\", \"9:30\"), (\"11:00\", \"13:30\"), (\"14:00\", \"16:30\")],\n        \"Wednesday\": [(\"9:00\", \"9:30\"), (\"10:00\", \"11:00\"), (\"11:30\", \"13:30\"), (\"14:00\", \"14:30\"), (\"15:00\", \"16:30\")],\n        \"Thursday\": [(\"10:30\", \"11:30\"), (\"12:00\", \"12:30\"), (\"15:00\", \"15:30\"), (\"16:30\", \"17:00\")],\n        \"Friday\": [(\"9:00\", \"10:30\"), (\"11:00\", \"12:00\"), (\"12:30\", \"14:30\"), (\"15:30\", \"16:00\"), (\"16:30\", \"17:00\")],\n    }\n}\n\n# Define preferences\npreferences = {\n    \"Bryan\": [\"Tuesday\"],\n    \"Nicholas\": [\"Monday\", \"Thursday\"],\n}\n\n# Define other parameters\nwork_hours = (\"9:00\", \"17:00\")\nduration = 1  # hour\ndays = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"]\n\n# Find meeting time\nday, time_range = find_meeting_time(participants, preferences, work_hours, duration, days)\n\n# Output the result\nprint(f\"{day}, {time_range}\")\n```",
            "count": "calendar_scheduling_example_910"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "9:00",
                "end_time": "10:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "9:00",
                "end_time": "10:00"
            },
            "has_error": false,
            "raw_model_response": "```python\nfrom typing import List, Dict, Tuple\n\ndef find_meeting_time(\n    participants: Dict[str, Dict[str, List[Tuple[str, str]]]],\n    days: List[str],\n    work_hours: Tuple[str, str],\n    duration: int,\n    earliest: bool = True\n) -> Tuple[str, str]:\n    \"\"\"\n    Find a meeting time that fits all participants' schedules.\n    \n    Args:\n        participants: Dictionary of participants and their busy times.\n        days: List of days to consider (e.g., [\"Monday\", \"Tuesday\"]).\n        work_hours: Tuple of work hours (e.g., (\"9:00\", \"17:00\")).\n        duration: Duration of the meeting in minutes.\n        earliest: If True, prioritize the earliest possible time.\n    \n    Returns:\n        Tuple of (day, time_range) where time_range is \"HH:MM:HH:MM\".\n    \"\"\"\n    # Parse work hours\n    work_start = convert_time_to_minutes(work_hours[0])\n    work_end = convert_time_to_minutes(work_hours[1])\n    \n    for day in days:\n        # Collect all busy intervals for the day\n        busy_intervals = []\n        for person in participants.values():\n            if day in person:\n                for start, end in person[day]:\n                    busy_start = convert_time_to_minutes(start)\n                    busy_end = convert_time_to_minutes(end)\n                    busy_intervals.append((busy_start, busy_end))\n        \n        # Sort busy intervals by start time\n        busy_intervals.sort()\n        \n        # Find free slots\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in busy_intervals:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for availability\n        for start, end in free_slots:\n            if end - start >= duration:\n                meeting_start = start if earliest else end - duration\n                meeting_end = meeting_start + duration\n                time_range = (\n                    f\"{convert_minutes_to_time(meeting_start)}:\"\n                    f\"{convert_minutes_to_time(meeting_end)}\"\n                )\n                return (day, time_range)\n    \n    return (\"\", \"\")\n\ndef convert_time_to_minutes(time_str: str) -> int:\n    \"\"\"Convert time string (HH:MM) to minutes since midnight.\"\"\"\n    hours, minutes = map(int, time_str.split(':'))\n    return hours * 60 + minutes\n\ndef convert_minutes_to_time(minutes: int) -> str:\n    \"\"\"Convert minutes since midnight to time string (HH:MM).\"\"\"\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\n# Define participants' schedules\nparticipants = {\n    \"Megan\": {\n        \"Monday\": [(\"13:00\", \"13:30\"), (\"14:00\", \"15:30\")],\n        \"Tuesday\": [(\"9:00\", \"9:30\"), (\"12:00\", \"12:30\"), (\"16:00\", \"17:00\")],\n        \"Wednesday\": [(\"9:30\", \"10:00\"), (\"10:30\", \"11:30\"), (\"12:30\", \"14:00\"), (\"16:00\", \"16:30\")],\n        \"Thursday\": [(\"13:30\", \"14:30\"), (\"15:00\", \"15:30\")],\n    },\n    \"Daniel\": {\n        \"Monday\": [(\"10:00\", \"11:30\"), (\"12:30\", \"15:00\")],\n        \"Tuesday\": [(\"9:00\", \"10:00\"), (\"10:30\", \"17:00\")],\n        \"Wednesday\": [(\"9:00\", \"10:00\"), (\"10:30\", \"11:30\"), (\"12:00\", \"17:00\")],\n        \"Thursday\": [(\"9:00\", \"12:00\"), (\"12:30\", \"14:30\"), (\"15:00\", \"15:30\"), (\"16:00\", \"17:00\")],\n    },\n}\n\n# Define meeting constraints\ndays = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\"]\nwork_hours = (\"9:00\", \"17:00\")\nduration = 60  # minutes\n\n# Find the earliest meeting time\nday, time_range = find_meeting_time(participants, days, work_hours, duration, earliest=True)\n\n# Output the result\nprint(f\"{day}: {time_range}\")\n```",
            "count": "calendar_scheduling_example_865"
        },
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "10:30",
                "end_time": "11:00"
            },
            "expected_time": {
                "day": "Tuesday",
                "start_time": "10:30",
                "end_time": "11:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    \n    # Define days to check\n    days = [\"Monday\", \"Tuesday\"]\n    \n    # Amanda's and Nathan's busy times in minutes since midnight for each day\n    amanda_busy = {\n        \"Monday\": [\n            (9 * 60, 10 * 60 + 30),    # 9:00-10:30\n            (11 * 60, 11 * 60 + 30),   # 11:00-11:30\n            (12 * 60 + 30, 13 * 60),   # 12:30-13:00\n            (13 * 60 + 30, 14 * 60),   # 13:30-14:00\n            (14 * 60 + 30, 15 * 60),  # 14:30-15:00\n        ],\n        \"Tuesday\": [\n            (9 * 60, 9 * 60 + 30),     # 9:00-9:30\n            (10 * 60, 10 * 60 + 30),    # 10:00-10:30\n            (11 * 60 + 30, 12 * 60),   # 11:30-12:00\n            (13 * 60 + 30, 14 * 60 + 30),  # 13:30-14:30\n            (15 * 60 + 30, 16 * 60),    # 15:30-16:00\n            (16 * 60 + 30, 17 * 60),   # 16:30-17:00\n        ]\n    }\n    \n    nathan_busy = {\n        \"Monday\": [\n            (10 * 60, 10 * 60 + 30),   # 10:00-10:30\n            (11 * 60, 11 * 60 + 30),   # 11:00-11:30\n            (13 * 60 + 30, 14 * 60 + 30),  # 13:30-14:30\n            (16 * 60, 16 * 60 + 30),   # 16:00-16:30\n        ],\n        \"Tuesday\": [\n            (9 * 60, 10 * 60 + 30),    # 9:00-10:30\n            (11 * 60, 13 * 60),        # 11:00-13:00\n            (13 * 60 + 30, 14 * 60),   # 13:30-14:00\n            (14 * 60 + 30, 15 * 60 + 30),  # 14:30-15:30\n            (16 * 60, 16 * 60 + 30),   # 16:00-16:30\n        ]\n    }\n    \n    meeting_duration = 30  # minutes\n    \n    # Nathan cannot meet on Monday, so remove Monday\n    days_to_check = [\"Tuesday\"]\n    \n    for day in days_to_check:\n        # Get busy intervals for both participants\n        amanda_intervals = amanda_busy.get(day, [])\n        nathan_intervals = nathan_busy.get(day, [])\n        \n        # Combine and sort all busy intervals\n        all_busy = amanda_intervals + nathan_intervals\n        all_busy.sort()\n        \n        # Merge overlapping or adjacent intervals\n        merged_busy = []\n        for start, end in all_busy:\n            if not merged_busy:\n                merged_busy.append((start, end))\n            else:\n                last_start, last_end = merged_busy[-1]\n                if start <= last_end:\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged_busy[-1] = (new_start, new_end)\n                else:\n                    merged_busy.append((start, end))\n        \n        # Check the time before the first busy interval\n        if len(merged_busy) > 0:\n            first_start, first_end = merged_busy[0]\n            if first_start - work_start >= meeting_duration:\n                # Amanda doesn't want to meet on Tuesday after 11:00\n                if day == \"Tuesday\" and work_start >= 11 * 60:\n                    continue\n                meeting_start = work_start\n                meeting_end = meeting_start + meeting_duration\n                return day, meeting_start, meeting_end\n        \n        # Check the time between busy intervals\n        for i in range(len(merged_busy) - 1):\n            current_end = merged_busy[i][1]\n            next_start = merged_busy[i + 1][0]\n            if next_start - current_end >= meeting_duration:\n                # Amanda doesn't want to meet on Tuesday after 11:00\n                if day == \"Tuesday\" and current_end >= 11 * 60:\n                    continue\n                meeting_start = current_end\n                meeting_end = meeting_start + meeting_duration\n                return day, meeting_start, meeting_end\n        \n        # Check the time after the last busy interval\n        if len(merged_busy) > 0:\n            last_start, last_end = merged_busy[-1]\n            if work_end - last_end >= meeting_duration:\n                # Amanda doesn't want to meet on Tuesday after 11:00\n                if day == \"Tuesday\" and last_end >= 11 * 60:\n                    continue\n                meeting_start = last_end\n                meeting_end = meeting_start + meeting_duration\n                return day, meeting_start, meeting_end\n        else:\n            # No busy intervals, any time works\n            # Amanda doesn't want to meet on Tuesday after 11:00\n            if day == \"Tuesday\" and work_start >= 11 * 60:\n                continue\n            meeting_start = work_start\n            meeting_end = meeting_start + meeting_duration\n            return day, meeting_start, meeting_end\n    \n    return None\n\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    mins = minutes % 60\n    return f\"{hours:02d}:{mins:02d}\"\n\nday, start, end = find_meeting_time()\nstart_time = minutes_to_time(start)\nend_time = minutes_to_time(end)\nprint(f\"{day}: {start_time}:{end_time}\")\n```",
            "count": "calendar_scheduling_example_682"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "9:30",
                "end_time": "10:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "9:30",
                "end_time": "10:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours and meeting duration\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define each participant's busy slots in minutes (start, end)\n    jacqueline_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (11 * 60, 11 * 60 + 30),\n        (12 * 60 + 30, 13 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n    harold_busy = [\n        (10 * 60, 10 * 60 + 30),\n        (13 * 60, 13 * 60 + 30),\n        (15 * 60, 17 * 60)\n    ]\n    # Harold doesn't want to meet after 13:00\n    harold_no_meet_after = 13 * 60\n    arthur_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 12 * 60 + 30),\n        (14 * 60 + 30, 15 * 60),\n        (15 * 60 + 30, 17 * 60)\n    ]\n    kelly_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 11 * 60),\n        (11 * 60 + 30, 12 * 60 + 30),\n        (14 * 60, 15 * 60),\n        (15 * 60 + 30, 16 * 60)\n    ]\n\n    # Combine all busy slots for all participants\n    all_busy = jacqueline_busy + harold_busy + arthur_busy + kelly_busy\n\n    # Generate free slots by finding gaps in busy times\n    all_busy.sort()  # Sort by start time\n    free_slots = []\n    previous_end = work_start\n\n    for busy_start, busy_end in all_busy:\n        if busy_start > previous_end:\n            free_slots.append((previous_end, busy_start))\n        previous_end = max(previous_end, busy_end)\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n\n    # Now, find a free slot that fits the meeting duration and Harold's constraint\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= meeting_duration:\n            # Check if the slot starts before Harold's no-meet-after time\n            potential_start = slot_start\n            potential_end = potential_start + meeting_duration\n            if potential_end <= harold_no_meet_after:\n                # Check if all participants are free during this slot\n                all_free = True\n                # Check Jacqueline\n                for busy_start, busy_end in jacqueline_busy:\n                    if busy_start < potential_end and busy_end > potential_start:\n                        all_free = False\n                        break\n                if not all_free:\n                    continue\n                # Check Harold\n                for busy_start, busy_end in harold_busy:\n                    if busy_start < potential_end and busy_end > potential_start:\n                        all_free = False\n                        break\n                if not all_free:\n                    continue\n                # Check Arthur\n                for busy_start, busy_end in arthur_busy:\n                    if busy_start < potential_end and busy_end > potential_start:\n                        all_free = False\n                        break\n                if not all_free:\n                    continue\n                # Check Kelly\n                for busy_start, busy_end in kelly_busy:\n                    if busy_start < potential_end and busy_end > potential_start:\n                        all_free = False\n                        break\n                if all_free:\n                    # Format the time as HH:MM:HH:MM\n                    start_hh = potential_start // 60\n                    start_mm = potential_start % 60\n                    end_hh = potential_end // 60\n                    end_mm = potential_end % 60\n                    time_str = f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n                    return time_str, \"Monday\"\n\n    return \"No suitable time found\", \"Monday\"\n\n# Run the function and print the result\ntime_range, day = find_meeting_time()\nprint(f\"{time_range} {day}\")\n```",
            "count": "calendar_scheduling_example_173"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "9:00",
                "end_time": "9:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "9:00",
                "end_time": "9:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, day, work_start, work_end, duration_minutes):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration = duration_minutes\n    \n    # Initialize a list to track busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = interval\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            busy_intervals.append((start_min, end_min))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Merge overlapping or adjacent busy intervals\n    merged = []\n    for start, end in busy_intervals:\n        if not merged:\n            merged.append((start, end))\n        else:\n            last_start, last_end = merged[-1]\n            if start <= last_end:\n                # Overlapping or adjacent, merge them\n                new_start = min(last_start, start)\n                new_end = max(last_end, end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append((start, end))\n    \n    # Find available slots by checking gaps between busy intervals and work hours\n    available_slots = []\n    prev_end = work_start_min\n    \n    for start, end in merged:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    # Check the slot after the last busy interval\n    if prev_end < work_end_min:\n        available_slots.append((prev_end, work_end_min))\n    \n    # Find the first available slot that can fit the meeting\n    for slot_start, slot_end in available_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            \n            start_time = minutes_to_time(meeting_start)\n            end_time = minutes_to_time(meeting_end)\n            return f\"{start_time}:{end_time}\"\n    \n    return None\n\n# Define participants' schedules\nparticipants_schedules = [\n    [(\"10:00\", \"10:30\"), (\"16:00\", \"16:30\")],  # Emily\n    [],                                         # Mason\n    [(\"10:30\", \"11:00\"), (\"14:00\", \"14:30\")],  # Maria\n    [(\"09:30\", \"10:00\"), (\"10:30\", \"12:30\"), (\"13:30\", \"14:00\"), (\"14:30\", \"15:30\"), (\"16:00\", \"17:00\")],  # Carl\n    [(\"09:30\", \"11:00\"), (\"11:30\", \"12:00\"), (\"12:30\", \"13:30\"), (\"14:00\", \"15:00\"), (\"16:00\", \"17:00\")],  # David\n    [(\"09:30\", \"10:30\"), (\"11:00\", \"11:30\"), (\"12:30\", \"13:30\"), (\"14:30\", \"17:00\")]  # Frank\n]\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_schedules, \"Monday\", \"09:00\", \"17:00\", 30)\n\n# Output the result\nprint(f\"{{{meeting_time}}}\")\nprint(\"Monday\")\n```",
            "count": "calendar_scheduling_example_360"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "11:30",
                "end_time": "12:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "12:30",
                "end_time": "13:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n\n    # Define participants' busy times in minutes since midnight\n    jeffrey_busy = [\n        (9 * 60 + 30, 10 * 60),\n        (10 * 60 + 30, 11 * 60)\n    ]\n    virginia_busy = [\n        (9 * 60, 9 * 60 + 30),\n        (10 * 60, 10 * 60 + 30),\n        (14 * 60 + 30, 15 * 60),\n        (16 * 60, 16 * 60 + 30)\n    ]\n    melissa_busy = [\n        (9 * 60, 11 * 60 + 30),\n        (12 * 60, 12 * 60 + 30),\n        (13 * 60, 15 * 60),\n        (16 * 60, 17 * 60)\n    ]\n    melissa_preference_end = 14 * 60  # Prefers not to meet after 14:00\n\n    # Combine all busy times\n    all_busy = jeffrey_busy + virginia_busy + melissa_busy\n\n    # Generate available slots (gaps between busy times)\n    all_busy.sort()  # Sort by start time\n    available_slots = []\n    prev_end = work_start\n\n    for start, end in all_busy:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n\n    # Filter slots that are at least 30 minutes and meet Melissa's preference\n    meeting_duration = 30\n    possible_slots = []\n    for start, end in available_slots:\n        if end - start >= meeting_duration:\n            if start < melissa_preference_end:\n                possible_slots.append((start, end))\n\n    # Select the earliest possible slot\n    if possible_slots:\n        chosen_start, chosen_end = possible_slots[0]\n        # Convert back to HH:MM format\n        start_hh = chosen_start // 60\n        start_mm = chosen_start % 60\n        end_time = chosen_start + meeting_duration\n        end_hh = end_time // 60\n        end_mm = end_time % 60\n        # Format the output\n        time_range = f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n        print(f\"Monday, {time_range}\")\n    else:\n        print(\"No suitable time found.\")\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_30"
        },
        {
            "final_program_time": {
                "day": "Wednesday",
                "start_time": "14:30",
                "end_time": "15:30"
            },
            "expected_time": {
                "day": "Wednesday",
                "start_time": "14:30",
                "end_time": "15:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours and days\n    work_hours_start = 9 * 60  # 9:00 in minutes\n    work_hours_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Define busy times for Natalie and William in minutes since midnight\n    natalie_busy = {\n        'Monday': [(9*60, 9*60 + 30), (10*60, 12*60), (12*60 + 30, 13*60), (14*60, 14*60 + 30), (15*60, 16*60 + 30)],\n        'Tuesday': [(9*60, 9*60 + 30), (10*60, 10*60 + 30), (12*60 + 30, 14*60), (16*60, 17*60)],\n        'Wednesday': [(11*60, 11*60 + 30), (16*60, 16*60 + 30)],\n        'Thursday': [(10*60, 11*60), (11*60 + 30, 15*60), (15*60 + 30, 16*60), (16*60 + 30, 17*60)]\n    }\n    \n    william_busy = {\n        'Monday': [(9*60 + 30, 11*60), (11*60 + 30, 17*60)],\n        'Tuesday': [(9*60, 13*60), (13*60 + 30, 16*60)],\n        'Wednesday': [(9*60, 12*60 + 30), (13*60, 14*60 + 30), (15*60 + 30, 16*60), (16*60 + 30, 17*60)],\n        'Thursday': [(9*60, 10*60 + 30), (11*60, 11*60 + 30), (12*60, 12*60 + 30), (13*60, 14*60), (15*60, 17*60)]\n    }\n    \n    meeting_duration = 60  # 1 hour in minutes\n    \n    for day in days:\n        # Combine and sort all busy intervals for both participants\n        combined_busy = natalie_busy.get(day, []) + william_busy.get(day, [])\n        combined_busy.sort()\n        \n        # Find free intervals\n        free_intervals = []\n        prev_end = work_hours_start\n        \n        for start, end in combined_busy:\n            if start > prev_end:\n                free_intervals.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_hours_end:\n            free_intervals.append((prev_end, work_hours_end))\n        \n        # Check if any free interval is long enough\n        for start, end in free_intervals:\n            if end - start >= meeting_duration:\n                meeting_start = start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                return f\"{day}, {start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    \n    return \"No suitable time found.\"\n\n# Run the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_875"
        },
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "9:30",
                "end_time": "10:30"
            },
            "expected_time": {
                "day": "Tuesday",
                "start_time": "9:30",
                "end_time": "10:30"
            },
            "has_error": false,
            "raw_model_response": "```python\nfrom typing import Dict, List, Tuple\n\ndef find_meeting_time(brian_busy: Dict[str, List[Tuple[str, str]]], \n                     julia_busy: Dict[str, List[Tuple[str, str]]], \n                     duration: int = 60,\n                     work_hours: Tuple[str, str] = ('09:00', '17:00'),\n                     days_order: List[str] = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'],\n                     brian_avoid_days: List[str] = ['Monday']) -> Tuple[str, str]:\n    \"\"\"\n    Finds the earliest available meeting time for Brian and Julia.\n    \n    Args:\n        brian_busy: Dictionary mapping days to list of busy time ranges for Brian.\n        julia_busy: Dictionary mapping days to list of busy time ranges for Julia.\n        duration: Duration of the meeting in minutes.\n        work_hours: Tuple of start and end time of work hours in 'HH:MM' format.\n        days_order: List of days in order to check.\n        brian_avoid_days: List of days Brian wants to avoid.\n    \n    Returns:\n        A tuple of (day, time_range) where time_range is in 'HH:MM-HH:MM' format.\n    \"\"\"\n    def time_to_minutes(time_str: str) -> int:\n        \"\"\"Converts 'HH:MM' time string to minutes since midnight.\"\"\"\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes: int) -> str:\n        \"\"\"Converts minutes since midnight to 'HH:MM' time string.\"\"\"\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    def merge_busy_slots(busy_slots: List[Tuple[str, str]]) -> List[Tuple[int, int]]:\n        \"\"\"Merges overlapping or adjacent busy slots and converts to minutes.\"\"\"\n        if not busy_slots:\n            return []\n        # Convert to minutes and sort\n        slots = [(time_to_minutes(start), time_to_minutes(end)) for start, end in busy_slots]\n        slots.sort()\n        merged = [slots[0]]\n        for current_start, current_end in slots[1:]:\n            last_start, last_end = merged[-1]\n            if current_start <= last_end:\n                # Overlapping or adjacent, merge them\n                merged[-1] = (last_start, max(last_end, current_end))\n            else:\n                merged.append((current_start, current_end))\n        return merged\n    \n    work_start, work_end = map(time_to_minutes, work_hours)\n    \n    for day in days_order:\n        if day in brian_avoid_days:\n            continue\n        \n        # Get busy slots for both participants\n        brian_day_slots = brian_busy.get(day, [])\n        julia_day_slots = julia_busy.get(day, [])\n        \n        # Merge and combine busy slots\n        brian_merged = merge_busy_slots(brian_day_slots)\n        julia_merged = merge_busy_slots(julia_day_slots)\n        \n        # Combine all busy slots and sort\n        all_busy = brian_merged + julia_merged\n        all_busy.sort()\n        \n        # Find available slots\n        prev_end = work_start\n        available_slots = []\n        for busy_start, busy_end in all_busy:\n            if busy_start > prev_end:\n                available_slots.append((prev_end, busy_start))\n            prev_end = max(prev_end, busy_end)\n        if prev_end < work_end:\n            available_slots.append((prev_end, work_end))\n        \n        # Check for a slot that can fit the meeting\n        for slot_start, slot_end in available_slots:\n            if slot_end - slot_start >= duration:\n                meeting_start = slot_start\n                meeting_end = meeting_start + duration\n                time_range = f\"{minutes_to_time(meeting_start)}-{minutes_to_time(meeting_end)}\"\n                return (day, time_range)\n    \n    return (\"No day found\", \"\")\n\n# Define busy schedules\nbrian_busy = {\n    'Monday': [('9:30', '10:00'), ('12:30', '14:30'), ('15:30', '16:00')],\n    'Tuesday': [('9:00', '9:30')],\n    'Wednesday': [('12:30', '14:00'), ('16:30', '17:00')],\n    'Thursday': [('11:00', '11:30'), ('13:00', '13:30'), ('16:30', '17:00')],\n    'Friday': [('9:30', '10:00'), ('10:30', '11:00'), ('13:00', '13:30'), ('15:00', '16:00'), ('16:30', '17:00')]\n}\n\njulia_busy = {\n    'Monday': [('9:00', '10:00'), ('11:00', '11:30'), ('12:30', '13:00'), ('15:30', '16:00')],\n    'Tuesday': [('13:00', '14:00'), ('16:00', '16:30')],\n    'Wednesday': [('9:00', '11:30'), ('12:00', '12:30'), ('13:00', '17:00')],\n    'Thursday': [('9:00', '10:30'), ('11:00', '17:00')],\n    'Friday': [('9:00', '10:00'), ('10:30', '11:30'), ('12:30', '14:00'), ('14:30', '15:00'), ('15:30', '16:00')]\n}\n\n# Find meeting time\nday, time_range = find_meeting_time(brian_busy, julia_busy, duration=60, brian_avoid_days=['Monday'])\n\n# Output the result\nstart_time, end_time = time_range.split('-')\nprint(f\"{day} {start_time}:{end_time}\")\n```",
            "count": "calendar_scheduling_example_978"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "11:00",
                "end_time": "11:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "12:30",
                "end_time": "13:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration_minutes):\n    # Convert work hours to minutes since midnight for easier calculation\n    work_start = work_hours_start[0] * 60 + work_hours_start[1]\n    work_end = work_hours_end[0] * 60 + work_hours_end[1]\n    \n    # Initialize the free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's schedule to find common free slots\n    for schedule in participants_schedules:\n        busy_slots = []\n        for busy in schedule:\n            start = busy[0] * 60 + busy[1]\n            end = busy[2] * 60 + busy[3]\n            busy_slots.append((start, end))\n        \n        # Sort the busy slots by start time\n        busy_slots.sort()\n        \n        # Merge overlapping or adjacent busy slots\n        merged_busy = []\n        for busy in busy_slots:\n            if not merged_busy:\n                merged_busy.append(busy)\n            else:\n                last_start, last_end = merged_busy[-1]\n                current_start, current_end = busy\n                if current_start <= last_end:\n                    new_end = max(last_end, current_end)\n                    merged_busy[-1] = (last_start, new_end)\n                else:\n                    merged_busy.append(busy)\n        \n        # Subtract busy slots from free slots\n        new_free_slots = []\n        for free_start, free_end in free_slots:\n            current_free_start = free_start\n            for busy_start, busy_end in merged_busy:\n                if busy_start > current_free_start:\n                    new_free_slots.append((current_free_start, busy_start))\n                current_free_start = max(current_free_start, busy_end)\n            if current_free_start < free_end:\n                new_free_slots.append((current_free_start, free_end))\n        free_slots = new_free_slots\n    \n    # Find the first free slot that can accommodate the meeting\n    for slot in free_slots:\n        start, end = slot\n        duration = end - start\n        if duration >= meeting_duration_minutes:\n            meeting_start = start\n            meeting_end = meeting_start + meeting_duration_minutes\n            return (meeting_start, meeting_end)\n    \n    return None\n\ndef main():\n    # Define participants' schedules in HH:MM format converted to tuples (HH, MM, HH, MM)\n    participants_schedules = [\n        # Stephen's busy times: 10:00-10:30, 12:00-12:30\n        [(10, 0, 10, 30), (12, 0, 12, 30)],\n        # Brittany's busy times: 11:00-11:30, 13:30-14:00, 15:30-16:00, 16:30-17:00\n        [(11, 0, 11, 30), (13, 30, 14, 0), (15, 30, 16, 0), (16, 30, 17, 0)],\n        # Dorothy's busy times: 9:00-9:30, 10:00-10:30, 11:00-12:30, 13:00-15:00, 15:30-17:00\n        [(9, 0, 9, 30), (10, 0, 10, 30), (11, 0, 12, 30), (13, 0, 15, 0), (15, 30, 17, 0)],\n        # Rebecca's busy times: 9:30-10:30, 11:00-11:30, 12:00-12:30, 13:00-17:00\n        [(9, 30, 10, 30), (11, 0, 11, 30), (12, 0, 12, 30), (13, 0, 17, 0)],\n        # Jordan's busy times: 9:00-9:30, 10:00-11:00, 11:30-12:00, 13:00-15:00, 15:30-16:30\n        [(9, 0, 9, 30), (10, 0, 11, 0), (11, 30, 12, 0), (13, 0, 15, 0), (15, 30, 16, 30)]\n    ]\n    \n    # Work hours: 9:00 to 17:00\n    work_hours_start = (9, 0)\n    work_hours_end = (17, 0)\n    \n    # Meeting duration: 30 minutes\n    meeting_duration_minutes = 30\n    \n    # Find the meeting time\n    meeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, meeting_duration_minutes)\n    \n    if meeting_time:\n        start_min, end_min = meeting_time\n        start_hh = start_min // 60\n        start_mm = start_min % 60\n        end_hh = end_min // 60\n        end_mm = end_min % 60\n        print(f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\")\n        print(\"Monday\")\n    else:\n        print(\"No suitable time found\")\n\nif __name__ == \"__main__\":\n    main()\n```",
            "count": "calendar_scheduling_example_307"
        },
        {
            "final_program_time": {
                "day": null,
                "start_time": null,
                "end_time": null
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "16:00",
                "end_time": "17:00"
            },
            "has_error": true,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes, day):\n    # Convert all time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    \n    # Collect all busy intervals for all participants\n    busy_intervals = []\n    for schedule in participents_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find available slots by merging busy intervals\n    available_slots = []\n    prev_end = work_start\n    \n    for start, end in busy_intervals:\n        if start > prev_end:\n            available_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    if prev_end < work_end:\n        available_slots.append((prev_end, work_end))\n    \n    # Check each available slot for sufficient duration\n    for slot in available_slots:\n        slot_start, slot_end = slot\n        if slot_end - slot_start >= duration_minutes:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_minutes\n            return (minutes_to_time(meeting_start), minutes_to_time(meeting_end))\n    \n    return None\n\n# Define the problem parameters\nparticipants_schedules = [\n    [\"10:00 to 10:30\", \"14:30 to 16:00\"],  # Kayla's schedule\n    [\"09:00 to 13:00\", \"13:30 to 15:00\", \"15:30 to 16:00\"]  # Rebecca's schedule\n]\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nduration_minutes = 60\nday = \"Monday\"\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, work_hours_start, work_hours_end, duration_minutes, day)\n\n# Output the result\nif meeting_time:\n    start_time, end_time = meeting_time\n    print(f\"{start_time}:{end_time}\")\n    print(day)\nelse:\n    print(\"No suitable meeting time found.\")\n```\n\nThe output of this script will be:\n```\n16:00:17:00\nMonday\n```",
            "count": "calendar_scheduling_example_541"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "11:30",
                "end_time": "12:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "11:30",
                "end_time": "12:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, day, work_hours, duration):\n    start_work, end_work = work_hours\n    busy_times = []\n    \n    # Collect all busy times for each participant\n    for schedule in participants_schedules:\n        busy_times.extend(schedule)\n    \n    # Sort all busy times by start time\n    busy_times.sort()\n    \n    # Find free slots by checking gaps between busy times\n    free_slots = []\n    previous_end = start_work\n    \n    for start, end in busy_times:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the slot after the last busy time\n    if previous_end < end_work:\n        free_slots.append((previous_end, end_work))\n    \n    # Merge overlapping or adjacent busy times (not needed here as we process all at once)\n    # Now find the first free slot that can fit the duration\n    for slot_start, slot_end in free_slots:\n        if (slot_end - slot_start) >= duration:\n            return (slot_start, slot_start + duration)\n    \n    return None\n\ndef main():\n    # Define participants' schedules in 24-hour format as (start, end) tuples in minutes since 9:00 (540)\n    # Convert all times to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    # Participants' schedules in (start, end) in minutes since midnight\n    andrea = []\n    jack = [(time_to_minutes('9:00'), time_to_minutes('9:30')), (time_to_minutes('14:00'), time_to_minutes('14:30'))]\n    madison = [(time_to_minutes('9:30'), time_to_minutes('10:30')), (time_to_minutes('13:00'), time_to_minutes('14:00')), \n               (time_to_minutes('15:00'), time_to_minutes('15:30')), (time_to_minutes('16:30'), time_to_minutes('17:00'))]\n    rachel = [(time_to_minutes('9:30'), time_to_minutes('10:30')), (time_to_minutes('11:00'), time_to_minutes('11:30')), \n              (time_to_minutes('12:00'), time_to_minutes('13:30')), (time_to_minutes('14:30'), time_to_minutes('15:30')), \n              (time_to_minutes('16:00'), time_to_minutes('17:00'))]\n    douglas = [(time_to_minutes('9:00'), time_to_minutes('11:30')), (time_to_minutes('12:00'), time_to_minutes('16:30'))]\n    ryan = [(time_to_minutes('9:00'), time_to_minutes('9:30')), (time_to_minutes('13:00'), time_to_minutes('14:00')), \n            (time_to_minutes('14:30'), time_to_minutes('17:00'))]\n    \n    participants_schedules = [andrea, jack, madison, rachel, douglas, ryan]\n    day = \"Monday\"\n    work_hours = (time_to_minutes('9:00'), time_to_minutes('17:00'))\n    duration = 30  # minutes\n    \n    # Find the meeting time\n    meeting_time = find_meeting_time(participants_schedules, day, work_hours, duration)\n    \n    if meeting_time:\n        start, end = meeting_time\n        start_time = minutes_to_time(start)\n        end_time = minutes_to_time(end)\n        print(f\"{start_time}:{end_time}:{day}\")\n    else:\n        print(\"No suitable time found.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
            "count": "calendar_scheduling_example_396"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "9:00",
                "end_time": "9:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "12:30",
                "end_time": "13:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n\n    # Convert schedules to minutes since midnight\n    christine_busy = [\n        (11 * 60, 11 * 60 + 30),   # 11:00-11:30\n        (15 * 60, 15 * 60 + 30)    # 15:00-15:30\n    ]\n    \n    helen_busy = [\n        (9 * 60 + 30, 10 * 60 + 30),  # 9:30-10:30\n        (11 * 60, 11 * 60 + 30),      # 11:00-11:30\n        (12 * 60, 12 * 60 + 30),      # 12:00-12:30\n        (13 * 60 + 30, 16 * 60),      # 13:30-16:00\n        (16 * 60 + 30, 17 * 60)       # 16:30-17:00\n    ]\n    \n    # Helen cannot meet after 15:00\n    helen_no_meet_after = 15 * 60  # 15:00\n    \n    meeting_duration = 30  # minutes\n    \n    # Combine and sort all busy intervals for both participants\n    all_busy = christine_busy + helen_busy\n    all_busy.sort()\n    \n    # Find available slots\n    available_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            available_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    if work_end > previous_end:\n        available_slots.append((previous_end, work_end))\n    \n    # Filter slots that meet all constraints\n    valid_slots = []\n    for start, end in available_slots:\n        # Ensure slot is at least meeting_duration long\n        if end - start >= meeting_duration:\n            # Ensure Helen can meet (before 15:00)\n            slot_end = start + meeting_duration\n            if slot_end <= helen_no_meet_after:\n                valid_slots.append((start, slot_end))\n    \n    if not valid_slots:\n        return None\n    \n    # Select the earliest valid slot\n    meeting_start, meeting_end = valid_slots[0]\n    \n    # Convert back to HH:MM format\n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n    \n    start_time = minutes_to_time(meeting_start)\n    end_time = minutes_to_time(meeting_end)\n    \n    return f\"Monday {start_time}:{end_time}\"\n\n# Execute and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_579"
        },
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "12:00",
                "end_time": "13:00"
            },
            "expected_time": {
                "day": "Tuesday",
                "start_time": "12:00",
                "end_time": "13:00"
            },
            "has_error": false,
            "raw_model_response": "```python\nfrom datetime import datetime, timedelta\n\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = datetime.strptime(\"09:00\", \"%H:%M\").time()\n    work_end = datetime.strptime(\"17:00\", \"%H:%M\").time()\n    days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\"]\n    \n    # Define busy times for each participant per day\n    carl_busy = {\n        \"Monday\": [(\"11:00\", \"11:30\")],\n        \"Tuesday\": [(\"14:30\", \"15:00\")],\n        \"Wednesday\": [(\"10:00\", \"11:30\"), (\"13:00\", \"13:30\")],\n        \"Thursday\": [(\"13:30\", \"14:00\"), (\"16:00\", \"16:30\")]\n    }\n    \n    margaret_busy = {\n        \"Monday\": [(\"09:00\", \"10:30\"), (\"11:00\", \"17:00\")],\n        \"Tuesday\": [(\"09:30\", \"12:00\"), (\"13:30\", \"14:00\"), (\"15:30\", \"17:00\")],\n        \"Wednesday\": [(\"09:30\", \"12:00\"), (\"12:30\", \"13:00\"), (\"13:30\", \"14:30\"), (\"15:00\", \"17:00\")],\n        \"Thursday\": [(\"10:00\", \"12:00\"), (\"12:30\", \"14:00\"), (\"14:30\", \"17:00\")]\n    }\n    \n    # Convert busy times to datetime.time for easier comparison\n    def parse_busy_times(busy_dict):\n        parsed = {}\n        for day, slots in busy_dict.items():\n            parsed[day] = []\n            for start, end in slots:\n                start_time = datetime.strptime(start, \"%H:%M\").time()\n                end_time = datetime.strptime(end, \"%H:%M\").time()\n                parsed[day].append((start_time, end_time))\n        return parsed\n    \n    carl_busy_parsed = parse_busy_times(carl_busy)\n    margaret_busy_parsed = parse_busy_times(margaret_busy)\n    \n    # Check if a time slot is available for both participants\n    def is_available(day, start_time, end_time):\n        # Check Carl's availability\n        for busy_start, busy_end in carl_busy_parsed.get(day, []):\n            if not (end_time <= busy_start or start_time >= busy_end):\n                return False\n        # Check Margaret's availability\n        for busy_start, busy_end in margaret_busy_parsed.get(day, []):\n            if not (end_time <= busy_start or start_time >= busy_end):\n                return False\n        return True\n    \n    # Iterate through each day (excluding Thursday first due to Carl's preference)\n    preferred_days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\"]\n    # Move Thursday to the end of the list to prioritize other days\n    preferred_days.remove(\"Thursday\")\n    preferred_days.append(\"Thursday\")\n    \n    meeting_duration = timedelta(hours=1)\n    time_slot = timedelta(minutes=30)  # Check every 30 minutes\n    \n    for day in preferred_days:\n        current_time = datetime.combine(datetime.today(), work_start)\n        end_time = datetime.combine(datetime.today(), work_end)\n        \n        while current_time + meeting_duration <= end_time:\n            slot_start = current_time.time()\n            slot_end = (current_time + meeting_duration).time()\n            \n            if is_available(day, slot_start, slot_end):\n                # Format the output as HH:MM:HH:MM\n                start_str = slot_start.strftime(\"%H:%M\")\n                end_str = slot_end.strftime(\"%H:%M\")\n                print(f\"{day}: {start_str}:{end_str}\")\n                return\n            \n            current_time += time_slot\n    \n    print(\"No suitable time found.\")\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_858"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "15:00",
                "end_time": "15:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "15:00",
                "end_time": "15:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert each participant's busy slots to minutes\n    # Natalie: free all day\n    natalie_busy = []\n    \n    # David: busy 11:30-12:00, 14:30-15:00; prefers after 14:00\n    david_busy = [(11 * 60 + 30, 12 * 60), (14 * 60 + 30, 15 * 60)]\n    david_preference = 14 * 60  # prefers after 14:00\n    \n    # Douglas: busy 9:30-10:00, 11:30-12:00, 13:00-13:30, 14:30-15:00\n    douglas_busy = [(9 * 60 + 30, 10 * 60), (11 * 60 + 30, 12 * 60),\n                    (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60)]\n    \n    # Ralph: busy 9:00-9:30, 10:00-11:00, 11:30-12:30, 13:30-15:00, 15:30-16:00, 16:30-17:00\n    ralph_busy = [(9 * 60, 9 * 60 + 30), (10 * 60, 11 * 60),\n                  (11 * 60 + 30, 12 * 60 + 30), (13 * 60 + 30, 15 * 60),\n                  (15 * 60 + 30, 16 * 60), (16 * 60 + 30, 17 * 60)]\n    \n    # Jordan: busy 9:00-10:00, 12:00-12:30, 13:00-13:30, 14:30-15:00, 15:30-17:00\n    jordan_busy = [(9 * 60, 10 * 60), (12 * 60, 12 * 60 + 30),\n                   (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60),\n                   (15 * 60 + 30, 17 * 60)]\n    \n    # Combine all busy slots\n    all_busy = david_busy + douglas_busy + ralph_busy + jordan_busy\n    \n    # Sort busy slots by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy slots\n    free_slots = []\n    previous_end = work_start\n    \n    for start, end in all_busy:\n        if start > previous_end:\n            free_slots.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    \n    # Check the end of the day\n    if previous_end < work_end:\n        free_slots.append((previous_end, work_end))\n    \n    # Filter free slots that are at least 30 minutes and meet David's preference\n    meeting_duration = 30\n    valid_slots = []\n    \n    for start, end in free_slots:\n        if end - start >= meeting_duration and start >= david_preference:\n            valid_slots.append((start, end))\n    \n    # Select the earliest valid slot\n    if valid_slots:\n        meeting_start = valid_slots[0][0]\n        meeting_end = meeting_start + meeting_duration\n    else:\n        return \"No suitable time found.\"\n    \n    # Convert minutes back to HH:MM format\n    def minutes_to_time(minutes):\n        hours = minutes // 60\n        mins = minutes % 60\n        return f\"{hours:02d}:{mins:02d}\"\n    \n    start_time = minutes_to_time(meeting_start)\n    end_time = minutes_to_time(meeting_end)\n    \n    return f\"{start_time}:{end_time}\", \"Monday\"\n\n# Run the function and print the result\ntime_range, day = find_meeting_time()\nprint(f\"{time_range} {day}\")\n```\n\nThe output of this script will be:\n```\n15:00:15:30 Monday\n```",
            "count": "calendar_scheduling_example_227"
        },
        {
            "final_program_time": {
                "day": "Wednesday",
                "start_time": "11:30",
                "end_time": "12:00"
            },
            "expected_time": {
                "day": "Wednesday",
                "start_time": "11:30",
                "end_time": "12:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    meeting_duration = 30  # minutes\n\n    # Define busy slots for Nicole and Ruth in minutes since start of day\n    nicole_busy = {\n        'Monday': [(9*60, 9*60 + 30), (13*60, 13*60 + 30), (14*60 + 30, 15*60 + 30)],\n        'Tuesday': [(9*60, 9*60 + 30), (11*60 + 30, 13*60 + 30), (14*60 + 30, 15*60 + 30)],\n        'Wednesday': [(10*60, 11*60), (12*60 + 30, 15*60), (16*60, 17*60)]\n    }\n    \n    ruth_busy = {\n        'Monday': [(9*60, 17*60)],  # Entire day blocked\n        'Tuesday': [(9*60, 17*60)],  # Entire day blocked\n        'Wednesday': [\n            (9*60, 10*60 + 30),\n            (11*60, 11*60 + 30),\n            (12*60, 12*60 + 30),\n            (13*60 + 30, 15*60 + 30),\n            (16*60, 16*60 + 30)\n        ]\n    }\n    \n    # Ruth's additional constraint: no meetings after 13:30 on Wednesday\n    ruth_no_meet_after = 13 * 60 + 30  # 13:30 in minutes\n    \n    # Iterate through each day to find a suitable slot\n    for day in days:\n        if day == 'Wednesday':\n            # Adjust work_end for Ruth on Wednesday\n            effective_end = min(work_end, ruth_no_meet_after)\n        else:\n            effective_end = work_end\n        \n        # Generate all possible slots for the day\n        possible_slots = []\n        current_time = work_start\n        \n        # Merge and sort busy slots for both participants\n        all_busy = nicole_busy.get(day, []) + ruth_busy.get(day, [])\n        all_busy.sort()\n        \n        # Find free slots by checking gaps between busy slots\n        for busy_start, busy_end in all_busy:\n            if current_time < busy_start:\n                possible_slots.append((current_time, busy_start))\n            current_time = max(current_time, busy_end)\n        \n        # Check the slot after the last busy slot\n        if current_time < effective_end:\n            possible_slots.append((current_time, effective_end))\n        \n        # Check each possible slot for availability\n        for slot_start, slot_end in possible_slots:\n            slot_duration = slot_end - slot_start\n            if slot_duration >= meeting_duration:\n                # Found a suitable slot\n                start_time = slot_start\n                end_time = start_time + meeting_duration\n                \n                # Format the time as HH:MM\n                def format_time(minutes):\n                    hours = minutes // 60\n                    mins = minutes % 60\n                    return f\"{hours:02d}:{mins:02d}\"\n                \n                start_str = format_time(start_time)\n                end_str = format_time(end_time)\n                return f\"{day}:{start_str}:{end_str}\"\n    \n    return \"No suitable time found.\"\n\n# Run the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_791"
        },
        {
            "final_program_time": {
                "day": null,
                "start_time": null,
                "end_time": null
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "11:30",
                "end_time": "12:00"
            },
            "has_error": true,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, work_hours, duration, day):\n    # Convert time strings to minutes for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = work_hours.split(' to ')\n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Initialize busy slots for all participants\n    busy_slots = []\n    for schedule in participents_schedules:\n        for busy in schedule:\n            start, end = busy.split(' to ')\n            start_min = time_to_minutes(start)\n            end_min = time_to_minutes(end)\n            busy_slots.append((start_min, end_min))\n    \n    # Sort all busy slots by start time\n    busy_slots.sort()\n    \n    # Find all free slots\n    free_slots = []\n    prev_end = work_start_min\n    for start, end in busy_slots:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    if prev_end < work_end_min:\n        free_slots.append((prev_end, work_end_min))\n    \n    # Check each free slot for availability\n    duration_min = duration * 60\n    for slot in free_slots:\n        start, end = slot\n        if end - start >= duration_min:\n            meeting_end = start + duration_min\n            return f\"{minutes_to_time(start)}:{minutes_to_time(meeting_end)}\", day\n    \n    return None, None\n\n# Define the task parameters\nparticipants_schedules = [\n    [\"12:00 to 12:30\", \"15:30 to 16:00\"],  # Denise\n    [],                                    # Angela\n    [\"9:00 to 11:30\", \"12:00 to 13:00\", \"14:00 to 14:30\", \"15:00 to 17:00\"]  # Natalie\n]\nwork_hours = \"9:00 to 17:00\"\nmeeting_duration = 0.5  # in hours\nday = \"Monday\"\n\n# Find the earliest meeting time\nmeeting_time, day = find_meeting_time(participants_schedules, work_hours, meeting_duration, day)\n\n# Output the result\nprint(f\"{meeting_time}:{day}\")\n```",
            "count": "calendar_scheduling_example_70"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "10:00",
                "end_time": "11:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "10:00",
                "end_time": "11:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, day, work_start, work_end, duration):\n    # Convert time strings to minutes since midnight for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    duration_min = duration * 60\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find the earliest available slot\n    prev_end = work_start_min\n    for start, end in busy_intervals:\n        if start > prev_end:\n            available_start = prev_end\n            available_end = start\n            if available_end - available_start >= duration_min:\n                return (minutes_to_time(available_start), minutes_to_time(available_start + duration_min))\n        prev_end = max(prev_end, end)\n    \n    # Check the slot after the last busy interval\n    if work_end_min - prev_end >= duration_min:\n        return (minutes_to_time(prev_end), minutes_to_time(prev_end + duration_min))\n    \n    return None\n\n# Define the participants' schedules\nparticipants_schedules = [\n    [\"12:30 to 13:30\", \"14:30 to 15:00\", \"16:30 to 17:00\"],  # Olivia\n    [],  # Anna\n    [\"09:00 to 10:00\", \"11:30 to 16:00\", \"16:30 to 17:00\"],  # Virginia\n    [\"09:00 to 09:30\", \"11:00 to 11:30\", \"13:00 to 14:00\", \"14:30 to 16:00\", \"16:30 to 17:00\"],  # Paul\n]\n\n# Define meeting parameters\nday = \"Monday\"\nwork_start = \"09:00\"\nwork_end = \"17:00\"\nduration = 1  # in hours\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, day, work_start, work_end, duration)\n\nif meeting_time:\n    start_time, end_time = meeting_time\n    print(f\"{start_time}:{end_time}\")\n    print(day)\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_106"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "14:00",
                "end_time": "14:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "14:00",
                "end_time": "14:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration_minutes):\n    # Convert all time strings to minutes since 9:00 (assuming work_hours start at 9:00)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return (hh - 9) * 60 + mm  # Subtract 9 to start from 0 at 9:00\n    \n    work_start = time_to_minutes(work_hours[0])\n    work_end = time_to_minutes(work_hours[1])\n    duration = duration_minutes\n    \n    # Initialize free slots as the entire work day\n    free_slots = [(work_start, work_end)]\n    \n    # Process each participant's busy slots\n    for busy_slots in participants_busy:\n        new_free_slots = []\n        for busy_start, busy_end in busy_slots:\n            busy_start_min = time_to_minutes(busy_start)\n            busy_end_min = time_to_minutes(busy_end)\n            updated_free_slots = []\n            for slot_start, slot_end in free_slots:\n                if busy_end_min <= slot_start or busy_start_min >= slot_end:\n                    # No overlap, keep the slot\n                    updated_free_slots.append((slot_start, slot_end))\n                else:\n                    # Overlap, split the slot\n                    if slot_start < busy_start_min:\n                        updated_free_slots.append((slot_start, busy_start_min))\n                    if busy_end_min < slot_end:\n                        updated_free_slots.append((busy_end_min, slot_end))\n            free_slots = updated_free_slots\n        if not free_slots:\n            return None  # No common free time\n    \n    # Find the first slot that fits the duration\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = 9 + minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            start_time = minutes_to_time(meeting_start)\n            end_time = minutes_to_time(meeting_end)\n            return (start_time, end_time)\n    return None\n\n# Define work hours and meeting duration\nwork_hours = (\"9:00\", \"17:00\")\nduration_minutes = 30\n\n# Define busy slots for each participant (converted to HH:MM format)\nparticipants_busy = [\n    # Patrick's busy slots\n    [(\"9:00\", \"9:30\"), (\"10:00\", \"10:30\"), (\"13:30\", \"14:00\"), (\"16:00\", \"16:30\")],\n    # Kayla's busy slots\n    [(\"12:30\", \"13:30\"), (\"15:00\", \"15:30\"), (\"16:00\", \"16:30\")],\n    # Carl's busy slots\n    [(\"10:30\", \"11:00\"), (\"12:00\", \"12:30\"), (\"13:00\", \"13:30\"), (\"14:30\", \"17:00\")],\n    # Christian's busy slots\n    [(\"9:00\", \"12:30\"), (\"13:00\", \"14:00\"), (\"14:30\", \"17:00\")],\n]\n\n# Find meeting time\nmeeting_time = find_meeting_time(participants_busy, work_hours, duration_minutes)\n\n# Output the result\nif meeting_time:\n    start, end = meeting_time\n    print(f\"{start}:{end}\")\n    print(\"Monday\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_172"
        },
        {
            "final_program_time": {
                "day": null,
                "start_time": null,
                "end_time": null
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "9:00",
                "end_time": "9:30"
            },
            "has_error": true,
            "raw_model_response": "```python\ndef find_meeting_time(participants_busy, work_hours, duration, day):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    start_work, end_work = work_hours\n    start_work_min = time_to_minutes(start_work)\n    end_work_min = time_to_minutes(end_work)\n    duration_min = duration * 60\n    \n    # Collect all busy intervals for all participants\n    all_busy = []\n    for busy_slots in participents_busy.values():\n        for slot in busy_slots:\n            start, end = slot\n            all_busy.append((time_to_minutes(start), time_to_minutes(end)))\n    \n    # Sort all busy intervals by start time\n    all_busy.sort()\n    \n    # Find free slots by checking gaps between busy intervals and work hours\n    free_slots = []\n    prev_end = start_work_min\n    \n    for start, end in all_busy:\n        if start > prev_end:\n            free_slots.append((prev_end, start))\n        prev_end = max(prev_end, end)\n    \n    # Check the slot after last busy interval until end of work day\n    if prev_end < end_work_min:\n        free_slots.append((prev_end, end_work_min))\n    \n    # Find the first free slot that can accommodate the meeting duration\n    for slot_start, slot_end in free_slots:\n        if slot_end - slot_start >= duration_min:\n            meeting_start = slot_start\n            meeting_end = meeting_start + duration_min\n            return (f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\", day)\n    \n    return None\n\n# Define the task parameters\nparticipants_busy = {\n    'Adam': [('09:30', '10:00'), ('12:30', '13:00'), ('14:30', '15:00'), ('16:30', '17:00')],\n    'Roy': [('10:00', '11:00'), ('11:30', '13:00'), ('13:30', '14:30'), ('16:30', '17:00')],\n}\nwork_hours = ('09:00', '17:00')\nmeeting_duration = 30  # minutes\nday = 'Monday'\n\n# Find the meeting time\nresult = find_meeting_time(participants_busy, work_hours, meeting_duration, day)\nif result:\n    time_range, day = result\n    print(f\"{time_range}:{day}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_594"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "9:00",
                "end_time": "9:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "9:00",
                "end_time": "9:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Convert blocked times to minutes since midnight\n    eric_blocked = [\n        (12 * 60, 13 * 60),  # 12:00-13:00\n        (14 * 60, 15 * 60)   # 14:00-15:00\n    ]\n    henry_blocked = [\n        (9 * 60 + 30, 10 * 60),    # 9:30-10:00\n        (10 * 60 + 30, 11 * 60),   # 10:30-11:00\n        (11 * 60 + 30, 12 * 60 + 30),  # 11:30-12:30\n        (13 * 60, 13 * 60 + 30),    # 13:00-13:30\n        (14 * 60 + 30, 15 * 60),   # 14:30-15:00\n        (16 * 60, 17 * 60)          # 16:00-17:00\n    ]\n    henry_preference_end = 10 * 60  # Prefers not to meet after 10:00\n\n    # Combine all blocked times for both participants\n    all_blocked = []\n    for block in eric_blocked:\n        all_blocked.append(('Eric', block[0], block[1]))\n    for block in henry_blocked:\n        all_blocked.append(('Henry', block[0], block[1]))\n    # Sort blocked times by start time\n    all_blocked.sort(key=lambda x: x[1])\n\n    # Find available slots before Henry's preference end time\n    current_time = work_start\n    for block in all_blocked:\n        start, end = block[1], block[2]\n        if start > current_time:\n            available_start = current_time\n            available_end = min(start, henry_preference_end)\n            if available_end - available_start >= meeting_duration:\n                # Found a suitable slot\n                meeting_start = available_start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                print(f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\")\n                print(\"Monday\")\n                return\n        current_time = max(current_time, end)\n    \n    # Check after current_time but before henry_preference_end\n    if henry_preference_end - current_time >= meeting_duration:\n        meeting_start = current_time\n        meeting_end = meeting_start + meeting_duration\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        print(f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\")\n        print(\"Monday\")\n        return\n    \n    # If no slot found before preference, look after (even though Henry prefers not to)\n    current_time = work_start\n    for block in all_blocked:\n        start, end = block[1], block[2]\n        if start > current_time:\n            available_start = current_time\n            available_end = start\n            if available_end - available_start >= meeting_duration:\n                # Found a suitable slot\n                meeting_start = available_start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                print(f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\")\n                print(\"Monday\")\n                return\n        current_time = max(current_time, end)\n    \n    # Check after last blocked time\n    if work_end - current_time >= meeting_duration:\n        meeting_start = current_time\n        meeting_end = meeting_start + meeting_duration\n        start_hh = meeting_start // 60\n        start_mm = meeting_start % 60\n        end_hh = meeting_end // 60\n        end_mm = meeting_end % 60\n        print(f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\")\n        print(\"Monday\")\n        return\n    \n    print(\"No suitable time found.\")\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_553"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "9:00",
                "end_time": "9:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "9:00",
                "end_time": "9:30"
            },
            "has_error": false,
            "raw_model_response": "```python\nfrom datetime import time\n\ndef find_meeting_time(terry_busy, frances_busy, days, duration_minutes=30):\n    work_start = time(9, 0)\n    work_end = time(17, 0)\n    \n    for day in days:\n        if day == \"Tuesday\":\n            continue  # Frances prefers to avoid meetings on Tuesday\n            \n        # Get all busy intervals for Terry and Frances on the current day\n        terry_day = terry_busy.get(day, [])\n        frances_day = frances_busy.get(day, [])\n        \n        # Combine and sort all busy intervals\n        all_busy = terry_day + frances_day\n        all_busy.sort()\n        \n        # Check gaps between busy intervals\n        prev_end = work_start\n        for busy_start, busy_end in all_busy:\n            if busy_start > prev_end:\n                gap_duration = (busy_start.hour * 60 + busy_start.minute) - (prev_end.hour * 60 + prev_end.minute)\n                if gap_duration >= duration_minutes:\n                    return day, prev_end, time(prev_end.hour, prev_end.minute + duration_minutes)\n            prev_end = max(prev_end, busy_end)\n        \n        # Check gap after last busy interval\n        if prev_end < work_end:\n            gap_duration = (work_end.hour * 60 + work_end.minute) - (prev_end.hour * 60 + prev_end.minute)\n            if gap_duration >= duration_minutes:\n                return day, prev_end, time(prev_end.hour, prev_end.minute + duration_minutes)\n    \n    return None\n\ndef main():\n    terry_busy = {\n        \"Monday\": [(time(10, 30), time(11, 0)), (time(12, 30), time(14, 0)), (time(15, 0), time(17, 0))],\n        \"Tuesday\": [(time(9, 30), time(10, 0)), (time(10, 30), time(11, 0)), (time(14, 0), time(14, 30)), (time(16, 0), time(16, 30))],\n        \"Wednesday\": [(time(9, 30), time(10, 30)), (time(11, 0), time(12, 0)), (time(13, 0), time(13, 30)), (time(15, 0), time(16, 0)), (time(16, 30), time(17, 0))],\n        \"Thursday\": [(time(9, 30), time(10, 0)), (time(12, 0), time(12, 30)), (time(13, 0), time(14, 30)), (time(16, 0), time(16, 30))],\n        \"Friday\": [(time(9, 0), time(11, 30)), (time(12, 0), time(12, 30)), (time(13, 30), time(16, 0)), (time(16, 30), time(17, 0))]\n    }\n    \n    frances_busy = {\n        \"Monday\": [(time(9, 30), time(11, 0)), (time(11, 30), time(13, 0)), (time(14, 0), time(14, 30)), (time(15, 0), time(16, 0))],\n        \"Tuesday\": [(time(9, 0), time(9, 30)), (time(10, 0), time(10, 30)), (time(11, 0), time(12, 0)), (time(13, 0), time(14, 30)), (time(15, 30), time(16, 30))],\n        \"Wednesday\": [(time(9, 30), time(10, 0)), (time(10, 30), time(11, 0)), (time(11, 30), time(16, 0)), (time(16, 30), time(17, 0))],\n        \"Thursday\": [(time(11, 0), time(12, 30)), (time(14, 30), time(17, 0))],\n        \"Friday\": [(time(9, 30), time(10, 30)), (time(11, 0), time(12, 30)), (time(13, 0), time(16, 0)), (time(16, 30), time(17, 0))]\n    }\n    \n    days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"]\n    result = find_meeting_time(terry_busy, frances_busy, days)\n    \n    if result:\n        day, start, end = result\n        print(f\"{day}, {start.hour:02d}:{start.minute:02d}:{end.hour:02d}:{end.minute:02d}\")\n    else:\n        print(\"No suitable time found.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
            "count": "calendar_scheduling_example_935"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "10:00",
                "end_time": "10:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "10:00",
                "end_time": "10:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(bobby_busy, michael_busy, work_hours, duration, days):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        h, m = map(int, time_str.split(':'))\n        return h * 60 + m - 540  # Subtract 540 to start from 0 (9:00)\n\n    def minutes_to_time(minutes):\n        total_minutes = minutes + 540\n        h = total_minutes // 60\n        m = total_minutes % 60\n        return f\"{h:02d}:{m:02d}\"\n\n    # Generate free slots for a person\n    def get_free_slots(busy_slots, day_hours):\n        free_slots = []\n        start_of_day = time_to_minutes(day_hours[0])\n        end_of_day = time_to_minutes(day_hours[1])\n        \n        # Sort busy slots by start time\n        busy_slots_sorted = sorted(busy_slots, key=lambda x: x[0])\n        \n        # Check before first busy slot\n        if busy_slots_sorted and busy_slots_sorted[0][0] > start_of_day:\n            free_slots.append((start_of_day, busy_slots_sorted[0][0]))\n        \n        # Check between busy slots\n        for i in range(len(busy_slots_sorted) - 1):\n            current_end = busy_slots_sorted[i][1]\n            next_start = busy_slots_sorted[i+1][0]\n            if next_start > current_end:\n                free_slots.append((current_end, next_start))\n        \n        # Check after last busy slot\n        if busy_slots_sorted and busy_slots_sorted[-1][1] < end_of_day:\n            free_slots.append((busy_slots_sorted[-1][1], end_of_day))\n        \n        # If no busy slots, the whole day is free\n        if not busy_slots_sorted:\n            free_slots.append((start_of_day, end_of_day))\n        \n        return free_slots\n\n    # Find overlapping free slots between two people\n    def find_overlapping_slots(slots1, slots2, duration):\n        overlapping = []\n        for s1 in slots1:\n            for s2 in slots2:\n                start = max(s1[0], s2[0])\n                end = min(s1[1], s2[1])\n                if end - start >= duration:\n                    overlapping.append((start, end))\n        return overlapping\n\n    # Process each day\n    for day in days:\n        # Get Bobby's busy slots for the day in minutes\n        bobby_day_busy = []\n        for slot in bobby_busy.get(day, []):\n            start, end = map(time_to_minutes, slot.split(' to '))\n            bobby_day_busy.append((start, end))\n        \n        # Get Michael's busy slots for the day in minutes\n        michael_day_busy = []\n        for slot in michael_busy.get(day, []):\n            start, end = map(time_to_minutes, slot.split(' to '))\n            michael_day_busy.append((start, end))\n        \n        # Get free slots for both\n        bobby_free = get_free_slots(bobby_day_busy, work_hours)\n        michael_free = get_free_slots(michael_day_busy, work_hours)\n        \n        # Find overlapping slots\n        overlapping = find_overlapping_slots(bobby_free, michael_free, duration)\n        \n        if overlapping:\n            # Choose the earliest slot\n            earliest_start = overlapping[0][0]\n            meeting_start = minutes_to_time(earliest_start)\n            meeting_end = minutes_to_time(earliest_start + duration)\n            return f\"{day}:{meeting_start}:{meeting_end}\"\n    \n    return \"No suitable time found.\"\n\n# Define inputs\nbobby_busy = {\n    \"Monday\": [\"14:30 to 15:00\"],\n    \"Tuesday\": [\"9:00 to 11:30\", \"12:00 to 12:30\", \"13:00 to 15:00\", \"15:30 to 17:00\"]\n}\n\nmichael_busy = {\n    \"Monday\": [\"9:00 to 10:00\", \"10:30 to 13:30\", \"14:00 to 15:00\", \"15:30 to 17:00\"],\n    \"Tuesday\": [\"9:00 to 10:30\", \"11:00 to 11:30\", \"12:00 to 14:00\", \"15:00 to 16:00\", \"16:30 to 17:00\"]\n}\n\nwork_hours = [\"9:00\", \"17:00\"]\nduration = 30  # minutes\ndays = [\"Monday\", \"Tuesday\"]\n\n# Find and print the meeting time\nresult = find_meeting_time(bobby_busy, michael_busy, work_hours, duration, days)\nprint(result)\n```",
            "count": "calendar_scheduling_example_640"
        },
        {
            "final_program_time": {
                "day": "Wednesday",
                "start_time": "15:00",
                "end_time": "16:00"
            },
            "expected_time": {
                "day": "Wednesday",
                "start_time": "15:00",
                "end_time": "16:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours and days\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n    \n    # Define busy intervals for each person per day in minutes since midnight\n    diane_busy = {\n        'Monday': [(12 * 60, 12 * 60 + 30), (15 * 60, 15 * 60 + 30)],\n        'Tuesday': [(10 * 60, 11 * 60), (11 * 60 + 30, 12 * 60), (12 * 60 + 30, 13 * 60), (16 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 9 * 60 + 30), (14 * 60 + 30, 15 * 60), (16 * 60 + 30, 17 * 60)],\n        'Thursday': [(15 * 60 + 30, 16 * 60 + 30)],\n        'Friday': [(9 * 60 + 30, 11 * 60 + 30), (14 * 60 + 30, 15 * 60), (16 * 60, 17 * 60)]\n    }\n    \n    matthew_busy = {\n        'Monday': [(9 * 60, 10 * 60), (10 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 11 * 60), (12 * 60, 14 * 60 + 30), (16 * 60, 17 * 60)],\n        'Thursday': [(9 * 60, 16 * 60)],\n        'Friday': [(9 * 60, 17 * 60)]\n    }\n    \n    # Matthew's preference: not before 12:30 on Wednesday\n    matthew_preference = {\n        'Wednesday': 12 * 60 + 30\n    }\n    \n    meeting_duration = 60  # 1 hour in minutes\n    \n    for day in days:\n        # Check if day is Wednesday and apply Matthew's preference\n        if day == 'Wednesday':\n            start_candidate = max(work_start, matthew_preference.get(day, work_start))\n        else:\n            start_candidate = work_start\n        \n        # Collect all busy intervals for the day\n        busy_intervals = []\n        if day in diane_busy:\n            busy_intervals.extend(diane_busy[day])\n        if day in matthew_busy:\n            busy_intervals.extend(matthew_busy[day])\n        \n        # Sort busy intervals by start time\n        busy_intervals.sort()\n        \n        # Find free slots\n        current_time = start_candidate\n        for interval in busy_intervals:\n            if interval[0] > current_time:\n                # Check if there's enough time before the next busy interval\n                if interval[0] - current_time >= meeting_duration:\n                    # Found a suitable slot\n                    start_time = current_time\n                    end_time = start_time + meeting_duration\n                    # Format the time as HH:MM\n                    start_str = f\"{start_time // 60:02d}:{start_time % 60:02d}\"\n                    end_str = f\"{end_time // 60:02d}:{end_time % 60:02d}\"\n                    print(f\"{start_str}:{end_str}\")\n                    print(day)\n                    return\n            # Update current_time to the end of the current busy interval\n            current_time = max(current_time, interval[1])\n        \n        # Check after the last busy interval\n        if work_end - current_time >= meeting_duration:\n            start_time = current_time\n            end_time = start_time + meeting_duration\n            start_str = f\"{start_time // 60:02d}:{start_time % 60:02d}\"\n            end_str = f\"{end_time // 60:02d}:{end_time % 60:02d}\"\n            print(f\"{start_str}:{end_str}\")\n            print(day)\n            return\n    \n    print(\"No suitable time found.\")\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_985"
        },
        {
            "final_program_time": {
                "day": null,
                "start_time": null,
                "end_time": null
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "9:30",
                "end_time": "10:00"
            },
            "has_error": true,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, meeting_duration, work_hours_start, work_hours_end):\n    # Convert time strings to minutes since start of day for easier calculation\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n\n    # Convert minutes back to time string\n    def minutes_to_time(minutes):\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n\n    work_start = time_to_minutes(work_hours_start)\n    work_end = time_to_minutes(work_hours_end)\n    duration = meeting_duration * 60\n\n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(':'))\n            busy_intervals.append((start, end))\n\n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n\n    # Find the earliest time when everyone is free\n    current_time = work_start\n    for start, end in busy_intervals:\n        if start > current_time:\n            if start - current_time >= duration:\n                return minutes_to_time(current_time), minutes_to_time(current_time + duration)\n            else:\n                current_time = end\n        else:\n            if end > current_time:\n                current_time = end\n        if current_time + duration > work_end:\n            break\n\n    # Check the remaining time after the last meeting\n    if current_time + duration <= work_end:\n        return minutes_to_time(current_time), minutes_to_time(current_time + duration)\n    else:\n        return None\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"11:30:12:00\", \"14:00:14:30\"],  # John\n    [\"12:00:12:30\", \"14:00:15:00\", \"15:30:16:00\"],  # Megan\n    [],  # Brandon\n    [\"09:00:09:30\", \"10:00:10:30\", \"11:00:14:30\", \"15:00:16:00\", \"16:30:17:00\"],  # Kimberly\n    [\"10:00:11:00\", \"11:30:14:00\", \"15:00:15:30\"],  # Sean\n    [\"09:00:09:30\", \"10:30:12:00\", \"13:00:14:30\", \"16:00:16:30\"],  # Lori\n]\n\nmeeting_duration = 0.5  # half an hour\nwork_hours_start = \"09:00\"\nwork_hours_end = \"17:00\"\nday_of_week = \"Monday\"\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, meeting_duration, work_hours_start, work_hours_end)\n\nif meeting_time:\n    start_time, end_time = meeting_time\n    print(f\"{start_time}:{end_time}\")\n    print(day_of_week)\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_337"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "10:30",
                "end_time": "11:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "13:30",
                "end_time": "14:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    \n    # Convert all schedules to minutes for easier comparison\n    # Juan's busy times: 9:00-10:30, 15:30-16:00\n    juan_busy = [(9 * 60, 10 * 60 + 30), (15 * 60 + 30, 16 * 60)]\n    # Marilyn's busy times: 11:00-11:30, 12:30-13:00\n    marilyn_busy = [(11 * 60, 11 * 60 + 30), (12 * 60 + 30, 13 * 60)]\n    # Ronald's busy times: 9:00-10:30, 12:00-12:30, 13:00-13:30, 14:00-16:30\n    ronald_busy = [(9 * 60, 10 * 60 + 30), (12 * 60, 12 * 60 + 30), \n                   (13 * 60, 13 * 60 + 30), (14 * 60, 16 * 60 + 30)]\n    \n    # Juan cannot meet after 16:00, so adjust his work_end\n    juan_work_end = 16 * 60\n    \n    # Meeting duration is 30 minutes\n    duration = 30\n    \n    # Iterate through all possible time slots in work hours\n    for start in range(work_start, work_end - duration + 1, 15):  # Check every 15 minutes\n        end = start + duration\n        # Check if the time slot is within Juan's adjusted work hours\n        if end > juan_work_end:\n            continue\n        # Check if the time slot is free for all participants\n        juan_free = all(not (busy_start <= start < busy_end or busy_start < end <= busy_end) \n                       for busy_start, busy_end in juan_busy)\n        marilyn_free = all(not (busy_start <= start < busy_end or busy_start < end <= busy_end) \n                           for busy_start, busy_end in marilyn_busy)\n        ronald_free = all(not (busy_start <= start < busy_end or busy_start < end <= busy_end) \n                       for busy_start, busy_end in ronald_busy)\n        \n        if juan_free and marilyn_free and ronald_free:\n            # Convert start and end back to HH:MM format\n            start_hh = start // 60\n            start_mm = start % 60\n            end_hh = end // 60\n            end_mm = end % 60\n            return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\", \"Monday\"\n    \n    return \"No suitable time found\", \"Monday\"\n\n# Execute the function and print the result\ntime_range, day = find_meeting_time()\nprint(f\"{time_range} {day}\")\n```",
            "count": "calendar_scheduling_example_98"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "10:30",
                "end_time": "11:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "10:30",
                "end_time": "11:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours and meeting duration\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Randy's blocked times in minutes (start, end)\n    randy_blocked = [\n        (9 * 60, 10 * 60 + 30),  # 9:00-10:30\n        (11 * 60, 15 * 60 + 30), # 11:00-15:30\n        (16 * 60, 17 * 60)        # 16:00-17:00\n    ]\n\n    # Evelyn's constraint: no meetings after 13:00\n    evelyn_max_time = 13 * 60  # 13:00 in minutes\n\n    # Find available slots for Randy (inverted blocked times)\n    randy_available = []\n    previous_end = work_start\n    for start, end in sorted(randy_blocked):\n        if start > previous_end:\n            randy_available.append((previous_end, start))\n        previous_end = max(previous_end, end)\n    if previous_end < work_end:\n        randy_available.append((previous_end, work_end))\n\n    # Filter Randy's available slots by Evelyn's constraints\n    possible_slots = []\n    for start, end in randy_available:\n        # Adjust slot to end by 13:00 for Evelyn\n        slot_end = min(end, evelyn_max_time)\n        if slot_end - start >= meeting_duration:\n            possible_slots.append((start, slot_end))\n\n    # Select the earliest possible slot\n    if possible_slots:\n        chosen_start = possible_slots[0][0]\n        chosen_end = chosen_start + meeting_duration\n        # Format the time as HH:MM:HH:MM\n        start_str = f\"{chosen_start // 60:02d}:{chosen_start % 60:02d}\"\n        end_str = f\"{chosen_end // 60:02d}:{chosen_end % 60:02d}\"\n        print(f\"{start_str}:{end_str}\")\n        print(\"Monday\")\n    else:\n        print(\"No available time slot found.\")\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_555"
        },
        {
            "final_program_time": {
                "day": "Wednesday",
                "start_time": "12:00",
                "end_time": "13:00"
            },
            "expected_time": {
                "day": "Wednesday",
                "start_time": "12:00",
                "end_time": "13:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    meeting_duration = 60  # minutes\n    \n    # Define blocked times for each participant per day in minutes since midnight\n    blocked_times = {\n        'Judith': {\n            'Monday': [(12 * 60, 12 * 60 + 30)],  # 12:00-12:30\n            'Wednesday': [(11 * 60 + 30, 12 * 60)]  # 11:30-12:00\n        },\n        'Timothy': {\n            'Monday': [\n                (9 * 60 + 30, 10 * 60),        # 9:30-10:00\n                (10 * 60 + 30, 11 * 60 + 30),  # 10:30-11:30\n                (12 * 60 + 30, 14 * 60),       # 12:30-14:00\n                (15 * 60 + 30, 17 * 60)        # 15:30-17:00\n            ],\n            'Tuesday': [\n                (9 * 60 + 30, 13 * 60),        # 9:30-13:00\n                (13 * 60 + 30, 14 * 60),       # 13:30-14:00\n                (14 * 60 + 30, 17 * 60)        # 14:30-17:00\n            ],\n            'Wednesday': [\n                (9 * 60, 9 * 60 + 30),         # 9:00-9:30\n                (10 * 60 + 30, 11 * 60),      # 10:30-11:00\n                (13 * 60 + 30, 14 * 60 + 30),  # 13:30-14:30\n                (15 * 60, 15 * 60 + 30),       # 15:00-15:30\n                (16 * 60, 16 * 60 + 30)        # 16:00-16:30\n            ]\n        }\n    }\n    \n    # Judith's preferences: avoid Monday and Wednesday before 12:00\n    preferred_days = ['Tuesday', 'Wednesday']\n    \n    # Iterate through days in preferred order\n    for day in preferred_days:\n        if day == 'Wednesday':\n            # On Wednesday, Judith prefers after 12:00\n            start_time = max(work_start, 12 * 60)\n        else:\n            start_time = work_start\n        \n        # Generate all possible slots for the day\n        current_time = start_time\n        while current_time + meeting_duration <= work_end:\n            slot_end = current_time + meeting_duration\n            conflict = False\n            \n            # Check Judith's availability\n            for block_start, block_end in blocked_times['Judith'].get(day, []):\n                if not (slot_end <= block_start or current_time >= block_end):\n                    conflict = True\n                    break\n            \n            # Check Timothy's availability if no conflict yet\n            if not conflict:\n                for block_start, block_end in blocked_times['Timothy'].get(day, []):\n                    if not (slot_end <= block_start or current_time >= block_end):\n                        conflict = True\n                        break\n            \n            if not conflict:\n                # Format the time as HH:MM:HH:MM\n                start_str = f\"{current_time // 60:02d}:{current_time % 60:02d}\"\n                end_str = f\"{slot_end // 60:02d}:{slot_end % 60:02d}\"\n                return f\"{day}: {start_str}:{end_str}\"\n            \n            current_time += 15  # Check in 15-minute increments\n    \n    # If no preferred day works, check Monday (though Judith prefers to avoid)\n    day = 'Monday'\n    current_time = work_start\n    while current_time + meeting_duration <= work_end:\n        slot_end = current_time + meeting_duration\n        conflict = False\n        \n        # Check Judith's availability\n        for block_start, block_end in blocked_times['Judith'].get(day, []):\n            if not (slot_end <= block_start or current_time >= block_end):\n                conflict = True\n                break\n        \n        # Check Timothy's availability if no conflict yet\n        if not conflict:\n            for block_start, block_end in blocked_times['Timothy'].get(day, []):\n                if not (slot_end <= block_start or current_time >= block_end):\n                    conflict = True\n                    break\n        \n        if not conflict:\n            # Format the time as HH:MM:HH:MM\n            start_str = f\"{current_time // 60:02d}:{current_time % 60:02d}\"\n            end_str = f\"{slot_end // 60:02d}:{slot_end % 60:02d}\"\n            return f\"{day}: {start_str}:{end_str}\"\n        \n        current_time += 15  # Check in 15-minute increments\n    \n    return \"No suitable time found.\"\n\n# Run the function and print the result\nprint(find_meeting_time())\n```",
            "count": "calendar_scheduling_example_784"
        },
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "12:00",
                "end_time": "13:00"
            },
            "expected_time": {
                "day": "Tuesday",
                "start_time": "12:00",
                "end_time": "13:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n    \n    # Laura's busy times in minutes since midnight for each day\n    laura_busy = {\n        'Monday': [(10*60 + 30, 11*60), (12*60 + 30, 13*60), (14*60 + 30, 15*60 + 30), (16*60, 17*60)],\n        'Tuesday': [(9*60 + 30, 10*60), (11*60, 11*60 + 30), (13*60, 13*60 + 30), (14*60 + 30, 15*60), (16*60, 17*60)],\n        'Wednesday': [(11*60 + 30, 12*60), (12*60 + 30, 13*60), (15*60 + 30, 16*60 + 30)],\n        'Thursday': [(10*60 + 30, 11*60), (12*60, 13*60 + 30), (15*60, 15*60 + 30), (16*60, 16*60 + 30)]\n    }\n    \n    # Philip's busy times in minutes since midnight for each day\n    philip_busy = {\n        'Monday': [(9*60, 17*60)],\n        'Tuesday': [(9*60, 11*60), (11*60 + 30, 12*60), (13*60, 13*60 + 30), (14*60, 14*60 + 30), (15*60, 16*60 + 30)],\n        'Wednesday': [(9*60, 10*60), (11*60, 12*60), (12*60 + 30, 16*60), (16*60 + 30, 17*60)],\n        'Thursday': [(9*60, 10*60 + 30), (11*60, 12*60 + 30), (13*60, 17*60)]\n    }\n    \n    meeting_duration = 60  # 1 hour in minutes\n    \n    # Iterate through each day (excluding Wednesday for Philip)\n    for day in days:\n        if day == 'Wednesday':\n            continue  # Philip can't meet on Wednesday\n        \n        # Get busy intervals for both participants\n        laura_day = laura_busy.get(day, [])\n        philip_day = philip_busy.get(day, [])\n        \n        # Combine and sort all busy intervals\n        all_busy = laura_day + philip_day\n        all_busy.sort()\n        \n        # Find free intervals\n        free_intervals = []\n        prev_end = work_start\n        \n        for start, end in all_busy:\n            if start > prev_end:\n                free_intervals.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if prev_end < work_end:\n            free_intervals.append((prev_end, work_end))\n        \n        # Check each free interval for availability\n        for start, end in free_intervals:\n            available_duration = end - start\n            if available_duration >= meeting_duration:\n                meeting_start = start\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                time_str = f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n                print(f\"{day}: {time_str}\")\n                return\n    \n    print(\"No suitable time found.\")\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_825"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "12:30",
                "end_time": "13:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "12:30",
                "end_time": "13:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    meeting_duration = 30  # minutes\n\n    # Define busy times for each person in minutes since midnight\n    joshua_busy = {\n        'Monday': [(15 * 60, 15 * 60 + 30)],\n        'Tuesday': [(11 * 60 + 30, 12 * 60), (13 * 60, 13 * 60 + 30), (14 * 60 + 30, 15 * 60)],\n        'Wednesday': []\n    }\n    \n    joyce_busy = {\n        'Monday': [(9 * 60, 9 * 60 + 30), (10 * 60, 11 * 60), (11 * 60 + 30, 12 * 60 + 30),\n                   (13 * 60, 15 * 60), (15 * 60 + 30, 17 * 60)],\n        'Tuesday': [(9 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60, 9 * 60 + 30), (10 * 60, 11 * 60), (12 * 60 + 30, 15 * 60 + 30),\n                      (16 * 60, 16 * 60 + 30)]\n    }\n    \n    # Joyce's preference: not before 12:00 on Monday\n    joyce_preference = {\n        'Monday': 12 * 60,\n        'Tuesday': 0,\n        'Wednesday': 0\n    }\n    \n    # Iterate through each day to find a suitable time\n    for day in days:\n        # Collect all busy intervals for both participants\n        busy_intervals = joshua_busy[day] + joyce_busy[day]\n        busy_intervals.sort()  # Sort by start time\n        \n        # Find the earliest possible start time considering Joyce's preference\n        current_start = max(work_start, joyce_preference[day])\n        \n        # Check the time slots between busy intervals\n        for interval in busy_intervals:\n            interval_start, interval_end = interval\n            if current_start + meeting_duration <= interval_start:\n                # Found a suitable slot\n                start_time = current_start\n                end_time = start_time + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                start_str = f\"{start_time // 60:02d}:{start_time % 60:02d}\"\n                end_str = f\"{end_time // 60:02d}:{end_time % 60:02d}\"\n                print(f\"{day}:{start_str}:{end_str}\")\n                return\n            # Update current_start to the end of the current busy interval\n            if interval_end > current_start:\n                current_start = interval_end\n        \n        # Check the time after the last busy interval\n        if current_start + meeting_duration <= work_end:\n            start_time = current_start\n            end_time = start_time + meeting_duration\n            start_str = f\"{start_time // 60:02d}:{start_time % 60:02d}\"\n            end_str = f\"{end_time // 60:02d}:{end_time % 60:02d}\"\n            print(f\"{day}:{start_str}:{end_str}\")\n            return\n    \n    print(\"No suitable time found.\")\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_765"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "16:30",
                "end_time": "17:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "16:30",
                "end_time": "17:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, day, work_hours_start, work_hours_end, duration_minutes):\n    # Convert all time slots to minutes since start of the day for easier calculation\n    start_work = work_hours_start[0] * 60 + work_hours_start[1]\n    end_work = work_hours_end[0] * 60 + work_hours_end[1]\n    \n    # Initialize the list of busy intervals for all participants\n    busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for block in schedule:\n            start_block = block[0][0] * 60 + block[0][1]\n            end_block = block[1][0] * 60 + block[1][1]\n            busy_intervals.append((start_block, end_block))\n    \n    # Sort all busy intervals by start time\n    busy_intervals.sort()\n    \n    # Find the earliest available slot\n    current_time = start_work\n    available_slot_end = current_time + duration_minutes\n    \n    for start, end in busy_intervals:\n        if start > current_time:\n            if available_slot_end <= start:\n                # Found a suitable slot\n                break\n            else:\n                current_time = end\n                available_slot_end = current_time + duration_minutes\n        else:\n            if current_time < end:\n                current_time = end\n                available_slot_end = current_time + duration_minutes\n    \n    # Check if the slot is within work hours\n    if available_slot_end <= end_work:\n        # Convert back to HH:MM format\n        start_hh = current_time // 60\n        start_mm = current_time % 60\n        end_hh = available_slot_end // 60\n        end_mm = available_slot_end % 60\n        return f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n    else:\n        return None\n\n# Define participants' schedules in HH:MM format\ndiane_schedule = [\n    [(9, 30), (10, 0)],\n    [(14, 30), (15, 0)]\n]\njack_schedule = [\n    [(13, 30), (14, 0)],\n    [(14, 30), (15, 0)]\n]\neugene_schedule = [\n    [(9, 0), (10, 0)],\n    [(10, 30), (11, 30)],\n    [(12, 0), (14, 30)],\n    [(15, 0), (16, 30)]\n]\npatricia_schedule = [\n    [(9, 30), (10, 30)],\n    [(11, 0), (12, 0)],\n    [(12, 30), (14, 0)],\n    [(15, 0), (16, 30)]\n]\n\nparticipants_schedules = [diane_schedule, jack_schedule, eugene_schedule, patricia_schedule]\nday = \"Monday\"\nwork_hours_start = (9, 0)\nwork_hours_end = (17, 0)\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, day, work_hours_start, work_hours_end, duration_minutes)\n\n# Output the result\nprint(f\"{meeting_time}:{day}\")\n```",
            "count": "calendar_scheduling_example_103"
        },
        {
            "final_program_time": {
                "day": "Wednesday",
                "start_time": "15:30",
                "end_time": "16:30"
            },
            "expected_time": {
                "day": "Wednesday",
                "start_time": "15:30",
                "end_time": "16:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    meeting_duration = 60  # minutes\n\n    # Define blocked times for each participant per day in minutes since midnight\n    martha_blocked = {\n        'Monday': [(16 * 60, 17 * 60)],\n        'Tuesday': [(15 * 60, 15 * 60 + 30)],\n        'Wednesday': [(10 * 60, 11 * 60), (14 * 60, 14 * 60 + 30)]\n    }\n\n    beverly_blocked = {\n        'Monday': [(9 * 60, 13 * 60 + 30), (14 * 60, 17 * 60)],\n        'Tuesday': [(9 * 60, 17 * 60)],\n        'Wednesday': [(9 * 60 + 30, 15 * 60 + 30), (16 * 60 + 30, 17 * 60)]\n    }\n\n    # Iterate through each day to find a suitable time slot\n    for day in days:\n        # Collect all blocked times for both participants\n        blocked_times = martha_blocked.get(day, []) + beverly_blocked.get(day, [])\n        blocked_times.sort()  # Sort by start time\n\n        # Check available slots between work hours\n        current_time = work_start\n        for block_start, block_end in blocked_times:\n            if current_time + meeting_duration <= block_start:\n                # Found a suitable slot\n                start_h = current_time // 60\n                start_m = current_time % 60\n                end_h = (current_time + meeting_duration) // 60\n                end_m = (current_time + meeting_duration) % 60\n                return day, f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n            # Update current_time to the end of the current block if it's later\n            if block_end > current_time:\n                current_time = block_end\n        # Check after the last block\n        if current_time + meeting_duration <= work_end:\n            start_h = current_time // 60\n            start_m = current_time % 60\n            end_h = (current_time + meeting_duration) // 60\n            end_m = (current_time + meeting_duration) % 60\n            return day, f\"{start_h:02d}:{start_m:02d}:{end_h:02d}:{end_m:02d}\"\n\n    return \"No suitable time found\", \"\"\n\n# Execute the function and print the result\nday, time_slot = find_meeting_time()\nprint(f\"{day}: {time_slot}\")\n```",
            "count": "calendar_scheduling_example_767"
        },
        {
            "final_program_time": {
                "day": null,
                "start_time": null,
                "end_time": null
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "11:00",
                "end_time": "11:30"
            },
            "has_error": true,
            "raw_model_response": "```python\ndef find_meeting_time(participants_schedules, day, work_start, work_end, duration_minutes):\n    # Convert time strings to minutes since 9:00 (540 minutes)\n    def time_to_minutes(time_str):\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    work_start_min = time_to_minutes(work_start)\n    work_end_min = time_to_minutes(work_end)\n    \n    # Initialize a list to track busy intervals for all participants\n    all_busy_intervals = []\n    \n    for schedule in participants_schedules:\n        for interval in schedule:\n            start, end = map(time_to_minutes, interval.split(' to '))\n            all_busy_intervals.append((start, end))\n    \n    # Sort all busy intervals by start time\n    all_busy_intervals.sort()\n    \n    # Find the earliest available slot\n    current_time = work_start_min\n    for start, end in all_busy_intervals:\n        if start > current_time and start - current_time >= duration_minutes:\n            # Found a slot\n            meeting_start = current_time\n            meeting_end = meeting_start + duration_minutes\n            # Convert back to HH:MM format\n            def minutes_to_time(minutes):\n                hh = minutes // 60\n                mm = minutes % 60\n                return f\"{hh:02d}:{mm:02d}\"\n            return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n        current_time = max(current_time, end)\n    \n    # Check after the last busy interval\n    if work_end_min - current_time >= duration_minutes:\n        meeting_start = current_time\n        meeting_end = meeting_start + duration_minutes\n        def minutes_to_time(minutes):\n            hh = minutes // 60\n            mm = minutes % 60\n            return f\"{hh:02d}:{mm:02d}\"\n        return f\"{minutes_to_time(meeting_start)}:{minutes_to_time(meeting_end)}\"\n    \n    return None\n\n# Define participants' schedules\nparticipants_schedules = [\n    [\"11:30 to 12:00\", \"14:30 to 15:00\"],  # Joan\n    [\"9:00 to 10:00\", \"14:00 to 14:30\", \"16:00 to 16:30\"],  # Megan\n    [],  # Austin\n    [\"9:30 to 10:00\", \"11:30 to 12:00\", \"13:30 to 14:00\", \"16:00 to 16:30\"],  # Betty\n    [\"9:00 to 11:00\", \"12:00 to 13:00\", \"14:00 to 15:00\"],  # Judith\n    [\"9:30 to 10:00\", \"11:30 to 12:30\", \"13:00 to 14:00\", \"15:00 to 15:30\", \"16:00 to 17:00\"],  # Terry\n    [\"9:30 to 10:00\", \"10:30 to 11:00\", \"11:30 to 13:00\", \"14:00 to 16:00\", \"16:30 to 17:00\"],  # Kathryn\n]\n\nday = \"Monday\"\nwork_start = \"9:00\"\nwork_end = \"17:00\"\nduration_minutes = 30\n\n# Find the meeting time\nmeeting_time = find_meeting_time(participants_schedules, day, work_start, work_end, duration_minutes)\n\nif meeting_time:\n    start, end = meeting_time.split(':')\n    print(f\"{{{start}:{end}}} {day}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_441"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "13:00",
                "end_time": "14:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "13:00",
                "end_time": "14:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time(gary_schedule, david_schedule, work_hours_start, work_hours_end, meeting_duration, days):\n    for day in days:\n        # Initialize available time for the day\n        available_start = work_hours_start\n        available_end = work_hours_end\n        \n        # Get blocked times for Gary and David on the current day\n        gary_blocked = gary_schedule.get(day, [])\n        david_blocked = david_schedule.get(day, [])\n        \n        # Combine and sort all blocked times\n        all_blocked = gary_blocked + david_blocked\n        all_blocked.sort()\n        \n        # Merge overlapping or adjacent blocked times\n        merged_blocked = []\n        for start, end in all_blocked:\n            if not merged_blocked:\n                merged_blocked.append((start, end))\n            else:\n                last_start, last_end = merged_blocked[-1]\n                if start <= last_end:\n                    # Overlapping or adjacent, merge them\n                    new_start = min(last_start, start)\n                    new_end = max(last_end, end)\n                    merged_blocked[-1] = (new_start, new_end)\n                else:\n                    merged_blocked.append((start, end))\n        \n        # Find available slots\n        current_time = available_start\n        for start, end in merged_blocked:\n            if current_time < start:\n                # Check if the slot is long enough\n                if (start - current_time) >= meeting_duration:\n                    return day, (current_time, current_time + meeting_duration)\n            current_time = max(current_time, end)\n        \n        # Check the remaining time after the last blocked slot\n        if (available_end - current_time) >= meeting_duration:\n            return day, (current_time, current_time + meeting_duration)\n    \n    return None, None\n\n# Define work hours and meeting duration\nwork_hours_start = 9.0  # 9:00\nwork_hours_end = 17.0    # 17:00\nmeeting_duration = 1.0   # 1 hour\n\n# Define schedules\ngary_schedule = {\n    'Monday': [(9.5, 10.0), (11.0, 13.0), (14.0, 14.5), (16.5, 17.0)],\n    'Tuesday': [(9.0, 9.5), (10.5, 11.0), (14.5, 16.0)]\n}\n\ndavid_schedule = {\n    'Monday': [(9.0, 9.5), (10.0, 13.0), (14.5, 16.5)],\n    'Tuesday': [(9.0, 9.5), (10.0, 10.5), (11.0, 12.5), (13.0, 14.5), (15.0, 16.0), (16.5, 17.0)]\n}\n\n# Days to consider\ndays = ['Monday', 'Tuesday']\n\n# Find meeting time\nday, time_slot = find_meeting_time(gary_schedule, david_schedule, work_hours_start, work_hours_end, meeting_duration, days)\n\nif day and time_slot:\n    start_hour = int(time_slot[0])\n    start_min = int((time_slot[0] - start_hour) * 60)\n    end_hour = int(time_slot[1])\n    end_min = int((time_slot[1] - end_hour) * 60)\n    print(f\"{day}: {start_hour:02d}:{start_min:02d}:{end_hour:02d}:{end_min:02d}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_662"
        },
        {
            "final_program_time": {
                "day": "Tuesday",
                "start_time": "9:30",
                "end_time": "10:30"
            },
            "expected_time": {
                "day": "Tuesday",
                "start_time": "9:30",
                "end_time": "10:30"
            },
            "has_error": false,
            "raw_model_response": "```python\nfrom typing import List, Dict, Tuple\n\ndef find_meeting_time(\n    participants: List[str],\n    schedules: Dict[str, Dict[str, List[Tuple[str, str]]]],\n    preferences: Dict[str, Dict[str, str]],\n    work_hours: Tuple[str, str],\n    meeting_duration: int,\n    days: List[str]\n) -> Tuple[str, Tuple[str, str]]:\n    \"\"\"\n    Find a meeting time that fits all participants' schedules and constraints.\n    \n    Args:\n        participants: List of participant names.\n        schedules: Dictionary with participant names as keys and their schedules as values.\n                  Schedules are dictionaries with days as keys and list of (start, end) time tuples as values.\n        preferences: Dictionary with participant names as keys and their preferences as values.\n                    Preferences are dictionaries with keys like \"avoid_day\" or \"cannot_meet_after\".\n        work_hours: Tuple of (start, end) time for work hours.\n        meeting_duration: Duration of the meeting in minutes.\n        days: List of days to consider for the meeting.\n    \n    Returns:\n        Tuple of (day, (start_time, end_time)) if a slot is found, otherwise (None, (None, None)).\n    \"\"\"\n    # Convert all time strings to minutes since midnight for easier calculations\n    def time_to_minutes(time_str: str) -> int:\n        hh, mm = map(int, time_str.split(':'))\n        return hh * 60 + mm\n    \n    def minutes_to_time(minutes: int) -> str:\n        hh = minutes // 60\n        mm = minutes % 60\n        return f\"{hh:02d}:{mm:02d}\"\n    \n    work_start, work_end = map(time_to_minutes, work_hours)\n    duration_minutes = meeting_duration\n    \n    for day in days:\n        # Check if day is avoided by any participant\n        avoid_day = False\n        for participant in participants:\n            if preferences.get(participant, {}).get(\"avoid_day\") == day:\n                avoid_day = True\n                break\n        if avoid_day:\n            continue\n        \n        # Collect all busy intervals for the day\n        busy_intervals = []\n        for participant in participants:\n            for interval in schedules[participant].get(day, []):\n                start, end = map(time_to_minutes, interval)\n                busy_intervals.append((start, end))\n        \n        # Also add constraints like \"cannot meet after\"\n        for participant in participants:\n            cannot_meet_after = preferences.get(participant, {}).get(\"cannot_meet_after\")\n            if cannot_meet_after and day in preferences.get(participant, {}).get(\"cannot_meet_after_day\", day):\n                cutoff = time_to_minutes(cannot_meet_after)\n                busy_intervals.append((cutoff, work_end))\n        \n        # Sort intervals by start time\n        busy_intervals.sort()\n        \n        # Find free slots\n        prev_end = work_start\n        free_slots = []\n        for start, end in busy_intervals:\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        if prev_end < work_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check if any free slot can fit the meeting\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= duration_minutes:\n                meeting_start = slot_start\n                meeting_end = meeting_start + duration_minutes\n                return (day, (minutes_to_time(meeting_start), minutes_to_time(meeting_end)))\n    \n    return (None, (None, None))\n\n# Define the problem\nparticipants = [\"Stephanie\", \"Betty\"]\nschedules = {\n    \"Stephanie\": {\n        \"Monday\": [(\"9:30\", \"10:00\"), (\"10:30\", \"11:00\"), (\"11:30\", \"12:00\"), (\"14:00\", \"14:30\")],\n        \"Tuesday\": [(\"12:00\", \"13:00\")],\n        \"Wednesday\": [(\"9:00\", \"10:00\"), (\"13:00\", \"14:00\")],\n    },\n    \"Betty\": {\n        \"Monday\": [(\"9:00\", \"10:00\"), (\"11:00\", \"11:30\"), (\"14:30\", \"15:00\"), (\"15:30\", \"16:00\")],\n        \"Tuesday\": [(\"9:00\", \"9:30\"), (\"11:30\", \"12:00\"), (\"12:30\", \"14:30\"), (\"15:30\", \"16:00\")],\n        \"Wednesday\": [(\"10:00\", \"11:30\"), (\"12:00\", \"14:00\"), (\"14:30\", \"17:00\")],\n    },\n}\npreferences = {\n    \"Stephanie\": {\"avoid_day\": \"Monday\"},\n    \"Betty\": {\"cannot_meet_after\": \"12:30\", \"cannot_meet_after_day\": \"Tuesday\"},\n}\nwork_hours = (\"9:00\", \"17:00\")\nmeeting_duration = 60  # minutes\ndays = [\"Monday\", \"Tuesday\", \"Wednesday\"]\n\n# Find the meeting time\nday, (start_time, end_time) = find_meeting_time(participants, schedules, preferences, work_hours, meeting_duration, days)\n\n# Output the result\nif day:\n    print(f\"{day}:{start_time}:{end_time}\")\nelse:\n    print(\"No suitable time found.\")\n```",
            "count": "calendar_scheduling_example_703"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "9:30",
                "end_time": "10:00"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "9:30",
                "end_time": "10:00"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60    # 17:00 in minutes\n    meeting_duration = 30  # minutes\n\n    # Define days to consider (excluding Wednesday and Thursday per Cheryl's preference)\n    days = [\"Monday\", \"Tuesday\"]\n\n    # James's schedule: each day is a list of busy time slots in minutes since midnight\n    james_schedule = {\n        \"Monday\": [\n            (9 * 60, 9 * 60 + 30),    # 9:00-9:30\n            (10 * 60 + 30, 11 * 60),  # 10:30-11:00\n            (12 * 60 + 30, 13 * 60),  # 12:30-13:00\n            (14 * 60 + 30, 15 * 60 + 30),  # 14:30-15:30\n            (16 * 60 + 30, 17 * 60),  # 16:30-17:00\n        ],\n        \"Tuesday\": [\n            (9 * 60, 11 * 60),        # 9:00-11:00\n            (11 * 60 + 30, 12 * 60),  # 11:30-12:00\n            (12 * 60 + 30, 15 * 60 + 30),  # 12:30-15:30\n            (16 * 60, 17 * 60),      # 16:00-17:00\n        ],\n    }\n\n    # Cheryl's schedule is wide open, so only need to check James's schedule\n\n    # Iterate through days in order (Monday, Tuesday)\n    for day in days:\n        busy_slots = james_schedule.get(day, [])\n        # Add boundaries of work hours\n        busy_slots.append((work_end, work_end))  # dummy slot to simplify loop\n\n        # Start checking from the beginning of the work day\n        prev_end = work_start\n        for start, end in busy_slots:\n            if start - prev_end >= meeting_duration:\n                # Found a suitable slot\n                meeting_start = prev_end\n                meeting_end = meeting_start + meeting_duration\n                # Format the time as HH:MM:HH:MM\n                start_hh = meeting_start // 60\n                start_mm = meeting_start % 60\n                end_hh = meeting_end // 60\n                end_mm = meeting_end % 60\n                time_str = f\"{start_hh:02d}:{start_mm:02d}:{end_hh:02d}:{end_mm:02d}\"\n                print(f\"{day}: {time_str}\")\n                return\n            prev_end = max(prev_end, end)\n\n    print(\"No suitable time found.\")\n\nfind_meeting_time()\n```",
            "count": "calendar_scheduling_example_826"
        },
        {
            "final_program_time": {
                "day": "Monday",
                "start_time": "9:00",
                "end_time": "9:30"
            },
            "expected_time": {
                "day": "Monday",
                "start_time": "9:00",
                "end_time": "9:30"
            },
            "has_error": false,
            "raw_model_response": "```python\ndef find_meeting_time():\n    # Define work hours and days to consider\n    work_start = 9 * 60  # 9:00 in minutes\n    work_end = 17 * 60   # 17:00 in minutes\n    days = ['Monday', 'Tuesday', 'Wednesday']\n    \n    # Samuel's busy times in minutes since midnight for each day\n    samuel_busy = {\n        'Monday': [(10*60 + 30, 11*60), (12*60, 12*60 + 30), (13*60, 15*60), (15*60 + 30, 16*60 + 30)],\n        'Tuesday': [(9*60, 12*60), (14*60, 15*60 + 30), (16*60 + 30, 17*60)],\n        'Wednesday': [(10*60 + 30, 11*60), (11*60 + 30, 12*60), (12*60 + 30, 13*60), (14*60, 14*60 + 30), (15*60, 16*60)]\n    }\n    \n    # Larry's preferences: avoid Wednesday\n    # Samuel's preferences: avoid Tuesday\n    preferred_days = ['Monday', 'Tuesday']  # Wednesday is last resort\n    \n    # Duration in minutes\n    duration = 30\n    \n    # Iterate through days in order of preference\n    for day in preferred_days + ['Wednesday']:\n        if day == 'Tuesday' and day in preferred_days:\n            continue  # Skip Tuesday as Samuel prefers to avoid it\n        \n        # Get Samuel's busy times for the day\n        busy_times = samuel_busy.get(day, [])\n        \n        # Find all free slots in Samuel's schedule\n        free_slots = []\n        prev_end = work_start\n        \n        for start, end in sorted(busy_times):\n            if start > prev_end:\n                free_slots.append((prev_end, start))\n            prev_end = max(prev_end, end)\n        \n        if work_end > prev_end:\n            free_slots.append((prev_end, work_end))\n        \n        # Check each free slot for availability\n        for slot_start, slot_end in free_slots:\n            if slot_end - slot_start >= duration:\n                # Found a suitable slot\n                start_time = slot_start\n                end_time = start_time + duration\n                \n                # Convert times back to HH:MM format\n                def format_time(minutes):\n                    hours = minutes // 60\n                    mins = minutes % 60\n                    return f\"{hours:02d}:{mins:02d}\"\n                \n                time_range = f\"{format_time(start_time)}:{format_time(end_time)}\"\n                return day, time_range\n    \n    # Fallback (shouldn't reach here as per problem statement)\n    return None, None\n\nday, time_range = find_meeting_time()\nprint(f\"{day}: {time_range}\")\n```",
            "count": "calendar_scheduling_example_704"
        }
    ]
}